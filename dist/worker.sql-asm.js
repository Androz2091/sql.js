
// We are modularizing this manually because the current modularize setting in Emscripten has some issues:
// https://github.com/kripken/emscripten/issues/5820
// In addition, When you use emcc's modularization, it still expects to export a global object called `Module`,
// which is able to be used/called before the WASM is loaded.
// The modularization below exports a promise that loads and resolves to the actual sql.js module.
// That way, this module can't be used before the WASM is finished loading.

// We are going to define a function that a user will call to start loading initializing our Sql.js library
// However, that function might be called multiple times, and on subsequent calls, we don't actually want it to instantiate a new instance of the Module
// Instead, we want to return the previously loaded module

// TODO: Make this not declare a global if used in the browser
var initSqlJsPromise = undefined;

var initSqlJs = function (moduleConfig) {

    if (initSqlJsPromise){
      return initSqlJsPromise;
    }
    // If we're here, we've never called this function before
    initSqlJsPromise = new Promise(function (resolveModule, reject) {

        // We are modularizing this manually because the current modularize setting in Emscripten has some issues:
        // https://github.com/kripken/emscripten/issues/5820

        // The way to affect the loading of emcc compiled modules is to create a variable called `Module` and add
        // properties to it, like `preRun`, `postRun`, etc
        // We are using that to get notified when the WASM has finished loading.
        // Only then will we return our promise

        // If they passed in a moduleConfig object, use that
        // Otherwise, initialize Module to the empty object
        var Module = typeof moduleConfig !== 'undefined' ? moduleConfig : {};

        // EMCC only allows for a single onAbort function (not an array of functions)
        // So if the user defined their own onAbort function, we remember it and call it
        var originalOnAbortFunction = Module['onAbort'];
        Module['onAbort'] = function (errorThatCausedAbort) {
            reject(new Error(errorThatCausedAbort));
            if (originalOnAbortFunction){
              originalOnAbortFunction(errorThatCausedAbort);
            }
        };

        Module['postRun'] = Module['postRun'] || [];
        Module['postRun'].push(function () {
            // When Emscripted calls postRun, this promise resolves with the built Module
            resolveModule(Module);
        });

        // There is a section of code in the emcc-generated code below that looks like this:
        // (Note that this is lowercase `module`)
        // if (typeof module !== 'undefined') {
        //     module['exports'] = Module;
        // }
        // When that runs, it's going to overwrite our own modularization export efforts in shell-post.js!
        // The only way to tell emcc not to emit it is to pass the MODULARIZE=1 or MODULARIZE_INSTANCE=1 flags,
        // but that carries with it additional unnecessary baggage/bugs we don't want either.
        // So, we have three options:
        // 1) We undefine `module`
        // 2) We remember what `module['exports']` was at the beginning of this function and we restore it later
        // 3) We write a script to remove those lines of code as part of the Make process.
        //
        // Since those are the only lines of code that care about module, we will undefine it. It's the most straightforward
        // of the options, and has the side effect of reducing emcc's efforts to modify the module if its output were to change in the future.
        // That's a nice side effect since we're handling the modularization efforts ourselves
        module = undefined;

        // The emcc-generated code and shell-post.js code goes below,
        // meaning that all of it runs inside of this promise. If anything throws an exception, our promise will abort


// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// See https://caniuse.com/mdn-javascript_builtins_object_assign

// See https://caniuse.com/mdn-javascript_builtins_bigint64array

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
/* global
    ALLOC_NORMAL
    FS
    HEAP8
    Module
    _malloc
    _free
    addFunction
    allocate
    allocateUTF8OnStack
    getValue
    intArrayFromString
    removeFunction
    setValue
    stackAlloc
    stackRestore
    stackSave
    UTF8ToString
    stringToUTF8
    lengthBytesUTF8
*/

"use strict";

/**
 * @typedef {{Database:Database, Statement:Statement}} SqlJs
 * @property {Database} Database A class that represents an SQLite database
 * @property {Statement} Statement The prepared statement class
 */

/**
 * @typedef {{locateFile:function(string):string}} SqlJsConfig
 * @property {function(string):string} locateFile
 * a function that returns the full path to a resource given its file name
 * @see https://emscripten.org/docs/api_reference/module.html
 */

/**
 * Asynchronously initializes sql.js
 * @function initSqlJs
 * @param {SqlJsConfig} config module inititialization parameters
 * @returns {SqlJs}
 * @example
 * initSqlJs({
 *  locateFile: name => '/path/to/assets/' + name
 * }).then(SQL => {
 *  const db = new SQL.Database();
 *  const result = db.exec("select 'hello world'");
 *  console.log(result);
 * })
 */

/**
 * @module SqlJs
 */
// Wait for preRun to run, and then finish our initialization
Module["onRuntimeInitialized"] = function onRuntimeInitialized() {
    // Declare toplevel variables
    // register, used for temporary stack values
    var apiTemp = stackAlloc(4);
    var cwrap = Module["cwrap"];
    // Null pointer
    var NULL = 0;
    // SQLite enum
    var SQLITE_OK = 0;
    var SQLITE_ROW = 100;
    var SQLITE_DONE = 101;
    var SQLITE_INTEGER = 1;
    var SQLITE_FLOAT = 2;
    var SQLITE_TEXT = 3;
    var SQLITE_BLOB = 4;
    // var - Encodings, used for registering functions.
    var SQLITE_UTF8 = 1;
    // var - cwrap function
    var sqlite3_open = cwrap("sqlite3_open", "number", ["string", "number"]);
    var sqlite3_close_v2 = cwrap("sqlite3_close_v2", "number", ["number"]);
    var sqlite3_exec = cwrap(
        "sqlite3_exec",
        "number",
        ["number", "string", "number", "number", "number"]
    );
    var sqlite3_changes = cwrap("sqlite3_changes", "number", ["number"]);
    var sqlite3_prepare_v2 = cwrap(
        "sqlite3_prepare_v2",
        "number",
        ["number", "string", "number", "number", "number"]
    );
    var sqlite3_sql = cwrap("sqlite3_sql", "string", ["number"]);
    var sqlite3_normalized_sql = cwrap(
        "sqlite3_normalized_sql",
        "string",
        ["number"]
    );
    var sqlite3_prepare_v2_sqlptr = cwrap(
        "sqlite3_prepare_v2",
        "number",
        ["number", "number", "number", "number", "number"]
    );
    var sqlite3_bind_text = cwrap(
        "sqlite3_bind_text",
        "number",
        ["number", "number", "number", "number", "number"]
    );
    var sqlite3_bind_blob = cwrap(
        "sqlite3_bind_blob",
        "number",
        ["number", "number", "number", "number", "number"]
    );
    var sqlite3_bind_double = cwrap(
        "sqlite3_bind_double",
        "number",
        ["number", "number", "number"]
    );
    var sqlite3_bind_int = cwrap(
        "sqlite3_bind_int",
        "number",
        ["number", "number", "number"]
    );

    var sqlite3_bind_parameter_index = cwrap(
        "sqlite3_bind_parameter_index",
        "number",
        ["number", "string"]
    );
    var sqlite3_step = cwrap("sqlite3_step", "number", ["number"]);
    var sqlite3_errmsg = cwrap("sqlite3_errmsg", "string", ["number"]);
    var sqlite3_column_count = cwrap(
        "sqlite3_column_count",
        "number",
        ["number"]
    );
    var sqlite3_data_count = cwrap("sqlite3_data_count", "number", ["number"]);
    var sqlite3_column_double = cwrap(
        "sqlite3_column_double",
        "number",
        ["number", "number"]
    );
    var sqlite3_column_text = cwrap(
        "sqlite3_column_text",
        "string",
        ["number", "number"]
    );
    var sqlite3_column_blob = cwrap(
        "sqlite3_column_blob",
        "number",
        ["number", "number"]
    );
    var sqlite3_column_bytes = cwrap(
        "sqlite3_column_bytes",
        "number",
        ["number", "number"]
    );
    var sqlite3_column_type = cwrap(
        "sqlite3_column_type",
        "number",
        ["number", "number"]
    );
    var sqlite3_column_name = cwrap(
        "sqlite3_column_name",
        "string",
        ["number", "number"]
    );
    var sqlite3_reset = cwrap("sqlite3_reset", "number", ["number"]);
    var sqlite3_clear_bindings = cwrap(
        "sqlite3_clear_bindings",
        "number",
        ["number"]
    );
    var sqlite3_finalize = cwrap("sqlite3_finalize", "number", ["number"]);
    var sqlite3_create_function_v2 = cwrap(
        "sqlite3_create_function_v2",
        "number",
        [
            "number",
            "string",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number",
            "number"
        ]
    );
    var sqlite3_value_type = cwrap("sqlite3_value_type", "number", ["number"]);
    var sqlite3_value_bytes = cwrap(
        "sqlite3_value_bytes",
        "number",
        ["number"]
    );
    var sqlite3_value_text = cwrap("sqlite3_value_text", "string", ["number"]);
    var sqlite3_value_blob = cwrap("sqlite3_value_blob", "number", ["number"]);
    var sqlite3_value_double = cwrap(
        "sqlite3_value_double",
        "number",
        ["number"]
    );
    var sqlite3_result_double = cwrap(
        "sqlite3_result_double",
        "",
        ["number", "number"]
    );
    var sqlite3_result_null = cwrap(
        "sqlite3_result_null",
        "",
        ["number"]
    );
    var sqlite3_result_text = cwrap(
        "sqlite3_result_text",
        "",
        ["number", "string", "number", "number"]
    );
    var sqlite3_result_blob = cwrap(
        "sqlite3_result_blob",
        "",
        ["number", "number", "number", "number"]
    );
    var sqlite3_result_int = cwrap(
        "sqlite3_result_int",
        "",
        ["number", "number"]
    );
    var sqlite3_result_error = cwrap(
        "sqlite3_result_error",
        "",
        ["number", "string", "number"]
    );

    // https://www.sqlite.org/c3ref/aggregate_context.html
    // void *sqlite3_aggregate_context(sqlite3_context*, int nBytes)
    var sqlite3_aggregate_context = cwrap(
        "sqlite3_aggregate_context",
        "number",
        ["number", "number"]
    );
    var registerExtensionFunctions = cwrap(
        "RegisterExtensionFunctions",
        "number",
        ["number"]
    );

    var sqlite3_series_init = cwrap(
        "sqlite3_series_init",
        "number",
        ["number", "number", "number"]
    );

    /**
    * @classdesc
    * Represents a prepared statement.
    * Prepared statements allow you to have a template sql string,
    * that you can execute multiple times with different parameters.
    *
    * You can't instantiate this class directly, you have to use a
    * {@link Database} object in order to create a statement.
    *
    * **Warnings**
    * 1. When you close a database (using db.close()), all
    * its statements are closed too and become unusable.
    * 1. After calling db.prepare() you must manually free the assigned memory
    * by calling Statement.free(). Failure to do this will cause subsequent
    * 'DROP TABLE ...' statements to fail with 'Uncaught Error: database table
    * is locked'.
    *
    * Statements can't be created by the API user directly, only by
    * Database::prepare
    *
    * @see Database.html#prepare-dynamic
    * @see https://en.wikipedia.org/wiki/Prepared_statement
    *
    * @constructs Statement
    * @memberof module:SqlJs
    * @param {number} stmt1 The SQLite statement reference
    * @param {Database} db The database from which this statement was created
     */
    function Statement(stmt1, db) {
        this.stmt = stmt1;
        this.db = db;
        // Index of the leftmost parameter is 1
        this.pos = 1;
        // Pointers to allocated memory, that need to be freed
        // when the statemend is destroyed
        this.allocatedmem = [];
    }

    /** @typedef {string|number|null|Uint8Array} Database.SqlValue */
    /** @typedef {
        Database.SqlValue[]|Object<string, Database.SqlValue>|null
    } Statement.BindParams
     */

    /** Bind values to the parameters, after having reseted the statement.
    * If values is null, do nothing and return true.
    *
    * SQL statements can have parameters,
    * named *'?', '?NNN', ':VVV', '@VVV', '$VVV'*,
    * where NNN is a number and VVV a string.
    * This function binds these parameters to the given values.
    *
    * *Warning*: ':', '@', and '$' are included in the parameters names
    *
    * ## Value types
    * Javascript type  | SQLite type
    * -----------------| -----------
    * number           | REAL, INTEGER
    * boolean          | INTEGER
    * string           | TEXT
    * Array, Uint8Array| BLOB
    * null             | NULL
    *
    * @example <caption>Bind values to named parameters</caption>
    *     var stmt = db.prepare(
    *         "UPDATE test SET a=@newval WHERE id BETWEEN $mini AND $maxi"
    *     );
    *     stmt.bind({$mini:10, $maxi:20, '@newval':5});
    *
    * @example <caption>Bind values to anonymous parameters</caption>
    * // Create a statement that contains parameters like '?', '?NNN'
    * var stmt = db.prepare("UPDATE test SET a=? WHERE id BETWEEN ? AND ?");
    * // Call Statement.bind with an array as parameter
    * stmt.bind([5, 10, 20]);
    *
    * @see http://www.sqlite.org/datatype3.html
    * @see http://www.sqlite.org/lang_expr.html#varparam

    * @param {Statement.BindParams} values The values to bind
    * @return {boolean} true if it worked
    * @throws {String} SQLite Error
    */
    Statement.prototype["bind"] = function bind(values) {
        if (!this.stmt) {
            throw "Statement closed";
        }
        this["reset"]();
        if (Array.isArray(values)) return this.bindFromArray(values);
        if (values != null && typeof values === "object") {
            return this.bindFromObject(values);
        }
        return true;
    };

    /** Execute the statement, fetching the the next line of result,
    that can be retrieved with {@link Statement.get}.

    @return {boolean} true if a row of result available
    @throws {String} SQLite Error
     */
    Statement.prototype["step"] = function step() {
        if (!this.stmt) {
            throw "Statement closed";
        }
        this.pos = 1;
        var ret = sqlite3_step(this.stmt);
        switch (ret) {
            case SQLITE_ROW:
                return true;
            case SQLITE_DONE:
                return false;
            default:
                throw this.db.handleError(ret);
        }
    };

    /*
    Internal methods to retrieve data from the results of a statement
    that has been executed
     */
    Statement.prototype.getNumber = function getNumber(pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        return sqlite3_column_double(this.stmt, pos);
    };

    Statement.prototype.getBigInt = function getBigInt(pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        var text = sqlite3_column_text(this.stmt, pos);
        if (typeof BigInt !== "function") {
            throw new Error("BigInt is not supported");
        }
        /* global BigInt */
        return BigInt(text);
    };

    Statement.prototype.getString = function getString(pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        return sqlite3_column_text(this.stmt, pos);
    };

    Statement.prototype.getBlob = function getBlob(pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        var size = sqlite3_column_bytes(this.stmt, pos);
        var ptr = sqlite3_column_blob(this.stmt, pos);
        var result = new Uint8Array(size);
        for (var i = 0; i < size; i += 1) {
            result[i] = HEAP8[ptr + i];
        }
        return result;
    };

    /** Get one row of results of a statement.
    If the first parameter is not provided, step must have been called before.
    @param {Statement.BindParams} [params] If set, the values will be bound
    to the statement before it is executed
    @return {Database.SqlValue[]} One row of result

    @example
    <caption>Print all the rows of the table test to the console</caption>
    var stmt = db.prepare("SELECT * FROM test");
    while (stmt.step()) console.log(stmt.get());

    <caption>Enable BigInt support</caption>
    var stmt = db.prepare("SELECT * FROM test");
    while (stmt.step()) console.log(stmt.get(null, {useBigInt: true}));
     */
    Statement.prototype["get"] = function get(params, config) {
        config = config || {};
        if (params != null && this["bind"](params)) {
            this["step"]();
        }
        var results1 = [];
        var ref = sqlite3_data_count(this.stmt);
        for (var field = 0; field < ref; field += 1) {
            switch (sqlite3_column_type(this.stmt, field)) {
                case SQLITE_INTEGER:
                    var getfunc = config["useBigInt"]
                        ? this.getBigInt(field)
                        : this.getNumber(field);
                    results1.push(getfunc);
                    break;
                case SQLITE_FLOAT:
                    results1.push(this.getNumber(field));
                    break;
                case SQLITE_TEXT:
                    results1.push(this.getString(field));
                    break;
                case SQLITE_BLOB:
                    results1.push(this.getBlob(field));
                    break;
                default:
                    results1.push(null);
            }
        }
        return results1;
    };

    /** Get the list of column names of a row of result of a statement.
    @return {string[]} The names of the columns
    @example
    var stmt = db.prepare(
        "SELECT 5 AS nbr, x'616200' AS data, NULL AS null_value;"
    );
    stmt.step(); // Execute the statement
    console.log(stmt.getColumnNames());
    // Will print ['nbr','data','null_value']
     */
    Statement.prototype["getColumnNames"] = function getColumnNames() {
        var results1 = [];
        var ref = sqlite3_column_count(this.stmt);
        for (var i = 0; i < ref; i += 1) {
            results1.push(sqlite3_column_name(this.stmt, i));
        }
        return results1;
    };

    /** Get one row of result as a javascript object, associating column names
    with their value in the current row.
    @param {Statement.BindParams} [params] If set, the values will be bound
    to the statement, and it will be executed
    @return {Object<string, Database.SqlValue>} The row of result
    @see {@link Statement.get}

    @example

        var stmt = db.prepare(
            "SELECT 5 AS nbr, x'010203' AS data, NULL AS null_value;"
        );
        stmt.step(); // Execute the statement
        console.log(stmt.getAsObject());
        // Will print {nbr:5, data: Uint8Array([1,2,3]), null_value:null}
     */
    Statement.prototype["getAsObject"] = function getAsObject(params, config) {
        var values = this["get"](params, config);
        var names = this["getColumnNames"]();
        var rowObject = {};
        for (var i = 0; i < names.length; i += 1) {
            var name = names[i];
            rowObject[name] = values[i];
        }
        return rowObject;
    };

    /** Get the SQL string used in preparing this statement.
     @return {string} The SQL string
     */
    Statement.prototype["getSQL"] = function getSQL() {
        return sqlite3_sql(this.stmt);
    };

    /** Get the SQLite's normalized version of the SQL string used in
    preparing this statement.  The meaning of "normalized" is not
    well-defined: see {@link https://sqlite.org/c3ref/expanded_sql.html
    the SQLite documentation}.

     @example
     db.run("create table test (x integer);");
     stmt = db.prepare("select * from test where x = 42");
     // returns "SELECT*FROM test WHERE x=?;"

     @return {string} The normalized SQL string
     */
    Statement.prototype["getNormalizedSQL"] = function getNormalizedSQL() {
        return sqlite3_normalized_sql(this.stmt);
    };

    /** Shorthand for bind + step + reset
    Bind the values, execute the statement, ignoring the rows it returns,
    and resets it
    @param {Statement.BindParams} [values] Value to bind to the statement
     */
    Statement.prototype["run"] = function run(values) {
        if (values != null) {
            this["bind"](values);
        }
        this["step"]();
        return this["reset"]();
    };

    Statement.prototype.bindString = function bindString(string, pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        var bytes = intArrayFromString(string);
        var strptr = allocate(bytes, ALLOC_NORMAL);
        this.allocatedmem.push(strptr);
        this.db.handleError(sqlite3_bind_text(
            this.stmt,
            pos,
            strptr,
            bytes.length - 1,
            0
        ));
        return true;
    };

    Statement.prototype.bindBlob = function bindBlob(array, pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        var blobptr = allocate(array, ALLOC_NORMAL);
        this.allocatedmem.push(blobptr);
        this.db.handleError(sqlite3_bind_blob(
            this.stmt,
            pos,
            blobptr,
            array.length,
            0
        ));
        return true;
    };

    Statement.prototype.bindNumber = function bindNumber(num, pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        var bindfunc = (
            num === (num | 0)
                ? sqlite3_bind_int
                : sqlite3_bind_double
        );
        this.db.handleError(bindfunc(this.stmt, pos, num));
        return true;
    };

    Statement.prototype.bindNull = function bindNull(pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }
        return sqlite3_bind_blob(this.stmt, pos, 0, 0, 0) === SQLITE_OK;
    };

    Statement.prototype.bindValue = function bindValue(val, pos) {
        if (pos == null) {
            pos = this.pos;
            this.pos += 1;
        }

        switch (typeof val) {
            case "string":
                return this.bindString(val, pos);
            case "number":
                return this.bindNumber(val + 0, pos);
            case "bigint":
                // BigInt is not fully supported yet at WASM level.
                return this.bindString(val.toString(), pos);
            case "boolean":
                return this.bindNumber(val + 0, pos);
            case "object":
                if (val === null) {
                    return this.bindNull(pos);
                }
                if (val.length != null) {
                    return this.bindBlob(val, pos);
                }
                break;
            default:
                break;
        }
        throw (
            "Wrong API use : tried to bind a value of an unknown type ("
            + val + ")."
        );
    };

    /** Bind names and values of an object to the named parameters of the
    statement
    @param {Object<string, Database.SqlValue>} valuesObj
    @private
    @nodoc
     */
    Statement.prototype.bindFromObject = function bindFromObject(valuesObj) {
        var that = this;
        Object.keys(valuesObj).forEach(function each(name) {
            var num = sqlite3_bind_parameter_index(that.stmt, name);
            if (num !== 0) {
                that.bindValue(valuesObj[name], num);
            }
        });
        return true;
    };

    /** Bind values to numbered parameters
    @param {Database.SqlValue[]} values
    @private
    @nodoc
     */
    Statement.prototype.bindFromArray = function bindFromArray(values) {
        for (var num = 0; num < values.length; num += 1) {
            this.bindValue(values[num], num + 1);
        }
        return true;
    };

    /** Reset a statement, so that its parameters can be bound to new values
    It also clears all previous bindings, freeing the memory used
    by bound parameters.
     */
    Statement.prototype["reset"] = function reset() {
        this["freemem"]();
        return (
            sqlite3_clear_bindings(this.stmt) === SQLITE_OK
            && sqlite3_reset(this.stmt) === SQLITE_OK
        );
    };

    /** Free the memory allocated during parameter binding */
    Statement.prototype["freemem"] = function freemem() {
        var mem;
        while ((mem = this.allocatedmem.pop()) !== undefined) {
            _free(mem);
        }
    };

    /** Free the memory used by the statement
    @return {boolean} true in case of success
     */
    Statement.prototype["free"] = function free() {
        var res;
        this["freemem"]();
        res = sqlite3_finalize(this.stmt) === SQLITE_OK;
        delete this.db.statements[this.stmt];
        this.stmt = NULL;
        return res;
    };

    /**
     * @classdesc
     * An iterator over multiple SQL statements in a string,
     * preparing and returning a Statement object for the next SQL
     * statement on each iteration.
     *
     * You can't instantiate this class directly, you have to use a
     * {@link Database} object in order to create a statement iterator
     *
     * {@see Database#iterateStatements}
     *
     * @example
     * // loop over and execute statements in string sql
     * for (let statement of db.iterateStatements(sql) {
     *     statement.step();
     *     // get results, etc.
     *     // do not call statement.free() manually, each statement is freed
     *     // before the next one is parsed
     * }
     *
     * // capture any bad query exceptions with feedback
     * // on the bad sql
     * let it = db.iterateStatements(sql);
     * try {
     *     for (let statement of it) {
     *         statement.step();
     *     }
     * } catch(e) {
     *     console.log(
     *         `The SQL string "${it.getRemainingSQL()}" ` +
     *         `contains the following error: ${e}`
     *     );
     * }
     *
     * @implements {Iterator<Statement>}
     * @implements {Iterable<Statement>}
     * @constructs StatementIterator
     * @memberof module:SqlJs
     * @param {string} sql A string containing multiple SQL statements
     * @param {Database} db The database from which this iterator was created
     */
    function StatementIterator(sql, db) {
        this.db = db;
        var sz = lengthBytesUTF8(sql) + 1;
        this.sqlPtr = _malloc(sz);
        if (this.sqlPtr === null) {
            throw new Error("Unable to allocate memory for the SQL string");
        }
        stringToUTF8(sql, this.sqlPtr, sz);
        this.nextSqlPtr = this.sqlPtr;
        this.nextSqlString = null;
        this.activeStatement = null;
    }

    /**
     * @typedef {{ done:true, value:undefined } |
     *           { done:false, value:Statement}}
     *           StatementIterator.StatementIteratorResult
     * @property {Statement} value the next available Statement
     * (as returned by {@link Database.prepare})
     * @property {boolean} done true if there are no more available statements
     */

    /** Prepare the next available SQL statement
     @return {StatementIterator.StatementIteratorResult}
     @throws {String} SQLite error or invalid iterator error
     */
    StatementIterator.prototype["next"] = function next() {
        if (this.sqlPtr === null) {
            return { done: true };
        }
        if (this.activeStatement !== null) {
            this.activeStatement["free"]();
            this.activeStatement = null;
        }
        if (!this.db.db) {
            this.finalize();
            throw new Error("Database closed");
        }
        var stack = stackSave();
        var pzTail = stackAlloc(4);
        setValue(apiTemp, 0, "i32");
        setValue(pzTail, 0, "i32");
        try {
            this.db.handleError(sqlite3_prepare_v2_sqlptr(
                this.db.db,
                this.nextSqlPtr,
                -1,
                apiTemp,
                pzTail
            ));
            this.nextSqlPtr = getValue(pzTail, "i32");
            var pStmt = getValue(apiTemp, "i32");
            if (pStmt === NULL) {
                this.finalize();
                return { done: true };
            }
            this.activeStatement = new Statement(pStmt, this.db);
            this.db.statements[pStmt] = this.activeStatement;
            return { value: this.activeStatement, done: false };
        } catch (e) {
            this.nextSqlString = UTF8ToString(this.nextSqlPtr);
            this.finalize();
            throw e;
        } finally {
            stackRestore(stack);
        }
    };

    StatementIterator.prototype.finalize = function finalize() {
        _free(this.sqlPtr);
        this.sqlPtr = null;
    };

    /** Get any un-executed portions remaining of the original SQL string
     @return {String}
     */
    StatementIterator.prototype["getRemainingSQL"] = function getRemainder() {
        // iff an exception occurred, we set the nextSqlString
        if (this.nextSqlString !== null) return this.nextSqlString;
        // otherwise, convert from nextSqlPtr
        return UTF8ToString(this.nextSqlPtr);
    };

    /* implement Iterable interface */

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        StatementIterator.prototype[Symbol.iterator] = function iterator() {
            return this;
        };
    }

    /** @classdesc
    * Represents an SQLite database
    * @constructs Database
    * @memberof module:SqlJs
    * Open a new database either by creating a new one or opening an existing
    * one stored in the byte array passed in first argument
    * @param {number[]} data An array of bytes representing
    * an SQLite database file
    */
    function Database(data) {
        this.filename = "dbfile_" + (0xffffffff * Math.random() >>> 0);
        if (data != null) {
            FS.createDataFile("/", this.filename, data, true, true);
        }
        this.handleError(sqlite3_open(this.filename, apiTemp));
        this.db = getValue(apiTemp, "i32");
        registerExtensionFunctions(this.db);
        // Initialiser l'extension
        var errMessagePtr = _malloc(4);
        setValue(errMessagePtr, 0, "i8*");
        console.log(typeof this.db, typeof errMessagePtr, typeof apiTemp);
        var result = sqlite3_series_init(this.db, errMessagePtr, 0);

        // Vérifier le résultat
        if (result !== SQLITE_OK) {
            var errMessage = UTF8ToString(getValue(errMessagePtr, "i8*"));
            _free(errMessagePtr);
            // eslint-disable-next-line max-len
            throw new Error("Failed to initialize series extension: " + errMessage);
        }
        _free(errMessagePtr);
        // A list of all prepared statements of the database
        this.statements = {};
        // A list of all user function of the database
        // (created by create_function call)
        this.functions = {};
    }

    /** Execute an SQL query, ignoring the rows it returns.
    @param {string} sql a string containing some SQL text to execute
    @param {Statement.BindParams} [params] When the SQL statement contains
    placeholders, you can pass them in here. They will be bound to the statement
    before it is executed. If you use the params argument, you **cannot**
    provide an sql string that contains several statements (separated by `;`)

    @example
    // Insert values in a table
    db.run(
        "INSERT INTO test VALUES (:age, :name)",
        { ':age' : 18, ':name' : 'John' }
    );

    @return {Database} The database object (useful for method chaining)
     */
    Database.prototype["run"] = function run(sql, params) {
        if (!this.db) {
            throw "Database closed";
        }
        if (params) {
            var stmt = this["prepare"](sql, params);
            try {
                stmt["step"]();
            } finally {
                stmt["free"]();
            }
        } else {
            this.handleError(sqlite3_exec(this.db, sql, 0, 0, apiTemp));
        }
        return this;
    };

    /**
     * @typedef {{
        columns:string[],
        values:Database.SqlValue[][]
    }} Database.QueryExecResult
     * @property {string[]} columns the name of the columns of the result
     * (as returned by {@link Statement.getColumnNames})
     * @property {Database.SqlValue[][]} values one array per row, containing
     * the column values
     */

    /** Execute an SQL query, and returns the result.
    *
    * This is a wrapper against
    * {@link Database.prepare},
    * {@link Statement.bind},
    * {@link Statement.step},
    * {@link Statement.get},
    * and {@link Statement.free}.
    *
    * The result is an array of result elements. There are as many result
    * elements as the number of statements in your sql string (statements are
    * separated by a semicolon)
    *
    * ## Example use
    * We will create the following table, named *test* and query it with a
    * multi-line statement using params:
    *
    * | id | age |  name  |
    * |:--:|:---:|:------:|
    * | 1  |  1  | Ling   |
    * | 2  |  18 | Paul   |
    *
    * We query it like that:
    * ```javascript
    * var db = new SQL.Database();
    * var res = db.exec(
    *     "DROP TABLE IF EXISTS test;\n"
    *     + "CREATE TABLE test (id INTEGER, age INTEGER, name TEXT);"
    *     + "INSERT INTO test VALUES ($id1, :age1, @name1);"
    *     + "INSERT INTO test VALUES ($id2, :age2, @name2);"
    *     + "SELECT id FROM test;"
    *     + "SELECT age,name FROM test WHERE id=$id1",
    *     {
    *         "$id1": 1, ":age1": 1, "@name1": "Ling",
    *         "$id2": 2, ":age2": 18, "@name2": "Paul"
    *     }
    * );
    * ```
    *
    * `res` is now :
    * ```javascript
    *     [
    *         {"columns":["id"],"values":[[1],[2]]},
    *         {"columns":["age","name"],"values":[[1,"Ling"]]}
    *     ]
    * ```
    *
    @param {string} sql a string containing some SQL text to execute
    @param {Statement.BindParams} [params] When the SQL statement contains
    placeholders, you can pass them in here. They will be bound to the statement
    before it is executed. If you use the params argument as an array,
    you **cannot** provide an sql string that contains several statements
    (separated by `;`). This limitation does not apply to params as an object.
    * @return {Database.QueryExecResult[]} The results of each statement
    */
    Database.prototype["exec"] = function exec(sql, params, config) {
        if (!this.db) {
            throw "Database closed";
        }
        var stack = stackSave();
        var stmt = null;
        try {
            var nextSqlPtr = allocateUTF8OnStack(sql);
            var pzTail = stackAlloc(4);
            var results = [];
            while (getValue(nextSqlPtr, "i8") !== NULL) {
                setValue(apiTemp, 0, "i32");
                setValue(pzTail, 0, "i32");
                this.handleError(sqlite3_prepare_v2_sqlptr(
                    this.db,
                    nextSqlPtr,
                    -1,
                    apiTemp,
                    pzTail
                ));
                // pointer to a statement, or null
                var pStmt = getValue(apiTemp, "i32");
                nextSqlPtr = getValue(pzTail, "i32");
                // Empty statement
                if (pStmt !== NULL) {
                    var curresult = null;
                    stmt = new Statement(pStmt, this);
                    if (params != null) {
                        stmt.bind(params);
                    }
                    while (stmt["step"]()) {
                        if (curresult === null) {
                            curresult = {
                                columns: stmt["getColumnNames"](),
                                values: [],
                            };
                            results.push(curresult);
                        }
                        curresult["values"].push(stmt["get"](null, config));
                    }
                    stmt["free"]();
                }
            }
            return results;
        } catch (errCaught) {
            if (stmt) stmt["free"]();
            throw errCaught;
        } finally {
            stackRestore(stack);
        }
    };

    /** Execute an sql statement, and call a callback for each row of result.

    Currently this method is synchronous, it will not return until the callback
    has been called on every row of the result. But this might change.

    @param {string} sql A string of SQL text. Can contain placeholders
    that will be bound to the parameters given as the second argument
    @param {Statement.BindParams} [params=[]] Parameters to bind to the query
    @param {function(Object<string, Database.SqlValue>):void} callback
    Function to call on each row of result
    @param {function():void} done A function that will be called when
    all rows have been retrieved

    @return {Database} The database object. Useful for method chaining

    @example <caption>Read values from a table</caption>
    db.each("SELECT name,age FROM users WHERE age >= $majority", {$majority:18},
            function (row){console.log(row.name + " is a grown-up.")}
    );
     */
    Database.prototype["each"] = function each(
        sql, params, callback, done, config
    ) {
        var stmt;
        if (typeof params === "function") {
            done = callback;
            callback = params;
            params = undefined;
        }
        stmt = this["prepare"](sql, params);
        try {
            while (stmt["step"]()) {
                callback(stmt["getAsObject"](null, config));
            }
        } finally {
            stmt["free"]();
        }
        if (typeof done === "function") {
            return done();
        }
        return undefined;
    };

    /** Prepare an SQL statement
    @param {string} sql a string of SQL, that can contain placeholders
    (`?`, `:VVV`, `:AAA`, `@AAA`)
    @param {Statement.BindParams} [params] values to bind to placeholders
    @return {Statement} the resulting statement
    @throws {String} SQLite error
     */
    Database.prototype["prepare"] = function prepare(sql, params) {
        setValue(apiTemp, 0, "i32");
        this.handleError(sqlite3_prepare_v2(this.db, sql, -1, apiTemp, NULL));
        // pointer to a statement, or null
        var pStmt = getValue(apiTemp, "i32");
        if (pStmt === NULL) {
            throw "Nothing to prepare";
        }
        var stmt = new Statement(pStmt, this);
        if (params != null) {
            stmt.bind(params);
        }
        this.statements[pStmt] = stmt;
        return stmt;
    };

    /** Iterate over multiple SQL statements in a SQL string.
     * This function returns an iterator over {@link Statement} objects.
     * You can use a for..of loop to execute the returned statements one by one.
     * @param {string} sql a string of SQL that can contain multiple statements
     * @return {StatementIterator} the resulting statement iterator
     * @example <caption>Get the results of multiple SQL queries</caption>
     * const sql_queries = "SELECT 1 AS x; SELECT '2' as y";
     * for (const statement of db.iterateStatements(sql_queries)) {
     *     const sql = statement.getSQL(); // Get the SQL source
     *     const result = statement.getAsObject({}); // Get the row of data
     *     console.log(sql, result);
     * }
     * // This will print:
     * // 'SELECT 1 AS x;' { x: 1 }
     * // " SELECT '2' as y" { y: '2' }
     */
    Database.prototype["iterateStatements"] = function iterateStatements(sql) {
        return new StatementIterator(sql, this);
    };

    /** Exports the contents of the database to a binary array
    @return {Uint8Array} An array of bytes of the SQLite3 database file
     */
    Database.prototype["export"] = function exportDatabase() {
        Object.values(this.statements).forEach(function each(stmt) {
            stmt["free"]();
        });
        Object.values(this.functions).forEach(removeFunction);
        this.functions = {};
        this.handleError(sqlite3_close_v2(this.db));
        var binaryDb = FS.readFile(this.filename, { encoding: "binary" });
        this.handleError(sqlite3_open(this.filename, apiTemp));
        this.db = getValue(apiTemp, "i32");
        return binaryDb;
    };

    /** Close the database, and all associated prepared statements.
    * The memory associated to the database and all associated statements
    * will be freed.
    *
    * **Warning**: A statement belonging to a database that has been closed
    * cannot be used anymore.
    *
    * Databases **must** be closed when you're finished with them, or the
    * memory consumption will grow forever
     */
    Database.prototype["close"] = function close() {
        // do nothing if db is null or already closed
        if (this.db === null) {
            return;
        }
        Object.values(this.statements).forEach(function each(stmt) {
            stmt["free"]();
        });
        Object.values(this.functions).forEach(removeFunction);
        this.functions = {};
        this.handleError(sqlite3_close_v2(this.db));
        FS.unlink("/" + this.filename);
        this.db = null;
    };

    /** Analyze a result code, return null if no error occured, and throw
    an error with a descriptive message otherwise
    @nodoc
     */
    Database.prototype["handleError"] = function handleError(returnCode) {
        var errmsg;
        if (returnCode === SQLITE_OK) {
            return null;
        }
        errmsg = sqlite3_errmsg(this.db);
        throw new Error(errmsg);
    };

    /** Returns the number of changed rows (modified, inserted or deleted)
    by the latest completed INSERT, UPDATE or DELETE statement on the
    database. Executing any other type of SQL statement does not modify
    the value returned by this function.

    @return {number} the number of rows modified
    */
    Database.prototype["getRowsModified"] = function getRowsModified() {
        return sqlite3_changes(this.db);
    };

    var extract_blob = function extract_blob(ptr) {
        var size = sqlite3_value_bytes(ptr);
        var blob_ptr = sqlite3_value_blob(ptr);
        var blob_arg = new Uint8Array(size);
        for (var j = 0; j < size; j += 1) {
            blob_arg[j] = HEAP8[blob_ptr + j];
        }
        return blob_arg;
    };

    var parseFunctionArguments = function parseFunctionArguments(argc, argv) {
        var args = [];
        for (var i = 0; i < argc; i += 1) {
            var value_ptr = getValue(argv + (4 * i), "i32");
            var value_type = sqlite3_value_type(value_ptr);
            var arg;
            if (
                value_type === SQLITE_INTEGER
                || value_type === SQLITE_FLOAT
            ) {
                arg = sqlite3_value_double(value_ptr);
            } else if (value_type === SQLITE_TEXT) {
                arg = sqlite3_value_text(value_ptr);
            } else if (value_type === SQLITE_BLOB) {
                arg = extract_blob(value_ptr);
            } else arg = null;
            args.push(arg);
        }
        return args;
    };
    var setFunctionResult = function setFunctionResult(cx, result) {
        switch (typeof result) {
            case "boolean":
                sqlite3_result_int(cx, result ? 1 : 0);
                break;
            case "number":
                sqlite3_result_double(cx, result);
                break;
            case "string":
                sqlite3_result_text(cx, result, -1, -1);
                break;
            case "object":
                if (result === null) {
                    sqlite3_result_null(cx);
                } else if (result.length != null) {
                    var blobptr = allocate(result, ALLOC_NORMAL);
                    sqlite3_result_blob(cx, blobptr, result.length, -1);
                    _free(blobptr);
                } else {
                    sqlite3_result_error(cx, (
                        "Wrong API use : tried to return a value "
                        + "of an unknown type (" + result + ")."
                    ), -1);
                }
                break;
            default:
                sqlite3_result_null(cx);
        }
    };

    /** Register a custom function with SQLite
      @example <caption>Register a simple function</caption>
          db.create_function("addOne", function (x) {return x+1;})
          db.exec("SELECT addOne(1)") // = 2

      @param {string} name the name of the function as referenced in
      SQL statements.
      @param {function} func the actual function to be executed.
      @return {Database} The database object. Useful for method chaining
       */
    Database.prototype["create_function"] = function create_function(
        name,
        func
    ) {
        function wrapped_func(cx, argc, argv) {
            var args = parseFunctionArguments(argc, argv);
            var result;
            try {
                result = func.apply(null, args);
            } catch (error) {
                sqlite3_result_error(cx, error, -1);
                return;
            }
            setFunctionResult(cx, result);
        }
        if (Object.prototype.hasOwnProperty.call(this.functions, name)) {
            removeFunction(this.functions[name]);
            delete this.functions[name];
        }
        // The signature of the wrapped function is :
        // void wrapped(sqlite3_context *db, int argc, sqlite3_value **argv)
        var func_ptr = addFunction(wrapped_func, "viii");
        this.functions[name] = func_ptr;
        this.handleError(sqlite3_create_function_v2(
            this.db,
            name,
            func.length,
            SQLITE_UTF8,
            0,
            func_ptr,
            0,
            0,
            0
        ));
        return this;
    };

    /** Register a custom aggregate with SQLite
      @example <caption>Register a custom sum function</caption>
        db.create_aggregate("js_sum", {
            init: () => 0,
            step: (state, value) => state + value,
            finalize: state => state
        });
        db.exec("SELECT js_sum(column1) FROM (VALUES (1), (2))"); // = 3

      @param {string} name the name of the aggregate as referenced in
      SQL statements.
      @param {object} aggregateFunctions
                      object containing at least a step function.
      @param {function(): T} [aggregateFunctions.init = ()=>null]
            a function receiving no arguments and returning an initial
            value for the aggregate function. The initial value will be
            null if this key is omitted.
      @param {function(T, any) : T} aggregateFunctions.step
            a function receiving the current state and a value to aggregate
            and returning a new state.
            Will receive the value from init for the first step.
      @param {function(T): any} [aggregateFunctions.finalize = (state)=>state]
            a function returning the result of the aggregate function
            given its final state.
            If omitted, the value returned by the last step
            will be used as the final value.
      @return {Database} The database object. Useful for method chaining
      @template T
       */
    Database.prototype["create_aggregate"] = function create_aggregate(
        name,
        aggregateFunctions
    ) {
        // Default initializer and finalizer
        var init = aggregateFunctions["init"]
            || function init() { return null; };
        var finalize = aggregateFunctions["finalize"]
            || function finalize(state) { return state; };
        var step = aggregateFunctions["step"];

        if (!step) {
            throw "An aggregate function must have a step function in " + name;
        }

        // state is a state object; we'll use the pointer p to serve as the
        // key for where we hold our state so that multiple invocations of
        // this function never step on each other
        var state = {};

        function wrapped_step(cx, argc, argv) {
            // > The first time the sqlite3_aggregate_context(C,N) routine is
            // > called for a particular aggregate function, SQLite allocates N
            // > bytes of memory, zeroes out that memory, and returns a pointer
            // > to the new memory.
            //
            // We're going to use that pointer as a key to our state array,
            // since using sqlite3_aggregate_context as it's meant to be used
            // through webassembly seems to be very difficult. Just allocate
            // one byte.
            var p = sqlite3_aggregate_context(cx, 1);

            // If this is the first invocation of wrapped_step, call `init`
            //
            // Make sure that every path through the step and finalize
            // functions deletes the value state[p] when it's done so we don't
            // leak memory and possibly stomp the init value of future calls
            if (!Object.hasOwnProperty.call(state, p)) state[p] = init();

            var args = parseFunctionArguments(argc, argv);
            var mergedArgs = [state[p]].concat(args);
            try {
                state[p] = step.apply(null, mergedArgs);
            } catch (error) {
                delete state[p];
                sqlite3_result_error(cx, error, -1);
            }
        }

        function wrapped_finalize(cx) {
            var result;
            var p = sqlite3_aggregate_context(cx, 1);
            try {
                result = finalize(state[p]);
            } catch (error) {
                delete state[p];
                sqlite3_result_error(cx, error, -1);
                return;
            }
            setFunctionResult(cx, result);
            delete state[p];
        }

        if (Object.hasOwnProperty.call(this.functions, name)) {
            removeFunction(this.functions[name]);
            delete this.functions[name];
        }
        var finalize_name = name + "__finalize";
        if (Object.hasOwnProperty.call(this.functions, finalize_name)) {
            removeFunction(this.functions[finalize_name]);
            delete this.functions[finalize_name];
        }
        // The signature of the wrapped function is :
        // void wrapped(sqlite3_context *db, int argc, sqlite3_value **argv)
        var step_ptr = addFunction(wrapped_step, "viii");

        // The signature of the wrapped function is :
        // void wrapped(sqlite3_context *db)
        var finalize_ptr = addFunction(wrapped_finalize, "vi");
        this.functions[name] = step_ptr;
        this.functions[finalize_name] = finalize_ptr;

        // passing null to the sixth parameter defines this as an aggregate
        // function
        //
        // > An aggregate SQL function requires an implementation of xStep and
        // > xFinal and NULL pointer must be passed for xFunc.
        // - http://www.sqlite.org/c3ref/create_function.html
        this.handleError(sqlite3_create_function_v2(
            this.db,
            name,
            step.length - 1,
            SQLITE_UTF8,
            0,
            0,
            step_ptr,
            finalize_ptr,
            0
        ));
        return this;
    };

    // export Database to Module
    Module.Database = Database;
};


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

// Normally we don't log exceptions but instead let them bubble out the top
// level where the embedding environment (e.g. the browser) can handle
// them.
// However under v8 and node we sometimes exit the process direcly in which case
// its up to use us to log the exception before exiting.
// If we fix https://github.com/emscripten-core/emscripten/issues/15080
// this may no longer be needed under node.
function logExceptionOnExit(e) {
  if (e instanceof ExitStatus) return;
  let toLog = e;
  err('exiting due to exception: ' + toLog);
}

var fs;
var nodePath;
var requireNodeFS;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js


requireNodeFS = () => {
  // Use nodePath as the indicator for these not being initialized,
  // since in some environments a global fs may have already been
  // created.
  if (!nodePath) {
    fs = require('fs');
    nodePath = require('path');
  }
};

read_ = function shell_read(filename, binary) {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
    return binary ? ret : ret.toString();
  }
  requireNodeFS();
  filename = nodePath['normalize'](filename);
  return fs.readFileSync(filename, binary ? undefined : 'utf8');
};

readBinary = (filename) => {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  return ret;
};

readAsync = (filename, onload, onerror) => {
  var ret = tryParseAsDataURI(filename);
  if (ret) {
    onload(ret);
  }
  requireNodeFS();
  filename = nodePath['normalize'](filename);
  fs.readFile(filename, function(err, data) {
    if (err) onerror(err);
    else onload(data.buffer);
  });
};

// end include: node_shell_read.js
  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module != 'undefined') {
    module['exports'] = Module;
  }

  quit_ = (status, toThrow) => {
    if (keepRuntimeAlive()) {
      process['exitCode'] = status;
      throw toThrow;
    }
    logExceptionOnExit(toThrow);
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {
// include: web_or_worker_shell_read.js


  read_ = (url) => {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  }

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = (url, onload, onerror) => {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = () => {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  }

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = (title) => document.title = title;
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message




var STACK_ALIGN = 16;
var POINTER_SIZE = 4;

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': case 'u8': return 1;
    case 'i16': case 'u16': return 2;
    case 'i32': case 'u32': return 4;
    case 'i64': case 'u64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length - 1] === '*') {
        return POINTER_SIZE;
      }
      if (type[0] === 'i') {
        const bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      }
      return 0;
    }
  }
}

// include: runtime_debug.js


// end include: runtime_debug.js


// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

// include: wasm2js.js


// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{duplicate, const} */
var
WebAssembly = {
  // Note that we do not use closure quoting (this['buffer'], etc.) on these
  // functions, as they are just meant for internal use. In other words, this is
  // not a fully general polyfill.
  /** @constructor */
  Memory: function(opts) {
    this.buffer = new ArrayBuffer(opts['initial'] * 65536);
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
  },

  /** @constructor */
  Instance: function(module, info) {
    // TODO: use the module and info somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    this.exports = (
// EMSCRIPTEN_START_ASM
function instantiate(asmLibraryArg) {
function Table(ret) {
  ret.grow = function(by) {
    var old = this.length;
    this.length = this.length + by;
    return old;
  };
  ret.set = function(i, func) {
    this[i] = func;
  };
  ret.get = function(i) {
    return this[i];
  };
  return ret;
}

  var bufferView;
  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
  for (var i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
  }
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 1024, "My4zOS4zAHt9ACVzLiV6AGFmZmluaXR5AFJlYWxBZmZpbml0eQBidXN5AHRlbXBfc3RvcmVfZGlyZWN0b3J5AG5vdCBhIHdyaXRhYmxlIGRpcmVjdG9yeQBvcGVuRGlyZWN0b3J5AHNocmlua19tZW1vcnkAb3V0IG9mIG1lbW9yeQBmYWlsZWQgdG8gYWxsb2NhdGUgJXUgYnl0ZXMgb2YgbWVtb3J5AEhBVklORyBjbGF1c2Ugb24gYSBub24tYWdncmVnYXRlIHF1ZXJ5AEludENvcHkAU0NvcHkAVkRlc3Ryb3kATXVsdGlwbHkAcXVlcnlfb25seQB1bmxpa2VseQB0YWJsZSAiJXMiIGhhcyBtb3JlIHRoYW4gb25lIHByaW1hcnkga2V5AGZvcmVpZ24ga2V5AGpzb25fZ3JvdXBfYXJyYXkAanNvbl9hcnJheQBqdWxpYW5kYXkAZnRzNGF1eAB1bml4AHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgAcHJlZml4AExJS0Ugb3IgR0xPQiBwYXR0ZXJuIHRvbyBjb21wbGV4AGhleABjaGFyaW5kZXgAT3BlbkF1dG9pbmRleABhdXRvbWF0aWNfaW5kZXgAYXV0by1pbmRleABvcnBoYW4gaW5kZXgAc2VyaWVzQmVzdEluZGV4AERyb3BJbmRleABpZHgAUmVvcGVuSWR4AHBjeABtYXgATWVtTWF4ACUwMngAMHgAIEZST00gJyVxJy4nJXElcycgQVMgeABDUkVBVEUgVEFCTEUgeABydwBwc293AGltcGxpZXNfbm9ubnVsbF9yb3cAbm93AGludGVnZXIgb3ZlcmZsb3cAcGFyc2VyIHN0YWNrIG92ZXJmbG93AHdpbmRvdwBzaGFkb3cAUmVzdWx0Um93AElmTnVsbFJvdwBuZXcAbm8gc3VjaCB2aWV3AGNhbm5vdCBtb2RpZnkgJXMgYmVjYXVzZSBpdCBpcyBhIHZpZXcAQ2Fubm90IGFkZCBhIGNvbHVtbiB0byBhIHZpZXcAY2Fubm90IFVQU0VSVCBhIHZpZXcAUHJldgBzdGRldgAgJWxsdQAlYyV1ACUuKno6JXUARnJhZ21lbnRhdGlvbiBvZiAlZCBieXRlcyByZXBvcnRlZCBhcyAlZCBvbiBwYWdlICV1AE11bHRpcGxlIHVzZXMgZm9yIGJ5dGUgJXUgb2YgcGFnZSAldQB1bmFibGUgdG8gdXNlIGZ1bmN0aW9uICVzIGluIHRoZSByZXF1ZXN0ZWQgY29udGV4dABTb3J0ZXJOZXh0AFZOZXh0AGluY29tcGxldGUgaW5wdXQAYnVzeV90aW1lb3V0AGxvY2FsaG9zdABjYW5ub3QgZHJvcCBjb2x1bW4gIiVzIjogbm8gb3RoZXIgY29sdW1ucyBleGlzdABwZXJzaXN0AGZvcmVpZ25fa2V5X2xpc3QAaW5kZXhfbGlzdABmdW5jdGlvbl9saXN0AGNvbGxhdGlvbl9saXN0AGRhdGFiYXNlX2xpc3QAbW9kdWxlX2xpc3QAUFJBR01BIHRhYmxlX2xpc3QAcHJhZ21hX2xpc3QAc2V0IGxpc3QAVmFsdWVMaXN0AHNxbGl0ZV9yZW5hbWVfdGVzdABSb3dTZXRUZXN0AFNlcXVlbmNlVGVzdABmYXN0AExhc3QAQ2FzdABzcXJ0AFNvcnRlclNvcnQAanNvbl9pbnNlcnQASWR4SW5zZXJ0AFNvcnRlckluc2VydAByZXN0YXJ0AGNvdABCaXROb3QASWZOb3QAUGFnZWNvdW50AGZyZWVsaXN0X2NvdW50AG1heF9wYWdlX2NvdW50AFJlc2V0Q291bnQAd2FsX2F1dG9jaGVja3BvaW50AHdhbF9jaGVja3BvaW50AENoZWNrcG9pbnQAU2F2ZXBvaW50AGEgQ0hFQ0sgY29uc3RyYWludAAlc09OIENPTkZMSUNUIGNsYXVzZSBkb2VzIG5vdCBtYXRjaCBhbnkgUFJJTUFSWSBLRVkgb3IgVU5JUVVFIGNvbnN0cmFpbnQAQ3Vyc29ySGludABfY29udGVudABwYXJlbnQARElTVElOQ1QgYWdncmVnYXRlcyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgYXJndW1lbnQAY29tbWVudABBUEkgY2FsbGVkIHdpdGggZmluYWxpemVkIHByZXBhcmVkIHN0YXRlbWVudABBUEkgY2FsbGVkIHdpdGggTlVMTCBwcmVwYXJlZCBzdGF0ZW1lbnQATWF4UGdjbnQAZGVmYXVsdCB2YWx1ZSBvZiBjb2x1bW4gWyVzXSBpcyBub3QgY29uc3RhbnQATXVzdEJlSW50AENhbm5vdCBhZGQgYSBjb2x1bW4gd2l0aCBub24tY29uc3RhbnQgZGVmYXVsdABIYWx0AGxhbm9pdABzdGF0X2luaXQASW5pdABBdXRvQ29tbWl0AGFuYWx5c2lzX2xpbWl0AHNvZnRfaGVhcF9saW1pdABoYXJkX2hlYXBfbGltaXQAam91cm5hbF9zaXplX2xpbWl0AE9mZnNldExpbWl0AFNlZWtIaXQAT04gY2xhdXNlIHJlZmVyZW5jZXMgdGFibGVzIHRvIGl0cyByaWdodABTaGlmdFJpZ2h0AGhnaHQAU2hpZnRMZWZ0AE9mZnNldAByZXNldABqc29uX3NldAB0b28gbWFueSBjb2x1bW5zIGluIHJlc3VsdCBzZXQAJXIgT1JERVIgQlkgdGVybSBkb2VzIG5vdCBtYXRjaCBhbnkgY29sdW1uIGluIHRoZSByZXN1bHQgc2V0AHNuaXBwZXQAc3RhdF9nZXQAc3FsaXRlX2NvbXBpbGVvcHRpb25fZ2V0AHN0cmljdABOb0NvbmZsaWN0AGpzb25fZ3JvdXBfb2JqZWN0AGpzb25fb2JqZWN0AGpzb25fZXh0cmFjdABTdWJ0cmFjdABsc3RhdABmc3RhdAAlc19zdGF0AHRibCxpZHgsc3RhdAB1bnN1cHBvcnRlZCBmaWxlIGZvcm1hdABncm91cF9jb25jYXQAQ29uY2F0AEx0AEd0AGRlZmVyX2ZvcmVpZ25fa2V5cwBhbHdheXMAcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgaW4gdmlld3MAc3RhdHVzAHN5bmNocm9ub3VzAGluZGV4ICVzIGFscmVhZHkgZXhpc3RzAG91dHB1dCBmaWxlIGFscmVhZHkgZXhpc3RzACVzICVUIGFscmVhZHkgZXhpc3RzAHRyaWdnZXIgJVQgYWxyZWFkeSBleGlzdHMATm90RXhpc3RzAGlnbm9yZV9jaGVja19jb25zdHJhaW50cwBDSEVDSyBjb25zdHJhaW50cwBleHByZXNzaW9ucyBwcm9oaWJpdGVkIGluIFBSSU1BUlkgS0VZIGFuZCBVTklRVUUgY29uc3RyYWludHMAanNvbl9vYmplY3QoKSByZXF1aXJlcyBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMAanNvbl8lcygpIG5lZWRzIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzACVzX3NlZ21lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IHVzZXItZnVuY3Rpb24gZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHVuYWJsZSB0byBkZWxldGUvbW9kaWZ5IGNvbGxhdGlvbiBzZXF1ZW5jZSBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAb2Zmc2V0cwByZXZlcnNlX3Vub3JkZXJlZF9zZWxlY3RzAGlpc3Nzc3NzAGlzcwBzZXNzAHVuY29tcHJlc3MAY2Fubm90IG9wZW4gc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IHJlbGVhc2Ugc2F2ZXBvaW50IC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IGNvbW1pdCB0cmFuc2FjdGlvbiAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBWQUNVVU0gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBhY2Nlc3MAcGFyYW1ldGVycwByZWN1cnNpdmVfdHJpZ2dlcnMAdGhlIElOREVYRUQgQlkgY2xhdXNlIGlzIG5vdCBhbGxvd2VkIG9uIFVQREFURSBvciBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAdGhlIE5PVCBJTkRFWEVEIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHF1YWxpZmllZCB0YWJsZSBuYW1lcyBhcmUgbm90IGFsbG93ZWQgb24gSU5TRVJULCBVUERBVEUsIGFuZCBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAQ2hpbGQgcGFnZSBkZXB0aCBkaWZmZXJzAHVuYWJsZSB0byBjbG9zZSBkdWUgdG8gdW5maW5hbGl6ZWQgc3RhdGVtZW50cyBvciB1bmZpbmlzaGVkIGJhY2t1cHMAYWNvcwBJZlBvcwBjb21waWxlX29wdGlvbnMARElTVElOQ1QgaXMgbm90IHN1cHBvcnRlZCBmb3Igd2luZG93IGZ1bmN0aW9ucwBGSUxURVIgY2xhdXNlIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhZ2dyZWdhdGUgd2luZG93IGZ1bmN0aW9ucwBub24tZGV0ZXJtaW5pc3RpYyBmdW5jdGlvbnMAaW5kZXggZXhwcmVzc2lvbnMAU0VMRUNUcyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgJXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJlc3VsdCBjb2x1bW5zAHZpcnR1YWwgdGFibGVzIGNhbm5vdCB1c2UgY29tcHV0ZWQgY29sdW1ucwBnZW5lcmF0ZWQgY29sdW1ucwB0YWJsZSAlcyBoYXMgJWQgdmFsdWVzIGZvciAlZCBjb2x1bW5zAHJhZGlhbnMAYWxsIFZBTFVFUyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHRlcm1zAGVtcHR5X3Jlc3VsdF9jYWxsYmFja3MATG9hZEFuYWx5c2lzAGZsZ3MAZmxhZ3MAdmZzACVkIGNvbHVtbnMgYXNzaWduZWQgJWQgdmFsdWVzAEpTT04gY2Fubm90IGhvbGQgQkxPQiB2YWx1ZXMAZmFpbGVkIG1lbW9yeSByZXNpemUgJXUgdG8gJXUgYnl0ZXMAcGFydGlhbCBpbmRleCBXSEVSRSBjbGF1c2VzAHNob3J0X2NvbHVtbl9uYW1lcwBmdWxsX2NvbHVtbl9uYW1lcwB1bmFibGUgdG8gb3BlbiBhIHRlbXBvcmFyeSBkYXRhYmFzZSBmaWxlIGZvciBzdG9yaW5nIHRlbXBvcmFyeSB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiB2aXJ0dWFsIHRhYmxlcwAlcyBSRVRVUk5JTkcgaXMgbm90IGF2YWlsYWJsZSBvbiB2aXJ0dWFsIHRhYmxlcwBjYW5ub3Qgam9pbiB1c2luZyBjb2x1bW4gJXMgLSBjb2x1bW4gbm90IHByZXNlbnQgaW4gYm90aCB0YWJsZXMAQVVUT0lOQ1JFTUVOVCBub3QgYWxsb3dlZCBvbiBXSVRIT1VUIFJPV0lEIHRhYmxlcwAlcyBjYW5ub3QgdXNlIHZhcmlhYmxlcwB0b28gbWFueSBTUUwgdmFyaWFibGVzAHN1YnF1ZXJpZXMAY2Fubm90IHVzZSB3aW5kb3cgZnVuY3Rpb25zIGluIHJlY3Vyc2l2ZSBxdWVyaWVzAGdlbmVyYXRlX3NlcmllcwBjb3VudF9jaGFuZ2VzAHRvdGFsX2NoYW5nZXMAZGVncmVlcwBSRVRVUk5JTkcgbWF5IG5vdCB1c2UgIlRBQkxFLioiIHdpbGRjYXJkcwB0aHJlYWRzAGFicwAuJS4qcwBDUkVBVEUgJXMgJS4qcwBDUkVBVEUlcyBJTkRFWCAlLipzAGludmFsaWQgdXJpIGF1dGhvcml0eTogJS4qcwB1bmtub3duIHRhYmxlIG9wdGlvbjogJS4qcwAlLipzJXMALCVzJXMlcwBTQ0FOICVzJXMlcwBzcWxpdGVfYWx0ZXJ0YWJfJXMAU0NBTiAlZCBDT05TVEFOVCBST1clcwAlUSVzACBWSVJUVUFMIFRBQkxFIElOREVYICVkOiVzACVzOiAlcy4lcy4lcwBtaXNzaW5nIGRhdGF0eXBlIGZvciAlcy4lcwBjYW5ub3Qgc3RvcmUgJXMgdmFsdWUgaW4gJXMgY29sdW1uICVzLiVzAG5vbi0lcyB2YWx1ZSBpbiAlcy4lcwBOVUxMIHZhbHVlIGluICVzLiVzACVzOiAlcy4lcwBubyBzdWNoIHRhYmxlIGNvbHVtbjogJXMuJXMALi4lcwAlLjE4cy0lcwAgVVNJTkcgSU5URUdFUiBQUklNQVJZIEtFWSAoJXMAdXNlIERST1AgVklFVyB0byBkZWxldGUgdmlldyAlcwBpbGxlZ2FsIGZpcnN0IGFyZ3VtZW50IHRvICVzAG1pc3VzZSBvZiBhbGlhc2VkIHdpbmRvdyBmdW5jdGlvbiAlcwB0b28gbWFueSBjb2x1bW5zIG9uICVzAHRvbyBtYW55IGNvbHVtbnMgaW4gJXMAJXMgcHJvaGliaXRlZCBpbiAlcwBDSEVDSyBjb25zdHJhaW50IGZhaWxlZCBpbiAlcwBub24tZGV0ZXJtaW5pc3RpYyB1c2Ugb2YgJXMoKSBpbiAlcwByZWNvdmVyZWQgJWQgcGFnZXMgZnJvbSAlcwBtaXN1c2Ugb2YgYWxpYXNlZCBhZ2dyZWdhdGUgJXMAJXMgJVQgY2Fubm90IHJlZmVyZW5jZSBvYmplY3RzIGluIGRhdGFiYXNlICVzAGNhbm5vdCBkZXRhY2ggZGF0YWJhc2UgJXMAYSBKT0lOIGNsYXVzZSBpcyByZXF1aXJlZCBiZWZvcmUgJXMAY2Fubm90IG9wZW4gdmFsdWUgb2YgdHlwZSAlcwBjYW5ub3QgZnN0YXQgZGIgZmlsZSAlcwByZWNvdmVyZWQgJWQgZnJhbWVzIGZyb20gV0FMIGZpbGUgJXMAUFJJTUFSWSBLRVkgbWlzc2luZyBvbiB0YWJsZSAlcwB1c2UgRFJPUCBUQUJMRSB0byBkZWxldGUgdGFibGUgJXMAU0VMRUNUICVzIE9SREVSIEJZIHJvd2lkICVzAFNFTEVDVCAlcyBXSEVSRSByb3dpZCBCRVRXRUVOICVsbGQgQU5EICVsbGQgT1JERVIgQlkgcm93aWQgJXMAdGhlcmUgaXMgYWxyZWFkeSBhbiBpbmRleCBuYW1lZCAlcwB0YWJsZSAlUyBoYXMgbm8gY29sdW1uIG5hbWVkICVzAHRoZXJlIGlzIGFscmVhZHkgYSB0YWJsZSBuYW1lZCAlcwBzdGF0ZW1lbnQgYWJvcnRzIGF0ICVkOiBbJXNdICVzAENPVkVSSU5HIElOREVYICVzAFNFTEVDVCAlcwB1bnN1cHBvcnRlZCB1c2Ugb2YgTlVMTFMgJXMAVVNFIFRFTVAgQi1UUkVFIEZPUiAlcwAtLSBUUklHR0VSICVzAFJJR0hULUpPSU4gJXMAPj8gQU5EICVzACV6OiAlcwByZWN1cnNpdmUgcmVmZXJlbmNlIGluIGEgc3VicXVlcnk6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBjYWxsZWQgcmVjdXJzaXZlbHk6ICVzAG5vIHN1Y2ggaW5kZXg6ICVzAG5vIHN1Y2ggd2luZG93OiAlcwBjYW5ub3Qgb3ZlcnJpZGUgJXMgb2Ygd2luZG93OiAlcwBjYW5ub3Qgb3BlbiB2aWV3OiAlcwBubyBzdWNoIHNhdmVwb2ludDogJXMAbm8gc3VjaCB2ZnM6ICVzAG11bHRpcGxlIHJlY3Vyc2l2ZSByZWZlcmVuY2VzOiAlcwBlcnJvciBpbiAlcyAlcyVzJXM6ICVzAGVycm9yIGluICVzICVzIGFmdGVyICVzOiAlcwB1bmtub3duIHRva2VuaXplcjogJXMAZXJyb3IgcGFyc2luZyBwcmVmaXggcGFyYW1ldGVyOiAlcwB1bnJlY29nbml6ZWQgcGFyYW1ldGVyOiAlcwB1bnJlY29nbml6ZWQgb3JkZXI6ICVzAHVucmVjb2duaXplZCBtYXRjaGluZm86ICVzAG5vIHN1Y2ggY29sdW1uOiAlcwBmaWxlIHJlbmFtZWQgd2hpbGUgb3BlbjogJXMAZmlsZSB1bmxpbmtlZCB3aGlsZSBvcGVuOiAlcwB1bnN1cHBvcnRlZCBlbmNvZGluZzogJXMAY2Fubm90IGxpbWl0IFdBTCBzaXplOiAlcwBNSiBkZWxldGU6ICVzAHRhcmdldCBvYmplY3QvYWxpYXMgbWF5IG5vdCBhcHBlYXIgaW4gRlJPTSBjbGF1c2U6ICVzAG9iamVjdCBuYW1lIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2U6ICVzAHVua25vd24gZGF0YWJhc2U6ICVzAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlOiAlcwBubyBzdWNoIGRhdGFiYXNlOiAlcwB0aGVyZSBpcyBhbHJlYWR5IGFub3RoZXIgdGFibGUgb3IgaW5kZXggd2l0aCB0aGlzIG5hbWU6ICVzAGR1cGxpY2F0ZSBjb2x1bW4gbmFtZTogJXMAZHVwbGljYXRlIFdJVEggdGFibGUgbmFtZTogJXMAbm8gc3VjaCBtb2R1bGU6ICVzAG11bHRpcGxlIGxpbmtzIHRvIGZpbGU6ICVzAGNhbm5vdCBvcGVuIHZpcnR1YWwgdGFibGU6ICVzAG5vIHN1Y2ggdGFibGU6ICVzAG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gcmVjdXJzaXZlIHRhYmxlOiAlcwBubyBzdWNoICVzIG1vZGU6ICVzAE1KIGNvbGxpZGU6ICVzAG5vIHN1Y2ggY29sbGF0aW9uIHNlcXVlbmNlOiAlcwBjaXJjdWxhciByZWZlcmVuY2U6ICVzAGNhbm5vdCBvcGVuIHRhYmxlIHdpdGhvdXQgcm93aWQ6ICVzACVzIG1vZGUgbm90IGFsbG93ZWQ6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBmYWlsZWQ6ICVzAGF1dG9tYXRpYyBleHRlbnNpb24gbG9hZGluZyBmYWlsZWQ6ICVzAGRhdGFiYXNlIHRhYmxlIGlzIGxvY2tlZDogJXMAZGF0YWJhc2Ugc2NoZW1hIGlzIGxvY2tlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGRpZCBub3QgZGVjbGFyZSBzY2hlbWE6ICVzAGFib3J0IGF0ICVkIGluIFslc106ICVzAC0tICVzACV6IC0gJXMAb3NfdW5peC5jOiVkOiAoJWQpICVzKCVzKSAtICVzAHdyAHJpZ2h0c3RyAGxlZnRzdHIAaW5zdHIAc3Vic3RyAGV4cHJfaW1wbGllc19leHByAGludmFsaWQgYXJndW1lbnRzIHRvIGZ0czRhdXggY29uc3RydWN0b3IAbWlzc2luZyAlcyBwYXJhbWV0ZXIgaW4gZnRzNCBjb25zdHJ1Y3RvcgB0aGUgIi4iIG9wZXJhdG9yAGZ0czNjdXJzb3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAdW5rbm93biBlcnJvcgBkb21haW4gZXJyb3IAbm90IGFuIGVycm9yAFNRTCBsb2dpYyBlcnJvcgBkaXNrIEkvTyBlcnJvcgBmbG9vcgBybWRpcgBta2RpcgBzZWdkaXIAZnRzM190b2tlbml6ZXIAdW5rbm93biB0b2tlbml6ZXIAcG93ZXIAbG93ZXIAc3FsaXRlX3RlbXBfbWFzdGVyAHNxbGl0ZV9tYXN0ZXIAcG9ydGVyAFJlc2V0U29ydGVyAEZrQ291bnRlcgBBUEkgY2FsbCB3aXRoICVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gcG9pbnRlcgBzdHJmaWx0ZXIAVkZpbHRlcgBFU0NBUEUgZXhwcmVzc2lvbiBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3RlcgBnZW5lcmF0ZV9zZXJpZXMoKSByZXF1aXJlcyBTUUxpdGUgMy44LjEyIG9yIGxhdGVyAHVwcGVyAHByb3BlcgBJZlNtYWxsZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAERyb3BUcmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBJbnRlZ2VyAFJvd2lkICVsbGQgb3V0IG9mIG9yZGVyAFJlbWFpbmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBhZGRyAHBhZHIAY2hhcgB5ZWFyAENsZWFyAEJpdE9yAHNlcQBDb2xsU2VxAEVsc2VFcQByZWdleHAAT3BlbkR1cABOb29wAEp1bXAAL3Vzci90bXAAL3Zhci90bXAAdGVtcABjdXJyZW50X3RpbWVzdGFtcABBZ2dTdGVwAG1vZGVTdGVwAHZhcmlhbmNlU3RlcABtdW5tYXAAbW1hcABtcmVtYXAAdnRhYjolcABzc2Vuc3VvAGlsc3VvAGF1dG8AR290bwBpbnRvAGluY3JlbWVudGFsX3ZhY3V1bSBlbmFibGVkIHdpdGggYSBtYXggcm9vdHBhZ2Ugb2YgemVybwBJZk5vdFplcm8ARGVjckp1bXBaZXJvAEZrSWZaZXJvAHNlcW5vAGluZGV4X3hpbmZvAHRhYmxlX3hpbmZvAG1hdGNoaW5mbwBpbmRleF9pbmZvAHRhYmxlX2luZm8AT3BlblBzZXVkbwBmY2hvd24AQmVnaW5TdWJydG4AUmV0dXJuAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgB1bmtub3duIGNvbHVtbiAiJXMiIGluIGZvcmVpZ24ga2V5IGRlZmluaXRpb24AJXMueEJlc3RJbmRleCBtYWxmdW5jdGlvbgBhdXRob3JpemVyIG1hbGZ1bmN0aW9uACUjVCgpIG1heSBub3QgYmUgdXNlZCBhcyBhIHdpbmRvdyBmdW5jdGlvbgAnJXMnIGlzIG5vdCBhIGZ1bmN0aW9uAEZ1bmN0aW9uAGNhbm5vdCBzdGFydCBhIHRyYW5zYWN0aW9uIHdpdGhpbiBhIHRyYW5zYWN0aW9uAGNhbm5vdCBjaGFuZ2UgJXMgd2FsIG1vZGUgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgB0ZW1wb3Jhcnkgc3RvcmFnZSBjYW5ub3QgYmUgY2hhbmdlZCBmcm9tIHdpdGhpbiBhIHRyYW5zYWN0aW9uAGNhbm5vdCBWQUNVVU0gZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBTYWZldHkgbGV2ZWwgbWF5IG5vdCBiZSBjaGFuZ2VkIGluc2lkZSBhIHRyYW5zYWN0aW9uAFRyYW5zYWN0aW9uAFBlcm11dGF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24AUkFOR0Ugd2l0aCBvZmZzZXQgUFJFQ0VESU5HL0ZPTExPV0lORyByZXF1aXJlcyBvbmUgT1JERVIgQlkgZXhwcmVzc2lvbgB0b28gbWFueSBsZXZlbHMgb2YgdHJpZ2dlciByZWN1cnNpb24AdXNlcl92ZXJzaW9uAHNxbGl0ZV92ZXJzaW9uAGRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgBWQ29sdW1uAGJ1aWx0aW4AYXNpbgBhdCBtb3N0ICVkIHRhYmxlcyBpbiBhIGpvaW4AbWluAG9yaWdpbgBWQmVnaW4AbWFpbgBFeHBsYWluAHNpZ24Ac3NlbgBvcGVuAElmTm90T3BlbgBTb3J0ZXJPcGVuAFZPcGVuAGhpZGRlbgBhdGFuAG1lZGlhbgBTZWVrU2NhbgBWSW5pdEluAGF1dG9fdmFjdXVtAGluY3JlbWVudGFsX3ZhY3V1bQBJbmNyVmFjdXVtAHN1bQBkcm9wIGNvbHVtbiBmcm9tAC9kZXYvdXJhbmRvbQBBZGRJbW0AcnRyaW0AbHRyaW0AcmVhZG9ubHlfc2htACVzLXNobQB0bmVtAFJBSVNFKCkgbWF5IG9ubHkgYmUgdXNlZCB3aXRoaW4gYSB0cmlnZ2VyLXByb2dyYW0AUHJvZ3JhbQBQYXJhbQBmdWwAZmNudGwAaW9jdGwAaWdvbABsb2NraW5nIHByb3RvY29sAG5jb2wAbm90bnVsbABpZm51bGwAL2Rldi9udWxsAGRhdGFiYXNlIG9yIGRpc2sgaXMgZnVsbABOb3ROdWxsAFNvZnROdWxsAElzTnVsbABaZXJvT3JOdWxsAEhhbHRJZk51bGwAY29sbABjYWNoZV9zcGlsbABSb3dDZWxsAGNlaWwAZGV0YWlsAHBhZGwAdW5peC1leGNsAHRibAB3YWwAdmlydHVhbAB0b3RhbABpbmNyZW1lbnRhbABPcGVuRXBoZW1lcmFsAEFnZ0ZpbmFsAG5vcm1hbABJbmRleCBhbHJlYWR5IG9wdGltYWwAcGFydGlhbAByZWFsAFJlYWwAcGsAb2sAdW5saW5rAHJlYWRsaW5rAEZpbmlzaFNlZWsARGVmZXJyZWRTZWVrAG5vbG9jawBDdXJzb3JVbmxvY2sAYmxvY2sAJXMubG9jawBDdXJzb3JMb2NrAFRhYmxlTG9jawBpbnRlZ3JpdHlfY2hlY2sAZm9yZWlnbl9rZXlfY2hlY2sAcXVpY2tfY2hlY2sAY2VsbF9zaXplX2NoZWNrAGludGVncml0eS1jaGVjawBGa0NoZWNrAFR5cGVDaGVjawBJbnRlZ3JpdHlDawByZXppAG5vaXRhemkAaXRpdmkAc3NlbmV2aQBpdGkAaXNzaXNpAGlzaXNpAHBpAG5vaQBnbmkAc2lzc2lpAGlzc2lzaWkAc3NzaWlpAHNlaQBpdGljaQBldGFjaQBsYWNpAGNvdGgAbW9udGgAanNvbl9hcnJheV9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAYWNvc2gAYXNpbmgAYXRhbmgAanNvbl9wYXRjaABkYXRhdHlwZSBtaXNtYXRjaABhcmd1bWVudCB0eXBlIG1pc21hdGNoAGFiYnJldmlhdGVkIHF1ZXJ5IGFsZ29yaXRobSBzZWFyY2gAdW5peGVwb2NoAHNxbGl0ZV9hdHRhY2gAc3FsaXRlX2RldGFjaABqc29uX2VhY2gAYXZnAG5hcmcAc3FsaXRlX2xvZwBzdGF0ZW1lbnQgdG9vIGxvbmcAY2Fubm90IG9wZW4gJXMgY29sdW1uIGZvciB3cml0aW5nAHN1YnN0cmluZwBTdHJpbmcAc3FsaXRlX3JldHVybmluZwBlbmNvZGluZwBzdHJpbmcgb3IgYmxvYiB0b28gYmlnAFJlbGVhc2VSZWcAJS4xNmcAJSEuMTVnAHNzZW5sdWYAcHJpbnRmAHR5cGVvZgBtb2Rlb2YAb3V0IG9mAHJlbmFtZSBjb2x1bW5zIG9mAG51bGxpZgBpaWYAb2ZmADAxMjM0NTY3ODlhYmNkZWYASWYAJTA2LjNmACUuKmYAZ2V0cGFnZXNpemUAZG9jc2l6ZQBtbWFwX3NpemUAZGVmYXVsdF9jYWNoZV9zaXplAFBSQUdNQSAlUS5wYWdlX3NpemUAZnRzM3Rva2VuaXplAG9wdGltaXplAGpzb25fcmVtb3ZlAE1vdmUAY2Fubm90IGNvbW1pdCAtIG5vIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZQBjYW5ub3Qgcm9sbGJhY2sgLSBubyB0cmFuc2FjdGlvbiBpcyBhY3RpdmUAZXhjbHVzaXZlAHRydWUASXNUcnVlAHVuaXF1ZQBkZmx0X3ZhbHVlAENhbm5vdCBhZGQgYSBSRUZFUkVOQ0VTIGNvbHVtbiB3aXRoIG5vbi1OVUxMIGRlZmF1bHQgdmFsdWUAQWdnVmFsdWUAanNvbl9xdW90ZQBwd3JpdGUAT3BlbldyaXRlAG9uX2RlbGV0ZQBzZWN1cmVfZGVsZXRlAElkeERlbGV0ZQBwcml2YXRlAGFnZ3JlZ2F0ZQBWQ3JlYXRlAG9uX3VwZGF0ZQBWVXBkYXRlAGN1cnJlbnRfZGF0ZQBmYWxsb2NhdGUAZnRydW5jYXRlAHJlcGxpY2F0ZQBiYWQgcGFyYW1ldGVyIG9yIG90aGVyIEFQSSBtaXN1c2UAdG9vIG1hbnkgdGVybXMgaW4gJXMgQlkgY2xhdXNlAHRvbyBtYW55IHRlcm1zIGluIE9SREVSIEJZIGNsYXVzZQBhZ2dyZWdhdGUgZnVuY3Rpb25zIGFyZSBub3QgYWxsb3dlZCBpbiB0aGUgR1JPVVAgQlkgY2xhdXNlAFBBUlRJVElPTiBjbGF1c2UAYSBOQVRVUkFMIGpvaW4gbWF5IG5vdCBoYXZlIGFuIE9OIG9yIFVTSU5HIGNsYXVzZQBkYXRhYmFzZSAlcyBpcyBhbHJlYWR5IGluIHVzZQBBZ2dJbnZlcnNlAHJldmVyc2UAY2xvc2UAQ2xvc2UAZmFsc2UAYXR0ZW1wdCB0byB3cml0ZSBhIHJlYWRvbmx5IGRhdGFiYXNlAGNvcnJ1cHQgZGF0YWJhc2UAYXR0YWNoZWQgZGF0YWJhc2VzIG11c3QgdXNlIHRoZSBzYW1lIHRleHQgZW5jb2RpbmcgYXMgbWFpbiBkYXRhYmFzZQBmaWxlIGlzIG5vdCBhIGRhdGFiYXNlAHRlbXBfc3RvcmUAJXMgY2xhdXNlIHNob3VsZCBjb21lIGFmdGVyICVzIG5vdCBiZWZvcmUARXhwaXJlAHNxdWFyZQBleHByX2NvbXBhcmUAU29ydGVyQ29tcGFyZQBzdWJ0eXBlAENsclN1YnR5cGUAanNvbl90eXBlAElzTnVsbE9yVHlwZQBJZk5vSG9wZQBpbHRuZQB1bml4LW5vbmUASW5pdENvcm91dGluZQBFbmRDb3JvdXRpbmUAaWNuZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHRuZW1lAGFmdGVyIHJlbmFtZQBub24tdGV4dCBmaWxlbmFtZQBWUmVuYW1lAGFtYmlndW91cyBjb2x1bW4gbmFtZQB0ZW1wb3JhcnkgdHJpZ2dlciBtYXkgbm90IGhhdmUgcXVhbGlmaWVkIG5hbWUAc2ltcGxlAGxvd2VyX3F1YXJ0aWxlAHVwcGVyX3F1YXJ0aWxlAHVuaXgtZG90ZmlsZQBjYW5ub3Qgb3BlbiBmaWxlAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlIGZpbGUAaW1tdXRhYmxlAEFib3J0YWJsZQBsZWdhY3lfYWx0ZXJfdGFibGUAc3FsaXRlX3JlbmFtZV90YWJsZQBjYW5ub3QgY3JlYXRlIHRyaWdnZXIgb24gc3lzdGVtIHRhYmxlAHZpcnR1YWwgdGFibGUAbm8gc3VjaCB0YWJsZQBudW1iZXIgb2YgY29sdW1ucyBpbiBmb3JlaWduIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHJlZmVyZW5jZWQgdGFibGUAZmlyc3QgYXJndW1lbnQgdG8gImdlbmVyYXRlX3NlcmllcygpIiBtaXNzaW5nIG9yIHVudXNhYmxlAGxvY2FsIHRpbWUgdW5hdmFpbGFibGUAYW5vdGhlciByb3cgYXZhaWxhYmxlAG5vIG1vcmUgcm93cyBhdmFpbGFibGUAVmFyaWFibGUARHJvcFRhYmxlAHV0ZjE2bGUAVVRGMTZsZQBVVEYtMTZsZQBjYXNlX3NlbnNpdGl2ZV9saWtlAFNldENvb2tpZQBSZWFkQ29va2llAGNhY2hlAGNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UAbm90aWZpY2F0aW9uIG1lc3NhZ2UAd2FybmluZyBtZXNzYWdlAGludmFsaWQgcm9vdHBhZ2UARXh0ZW5kcyBvZmYgZW5kIG9mIHBhZ2UAanNvbl90cmVlAENyZWF0ZUJ0cmVlAGRlZQBqb3VybmFsX21vZGUAbG9ja2luZ19tb2RlAG9wY29kZQB1bmljb2RlAEpvdXJuYWxNb2RlAERpdmlkZQBjb2FsZXNjZQBzcWxpdGVfc2VxdWVuY2UAU2VxdWVuY2UAZGlmZmVyZW5jZQB2YXJpYW5jZQBPbmNlAFRyYWNlAGpzb25fcmVwbGFjZQB1dGYxNmJlAFVURjE2YmUAVVRGLTE2YmUATmUATGUAR2UAMjBjOjIwZQAyMGI6MjBlACUhLjIwZQBnZXRjd2QATWFrZVJlY29yZAB0aHN0bmRyZABsaWtlbGlob29kAGZjaG1vZAByb3VuZABOb3RGb3VuZABSZXdpbmQAU2Vla0VuZABCaXRBbmQAb2xkACVsbGQgJWxsZABubyBzdWNoIHJvd2lkOiAlbGxkAHJlYnVpbGQAWWllbGQAbGFzdF9pbnNlcnRfcm93aWQAJXMucm93aWQAU0VMRUNUKkZST00iJXciLiVzIE9SREVSIEJZIHJvd2lkAFNFTEVDVCpGUk9NIiV3Ii4lcyBXSEVSRSAlcyBPUkRFUiBCWSByb3dpZABJZHhSb3dpZABOZXdSb3dpZABTZWVrUm93aWQAZ2V0ZXVpZABpbnZhbGlkAGpzb25fdmFsaWQAZmtpZABfX2xhbmdpZAAleiwgbGFuZ2lkAGxhbmd1YWdlaWQAZG9jaWQAYXBwbGljYXRpb25faWQAc3FsaXRlX3NvdXJjZV9pZABub3QgYXV0aG9yaXplZABJbmRleCBvcHRpbWl6ZWQAbm90aW5kZXhlZAB1bmFibGUgdG8gaWRlbnRpZnkgdGhlIG9iamVjdCB0byBiZSByZWluZGV4ZWQAdmlld3MgbWF5IG5vdCBiZSBpbmRleGVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgaW5kZXhlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGluZGV4ZWQAcmVhZF91bmNvbW1pdHRlZAByZWN1cnNpdmUgYWdncmVnYXRlIHF1ZXJpZXMgbm90IHN1cHBvcnRlZABxdWVyeSBhYm9ydGVkAHJvd3MgaW5zZXJ0ZWQAaW50ZXJydXB0ZWQAY2hlY2twb2ludGVkAGFjY2VzcyB0byAleiBpcyBwcm9oaWJpdGVkAGFjY2VzcyB0byB2aWV3ICIlcyIgcHJvaGliaXRlZAByb3dzIGRlbGV0ZWQAZ2VuZXJhdGVkAHJvd3MgdXBkYXRlZABub3R1c2VkAHJvdyB2YWx1ZSBtaXN1c2VkAHNxbGl0ZV9jb21waWxlb3B0aW9uX3VzZWQAUGFnZSAlZCBpcyBuZXZlciB1c2VkAENvbHVtbnNVc2VkAHN0b3JlZAB2aXJ0dWFsIHRhYmxlcyBtYXkgbm90IGJlIGFsdGVyZWQAdmlldyAlcyBtYXkgbm90IGJlIGFsdGVyZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBhbHRlcmVkAHNoYXJlZABpbmRleCBhc3NvY2lhdGVkIHdpdGggVU5JUVVFIG9yIFBSSU1BUlkgS0VZIGNvbnN0cmFpbnQgY2Fubm90IGJlIGRyb3BwZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBkcm9wcGVkAHZpZXcgJXMgaXMgY2lyY3VsYXJseSBkZWZpbmVkAHVub3BlbmVkAGRhdGFiYXNlIGRpc2sgaW1hZ2UgaXMgbWFsZm9ybWVkACVzIGNvbnN0cmFpbnQgZmFpbGVkAEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkAGxhcmdlIGZpbGUgc3VwcG9ydCBpcyBkaXNhYmxlZABmdHMzdG9rZW5pemUgZGlzYWJsZWQAZGF0YWJhc2UgJXMgaXMgbG9ja2VkAGRhdGFiYXNlIGlzIGxvY2tlZABkYXRhYmFzZSB0YWJsZSBpcyBsb2NrZWQAYXV0aG9yaXphdGlvbiBkZW5pZWQAYWNjZXNzIHBlcm1pc3Npb24gZGVuaWVkAHRhYmxlICVTIGhhcyAlZCBjb2x1bW5zIGJ1dCAlZCB2YWx1ZXMgd2VyZSBzdXBwbGllZAB0ZW1wb3JhcnkgdGFibGUgbmFtZSBtdXN0IGJlIHVucXVhbGlmaWVkAHRhYmxlICVzIG1heSBub3QgYmUgbW9kaWZpZWQAY29uZmxpY3RpbmcgT04gQ09ORkxJQ1QgY2xhdXNlcyBzcGVjaWZpZWQAbm8gdGFibGVzIHNwZWNpZmllZABkYXRhYmFzZSBpcyBhbHJlYWR5IGF0dGFjaGVkAGRhdGFiYXNlIHNjaGVtYSBoYXMgY2hhbmdlZABleGNsdWRlZABQb2ludGVyIG1hcCBwYWdlICVkIGlzIHJlZmVyZW5jZWQAUm93U2V0QWRkAEZpbHRlckFkZABwcmVhZABSb3dTZXRSZWFkAE9wZW5SZWFkACUwNGQAJTAzZAAlMDJkADQwZi0yMWEtMjFkAHNxbGl0ZV9zdGF0JWQAY29sdW1uJWQAc3FsaXRlX2F1dG9pbmRleF8lc18lZAB2YXJpYWJsZSBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuID8xIGFuZCA/JWQARmFpbGVkIHRvIHJlYWQgcHRybWFwIGtleT0lZAB1bmFibGUgdG8gZ2V0IHRoZSBwYWdlLiBlcnJvciBjb2RlPSVkAE9mZnNldCAlZCBvdXQgb2YgcmFuZ2UgJWQuLiVkAGsoJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHJvb3RwYWdlPSVkIFdIRVJFICMlZCBBTkQgcm9vdHBhZ2U9IyVkAFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0eXBlPSclcycsIG5hbWU9JVEsIHRibF9uYW1lPSVRLCByb290cGFnZT0jJWQsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9J3RhYmxlJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPTAsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAdG9vIG1hbnkgYXR0YWNoZWQgZGF0YWJhc2VzIC0gbWF4ICVkAHRvbyBtYW55IGFyZ3VtZW50cyBvbiAlcygpIC0gbWF4ICVkAGV4cGVjdGVkICVkIGNvbHVtbnMgZm9yICclcycgYnV0IGdvdCAlZABhdHRlbXB0IHRvIG9wZW4gIiVzIiBhcyBmaWxlIGRlc2NyaXB0b3IgJWQAaW52YWxpZCBwYWdlIG51bWJlciAlZABmYWlsZWQgdG8gZ2V0IHBhZ2UgJWQAMm5kIHJlZmVyZW5jZSB0byBwYWdlICVkAGZyZWVsaXN0IGxlYWYgY291bnQgdG9vIGJpZyBvbiBwYWdlICVkAGJ0cmVlSW5pdFBhZ2UoKSByZXR1cm5zIGVycm9yIGNvZGUgJWQAJXMgaXMgJWQgYnV0IHNob3VsZCBiZSAlZAAlciAlcyBCWSB0ZXJtIG91dCBvZiByYW5nZSAtIHNob3VsZCBiZSBiZXR3ZWVuIDEgYW5kICVkAHN1Yi1zZWxlY3QgcmV0dXJucyAlZCBjb2x1bW5zIC0gZXhwZWN0ZWQgJWQASU4oLi4uKSBlbGVtZW50IGhhcyAlZCB0ZXJtJXMgLSBleHBlY3RlZCAlZAAlc0xJU1QgU1VCUVVFUlkgJWQAUkVVU0UgTElTVCBTVUJRVUVSWSAlZAAlc1NDQUxBUiBTVUJRVUVSWSAlZABSRVVTRSBTVUJRVUVSWSAlZABJTkRFWCAlZAB0b28gbWFueSBGUk9NIGNsYXVzZSB0ZXJtcywgbWF4OiAlZAByd2MAdXRjAGRlc2MAYXNjAGNoZWNrcG9pbnRfZnVsbGZzeW5jAGZ1bGxfZnN5bmMAY2hhcmluZGV4RnVuYwBzcXJ0RnVuYwBjb3RGdW5jAHJpZ2h0RnVuYwBsZWZ0RnVuYwBhY29zRnVuYwBmbG9vckZ1bmMAcG93ZXJGdW5jAHN0cmZpbHRlckZ1bmMAcHJvcGVyRnVuYwBwYWRyRnVuYwBleHBGdW5jAGFzaW5GdW5jAHNpZ25GdW5jAGF0YW5GdW5jAGNlaWxGdW5jAHBhZGxGdW5jAGNvdGhGdW5jAGFjb3NoRnVuYwBhc2luaEZ1bmMAYXRhbmhGdW5jAGxvZ0Z1bmMAcmFkMmRlZ0Z1bmMAcmV2ZXJzZUZ1bmMAUHVyZUZ1bmMAc3F1YXJlRnVuYwBkaWZmZXJlbmNlRnVuYwBkZWcycmFkRnVuYwBwYWRjRnVuYwBhdG4yRnVuYwBsb2cxMEZ1bmMAZW5jAG51bWVyaWMAMT09YXJnYwBTcWxFeGVjAHBhZGMAJS40YyVzJS4xNmMAc3FsaXRlLXNyYy9zcWxpdGUtYW1hbGdhbWF0aW9uLTMzOTAzMDAvZXh0ZW5zaW9uLWZ1bmN0aW9ucy5jAHNxbGl0ZS1zcmMvc3FsaXRlLWFtYWxnYW1hdGlvbi0zMzkwMzAwL3Nlcmllcy5jACVzL2V0aWxxc18lbGx4JWMAdW5yZWNvZ25pemVkIG1hdGNoaW5mbyByZXF1ZXN0OiAlYwBHb3N1YgBnbG9iAHplcm9ibG9iAHJhbmRvbWJsb2IAQmxvYgBpbGIAaXRpbGliAG1lbWRiAEFUVEFDSCAlUSBBUyB2YWN1dW1fZGIAcm90YQBldml0YQBsYW5vaXRhAGV0YQBSb3dEYXRhAFNvcnRlckRhdGEAaWNuYQBzcWxpdGVfdGVtcF9zY2hlbWEAc3FsaXRlX3NjaGVtYQB3cml0YWJsZV9zY2hlbWEAdHJ1c3RlZF9zY2hlbWEAY29ycnVwdCBzY2hlbWEAUGFyc2VTY2hlbWEAaWxsYQBlemlsYQBpdGlsYQBtc2lsYQBzcWxpdGVfAHByYWdtYV8AU1FMSVRFXwBfUk9XSURfACVzIGF0IGxpbmUgJWQgb2YgWyUuMTBzXQBiaW5kIG9uIGEgYnVzeSBwcmVwYXJlZCBzdGF0ZW1lbnQ6IFslc10AbWFsZm9ybWVkIE1BVENIIGV4cHJlc3Npb246IFslc10AWyVkXQBbXQBbMF0AJFsATEVGVC1NT1NUIFNVQlFVRVJZAENPTVBPVU5EIFFVRVJZAEFOWQBnZW5lcmF0ZWQgY29sdW1ucyBjYW5ub3QgYmUgcGFydCBvZiB0aGUgUFJJTUFSWSBLRVkAQVVUT0lOQ1JFTUVOVCBpcyBvbmx5IGFsbG93ZWQgb24gYW4gSU5URUdFUiBQUklNQVJZIEtFWQBkb2NpZCBJTlRFR0VSIFBSSU1BUlkgS0VZAEZPUkVJR04gS0VZAFJJR0hUIFBBUlQgT0YgT1JERVIgQlkAR1JPVVAgQlkAaWlzWABpc2lYAEFVVE9NQVRJQyBQQVJUSUFMIENPVkVSSU5HIElOREVYAEFVVE9NQVRJQyBDT1ZFUklORyBJTkRFWAAtbWolMDZYOSUwMlgAU0NBTiBDT05TVEFOVCBST1cAVklFVwBqc29uX29iamVjdCgpIGxhYmVscyBtdXN0IGJlIFRFWFQARklSU1QATEFTVABFWENFUFQATk9UACBJTlQASWR4TFQAU2Vla0xUAFNFVCBERUZBVUxUAE1VVEVYX09NSVQAQ09NTUlUAExJTUlUAFJJR0hUAElkeEdUAFNlZWtHVABMRUZUAERJU1RJTkNUAFJFU1RSSUNUAElOVEVSU0VDVAB0b28gbWFueSB0ZXJtcyBpbiBjb21wb3VuZCBTRUxFQ1QAdW5rbm93biBqb2luIHR5cGU6ICVUJXMlVCVzJVQALSVUAHRvbyBtYW55IGFyZ3VtZW50cyBvbiBmdW5jdGlvbiAlVAB1bmtub3duIGRhdGFiYXNlICVUAGZvcmVpZ24ga2V5IG9uICVzIHNob3VsZCByZWZlcmVuY2Ugb25seSBvbmUgY29sdW1uIG9mIHRhYmxlICVUAENSRUFURSBWSVJUVUFMIFRBQkxFICVUAGhleCBsaXRlcmFsIHRvbyBiaWc6ICVzJSNUAG5vIHN1Y2ggZnVuY3Rpb246ICUjVABub3QgYXV0aG9yaXplZCB0byB1c2UgZnVuY3Rpb246ICUjVABERUZBVUxUX1JFQ1VSU0lWRV9UUklHR0VSUwBJTlMARU5BQkxFX0ZUUzNfUEFSRU5USEVTSVMARElTQUJMRV9MRlMAJXMgJVMAbm8gc3VjaCBpbmRleDogJVMAY2Fubm90IGNyZWF0ZSAlcyB0cmlnZ2VyIG9uIHZpZXc6ICVTAG5vIHN1Y2ggdHJpZ2dlcjogJVMAY2Fubm90IGNyZWF0ZSBJTlNURUFEIE9GIHRyaWdnZXIgb24gdGFibGU6ICVTAE1BVEVSSUFMSVpFICUhUwBDTy1ST1VUSU5FICUhUwBVU0lORyBJTkRFWCAlcyBGT1IgSU4tT1BFUkFUT1IAVVNJTkcgUk9XSUQgU0VBUkNIIE9OIFRBQkxFICVzIEZPUiBJTi1PUEVSQVRPUgBNVUxUSS1JTkRFWCBPUgBTUUxJVEVfVE1QRElSAEFGVEVSAElOVEVHRVIAT1JERVIATkVBUgBERUxFVEUgRlJPTSAlUS4lcyBXSEVSRSAlcz0lUQBuYW1lPSVRIEFORCBzcWw9JVEAREVMRVRFIEZST00gJVEuc3FsaXRlX3NlcXVlbmNlIFdIRVJFIG5hbWU9JVEALCB4LiVRAFNFTEVDVCAqIEZST00gJVEuJVEAVVBEQVRFICIldyIuc3FsaXRlX3NlcXVlbmNlIHNldCBuYW1lID0gJVEgV0hFUkUgbmFtZSA9ICVRAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHByaW50ZignJSUuJWRzLCAnLHNxbCkgfHwgJVEgfHwgc3Vic3RyKHNxbCwxK2xlbmd0aChwcmludGYoJyUlLiVkcycsc3FsKSkpIFdIRVJFIHR5cGUgPSAndGFibGUnIEFORCBuYW1lID0gJVEAU0VUVVAAR1JPVVAAUkVDVVJTSVZFIFNURVAATmFOAG1hbGZvcm1lZCBKU09OAE5PIEFDVElPTgBPTUlUX0xPQURfRVhURU5TSU9OAFVOSU9OACBMRUZULUpPSU4AQkVHSU4ALGFyZyBISURERU4ALHNjaGVtYSBISURERU4AU0NBTgBERUZBVUxUX0FVVE9WQUNVVU0AIE5VTQBSVFJJTQBDYW5ub3QgYWRkIGEgTk9UIE5VTEwgY29sdW1uIHdpdGggZGVmYXVsdCB2YWx1ZSBOVUxMAE5PVCBOVUxMAFNFVCBOVUxMAFNFTEVDVCAxIEZST00gJVEuJyVxX3NlZ21lbnRzJyBXSEVSRSBibG9ja2lkPT8gQU5EIGJsb2NrIElTIE5VTEwAVU5JT04gQUxMACBSRUFMAENIRUNLAGFib3J0IGR1ZSB0byBST0xMQkFDSwBNQVRDSABTRUFSQ0gAVVNJTkcARU5BQkxFX05PUk1BTElaRQAgVU5JUVVFAERFTEVURQBVUERBVEUAUkVMRUFTRQBOT0NBU0UAQkVGT1JFAENSRQBOT05FAElkeExFAFNlZWtMRQBUQUJMRQAxNkxFAElkeEdFAFNlZWtHRQAlcyBVU0lORyBURU1QIEItVFJFRQBDQVNDQURFADE2QkUAQU5EAFJPV0lEAE9JRABERVNDAFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8gT1JERVIgQlkgaWR4IEFTQwBTRUxFQ1QgaWR4LCBzdGFydF9ibG9jaywgbGVhdmVzX2VuZF9ibG9jaywgZW5kX2Jsb2NrLCByb290IEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/T1JERVIgQlkgbGV2ZWwgREVTQywgaWR4IEFTQwBTRUxFQ1QgbGV2ZWwsIGlkeCwgZW5kX2Jsb2NrIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/IE9SREVSIEJZIGxldmVsIERFU0MsIGlkeCBBU0MAU0VMRUNUIGlkeCBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsPT8gT1JERVIgQlkgMSBBU0MAU1lTVEVNX01BTExPQwBCTE9CAEJCQgBVUERBVEUgT1IgRkFJTCAlUS4nJXFfc2VnZGlyJyBTRVQgbGV2ZWw9LTEsaWR4PT8gV0hFUkUgbGV2ZWw9PyBBTkQgaWR4PT8AVVBEQVRFICVRLiclcV9zZWdkaXInIFNFVCBpZHggPSA/IFdIRVJFIGxldmVsPT8gQU5EIGlkeD0/ACVzPT8AU0VMRUNUICVzIFdIRVJFIHJvd2lkPT8AU0VMRUNUIHNpemUgRlJPTSAlUS4nJXFfZG9jc2l6ZScgV0hFUkUgZG9jaWQ9PwBTRUxFQ1QgdmFsdWUgRlJPTSAlUS4nJXFfc3RhdCcgV0hFUkUgaWQ9PwA/LD8sPwBERUxFVEUgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID8AU0VMRUNUIG1heChsZXZlbCkgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ21lbnRzJyBXSEVSRSBibG9ja2lkIEJFVFdFRU4gPyBBTkQgPwBVUERBVEUgJVEuJyVxX3NlZ2RpcicgU0VUIHN0YXJ0X2Jsb2NrID0gPywgcm9vdCA9ID9XSEVSRSBsZXZlbCA9ID8gQU5EIGlkeCA9ID8AU0VMRUNUIGlkeCwgc3RhcnRfYmxvY2ssIGxlYXZlc19lbmRfYmxvY2ssIGVuZF9ibG9jaywgcm9vdCBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPyBBTkQgaWR4ID0gPwBERUxFVEUgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8gQU5EIGlkeCA9ID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/AFNFTEVDVCBjb3VudCgqKSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPwBTRUxFQ1QgJXMgV0hFUkUgcm93aWQgPSA/AERFTEVURSBGUk9NICVRLiclcV9jb250ZW50JyBXSEVSRSByb3dpZCA9ID8AREVMRVRFIEZST00gJVEuJyVxX2RvY3NpemUnIFdIRVJFIGRvY2lkID0gPwAsID8APGV4cHI+ADxiPgA8Yj4uLi48L2I+AC0+PgAtPgBzZXBhcmF0b3JzPQB0b2tlbmNoYXJzPQBhdXRvbWVyZ2U9ADwASU5TRVJUIElOVE8gJVEuc3FsaXRlX21hc3RlciBWQUxVRVMoJ2luZGV4JywlUSwlUSwjJWQsJVEpOwBDUkVBVEUgVEFCTEUgJVEuJyVxX3NlZ21lbnRzJyhibG9ja2lkIElOVEVHRVIgUFJJTUFSWSBLRVksIGJsb2NrIEJMT0IpOwBDUkVBVEUgVEFCTEUgJVEuJyVxX2RvY3NpemUnKGRvY2lkIElOVEVHRVIgUFJJTUFSWSBLRVksIHNpemUgQkxPQik7AENSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICVRLiclcV9zdGF0JyhpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCB2YWx1ZSBCTE9CKTsAQ1JFQVRFIFRBQkxFICVRLiclcV9zZWdkaXInKGxldmVsIElOVEVHRVIsaWR4IElOVEVHRVIsc3RhcnRfYmxvY2sgSU5URUdFUixsZWF2ZXNfZW5kX2Jsb2NrIElOVEVHRVIsZW5kX2Jsb2NrIElOVEVHRVIscm9vdCBCTE9CLFBSSU1BUlkgS0VZKGxldmVsLCBpZHgpKTsAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHRibF9uYW1lID0gJVEsIG5hbWUgPSBDQVNFIFdIRU4gdHlwZT0ndGFibGUnIFRIRU4gJVEgV0hFTiBuYW1lIExJS0UgJ3NxbGl0ZVhfYXV0b2luZGV4JSUnIEVTQ0FQRSAnWCcgICAgICBBTkQgdHlwZT0naW5kZXgnIFRIRU4gJ3NxbGl0ZV9hdXRvaW5kZXhfJyB8fCAlUSB8fCBzdWJzdHIobmFtZSwlZCsxOCkgRUxTRSBuYW1lIEVORCBXSEVSRSB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSBBTkQgKHR5cGU9J3RhYmxlJyBPUiB0eXBlPSdpbmRleCcgT1IgdHlwZT0ndHJpZ2dlcicpOwBEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfc2VnbWVudHMnO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9zZWdkaXInO0RST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9kb2NzaXplJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfc3RhdCc7JXMgRFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX2NvbnRlbnQnOwBBTFRFUiBUQUJMRSAlUS4nJXFfY29udGVudCcgIFJFTkFNRSBUTyAnJXFfY29udGVudCc7AEFMVEVSIFRBQkxFICVRLiclcV9zdGF0JyAgUkVOQU1FIFRPICclcV9zdGF0JzsAQUxURVIgVEFCTEUgJVEuJyVxX3NlZ21lbnRzJyBSRU5BTUUgVE8gJyVxX3NlZ21lbnRzJzsAQUxURVIgVEFCTEUgJVEuJyVxX3NlZ2RpcicgICBSRU5BTUUgVE8gJyVxX3NlZ2Rpcic7AEFMVEVSIFRBQkxFICVRLiclcV9kb2NzaXplJyAgUkVOQU1FIFRPICclcV9kb2NzaXplJzsAOm1lbW9yeToAZmlsZToAU3RyaW5nOAB1dGY4ADIwMjItMDktMDUgMTE6MDI6MjMgNDYzNWY0YTY5YzhjMmE4ZGYyNDJiMzg0YTk5MmFlYTcxMjI0ZTM5YTJjY2FiNDJkOGMwYjA2MDJmMWU4MjZlOABVVEY4AFVURi04AE1BWF9GVU5DVElPTl9BUkc9MTI3AERFRkFVTFRfU0VDVE9SX1NJWkU9NDA5NgBERUZBVUxUX1BBR0VfU0laRT00MDk2AE1BWF9WQVJJQUJMRV9OVU1CRVI9MzI3NjYATUFYX1BBR0VfU0laRT02NTUzNgBVVEYxNgBVVEYtMTYAcDUAdG9vIG1hbnkgcmVmZXJlbmNlcyB0byAiJXMiOiBtYXggNjU1MzUAc3FsaXRlX3N0YXQ0AGZ0czQAcDQAREVGQVVMVF9GSUxFX0ZPUk1BVD00AEludDY0AHB3cml0ZTY0AHByZWFkNjQATUFMTE9DX1NPRlRfTElNSVQ9MTAyNABzcWxpdGVfc3RhdDMAU0FWRVBPSU5UIGZ0czMAUk9MTEJBQ0sgVE8gZnRzMwBSRUxFQVNFIGZ0czMAcDMARU5BQkxFX0ZUUzMATUFYX1BBR0VfQ09VTlQ9MTA3Mzc0MTgyMwBwMgBhdG4yAGF0YW4yAHJlbW92ZV9kaWFjcml0aWNzPTIAREVGQVVMVF9TWU5DSFJPTk9VUz0yAERFRkFVTFRfV0FMX1NZTkNIUk9OT1VTPTIAYXJnYz09MyB8fGFyZ2M9PTIAaUNvbD49MCAmJiBpQ29sPD0yAE1BWF9ERUZBVUxUX1BBR0VfU0laRT04MTkyAFNFTEVDVCB0YmwsaWR4LHN0YXQgRlJPTSAlUS5zcWxpdGVfc3RhdDEAQWdnU3RlcDEAcmVtb3ZlX2RpYWNyaXRpY3M9MQBBVE9NSUNfSU5UUklOU0lDUz0xAFRFTVBfU1RPUkU9MQBhcmdjPT0xAHVuaWNvZGU2MQBVUERBVEUgT1IgRkFJTCAlUS4nJXFfc2VnZGlyJyBTRVQgbGV2ZWw9PyBXSEVSRSBsZXZlbD0tMQBERUZBVUxUX0pPVVJOQUxfU0laRV9MSU1JVD0tMQBTRUxFQ1QgbGV2ZWwsIGNvdW50KCopIEFTIGNudCBGUk9NICVRLiclcV9zZWdkaXInICAgR1JPVVAgQlkgbGV2ZWwgSEFWSU5HIGNudD49PyAgT1JERVIgQlkgKGxldmVsICUlIDEwMjQpIEFTQywgMiBERVNDIExJTUlUIDEAU0VMRUNUIChTRUxFQ1QgbWF4KGlkeCkgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8pICsgMQBTRUxFQ1QnSU5TRVJUIElOVE8gdmFjdXVtX2RiLid8fHF1b3RlKG5hbWUpfHwnIFNFTEVDVCpGUk9NIiV3Ii4nfHxxdW90ZShuYW1lKUZST00gdmFjdXVtX2RiLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIGNvYWxlc2NlKHJvb3RwYWdlLDEpPjAAU0VMRUNUIHNxbCBGUk9NICIldyIuc3FsaXRlX3NjaGVtYSBXSEVSRSB0eXBlPSd0YWJsZSdBTkQgbmFtZTw+J3NxbGl0ZV9zZXF1ZW5jZScgQU5EIGNvYWxlc2NlKHJvb3RwYWdlLDEpPjAAcmVtb3ZlX2RpYWNyaXRpY3M9MABNQVhfV09SS0VSX1RIUkVBRFM9MABERUZBVUxUX1dPUktFUl9USFJFQURTPTAATUFYX01NQVBfU0laRT0wAERFRkFVTFRfTU1BUF9TSVpFPTAAVEhSRUFEU0FGRT0wADkyMjMzNzIwMzY4NTQ3NzU4MABERUZBVUxUX1BDQUNIRV9JTklUU1o9MjAAbG9nMTAATUFYX0FUVEFDSEVEPTEwAE1BWF9DT01QT1VORF9TRUxFQ1Q9NTAwAD8wMDAATUFYX0NPTFVNTj0yMDAwAERFRkFVTFRfQ0FDSEVfU0laRT0tMjAwMABERUZBVUxUX1dBTF9BVVRPQ0hFQ0tQT0lOVD0xMDAwAE1BWF9FWFBSX0RFUFRIPTEwMDAATUFYX1RSSUdHRVJfREVQVEg9MTAwMABNQVhfTElLRV9QQVRURVJOX0xFTkdUSD01MDAwMABNQVhfVkRCRV9PUD0yNTAwMDAwMDAATUFYX0xFTkdUSD0xMDAwMDAwMDAwAE1BWF9TUUxfTEVOR1RIPTEwMDAwMDAwMDAAc2Vjb25kIGFyZ3VtZW50IHRvICUjVCgpIG11c3QgYmUgYSBjb25zdGFudCBiZXR3ZWVuIDAuMCBhbmQgMS4wAENPTVBJTEVSPWNsYW5nLTE2LjAuMAAvcHJvYy9zZWxmL2ZkLwAlUS4ATi4AJC4ALS0ALABub3NraXBzY2FuKgB1bm9yZGVyZWQqAHN6PVswLTldKgAoc3VicXVlcnktJXUpAChqb2luLSV1KQBDUkVBVEUgVEFCTEUgeCh0eXBlIHRleHQsbmFtZSB0ZXh0LHRibF9uYW1lIHRleHQscm9vdHBhZ2UgaW50LHNxbCB0ZXh0KQBDUkVBVEUgVEFCTEUgJVEuJXMoJXMpAGF1dG9tYXRpYyBpbmRleCBvbiAlcyglcykAQU5ZKCVzKQBJTlNFUlQgSU5UTyAlUS4nJXFfY29udGVudCcgVkFMVUVTKCVzKQBDUkVBVEUgVEFCTEUgJVEuJyVxX2NvbnRlbnQnKCVzKQBtYWxmb3JtZWQgZGF0YWJhc2Ugc2NoZW1hICglcykATUVSR0UgKCVzKQBDUkVBVEUgVEFCTEUgJVEuc3FsaXRlX3NlcXVlbmNlKG5hbWUsc2VxKQBDUkVBVEUgVEFCTEUgeChpbnB1dCwgdG9rZW4sIHN0YXJ0LCBlbmQsIHBvc2l0aW9uKQBDUkVBVEUgVEFCTEUgeCh2YWx1ZSxzdGFydCBoaWRkZW4sc3RvcCBoaWRkZW4sc3RlcCBoaWRkZW4pAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9kcm9wX2NvbHVtbiglZCwgc3FsLCAlZCkgV0hFUkUgKHR5cGU9PSd0YWJsZScgQU5EIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlKQBtZW1kYiglcCwlbGxkKQBCYWQgcHRyIG1hcCBlbnRyeSBrZXk9JWQgZXhwZWN0ZWQ9KCVkLCVkKSBnb3Q9KCVkLCVkKQAlcyglZCkAemVyb2Jsb2IoJWQpAG1heCByb290cGFnZSAoJWQpIGRpc2FncmVlcyB3aXRoIGhlYWRlciAoJWQpAEZUUyBleHByZXNzaW9uIHRyZWUgaXMgdG9vIGxhcmdlIChtYXhpbXVtIGRlcHRoICVkKQBFeHByZXNzaW9uIHRyZWUgaXMgdG9vIGxhcmdlIChtYXhpbXVtIGRlcHRoICVkKQAoYmxvYikAVVNFIFRFTVAgQi1UUkVFIEZPUiAlcyhESVNUSU5DVCkAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9jb2x1bW4oc3FsLCB0eXBlLCBuYW1lLCAlUSwgJVEsICVkLCAlUSwgJWQsICVkKSBXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnICBBTkQgKHR5cGUgIT0gJ2luZGV4JyBPUiB0YmxfbmFtZSA9ICVRKQBDUkVBVEUgVEFCTEUgeChrZXksdmFsdWUsdHlwZSxhdG9tLGlkLHBhcmVudCxmdWxsa2V5LHBhdGgsanNvbiBISURERU4scm9vdCBISURERU4pAENSRUFURSBUQUJMRSB4KHRlcm0sIGNvbCwgZG9jdW1lbnRzLCBvY2N1cnJlbmNlcywgbGFuZ3VhZ2VpZCBISURERU4pAENSRUFURSBUQUJMRSB4KCVzICVRIEhJRERFTiwgZG9jaWQgSElEREVOLCAlUSBISURERU4pAChOVUxMKQAlYz8pAFNFTEVDVCBOT1QgRVhJU1RTKFNFTEVDVCBkb2NpZCBGUk9NICVRLiclcV9jb250ZW50JyBXSEVSRSByb3dpZCE9PykAUkVQTEFDRSBJTlRPICVRLiclcV9zZWdkaXInIFZBTFVFUyg/LD8sPyw/LD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9zdGF0JyBWQUxVRVMoPyw/KQBSRVBMQUNFIElOVE8gJVEuJyVxX2RvY3NpemUnIFZBTFVFUyg/LD8pACwlcyg/KQBSRVBMQUNFIElOVE8gJVEuJyVxX3NlZ21lbnRzJyhibG9ja2lkLCBibG9jaykgVkFMVUVTKD8sID8pAFNFTEVDVCBjb2FsZXNjZSgoU0VMRUNUIG1heChibG9ja2lkKSBGUk9NICVRLiclcV9zZWdtZW50cycpICsgMSwgMSkASU5TRVJUIElOVE8gdmFjdXVtX2RiLnNxbGl0ZV9zY2hlbWEgU0VMRUNUKkZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGUgSU4oJ3ZpZXcnLCd0cmlnZ2VyJykgT1IodHlwZT0ndGFibGUnQU5EIHJvb3RwYWdlPTApAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gc25pcHBldCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICVzKCkAbWlzdXNlIG9mICVzIGZ1bmN0aW9uICUjVCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJSNUKCkAdW5zYWZlIHVzZSBvZiAlI1QoKQBGSUxURVIgbWF5IG5vdCBiZSB1c2VkIHdpdGggbm9uLWFnZ3JlZ2F0ZSAlI1QoKQB1bmtub3duIGZ1bmN0aW9uOiAlI1QoKQBtaXN1c2Ugb2YgYWdncmVnYXRlOiAlI1QoKQBhbWJpZ3VvdXMgcmVmZXJlbmNlIHRvICVzIGluIFVTSU5HKCkAVVBEQVRFIHRlbXAuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9jb2x1bW4oc3FsLCB0eXBlLCBuYW1lLCAlUSwgJVEsICVkLCAlUSwgJWQsIDEpIFdIRVJFIHR5cGUgSU4gKCd0cmlnZ2VyJywgJ3ZpZXcnKQBVUERBVEUgc3FsaXRlX3RlbXBfc2NoZW1hIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3RhYmxlKCVRLCB0eXBlLCBuYW1lLCBzcWwsICVRLCAlUSwgMSksIHRibF9uYW1lID0gQ0FTRSBXSEVOIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlIEFORCAgIHNxbGl0ZV9yZW5hbWVfdGVzdCglUSwgc3FsLCB0eXBlLCBuYW1lLCAxLCAnYWZ0ZXIgcmVuYW1lJywgMCkgVEhFTiAlUSBFTFNFIHRibF9uYW1lIEVORCBXSEVSRSB0eXBlIElOICgndmlldycsICd0cmlnZ2VyJykALCVzKHguJ2MlZCVxJykASU5TRVJUIElOVE8gJVEuc3FsaXRlX21hc3RlciBWQUxVRVMoJ3RyaWdnZXInLCVRLCVRLDAsJ0NSRUFURSBUUklHR0VSICVxJykAU0VMRUNUIDIgKiB0b3RhbCgxICsgbGVhdmVzX2VuZF9ibG9jayAtIHN0YXJ0X2Jsb2NrKSAgIEZST00gKFNFTEVDVCAqIEZST00gJVEuJyVxX3NlZ2RpcicgICAgICAgICBXSEVSRSBsZXZlbCA9ID8gT1JERVIgQlkgaWR4IEFTQyBMSU1JVCA/ICApAAopAEJMT09NIEZJTFRFUiBPTiAlUyAoAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0naW5kZXgnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0naW5kZXgnAG5hbWU9JyVxJyBBTkQgdHlwZT0naW5kZXgnAERFTEVURSBGUk9NICVRLiclcV9jb250ZW50JwBERUxFVEUgRlJPTSAlUS4nJXFfc3RhdCcAREVMRVRFIEZST00gJVEuJyVxX3NlZ21lbnRzJwBERUxFVEUgRlJPTSAlUS4nJXFfc2VnZGlyJwBTRUxFQ1QgPyBVTklPTiBTRUxFQ1QgbGV2ZWwgLyAoMTAyNCAqID8pIEZST00gJVEuJyVxX3NlZ2RpcicAU0VMRUNUIG1heCggbGV2ZWwgJSUgMTAyNCApIEZST00gJVEuJyVxX3NlZ2RpcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSBuYW1lPSVRIEFORCB0eXBlPSd0cmlnZ2VyJwBERUxFVEUgRlJPTSAlUS5zcWxpdGVfbWFzdGVyIFdIRVJFIHRibF9uYW1lPSVRIGFuZCB0eXBlIT0ndHJpZ2dlcicAdGJsX25hbWU9JyVxJyBBTkQgdHlwZSE9J3RyaWdnZXInACclLipxJwAleiwgJ2MlZCVxJwB0eXBlPSd0cmlnZ2VyJyBBTkQgbmFtZT0nJXEnACwgeC4nJXEnAGluZGV4ICclcScASlNPTiBwYXRoIGVycm9yIG5lYXIgJyVxJwBERUxFVEUgRlJPTSAlUS4nJXFfZG9jc2l6ZScAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV90YWJsZSglUSwgdHlwZSwgbmFtZSwgc3FsLCAlUSwgJVEsICVkKSBXSEVSRSAodHlwZSE9J2luZGV4JyBPUiB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSlBTkQgICBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnAFNFTEVDVCBDQVNFIFdIRU4gcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBUSEVOIHJhaXNlKEFCT1JULCdDSEVDSyBjb25zdHJhaW50IGZhaWxlZCcpIEVMU0UgcmFpc2UoQUJPUlQsJ05PVCBOVUxMIGNvbnN0cmFpbnQgZmFpbGVkJykgRU5EICBGUk9NIHByYWdtYV9xdWlja19jaGVjayglUSwlUSkgV0hFUkUgcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBPUiBxdWlja19jaGVjayBHTE9CICdOVUxMKicAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9xdW90ZWZpeCglUSwgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAVVBEQVRFIHRlbXAuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9xdW90ZWZpeCgndGVtcCcsIHNxbClXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnIEFORCBzcWwgTk9UIExJS0UgJ2NyZWF0ZSB2aXJ0dWFsJSUnAHNxbGl0ZVxfJQAkAFNFTEVDVCpGUk9NIiV3IgBTRUxFQ1QgcmFpc2UoQUJPUlQsJVEpIEZST00gIiV3Ii4iJXciAEFOQUxZWkUgIiV3Ii4iJXciAGZvcmVpZ24ga2V5IG1pc21hdGNoIC0gIiV3IiByZWZlcmVuY2luZyAiJXciAGRvdWJsZS1xdW90ZWQgc3RyaW5nIGxpdGVyYWw6ICIldyIAc3ludGF4IGVycm9yIGFmdGVyIGNvbHVtbiBuYW1lICIlLipzIgAlYyIlcyIAKCIlcyIAY2Fubm90ICVzICVzICIlcyIAZ2VuZXJhdGVkIGNvbHVtbiBsb29wIG9uICIlcyIAY2Fubm90IElOU0VSVCBpbnRvIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBlcnJvciBpbiBnZW5lcmF0ZWQgY29sdW1uICIlcyIAY2Fubm90IFVQREFURSBnZW5lcmF0ZWQgY29sdW1uICIlcyIAJXMgaW4gIiVzIgBVUFNFUlQgbm90IGltcGxlbWVudGVkIGZvciB2aXJ0dWFsIHRhYmxlICIlcyIAdW5zYWZlIHVzZSBvZiB2aXJ0dWFsIHRhYmxlICIlcyIAY2Fubm90IGNyZWF0ZSBhIFRFTVAgaW5kZXggb24gbm9uLVRFTVAgdGFibGUgIiVzIgBubyBzdWNoIGluZGV4OiAiJXMiAHVua25vd24gZGF0YXR5cGUgZm9yICVzLiVzOiAiJXMiAGNhbm5vdCBkcm9wICVzIGNvbHVtbjogIiVzIgBubyBzdWNoIGNvbHVtbjogIiVzIgBubyBzdWNoIGNvbHVtbjogIiVUIgB1bnJlY29nbml6ZWQgdG9rZW46ICIlVCIAd2Vla2RheSAAbm9uLXVuaXF1ZSBlbnRyeSBpbiBpbmRleCAAd3JvbmcgIyBvZiBlbnRyaWVzIGluIGluZGV4IAAgbWlzc2luZyBmcm9tIGluZGV4IAByb3cgACVyIABzdGFydCBvZiAAJWQgJWQgJWQgJWQgACBVU0lORyBDT1ZFUklORyBJTkRFWCAAU0VMRUNUIDEgRlJPTSAiJXciLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJyBBTkQgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsICVkLCAlUSwgJWQpPU5VTEwgAFNFTEVDVCAxIEZST00gdGVtcC5zcWxpdGVfbWFzdGVyIFdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScgQU5EIHNxbGl0ZV9yZW5hbWVfdGVzdCglUSwgc3FsLCB0eXBlLCBuYW1lLCAxLCAlUSwgJWQpPU5VTEwgACBVU0lORyAAQ1JFQVRFIABDUkVBVEUgVEFCTEUgACBBTkQgAENPUlJFTEFURUQgAFBSQUdNQSAAUGFnZSAldTogAE1haW4gZnJlZWxpc3Q6IABPbiBwYWdlICV1IGF0IHJpZ2h0IGNoaWxkOiAAT24gdHJlZSBwYWdlICV1IGNlbGwgJWQ6IAAtLSAAJXolUSwgACIldyIgAEAgIAAsCiAgACoqKiBpbiBkYXRhYmFzZSAlcyAqKioK");
  base64DecodeToExistingUint8Array(bufferView, 29632, "ZAoBEAAAcwAEBQAAZwABAx4AegAEBgAAcQAECQAAUQAECgAAdwAEDgAAYwAACAAAbwgAAAACdQoAEAAAeBAAABABWBAAAAAEZgABAQAAZQABAh4ARQABAg4ARwABAw4AaQoBEAAAbgAABAAAJQAABwAAcBAADQABVAAACwAAUwAADAAAcgoBDwAAAAAAAAAAMDEyMzQ1Njc4OUFCQ0RFRjAxMjM0NTY3ODlhYmNkZWYALXgwAFgw");
  base64DecodeToExistingUint8Array(bufferView, 29830, "4D+amZmZmZmpP3sUrkfhenQ//Knx0k1iQD8tQxzr4jYKP/Fo44i1+NQ+je21oPfGoD5Ir7ya8tdqPjqMMOKOeTU+ldYm6AsuAT4AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6W1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AQAAAQEAAAEAAQABAQABAAABAAB/AAAAgAAAAIEAAAAEBQMFAQUBBQIFAgUBBQEFBAUDBQEFAQUCBQIFAQUBBQIFAwUCBQIFAgUCBQIFAgUEBQMFAgUCBQIFAgUCBQIFqQAAAHAAAAAeAAUBXgAAAVQBAABGAAAAKj9bACVfAAE=");
  base64DecodeToExistingUint8Array(bufferView, 30297, "AQEBAQE=");
  base64DecodeToExistingUint8Array(bufferView, 30320, "AQCAAEAAAIAAAAAAAAAAAAwMDAwMDAwMDAwAAAAAAAAACgoKCgoKAgICAgICAgICAgICAgICAgICAgKAAAAAQIAqKioqKioiIiIiIiIiIiIiIiIiIiIiIiIiIgAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEABBAMCBQ==");
  base64DecodeToExistingUint8Array(bufferView, 30560, "UkVJTkRFWEVERVNDQVBFQUNIRUNLRVlCRUZPUkVJR05PUkVHRVhQTEFJTlNURUFEREFUQUJBU0VMRUNUQUJMRUZUSEVOREVGRVJSQUJMRUxTRVhDTFVERUxFVEVNUE9SQVJZSVNOVUxMU0FWRVBPSU5URVJTRUNUSUVTTk9UTlVMTElLRVhDRVBUUkFOU0FDVElPTkFUVVJBTFRFUkFJU0VYQ0xVU0lWRVhJU1RTQ09OU1RSQUlOVE9GRlNFVFJJR0dFUkFOR0VORVJBVEVERVRBQ0hBVklOR0xPQkVHSU5ORVJFRkVSRU5DRVNVTklRVUVSWVdJVEhPVVRFUkVMRUFTRUFUVEFDSEJFVFdFRU5PVEhJTkdST1VQU0NBU0NBREVGQVVMVENBU0VDT0xMQVRFQ1JFQVRFQ1VSUkVOVF9EQVRFSU1NRURJQVRFSk9JTlNFUlRNQVRDSFBMQU5BTFlaRVBSQUdNQVRFUklBTElaRURFRkVSUkVESVNUSU5DVFVQREFURVZBTFVFU1ZJUlRVQUxXQVlTV0hFTldIRVJFQ1VSU0lWRUFCT1JUQUZURVJFTkFNRUFORFJPUEFSVElUSU9OQVVUT0lOQ1JFTUVOVENBU1RDT0xVTU5DT01NSVRDT05GTElDVENST1NTQ1VSUkVOVF9USU1FU1RBTVBSRUNFRElOR0ZBSUxBU1RGSUxURVJFUExBQ0VGSVJTVEZPTExPV0lOR0ZST01GVUxMSU1JVElGT1JERVJFU1RSSUNUT1RIRVJTT1ZFUkVUVVJOSU5HUklHSFRST0xMQkFDS1JPV1NVTkJPVU5ERURVTklPTlVTSU5HVkFDVVVNVklFV0lORE9XQllJTklUSUFMTFlQUklNQVJZAAAAAAAAAAACAAIACAAJAA4AEAAUABcAGQAZAB0AIQAkACkALgAwADUANgA7AD4AQQBDAEUATgBRAFYAWgBaAF4AYwBlAGkAbwB3AHsAewB7AH4AgQCEAIkAjgCSAJMAmACcAKAAqACuALUAuAC4ALsAvQDDAMYAzgDTANgA2wDeAOIA7ADvAPQA9AD4APwAAwEJAQ8BFQEVARsBHAEgAScBKwEyATgBRAFNAU8BVQFaAVwBYwFnAXIBeQF6AYEBhwGNAZIBmAGcAZ8BqAGtAbEBtwG5AbwBxQHHAckB0gHWAdwB4gHqAe8B7wHvAf8BCAILAg8CFAIbAiACKQItAjACNQI3AjsCQwJJAkwCVQJaAmICYgJmAm8CdAJ5An8CggKFAogCigKPApMC");
  base64DecodeToExistingUint8Array(bufferView, 31536, "BwcFBAYEBQMGBwMGBgcHAwgCBgUEBAMKBAcGCQQCBgUJCQQHAwIEBAYLBgIHBQUJBgoEBgIDBwUJBgYEBQUKBgUHBAUHBgcHBgUHAwcEBwYMCQQGBQQHBgwICAIGBgcGBAUJBQUGAwQJDQICBAYGCAURDAcJBAQGBwUJBAQFAgUIBgQJBQgEAwkFBQYEBgICCQMH");
  base64DecodeToExistingUint8Array(bufferView, 31696, "6gMAAABAAADrAwAAAAAEAPcDAAAAAACA7AMAAAAAQADtAwAAAAABAO4DAAAACAAA7wMAAAAAgADwAwAAAAAAAfEDAAAAAAAC8gMAAAAAABDzAwAAAQAACPQDAAAAAAAE9gMAAAAAACD1AwAAAAAAQPgDAAACAAAA+QMAAIAAAAAAypo7AMqaO9AHAADoAwAA9AEAAICy5g5/AAAACgAAAFDDAAD+fwAA6AMAAAAAAAADAAAAggAAAIMAAACEAAAAhQAAAIYAAACHAAAAiAAAAIkAAACKAAAAiwAAAIwAAACNAAAAjgAAAI8AAACQAAAAkQAAAJIAAACTAAAAAwAAAKoAAACDAAAAhAAAAIUAAACGAAAAhwAAAKsAAACsAAAArQAAAIsAAACMAAAAjQAAAAAAAACPAAAAkAAAAJEAAACSAAAAkwAAAAEAAACuAAAAgwAAAIQAAACFAAAAhgAAAIcAAACvAAAAsAAAALEAAACLAAAAjAAAAI0AAAAAAAAAjwAAAJAAAACRAAAAkgAAAJMAAAADAAAAsgAAALMAAAC0AAAAtQAAALYAAAC3AAAAuAAAALgAAAAAAAAAuQAAAAAAAAC6");
  base64DecodeToExistingUint8Array(bufferView, 32168, "uwAAALw=");
  base64DecodeToExistingUint8Array(bufferView, 32184, "AQAAAL0AAAC+AAAAvwAAAMAAAADBAAAAwg==");
  base64DecodeToExistingUint8Array(bufferView, 32260, "2dUF+SChY9c=");
  base64DecodeToExistingUint8Array(bufferView, 32304, "U1FMaXRlIGZvcm1hdCAzAAABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fAAECAwQFBgcICQoLDA0ODwABAgMEBQYHAAECAwABAABCSU5BUlk=");
  base64DecodeToExistingUint8Array(bufferView, 32400, "zVIAACZYAABbTQAAik0AAKwJAABGCwAA3ScAAKEJAADsNgAAiyoAAFQiAADqMAAAHiUAAGpEAABzMwAAAjgAAPMKAACkJAAANTcAAE0vAABGCQAATTMAALMGAABICQAAa0cAAE5NAABmTQAAokcAACkqAABaMwAAjQwAALk3AAC8NwAAgjgAANINAAD2CAAAyCIAAAUJAAALCQAAwjcAANEHAAAnBwAA3QcAAEhNAACcRwAAZUcAAGBNAAB6JAAA1DcAAOY9AADZCAAAEisAAHYlAADKEQAAjisAAH0rAABmNwAAjSQAABwNAABpNwAAGQ0AAGw3AACJJAAAXyUAAGklAACHKgAA3AcAAFUiAABBCwAAUUMAANUmAADbJQAAgTMAAKArAAArCwAAzSMAAP1YAACnLgAAzyUAAKYrAACFKwAAiUQAAOY1AADDLwAA2QQAANgEAADQBAAA+iwAAKkGAACBJAAAtCoAABkEAAD7CAAA6ScAACgzAAArMAAAlSsAAOoLAADLKQAAAi0AAB0EAACNNwAAeQkAADA2AAAmNgAADQYAANE3AAB3JAAA4AsAANALAADcPQAAwwwAAOcEAAD4NgAA7SMAABINAADxPQAAmjAAAD8JAACXJAAAuQUAALtXAAABLAAAMyoAAOQIAAC9JQAANTIAALg6AABXKgAAnwsAABg3AAB5OAAALAkAALwrAAC/MAAAdAkAACIzAADVRAAAzUQAAIY4AAC1BgAAyTcAABwJAAAmCQAAvDAAAGgsAABwOAAAXSwAAN8EAABxJAAAByIAALM2AACwQwAANEUAAH4TAADvNQAA/wUAAEIsAAD0IgAADC0AAMw9AAAaKwAAEyIAAB8GAACTCwAAHDIAANIkAABJWgAAfzAAAA8sAAAHMwAAlywAAHwsAACiLAAABioAANgwAADeBAAAPioAAGAqAADKKQAA4TMAAEwJAAC9CgAAODMAANY9AAA6NwAAEgoAAN8uAACfJAAAEioAAJc0AAAAAAAAcEwAABRNAADTTAAAlEYAAAAAAAABAgACAgABAgEBAQIBAhAAAgI=");
  base64DecodeToExistingUint8Array(bufferView, 33217, "AQIDBAYICAAAAAAAAAEBAgIDAwQEBQUGBgcHCAgJCQoKCwsMDA0NDg4PDxAQERESEhMTFBQVFRYWFxcYGBkZGhobGxwcHR0eHh8fICAhISIiIyMkJCUlJiYnJygoKSkqKisrLCwtLS4uLy8wMDExMjIzMzQ0NTU2Njc3ODg5ORBAAkA=");
  base64DecodeToExistingUint8Array(bufferView, 33360, "YUcAAM5MAABFRwAATU8AAL5MAAAAAQIDBAYIAAAAAADIMwAA+SgAAGkpAAAhACAAHgAcABo=");
  base64DecodeToExistingUint8Array(bufferView, 33424, "tTAAADoIAAA4LwAACjEAAKIEAADjKwAAAQEDAAUABgAI");
  base64DecodeToExistingUint8Array(bufferView, 33480, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 33504, "HRwcHBwcHBwcBwccBwccHBwcHBwcHBwcHBwcHBwcHBwHDwgFBBYYCBESFRQXCxoQAwMDAwMDAwMDAwUTDA4NBgUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQACAgkcHBwCCAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAICHAocGRwbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxseGxsbGxsbGxsbGxsbGxsbG1RchlJpHQAAXgBVSAA1I1YPACphNlmHEwAAjAAogQAWawAJAAB7UABOBgBBZ5MAiHMAADAAWhgAEQAbRhcaBTyObnoASVtHkT14SgAxAAspAHEAAABtCm90fQ4yfABkABJ5kDiCi1hTJR5+AABsM4OAACIAAIQAYiYnABQtdV0AYnShJzopfEMhhD4/LwJBoyYYihB2nwuDoFuAFRUrMlINiV4zE0J5L4gGHHN2okcJFHeXRUSCTVlfKJMvBXZ9ewMaUXYOIDCYXJIjH3idcRFkCI9/LgQeRmEHjC2Bi1BgnpVIGx1jLIVXfg8xJDwKJXZkZFVYKlSmSVNWjnaUEpFKXaWWdgxMS1qGkE5PpD0iQId6");
  base64DecodeToExistingUint8Array(bufferView, 34052, "BAArAABqcgAAAAIAAI8AAAANAAAAAI0AAHc0AACJDAAAPgCKAIUAACQAABxNAAAAADsALw==");
  base64DecodeToExistingUint8Array(bufferView, 34114, "RQAAAAAAkgMAOgABSwAAAB8AAAAAAH8AaABAQj8AAAAAAC4AEAg=");
  base64DecodeToExistingUint8Array(bufferView, 34162, "UWUAcBUHQwBPYHYAAEQAAGMsADcATABfICE5GQBmAABX");
  base64DecodeToExistingUint8Array(bufferView, 34212, "EAABAAEBAQMDAQEDAwMBEgkJCQkBCQkJCQkJAQEBAQEBAQEBAQEBJiYjCwEBAwMDCwsLCwsLAQMDAQEBAQAAAgIIABAQEAAQABAQAAAQEAAAAAICAgAAEh4gAAAAABAQAAAmJiYmJiYmJiYmAAASAAAQAAAAAAAAAAAQEAAAAAAAAAAQAAAEBAAAEAAQAAAQAAAAAAAQAAAGEAAEGg==");
  base64DecodeToExistingUint8Array(bufferView, 34382, "EAAAEBAC");
  base64DecodeToExistingUint8Array(bufferView, 34400, "XSQAAN02AABPWgAAjlkAAGVZAADkWAAAqFgAAGAKAADuOAAAJgoAAG46AADJKw==");
  base64DecodeToExistingUint8Array(bufferView, 34456, "wwAAAMQAAADFAAAAAAAAAMYAAADHAAAAyAAAAMkAAADKAAAAywAAAMw=");
  base64DecodeToExistingUint8Array(bufferView, 34544, "UQsAAAEQ");
  base64DecodeToExistingUint8Array(bufferView, 34560, "0TgAAAIUAAAIAAAAAAAAAGgqAAADlQ==");
  base64DecodeToExistingUint8Array(bufferView, 34592, "xwUAAAQUAAAAgAAAAAAAAPMHAAAFEDgBAAAAAAAAAACCLwAABpU=");
  base64DecodeToExistingUint8Array(bufferView, 34640, "sCsAAAeU");
  base64DecodeToExistingUint8Array(bufferView, 34656, "EjYAAAgC");
  base64DecodeToExistingUint8Array(bufferView, 34672, "2iwAAAQUAAAAACAAAAAAAERCAAAEFAAAEAAAAAAAAABsCAAACRAmAgAAAAAAAAAA0BEAAAoQ");
  base64DecodeToExistingUint8Array(bufferView, 34736, "xhUAAAQUAAAAAAAAAQAAAK8oAAACGAAADwAAAAAAAAB7CAAADBAvAwAAAAAAAAAAei8AAA2VNwEAAAAAAAAAAB8NAAAEFAAAAAAIAAAAAABnEwAABBQAAAABAAAAAAAAvy4AAA4U");
  base64DecodeToExistingUint8Array(bufferView, 34848, "vCwAAA9xKwQAAAAAAAAAAEIIAAAQYQAIAAAAAAAAAAAlDQAABBQAAABAAAAAAAAAVgkAAAIY");
  base64DecodeToExistingUint8Array(bufferView, 34912, "KBQAAAQUAAAEAAAAAAAAAE9CAAAEFAAACAAAAAAAAABeCAAAERAbBgAAAAAAAAAAcAsAABIQ");
  base64DecodeToExistingUint8Array(bufferView, 34976, "3A0AAAQUAAAAAgAAAAAAAHQqAAATAw==");
  base64DecodeToExistingUint8Array(bufferView, 35008, "pyUAABRhFQMAAAAAAAAAAFMIAAAVYSYFAAAAAAAAAACFJQAAFGEVBgEAAAAAAAAArCwAABZx");
  base64DecodeToExistingUint8Array(bufferView, 35072, "wzYAABeR");
  base64DecodeToExistingUint8Array(bufferView, 35088, "gAsAABiQ");
  base64DecodeToExistingUint8Array(bufferView, 35104, "oTQAAAQUAAAAAAAEAAAAANA2AAAakA==");
  base64DecodeToExistingUint8Array(bufferView, 35136, "ZQkAABuR");
  base64DecodeToExistingUint8Array(bufferView, 35152, "cC8AABw=");
  base64DecodeToExistingUint8Array(bufferView, 35168, "iQgAAB0QCQEAAAAAAAAAAK4vAAAeIQ==");
  base64DecodeToExistingUint8Array(bufferView, 35200, "aQkAABuR");
  base64DecodeToExistingUint8Array(bufferView, 35216, "ly8AAB+U");
  base64DecodeToExistingUint8Array(bufferView, 35232, "pwgAACAQCQEAAAAAAAAAAPAEAAAEFAAAAAAQAAAAAADOLAAAFnE=");
  base64DecodeToExistingUint8Array(bufferView, 35280, "oDkAAAQUAAAABAAAAAAAAE0QAAAEFAAAACAAAAAAAAA5DwAABBQAAAAQAAAAAAAAvCgAAAIUAAABAAAAAAAAAK4wAAAhEA==");
  base64DecodeToExistingUint8Array(bufferView, 35360, "FRQAAAQUAABAAAAAAAAAAGcEAAAiAg==");
  base64DecodeToExistingUint8Array(bufferView, 35392, "YAsAACMQ");
  base64DecodeToExistingUint8Array(bufferView, 35408, "ZA0AACSV");
  base64DecodeToExistingUint8Array(bufferView, 35424, "siUAACVhCAYAAAAAAAAAAJwIAAAmIQ8GAAAAAAAAAACRJQAAJWEIBwEAAAAAAAAA0jIAACcU");
  base64DecodeToExistingUint8Array(bufferView, 35488, "KwQAACgE");
  base64DecodeToExistingUint8Array(bufferView, 35504, "FBYAACkQ");
  base64DecodeToExistingUint8Array(bufferView, 35520, "FkUAAAQUAACAAAAAAAAAAJMoAAACFAAABgAAAAAAAAB/CQAAKg==");
  base64DecodeToExistingUint8Array(bufferView, 35568, "kgkAACsBMgMAAAAAAAAAAAZFAAAEFAAAAQAACAAAAADuOAAAfSQAAGI1AACiKgAAJSUAAOAwAACkMAAA+y0AAM04AAAoNAAASDMAAEsrAAA5MAAARywAAEQqAAAtRQAAKDQAAEgzAABGKwAAmSAAAIYMAAB/JQAAzTgAACg0AAA7QgAAqysAADUFAAAoNAAA0ikAAEgzAACcQwAAWC4AAJATAADfKwAACQYAAKwtAADbCwAAixMAAH0kAAAoNAAAMjAAAP8pAAA1LAAAYjUAAGo4AAAmCgAApzgAAH0kAAAoNAAAiDQAACYEAABkLgAAAzoAAMkyAABdDQAAgi8AAPgHAAADAgE=");
  base64DecodeToExistingUint8Array(bufferView, 35844, "OwA7ADsAOwAAADsAOwA7AAAAOwA7ADsAOwAAAAAAAAA7AAAAAAA7");
  base64DecodeToExistingUint8Array(bufferView, 35892, "OwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7AAAAAAAAADsAOw==");
  base64DecodeToExistingUint8Array(bufferView, 35960, "OwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7ADsAOwA7");
  base64DecodeToExistingUint8Array(bufferView, 36224, "//3//QD////+/v79+/r/AP3/APv+AP3+//4A/Pr+AAD+/fz8/P39+/78/P/+/fwA/wD+/v39/f7+///+/f4A/v4A//75+/v2AAD9AP7///z+APf8//38//3//v/39vz7//8AAPv9+/4AAP7+APv6+Pr6AP7//f/9+/3//v38/vwAAP3+AP37/f//AP7+AAD9AP4A/vz8+gD+AP7+/Pf7+f37+fgA/vT3+/j+/v8A/f3//f///fv//////fr7/Pr7//v9/f39/f39/f79+/79/fz6+/7+/v3//vv//vv9+/v8+/v8/gD/AAD9/wD99P8AAP37/QD+/P79/gD9+/r7+v7++/X//gD///0A/v3+/f3+9/j6/fz6/////Pr9AP7//f/9+vn6//j//PgA//3//v3//v36//3//fv7+vz7//4A/fr///7//v7+AP7+/v/+/v///P77//7///79AP/+/wD+//z+//////////4A/vz+/v3/AP/////+//8A////////////AP3/AP8AAP///f4A/P4=");
  base64DecodeToExistingUint8Array(bufferView, 36640, "cAbFBfgEQgFCAQEAJwXGBdMFLQctBy0H1wEAAAAA1gBFBC0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HDwEPAcMEwwTYAFgAAQABAAEAAQABACgAbwACAWkB1QEAAkcCbgK1AtwCIwNKA5EDMQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRZBEUEwAS9A70DYwZ+BvEGLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQeJALUAtQC1ALUAtQC1ALUAXgCuAUIAQQBwAG4BFQIVAuQC7QQVAhUCTwBPABUCnAGcAZwBTQCcAXsAcQBxABYAFgAyCDIISAFIAUgB7wDUAdQB1AHUAfcD9wOZAW4BaQSiBBUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQLJA20CbQIVAoICFAMUA8wEzAQ2AzYDQwD6BDIIMggyCDIIMggyCDIIGwW6A7oDSQLYAYACgwG3AhoCHQK8AhUCFQIVAhUCFQIVAhUCFQIVAhUC3gAVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQKbBJsEmwQVAhUCFQI1AhUCFQIVApQDeAQVAhUCCAUVAhUCFQIVAhUCFQIVAhUCfwIyBdEANAQ0BDQENAREAtEA0QAhBQADlQOJAp0EJAWVASQF1gT5AJ0EnQT5AJ0ElQHWBFkF0AHrBPQD9AP0A1gFWAVYBVgFuAC4AC4FiAMHBcgFsAawBmEGYQbdBt0GYQZvBnMG9wbkBv8G/wb/Bv8GYQYOB40GcwZzBo0G9wbkBo0G5AaNBmEGDgeKBvMGYQYOBx8HYQYOB2EGDgcfB8QGxAbEBgIHMAcwBx8HxAbKBsQGAgfEBsQGpQY0B94G3gYfB2EG/Qb9Bg8HDwfOBtgGVQdhBs8GzgbfBuUGjQZXB2kHaQd6B3oHegcyCDIIMggyCDIIMggyCDIIMggyCDIIMggyCDIIMgjPAEcESwFsAocDJgMyBMsFmAXJBSoFWgVyBesFCwUKBgsGFQY7Bj4GPwaaBa0FUga2BR8G0QVsBnYGUAZ8BgwGDQaSBpUGPQbmApUHmQeHB/sGkQeUB44HkAcdBxIHKAeSB5IHlgceB5sHIAedB7AHJAcxB5IHMgd4B5MHkgciB4EHggeFB4YHOgdJB5wHMwe+B7wHrAdQByMHiAeyB4kHgwemBzgHXQe5B78HwQdPB1gHwAeXB8IHwwfEB8YHmgejB8cHdwfFB8oHnwfIB8wHUQfOB9AH0QfSB9MH1AfPB40HYgfZB9oHdgfVB9wHZAfbB9YH1wfYB90HngeqB6UH3gexB6AH3wfnB+oH6wfpB+wH4gd5B3sH7wfbB/EH9Af1B/YH9wf4B/sHAwj8B/0H/gf/BwEIAggACJgHjwehB6IHpAcECAcIBQgZCBoIwQDBAMEAEgETARQBwQASARMBFAHBAN8A2wDhAM4A0gDTANQAwQATANsA6QDYANgA2QDYANkAwQAnAdgA2QAfAMEA2ADZAMEA5ADVAOYAJwDOANgA2QArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDBABMAuQC6ALsAvAC9AL4A/QASARMBFAHDAMEAxQDBAAUBEgETARQB/QDMAO4AzABRACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABIBEwEUAQYBZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA7wDwAO8A8ADSANMA1AA6ATsBOgE7ADwBVgD8AFgA/AATADoBOwEAAQEBcQAZAEgAKAGKAIsACgFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQBRACQBOwAkASoBbABtAG4AbwBwAHEARQB0AHUAdgBIAGoAawDBAG8AcABxADYANwA4ADkAOgBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQB4ABkA2ADZAJEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA5wCKAIsAdAB1AHYApACZABMAmwA2ADcAOAA5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAIAAgQAuAC8AMAAxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ANgAwQAZADsAwQATAKUApgDBAEMAGABmAGcAaABpAGoAawBsAG0AbgBvAHAAcQBJANgA2QA7ANgA2QArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQB5AJEAOwDBAHQAdQB2AHcAEQHMAHoAewB8ABMAFACGABYAiACJABMAhAB/AIAAgQAYABYAFwB0AHUAdgAkAMEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA7wDwADcBOAHXAGoAawDxABMAOwDYANkA3wD8AHMAdAB1AHYAlwB4ABoARwDBADQBNQHBAJUAgAA5AdgADQFRACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AP0A2ADZAGQAXwCZADsAmwAFAWoAawAZAMEAZQDBAMEA5wByABkAdAB1AHYAcQAwAXkAwQDMADsAdwB4AHkAegB7AHwAfQDYANkAwQDYANkAgwCKAIsA5gBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQCZAJoAmwCcAJ0A7wDwAHQAdQB2AEwAwQAXABMAGQAWAP0AFwD8AP0AbABXAMwAWQAFAcYAXAAFAXQAdQB2AMEAMgEzAdgA2QCWACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADsAwQDYANkAEwDvAPAAGwEXAGoAawBsAG0AbgBvAHAAcQBJAPwA/QCOADQBNQGKAIsAUQA5AZEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAMwFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAZAXQAdQB2AB0BFwDBABkAdwA7AMEAegB7AHwAOwB/AMsAOwDNABMADAGEABkAFwAWAMEAigCLAPkAzAD7AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABMAFgAXADsAFwAZAO8A8AB0AHUAdgDBAAsAdAB1AHYAdAB1AHYA/AANARYAwQAPACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABEBjwDBAHYAjwBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQBMAHYAOwDxAHQAdQB2ADAB2ADZACQBjwA8AFkA8QATAFwAwQDBABcAFgA3ATgB5wBlABYAjwBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQATAMEAwQA7ABcAdAB1AHYAOwDJABUA8QAwARYAzgB/AIAAgQDBAIAAgQDrAOwAMAErACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAWAMEA2ADZAMEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA5wDBAMEAwQB0AHUAdgDYANkAdAB1AHYA4gBQAMEAEwDrAOwAMAEXANMA1ADnAMwA2ADZAM0AZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAEwDBAHsATADvAPAAwQD9AO8A8ADvAPAAwQBqAGsAwQBZAPwAwQBcADsA/ACNAPwAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAHAGhANgA2QDBAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAOcAwQAQALsAvAC9AL4ABwAIAAkANQHDABkAxQA5ARMAfwCAAIEABgHMABYAdQAYANgA2QAHAWYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMEA7wDwAMEAOwATALwA/QC+AE0A4gBPAMEAwwD8AMUAwQATAC0BLgHBAMEAzADYANkA4gDYANkACgHMAJ8ALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAMAO8A8ADoACoB7gB1AP0A7wDwAO4AAwEEAcEA/AAbAB8AwQDBAI4AzAD8AMEAwQAnAAYBwQBkAAoBFgEqAMwAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAdQCfANgA2QB5ANgA2QA/AMEAwQDBAO8A8ABzAHQAwQAqAUkA7gDuAOcAEwDvAPAA/AAWABgA0wDUABgAwQDYANkA2ADZAPwAmQCaAJsA/QAQABMAkADVAAwBKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkA7gATADsAwQA7ACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABYAFwDBABkAwQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAcAU0AwQBPAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAB4BwQDBAMEAdQAjAXUA6ABmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDMABYAFwBCABkA2ADZACMAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAwQAMAVUAZQDBADUBNQHwABMAOQE5AV4A0ADRAMEA7wDwAMEAQgD8ABMADAH0ANgA2QDBAEoA1QD8AKEAEwAHAf4ALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMEA2ADZAAUAOwDBABMA9AAKAAsADAANAA4AZQA1AREAkgD+ADkBwQDBAEwAcwDYANkANQEMAAcBHgA5ASAALgBXAC4AWQCCAMEAXAAoABYABwEbANgA2QBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAqAJYAIwHYANkAdAB1AHYAEwAUAMEAFgBGAAQBdADBABgACAHBAAcBTgA/AD0AUQB0ACQAwQAEAcEAHQDBAAgBwQAhAJEAwQA7ADAA2ADZAGIA2ADZAMEAcwDBAHMAwQA7ANgA2QDYANkA2ADZANgA2QD/ANgA2QBHAMEAgwDBABkAQQDYANkA2ADZANgA2QDQANEAVQCFAMEAZADBAFoAigCLAIoAiwDYANkA2ADZAMEAZADBAGwAhwB0AHUAagBrAIwAeQDYANkA2ADZAHIAogB0AHUAdgArASwBeQDYANkA2ADZAMEA9ADBAIcA9ADBAAABAQGMAPQAwQD+AMEAwQD+AJkAmgCbAI0A/gCVAJYAAgHYANkA2ADZAJkAmgCbAJwAnQAAAAEAAgDYANkABQBzAJ4AwQCgAAoACwAMAA0ADgDBADsAEQB+AMEAEwAUAIEAFgDBABYAFgAYAMEAFwAeABkAIAATABQAkAAWACQA2ADZACgAwQDYANkAwQCYAIEA2ADZAMEAJADYANkAwQBjAMEAwQA1AMEAwQA7ABcAwQAZANgA2QDBANgA2QCYAEYAOwBHADsAdQDBANgA2QBOANgA2QBRANgA2QA+AUcAVQDBAIUAwQDBAFoAFwAXABkAGQB4AHkAYgBVAMEAZADBABcAWgAZAHkAagBrABMA2ADZANgA2QBkAHIAgwB0AHUAdgBqAGsAeQDYANkA2ADZAMEAcgB1AHQAdQB2AIUAwQB5AMEAwQCKAIsAwQAXAMEAGQAXABcAGQAZAAcACADYANkAwQDBAJkAmgCbAJwAnQDYANkAwQCiANgA2QDYANkAmQCaAJsAnACdAAEAAgDBAMEABQATABQAOwAWAAoACwAMAA0ADgDBAGEAEQDBABcAwQAZACABJADBAPIA2ADZAOwAFwAeABkAIAATABQAFwAWABkA2ADZACgA2ADZANgA2QDBADsA2ADZAMEAJABTAFQAmQCZAJsAmwAXAEcAGQAXAMEAGQDBAMEAwQB1AMEAwQDBAEYAwQDBADsAwQD/AP8AHwFOAP8A8wBRAL8A/wApAUcADwFkACUB9QALAdYA9gBqAGsAbAD2AA8BYgD1ACUBcgDcAHQAdQB2AAsBDwF5AA8B4QDbAOUA2wBkANsAAwEDAQMBAwFqAGsA+QDEADwAGAGNAPMAcgD5AHQAdQB2AIUA9QB5AMgAKQGKAIsAmQCaAJsAnACdACkByAAmABMAFACXABYAyACWAIwAJgEmARYAEAErAOoAEgCiAA4ByAAkAO0AmQCaAJsAnACdAO0AGwHtAO0AEgDHAJUA9gAQAQ4BEAHIAJ4A9gD2AOoAOwDqAPYAxwAiAT4AIQHIAMcAFgDdAHMARwDIAMgAxwDHAN0A2gDaABMAFABAABYA2gDjABYA4AB+AOAApQDdABgAMQHIAHEAOAEkANoA3ADaAGQAGgHaAFsA2gA9AWoAawDdAOMAGgE9AVIAlAByAAkBdAB1AHYAOwCRAHkAFgAVAZ4AyAAJARkAygCTAPoARwAXAQ0AkgDCAMIA+QD4APoAjAD3APYABgDAAMAAwAAvAS8B1QDPACwB1QCZAJoAmwCcAJ0A1QDVAGQA1QDeAM8A1gDWAGoAawAEAN4AzwADABYAowByAA8AdAB1AHYAEAAXAHkAFwCLAJcAggAZAI4AEAAYABQAkAABAI4AggCCAD0ANQA1ACUAlwA1ADUAggB0ACIAAQCNAAUAFgBzAKEAjQCZAJoAmwCcAJ0AGQBEAEQASwApAHMAGACDABQAEwB9ABYAYAAWABYAQwAXABYAQwA7ABgAFgAcAEMAFwAWABYAlQAXABcAFwB0ABcAGQAlAGEAjQAXABcAFgCPABkASwBYACIAIgAiACIAVgBLAF0AFwAiABYAIgAZABgAIgAZABcAjgAXAI4ALAAXABcAFwALABcAGQAWABYAFgAPABcAFwAWABYAGQABAAEAjQAZABcAhwA/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BjQCNAD8BjQA/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8B");
  base64DecodeToExistingUint8Array(bufferView, 42368, "OALQADgCdgBzAOUAOAJ2AHMA5QA4AiIFeQENBZgBMgIyAjICOAKZAXoBIgX8BCkAKQApACkA0AD2BUcARwDLA6MBKQApAOsBLwEXAS8BzAONAUcARwB9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfADcAZkB2QQBAAEAPwICAN0EJgJ2AHMA5QA9AeABkgDgAQwCdgBzAOUAEQIvBaEBCwKOAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AHYAcwDlAEcBegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBHAEcARwBHAG6AboBugEfBngBIQaoBHcBiwQ1AosENQKZAR8GGQIDAeIAvAFlAJEAwQE8AS8C8AB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAF9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfACOACYBqARTAcABeAB4AHgAdwB0ALwBfwCoBKkEqgSUALkBuAE4AncAdAC8AXwAfAB8AHwAdQB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAHGAXEADQANACICegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBpgE8AS8CqASpBKoElQDIBJkByAR8AHwAfAB8AHoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AdEBVgENBA0EGwQeBH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AP8ECgLeAKgEOAKZAeAAAgKvAFIAUwB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAHvAxAAEACoBIUAhQB9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfAB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAERBCICqAR1AagEqQSqBPwAmgWPAfgB9QH0AW8AMAI2AgQAngOeA7EB8wFUAcwBSAFoAYoB1QSoBKkEqgQzAjgCegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBHAEcAXEBLAZHBrkBuAGaAJkBvQFHAEcABgU1AsUEqASpBKoEVQDHBA8BLQIfAgMCGQY4AmIAxgQGAP4E2AGOAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8ACYCDQANAAME+wHIBKgEyAQlAm0AbQDeADgC1gSvADgCqwFuAMUAvQE6AjkCrgEQBvkDRQEnAqgEDgEfAXAB/gFrAf0BAQFHAEcAHwJHAEcAZwE8AS8CTQZ6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAH5A/kD+wP8AxsAHAEcAagEqQSqBIYEOAJMBpkBhQO+ACYCZAE1AiYCqQMVAgUChgQEAp0BhgQoAqgEqQSqBDgCIAISBjMAMwDWAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AKgE2gGHAIcAmQEcARwB0gX5AXkAeQB4AHgAeAB3AHQAvAHvAzUCBgLZAB0CGQY8AS8CjgAGABQCfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAEwZ6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAHlAagEqQSqBOIBGQHzBL0D/ACoBHUB+AH1AfQBqARUATsCqAQ7ApkBJAHzAb0DbAO/AOABPAEvAoABIgF8AXoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AX0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AJkBigFwBKgEZQNkABwBHAGoBKkEqgR1AUUEqASpBKoEqASpBKoENQLHASAAdQHpAH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AJkFvwM4AuQAvgN6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAGGBOQAqASdAKgEqQSqBBEGDQANAC0BvQPQBIYEmQCZAYYEdQEvBpgEBQBxASwGrQHWBAMAvQN6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAF9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfACZAdAANwKoBAQEqASpBKoEqASEAVQDmwAQBh4BkgFKBEoE6AE4AtEBVgEnBScFEAZ9AH4AUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfACBADgCDQANAHYBegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBLgE4AsUBEAKoBKkEqgQNAA0AqASpBKoEEQXPAfMEmQElBSUFEAb0A8UBxAHIACsBRwBHAPEEegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAmQHjADEEhgQcARwBowE4ARYBFgEdAR0BiwWWAZUBfgGGBDUCOAKGBKwENQJABjUCfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAxQHKBQ0ADQAABnoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AckAOAJiATIGPwICAN0ESANJA0oDGgY9AbwEkgAGAJkB/wD+AP0AzgAvBQkArAQGAUcARwCoAXoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AX0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8ADgCHAEcATgCvQSZAT4COQHdBF0BEAVgAaMBPQE1ApIA6wENAmsGiwFzAesBLwVGAEYADwVHAEcA8AAtBWgAUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfAB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAFaBBwBHAGsAcAB9QW9BLcBHAEcAdEFSAU3AdoBNQJbBMsD6wHrAdkA7wQ1AgIGOALMA88AOAIDBPAAfwFcBAcCegB6AHoAegB5AHkAeAB4AHgAdwB0ALwB+gNrAEcARwD5Aw0ADQCQAzgC1wU4AhwBHAFhAA4C6wHAAZEDLgUqBSECmQEcARwBNQKXANEA1wXZBQYBwgE3ADcAOAA4ADUC+QP5A/sDuwFMAZkBDwIMACcBfQB+AFAAwQTBBBoEHQQQBBAEewB7AHwAfAB8AHwAWwGZAWAD/gW9BH0AfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8AHEEaQbaAWkGcwF9AHIAUADBBMEEGgQdBBAEEAR7AHsAfAB8AHwAfADXBUkB2gFLAXoAegB6AHoAeQB5AHgAeAB4AHcAdAC8AcsAiwU4Ag4FYAPQAb0EtAF6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAEpAnEEagYbAmoGDwAPAHwDegB6AHoAegB5AHkAeAB4AHgAdwB0ALwBOAIqARoCbwSLBRcGGAYzBZkBBgAGAJEE9ASfAUABHAEcAYsF/AE1Ag0CLAHJASsAKwA4An0DDAA1AkoB3gGpAZcBfgBQAMEEwQQaBB0EEAQQBHsAewB8AHwAfAB8ADgCOQA5ACABqASLBfABygGIAYgBhwERAYUBbwQWBlEDkQSXAQYAOAJBAYYE1gEsACwAFQZaBKoB6gAGAEMBAAEcAgABhgSvATgChgRCAREA5wFbBDoAOgB6AHoAegB6AHkAeQB4AHgAeAB3AHQAvAFcBNgA4QE7ADsAqASpBKoEbwAwAkQBBADsAMgBDgI4Au0AyAE4ArUBqAAsAqQBjQDfATMCOAIlATgCRwQ4AiUBOAJHBBMCOAJoAwgAPAA8AOsAPQA9ADgCngE4Ap4BOAK9AT4APgAtAC0ALgAuAC8ALwDHADEAMQAtAjgCZwE4AmQA5gEyADIAPwA/AEAAQAAxAp8BFwKaATgCAwQ4AhYCPAEvAjwBLwJBAEEADgAOADgCAwQ4AgACpANoA/oDbQBtAKMD+QNCAEIAgwCDAG4AwwG9AToCOQKgAbEA+QOEAIQAQwBDADgC0wE4AqQD1wFUBRsB4gCjAzsBUwWXATgCywGXAfkD+QP7A+8AlwFWANUARgU0ADQARABEAPkD+QP7A/wDGwAxBpwEvwFFAEUAIAFhAGwABQZqAIgBiAGHAREBhQE4Am8DUQNzAzgCbwAwAtIBBAA4ApgAHgAmADgCbATqAIwBQwFvADACDwIEADMCNQA1AEIBOAKjAKMAOAJRAdQBpACkAE0BMwJMAEwAOAIhAeoFOAIfAOkFOAK9AVIB4wFkADYANgBYAUgASAAoAewAOAQtAr0BbwNQBYYAhgCoAEkASQCNAKEAoQAmBi0CFwI4Aj8BOAJcARgC8QPZAQUBBQF7A3oD6wAXAjgCAwQ4AtsBFgIFAW8BbQBtAAkCiACIAIIAggADBG4AbgG9AToCOQJtAG0A+QOiAKIAnACcADgCbgA4BL0BOgI5ApoBXwH5AzgCYQE8AS8COAJXATgCZADxAWUBAgFkAIIDgwOMAIwAYwEeBfkD+QP7A/wDGwCLAIsAagHDAYkAiQCKAIoA+QP5A/sD/AMbAJwEvwE4AnQBIAFvADAC/QMEAIgBiAGHAREBhQE4AnUEUQM4AjQEOAICAewBMwI4AtMASwBLACsCwgPqAAUBQwFvADACoQMEAHEATQBNAEIBSgBKACoAKgBdBb0BMAAwAIoFMwLOA88DRARDBEQEQwReAy0ClgCiA0IFcQBOBSoCkAX9A/sE8gTmBOwA5QTnBL0BOQY/BTQBFAGoADUBCwCNAIkBNgHoAC0CfQUDBE8BIwF4BdsAUAFtAG0AqAMpAYIF6wBVAd0BbgD2Ab0BOgI5AnEFgQX5A5ABDQVtAd8AzgUDBM0FSwVMBUoFSQVtAG0AzAA8BtAELgIJAdoAbgDNAL0BOgI5ApoBgwH5A/0FswA8AS8C+QP5A/sD/AMbAOYA+wXNBE8AMAJVAAQAogHXACQCUQBUALwAfgWtALUAzQHDASMAzgEzArcA+QP5A/sD/AMbALgA0wW5ALoA7wHyAGIAjgGEBSQAgwXkAVsA1QGRAYYFvQHAAMgF9gDeBeoBWgEVAfgAxADtAf8BLQJeAegE+QD6AJMBIQUgBW8AMAKwAQQAHwUYBV0ASwZzA0oG4ACUAbIBCAIHAbMBKwYzAgMFAgVsAQMEMgEBBQgBSQYdBm0AbQByARcFMwEcBrYBgABuAGIFvQE6AjkCvQEiAvkDCgC6BWkAfQFhBSIAPAJjADgFLQI6AaIEEgIQARIBewHSADcFIwKBAYIBEwE9AuME3gSbAZwB7gWlALIA7wX5A/kD+wP8AxsA7QXsBQMETgCTAKYA3ADdAG0AbQBEAzABpwC+AdQAPgFuAOcAvQE6AjkCkABCBPkDQARGAbQAqQC8BLYATgHuAJMD8QBQBLsAqgCrAKUBVwBYAKcBvQBZAFoArABTBPMATwT0AJ4AEgD1AFkB9wD5A/kD+wP8AxsABQFIBMEAygTpAcIAJQBuAVMD7gH7AMMA+gFcABMA8gFmARQA9wFxA2kBXgB+AzEBnwABAicAXwCWBKAAIATGA3cEYACuAHYE4QAYARoBxgDAA3EAjASIBAQBFQAWABcAigSQBI8EfAQYACEAGQDKAB4CGgBkAC8EZgAhBGcABwAfBCMEWQQkBFgECgELARwAKACGAf4DXwNwAB0ANAKeBJ0EDAGwAI8AnQPaBNoE2gTaBNoE2gTaBNoE2gTaBNoE2gTaBNoEDQFCBtoEQQY=");
  base64DecodeToExistingUint8Array(bufferView, 46576, "bwZvBm8GwwXYBEcF2ATYBNgEwwXDBcMF2ARlBWUF+AX5BNgE2ATYBNgE2ATYBNgE2ATYBNgEwgXYBNgE2ATYBBsGGwbYBNgE2ATYBNgE2ATYBNgEbgXYBHUF2ATYBNgE2ATYBMQFxQXYBNgE2AT3BfkF1AV8BXsFegV5BeYFWQVzBWwFcAW+Bb8FvQXBBcUFxAXYBG8FngWuBZ0F2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ASmBa0FrAWrBbQFqgWnBaAFnwWhBaIF2ATYBPAE2ATYBO0EIwXYBNgE2ATYBNgECwYKBtgEowXYBPkEmAWXBbEFpAWwBa8F/wU/Bj4G1QXYBNgE2ATYBNgE2AQbBtgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ARbBRsGGwbYBPkEGwYbBlwFXAX1BPUEXwXYBAYGPgU+BT4FPgVHBT4F2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE/AX6BdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBEMF2ATYBNgE2ATYBNgE2ATYBNgE2ATYBDgG2AThBTEFQwVDBUMFQwVFBTIFMAU9BfoE3wRnBn8FdAVEBXQFZAZyBX8FfwVyBX8FRAVkBgoFTwYFBWUFZQVlBVsFWwVbBVsFXwVfBcAFRAU9BdgEZwZnBk0FTQVmBmYGTQXVBVcGiAUmBSwFLAUsBSwFTQXqBHIFVwZXBnIFiAUmBXIFJgVyBU0F6gTlBWEGTQXqBMsFTQXqBE0F6gTLBSQFJAUkBRkF2ATYBMsFJAUKBSQFGQUkBSQFLQbYBM8FzwXLBU0FJQYlBmgFaAVtBV8FxgVNBdgEbQVrBWkFcgUcBTsGOwY3BjcGNwZsBmwGBgZIBvkE+QT5BPkESAYMBQwF+gT6BPkESAbYBNgE2ATYBNgE2ARDBtgEAQbWBVEF2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBAwG2ATYBNgE2ATYBNgE2ATYBNgE2ASNBdgE2wQDBtgE2ATYBNgE2ATYBNgE2AR2BXcFUgXYBNgE2ATYBNgE2ATYBIUF2ATYBNgEgAXYBNgE2ATYBNgE2ATYBNgEYwbYBNgE2ATYBNgE2ATkBeMF2ATYBE8F2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2AQIBdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ARqBdgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2AQqBmAF2ATYBNgE2ARaBtgE2ATYBNgE2ATYBNgE2ATYBNgE2ATYBNgE2ARTBjQFjwXYBI4FkgXuBNgE5ATYBNgECQ==");
  base64DecodeToExistingUint8Array(bufferView, 47760, "vQC9ALwAvgC/AL8AvwC/AL4AvgC+AL4AvgDDAMUAxwDHAMYAxgDEAMQAywDLAM0AzQDOANAA0ADQANEA1QDWANcA1wDXANcA1wDXANcA1wDXANcA1wDXANcA4ADgANwA3ADeAN4A4QDhAOEA4QDiAOIA4gDiAOIA3wDfAOMA4wDjAMoA5QDmAOYA5gDmAOYA6QDaANoA6gDqAOsA6wC+AO0A7QC+AL4AvgDMAMwAzADvAPIA8gDyAPAA8AD8APwA8wDzAPMA/gD0APQA9AD/AP8A9QD1AAEBAQEAAQABAAEAAQAByADIAO4A7gAGAQYBBgEGAQIBAgECAQIBAwEDAQMBCAEEAQQB+QD5AOcA5wDbANsA2wAJAQkBCQH3APcA+AD4APoA+gD6APoAvgD2APYACwELAQsBCwG+AAwBDAEMAQwBvgC+AA8BDwEPAQ8BDwEPARABDQENAQ4BDgEHAQcB2QDZANkA2QDZANgA2ADYANkA2QDZANkA2QDZANkA2ADZANkA2QDZANkA2QDZANkA2QASAdkA2QDZANkA2QDZANkA2QDZANkA2QDZABMBEwHZABQBFAHZANkA2QDZANkA2QAXARcBGAEYARYBFgEFAf0A/QAVARUBvgAZARkB3QDdAOgA6AAaARoBvgC+AL4AGwEbAb4AvgC+AL4AvgDTANQAvgAdAR8BHwEfASABIAEgASIBIgEeAR4BJAElASUBIwEjASMBIwHZANkA7ADsAOwAvgC+AL4AJwEnAb4AvgC+AL4AvgC+AL4AKAG+AL4AvgAqASwBLQEtAS4BCgEKATEBMQExATAB8QDxADIBMgEzATQBNAE0ATQBNAE0ATUBNQE1ATkBOwE7ATwBPAE6AToBPQE9AT4BPgE+AfsAEQERAREBOAE4ATcBuQC6ALoAuwC7ALsAwADAAMAAwgDCAL4AywDJAMkAwQDBAMEA0ADRANIA0gDPAM8A1wDXANcAygDkAOQA5QDpAOsA7wDwAP4A/wAIARAB2QASAQUBHAEcARwBHAEcAdMAIQEhASQBJQEmASYBKQEpASsBKwEsAS8BLwEvAQoBAAAAAAAASwAAACMACgBeAAAANAAJAIcAAABeAAEAVgAAAFAAAAAIAAsAJgACAEcAAAB6AAAAQgBDAEQARQ==");
  base64DecodeToExistingUint8Array(bufferView, 48640, "hEQAAMwHAACgQwAAxSMAAD0sAAD3SwAAKU0AAOZMAAACBAgGBgAAAAAAcm93X251bWJlcgBkZW5zZV9yYW5rAHJhbmsAcGVyY2VudF9yYW5rAGN1bWVfZGlzdABudGlsZQBsZWFkAGxhZwAAAAAAACq+AABMAAAAWgAAAFUAAAA1vgAAWQAAAFoAAABVAAAAQL4AAFkAAABaAAAAVQAAAEW+AABcAAAAVQAAAFoAAABSvgAAXAAAAFYAAABaAAAAXL4AAEwAAABVAAAAWgAAAGK+AABMAAAAWgAAAFoAAABnvgAATAAAAFoAAABVAAAA/zYAAAg=");
  base64DecodeToExistingUint8Array(bufferView, 48896, "t3MAAERHAAAwTAAAYEcAAM1MAAADBAMHBARDQURERUIKCgkJCAgHBwcGBgYFBQUEBAQEAwMDAwMDAgICAgICAm50aF92YWx1ZQBmaXJzdF92YWx1ZQA5NwAAAAAAAAAA+y0AAEAAAABwRAAAQgAAACE2AABBAAAAkCQAAEMAAAAXFRQWAAAjHxcUFhUqKCcpJiUjHw==");
  base64DecodeToExistingUint8Array(bufferView, 49056, "ZSMAAJojAAAAIwAA9yMAACsk");
  base64DecodeToExistingUint8Array(bufferView, 49088, "OQAAADkAAAA2AAAAOQAAADk=");
  base64DecodeToExistingUint8Array(bufferView, 49120, "bmF0dXJhbGVmdG91dGVyaWdodGZ1bGxpbm5lcmNyb3Nz");
  base64DecodeToExistingUint8Array(bufferView, 49169, "BwQGBCgKBSAOBTATBDgXBQEcBQMAAADYNwAAAwAAAL0GAAAD");
  base64DecodeToExistingUint8Array(bufferView, 49216, "MwACAH8AAABhAAIAgAAAAHo=");
  base64DecodeToExistingUint8Array(bufferView, 49248, "AgAAAGMAAQMxAQgARwACAGsBAgExAQgARwABALgAAABUAQE=");
  base64DecodeToExistingUint8Array(bufferView, 49296, "AgABAGMAAQQPAQAARgACAGQABwBoRAAAnAcAAEcsAAAABAEBAgM=");
  base64DecodeToExistingUint8Array(bufferView, 49344, "VgEAADsBBAB1AAMAVAMBAEYAAAB1AAMACAADAAAAAAAdWAAAAQAAACJYAAABAAAACTYAAAIAAABdNwAAAwAAAAE2AAACAAAAVTcAAAMAAAChWAAAAAAAAJtY");
  base64DecodeToExistingUint8Array(bufferView, 49448, "AgABAGQAAAACAAAAYwABAFQBAQAAAAAAb25vZmZhbHNleWVzdHJ1ZXh0cmFmdWxsAAABAgQJDA8UAgIDBQMEBQQBAAAAAQEDAg==");
  base64DecodeToExistingUint8Array(bufferView, 49540, "w1cAAPk1AABNNwAAJV8AAAMAAAAB");
  base64DecodeToExistingUint8Array(bufferView, 49572, "zQ==");
  base64DecodeToExistingUint8Array(bufferView, 49588, "Li4AAAAAAAB4AAAAJDsAAAAAAgDGMAAAAAAE");
  base64DecodeToExistingUint8Array(bufferView, 49632, "fCUAAAEAAABUBgAAAgAAADNCAAAGAAAAogQAAIA=");
  base64DecodeToExistingUint8Array(bufferView, 49672, "AQAAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 49688, "zg==");
  base64DecodeToExistingUint8Array(bufferView, 49704, "PC4AAAAAAAA8WgAA4AwAANJYAAAAAAAAK1kAAAAAAAAEAAAAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 49752, "zw==");
  base64DecodeToExistingUint8Array(bufferView, 49768, "NwsAAAAAAAACAAAAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 49792, "0A==");
  base64DecodeToExistingUint8Array(bufferView, 49808, "sS0AAAAAAAABAAAAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 49832, "0Q==");
  base64DecodeToExistingUint8Array(bufferView, 49848, "ZAwAAAAAAACD/90CFQPxACUBhf8//0H/Sf9F/6YA7gCFADH/Of/1/lD/+v/MAOkBQAJR/1YCrgJnAtUCXAMKAw0DWQNoAncDVwDwAED/mAFyAhwDSwNWA+sD8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f7x/vH+8f5QAFMAOQF2A3gD5AMKBCMEOQRMBF0EgASDBIsEjQSPBJEElAScBJ4EoASuBLAEvQS/BMkEywTkBOYE8AQTBRcFHAUgBS0FMAU5BTwFPwVbBV0FaAVqBYMFjAWQBZIFsgW+BcEFwwXHBfH+8f7x/vH+8f7x/vH+8f7x/vH+8f6KAMsBjAFi/9YBLgEs/wkCyQA9/6T/LwJ2AngCdgLx/ngChQM/AJcB8f7x/vH+8f6hAKEAoQD7AE8BTwPAA9QDGQJMAmoCdAKwArACWv9f/6ICFgMaAx8DUwNUA4b/qAKI/+MDDgSfARsEfQMeA8IDkAE+BAsDmwOcAwcBEQTTA94DOwRJBAcEqgRqAeIDcwTtAw0EsgS1BKsEugQ+/zgAuQB5/+gACgIwAlkCaQKdAqsCxwJYA4wDrQMYBE0EewTpBO4E8QSIAQwFNQU7BT4FQgVGBU8FXgWKBY0FnAWdBVEC8wICA+UDpQWzBbkE3AXgBewFbATbBO4F7wWgBfAFMALyBfMF9AX2BfcF+QVmBZ4FlwW8Bb0FwAXEBbkElwWXBc0F9QUDBpsFtwW/BdQFzwWjBdYFwgXMBdoFzgXeBa8F+gX7Bf0FBAYGBggG4QXiBeMF5AXxBfgF1QUBBvwFJwbQBdgFMAY6BuUF5gVABgIG/gUFBiYGKQYvBjEGMgZMBloGLQYUBhYGMwYXBkEGNAZDBjgGXwZoBg4GEQZrBm0GWQZxBnQGcgZ1BmAGZAZlBmoGYgZnBmkGbgZ4BncGegZ7Bn0GfwYYBhwGPAZFBoAGhgYdBiMGWwZmBnkGgQZXBqYGXgaCBoMGhwaJBqcGtga3BsEGwgbDBlUGVgZcBrgGsQa0BroGuwbFBrUGvAa/BsAGvQbMBgAAAQAAAJ5zAAAAAAAAxSMAAD0sAADMBwAAhEQAAF8r");
  base64DecodeToExistingUint8Array(bufferView, 50720, "MDEyMzQ1Njc4OUFCQ0RFRmxhc3RfdmFsdWUAAAwADgAYAB8AOwAPJwAAAAAAAAAABnNlY29uZAAkINNXAACAPwZtaW51dGUA2TPhVAAAcEIEaG91cgAAALA58FEAAGFFA2RheQAAAABa/KNKAMCoRwVtb250aAAAgGgsSAA0HkoEeWVhcgAAAADkZUbAmfBL");
  base64DecodeToExistingUint8Array(bufferView, 50873, "AQEAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 50896, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 51128, "YnRuAGZy");
  base64DecodeToExistingUint8Array(bufferView, 51152, "XysAACYwAAA7MgAAxSMAAD0sAADMBwAATwUAAK8MAABCAQAAQwEAAEQBAABFAQAARgEAAEcBAABIAQAAAAAAAAEAAAAAAAAASQEAAEoBAABLAQAATAEAAE0BAABOAQAATwEAAFABAABRAQAAUgEAAFMB");
  base64DecodeToExistingUint8Array(bufferView, 51280, "bSEAAHohAAAAAAAAlzwAANs5AABWPAAAaTwAAHUEAABBMgAA9zkAAIohAAC3OwAA9ScAAGQrAABwNAAANSsAAAAAAACFPQAAyC4AAPk7AADYLQAAHTEAAAs8AACCPAAAAAAAAEE2AAC7MgAAWzYAAHA2AABUAQAAVQEAAFYBAAADAAAAVwEAAFgBAABZAQAAWgEAAFsBAABcAQAAXQEAAF4BAABfAQAAYAEAAGEBAABiAQAAYwEAAGQBAABlAQAAZgEAAGcBAABoAQAAaQEAAGoBAABrAQAAbAEAAG0BAAAAAAAAbgEAAG8BAABwAQAAcQEAAHIB");
  base64DecodeToExistingUint8Array(bufferView, 51536, "MAAAAAfoAAAGbAEAL+wBAAesAgAB0AIAA9gCAAHsAgAB/AIAAVwDAAHcAwAECAsADkgLAAeUCwABtAsAgbwLAAHUDQAB+A0AAhAOAAEcDgAB2A8ACAgSAAZoFQACJBYAATwWADdEFgACzBcABQAYABYYGAACeBgAFSwZAASoGQABwBkAAVAbAA9YGwAHnBsAAvQbAA4AHAABPBwAAUQcABvAHAALmB4ACawfAATYHwAEWCAACWwgAAOUIAAFpCAAD8AgAANkIQABeCEAG5AjAAQAJAAD6CQAEvgkAAdEJQAEiCUAAcAlAAMEJgAB8CYAB/gmAAIcJwADLCcAAVwnAAKIJwACyCcAAugnAAMEKAAB8CgABfgoAAIcKQADLCkAAUQpAALAKQAB1CkAAwQqAAHwKgAI+CoAAxwrAAMsKwACiCsAAsArAAMELAAB8CwAB/gsAAIcLQADLC0AAlgtAAKILQABwC0AAQguAAX4LgADGC8ABCgvAAFcLwAIzC8AAwQwAAf4MAADGDEABCgxAAJUMQACiDEAAfwxAAIIMgAB8DIAB/gyAAMYMwAEKDMAAlQzAAKIMwACCDQAB/g0AAMYNQAEKDUAAVw1AAKINQAB5DUAAgg2AAEoNwAGPDcAAVg3AAhgNwADyDcAAcQ4AAfQOAAB/DgACRw5AAJoOQABxDoABtA6AALsOgAGIDsAHwQ8AAzQPAAXxD0ACzQ+ACRkPgAP+D4ADTg/ABSsQAAGKEEABFhBAAN4QQADiEEAB5xBAATEQQAMCEIAATxCAAZoQgAB7EMADHRNAApATgABAFAAArRZAAEAWgACbFoAA6xbAANIXAAFyFwAAkhdAALIXQAj0F4ABGBfAAF0XwAPAGAAAaRiAAyAZAAMwGQAAQBlAAIQZQARwGYAAiBnACJ4ZwAFXGgAAnhoAApUaQAdgGkAAfxpAAeAagAGoGoABQBsABHQbAAjaG0AAwBuAA2EbgAOmG8ABPBvABSQcAAF7HAAAvhxAAgAcwAZQHMAAbRzAAPIcwAnAHcABPB3AAH0fgAD/H4AAzR/AAN0fwADtH8AAvR/AGUAgAAGqIEABeiBAAUoggAagIIAIUCDAAIAhAAEDIQAAiCEAAFQhAADWIQABniEAAGUhAABnIQAAaSEAAG4hAAC6IQABQCFAAQohQABPIUAZEKGACcAkAALAJEATnCSAAAClAB1BJwAuVOeAApArQAGlLMAA7yzAATkswAC+LMAAcC1AAH8tQBPgLcADMC4ABoAugBZbLoA1gC8AAzAvwAFAMAAGSDAAAeowAAC2MAAA/TAAARkwgABgMIAAezDAAJAxgAKWMYAJADHAB8AyAAeqMgAAUDJACCAyQAnKMoAPwDLAAABzABAADcBN0CSAgL4kwIDNJgCELyZAgF8mgIIwJsCFwCcAgKAnAICJJ4CAQigAgEYoAIBLKACCYygAgTYoAIE0KECAgCiAhHQogICOKMCEoCjAgPgowIKmKQCDRylAgF8pQIEAKYCG8ymAgJ4pwIOpKgCAQypAgIwqQIEcKkCA9ypAgHsqQIBwKoCA8iqAgLcqgIC+KoCAQSrAgJ4qwIHrKsCAtSrAguMrwIBAGADAvxtAwL8bwMB/H8DAXjsAwGk7AMQyO4DAvj0AwLw9wMaAPgDB4D4AyPA+AMTUPkDBKD5AwH8+wMPBPwDB2j8Awbs/AMLbP0DB4D/Aweg/wMF5P8DAwAEBAncBAQR5AUEDEAGBC5ABwQBfA4EAUAPBAFcIQQBfCQEAfwkBAMEKAQCFCgEBDAoBAPgKAQB/CgECUApBAH8KQQH5CwEAwBABBbgQAQDAEIEEsBCBAMARAQOnEQEBABFBAMARgQOzEYEBBRHBA2sWgQEwJEELkS9BQQ8vgX2AEAHJwBEB7WkRAdGAEgHVwBMBwEEWwcBbFsHAexbBwFUXAcB1FwHATxdBwG8XQcBJF4HAaReBwEMXwcCwLsHLADAB2TAwAcPgMIHDsTCBw8EwwcPRMMHH0DEBzzAxAcrwMUHHZjHBytAyAcJAMkHAkDJByEAzAcGwMwHRtzMBxQAzgclgM4HBRjPBxGAzwc/ANAHAQDRB7YI0QcE5NMHPgDUBwQA1QcYQNUHRuzXBwsU2QdGANoHdADcBwEEADhggAA48AAEOAAAAAAAAAAA////////APwBAAD4AQAA+EEADhq1AEABwAAOF9gADgcAAQEwMgEBBjkBARBKAQEueAF0AXkBAQZ/AWgBgQEyAYIBAQSGASwBhwEAAYkBKgKLAQABjgEgAY8BJgGQASgBkQEAAZMBKgGUAS4BlgE0AZcBMAGYAQABnAE0AZ0BNgGfATgBoAEBBqYBPAGnAQABqQE8AawBAAGuATwBrwEAAbEBOgKzAQEEtwE+AbgBAAG8AQABxAECAcUBAAHHAQIByAEAAcoBAgHLAQES3gEBEvEBAgHyAQEE9gF6AfcBhgH4AQEoIAJuASICARI6AkYBOwIAAT0CbAE+AkQBQQIAAUMCagFEAhwBRQIeAUYCAQpFAyQBcAMBBHYDAAGGAxIBiAMQA4wDGgGOAxgCkQMOEaMDDgnCAwABzwMEAdADjAHRA44B1QOSAdYDkAHYAwEY8AOIAfEDigH0A4IB9QOAAfcDAAH5A5gB+gMAAf0DbgMABCIQEAQOIGAEASKKBAE2wAQGAcEEAQ7QBAFYMQUWJqAQQibHEEIBzRBCAQAeAZabHoQBnh5gAaAeAWAIH5YIGB+WBigflgg4H5YISB+WBlkflwhoH5YIiB+WCJgflgioH5YIuB+WAroffgK8H5QBvh9kAcgffATMH5QB2B+WAtofeALoH5YC6h92AuwfmAH4H3AC+h9yAvwflAEmIWIBKiFcASshXgEyIQwBYCEIEIMhAAG2JAoaACwWL2AsAAFiLFgBYyxmAWQsWgFnLAEGbSxUAW4sVgFvLFABcCxSAXIsAAF1LAABfixOAoAsAWTrLAEE8iwAAUCmAS6ApgEYIqcBDjKnAT55pwEEfadMAX6nAQqLpwABjadKAZCnAQSgpwEKqqdIASH/DhoAAAAAAQACAAgADwAQABoAHAAgACUAJgAoADAAPwBAAEUARwBPAFAAdADKAMsAzQDOAM8A0QDSANMA1QDWANkA2gDbAAcDYBwoKisqvFrYWvx1wdXh1eLV5NUD1gnWGdZB37rfQeKj4vvjGvH0/j3/Xf9+/4D/gv+H/5D/nP+f/6r/tv/A/8T/xv/I/8r/0P/i/+f/6v/x//f/+P/5/wAAAAAAAAAABQc4B0MHYweIB5QHywfoB/gHDAg+CHgIngjYCO4IKAlPCagJuAnUCSQKbAqsCt4KGgtOC4oLqAu4C9QLCA2ADXAOgA6QDqAOtg74DjgPSA9YD2gPgA+oD8gP2A8KECoQShBqEIoQqhDIENgQ+BA4EUgRWhF4EYgRmBEEGDYYeBiIGNgYHRlpGYEZCPAc8EjwXvCY8KrwyvDo8PjwCPEe8VjxaPF48YzxuPHI8drx/PEu8m7yqvLK8ujy+PIK8yzzXvOc88rz6vMO9Ej0WvR49Iz0sPS49MD0yPQK9S71bvWq9cz1/vU49kr2avaO9s72Cvcq9073iPee9wAAAAAAYWNlaW5vdXl5YWNkZWVnaGlqa2xub3JzdHV1d3l6b3VhaW919eFna2/vamdu4WFlaW9ydXN0aGFl72/veQAAAAAAAAAAYWLjZGTlZeVmZ2hoaelrbOxsbW7vcHLycnPzdHX1dnd3eHl6aHR3eWHh4eFl5eVpb+/v73X19XkAAAAAAABzAQAAcwEAAHQBAAB1AQAAdQEAAHYBAAB3AQAAeAEAAHkBAAB6AQAAewEAAHwB");
  base64DecodeToExistingUint8Array(bufferView, 54480, "c1IAALBjAADCaQAA92kAABRqAACdawAA3mkAAN5PAABvWwAAemQAALVkAAD0YwAAok0AABJOAAAlUgAAjFAAAPpRAADOUAAAi18AAJ9SAABKZAAA9k8AACVQAAAkZAAAt3MAALdzAABVUAAAL2oAAPBaAACPaAAAw1EAAJ9PAABYUQAACVEAAIJMAAADTwAAbGoAAJlOAABWTwAAmVoAAAAAAAB9AQAAfgEAAH8BAACAAQAAgQE=");
  base64DecodeToExistingUint8Array(bufferView, 54672, "ggEAAIMBAACEAQAAhQEAAIYB");
  base64DecodeToExistingUint8Array(bufferView, 54704, "AQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAQEBAAEBAQABAQEBAQABAQEBAQABAQECAQAAAAAAAJ0lAAAJAAAAgwUAAAYAAABnDwAACAAAAGUPAAAKAAAA5yMAAAUAAAAeCgAABwAAAMA4AAAKAAAAEDkAAAo=");
  base64DecodeToExistingUint8Array(bufferView, 54916, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 54928, "AQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAArSgAAAgAEAI9NAAADAQMAXEcAAAMBAgBQSgAABAABAFwMAACHAQAAMQ8AAIgBAACuLwAAiQEAAJ0lAACKAQAAHgoAAGgvAACrIQAApQ4AAOgMAAAAAAAAiwEAAIsBAACMAQAAjQEAAI0BAACOAQAAjwEAAJABAACRAQAAkgEAAJMBAACUAQ==");
  base64DecodeToExistingUint8Array(bufferView, 55200, "Si4AAMARAQCpNgAAIBIBAAAAAgADAAUABgAHAAgACQBmWgAAnV4AAB1MAACVXQAA51gAANJaAAAFXQAAVlgAADldAADwSAAAPVgAALBZAACuXQAAxlkAANxcAAAnSQAAaFkAAA9JAAACTQAAFFkAAFhdAACFXQAAaF0AAAVaAADOXQAAKFgAAC1eAAD5XQAA9VwAAHRZAACHWAAAQ14AAOJdAABtWAAAF14AAMdcAAB+RwAA0ksAAD9PAAB6WgAAGV0AAMNMAABVRwAAwEcAALdHAAB5TAAAckcAAIJNAADFEQAAAQABAK4BAADaKQAAAQABAK8BAABLKgAAAQABALABAACRWQAAAgABALEBAACWWQAAAgABALEBAAC7LQAAAQABALIBAADBLQAAAQABALMBAADHLQAAAQABALQBAAAhNwAAAgABALUBAADiFQAAAQABALYBAAAxEwAAAQABALcBAADGEQAAAQABALgBAADbKQAAAQABALkBAABMKgAAAQABALoBAAA7CQAAAQABALsBAAC8LQAAAQABALwBAADCLQAAAQABAL0BAADILQAAAQABAL4BAAB6LQAAAQABAL8BAACTJAAAAQABAMABAABkLgAAAQABAMEBAABSXQAAAQABAMIBAADTIQAAAgABAMMBAAAaKgAAAQABAMQBAAAACQAAAQABAMUBAAAOMwAAAQABAMYBAADEKwAAAQABAMcBAACZIQAAAQABAMgBAABELQAAAAABAckBAAATMQAAAgABAMoBAACvBQAAAgABAMsBAACvBQAAAwABAMsBAAClIAAAAgABAMwBAACcIAAAAgABAM0BAAAnMgAAAQABAM4BAADBIgAAAQABAM8BAADQKwAAAgABANABAABiJAAAAgABANEBAAC4QwAAAgABANIBAABKIgAAAgABANMBAAAsBwAAAQAAANQBAADVAQAALDcAAAEAAADUAQAA1gEAANg2AAABAAAA1wEAANgBAABQKgAAAQAAANcBAADZAQAANDQAAAEAAADXAQAA2gEAAEM0AAABAAAA1wEAANsB");
  base64DecodeToExistingUint8Array(bufferView, 56066, "AQIDAAECAAACAgQFBQABAgYCAwABAAIAAgAAAAAAAAABAgMAAQIAAAICBAUFAAECBgIDAAEAAgAC");
  base64DecodeToExistingUint8Array(bufferView, 56256, "BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgICAgICAgMDAwMDAwMDBAQEBAQEBAQAAAAAgDAAAIAgDgCAIMgDAAAAAID///8A+P//AAD//wAAAAAAAPA/AAAAAAAA+D8AAAAAAAAAAAbQz0Pr/Uw+");
  base64DecodeToExistingUint8Array(bufferView, 56459, "QAO44j/+gitlRxVnQAAAAAAAADhDAAD6/kIudr86O568mvcMvb39/////98/PFRVVVVVxT+RKxfPVVWlPxfQpGcREYE/AAAAAAAAyELvOfr+Qi7mPyTEgv+9v84/tfQM1whrrD/MUEbSq7KDP4Q6Tpvg11U/");
  base64DecodeToExistingUint8Array(bufferView, 56590, "8D9uv4gaTzubPDUz+6k99u8/XdzYnBNgcbxhgHc+muzvP9FmhxB6XpC8hX9u6BXj7z8T9mc1UtKMPHSFFdOw2e8/+o75I4DOi7ze9t0pa9DvP2HI5mFO92A8yJt1GEXH7z+Z0zNb5KOQPIPzxso+vu8/bXuDXaaalzwPiflsWLXvP/zv/ZIatY4890dyK5Ks7z/RnC9wPb4+PKLR0zLso+8/C26QiTQDarwb0/6vZpvvPw69LypSVpW8UVsS0AGT7z9V6k6M74BQvMwxbMC9iu8/FvTVuSPJkbzgLamumoLvP69VXOnj04A8UY6lyJh67z9Ik6XqFRuAvHtRfTy4cu8/PTLeVfAfj7zqjYw4+WrvP79TEz+MiYs8dctv61tj7z8m6xF2nNmWvNRcBITgW+8/YC86PvfsmjyquWgxh1TvP504hsuC54+8Hdn8IlBN7z+Nw6ZEQW+KPNaMYog7Ru8/fQTksAV6gDyW3H2RST/vP5SoqOP9jpY8OGJ1bno47z99SHTyGF6HPD+msk/OMe8/8ucfmCtHgDzdfOJlRSvvP14IcT97uJa8gWP14d8k7z8xqwlt4feCPOHeH/WdHu8/+r9vGpshPbyQ2drQfxjvP7QKDHKCN4s8CwPkpoUS7z+Py86JkhRuPFYvPqmvDO8/tquwTXVNgzwVtzEK/gbvP0x0rOIBQoY8MdhM/HAB7z9K+NNdOd2PPP8WZLII/O4/BFuOO4Cjhrzxn5JfxfbuP2hQS8ztSpK8y6k6N6fx7j+OLVEb+AeZvGbYBW2u7O4/0jaUPujRcbz3n+U02+fuPxUbzrMZGZm85agTwy3j7j9tTCqnSJ+FPCI0Ekym3u4/imkoemASk7wcgKwERdruP1uJF0iPp1i8Ki73IQrW7j8bmklnmyx8vJeoUNn10e4/EazCYO1jQzwtiWFgCM7uP+9kBjsJZpY8VwAd7UHK7j95A6Ha4cxuPNA8wbWixu4/MBIPP47/kzze09fwKsPuP7CvervOkHY8Jyo21dq/7j934FTrvR2TPA3d/ZmyvO4/jqNxADSUj7ynLJ12srnuP0mjk9zM3oe8QmbPotq27j9fOA+9xt54vIJPnVYrtO4/9lx77EYShrwPkl3KpLHuP47X/RgFNZM82ie1Nkev7j8Fm4ovt5h7PP3Hl9QSre4/CVQc4uFjkDwpVEjdB6vuP+rGGVCFxzQ8t0ZZiiap7j81wGQr5jKUPEghrRVvp+4/n3aZYUrkjLwJ3Ha54aXuP6hN7zvFM4y8hVU6sH6k7j+u6SuJeFOEvCDDzDRGo+4/WFhWeN3Ok7wlIlWCOKLuP2QZfoCqEFc8c6lM1FWh7j8oIl6/77OTvM07f2aeoO4/grk0h60Sary/2gt1EqDuP+6pbbjvZ2O8LxplPLKf7j9RiOBUPdyAvISUUfl9n+4/zz5afmQfeLx0X+zodZ/uP7B9i8BK7oa8dIGlSJqf7j+K5lUeMhmGvMlnQlbrn+4/09QJXsuckDw/Xd5PaaDuPx2lTbncMnu8hwHrcxSh7j9rwGdU/eyUPDLBMAHtoe4/VWzWq+HrZTxiTs8286LuP0LPsy/FoYi8Eho+VCek7j80NzvxtmmTvBPOTJmJpe4/Hv8ZOoRegLytxyNGGqfuP25XcthQ1JS87ZJEm9mo7j8Aig5bZ62QPJlmitnHqu4/tOrwwS+3jTzboCpC5azuP//nxZxgtmW8jES1FjKv7j9EX/NZg/Z7PDZ3FZmuse4/gz0epx8Jk7zG/5ELW7TuPykebIu4qV285cXNsDe37j9ZuZB8+SNsvA9SyMtEuu4/qvn0IkNDkrxQTt6fgr3uP0uOZtdsyoW8ugfKcPHA7j8nzpEr/K9xPJDwo4KRxO4/u3MK4TXSbTwjI+MZY8juP2MiYiIExYe8ZeVde2bM7j/VMeLjhhyLPDMtSuyb0O4/Fbu809G7kbxdJT6yA9XuP9Ix7pwxzJA8WLMwE57Z7j+zWnNuhGmEPL/9eVVr3u4/tJ2Ol83fgrx689O/a+PuP4czy5J3Gow8rdNamZ/o7j/62dFKj3uQvGa2jSkH7u4/uq7cVtnDVbz7FU+4ovPuP0D2pj0OpJC8OlnljXL57j80k6049NZovEde+/J2/+4/NYpYa+LukbxKBqEwsAXvP83dXwrX/3Q80sFLkB4M7z+smJL6+72RvAke11vCEu8/swyvMK5uczycUoXdmxnvP5T9n1wy4448etD/X6sg7z+sWQnRj+CEPEvRVy7xJ+8/ZxpOOK/NYzy15waUbS/vP2gZkmwsa2c8aZDv3CA37z/StcyDGIqAvPrDXVULP+8/b/r/P12tj7x8iQdKLUfvP0mpdTiuDZC88okNCIdP7z+nBz2mhaN0PIek+9wYWO8/DyJAIJ6RgryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/T7thBWes3T8YLURU+yHpP5v2gdILc+8/GC1EVPsh+T/iZS8ifyt6PAdcFDMmpoE8vcvweogHcDwHXBQzJqaRPBgtRFT7Iek/GC1EVPsh6b/SITN/fNkCQNIhM3982QLA");
  base64DecodeToExistingUint8Array(bufferView, 58735, "gBgtRFT7IQlAGC1EVPshCcADAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSdKgBw16sAY3z4AHqwVwAXFecAwElWADvW2QCnhDgAJCPLANaKdwBaVCMAAB+5APEKGwAZzt8AnzH/AGYeagCZV2EArPtHAH5/2AAiZbcAMuiJAOa/YADvxM0AbDYJAF0/1AAW3tcAWDveAN6bkgDSIigAKIboAOJYTQDGyjIACOMWAOB9ywAXwFAA8x2nABjgWwAuEzQAgxJiAINIAQD1jlsArbB/AB7p8gBISkMAEGfTAKrd2ACuX0IAamHOAAoopADTmbQABqbyAFx3fwCjwoMAYTyIAIpzeACvjFoAb9e9AC2mYwD0v8sAjYHvACbBZwBVykUAytk2ACio0gDCYY0AEsl3AAQmFAASRpsAxFnEAMjFRABNspEAABfzANRDrQApSeUA/dUQAAC+/AAelMwAcM7uABM+9QDs8YAAs+fDAMf4KACTBZQAwXE+AC4JswALRfMAiBKcAKsgewAutZ8AR5LCAHsyLwAMVW0AcqeQAGvnHwAxy5YAeRZKAEF54gD034kA6JSXAOLmhACZMZcAiO1rAF9fNgC7/Q4ASJq0AGekbABxckIAjV0yAJ8VuAC85QkAjTElAPd0OQAwBRwADQwBAEsIaAAs7lgAR6qQAHTnAgC91iQA932mAG5IcgCfFu8AjpSmALSR9gDRU1EAzwryACCYMwD1S34AsmNoAN0+XwBAXQMAhYl/AFVSKQA3ZMAAbdgQADJIMgBbTHUATnHUAEVUbgALCcEAKvVpABRm1QAnB50AXQRQALQ72wDqdsUAh/kXAElrfQAdJ7oAlmkpAMbMrACtFFQAkOJqAIjZiQAsclAABKS+AHcHlADzMHAAAPwnAOpxqABmwkkAZOA9AJfdgwCjP5cAQ5T9AA2GjAAxQd4AkjmdAN1wjAAXt+cACN87ABU3KwBcgKAAWoCTABARkgAP6NgAbICvANv/SwA4kA8AWRh2AGKlFQBhy7sAx4m5ABBAvQDS8gQASXUnAOu29gDbIrsAChSqAIkmLwBkg3YACTszAA6UGgBROqoAHaPCAK/trgBcJhIAbcJNAC16nADAVpcAAz+DAAnw9gArQIwAbTGZADm0BwAMIBUA2MNbAPWSxADGrUsATsqlAKc3zQDmqTYAq5KUAN1CaAAZY94AdozvAGiLUgD82zcArqGrAN8VMQAArqEADPvaAGRNZgDtBbcAKWUwAFdWvwBH/zoAavm5AHW+8wAok98Aq4AwAGaM9gAEyxUA+iIGANnkHQA9s6QAVxuPADbNCQBOQukAE76kADMjtQDwqhoAT2WoANLBpQALPw8AW3jNACP5dgB7iwQAiRdyAMamUwBvbuIA7+sAAJtKWADE2rcAqma6AHbPzwDRAh0AsfEtAIyZwQDDrXcAhkjaAPddoADGgPQArPAvAN3smgA/XLwA0N5tAJDHHwAq27YAoyU6AACvmgCtU5MAtlcEACkttABLgH4A2genAHaqDgB7WaEAFhIqANy3LQD65f0Aidv+AIm+/QDkdmwABqn8AD6AcACFbhUA/Yf/ACg+BwBhZzMAKhiGAE296gCz568Aj21uAJVnOQAxv1sAhNdIADDfFgDHLUMAJWE1AMlwzgAwy7gAv2z9AKQAogAFbOQAWt2gACFvRwBiEtIAuVyEAHBhSQBrVuAAmVIBAFBVNwAe1bcAM/HEABNuXwBdMOQAhS6pAB2ywwChMjYACLekAOqx1AAW9yEAj2nkACf/dwAMA4AAjUAtAE/NoAAgpZkAs6LTAC9dCgC0+UIAEdrLAH2+0ACb28EAqxe9AMqigQAIalwALlUXACcAVQB/FPAA4QeGABQLZACWQY0Ah77eANr9KgBrJbYAe4k0AAXz/gC5v54AaGpPAEoqqABPxFoALfi8ANdamAD0x5UADU2NACA6pgCkV18AFD+xAIA4lQDMIAEAcd2GAMnetgC/YPUATWURAAEHawCMsKwAssDQAFFVSAAe+w4AlXLDAKMGOwDAQDUABtx7AOBFzABOKfoA1srIAOjzQQB8ZN4Am2TYANm+MQCkl8MAd1jUAGnjxQDw2hMAujo8AEYYRgBVdV8A0r31AG6SxgCsLl0ADkTtABw+QgBhxIcAKf3pAOfW8wAifMoAb5E1AAjgxQD/140AbmriALD9xgCTCMEAfF10AGutsgDNbp0APnJ7AMYRagD3z6kAKXPfALXJugC3AFEA4rINAHS6JADlfWAAdNiKAA0VLACBGAwAfmaUAAEpFgCfenYA/f2+AFZF7wDZfjYA7NkTAIu6uQDEl/wAMagnAPFuwwCUxTYA2KhWALSotQDPzA4AEoktAG9XNAAsVokAmc7jANYguQBrXqoAPiqcABFfzAD9C0oA4fT7AI47bQDihiwA6dSEAPy0qQDv7tEALjXJAC85YQA4IUQAG9nIAIH8CgD7SmoALxzYAFO0hABOmYwAVCLMACpV3ADAxtYACxmWABpwuABplWQAJlpgAD9S7gB/EQ8A9LURAPzL9QA0vC0ANLzuAOhdzADdXmAAZ46bAJIz7wDJF7gAYVibAOFXvABRg8YA2D4QAN1xSAAtHN0ArxihACEsRgBZ89cA2XqYAJ5UwABPhvoAVgb8AOV5rgCJIjYAOK0iAGeT3ABV6KoAgiY4AMrnmwBRDaQAmTOxAKnXDgBpBUgAZbLwAH+IpwCITJcA+dE2ACGSswB7gkoAmM8hAECf3ADcR1UA4XQ6AGfrQgD+nd8AXtRfAHtnpAC6rHoAVfaiACuIIwBBulUAWW4IACEqhgA5R4MAiePmAOWe1ABJ+0AA/1bpABwPygDFWYoAlPorANPBxQAPxc8A21quAEfFhgCFQ2IAIYY7ACx5lAAQYYcAKkx7AIAsGgBDvxIAiCaQAHg8iQCoxOQA5dt7AMQ6wgAm9OoA92eKAA2SvwBloysAPZOxAL18CwCkUdwAJ91jAGnh3QCalBkAqCmVAGjOKAAJ7bQARJ8gAE6YygBwgmMAfnwjAA+5MgCn9Y4AFFbnACHxCAC1nSoAb35NAKUZUQC1+asAgt/WAJbdYQAWNgIAxDqfAIOioQBy7W0AOY16AIK4qQBrMlwARidbAAA07QDSAHcA/PRVAAFZTQDgcYA=");
  base64DecodeToExistingUint8Array(bufferView, 61539, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNQABFwIdGBMDHhsZCxQIBA0fFhwSGgoHDBURCQYQBQ8OTm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATXVsdGlob3AgYXR0ZW1wdGVkAAAAAAClAlsA8AG1BYwFJQGDBh0DlAT/AMcDMQMLBrwBjwF/A8oEKwDaBq8AQgNOA9wBDgQVAKEGDQGUAgsCOAZkArwC/wJdA+cECwfPAssF7wXbBeECHgZFAoUAggJsA28E8QDzAxgF2QDaA0wGVAJ7AZ0DvQQAAFEAFQK7ALMDbQD/AYUELwX5BDgAZQFGAZ8AtwaoAXMCUwE=");
  base64DecodeToExistingUint8Array(bufferView, 63656, "IQQAAAAAAAAAAC8C");
  base64DecodeToExistingUint8Array(bufferView, 63688, "NQRHBFYE");
  base64DecodeToExistingUint8Array(bufferView, 63710, "oAQ=");
  base64DecodeToExistingUint8Array(bufferView, 63730, "RgVgBW4FYQYAAM8BAAAAAAAAAADJBukG+QYAAAAAAv8ABGQAIAAABP//BgABAAEAAQD//wH/Af//////Af8B/wH/Af8B/wH/Af8B//////8K/yAA//8D/wH/BP8eAAABBf//////YwAACGMA6AMCAAAA//////8AAAAB/wH//////////////w==");
  base64DecodeToExistingUint8Array(bufferView, 63881, "BA==");
  base64DecodeToExistingUint8Array(bufferView, 63894, "Af8B//////8AASAABACAAAAI//8B/wH/////////Af8G/wf/CP8J//////+8ArwCAQD//wEAAQD//wAA//////////8=");
  base64DecodeToExistingUint8Array(bufferView, 63978, "FA==");
  base64DecodeToExistingUint8Array(bufferView, 64010, "//8BAAr///////////8B/wH/AAAAAAAAAf8B/wH/");
  base64DecodeToExistingUint8Array(bufferView, 64058, "Af8AAAAAAAAB/wH/AQAAAAEAAAAB//////8AAAAAAf///wAAAAD/////////////KAAK//////8BAAr/////AP//////////");
  base64DecodeToExistingUint8Array(bufferView, 64230, "Af8B////AQD//////////////////wr//////w==");
  base64DecodeToExistingUint8Array(bufferView, 64272, "AQAAAAEAAAEAAQAA/v//fwAAAACwBAAAKAAAAAAAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 64464, "FA==");
  base64DecodeToExistingUint8Array(bufferView, 64476, "+g==");
  base64DecodeToExistingUint8Array(bufferView, 64523, "QA==");
  base64DecodeToExistingUint8Array(bufferView, 64540, "/v//f////38=");
  base64DecodeToExistingUint8Array(bufferView, 64572, "BwAAAAMAAAA0AAAAAAIAAAAAAABnBQAA5HUAAHMAAAB0AAAAdQAAAHY=");
  base64DecodeToExistingUint8Array(bufferView, 64632, "dwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAADAAAANAAAAAACAAAAAAAAaTMAAOh1AABzAAAAdAAAAHUAAAB2");
  base64DecodeToExistingUint8Array(bufferView, 64720, "dwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAADAAAANAAAAAACAAAAAAAAUjQAAOx1AABzAAAAdAAAAHUAAAB2");
  base64DecodeToExistingUint8Array(bufferView, 64808, "dwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAADAAAANAAAAAACAAAAAAAA1SsAAOR1AABzAAAAdAAAAHUAAAB2");
  base64DecodeToExistingUint8Array(bufferView, 64896, "dwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAAAAABA");
  base64DecodeToExistingUint8Array(bufferView, 64944, "JCoAAJQAAAAAAAAALzIAAJUAAAAAAAAAOxAAAJYAAAAAAAAAhjcAAJcAAAAAAAAA6AwAAJgAAAAAAAAA0gwAAJkAAAAAAAAACTEAAJoAAAAAAAAAJCsAAJsAAAAAAAAA4T0AAJwAAAAAAAAA4D0=");
  base64DecodeToExistingUint8Array(bufferView, 65064, "DFk=");
  base64DecodeToExistingUint8Array(bufferView, 65076, "lDAAAJ0AAAAAAAAAkzA=");
  base64DecodeToExistingUint8Array(bufferView, 65100, "A1k=");
  base64DecodeToExistingUint8Array(bufferView, 65112, "rDcAAJ4AAAAAAAAA/zA=");
  base64DecodeToExistingUint8Array(bufferView, 65136, "TSwAAJ8AAAAAAAAAWQQAAKAAAAAAAAAApSEAAKEAAAAAAAAAnyEAAKIAAAAAAAAAyCUAAKMAAAAAAAAAjDgAAKQAAAAAAAAA9yQAAKUAAAAAAAAA8CQAAKYAAAAAAAAA/CQ=");
  base64DecodeToExistingUint8Array(bufferView, 65244, "XC8AAKcAAAAAAAAAVCwAAKgAAAAAAAAAzAwAAKkAAAAAAAAAKis=");
  base64DecodeToExistingUint8Array(bufferView, 65304, "siQAAKkkAAC2JAAAyl4=");
  base64DecodeToExistingUint8Array(bufferView, 65328, "CkYAAE1PAABhRwAAQkoAAM5MAABFRw==");
  base64DecodeToExistingUint8Array(bufferView, 65360, "AgAAAAFIxAABAAAAAAAAANI=");
  base64DecodeToExistingUint8Array(bufferView, 65392, "XAYAAAAAAAACAAAAAUjEAAMAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 65432, "FTMAAAAAAAACAAAAAUjEAAIAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 65472, "uiAAAAAAAAABAAAAAUjEAAQAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 65512, "EAQAAAAAAAABAAAAASCA");
  base64DecodeToExistingUint8Array(bufferView, 65536, "0w==");
  base64DecodeToExistingUint8Array(bufferView, 65552, "iDoAAAAAAAABAAAAASCA");
  base64DecodeToExistingUint8Array(bufferView, 65576, "1A==");
  base64DecodeToExistingUint8Array(bufferView, 65592, "bQwAAAAAAAABAAAAAQzAAGMAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 65632, "+wQAAAAAAAACAAAAAQzAAGMAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 65672, "oTcAAAAAAAABAAAAAQzAAGMAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 65712, "/QQAAAAAAAABAAAAAQiAAAEAAAAAAAAA1Q==");
  base64DecodeToExistingUint8Array(bufferView, 65752, "wSoAAAAAAAACAAAAAQiAAAEAAAAAAAAA1Q==");
  base64DecodeToExistingUint8Array(bufferView, 65792, "wSoAAAAAAAABAAAAAQiAAAIAAAAAAAAA1Q==");
  base64DecodeToExistingUint8Array(bufferView, 65832, "uyoAAAAAAAACAAAAAQiAAAIAAAAAAAAA1Q==");
  base64DecodeToExistingUint8Array(bufferView, 65872, "uyoAAAAAAAABAAAAAQiAAAMAAAAAAAAA1Q==");
  base64DecodeToExistingUint8Array(bufferView, 65912, "wioAAAAAAAACAAAAAQiAAAMAAAAAAAAA1Q==");
  base64DecodeToExistingUint8Array(bufferView, 65952, "wioAAAAAAAD/AAAAIQiA");
  base64DecodeToExistingUint8Array(bufferView, 65976, "1g==");
  base64DecodeToExistingUint8Array(bufferView, 65992, "+yk=");
  base64DecodeToExistingUint8Array(bufferView, 66004, "IQiA");
  base64DecodeToExistingUint8Array(bufferView, 66032, "+ykAAAAAAAABAAAAIRCACAAAAAAAAAAA1wAAANgAAADZAAAAAAAAAPspAAAAAAAA/wAAACEIgAABAAAAAAAAANY=");
  base64DecodeToExistingUint8Array(bufferView, 66112, "GwY=");
  base64DecodeToExistingUint8Array(bufferView, 66124, "IQiAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 66152, "GwYAAAAAAAABAAAAIRCACAEAAAAAAAAA1wAAANgAAADZAAAAAAAAABsGAAAAAAAAAQAAAIEIgA==");
  base64DecodeToExistingUint8Array(bufferView, 66216, "2g==");
  base64DecodeToExistingUint8Array(bufferView, 66232, "Bi8AAAAAAAABAAAAgQiA");
  base64DecodeToExistingUint8Array(bufferView, 66256, "2w==");
  base64DecodeToExistingUint8Array(bufferView, 66272, "MDMAAAAAAAABAAAAQQiA");
  base64DecodeToExistingUint8Array(bufferView, 66296, "3A==");
  base64DecodeToExistingUint8Array(bufferView, 66312, "pS0AAAAAAAACAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66336, "3Q==");
  base64DecodeToExistingUint8Array(bufferView, 66352, "rSAAAAAAAAD/AAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66376, "3g==");
  base64DecodeToExistingUint8Array(bufferView, 66392, "/y4AAAAAAAD/AAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66416, "3g==");
  base64DecodeToExistingUint8Array(bufferView, 66432, "/gwAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66456, "3w==");
  base64DecodeToExistingUint8Array(bufferView, 66472, "5DYAAAAAAAD/AAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66496, "4A==");
  base64DecodeToExistingUint8Array(bufferView, 66512, "ZyQAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66536, "4Q==");
  base64DecodeToExistingUint8Array(bufferView, 66552, "HBYAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66576, "4g==");
  base64DecodeToExistingUint8Array(bufferView, 66592, "szcAAAAAAAACAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66616, "4g==");
  base64DecodeToExistingUint8Array(bufferView, 66632, "szcAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66656, "4w==");
  base64DecodeToExistingUint8Array(bufferView, 66672, "uyIAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66696, "5A==");
  base64DecodeToExistingUint8Array(bufferView, 66712, "2SEAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 66736, "5Q==");
  base64DecodeToExistingUint8Array(bufferView, 66752, "qwUAAAAAAAACAAAAAQjA");
  base64DecodeToExistingUint8Array(bufferView, 66776, "0g==");
  base64DecodeToExistingUint8Array(bufferView, 66792, "Uys=");
  base64DecodeToExistingUint8Array(bufferView, 66804, "AQCA");
  base64DecodeToExistingUint8Array(bufferView, 66816, "5g==");
  base64DecodeToExistingUint8Array(bufferView, 66832, "rSoAAAAAAAABAAAAAQCA");
  base64DecodeToExistingUint8Array(bufferView, 66856, "5w==");
  base64DecodeToExistingUint8Array(bufferView, 66872, "fkQAAAAAAAACAAAAIQiA");
  base64DecodeToExistingUint8Array(bufferView, 66896, "6A==");
  base64DecodeToExistingUint8Array(bufferView, 66912, "LS8=");
  base64DecodeToExistingUint8Array(bufferView, 66924, "ASCA");
  base64DecodeToExistingUint8Array(bufferView, 66936, "0g==");
  base64DecodeToExistingUint8Array(bufferView, 66952, "oCg=");
  base64DecodeToExistingUint8Array(bufferView, 66964, "ASCA");
  base64DecodeToExistingUint8Array(bufferView, 66976, "6Q==");
  base64DecodeToExistingUint8Array(bufferView, 66992, "4DgAAAAAAAACAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67016, "6g==");
  base64DecodeToExistingUint8Array(bufferView, 67032, "XS4AAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67056, "6w==");
  base64DecodeToExistingUint8Array(bufferView, 67072, "jTA=");
  base64DecodeToExistingUint8Array(bufferView, 67084, "AQCA");
  base64DecodeToExistingUint8Array(bufferView, 67096, "7A==");
  base64DecodeToExistingUint8Array(bufferView, 67112, "CDg=");
  base64DecodeToExistingUint8Array(bufferView, 67124, "AQCA");
  base64DecodeToExistingUint8Array(bufferView, 67136, "7Q==");
  base64DecodeToExistingUint8Array(bufferView, 67152, "2hU=");
  base64DecodeToExistingUint8Array(bufferView, 67164, "AQCA");
  base64DecodeToExistingUint8Array(bufferView, 67176, "7g==");
  base64DecodeToExistingUint8Array(bufferView, 67192, "1BUAAAAAAAADAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67216, "7w==");
  base64DecodeToExistingUint8Array(bufferView, 67232, "RTcAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67256, "8A==");
  base64DecodeToExistingUint8Array(bufferView, 67272, "dUQAAAAAAAACAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67296, "8Q==");
  base64DecodeToExistingUint8Array(bufferView, 67312, "syAAAAAAAAADAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67336, "8Q==");
  base64DecodeToExistingUint8Array(bufferView, 67352, "syAAAAAAAAACAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67376, "8Q==");
  base64DecodeToExistingUint8Array(bufferView, 67392, "nS4AAAAAAAADAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67416, "8Q==");
  base64DecodeToExistingUint8Array(bufferView, 67432, "nS4AAAAAAAABAAAAAQCA");
  base64DecodeToExistingUint8Array(bufferView, 67456, "8gAAAPMAAADzAAAA9AAAAJIqAAAAAAAAAQAAAAEAgA==");
  base64DecodeToExistingUint8Array(bufferView, 67496, "8gAAAPUAAAD1AAAA9AAAAO8rAAAAAAAAAQAAAAEAgA==");
  base64DecodeToExistingUint8Array(bufferView, 67536, "8gAAAPYAAAD2AAAA9AAAAFQu");
  base64DecodeToExistingUint8Array(bufferView, 67564, "AQGACAAAAAAAAAAA9wAAAPgAAAD4AAAA+QAAAG4JAAAAAAAAAQAAAAEAgAgAAAAAAAAAAPcAAAD4AAAA+AAAAPkAAABuCQAAAAAAAAEAAAABAIA=");
  base64DecodeToExistingUint8Array(bufferView, 67656, "+gAAAPsAAAD8AAAA/QAAAAUNAAAAAAAAAgAAAAEAgA==");
  base64DecodeToExistingUint8Array(bufferView, 67696, "+gAAAPsAAAD8AAAA/QAAAAUNAAAAAAAAAgAAAA0IgABIdgAAAAAAAD4=");
  base64DecodeToExistingUint8Array(bufferView, 67752, "cEQAAAAAAAACAAAABQiAAEx2AAAAAAAAPg==");
  base64DecodeToExistingUint8Array(bufferView, 67792, "ITYAAAAAAAADAAAABQiAAEx2AAAAAAAAPg==");
  base64DecodeToExistingUint8Array(bufferView, 67832, "ITYAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67872, "/zY=");
  base64DecodeToExistingUint8Array(bufferView, 67884, "AQiA");
  base64DecodeToExistingUint8Array(bufferView, 67912, "/zYAAAAAAAABAAAAAQiA");
  base64DecodeToExistingUint8Array(bufferView, 67936, "/g==");
  base64DecodeToExistingUint8Array(bufferView, 67952, "GioAAAAAAAD/AAAAAQjA");
  base64DecodeToExistingUint8Array(bufferView, 67976, "0g==");
  base64DecodeToExistingUint8Array(bufferView, 67992, "/zYAAAAAAAADAAAAAQjAAAUAAAAAAAAA0g==");
  base64DecodeToExistingUint8Array(bufferView, 68032, "NC8=");
  base64DecodeToExistingUint8Array(bufferView, 68048, "CQAAAAEIhA==");
  base64DecodeToExistingUint8Array(bufferView, 68064, "/w==");
  base64DecodeToExistingUint8Array(bufferView, 68080, "3igAAAAAAAAHAAAAAQiE");
  base64DecodeToExistingUint8Array(bufferView, 68105, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 68120, "tDQAAAAAAAAHAAAAAQiE");
  base64DecodeToExistingUint8Array(bufferView, 68144, "AQE=");
  base64DecodeToExistingUint8Array(bufferView, 68160, "xggAAAAAAAADAAAAAQiE");
  base64DecodeToExistingUint8Array(bufferView, 68184, "AgE=");
  base64DecodeToExistingUint8Array(bufferView, 68200, "yygAAAAAAAACAAAAAQiE");
  base64DecodeToExistingUint8Array(bufferView, 68224, "AwE=");
  base64DecodeToExistingUint8Array(bufferView, 68240, "bAU=");
  base64DecodeToExistingUint8Array(bufferView, 68260, "AQCB");
  base64DecodeToExistingUint8Array(bufferView, 68272, "BAEAAAUBAAAFAQAAVgAAACq+");
  base64DecodeToExistingUint8Array(bufferView, 68300, "AQCB");
  base64DecodeToExistingUint8Array(bufferView, 68312, "BgEAAAcBAAAHAQAAVgAAADW+");
  base64DecodeToExistingUint8Array(bufferView, 68340, "AQCB");
  base64DecodeToExistingUint8Array(bufferView, 68352, "CAEAAAkBAAAJAQAAVgAAAEC+");
  base64DecodeToExistingUint8Array(bufferView, 68380, "AQCB");
  base64DecodeToExistingUint8Array(bufferView, 68392, "CgEAAAsBAAALAQAADAEAAEW+");
  base64DecodeToExistingUint8Array(bufferView, 68420, "AQCB");
  base64DecodeToExistingUint8Array(bufferView, 68432, "DQEAAA4BAAAOAQAADwEAAFK+AAAAAAAAAQAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68472, "EAEAABEBAAARAQAAEgEAAFy+AAAAAAAAAQAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68512, "EwEAABQBAAAVAQAAFgEAADDGAAAAAAAAAgAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68552, "FwEAABgBAAAZAQAAVgAAAEC/AAAAAAAAAQAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68592, "GgEAABsBAAAZAQAAVgAAAEq/AAAAAAAAAQAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68632, "VgAAABkBAAAZAQAAVgAAAGK+AAAAAAAAAgAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68672, "VgAAABkBAAAZAQAAVgAAAGK+AAAAAAAAAwAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68712, "VgAAABkBAAAZAQAAVgAAAGK+AAAAAAAAAQAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68752, "VgAAABkBAAAZAQAAVgAAAGe+AAAAAAAAAgAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68792, "VgAAABkBAAAZAQAAVgAAAGe+AAAAAAAAAwAAAAEAgQ==");
  base64DecodeToExistingUint8Array(bufferView, 68832, "VgAAABkBAAAZAQAAVgAAAGe+");
  base64DecodeToExistingUint8Array(bufferView, 68864, "/wAAAAEogAAQ+wAAAAAAABwB");
  base64DecodeToExistingUint8Array(bufferView, 68896, "VQUAAAAAAAD/AAAAASiAABD7AAAAAAAAHQE=");
  base64DecodeToExistingUint8Array(bufferView, 68936, "JC4AAAAAAAD/AAAAASiAABD7AAAAAAAAHgE=");
  base64DecodeToExistingUint8Array(bufferView, 68976, "+jAAAAAAAAD/AAAAASiAABD7AAAAAAAAHwE=");
  base64DecodeToExistingUint8Array(bufferView, 69016, "tzMAAAAAAAD/AAAAASiAABD7AAAAAAAAIAE=");
  base64DecodeToExistingUint8Array(bufferView, 69056, "pjMAAAAAAAD/AAAAASiAABD7AAAAAAAAIQE=");
  base64DecodeToExistingUint8Array(bufferView, 69096, "nTM=");
  base64DecodeToExistingUint8Array(bufferView, 69108, "ASCA");
  base64DecodeToExistingUint8Array(bufferView, 69120, "IgE=");
  base64DecodeToExistingUint8Array(bufferView, 69136, "rzM=");
  base64DecodeToExistingUint8Array(bufferView, 69148, "ASCA");
  base64DecodeToExistingUint8Array(bufferView, 69160, "IwE=");
  base64DecodeToExistingUint8Array(bufferView, 69176, "wCQ=");
  base64DecodeToExistingUint8Array(bufferView, 69188, "ASCA");
  base64DecodeToExistingUint8Array(bufferView, 69200, "JAE=");
  base64DecodeToExistingUint8Array(bufferView, 69216, "8jA=");
  base64DecodeToExistingUint8Array(bufferView, 69232, "AQAAAAEIoA==");
  base64DecodeToExistingUint8Array(bufferView, 69248, "JQE=");
  base64DecodeToExistingUint8Array(bufferView, 69264, "4iUAAAAAAAD/AAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69288, "JgE=");
  base64DecodeToExistingUint8Array(bufferView, 69304, "SgUAAAAAAAABAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69328, "JwE=");
  base64DecodeToExistingUint8Array(bufferView, 69344, "hS0AAAAAAAACAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69368, "JwE=");
  base64DecodeToExistingUint8Array(bufferView, 69384, "hS0AAAAAAAD/AAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69408, "KAE=");
  base64DecodeToExistingUint8Array(bufferView, 69424, "tgwAAAAAAAACAAAAAQigAAEAAAAAAAAAKAE=");
  base64DecodeToExistingUint8Array(bufferView, 69464, "6VIAAAAAAAACAAAAAQigAAIAAAAAAAAAKAE=");
  base64DecodeToExistingUint8Array(bufferView, 69504, "5VIAAAAAAAD/AAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69528, "KQE=");
  base64DecodeToExistingUint8Array(bufferView, 69544, "EAkAAAAAAAD/AAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69568, "KgE=");
  base64DecodeToExistingUint8Array(bufferView, 69584, "qgwAAAAAAAACAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69608, "KwE=");
  base64DecodeToExistingUint8Array(bufferView, 69624, "zS0AAAAAAAABAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69648, "LAE=");
  base64DecodeToExistingUint8Array(bufferView, 69664, "iDAAAAAAAAD/AAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69688, "JQE=");
  base64DecodeToExistingUint8Array(bufferView, 69704, "ty8AAAAAAAD/AAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69728, "LQE=");
  base64DecodeToExistingUint8Array(bufferView, 69744, "QDcAAAAAAAD/AAAAAQigAAQAAAAAAAAAKQE=");
  base64DecodeToExistingUint8Array(bufferView, 69784, "9wsAAAAAAAABAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69808, "LgE=");
  base64DecodeToExistingUint8Array(bufferView, 69824, "QzMAAAAAAAACAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69848, "LgE=");
  base64DecodeToExistingUint8Array(bufferView, 69864, "QzMAAAAAAAABAAAAAQig");
  base64DecodeToExistingUint8Array(bufferView, 69888, "LwE=");
  base64DecodeToExistingUint8Array(bufferView, 69904, "nDgAAAAAAAABAAAAAQiw");
  base64DecodeToExistingUint8Array(bufferView, 69928, "MAEAADEBAAAyAQAAMwEAADkFAAAAAAAAAgAAAAEIsA==");
  base64DecodeToExistingUint8Array(bufferView, 69968, "NAEAADUBAAA2AQAAMwEAAJgMAAAAAAAAAgAAAAAAAAAABAAAAAAAAJlEAAAAAAAANwEAAAAAAAA4AQAAOQEAADoBAAA7AQAAPAEAAD0BAAA+AQAAPwEAAAAAAABAAQAAQQE=");
  base64DecodeToExistingUint8Array(bufferView, 70088, "lQEAAJYBAACXAQAAAAAAAJgBAACZAQAAmgEAAJsBAACcAQAAnQEAAJ4B");
  base64DecodeToExistingUint8Array(bufferView, 70184, "lQEAAJYBAACXAQAAAAAAAJ8BAACZAQAAmgEAAJsBAACcAQAAnQEAAJ4B");
  base64DecodeToExistingUint8Array(bufferView, 70280, "oAEAAKEBAACiAQAAAAAAAKMBAACkAQAApQEAAKYBAACnAQAAqAEAAKkB");
  base64DecodeToExistingUint8Array(bufferView, 70368, "8BdR");
}

  var scratchBuffer = new ArrayBuffer(16);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
function asmFunc(env) {
 var memory = env.memory;
 var buffer = memory.buffer;
 var HEAP8 = new Int8Array(buffer);
 var HEAP16 = new Int16Array(buffer);
 var HEAP32 = new Int32Array(buffer);
 var HEAPU8 = new Uint8Array(buffer);
 var HEAPU16 = new Uint16Array(buffer);
 var HEAPU32 = new Uint32Array(buffer);
 var HEAPF32 = new Float32Array(buffer);
 var HEAPF64 = new Float64Array(buffer);
 var Math_imul = Math.imul;
 var Math_fround = Math.fround;
 var Math_abs = Math.abs;
 var Math_clz32 = Math.clz32;
 var Math_min = Math.min;
 var Math_max = Math.max;
 var Math_floor = Math.floor;
 var Math_ceil = Math.ceil;
 var Math_trunc = Math.trunc;
 var Math_sqrt = Math.sqrt;
 var abort = env.abort;
 var nan = NaN;
 var infinity = Infinity;
 var __assert_fail = env.__assert_fail;
 var __syscall_faccessat = env.__syscall_faccessat;
 var __wasi_fd_close = env.fd_close;
 var _tzset_js = env._tzset_js;
 var _localtime_js = env._localtime_js;
 var _emscripten_date_now = env._emscripten_date_now;
 var emscripten_get_now = env.emscripten_get_now;
 var __syscall_fchmod = env.__syscall_fchmod;
 var __syscall_chmod = env.__syscall_chmod;
 var __syscall_fchown32 = env.__syscall_fchown32;
 var __syscall_fcntl64 = env.__syscall_fcntl64;
 var __syscall_fstat64 = env.__syscall_fstat64;
 var __syscall_stat64 = env.__syscall_stat64;
 var __syscall_lstat64 = env.__syscall_lstat64;
 var __syscall_newfstatat = env.__syscall_newfstatat;
 var __wasi_fd_sync = env.fd_sync;
 var __syscall_getcwd = env.__syscall_getcwd;
 var __wasi_environ_sizes_get = env.environ_sizes_get;
 var __wasi_environ_get = env.environ_get;
 var __syscall_mkdirat = env.__syscall_mkdirat;
 var _munmap_js = env._munmap_js;
 var _mmap_js = env._mmap_js;
 var __syscall_openat = env.__syscall_openat;
 var __wasi_fd_read = env.fd_read;
 var __syscall_readlinkat = env.__syscall_readlinkat;
 var __syscall_rmdir = env.__syscall_rmdir;
 var __wasi_fd_write = env.fd_write;
 var emscripten_get_heap_max = env.emscripten_get_heap_max;
 var __syscall_unlinkat = env.__syscall_unlinkat;
 var __syscall_utimensat = env.__syscall_utimensat;
 var __wasi_fd_fdstat_get = env.fd_fdstat_get;
 var emscripten_resize_heap = env.emscripten_resize_heap;
 var legalimport$__syscall_ftruncate64 = env.__syscall_ftruncate64;
 var legalimport$__wasi_fd_seek = env.fd_seek;
 var __stack_pointer = 5314544;
 var tempRet0 = 0;
 var __wasm_intrinsics_temp_i64 = 0;
 var __wasm_intrinsics_temp_i64$hi = 0;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
function sqlite3VdbeExec($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 $8 = __stack_pointer - 336 | 0;
 __stack_pointer = $8;
 $15 = HEAP32[$0 + 88 >> 2];
 $22 = HEAP32[$0 + 104 >> 2];
 $11 = HEAP32[$0 >> 2];
 $25 = HEAPU8[$11 + 84 | 0];
 sqlite3VdbeEnter($0);
 if (HEAP32[$11 + 368 >> 2]) {
  $1 = HEAP32[$11 + 376 >> 2];
  $30 = $1 - (HEAPU32[$0 + 176 >> 2] % ($1 >>> 0) | 0) | 0;
  $4 = 0;
 } else {
  $30 = -1;
  $9 = -1;
  $4 = -1;
 }
 $32 = $9;
 label$3: {
  label$4: {
   label$5: {
    label$6: {
     if (HEAP32[$0 + 36 >> 2] == 7) {
      $3 = $22;
      break label$6;
     }
     HEAP32[$0 + 120 >> 2] = 0;
     HEAP32[$0 + 56 >> 2] = 0;
     HEAP32[$0 + 60 >> 2] = 0;
     HEAP32[$0 + 36 >> 2] = 0;
     HEAP32[$11 + 452 >> 2] = 0;
     if (HEAP32[$11 + 296 >> 2]) {
      $6 = 9;
      $3 = $22;
      break label$5;
     }
     $39 = $11 + 488 | 0;
     $34 = $0 + 212 | 0;
     $31 = $0 + 124 | 0;
     $42 = $0 + 232 | 0;
     $3 = Math_imul(HEAP32[$0 + 32 >> 2], 20) + $22 | 0;
     $40 = $8 + 296 | 4;
     $43 = $8 + 300 | 0;
     $44 = $8 + 304 | 0;
     while (1) {
      $9 = $35;
      $7 = $9;
      $4 = $36;
      $12 = $4 + 1 | 0;
      $7 = $12 ? $7 : $7 + 1 | 0;
      $36 = $12;
      $35 = $7;
      label$10: {
       label$11: {
        label$12: {
         label$13: {
          label$14: {
           label$15: {
            label$16: {
             label$17: {
              label$18: {
               label$19: {
                label$20: {
                 label$21: {
                  label$22: {
                   label$23: {
                    label$24: {
                     label$25: {
                      label$26: {
                       label$27: {
                        label$28: {
                         label$29: {
                          label$30: {
                           label$31: {
                            label$32: {
                             label$33: {
                              label$34: {
                               label$35: {
                                label$36: {
                                 label$37: {
                                  label$38: {
                                   label$39: {
                                    label$40: {
                                     label$41: {
                                      label$42: {
                                       label$43: {
                                        label$44: {
                                         label$45: {
                                          label$46: {
                                           label$47: {
                                            label$48: {
                                             label$49: {
                                              label$50: {
                                               label$51: {
                                                label$52: {
                                                 label$53: {
                                                  label$54: {
                                                   label$55: {
                                                    label$56: {
                                                     label$57: {
                                                      label$58: {
                                                       label$59: {
                                                        label$60: {
                                                         label$61: {
                                                          label$62: {
                                                           label$63: {
                                                            label$64: {
                                                             label$65: {
                                                              label$66: {
                                                               label$67: {
                                                                label$68: {
                                                                 label$69: {
                                                                  label$70: {
                                                                   label$71: {
                                                                    label$72: {
                                                                     label$73: {
                                                                      label$74: {
                                                                       label$75: {
                                                                        label$76: {
                                                                         label$77: {
                                                                          label$78: {
                                                                           label$79: {
                                                                            label$80: {
                                                                             label$81: {
                                                                              label$82: {
                                                                               label$83: {
                                                                                label$84: {
                                                                                 label$85: {
                                                                                  label$86: {
                                                                                   label$87: {
                                                                                    label$88: {
                                                                                     label$89: {
                                                                                      label$90: {
                                                                                       label$91: {
                                                                                        label$92: {
                                                                                         label$93: {
                                                                                          label$94: {
                                                                                           label$95: {
                                                                                            label$96: {
                                                                                             label$97: {
                                                                                              label$98: {
                                                                                               label$99: {
                                                                                                label$100: {
                                                                                                 label$101: {
                                                                                                  label$102: {
                                                                                                   label$103: {
                                                                                                    label$104: {
                                                                                                     label$105: {
                                                                                                      label$106: {
                                                                                                       label$107: {
                                                                                                        label$108: {
                                                                                                         label$109: {
                                                                                                          label$110: {
                                                                                                           label$111: {
                                                                                                            label$112: {
                                                                                                             label$113: {
                                                                                                              label$114: {
                                                                                                               label$115: {
                                                                                                                label$116: {
                                                                                                                 label$117: {
                                                                                                                  label$118: {
                                                                                                                   label$119: {
                                                                                                                    label$120: {
                                                                                                                     label$121: {
                                                                                                                      label$122: {
                                                                                                                       label$123: {
                                                                                                                        label$124: {
                                                                                                                         label$125: {
                                                                                                                          label$126: {
                                                                                                                           label$127: {
                                                                                                                            label$128: {
                                                                                                                             label$129: {
                                                                                                                              label$130: {
                                                                                                                               label$131: {
                                                                                                                                label$132: {
                                                                                                                                 label$133: {
                                                                                                                                  label$134: {
                                                                                                                                   label$135: {
                                                                                                                                    label$136: {
                                                                                                                                     label$137: {
                                                                                                                                      label$138: {
                                                                                                                                       label$139: {
                                                                                                                                        label$140: {
                                                                                                                                         label$141: {
                                                                                                                                          label$142: {
                                                                                                                                           label$143: {
                                                                                                                                            label$144: {
                                                                                                                                             label$145: {
                                                                                                                                              label$146: {
                                                                                                                                               label$147: {
                                                                                                                                                label$148: {
                                                                                                                                                 label$149: {
                                                                                                                                                  label$150: {
                                                                                                                                                   label$151: {
                                                                                                                                                    label$152: {
                                                                                                                                                     label$153: {
                                                                                                                                                      label$154: {
                                                                                                                                                       label$155: {
                                                                                                                                                        label$156: {
                                                                                                                                                         label$157: {
                                                                                                                                                          label$158: {
                                                                                                                                                           label$159: {
                                                                                                                                                            label$160: {
                                                                                                                                                             label$161: {
                                                                                                                                                              label$162: {
                                                                                                                                                               label$163: {
                                                                                                                                                                label$164: {
                                                                                                                                                                 label$165: {
                                                                                                                                                                  label$166: {
                                                                                                                                                                   label$167: {
                                                                                                                                                                    label$168: {
                                                                                                                                                                     label$169: {
                                                                                                                                                                      label$170: {
                                                                                                                                                                       label$171: {
                                                                                                                                                                        label$172: {
                                                                                                                                                                         label$173: {
                                                                                                                                                                          label$174: {
                                                                                                                                                                           label$175: {
                                                                                                                                                                            label$176: {
                                                                                                                                                                             label$177: {
                                                                                                                                                                              label$178: {
                                                                                                                                                                               label$179: {
                                                                                                                                                                                label$180: {
                                                                                                                                                                                 label$181: {
                                                                                                                                                                                  label$182: {
                                                                                                                                                                                   label$183: {
                                                                                                                                                                                    label$184: {
                                                                                                                                                                                     label$185: {
                                                                                                                                                                                      label$186: {
                                                                                                                                                                                       label$187: {
                                                                                                                                                                                        label$188: {
                                                                                                                                                                                         label$189: {
                                                                                                                                                                                          $1 = HEAPU8[$3 | 0];
                                                                                                                                                                                          switch ($1 | 0) {
                                                                                                                                                                                          case 154:
                                                                                                                                                                                           break label$100;

                                                                                                                                                                                          case 155:
                                                                                                                                                                                           break label$101;

                                                                                                                                                                                          case 156:
                                                                                                                                                                                           break label$102;

                                                                                                                                                                                          case 45:
                                                                                                                                                                                           break label$103;

                                                                                                                                                                                          case 46:
                                                                                                                                                                                           break label$104;

                                                                                                                                                                                          case 47:
                                                                                                                                                                                           break label$105;

                                                                                                                                                                                          case 157:
                                                                                                                                                                                           break label$106;

                                                                                                                                                                                          case 158:
                                                                                                                                                                                           break label$107;

                                                                                                                                                                                          case 48:
                                                                                                                                                                                           break label$108;

                                                                                                                                                                                          case 159:
                                                                                                                                                                                           break label$109;

                                                                                                                                                                                          case 49:
                                                                                                                                                                                           break label$110;

                                                                                                                                                                                          case 160:
                                                                                                                                                                                           break label$111;

                                                                                                                                                                                          case 59:
                                                                                                                                                                                           break label$112;

                                                                                                                                                                                          case 60:
                                                                                                                                                                                           break label$113;

                                                                                                                                                                                          case 161:
                                                                                                                                                                                          case 162:
                                                                                                                                                                                           break label$115;

                                                                                                                                                                                          case 164:
                                                                                                                                                                                          case 165:
                                                                                                                                                                                           break label$116;

                                                                                                                                                                                          case 3:
                                                                                                                                                                                           break label$117;

                                                                                                                                                                                          case 4:
                                                                                                                                                                                           break label$118;

                                                                                                                                                                                          case 5:
                                                                                                                                                                                           break label$119;

                                                                                                                                                                                          case 8:
                                                                                                                                                                                           break label$12;

                                                                                                                                                                                          case 61:
                                                                                                                                                                                           break label$120;

                                                                                                                                                                                          case 166:
                                                                                                                                                                                           break label$121;

                                                                                                                                                                                          case 167:
                                                                                                                                                                                           break label$122;

                                                                                                                                                                                          case 168:
                                                                                                                                                                                           break label$123;

                                                                                                                                                                                          case 169:
                                                                                                                                                                                           break label$124;

                                                                                                                                                                                          case 170:
                                                                                                                                                                                           break label$125;

                                                                                                                                                                                          case 171:
                                                                                                                                                                                           break label$126;

                                                                                                                                                                                          case 172:
                                                                                                                                                                                           break label$127;

                                                                                                                                                                                          case 173:
                                                                                                                                                                                           break label$128;

                                                                                                                                                                                          case 174:
                                                                                                                                                                                           break label$129;

                                                                                                                                                                                          case 6:
                                                                                                                                                                                           break label$130;

                                                                                                                                                                                          case 175:
                                                                                                                                                                                           break label$131;

                                                                                                                                                                                          case 62:
                                                                                                                                                                                           break label$132;

                                                                                                                                                                                          case 176:
                                                                                                                                                                                           break label$133;

                                                                                                                                                                                          case 7:
                                                                                                                                                                                           break label$134;

                                                                                                                                                                                          case 177:
                                                                                                                                                                                           break label$135;

                                                                                                                                                                                          case 178:
                                                                                                                                                                                           break label$136;

                                                                                                                                                                                          case 65:
                                                                                                                                                                                          case 66:
                                                                                                                                                                                           break label$137;

                                                                                                                                                                                          case 179:
                                                                                                                                                                                           break label$138;

                                                                                                                                                                                          case 180:
                                                                                                                                                                                           break label$139;

                                                                                                                                                                                          case 63:
                                                                                                                                                                                           break label$140;

                                                                                                                                                                                          case 64:
                                                                                                                                                                                          case 181:
                                                                                                                                                                                           break label$141;

                                                                                                                                                                                          case 68:
                                                                                                                                                                                           break label$142;

                                                                                                                                                                                          case 94:
                                                                                                                                                                                           break label$143;

                                                                                                                                                                                          case 18:
                                                                                                                                                                                           break label$144;

                                                                                                                                                                                          case 51:
                                                                                                                                                                                           break label$145;

                                                                                                                                                                                          case 92:
                                                                                                                                                                                           break label$146;

                                                                                                                                                                                          case 17:
                                                                                                                                                                                           break label$147;

                                                                                                                                                                                          case 50:
                                                                                                                                                                                           break label$148;

                                                                                                                                                                                          case 16:
                                                                                                                                                                                           break label$149;

                                                                                                                                                                                          case 15:
                                                                                                                                                                                           break label$150;

                                                                                                                                                                                          case 14:
                                                                                                                                                                                           break label$151;

                                                                                                                                                                                          case 114:
                                                                                                                                                                                           break label$152;

                                                                                                                                                                                          case 19:
                                                                                                                                                                                           break label$153;

                                                                                                                                                                                          case 91:
                                                                                                                                                                                           break label$154;

                                                                                                                                                                                          case 43:
                                                                                                                                                                                          case 44:
                                                                                                                                                                                           break label$155;

                                                                                                                                                                                          case 13:
                                                                                                                                                                                           break label$156;

                                                                                                                                                                                          case 90:
                                                                                                                                                                                           break label$157;

                                                                                                                                                                                          case 58:
                                                                                                                                                                                           break label$158;

                                                                                                                                                                                          case 52:
                                                                                                                                                                                          case 53:
                                                                                                                                                                                          case 54:
                                                                                                                                                                                          case 55:
                                                                                                                                                                                          case 56:
                                                                                                                                                                                          case 57:
                                                                                                                                                                                           break label$159;

                                                                                                                                                                                          case 88:
                                                                                                                                                                                           break label$160;

                                                                                                                                                                                          case 87:
                                                                                                                                                                                           break label$161;

                                                                                                                                                                                          case 12:
                                                                                                                                                                                           break label$162;

                                                                                                                                                                                          case 86:
                                                                                                                                                                                           break label$163;

                                                                                                                                                                                          case 102:
                                                                                                                                                                                          case 103:
                                                                                                                                                                                          case 104:
                                                                                                                                                                                          case 105:
                                                                                                                                                                                           break label$164;

                                                                                                                                                                                          case 85:
                                                                                                                                                                                           break label$165;

                                                                                                                                                                                          case 106:
                                                                                                                                                                                          case 107:
                                                                                                                                                                                          case 108:
                                                                                                                                                                                          case 109:
                                                                                                                                                                                          case 110:
                                                                                                                                                                                           break label$166;

                                                                                                                                                                                          case 111:
                                                                                                                                                                                           break label$167;

                                                                                                                                                                                          case 84:
                                                                                                                                                                                           break label$168;

                                                                                                                                                                                          case 83:
                                                                                                                                                                                           break label$169;

                                                                                                                                                                                          case 82:
                                                                                                                                                                                           break label$170;

                                                                                                                                                                                          case 81:
                                                                                                                                                                                           break label$171;

                                                                                                                                                                                          case 80:
                                                                                                                                                                                           break label$172;

                                                                                                                                                                                          case 79:
                                                                                                                                                                                           break label$173;

                                                                                                                                                                                          case 78:
                                                                                                                                                                                           break label$174;

                                                                                                                                                                                          case 77:
                                                                                                                                                                                           break label$175;

                                                                                                                                                                                          case 76:
                                                                                                                                                                                           break label$176;

                                                                                                                                                                                          case 74:
                                                                                                                                                                                          case 75:
                                                                                                                                                                                           break label$177;

                                                                                                                                                                                          case 73:
                                                                                                                                                                                           break label$178;

                                                                                                                                                                                          case 117:
                                                                                                                                                                                           break label$179;

                                                                                                                                                                                          case 153:
                                                                                                                                                                                           break label$180;

                                                                                                                                                                                          case 72:
                                                                                                                                                                                           break label$181;

                                                                                                                                                                                          case 71:
                                                                                                                                                                                           break label$182;

                                                                                                                                                                                          case 70:
                                                                                                                                                                                           break label$183;

                                                                                                                                                                                          case 69:
                                                                                                                                                                                           break label$184;

                                                                                                                                                                                          case 11:
                                                                                                                                                                                           break label$185;

                                                                                                                                                                                          case 10:
                                                                                                                                                                                           break label$186;

                                                                                                                                                                                          case 67:
                                                                                                                                                                                           break label$187;

                                                                                                                                                                                          case 9:
                                                                                                                                                                                           break label$188;

                                                                                                                                                                                          case 163:
                                                                                                                                                                                           break label$189;

                                                                                                                                                                                          case 95:
                                                                                                                                                                                           break label$35;

                                                                                                                                                                                          case 96:
                                                                                                                                                                                           break label$36;

                                                                                                                                                                                          case 97:
                                                                                                                                                                                           break label$37;

                                                                                                                                                                                          case 98:
                                                                                                                                                                                           break label$38;

                                                                                                                                                                                          case 0:
                                                                                                                                                                                           break label$41;

                                                                                                                                                                                          case 1:
                                                                                                                                                                                           break label$42;

                                                                                                                                                                                          case 2:
                                                                                                                                                                                           break label$43;

                                                                                                                                                                                          case 99:
                                                                                                                                                                                           break label$44;

                                                                                                                                                                                          case 100:
                                                                                                                                                                                           break label$45;

                                                                                                                                                                                          case 112:
                                                                                                                                                                                          case 113:
                                                                                                                                                                                           break label$47;

                                                                                                                                                                                          case 101:
                                                                                                                                                                                           break label$48;

                                                                                                                                                                                          case 115:
                                                                                                                                                                                           break label$49;

                                                                                                                                                                                          case 116:
                                                                                                                                                                                          case 118:
                                                                                                                                                                                           break label$50;

                                                                                                                                                                                          case 119:
                                                                                                                                                                                           break label$51;

                                                                                                                                                                                          case 120:
                                                                                                                                                                                           break label$52;

                                                                                                                                                                                          case 121:
                                                                                                                                                                                           break label$53;

                                                                                                                                                                                          case 122:
                                                                                                                                                                                           break label$54;

                                                                                                                                                                                          case 20:
                                                                                                                                                                                          case 21:
                                                                                                                                                                                          case 22:
                                                                                                                                                                                          case 23:
                                                                                                                                                                                           break label$56;

                                                                                                                                                                                          case 124:
                                                                                                                                                                                           break label$57;

                                                                                                                                                                                          case 125:
                                                                                                                                                                                           break label$58;

                                                                                                                                                                                          case 24:
                                                                                                                                                                                           break label$59;

                                                                                                                                                                                          case 26:
                                                                                                                                                                                          case 27:
                                                                                                                                                                                          case 28:
                                                                                                                                                                                           break label$60;

                                                                                                                                                                                          case 25:
                                                                                                                                                                                           break label$61;

                                                                                                                                                                                          case 29:
                                                                                                                                                                                           break label$64;

                                                                                                                                                                                          case 30:
                                                                                                                                                                                           break label$65;

                                                                                                                                                                                          case 126:
                                                                                                                                                                                           break label$66;

                                                                                                                                                                                          case 127:
                                                                                                                                                                                           break label$67;

                                                                                                                                                                                          case 128:
                                                                                                                                                                                           break label$68;

                                                                                                                                                                                          case 129:
                                                                                                                                                                                           break label$69;

                                                                                                                                                                                          case 130:
                                                                                                                                                                                           break label$70;

                                                                                                                                                                                          case 131:
                                                                                                                                                                                           break label$71;

                                                                                                                                                                                          case 132:
                                                                                                                                                                                           break label$72;

                                                                                                                                                                                          case 133:
                                                                                                                                                                                           break label$73;

                                                                                                                                                                                          case 134:
                                                                                                                                                                                           break label$74;

                                                                                                                                                                                          case 135:
                                                                                                                                                                                           break label$75;

                                                                                                                                                                                          case 136:
                                                                                                                                                                                           break label$76;

                                                                                                                                                                                          case 31:
                                                                                                                                                                                          case 137:
                                                                                                                                                                                           break label$77;

                                                                                                                                                                                          case 32:
                                                                                                                                                                                           break label$78;

                                                                                                                                                                                          case 35:
                                                                                                                                                                                           break label$79;

                                                                                                                                                                                          case 33:
                                                                                                                                                                                          case 34:
                                                                                                                                                                                           break label$80;

                                                                                                                                                                                          case 36:
                                                                                                                                                                                           break label$82;

                                                                                                                                                                                          case 37:
                                                                                                                                                                                           break label$83;

                                                                                                                                                                                          case 38:
                                                                                                                                                                                           break label$84;

                                                                                                                                                                                          case 138:
                                                                                                                                                                                           break label$85;

                                                                                                                                                                                          case 139:
                                                                                                                                                                                           break label$86;

                                                                                                                                                                                          case 140:
                                                                                                                                                                                           break label$87;

                                                                                                                                                                                          case 141:
                                                                                                                                                                                          case 142:
                                                                                                                                                                                           break label$88;

                                                                                                                                                                                          case 143:
                                                                                                                                                                                           break label$89;

                                                                                                                                                                                          case 39:
                                                                                                                                                                                          case 40:
                                                                                                                                                                                          case 41:
                                                                                                                                                                                          case 42:
                                                                                                                                                                                           break label$90;

                                                                                                                                                                                          case 144:
                                                                                                                                                                                           break label$91;

                                                                                                                                                                                          case 145:
                                                                                                                                                                                           break label$92;

                                                                                                                                                                                          case 146:
                                                                                                                                                                                           break label$93;

                                                                                                                                                                                          case 147:
                                                                                                                                                                                           break label$94;

                                                                                                                                                                                          case 148:
                                                                                                                                                                                           break label$95;

                                                                                                                                                                                          case 149:
                                                                                                                                                                                           break label$96;

                                                                                                                                                                                          case 150:
                                                                                                                                                                                           break label$97;

                                                                                                                                                                                          case 151:
                                                                                                                                                                                           break label$98;

                                                                                                                                                                                          case 152:
                                                                                                                                                                                           break label$99;

                                                                                                                                                                                          default:
                                                                                                                                                                                           break label$10;
                                                                                                                                                                                          }
                                                                                                                                                                                         }
                                                                                                                                                                                         $2 = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                                         break label$114;
                                                                                                                                                                                        }
                                                                                                                                                                                        $4 = ($3 - $22 | 0) / 20 | 0;
                                                                                                                                                                                        $7 = $4 >> 31;
                                                                                                                                                                                        $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                                        HEAP32[$1 >> 2] = $4;
                                                                                                                                                                                        HEAP32[$1 + 4 >> 2] = $7;
                                                                                                                                                                                        HEAP16[$1 + 16 >> 1] = 4;
                                                                                                                                                                                        break label$12;
                                                                                                                                                                                       }
                                                                                                                                                                                       $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                                       if (!(HEAPU8[$1 + 16 | 0] & 4)) {
                                                                                                                                                                                        break label$10;
                                                                                                                                                                                       }
                                                                                                                                                                                       $3 = Math_imul(HEAP32[$1 >> 2], 20) + $22 | 0;
                                                                                                                                                                                       break label$10;
                                                                                                                                                                                      }
                                                                                                                                                                                      $1 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                                      $2 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                                      HEAP16[$2 + 16 >> 1] = 4;
                                                                                                                                                                                      $4 = $1 - 1 | 0;
                                                                                                                                                                                      $7 = $4 >> 31;
                                                                                                                                                                                      HEAP32[$2 >> 2] = $4;
                                                                                                                                                                                      HEAP32[$2 + 4 >> 2] = $7;
                                                                                                                                                                                      if (!HEAP32[$3 + 8 >> 2]) {
                                                                                                                                                                                       break label$10;
                                                                                                                                                                                      }
                                                                                                                                                                                      break label$13;
                                                                                                                                                                                     }
                                                                                                                                                                                     $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                                     HEAP16[$1 + 16 >> 1] = 4;
                                                                                                                                                                                     $2 = HEAP32[$1 >> 2];
                                                                                                                                                                                     $4 = ($3 - $22 | 0) / 20 | 0;
                                                                                                                                                                                     $7 = $4 >> 31;
                                                                                                                                                                                     HEAP32[$1 >> 2] = $4;
                                                                                                                                                                                     HEAP32[$1 + 4 >> 2] = $7;
                                                                                                                                                                                     $3 = Math_imul($2, 20) + $22 | 0;
                                                                                                                                                                                     break label$10;
                                                                                                                                                                                    }
                                                                                                                                                                                    if (!(HEAP8[(Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0) + 16 | 0] & 1)) {
                                                                                                                                                                                     break label$10;
                                                                                                                                                                                    }
                                                                                                                                                                                   }
                                                                                                                                                                                   $15 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                                   $1 = HEAP32[$34 >> 2];
                                                                                                                                                                                   if (!($15 | !$1)) {
                                                                                                                                                                                    HEAP32[$0 + 212 >> 2] = HEAP32[$1 + 4 >> 2];
                                                                                                                                                                                    HEAP32[$0 + 220 >> 2] = HEAP32[$0 + 220 >> 2] - 1;
                                                                                                                                                                                    $7 = HEAP32[$0 + 40 >> 2];
                                                                                                                                                                                    $4 = HEAP32[$0 + 44 >> 2];
                                                                                                                                                                                    sqlite3VdbeSetChanges($11, $7, $4);
                                                                                                                                                                                    $1 = sqlite3VdbeFrameRestore($1);
                                                                                                                                                                                    $22 = HEAP32[$0 + 104 >> 2];
                                                                                                                                                                                    $1 = HEAP32[$3 + 8 >> 2] == 4 ? HEAP32[(Math_imul($1, 20) + $22 | 0) + 8 >> 2] - 1 | 0 : $1;
                                                                                                                                                                                    $3 = $22 + Math_imul($1, 20) | 0;
                                                                                                                                                                                    $15 = HEAP32[$0 + 88 >> 2];
                                                                                                                                                                                    break label$10;
                                                                                                                                                                                   }
                                                                                                                                                                                   HEAP32[$0 + 36 >> 2] = $15;
                                                                                                                                                                                   HEAP8[$0 + 146 | 0] = HEAP32[$3 + 8 >> 2];
                                                                                                                                                                                   if ($15) {
                                                                                                                                                                                    $1 = HEAPU16[$3 + 2 >> 1];
                                                                                                                                                                                    label$193: {
                                                                                                                                                                                     if ($1) {
                                                                                                                                                                                      HEAP32[$8 + 80 >> 2] = HEAP32[($1 << 2) + 33164 >> 2];
                                                                                                                                                                                      sqlite3VdbeError($0, 15320, $8 + 80 | 0);
                                                                                                                                                                                      $1 = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                                      if (!$1) {
                                                                                                                                                                                       break label$193;
                                                                                                                                                                                      }
                                                                                                                                                                                      $24 = HEAP32[$31 >> 2];
                                                                                                                                                                                      HEAP32[$8 + 68 >> 2] = $1;
                                                                                                                                                                                      HEAP32[$8 + 64 >> 2] = $24;
                                                                                                                                                                                      HEAP32[$31 >> 2] = sqlite3MPrintf($11, 6959, $8 - -64 | 0);
                                                                                                                                                                                      break label$193;
                                                                                                                                                                                     }
                                                                                                                                                                                     HEAP32[$8 + 48 >> 2] = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                                     sqlite3VdbeError($0, 8342, $8 + 48 | 0);
                                                                                                                                                                                    }
                                                                                                                                                                                    $1 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                                    $24 = HEAP32[$0 + 196 >> 2];
                                                                                                                                                                                    HEAP32[$8 + 40 >> 2] = HEAP32[$0 + 124 >> 2];
                                                                                                                                                                                    HEAP32[$8 + 36 >> 2] = $24;
                                                                                                                                                                                    HEAP32[$8 + 32 >> 2] = ($3 - $22 | 0) / 20;
                                                                                                                                                                                    sqlite3_log($1, 8276, $8 + 32 | 0);
                                                                                                                                                                                   }
                                                                                                                                                                                   $24 = 5;
                                                                                                                                                                                   if ((sqlite3VdbeHalt($0) | 0) == 5) {
                                                                                                                                                                                    break label$15;
                                                                                                                                                                                   }
                                                                                                                                                                                   $24 = HEAP32[$0 + 36 >> 2] ? 1 : 101;
                                                                                                                                                                                   break label$14;
                                                                                                                                                                                  }
                                                                                                                                                                                  $17 = out2Prerelease($0, $3);
                                                                                                                                                                                  $4 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                                  $7 = $4 >> 31;
                                                                                                                                                                                  $10 = $4;
                                                                                                                                                                                  $4 = $17;
                                                                                                                                                                                  HEAP32[$4 >> 2] = $10;
                                                                                                                                                                                  HEAP32[$4 + 4 >> 2] = $7;
                                                                                                                                                                                  break label$10;
                                                                                                                                                                                 }
                                                                                                                                                                                 $17 = out2Prerelease($0, $3);
                                                                                                                                                                                 $9 = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                                 $7 = HEAP32[$9 >> 2];
                                                                                                                                                                                 $4 = HEAP32[$9 + 4 >> 2];
                                                                                                                                                                                 $10 = $7;
                                                                                                                                                                                 $7 = $17;
                                                                                                                                                                                 HEAP32[$7 >> 2] = $10;
                                                                                                                                                                                 HEAP32[$7 + 4 >> 2] = $4;
                                                                                                                                                                                 break label$10;
                                                                                                                                                                                }
                                                                                                                                                                                $1 = out2Prerelease($0, $3);
                                                                                                                                                                                HEAP16[$1 + 16 >> 1] = 8;
                                                                                                                                                                                HEAPF64[$1 >> 3] = HEAPF64[HEAP32[$3 + 16 >> 2] >> 3];
                                                                                                                                                                                break label$10;
                                                                                                                                                                               }
                                                                                                                                                                               $1 = out2Prerelease($0, $3);
                                                                                                                                                                               $5 = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                               $2 = sqlite3Strlen30($5);
                                                                                                                                                                               HEAP32[$3 + 4 >> 2] = $2;
                                                                                                                                                                               if (($25 | 0) != 1) {
                                                                                                                                                                                if (sqlite3VdbeMemSetStr($1, $5, -1, -1, 1, 0)) {
                                                                                                                                                                                 break label$25;
                                                                                                                                                                                }
                                                                                                                                                                                if (sqlite3VdbeChangeEncoding($1, $25)) {
                                                                                                                                                                                 break label$6;
                                                                                                                                                                                }
                                                                                                                                                                                $6 = 0;
                                                                                                                                                                                HEAP32[$1 + 24 >> 2] = 0;
                                                                                                                                                                                HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] | 8192;
                                                                                                                                                                                if (HEAPU8[$3 + 1 | 0] == 250) {
                                                                                                                                                                                 sqlite3DbFree($11, HEAP32[$3 + 16 >> 2]);
                                                                                                                                                                                }
                                                                                                                                                                                HEAP8[$3 + 1 | 0] = 250;
                                                                                                                                                                                HEAP32[$3 + 16 >> 2] = HEAP32[$1 + 8 >> 2];
                                                                                                                                                                                $2 = HEAP32[$1 + 12 >> 2];
                                                                                                                                                                                HEAP32[$3 + 4 >> 2] = $2;
                                                                                                                                                                               }
                                                                                                                                                                               if (HEAP32[$11 + 120 >> 2] < ($2 | 0)) {
                                                                                                                                                                                break label$25;
                                                                                                                                                                               }
                                                                                                                                                                               HEAP8[$3 | 0] = 73;
                                                                                                                                                                              }
                                                                                                                                                                              $1 = out2Prerelease($0, $3);
                                                                                                                                                                              HEAP16[$1 + 16 >> 1] = 8706;
                                                                                                                                                                              HEAP32[$1 + 8 >> 2] = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                              $2 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                              HEAP8[$1 + 18 | 0] = $25;
                                                                                                                                                                              HEAP32[$1 + 12 >> 2] = $2;
                                                                                                                                                                              $2 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                              if (($2 | 0) <= 0) {
                                                                                                                                                                               break label$10;
                                                                                                                                                                              }
                                                                                                                                                                              $9 = Math_imul($2, 40) + $15 | 0;
                                                                                                                                                                              $4 = HEAP32[$9 >> 2];
                                                                                                                                                                              $7 = HEAP32[$9 + 4 >> 2];
                                                                                                                                                                              $17 = $7;
                                                                                                                                                                              $7 = HEAPU16[$3 + 2 >> 1];
                                                                                                                                                                              $10 = $7;
                                                                                                                                                                              $9 = $4;
                                                                                                                                                                              $4 = $17;
                                                                                                                                                                              if (($9 | 0) != ($10 | 0) | $4) {
                                                                                                                                                                               break label$10;
                                                                                                                                                                              }
                                                                                                                                                                              HEAP16[$1 + 16 >> 1] = 8720;
                                                                                                                                                                              break label$10;
                                                                                                                                                                             }
                                                                                                                                                                             $1 = out2Prerelease($0, $3);
                                                                                                                                                                             $2 = HEAP32[$3 + 8 >> 2];
                                                                                                                                                                             $5 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                             $13 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                             HEAP32[$1 + 12 >> 2] = 0;
                                                                                                                                                                             $13 = $13 ? 257 : 1;
                                                                                                                                                                             HEAP16[$1 + 16 >> 1] = $13;
                                                                                                                                                                             $2 = $5 - $2 | 0;
                                                                                                                                                                             while (1) {
                                                                                                                                                                              if (($2 | 0) <= 0) {
                                                                                                                                                                               break label$10;
                                                                                                                                                                              }
                                                                                                                                                                              $5 = $1 + 40 | 0;
                                                                                                                                                                              sqlite3VdbeMemSetNull($5);
                                                                                                                                                                              HEAP32[$1 + 52 >> 2] = 0;
                                                                                                                                                                              HEAP16[$1 + 56 >> 1] = $13;
                                                                                                                                                                              $2 = $2 - 1 | 0;
                                                                                                                                                                              $1 = $5;
                                                                                                                                                                              continue;
                                                                                                                                                                             }
                                                                                                                                                                            }
                                                                                                                                                                            $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                            HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 65472 | 1;
                                                                                                                                                                            break label$10;
                                                                                                                                                                           }
                                                                                                                                                                           $1 = out2Prerelease($0, $3);
                                                                                                                                                                           $2 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                           $5 = HEAP32[$3 + 16 >> 2];
                                                                                                                                                                           label$198: {
                                                                                                                                                                            if (!$5) {
                                                                                                                                                                             sqlite3VdbeMemSetZeroBlob($1, $2);
                                                                                                                                                                             if (!sqlite3VdbeMemExpandBlob($1)) {
                                                                                                                                                                              break label$198;
                                                                                                                                                                             }
                                                                                                                                                                             break label$6;
                                                                                                                                                                            }
                                                                                                                                                                            $9 = $2 >> 31;
                                                                                                                                                                            sqlite3VdbeMemSetStr($1, $5, $2, $9, 0, 0);
                                                                                                                                                                           }
                                                                                                                                                                           HEAP8[$1 + 18 | 0] = $25;
                                                                                                                                                                           break label$10;
                                                                                                                                                                          }
                                                                                                                                                                          $2 = (HEAP32[$0 + 100 >> 2] + Math_imul(HEAP32[$3 + 4 >> 2], 40) | 0) - 40 | 0;
                                                                                                                                                                          if (sqlite3VdbeMemTooBig($2)) {
                                                                                                                                                                           break label$25;
                                                                                                                                                                          }
                                                                                                                                                                          $1 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                                          if (HEAPU8[$1 + 17 | 0] & 144) {
                                                                                                                                                                           sqlite3VdbeMemSetNull($1);
                                                                                                                                                                          }
                                                                                                                                                                          $4 = HEAP32[$2 + 4 >> 2];
                                                                                                                                                                          $9 = HEAP32[$2 >> 2];
                                                                                                                                                                          HEAP32[$1 >> 2] = $9;
                                                                                                                                                                          HEAP32[$1 + 4 >> 2] = $4;
                                                                                                                                                                          HEAP32[$1 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
                                                                                                                                                                          $9 = HEAP32[$2 + 12 >> 2];
                                                                                                                                                                          $4 = HEAP32[$2 + 8 >> 2];
                                                                                                                                                                          HEAP32[$1 + 8 >> 2] = $4;
                                                                                                                                                                          HEAP32[$1 + 12 >> 2] = $9;
                                                                                                                                                                          HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 36799 | 8256;
                                                                                                                                                                          break label$10;
                                                                                                                                                                         }
                                                                                                                                                                         $1 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                                         $2 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                         $5 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                         while (1) {
                                                                                                                                                                          sqlite3VdbeMemMove($1, $2);
                                                                                                                                                                          if (HEAPU8[$1 + 17 | 0] & 64) {
                                                                                                                                                                           if (sqlite3VdbeMemMakeWriteable($1)) {
                                                                                                                                                                            break label$6;
                                                                                                                                                                           }
                                                                                                                                                                          }
                                                                                                                                                                          $1 = $1 + 40 | 0;
                                                                                                                                                                          $2 = $2 + 40 | 0;
                                                                                                                                                                          $5 = $5 - 1 | 0;
                                                                                                                                                                          if ($5) {
                                                                                                                                                                           continue;
                                                                                                                                                                          }
                                                                                                                                                                          break;
                                                                                                                                                                         }
                                                                                                                                                                         break label$10;
                                                                                                                                                                        }
                                                                                                                                                                        $1 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                                        $2 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                        $5 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                        while (1) {
                                                                                                                                                                         sqlite3VdbeMemShallowCopy($1, $2, 16384);
                                                                                                                                                                         $13 = HEAPU16[$1 + 16 >> 1];
                                                                                                                                                                         if ($13 & 16384) {
                                                                                                                                                                          if (sqlite3VdbeMemMakeWriteable($1)) {
                                                                                                                                                                           break label$6;
                                                                                                                                                                          }
                                                                                                                                                                          $13 = HEAPU16[$1 + 16 >> 1];
                                                                                                                                                                         }
                                                                                                                                                                         if (!(!($13 & 2048) | !(HEAPU8[$3 + 2 | 0] & 2))) {
                                                                                                                                                                          HEAP16[$1 + 16 >> 1] = $13 & 63487;
                                                                                                                                                                         }
                                                                                                                                                                         if (!$5) {
                                                                                                                                                                          break label$10;
                                                                                                                                                                         }
                                                                                                                                                                         $2 = $2 + 40 | 0;
                                                                                                                                                                         $1 = $1 + 40 | 0;
                                                                                                                                                                         $5 = $5 - 1 | 0;
                                                                                                                                                                         continue;
                                                                                                                                                                        }
                                                                                                                                                                       }
                                                                                                                                                                       sqlite3VdbeMemShallowCopy(Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0, Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0, 16384);
                                                                                                                                                                       break label$10;
                                                                                                                                                                      }
                                                                                                                                                                      $10 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                      $9 = HEAP32[$10 >> 2];
                                                                                                                                                                      $4 = HEAP32[$10 + 4 >> 2];
                                                                                                                                                                      sqlite3VdbeMemSetInt64(Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0, $9, $4);
                                                                                                                                                                      break label$10;
                                                                                                                                                                     }
                                                                                                                                                                     $6 = 0;
                                                                                                                                                                     $1 = sqlite3VdbeCheckFk($0, 0);
                                                                                                                                                                     if (!$1) {
                                                                                                                                                                      break label$10;
                                                                                                                                                                     }
                                                                                                                                                                     $6 = $1;
                                                                                                                                                                     break label$5;
                                                                                                                                                                    }
                                                                                                                                                                    HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 2 | 1;
                                                                                                                                                                    HEAP32[$0 + 120 >> 2] = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15;
                                                                                                                                                                    if (HEAPU8[$11 + 87 | 0]) {
                                                                                                                                                                     break label$6;
                                                                                                                                                                    }
                                                                                                                                                                    if (HEAPU8[$11 + 94 | 0] & 4) {
                                                                                                                                                                     FUNCTION_TABLE[HEAP32[$11 + 212 >> 2]](4, HEAP32[$11 + 216 >> 2], $0, 0) | 0;
                                                                                                                                                                    }
                                                                                                                                                                    HEAP32[$0 + 32 >> 2] = (($3 - $22 | 0) / 20 | 0) + 1;
                                                                                                                                                                    $24 = 100;
                                                                                                                                                                    break label$14;
                                                                                                                                                                   }
                                                                                                                                                                   $18 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                   $1 = Math_imul($18, 40) + $15 | 0;
                                                                                                                                                                   $13 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                   $19 = Math_imul($13, 40) + $15 | 0;
                                                                                                                                                                   $2 = HEAPU16[$19 + 16 >> 1];
                                                                                                                                                                   $5 = HEAP32[$3 + 8 >> 2];
                                                                                                                                                                   $20 = Math_imul($5, 40) + $15 | 0;
                                                                                                                                                                   if (($2 | HEAPU16[$20 + 16 >> 1]) & 1) {
                                                                                                                                                                    sqlite3VdbeMemSetNull($1);
                                                                                                                                                                    break label$10;
                                                                                                                                                                   }
                                                                                                                                                                   $17 = $19;
                                                                                                                                                                   label$208: {
                                                                                                                                                                    label$209: {
                                                                                                                                                                     if (!($2 & 18)) {
                                                                                                                                                                      if (!sqlite3VdbeMemStringify($19, $25, 0)) {
                                                                                                                                                                       break label$209;
                                                                                                                                                                      }
                                                                                                                                                                      break label$6;
                                                                                                                                                                     }
                                                                                                                                                                     if (!($2 & 1024)) {
                                                                                                                                                                      break label$208;
                                                                                                                                                                     }
                                                                                                                                                                     if (sqlite3VdbeMemExpandBlob($19)) {
                                                                                                                                                                      break label$6;
                                                                                                                                                                     }
                                                                                                                                                                    }
                                                                                                                                                                    $2 = HEAPU16[$17 + 16 >> 1] & -3;
                                                                                                                                                                   }
                                                                                                                                                                   $10 = $20;
                                                                                                                                                                   $26 = $20 + 16 | 0;
                                                                                                                                                                   $23 = HEAPU16[$26 >> 1];
                                                                                                                                                                   label$211: {
                                                                                                                                                                    label$212: {
                                                                                                                                                                     if (!($23 & 18)) {
                                                                                                                                                                      if (!sqlite3VdbeMemStringify($20, $25, 0)) {
                                                                                                                                                                       break label$212;
                                                                                                                                                                      }
                                                                                                                                                                      break label$6;
                                                                                                                                                                     }
                                                                                                                                                                     if (!($23 & 1024)) {
                                                                                                                                                                      break label$211;
                                                                                                                                                                     }
                                                                                                                                                                     if (sqlite3VdbeMemExpandBlob($20)) {
                                                                                                                                                                      break label$6;
                                                                                                                                                                     }
                                                                                                                                                                    }
                                                                                                                                                                    $23 = HEAPU16[$10 + 16 >> 1] & -3;
                                                                                                                                                                   }
                                                                                                                                                                   $20 = Math_imul($5, 40) + $15 | 0;
                                                                                                                                                                   $4 = Math_imul($13, 40) + $15 | 0;
                                                                                                                                                                   $19 = HEAP32[$20 + 12 >> 2] + HEAP32[$4 + 12 >> 2] | 0;
                                                                                                                                                                   if (($19 | 0) > HEAP32[$11 + 120 >> 2]) {
                                                                                                                                                                    break label$25;
                                                                                                                                                                   }
                                                                                                                                                                   $7 = ($5 | 0) == ($18 | 0);
                                                                                                                                                                   if (sqlite3VdbeMemGrow($1, $19 + 2 | 0, $7)) {
                                                                                                                                                                    break label$6;
                                                                                                                                                                   }
                                                                                                                                                                   $1 = Math_imul($18, 40) + $15 | 0;
                                                                                                                                                                   HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 2;
                                                                                                                                                                   if (!$7) {
                                                                                                                                                                    __memcpy(HEAP32[$1 + 8 >> 2], HEAP32[(Math_imul($5, 40) + $15 | 0) + 8 >> 2], HEAP32[$20 + 12 >> 2]);
                                                                                                                                                                    HEAP16[$10 + 16 >> 1] = $23;
                                                                                                                                                                   }
                                                                                                                                                                   __memcpy(HEAP32[$1 + 8 >> 2] + HEAP32[$20 + 12 >> 2] | 0, HEAP32[(Math_imul($13, 40) + $15 | 0) + 8 >> 2], HEAP32[$4 + 12 >> 2]);
                                                                                                                                                                   HEAP16[$17 + 16 >> 1] = $2;
                                                                                                                                                                   $2 = $25 >>> 0 > 1 ? $19 & -2 : $19;
                                                                                                                                                                   HEAP8[$2 + HEAP32[$1 + 8 >> 2] | 0] = 0;
                                                                                                                                                                   HEAP8[(HEAP32[$1 + 8 >> 2] + $2 | 0) + 1 | 0] = 0;
                                                                                                                                                                   HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] | 512;
                                                                                                                                                                   HEAP8[$1 + 18 | 0] = $25;
                                                                                                                                                                   HEAP32[$1 + 12 >> 2] = $2;
                                                                                                                                                                   break label$10;
                                                                                                                                                                  }
                                                                                                                                                                  $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                  $5 = numericType($1);
                                                                                                                                                                  $2 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                                  $13 = numericType($2);
                                                                                                                                                                  $19 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                  $18 = Math_imul($19, 40) + $15 | 0;
                                                                                                                                                                  label$215: {
                                                                                                                                                                   label$216: {
                                                                                                                                                                    if ($5 & $13 & 4) {
                                                                                                                                                                     $4 = HEAP32[$1 >> 2];
                                                                                                                                                                     $16 = $4;
                                                                                                                                                                     $9 = HEAP32[$1 + 4 >> 2];
                                                                                                                                                                     $17 = $9;
                                                                                                                                                                     $9 = HEAP32[$2 >> 2];
                                                                                                                                                                     $21 = $9;
                                                                                                                                                                     $4 = HEAP32[$2 + 4 >> 2];
                                                                                                                                                                     $20 = $4;
                                                                                                                                                                     HEAP32[$8 + 296 >> 2] = $21;
                                                                                                                                                                     HEAP32[$8 + 300 >> 2] = $4;
                                                                                                                                                                     label$218: {
                                                                                                                                                                      label$219: {
                                                                                                                                                                       switch (HEAPU8[$3 | 0] - 106 | 0) {
                                                                                                                                                                       case 0:
                                                                                                                                                                        $4 = $17;
                                                                                                                                                                        if (!sqlite3AddInt64($8 + 296 | 0, $16, $4)) {
                                                                                                                                                                         break label$218;
                                                                                                                                                                        }
                                                                                                                                                                        break label$216;

                                                                                                                                                                       case 1:
                                                                                                                                                                        $4 = $17;
                                                                                                                                                                        if (!sqlite3SubInt64($8 + 296 | 0, $16, $4)) {
                                                                                                                                                                         break label$218;
                                                                                                                                                                        }
                                                                                                                                                                        break label$216;

                                                                                                                                                                       case 2:
                                                                                                                                                                        $4 = $17;
                                                                                                                                                                        if (!sqlite3MulInt64($8 + 296 | 0, $16, $4)) {
                                                                                                                                                                         break label$218;
                                                                                                                                                                        }
                                                                                                                                                                        break label$216;

                                                                                                                                                                       case 3:
                                                                                                                                                                        $4 = $17;
                                                                                                                                                                        if (!($4 | $16)) {
                                                                                                                                                                         break label$215;
                                                                                                                                                                        }
                                                                                                                                                                        $10 = $16;
                                                                                                                                                                        $4 = ($10 & $17) == -1;
                                                                                                                                                                        $7 = $21;
                                                                                                                                                                        $10 = $20;
                                                                                                                                                                        if ($4 & (!$7 & ($10 | 0) == -2147483648)) {
                                                                                                                                                                         break label$216;
                                                                                                                                                                        }
                                                                                                                                                                        $7 = $20;
                                                                                                                                                                        $10 = $17;
                                                                                                                                                                        $10 = __wasm_i64_sdiv($21, $7, $16, $10);
                                                                                                                                                                        HEAP32[$8 + 296 >> 2] = $10;
                                                                                                                                                                        $7 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                        HEAP32[$8 + 300 >> 2] = $7;
                                                                                                                                                                        break label$218;

                                                                                                                                                                       default:
                                                                                                                                                                        break label$219;
                                                                                                                                                                       }
                                                                                                                                                                      }
                                                                                                                                                                      $7 = $17;
                                                                                                                                                                      if (!($7 | $16)) {
                                                                                                                                                                       break label$215;
                                                                                                                                                                      }
                                                                                                                                                                      $9 = $16;
                                                                                                                                                                      $14 = ($9 & $17) == -1;
                                                                                                                                                                      $10 = $14 ? 1 : $16;
                                                                                                                                                                      $4 = $14 ? 0 : $7;
                                                                                                                                                                      $17 = $4;
                                                                                                                                                                      $4 = $20;
                                                                                                                                                                      $7 = $10;
                                                                                                                                                                      $10 = $17;
                                                                                                                                                                      $10 = __wasm_i64_srem($21, $4, $7, $10);
                                                                                                                                                                      HEAP32[$8 + 296 >> 2] = $10;
                                                                                                                                                                      $4 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                      HEAP32[$8 + 300 >> 2] = $4;
                                                                                                                                                                     }
                                                                                                                                                                     $10 = HEAP32[$8 + 300 >> 2];
                                                                                                                                                                     $4 = HEAP32[$8 + 296 >> 2];
                                                                                                                                                                     $17 = $4;
                                                                                                                                                                     $4 = $18;
                                                                                                                                                                     HEAP32[$4 >> 2] = $17;
                                                                                                                                                                     HEAP32[$4 + 4 >> 2] = $10;
                                                                                                                                                                     $1 = Math_imul($19, 40) + $15 | 0;
                                                                                                                                                                     HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 4;
                                                                                                                                                                     break label$10;
                                                                                                                                                                    }
                                                                                                                                                                    if ((HEAPU16[$2 + 16 >> 1] | HEAPU16[$1 + 16 >> 1]) & 1) {
                                                                                                                                                                     break label$215;
                                                                                                                                                                    }
                                                                                                                                                                   }
                                                                                                                                                                   $29 = sqlite3VdbeRealValue($1);
                                                                                                                                                                   $37 = sqlite3VdbeRealValue($2);
                                                                                                                                                                   label$224: {
                                                                                                                                                                    label$225: {
                                                                                                                                                                     switch (HEAPU8[$3 | 0] - 106 | 0) {
                                                                                                                                                                     case 0:
                                                                                                                                                                      $29 = $29 + $37;
                                                                                                                                                                      break label$224;

                                                                                                                                                                     case 1:
                                                                                                                                                                      $29 = $37 - $29;
                                                                                                                                                                      break label$224;

                                                                                                                                                                     case 2:
                                                                                                                                                                      $29 = $29 * $37;
                                                                                                                                                                      break label$224;

                                                                                                                                                                     case 3:
                                                                                                                                                                      if ($29 == 0) {
                                                                                                                                                                       break label$215;
                                                                                                                                                                      }
                                                                                                                                                                      $29 = $37 / $29;
                                                                                                                                                                      break label$224;

                                                                                                                                                                     default:
                                                                                                                                                                      break label$225;
                                                                                                                                                                     }
                                                                                                                                                                    }
                                                                                                                                                                    $10 = sqlite3VdbeIntValue($1);
                                                                                                                                                                    $16 = $10;
                                                                                                                                                                    $4 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                    $17 = $4;
                                                                                                                                                                    $4 = sqlite3VdbeIntValue($2);
                                                                                                                                                                    $21 = $4;
                                                                                                                                                                    $10 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                    $20 = $10;
                                                                                                                                                                    $10 = $17;
                                                                                                                                                                    if (!($10 | $16)) {
                                                                                                                                                                     break label$215;
                                                                                                                                                                    }
                                                                                                                                                                    $14 = $16;
                                                                                                                                                                    $7 = ($14 & $17) == -1;
                                                                                                                                                                    $4 = $7 ? 1 : $16;
                                                                                                                                                                    $9 = $7 ? 0 : $17;
                                                                                                                                                                    $10 = $9;
                                                                                                                                                                    $9 = $20;
                                                                                                                                                                    $17 = $4;
                                                                                                                                                                    $4 = $10;
                                                                                                                                                                    $4 = __wasm_i64_srem($21, $9, $17, $4);
                                                                                                                                                                    $9 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                    $29 = +($4 >>> 0) + +($9 | 0) * 4294967296;
                                                                                                                                                                   }
                                                                                                                                                                   if (sqlite3IsNaN($29)) {
                                                                                                                                                                    break label$215;
                                                                                                                                                                   }
                                                                                                                                                                   HEAPF64[$18 >> 3] = $29;
                                                                                                                                                                   $1 = Math_imul($19, 40) + $15 | 0;
                                                                                                                                                                   HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 8;
                                                                                                                                                                   break label$10;
                                                                                                                                                                  }
                                                                                                                                                                  sqlite3VdbeMemSetNull($18);
                                                                                                                                                                  break label$10;
                                                                                                                                                                 }
                                                                                                                                                                 $1 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                                 if (!$1) {
                                                                                                                                                                  break label$10;
                                                                                                                                                                 }
                                                                                                                                                                 sqlite3VdbeMemSetInt64(Math_imul($1, 40) + $15 | 0, 0, 0);
                                                                                                                                                                 break label$10;
                                                                                                                                                                }
                                                                                                                                                                $2 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                                $1 = Math_imul($2, 40) + $15 | 0;
                                                                                                                                                                $5 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                                $13 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                                if ((HEAPU16[$5 + 16 >> 1] | HEAPU16[$13 + 16 >> 1]) & 1) {
                                                                                                                                                                 sqlite3VdbeMemSetNull($1);
                                                                                                                                                                 break label$10;
                                                                                                                                                                }
                                                                                                                                                                $9 = sqlite3VdbeIntValue($5);
                                                                                                                                                                $16 = $9;
                                                                                                                                                                $4 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                $17 = $4;
                                                                                                                                                                $4 = sqlite3VdbeIntValue($13);
                                                                                                                                                                $21 = $4;
                                                                                                                                                                $9 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                                $20 = $9;
                                                                                                                                                                label$231: {
                                                                                                                                                                 label$232: {
                                                                                                                                                                  label$233: {
                                                                                                                                                                   label$234: {
                                                                                                                                                                    $5 = HEAPU8[$3 | 0];
                                                                                                                                                                    switch ($5 - 102 | 0) {
                                                                                                                                                                    case 1:
                                                                                                                                                                     break label$233;

                                                                                                                                                                    case 0:
                                                                                                                                                                     break label$234;

                                                                                                                                                                    default:
                                                                                                                                                                     break label$232;
                                                                                                                                                                    }
                                                                                                                                                                   }
                                                                                                                                                                   $14 = $21;
                                                                                                                                                                   $7 = $16;
                                                                                                                                                                   $16 = $14 & $7;
                                                                                                                                                                   $9 = $17;
                                                                                                                                                                   $4 = $20;
                                                                                                                                                                   $4 = $9 & $4;
                                                                                                                                                                   $17 = $4;
                                                                                                                                                                   break label$231;
                                                                                                                                                                  }
                                                                                                                                                                  $9 = $16;
                                                                                                                                                                  $14 = $21;
                                                                                                                                                                  $16 = $9 | $14;
                                                                                                                                                                  $4 = $17;
                                                                                                                                                                  $7 = $20;
                                                                                                                                                                  $7 = $4 | $7;
                                                                                                                                                                  $17 = $7;
                                                                                                                                                                  break label$231;
                                                                                                                                                                 }
                                                                                                                                                                 $7 = $20;
                                                                                                                                                                 if (!($7 | $21)) {
                                                                                                                                                                  break label$231;
                                                                                                                                                                 }
                                                                                                                                                                 $13 = ($20 | 0) < 0;
                                                                                                                                                                 $5 = $13 ? -47 - $5 | 0 : $5;
                                                                                                                                                                 $9 = $21;
                                                                                                                                                                 $10 = 0 - $9 | 0;
                                                                                                                                                                 $12 = (($9 | 0) != 0) + $7 | 0;
                                                                                                                                                                 $12 = 0 - $12 | 0;
                                                                                                                                                                 $4 = $9;
                                                                                                                                                                 $7 = $4 >>> 0 > 4294967232 & ($7 | 0) >= -1 | ($7 | 0) >= 0;
                                                                                                                                                                 $14 = $7 ? $10 : 64;
                                                                                                                                                                 $4 = $12;
                                                                                                                                                                 $9 = $7 ? $4 : 0;
                                                                                                                                                                 $12 = $13;
                                                                                                                                                                 $4 = $12 ? $14 : $21;
                                                                                                                                                                 $21 = $4;
                                                                                                                                                                 $14 = $20;
                                                                                                                                                                 $7 = $12 ? $9 : $14;
                                                                                                                                                                 $20 = $7;
                                                                                                                                                                 $12 = $21;
                                                                                                                                                                 if (($7 | 0) >= 0 & $12 >>> 0 >= 64 | ($7 | 0) > 0) {
                                                                                                                                                                  $12 = $17;
                                                                                                                                                                  $7 = ($5 & 255) != 104 & ($12 | 0) < 0;
                                                                                                                                                                  $14 = 0 - $7 | 0;
                                                                                                                                                                  $16 = $14;
                                                                                                                                                                  $10 = ($7 | 0) != 0;
                                                                                                                                                                  $10 = 0 - $10 | 0;
                                                                                                                                                                  $17 = $10;
                                                                                                                                                                  break label$231;
                                                                                                                                                                 }
                                                                                                                                                                 if (($5 & 255) == 104) {
                                                                                                                                                                  $10 = $17;
                                                                                                                                                                  $9 = $16;
                                                                                                                                                                  $7 = $21;
                                                                                                                                                                  $12 = $7 & 31;
                                                                                                                                                                  if (($7 & 63) >>> 0 >= 32) {
                                                                                                                                                                   $4 = $9 << $12;
                                                                                                                                                                   $16 = 0;
                                                                                                                                                                  } else {
                                                                                                                                                                   $4 = (1 << $12) - 1 & $9 >>> 32 - $12 | $10 << $12;
                                                                                                                                                                   $16 = $9 << $12;
                                                                                                                                                                  }
                                                                                                                                                                  $17 = $4;
                                                                                                                                                                  break label$231;
                                                                                                                                                                 }
                                                                                                                                                                 $4 = $17;
                                                                                                                                                                 $10 = $16;
                                                                                                                                                                 $7 = $21;
                                                                                                                                                                 $12 = $7 & 31;
                                                                                                                                                                 if (($7 & 63) >>> 0 >= 32) {
                                                                                                                                                                  $9 = 0;
                                                                                                                                                                  $26 = $4 >>> $12 | 0;
                                                                                                                                                                 } else {
                                                                                                                                                                  $9 = $4 >>> $12 | 0;
                                                                                                                                                                  $26 = ((1 << $12) - 1 & $4) << 32 - $12 | $10 >>> $12;
                                                                                                                                                                 }
                                                                                                                                                                 $18 = $9;
                                                                                                                                                                 $9 = $17;
                                                                                                                                                                 if (($9 | 0) > 0 | ($9 | 0) >= 0) {
                                                                                                                                                                  $16 = $26;
                                                                                                                                                                  $4 = $18;
                                                                                                                                                                  $17 = $4;
                                                                                                                                                                  break label$231;
                                                                                                                                                                 }
                                                                                                                                                                 $10 = $21;
                                                                                                                                                                 $12 = 64 - $10 | 0;
                                                                                                                                                                 $9 = $20;
                                                                                                                                                                 $14 = $9 + ($10 >>> 0 > 64) | 0;
                                                                                                                                                                 $14 = 0 - $14 | 0;
                                                                                                                                                                 $7 = $14;
                                                                                                                                                                 $10 = $12;
                                                                                                                                                                 $9 = $10 & 31;
                                                                                                                                                                 if (($10 & 63) >>> 0 >= 32) {
                                                                                                                                                                  $7 = -1 << $9;
                                                                                                                                                                  $14 = 0;
                                                                                                                                                                 } else {
                                                                                                                                                                  $7 = (1 << $9) - 1 & -1 >>> 32 - $9 | -1 << $9;
                                                                                                                                                                  $14 = -1 << $9;
                                                                                                                                                                 }
                                                                                                                                                                 $10 = $26;
                                                                                                                                                                 $16 = $14 | $10;
                                                                                                                                                                 $4 = $18;
                                                                                                                                                                 $4 = $7 | $4;
                                                                                                                                                                 $17 = $4;
                                                                                                                                                                }
                                                                                                                                                                HEAP32[$1 >> 2] = $16;
                                                                                                                                                                $4 = $17;
                                                                                                                                                                HEAP32[$1 + 4 >> 2] = $4;
                                                                                                                                                                $1 = Math_imul($2, 40) + $15 | 0;
                                                                                                                                                                HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 4;
                                                                                                                                                                break label$10;
                                                                                                                                                               }
                                                                                                                                                               $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                               sqlite3VdbeMemIntegerify($1);
                                                                                                                                                               $4 = HEAP32[$1 >> 2];
                                                                                                                                                               $7 = $4;
                                                                                                                                                               $14 = HEAP32[$1 + 4 >> 2];
                                                                                                                                                               $17 = $14;
                                                                                                                                                               $14 = HEAP32[$3 + 8 >> 2];
                                                                                                                                                               $4 = $14 >> 31;
                                                                                                                                                               $10 = $14;
                                                                                                                                                               $14 = $4;
                                                                                                                                                               $4 = $17;
                                                                                                                                                               $12 = $14 + $4 | 0;
                                                                                                                                                               $9 = $10 + $7 | 0;
                                                                                                                                                               $12 = $9 >>> 0 < $10 >>> 0 ? $12 + 1 | 0 : $12;
                                                                                                                                                               HEAP32[$1 >> 2] = $9;
                                                                                                                                                               HEAP32[$1 + 4 >> 2] = $12;
                                                                                                                                                               break label$10;
                                                                                                                                                              }
                                                                                                                                                              $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                              label$238: {
                                                                                                                                                               $5 = HEAPU16[$1 + 16 >> 1];
                                                                                                                                                               if ($5 & 4) {
                                                                                                                                                                break label$238;
                                                                                                                                                               }
                                                                                                                                                               applyAffinity($1, 67, $25);
                                                                                                                                                               $5 = HEAPU16[$1 + 16 >> 1];
                                                                                                                                                               if ($5 & 4) {
                                                                                                                                                                break label$238;
                                                                                                                                                               }
                                                                                                                                                               if (HEAP32[$3 + 8 >> 2]) {
                                                                                                                                                                break label$13;
                                                                                                                                                               }
                                                                                                                                                               $6 = 20;
                                                                                                                                                               break label$5;
                                                                                                                                                              }
                                                                                                                                                              HEAP16[$1 + 16 >> 1] = $5 & 62016 | 4;
                                                                                                                                                              break label$10;
                                                                                                                                                             }
                                                                                                                                                             $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                             if (!(HEAPU8[$1 + 16 | 0] & 36)) {
                                                                                                                                                              break label$10;
                                                                                                                                                             }
                                                                                                                                                             sqlite3VdbeMemRealify($1);
                                                                                                                                                             break label$10;
                                                                                                                                                            }
                                                                                                                                                            label$239: {
                                                                                                                                                             $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                             if (!(HEAPU8[$1 + 17 | 0] & 4)) {
                                                                                                                                                              break label$239;
                                                                                                                                                             }
                                                                                                                                                             $6 = sqlite3VdbeMemExpandBlob($1);
                                                                                                                                                             if (!$6) {
                                                                                                                                                              break label$239;
                                                                                                                                                             }
                                                                                                                                                             break label$5;
                                                                                                                                                            }
                                                                                                                                                            $6 = 0;
                                                                                                                                                            $1 = sqlite3VdbeMemCast($1, HEAPU8[$3 + 8 | 0], $25);
                                                                                                                                                            if (!$1) {
                                                                                                                                                             break label$10;
                                                                                                                                                            }
                                                                                                                                                            $6 = $1;
                                                                                                                                                            break label$5;
                                                                                                                                                           }
                                                                                                                                                           $23 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                           $5 = Math_imul($23, 40) + $15 | 0;
                                                                                                                                                           $2 = HEAPU16[$5 + 16 >> 1];
                                                                                                                                                           $28 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                           $13 = Math_imul($28, 40) + $15 | 0;
                                                                                                                                                           $18 = HEAPU16[$13 + 16 >> 1];
                                                                                                                                                           $19 = $2 & $18;
                                                                                                                                                           if ($19 & 4) {
                                                                                                                                                            $12 = HEAP32[$5 >> 2];
                                                                                                                                                            $16 = $12;
                                                                                                                                                            $7 = HEAP32[$5 + 4 >> 2];
                                                                                                                                                            $17 = $7;
                                                                                                                                                            $4 = $13;
                                                                                                                                                            $7 = HEAP32[$4 >> 2];
                                                                                                                                                            $21 = $7;
                                                                                                                                                            $12 = HEAP32[$4 + 4 >> 2];
                                                                                                                                                            $20 = $12;
                                                                                                                                                            $4 = $16;
                                                                                                                                                            $10 = $7;
                                                                                                                                                            $12 = $17;
                                                                                                                                                            $7 = $20;
                                                                                                                                                            if ($4 >>> 0 > $10 >>> 0 & ($12 | 0) >= ($7 | 0) | ($7 | 0) < ($12 | 0)) {
                                                                                                                                                             if (HEAPU8[$1 + 30120 | 0]) {
                                                                                                                                                              break label$13;
                                                                                                                                                             }
                                                                                                                                                             $27 = 1;
                                                                                                                                                             break label$10;
                                                                                                                                                            }
                                                                                                                                                            $10 = $16;
                                                                                                                                                            $7 = $21;
                                                                                                                                                            $4 = $17;
                                                                                                                                                            $12 = $20;
                                                                                                                                                            if ($10 >>> 0 < $7 >>> 0 & ($4 | 0) <= ($12 | 0) | ($12 | 0) > ($4 | 0)) {
                                                                                                                                                             if (HEAPU8[$1 + 30108 | 0]) {
                                                                                                                                                              break label$13;
                                                                                                                                                             }
                                                                                                                                                             $27 = -1;
                                                                                                                                                             break label$10;
                                                                                                                                                            }
                                                                                                                                                            if (HEAPU8[$1 + 30114 | 0]) {
                                                                                                                                                             break label$13;
                                                                                                                                                            }
                                                                                                                                                            break label$16;
                                                                                                                                                           }
                                                                                                                                                           $4 = $5;
                                                                                                                                                           $20 = HEAPU16[$3 + 2 >> 1];
                                                                                                                                                           $7 = $2 | $18;
                                                                                                                                                           if ($7 & 1) {
                                                                                                                                                            if ($20 & 128) {
                                                                                                                                                             $27 = 1;
                                                                                                                                                             if ($2 & 256 ? 0 : $19 & 1) {
                                                                                                                                                              break label$18;
                                                                                                                                                             }
                                                                                                                                                             if (!($2 & 1)) {
                                                                                                                                                              break label$19;
                                                                                                                                                             }
                                                                                                                                                             $27 = -1;
                                                                                                                                                             $5 = 30108;
                                                                                                                                                             break label$17;
                                                                                                                                                            }
                                                                                                                                                            if ($20 & 16) {
                                                                                                                                                             break label$13;
                                                                                                                                                            }
                                                                                                                                                            $27 = 1;
                                                                                                                                                            break label$10;
                                                                                                                                                           }
                                                                                                                                                           $1 = $20 & 71;
                                                                                                                                                           if ($1 >>> 0 >= 67) {
                                                                                                                                                            if (!($7 & 2)) {
                                                                                                                                                             break label$20;
                                                                                                                                                            }
                                                                                                                                                            if (($18 & 46) == 2) {
                                                                                                                                                             applyNumericAffinity($13, 0);
                                                                                                                                                             $2 = HEAPU16[$4 + 16 >> 1];
                                                                                                                                                            }
                                                                                                                                                            if (($2 & 46) != 2) {
                                                                                                                                                             break label$20;
                                                                                                                                                            }
                                                                                                                                                            applyNumericAffinity($5, 0);
                                                                                                                                                            break label$20;
                                                                                                                                                           }
                                                                                                                                                           if (($1 | 0) != 66) {
                                                                                                                                                            break label$20;
                                                                                                                                                           }
                                                                                                                                                           if (!($18 & 44) | $18 & 2) {
                                                                                                                                                            break label$22;
                                                                                                                                                           }
                                                                                                                                                           sqlite3VdbeMemStringify($13, $25, 1);
                                                                                                                                                           $18 = HEAPU16[$13 + 16 >> 1] & -3520 | $18 & 3519;
                                                                                                                                                           $1 = ($23 | 0) == ($28 | 0) ? $18 | 2 : $2;
                                                                                                                                                           $2 = $1 & 65535;
                                                                                                                                                           break label$21;
                                                                                                                                                          }
                                                                                                                                                          if ($27) {
                                                                                                                                                           break label$10;
                                                                                                                                                          }
                                                                                                                                                          $27 = 0;
                                                                                                                                                          break label$13;
                                                                                                                                                         }
                                                                                                                                                         $1 = 0;
                                                                                                                                                         $13 = 0;
                                                                                                                                                         $13 = HEAP8[$3 + 2 | 0] & 1 ? HEAP32[$3 - 4 >> 2] + 4 | 0 : $13;
                                                                                                                                                         $2 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                         $18 = ($2 | 0) > 0 ? $2 : 0;
                                                                                                                                                         $19 = HEAP32[$3 + 8 >> 2];
                                                                                                                                                         $20 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                         $5 = HEAP32[$3 + 16 >> 2];
                                                                                                                                                         while (1) {
                                                                                                                                                          if (($1 | 0) == ($18 | 0)) {
                                                                                                                                                           break label$10;
                                                                                                                                                          }
                                                                                                                                                          $27 = HEAPU8[HEAP32[$5 + 16 >> 2] + $1 | 0];
                                                                                                                                                          $2 = $13 ? HEAP32[($1 << 2) + $13 >> 2] : $1;
                                                                                                                                                          $23 = $20 + $2 | 0;
                                                                                                                                                          $28 = $2 + $19 | 0;
                                                                                                                                                          $2 = sqlite3MemCompare(Math_imul($23, 40) + $15 | 0, Math_imul($28, 40) + $15 | 0, HEAP32[(($1 << 2) + $5 | 0) + 20 >> 2]);
                                                                                                                                                          if ($2) {
                                                                                                                                                           $13 = $27 & 1;
                                                                                                                                                           $2 = !(HEAPU8[HEAP32[$5 + 16 >> 2] + $1 | 0] & 2) | !(HEAP8[(Math_imul($28, 40) + $15 | 0) + 16 | 0] & 1 ? 1 : HEAP8[(Math_imul($23, 40) + $15 | 0) + 16 | 0] & 1) ? $2 : 0 - $2 | 0;
                                                                                                                                                           $27 = $13 ? 0 - $2 | 0 : $2;
                                                                                                                                                           break label$10;
                                                                                                                                                          } else {
                                                                                                                                                           $1 = $1 + 1 | 0;
                                                                                                                                                           $27 = 0;
                                                                                                                                                           continue;
                                                                                                                                                          }
                                                                                                                                                         }
                                                                                                                                                        }
                                                                                                                                                        if (($27 | 0) < 0) {
                                                                                                                                                         $3 = (Math_imul(HEAP32[$3 + 4 >> 2], 20) + $22 | 0) - 20 | 0;
                                                                                                                                                         break label$10;
                                                                                                                                                        }
                                                                                                                                                        if (!$27) {
                                                                                                                                                         $3 = (Math_imul(HEAP32[$3 + 8 >> 2], 20) + $22 | 0) - 20 | 0;
                                                                                                                                                         break label$16;
                                                                                                                                                        }
                                                                                                                                                        $3 = (Math_imul(HEAP32[$3 + 12 >> 2], 20) + $22 | 0) - 20 | 0;
                                                                                                                                                        break label$10;
                                                                                                                                                       }
                                                                                                                                                       $1 = sqlite3VdbeBooleanValue(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0, 2);
                                                                                                                                                       $2 = sqlite3VdbeBooleanValue(Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0, 2);
                                                                                                                                                       $5 = HEAP32[$3 + 12 >> 2];
                                                                                                                                                       $7 = (Math_imul($1, 3) + $2 | 0) + (HEAPU8[$3 | 0] == 44 ? 33184 : 33193) | 0;
                                                                                                                                                       $10 = HEAPU8[$7 | 0];
                                                                                                                                                       $16 = $10;
                                                                                                                                                       $7 = $10;
                                                                                                                                                       if (($7 | 0) == 2) {
                                                                                                                                                        $1 = Math_imul($5, 40) + $15 | 0;
                                                                                                                                                        HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 1;
                                                                                                                                                        break label$10;
                                                                                                                                                       }
                                                                                                                                                       $1 = Math_imul($5, 40) + $15 | 0;
                                                                                                                                                       HEAP32[$1 >> 2] = $16;
                                                                                                                                                       HEAP32[$1 + 4 >> 2] = 0;
                                                                                                                                                       HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 4;
                                                                                                                                                       break label$10;
                                                                                                                                                      }
                                                                                                                                                      $10 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                      $4 = sqlite3VdbeBooleanValue(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0, HEAP32[$3 + 12 >> 2]) ^ HEAP32[$3 + 16 >> 2];
                                                                                                                                                      $7 = $4 >> 31;
                                                                                                                                                      sqlite3VdbeMemSetInt64($10, $4, $7);
                                                                                                                                                      break label$10;
                                                                                                                                                     }
                                                                                                                                                     $1 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                     $2 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                                     if (!(HEAP8[$2 + 16 | 0] & 1)) {
                                                                                                                                                      sqlite3VdbeMemSetInt64($1, !sqlite3VdbeBooleanValue($2, 0), 0);
                                                                                                                                                      break label$10;
                                                                                                                                                     }
                                                                                                                                                     sqlite3VdbeMemSetNull($1);
                                                                                                                                                     break label$10;
                                                                                                                                                    }
                                                                                                                                                    $1 = HEAP32[$3 + 4 >> 2];
                                                                                                                                                    $2 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                                                                    sqlite3VdbeMemSetNull($2);
                                                                                                                                                    $1 = Math_imul($1, 40) + $15 | 0;
                                                                                                                                                    if (HEAP8[$1 + 16 | 0] & 1) {
                                                                                                                                                     break label$10;
                                                                                                                                                    }
                                                                                                                                                    HEAP16[$2 + 16 >> 1] = 4;
                                                                                                                                                    $7 = sqlite3VdbeIntValue($1);
                                                                                                                                                    HEAP32[$2 >> 2] = $7 ^ -1;
                                                                                                                                                    $4 = i64toi32_i32$HIGH_BITS;
                                                                                                                                                    $7 = $4 ^ -1;
                                                                                                                                                    HEAP32[$2 + 4 >> 2] = $7;
                                                                                                                                                    break label$10;
                                                                                                                                                   }
                                                                                                                                                   $1 = HEAP32[$0 + 104 >> 2];
                                                                                                                                                   $2 = HEAP32[$0 + 212 >> 2];
                                                                                                                                                   label$258: {
                                                                                                                                                    if ($2) {
                                                                                                                                                     $1 = ($3 - $1 | 0) / 20 | 0;
                                                                                                                                                     $5 = 1 << ($1 & 7);
                                                                                                                                                     $1 = HEAP32[$2 + 24 >> 2] + ($1 >>> 3 | 0) | 0;
                                                                                                                                                     $2 = HEAPU8[$1 | 0];
                                                                                                                                                     if ($5 & $2) {
                                                                                                                                                      break label$13;
                                                                                                                                                     }
                                                                                                                                                     HEAP8[$1 | 0] = $2 | $5;
                                                                                                                                                     $1 = HEAP32[HEAP32[$0 + 104 >> 2] + 4 >> 2];
                                                                                                                                                     break label$258;
                                                                                                                                                    }
                                                                                                                                                    $1 = HEAP32[$1 + 4 >> 2];
                                                                                                                                                    if (($1 | 0) == HEAP32[$3 + 4 >> 2]) {
                                                                                                                                                     break label$13;
                                                                                                                                                    }
                                                                                                                                                   }
                                                                                                                                                   HEAP32[$3 + 4 >> 2] = $1;
                                                                                                                                                   break label$10;
                                                                                                                                                  }
                                                                                                                                                  if (sqlite3VdbeBooleanValue(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0, HEAP32[$3 + 12 >> 2])) {
                                                                                                                                                   break label$13;
                                                                                                                                                  }
                                                                                                                                                  break label$10;
                                                                                                                                                 }
                                                                                                                                                 if (!sqlite3VdbeBooleanValue(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0, !HEAP32[$3 + 12 >> 2])) {
                                                                                                                                                  break label$13;
                                                                                                                                                 }
                                                                                                                                                 break label$10;
                                                                                                                                                }
                                                                                                                                                if (HEAP8[(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0) + 16 | 0] & 1) {
                                                                                                                                                 break label$13;
                                                                                                                                                }
                                                                                                                                                break label$10;
                                                                                                                                               }
                                                                                                                                               $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                               if (HEAP8[$1 + 16 | 0] & 1) {
                                                                                                                                                break label$13;
                                                                                                                                               }
                                                                                                                                               if ((sqlite3_value_type($1) | 0) == HEAP32[$3 + 12 >> 2]) {
                                                                                                                                                break label$13;
                                                                                                                                               }
                                                                                                                                               break label$10;
                                                                                                                                              }
                                                                                                                                              if (HEAP8[(Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0) + 16 | 0] & 1 ? 1 : HEAP8[(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0) + 16 | 0] & 1) {
                                                                                                                                               sqlite3VdbeMemSetNull(Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0);
                                                                                                                                               break label$10;
                                                                                                                                              }
                                                                                                                                              sqlite3VdbeMemSetInt64(Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0, 0, 0);
                                                                                                                                              break label$10;
                                                                                                                                             }
                                                                                                                                             if (!(HEAP8[(Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0) + 16 | 0] & 1)) {
                                                                                                                                              break label$13;
                                                                                                                                             }
                                                                                                                                             break label$10;
                                                                                                                                            }
                                                                                                                                            if (!HEAPU8[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 2 | 0]) {
                                                                                                                                             break label$10;
                                                                                                                                            }
                                                                                                                                            sqlite3VdbeMemSetNull(Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0);
                                                                                                                                            break label$13;
                                                                                                                                           }
                                                                                                                                           $1 = HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) | 0;
                                                                                                                                           $23 = HEAP32[$3 + 8 >> 2];
                                                                                                                                           label$262: while (1) {
                                                                                                                                            $1 = HEAP32[$1 >> 2];
                                                                                                                                            while (1) {
                                                                                                                                             $18 = HEAP32[$1 + 64 >> 2];
                                                                                                                                             label$264: {
                                                                                                                                              $2 = HEAP32[$0 + 28 >> 2];
                                                                                                                                              if (($2 | 0) != HEAP32[$1 + 24 >> 2]) {
                                                                                                                                               if (HEAPU8[$1 + 2 | 0]) {
                                                                                                                                                label$267: {
                                                                                                                                                 if (HEAPU8[$1 | 0] != 3) {
                                                                                                                                                  break label$267;
                                                                                                                                                 }
                                                                                                                                                 $5 = HEAP32[$1 + 28 >> 2];
                                                                                                                                                 if (($5 | 0) <= 0) {
                                                                                                                                                  break label$267;
                                                                                                                                                 }
                                                                                                                                                 $5 = Math_imul($5, 40) + $15 | 0;
                                                                                                                                                 $13 = HEAP32[$5 + 12 >> 2];
                                                                                                                                                 HEAP32[$1 + 72 >> 2] = $13;
                                                                                                                                                 HEAP32[$1 + 76 >> 2] = $13;
                                                                                                                                                 $5 = HEAP32[$5 + 8 >> 2];
                                                                                                                                                 HEAP32[$1 + 68 >> 2] = $5;
                                                                                                                                                 break label$33;
                                                                                                                                                }
                                                                                                                                                sqlite3VdbeMemSetNull(Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0);
                                                                                                                                                break label$10;
                                                                                                                                               }
                                                                                                                                               $2 = HEAP32[$1 + 36 >> 2];
                                                                                                                                               if (HEAPU8[$1 + 3 | 0]) {
                                                                                                                                                label$269: {
                                                                                                                                                 $5 = HEAP32[$1 + 8 >> 2];
                                                                                                                                                 if ($5) {
                                                                                                                                                  $5 = HEAP32[(($23 << 2) + $5 | 0) + 4 >> 2];
                                                                                                                                                  if ($5) {
                                                                                                                                                   break label$269;
                                                                                                                                                  }
                                                                                                                                                 }
                                                                                                                                                 $6 = 0;
                                                                                                                                                 $5 = sqlite3VdbeFinishMoveto($1);
                                                                                                                                                 if ($5) {
                                                                                                                                                  break label$23;
                                                                                                                                                 }
                                                                                                                                                 break label$34;
                                                                                                                                                }
                                                                                                                                                $23 = $5 - 1 | 0;
                                                                                                                                                $1 = $1 + 32 | 0;
                                                                                                                                                continue label$262;
                                                                                                                                               }
                                                                                                                                               if (!sqlite3BtreeCursorHasMoved($2)) {
                                                                                                                                                break label$34;
                                                                                                                                               }
                                                                                                                                               break label$264;
                                                                                                                                              }
                                                                                                                                              if (sqlite3BtreeCursorHasMoved(HEAP32[$1 + 36 >> 2])) {
                                                                                                                                               break label$264;
                                                                                                                                              }
                                                                                                                                              $19 = HEAPU16[$1 + 54 >> 1];
                                                                                                                                              break label$32;
                                                                                                                                             }
                                                                                                                                             $6 = 0;
                                                                                                                                             $5 = sqlite3VdbeHandleMovedCursor($1);
                                                                                                                                             if (!$5) {
                                                                                                                                              continue;
                                                                                                                                             }
                                                                                                                                             break;
                                                                                                                                            }
                                                                                                                                            break;
                                                                                                                                           }
                                                                                                                                           break label$23;
                                                                                                                                          }
                                                                                                                                          $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                          $3 = HEAP32[(Math_imul(HEAP32[$1 >> 2], 20) + $22 | 0) + 8 >> 2];
                                                                                                                                          HEAP16[$1 + 16 >> 1] = 0;
                                                                                                                                          $3 = (Math_imul($3, 20) + $22 | 0) - 20 | 0;
                                                                                                                                          break label$10;
                                                                                                                                         }
                                                                                                                                         $1 = HEAPU8[$11 + 94 | 0];
                                                                                                                                         label$271: {
                                                                                                                                          if (!($1 & 65) | HEAPU8[$0 + 147 | 0] == 254) {
                                                                                                                                           break label$271;
                                                                                                                                          }
                                                                                                                                          $2 = HEAP32[$3 + 16 >> 2];
                                                                                                                                          if (!$2) {
                                                                                                                                           $2 = HEAP32[$0 + 196 >> 2];
                                                                                                                                           if (!$2) {
                                                                                                                                            break label$271;
                                                                                                                                           }
                                                                                                                                          }
                                                                                                                                          if ($1 & 64) {
                                                                                                                                           $1 = sqlite3VdbeExpandSql($0, $2);
                                                                                                                                           FUNCTION_TABLE[HEAP32[$11 + 212 >> 2]](HEAP32[$11 + 216 >> 2], $1);
                                                                                                                                           sqlite3_free($1);
                                                                                                                                           break label$271;
                                                                                                                                          }
                                                                                                                                          if (HEAP32[$11 + 196 >> 2] >= 2) {
                                                                                                                                           HEAP32[$8 + 96 >> 2] = $2;
                                                                                                                                           $1 = sqlite3MPrintf($11, 8300, $8 + 96 | 0);
                                                                                                                                           FUNCTION_TABLE[HEAP32[$11 + 212 >> 2]](1, HEAP32[$11 + 216 >> 2], $0, $1) | 0;
                                                                                                                                           sqlite3DbFree($11, $1);
                                                                                                                                           break label$271;
                                                                                                                                          }
                                                                                                                                          FUNCTION_TABLE[HEAP32[$11 + 212 >> 2]](1, HEAP32[$11 + 216 >> 2], $0, $2) | 0;
                                                                                                                                         }
                                                                                                                                         $1 = HEAP32[$3 + 4 >> 2];
                                                                                                                                         if (($1 | 0) >= HEAP32[16135]) {
                                                                                                                                          if (HEAPU8[$3 | 0] == 181) {
                                                                                                                                           break label$10;
                                                                                                                                          }
                                                                                                                                          $1 = 1;
                                                                                                                                          $2 = HEAP32[$0 + 108 >> 2];
                                                                                                                                          $5 = ($2 | 0) > 1 ? $2 : 1;
                                                                                                                                          while (1) {
                                                                                                                                           if (($1 | 0) != ($5 | 0)) {
                                                                                                                                            $2 = HEAP32[$0 + 104 >> 2] + Math_imul($1, 20) | 0;
                                                                                                                                            if (HEAPU8[$2 | 0] == 14) {
                                                                                                                                             HEAP32[$2 + 4 >> 2] = 0;
                                                                                                                                            }
                                                                                                                                            $1 = $1 + 1 | 0;
                                                                                                                                            continue;
                                                                                                                                           }
                                                                                                                                           break;
                                                                                                                                          }
                                                                                                                                          HEAP32[$3 + 4 >> 2] = 0;
                                                                                                                                          $1 = 0;
                                                                                                                                         }
                                                                                                                                         HEAP32[$3 + 4 >> 2] = $1 + 1;
                                                                                                                                         HEAP32[$0 + 184 >> 2] = HEAP32[$0 + 184 >> 2] + 1;
                                                                                                                                         break label$13;
                                                                                                                                        }
                                                                                                                                        $1 = HEAP32[$3 + 4 >> 2];
                                                                                                                                        $7 = filterHash($15, $3);
                                                                                                                                        $16 = $7;
                                                                                                                                        $12 = i64toi32_i32$HIGH_BITS;
                                                                                                                                        $17 = $12;
                                                                                                                                        $1 = Math_imul($1, 40) + $15 | 0;
                                                                                                                                        $9 = HEAP32[$1 + 8 >> 2];
                                                                                                                                        $12 = HEAP32[$1 + 12 >> 2];
                                                                                                                                        $7 = $12 >> 31;
                                                                                                                                        $4 = $7;
                                                                                                                                        $7 = $17;
                                                                                                                                        $10 = $12;
                                                                                                                                        $12 = $4;
                                                                                                                                        $12 = __wasm_i64_urem($16, $7, $10, $12);
                                                                                                                                        $16 = $12;
                                                                                                                                        $7 = i64toi32_i32$HIGH_BITS;
                                                                                                                                        $4 = $16;
                                                                                                                                        if (!(HEAPU8[(($7 & 7) << 29 | $4 >>> 3) + $9 | 0] >>> ($4 & 7) & 1)) {
                                                                                                                                         HEAP32[$0 + 192 >> 2] = HEAP32[$0 + 192 >> 2] + 1;
                                                                                                                                         break label$13;
                                                                                                                                        }
                                                                                                                                        HEAP32[$0 + 188 >> 2] = HEAP32[$0 + 188 >> 2] + 1;
                                                                                                                                        break label$10;
                                                                                                                                       }
                                                                                                                                       $1 = HEAP32[$3 + 4 >> 2];
                                                                                                                                       $12 = filterHash($15, $3);
                                                                                                                                       $16 = $12;
                                                                                                                                       $4 = i64toi32_i32$HIGH_BITS;
                                                                                                                                       $17 = $4;
                                                                                                                                       $1 = Math_imul($1, 40) + $15 | 0;
                                                                                                                                       $9 = HEAP32[$1 + 8 >> 2];
                                                                                                                                       $4 = HEAP32[$1 + 12 >> 2];
                                                                                                                                       $12 = $4 >> 31;
                                                                                                                                       $10 = $12;
                                                                                                                                       $12 = $17;
                                                                                                                                       $17 = $4;
                                                                                                                                       $4 = $10;
                                                                                                                                       $4 = __wasm_i64_urem($16, $12, $17, $4);
                                                                                                                                       $16 = $4;
                                                                                                                                       $12 = i64toi32_i32$HIGH_BITS;
                                                                                                                                       $4 = $12;
                                                                                                                                       $7 = $16;
                                                                                                                                       $1 = (($4 & 7) << 29 | $7 >>> 3) + $9 | 0;
                                                                                                                                       HEAP8[$1 | 0] = HEAPU8[$1 | 0] | 1 << ($7 & 7);
                                                                                                                                       break label$10;
                                                                                                                                      }
                                                                                                                                      $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                      HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 63487;
                                                                                                                                      break label$10;
                                                                                                                                     }
                                                                                                                                     label$280: {
                                                                                                                                      $13 = HEAP32[$3 + 12 >> 2];
                                                                                                                                      $5 = Math_imul($13, 40) + $15 | 0;
                                                                                                                                      $2 = HEAP32[$3 + 16 >> 2];
                                                                                                                                      if (($5 | 0) == HEAP32[$2 >> 2]) {
                                                                                                                                       $18 = HEAPU8[$2 + 26 | 0];
                                                                                                                                       break label$280;
                                                                                                                                      }
                                                                                                                                      HEAP8[$2 + 24 | 0] = $25;
                                                                                                                                      HEAP32[$2 >> 2] = $5;
                                                                                                                                      HEAP32[$2 + 12 >> 2] = $0;
                                                                                                                                      $18 = HEAPU8[$2 + 26 | 0];
                                                                                                                                      $1 = $18;
                                                                                                                                      while (1) {
                                                                                                                                       if (($1 | 0) <= 0) {
                                                                                                                                        break label$280;
                                                                                                                                       }
                                                                                                                                       $1 = $1 - 1 | 0;
                                                                                                                                       HEAP32[(($1 << 2) + $2 | 0) + 28 >> 2] = Math_imul(HEAP32[$3 + 8 >> 2] + $1 | 0, 40) + $15;
                                                                                                                                       continue;
                                                                                                                                      }
                                                                                                                                     }
                                                                                                                                     $1 = Math_imul($13, 40) + $15 | 0;
                                                                                                                                     HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 1;
                                                                                                                                     FUNCTION_TABLE[HEAP32[HEAP32[$2 + 4 >> 2] + 16 >> 2]]($2, $18, $2 + 28 | 0);
                                                                                                                                     $13 = HEAP32[$2 + 20 >> 2];
                                                                                                                                     if (!$13) {
                                                                                                                                      break label$10;
                                                                                                                                     }
                                                                                                                                     $1 = $6;
                                                                                                                                     if (($13 | 0) > 0) {
                                                                                                                                      HEAP32[$8 + 240 >> 2] = sqlite3_value_text($5);
                                                                                                                                      sqlite3VdbeError($0, 8342, $8 + 240 | 0);
                                                                                                                                      $1 = HEAP32[$2 + 20 >> 2];
                                                                                                                                     }
                                                                                                                                     sqlite3VdbeDeleteAuxData($11, $42, HEAP32[$2 + 16 >> 2], HEAP32[$3 + 4 >> 2]);
                                                                                                                                     $6 = 0;
                                                                                                                                     HEAP32[$2 + 20 >> 2] = 0;
                                                                                                                                     if (!$1) {
                                                                                                                                      break label$10;
                                                                                                                                     }
                                                                                                                                     $6 = $1;
                                                                                                                                     break label$5;
                                                                                                                                    }
                                                                                                                                    $5 = out2Prerelease($0, $3);
                                                                                                                                    $7 = $5;
                                                                                                                                    $1 = HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2];
                                                                                                                                    $2 = HEAP32[$3 + 12 >> 2];
                                                                                                                                    if ($2) {
                                                                                                                                     $13 = sqlite3BtreeLastPage($1);
                                                                                                                                     $2 = $2 >>> 0 < $13 >>> 0 ? $13 : $2;
                                                                                                                                    } else {
                                                                                                                                     $2 = 0;
                                                                                                                                    }
                                                                                                                                    HEAP32[$5 >> 2] = sqlite3BtreeMaxPageCount($1, $2);
                                                                                                                                    HEAP32[$7 + 4 >> 2] = 0;
                                                                                                                                    break label$10;
                                                                                                                                   }
                                                                                                                                   $7 = out2Prerelease($0, $3);
                                                                                                                                   HEAP32[$7 >> 2] = sqlite3BtreeLastPage(HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2]);
                                                                                                                                   HEAP32[$7 + 4 >> 2] = 0;
                                                                                                                                   break label$10;
                                                                                                                                  }
                                                                                                                                  HEAP32[$8 + 296 >> 2] = 0;
                                                                                                                                  HEAP32[$8 + 300 >> 2] = 0;
                                                                                                                                  if (HEAPU8[$11 + 87 | 0]) {
                                                                                                                                   break label$6;
                                                                                                                                  }
                                                                                                                                  $1 = 6;
                                                                                                                                  $13 = HEAP32[HEAP32[$3 + 16 >> 2] + 8 >> 2];
                                                                                                                                  label$286: {
                                                                                                                                   if (!$13) {
                                                                                                                                    break label$286;
                                                                                                                                   }
                                                                                                                                   $18 = HEAP32[$13 >> 2];
                                                                                                                                   if (!$18) {
                                                                                                                                    break label$286;
                                                                                                                                   }
                                                                                                                                   if (!HEAP32[$18 + 52 >> 2]) {
                                                                                                                                    break label$10;
                                                                                                                                   }
                                                                                                                                   $1 = 0;
                                                                                                                                   $19 = HEAP32[$3 + 8 >> 2];
                                                                                                                                   $2 = ($19 | 0) > 0 ? $19 : 0;
                                                                                                                                   $6 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                                                                                   $5 = HEAP32[$0 + 92 >> 2];
                                                                                                                                   $20 = HEAPU8[$11 + 92 | 0];
                                                                                                                                   while (1) {
                                                                                                                                    if (($1 | 0) != ($2 | 0)) {
                                                                                                                                     HEAP32[($1 << 2) + $5 >> 2] = $6;
                                                                                                                                     $1 = $1 + 1 | 0;
                                                                                                                                     $6 = $6 + 40 | 0;
                                                                                                                                     continue;
                                                                                                                                    }
                                                                                                                                    break;
                                                                                                                                   }
                                                                                                                                   HEAP8[$11 + 92 | 0] = HEAPU8[$3 + 2 | 0];
                                                                                                                                   $1 = FUNCTION_TABLE[HEAP32[$18 + 52 >> 2]]($13, $19, $5, $8 + 296 | 0) | 0;
                                                                                                                                   HEAP8[$11 + 92 | 0] = $20;
                                                                                                                                   sqlite3VtabImportErrmsg($0, $13);
                                                                                                                                   if (!$1) {
                                                                                                                                    if (HEAP32[$3 + 4 >> 2]) {
                                                                                                                                     $7 = HEAP32[$8 + 300 >> 2];
                                                                                                                                     $4 = HEAP32[$8 + 296 >> 2];
                                                                                                                                     HEAP32[$11 + 40 >> 2] = $4;
                                                                                                                                     HEAP32[$11 + 44 >> 2] = $7;
                                                                                                                                    }
                                                                                                                                    $7 = HEAP32[$0 + 40 >> 2];
                                                                                                                                    $12 = $7;
                                                                                                                                    $4 = HEAP32[$0 + 44 >> 2];
                                                                                                                                    $14 = $12 + 1 | 0;
                                                                                                                                    $9 = $14 ? $4 : $4 + 1 | 0;
                                                                                                                                    HEAP32[$0 + 40 >> 2] = $14;
                                                                                                                                    HEAP32[$0 + 44 >> 2] = $9;
                                                                                                                                    break label$40;
                                                                                                                                   }
                                                                                                                                   if (!(!HEAPU8[HEAP32[$3 + 16 >> 2] + 16 | 0] | ($1 & 255) != 19)) {
                                                                                                                                    $2 = 2;
                                                                                                                                    $6 = 0;
                                                                                                                                    label$292: {
                                                                                                                                     label$293: {
                                                                                                                                      $5 = HEAPU16[$3 + 2 >> 1];
                                                                                                                                      switch ($5 - 4 | 0) {
                                                                                                                                      case 0:
                                                                                                                                       break label$10;

                                                                                                                                      case 1:
                                                                                                                                       break label$292;

                                                                                                                                      default:
                                                                                                                                       break label$293;
                                                                                                                                      }
                                                                                                                                     }
                                                                                                                                     $2 = $5;
                                                                                                                                    }
                                                                                                                                    HEAP8[$0 + 146 | 0] = $2;
                                                                                                                                    break label$286;
                                                                                                                                   }
                                                                                                                                   $9 = HEAP32[$0 + 40 >> 2];
                                                                                                                                   $4 = $9;
                                                                                                                                   $12 = HEAP32[$0 + 44 >> 2];
                                                                                                                                   $7 = $4 + 1 | 0;
                                                                                                                                   $14 = $7 ? $12 : $12 + 1 | 0;
                                                                                                                                   HEAP32[$0 + 40 >> 2] = $7;
                                                                                                                                   HEAP32[$0 + 44 >> 2] = $14;
                                                                                                                                  }
                                                                                                                                  $6 = $1;
                                                                                                                                  break label$5;
                                                                                                                                 }
                                                                                                                                 $4 = HEAP32[$11 + 36 >> 2];
                                                                                                                                 $17 = $4;
                                                                                                                                 $14 = HEAP32[$11 + 32 >> 2];
                                                                                                                                 $16 = $14;
                                                                                                                                 $12 = $14;
                                                                                                                                 $10 = $12 | 67108864;
                                                                                                                                 HEAP32[$11 + 32 >> 2] = $10;
                                                                                                                                 HEAP32[$11 + 36 >> 2] = $4;
                                                                                                                                 $1 = HEAP32[HEAP32[$3 + 16 >> 2] + 8 >> 2];
                                                                                                                                 $6 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                                 $2 = sqlite3VdbeChangeEncoding($6, 1);
                                                                                                                                 if ($2) {
                                                                                                                                  $6 = $2;
                                                                                                                                  break label$5;
                                                                                                                                 }
                                                                                                                                 $2 = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 76 >> 2]]($1, HEAP32[$6 + 8 >> 2]) | 0;
                                                                                                                                 $12 = 0;
                                                                                                                                 $4 = $16;
                                                                                                                                 if (!($12 | $4 & 67108864)) {
                                                                                                                                  $4 = HEAP32[$11 + 36 >> 2];
                                                                                                                                  $12 = HEAP32[$11 + 32 >> 2];
                                                                                                                                  HEAP32[$11 + 32 >> 2] = $12 & -67108865;
                                                                                                                                  HEAP32[$11 + 36 >> 2] = $4;
                                                                                                                                 }
                                                                                                                                 sqlite3VtabImportErrmsg($0, $1);
                                                                                                                                 HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 252;
                                                                                                                                 $6 = 0;
                                                                                                                                 if (!$2) {
                                                                                                                                  break label$10;
                                                                                                                                 }
                                                                                                                                 $6 = $2;
                                                                                                                                 break label$5;
                                                                                                                                }
                                                                                                                                $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                                                                if (HEAPU8[$1 + 2 | 0]) {
                                                                                                                                 break label$10;
                                                                                                                                }
                                                                                                                                $6 = HEAP32[$1 + 36 >> 2];
                                                                                                                                $2 = HEAP32[$6 >> 2];
                                                                                                                                $5 = HEAP32[$2 >> 2];
                                                                                                                                $6 = FUNCTION_TABLE[HEAP32[$5 + 36 >> 2]]($6) | 0;
                                                                                                                                sqlite3VtabImportErrmsg($0, $2);
                                                                                                                                if ($6) {
                                                                                                                                 break label$5;
                                                                                                                                }
                                                                                                                                $6 = 0;
                                                                                                                                if (!(FUNCTION_TABLE[HEAP32[$5 + 40 >> 2]](HEAP32[$1 + 36 >> 2]) | 0)) {
                                                                                                                                 break label$12;
                                                                                                                                }
                                                                                                                                break label$11;
                                                                                                                               }
                                                                                                                               $5 = HEAP32[$3 + 12 >> 2];
                                                                                                                               $1 = Math_imul($5, 40) + $15 | 0;
                                                                                                                               $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                                                               if (HEAPU8[$2 + 2 | 0]) {
                                                                                                                                sqlite3VdbeMemSetNull($1);
                                                                                                                                break label$10;
                                                                                                                               }
                                                                                                                               $6 = HEAP32[HEAP32[$2 + 36 >> 2] >> 2];
                                                                                                                               $13 = HEAP32[$6 >> 2];
                                                                                                                               HEAP32[$40 + 24 >> 2] = 0;
                                                                                                                               $14 = $40;
                                                                                                                               HEAP32[$14 + 16 >> 2] = 0;
                                                                                                                               HEAP32[$14 + 20 >> 2] = 0;
                                                                                                                               HEAP32[$14 + 8 >> 2] = 0;
                                                                                                                               HEAP32[$14 + 12 >> 2] = 0;
                                                                                                                               HEAP32[$14 >> 2] = 0;
                                                                                                                               HEAP32[$14 + 4 >> 2] = 0;
                                                                                                                               HEAP8[$8 + 320 | 0] = $25;
                                                                                                                               HEAP32[$8 + 296 >> 2] = $1;
                                                                                                                               label$297: {
                                                                                                                                if (HEAP8[$3 + 2 | 0] & 1) {
                                                                                                                                 sqlite3VdbeMemSetNull($1);
                                                                                                                                 HEAP16[(Math_imul($5, 40) + $15 | 0) + 16 >> 1] = 1025;
                                                                                                                                 HEAP32[$1 >> 2] = 0;
                                                                                                                                 break label$297;
                                                                                                                                }
                                                                                                                                $5 = Math_imul($5, 40) + $15 | 0;
                                                                                                                                HEAP16[$5 + 16 >> 1] = HEAPU16[$5 + 16 >> 1] & 62016 | 1;
                                                                                                                               }
                                                                                                                               $2 = FUNCTION_TABLE[HEAP32[$13 + 44 >> 2]](HEAP32[$2 + 36 >> 2], $8 + 296 | 0, HEAP32[$3 + 8 >> 2]) | 0;
                                                                                                                               sqlite3VtabImportErrmsg($0, $6);
                                                                                                                               if (HEAP32[$8 + 316 >> 2] > 0) {
                                                                                                                                HEAP32[$8 + 224 >> 2] = sqlite3_value_text($1);
                                                                                                                                sqlite3VdbeError($0, 8342, $8 + 224 | 0);
                                                                                                                                $2 = HEAP32[$8 + 316 >> 2];
                                                                                                                               }
                                                                                                                               sqlite3VdbeChangeEncoding($1, $25);
                                                                                                                               $6 = 0;
                                                                                                                               if (!$2) {
                                                                                                                                break label$10;
                                                                                                                               }
                                                                                                                               $6 = $2;
                                                                                                                               break label$5;
                                                                                                                              }
                                                                                                                              $1 = 0;
                                                                                                                              $2 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                                                                              $13 = HEAP32[$2 + 40 >> 2];
                                                                                                                              $6 = ($13 | 0) > 0 ? $13 : 0;
                                                                                                                              $5 = $2 + 40 | 0;
                                                                                                                              $12 = HEAP32[$2 >> 2];
                                                                                                                              $16 = $12;
                                                                                                                              $14 = HEAP32[$2 + 4 >> 2];
                                                                                                                              $17 = $14;
                                                                                                                              $23 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                                                              $18 = HEAP32[$23 + 36 >> 2];
                                                                                                                              $20 = HEAP32[$18 >> 2];
                                                                                                                              $19 = HEAP32[$20 >> 2];
                                                                                                                              $2 = HEAP32[$0 + 92 >> 2];
                                                                                                                              while (1) {
                                                                                                                               if (($1 | 0) != ($6 | 0)) {
                                                                                                                                $4 = ($1 << 2) + $2 | 0;
                                                                                                                                $1 = $1 + 1 | 0;
                                                                                                                                HEAP32[$4 >> 2] = Math_imul($1, 40) + $5;
                                                                                                                                continue;
                                                                                                                               }
                                                                                                                               break;
                                                                                                                              }
                                                                                                                              $1 = FUNCTION_TABLE[HEAP32[$19 + 32 >> 2]]($18, $16, HEAP32[$3 + 16 >> 2], $13, $2) | 0;
                                                                                                                              sqlite3VtabImportErrmsg($0, $20);
                                                                                                                              if ($1) {
                                                                                                                               $6 = $1;
                                                                                                                               break label$5;
                                                                                                                              }
                                                                                                                              $6 = 0;
                                                                                                                              $1 = FUNCTION_TABLE[HEAP32[$19 + 40 >> 2]]($18) | 0;
                                                                                                                              HEAP8[$23 + 2 | 0] = 0;
                                                                                                                              if ($1) {
                                                                                                                               break label$13;
                                                                                                                              }
                                                                                                                              break label$10;
                                                                                                                             }
                                                                                                                             $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                                                             $1 = sqlite3_malloc64(8, 0);
                                                                                                                             if (!$1) {
                                                                                                                              break label$6;
                                                                                                                             }
                                                                                                                             HEAP32[$1 >> 2] = HEAP32[$2 + 36 >> 2];
                                                                                                                             HEAP32[$1 + 4 >> 2] = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15;
                                                                                                                             $2 = out2Prerelease($0, $3);
                                                                                                                             HEAP16[$2 + 16 >> 1] = 1;
                                                                                                                             sqlite3VdbeMemSetPointer($2, $1, 2236, 3);
                                                                                                                             break label$10;
                                                                                                                            }
                                                                                                                            HEAP32[$8 + 296 >> 2] = 0;
                                                                                                                            $6 = 6;
                                                                                                                            $1 = HEAP32[HEAP32[$3 + 16 >> 2] + 8 >> 2];
                                                                                                                            if (!$1) {
                                                                                                                             break label$5;
                                                                                                                            }
                                                                                                                            $2 = HEAP32[$1 >> 2];
                                                                                                                            if (!$2) {
                                                                                                                             break label$5;
                                                                                                                            }
                                                                                                                            $6 = FUNCTION_TABLE[HEAP32[$2 + 24 >> 2]]($1, $8 + 296 | 0) | 0;
                                                                                                                            sqlite3VtabImportErrmsg($0, $1);
                                                                                                                            if ($6) {
                                                                                                                             break label$5;
                                                                                                                            }
                                                                                                                            HEAP32[HEAP32[$8 + 296 >> 2] >> 2] = $1;
                                                                                                                            $6 = 0;
                                                                                                                            $5 = allocateCursor($0, HEAP32[$3 + 4 >> 2], 0, 2);
                                                                                                                            if ($5) {
                                                                                                                             HEAP32[$5 + 36 >> 2] = HEAP32[$8 + 296 >> 2];
                                                                                                                             HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
                                                                                                                             break label$10;
                                                                                                                            }
                                                                                                                            FUNCTION_TABLE[HEAP32[$2 + 28 >> 2]](HEAP32[$8 + 296 >> 2]) | 0;
                                                                                                                            break label$6;
                                                                                                                           }
                                                                                                                           HEAP32[$11 + 200 >> 2] = HEAP32[$11 + 200 >> 2] + 1;
                                                                                                                           $1 = sqlite3VtabCallDestroy($11, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 16 >> 2]);
                                                                                                                           HEAP32[$11 + 200 >> 2] = HEAP32[$11 + 200 >> 2] - 1;
                                                                                                                           $6 = 0;
                                                                                                                           if (!$1) {
                                                                                                                            break label$10;
                                                                                                                           }
                                                                                                                           $6 = $1;
                                                                                                                           break label$5;
                                                                                                                          }
                                                                                                                          $6 = 0;
                                                                                                                          memset($8 + 296 | 0, 0, 40);
                                                                                                                          HEAP32[$8 + 316 >> 2] = $11;
                                                                                                                          $1 = sqlite3VdbeMemCopy($8 + 296 | 0, Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0);
                                                                                                                          $2 = sqlite3_value_text($8 + 296 | 0);
                                                                                                                          if ($2) {
                                                                                                                           $1 = sqlite3VtabCallCreate($11, HEAP32[$3 + 4 >> 2], $2, $31);
                                                                                                                          }
                                                                                                                          sqlite3VdbeMemRelease($8 + 296 | 0);
                                                                                                                          if (!$1) {
                                                                                                                           break label$10;
                                                                                                                          }
                                                                                                                          $6 = $1;
                                                                                                                          break label$5;
                                                                                                                         }
                                                                                                                         $1 = HEAP32[$3 + 16 >> 2];
                                                                                                                         $2 = sqlite3VtabBegin($11, $1);
                                                                                                                         if ($1) {
                                                                                                                          sqlite3VtabImportErrmsg($0, HEAP32[$1 + 8 >> 2]);
                                                                                                                         }
                                                                                                                         $6 = 0;
                                                                                                                         if (!$2) {
                                                                                                                          break label$10;
                                                                                                                         }
                                                                                                                         $6 = $2;
                                                                                                                         break label$5;
                                                                                                                        }
                                                                                                                        $1 = HEAPU8[$3 + 12 | 0];
                                                                                                                        if (!(HEAPU8[$11 + 33 | 0] & 4 ? $1 : 1)) {
                                                                                                                         break label$10;
                                                                                                                        }
                                                                                                                        $1 = sqlite3BtreeLockTable(HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2], HEAP32[$3 + 8 >> 2], $1);
                                                                                                                        if (!$1) {
                                                                                                                         break label$40;
                                                                                                                        }
                                                                                                                        if (($1 & 255) == 6) {
                                                                                                                         HEAP32[$8 + 208 >> 2] = HEAP32[$3 + 16 >> 2];
                                                                                                                         sqlite3VdbeError($0, 8171, $8 + 208 | 0);
                                                                                                                        }
                                                                                                                        $6 = $1;
                                                                                                                        break label$5;
                                                                                                                       }
                                                                                                                       sqlite3BtreeCursorUnpin(HEAP32[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 36 >> 2]);
                                                                                                                       break label$10;
                                                                                                                      }
                                                                                                                      sqlite3BtreeCursorPin(HEAP32[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 36 >> 2]);
                                                                                                                      break label$10;
                                                                                                                     }
                                                                                                                     $1 = HEAP32[$3 + 8 >> 2];
                                                                                                                     if (!HEAP32[$3 + 4 >> 2]) {
                                                                                                                      sqlite3ExpirePreparedStatements($11, $1);
                                                                                                                      break label$10;
                                                                                                                     }
                                                                                                                     HEAP8[$0 + 150 | 0] = $1 + 1 & 3 | HEAPU8[$0 + 150 | 0] & 252;
                                                                                                                     break label$10;
                                                                                                                    }
                                                                                                                    $1 = sqlite3BtreeIncrVacuum(HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2]);
                                                                                                                    if (!$1) {
                                                                                                                     $6 = $1;
                                                                                                                     break label$10;
                                                                                                                    }
                                                                                                                    $6 = 0;
                                                                                                                    if (($1 | 0) == 101) {
                                                                                                                     break label$13;
                                                                                                                    }
                                                                                                                    $6 = $1;
                                                                                                                    break label$5;
                                                                                                                   }
                                                                                                                   $6 = 0;
                                                                                                                   $1 = HEAP32[$3 + 8 >> 2];
                                                                                                                   $1 = sqlite3RunVacuum($31, $11, HEAP32[$3 + 4 >> 2], $1 ? Math_imul($1, 40) + $15 | 0 : 0);
                                                                                                                   if (!$1) {
                                                                                                                    break label$10;
                                                                                                                   }
                                                                                                                   $6 = $1;
                                                                                                                   break label$5;
                                                                                                                  }
                                                                                                                  $1 = out2Prerelease($0, $3);
                                                                                                                  label$310: {
                                                                                                                   label$311: {
                                                                                                                    label$312: {
                                                                                                                     $19 = HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2];
                                                                                                                     $5 = sqlite3BtreePager($19);
                                                                                                                     $2 = sqlite3PagerGetJournalMode($5);
                                                                                                                     $13 = HEAP32[$3 + 12 >> 2];
                                                                                                                     $13 = sqlite3PagerOkToChangeJournalMode($5) ? ($13 | 0) == -1 ? $2 : $13 : $2;
                                                                                                                     label$313: {
                                                                                                                      if (($13 | 0) == 5) {
                                                                                                                       if (!sqlite3Strlen30(sqlite3PagerFilename($5, 1))) {
                                                                                                                        break label$313;
                                                                                                                       }
                                                                                                                       if (!sqlite3PagerWalSupported($5) | ($2 | 0) == ($13 | 0)) {
                                                                                                                        break label$313;
                                                                                                                       }
                                                                                                                       break label$312;
                                                                                                                      }
                                                                                                                      if (($2 | 0) != ($13 | 0)) {
                                                                                                                       break label$312;
                                                                                                                      }
                                                                                                                     }
                                                                                                                     $13 = $2;
                                                                                                                     break label$311;
                                                                                                                    }
                                                                                                                    if (($2 | 0) != 5 & ($13 | 0) != 5) {
                                                                                                                     break label$311;
                                                                                                                    }
                                                                                                                    if (!(HEAP32[$11 + 188 >> 2] < 2 ? HEAPU8[$11 + 85 | 0] : 0)) {
                                                                                                                     HEAP32[$8 + 192 >> 2] = ($13 | 0) == 5 ? 9507 : 12052;
                                                                                                                     sqlite3VdbeError($0, 9998, $8 + 192 | 0);
                                                                                                                     $6 = 1;
                                                                                                                     break label$5;
                                                                                                                    }
                                                                                                                    label$317: {
                                                                                                                     if (($2 | 0) == 5) {
                                                                                                                      $18 = sqlite3PagerCloseWal($5, $11);
                                                                                                                      if ($18) {
                                                                                                                       break label$310;
                                                                                                                      }
                                                                                                                      sqlite3PagerSetJournalMode($5, $13);
                                                                                                                      break label$317;
                                                                                                                     }
                                                                                                                     if (($2 | 0) == 4) {
                                                                                                                      sqlite3PagerSetJournalMode($5, 2);
                                                                                                                     }
                                                                                                                     if ($6) {
                                                                                                                      break label$311;
                                                                                                                     }
                                                                                                                    }
                                                                                                                    $18 = sqlite3BtreeSetVersion($19, ($13 | 0) == 5 ? 2 : 1);
                                                                                                                    break label$310;
                                                                                                                   }
                                                                                                                   $18 = $6;
                                                                                                                  }
                                                                                                                  $6 = sqlite3PagerSetJournalMode($5, $18 ? $2 : $13);
                                                                                                                  HEAP16[$1 + 16 >> 1] = 8706;
                                                                                                                  $6 = sqlite3JournalModename($6);
                                                                                                                  HEAP32[$1 + 8 >> 2] = $6;
                                                                                                                  $6 = sqlite3Strlen30($6);
                                                                                                                  HEAP8[$1 + 18 | 0] = 1;
                                                                                                                  HEAP32[$1 + 12 >> 2] = $6;
                                                                                                                  sqlite3VdbeChangeEncoding($1, $25);
                                                                                                                  $6 = 0;
                                                                                                                  if (!$18) {
                                                                                                                   break label$10;
                                                                                                                  }
                                                                                                                  $6 = $18;
                                                                                                                  break label$5;
                                                                                                                 }
                                                                                                                 HEAP32[$8 + 304 >> 2] = -1;
                                                                                                                 HEAP32[$8 + 296 >> 2] = 0;
                                                                                                                 HEAP32[$8 + 300 >> 2] = -1;
                                                                                                                 label$320: {
                                                                                                                  $1 = sqlite3Checkpoint($11, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2], $43, $44);
                                                                                                                  if ($1) {
                                                                                                                   if (($1 | 0) != 5) {
                                                                                                                    break label$320;
                                                                                                                   }
                                                                                                                   HEAP32[$8 + 296 >> 2] = 1;
                                                                                                                  }
                                                                                                                  $6 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                                                                  $1 = 0;
                                                                                                                  while (1) {
                                                                                                                   if (($1 | 0) == 3) {
                                                                                                                    break label$26;
                                                                                                                   }
                                                                                                                   $4 = ($8 + 296 | 0) + ($1 << 2) | 0;
                                                                                                                   $14 = HEAP32[$4 >> 2];
                                                                                                                   $12 = $14 >> 31;
                                                                                                                   sqlite3VdbeMemSetInt64($6, $14, $12);
                                                                                                                   $6 = $6 + 40 | 0;
                                                                                                                   $1 = $1 + 1 | 0;
                                                                                                                   continue;
                                                                                                                  }
                                                                                                                 }
                                                                                                                 $6 = $1;
                                                                                                                 break label$5;
                                                                                                                }
                                                                                                                $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                                $6 = HEAP32[$3 + 12 >> 2];
                                                                                                                label$323: {
                                                                                                                 if ($6) {
                                                                                                                  $6 = sqlite3VdbeMemAggValue($1, Math_imul($6, 40) + $15 | 0, HEAP32[$3 + 16 >> 2]);
                                                                                                                  $1 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                                                                  break label$323;
                                                                                                                 }
                                                                                                                 $6 = sqlite3VdbeMemFinalize($1, HEAP32[$3 + 16 >> 2]);
                                                                                                                }
                                                                                                                if (!$6) {
                                                                                                                 sqlite3VdbeChangeEncoding($1, $25);
                                                                                                                 break label$26;
                                                                                                                }
                                                                                                                HEAP32[$8 + 176 >> 2] = sqlite3_value_text($1);
                                                                                                                sqlite3VdbeError($0, 8342, $8 + 176 | 0);
                                                                                                                break label$5;
                                                                                                               }
                                                                                                               $1 = HEAPU16[$3 + 2 >> 1];
                                                                                                               $5 = $1 << 2;
                                                                                                               $2 = sqlite3DbMallocRawNN($11, $5 + 68 | 0, 0);
                                                                                                               if (!$2) {
                                                                                                                break label$6;
                                                                                                               }
                                                                                                               HEAP32[$2 + 8 >> 2] = 0;
                                                                                                               $5 = ($2 + $5 | 0) + 28 | 0;
                                                                                                               HEAP32[$2 >> 2] = $5;
                                                                                                               sqlite3VdbeMemInit($5, $11, 1);
                                                                                                               $5 = HEAP32[$3 + 16 >> 2];
                                                                                                               HEAP32[$2 + 16 >> 2] = ($3 - $22 | 0) / 20;
                                                                                                               HEAP32[$2 + 4 >> 2] = $5;
                                                                                                               HEAP8[$2 + 25 | 0] = 0;
                                                                                                               HEAP32[$2 + 12 >> 2] = $0;
                                                                                                               HEAP8[$2 + 26 | 0] = $1;
                                                                                                               HEAP8[$2 + 24 | 0] = $25;
                                                                                                               HEAP32[$2 + 20 >> 2] = 0;
                                                                                                               HEAP32[$3 + 16 >> 2] = $2;
                                                                                                               HEAP16[$3 >> 1] = 61859;
                                                                                                              }
                                                                                                              label$326: {
                                                                                                               $5 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                                                               if (($5 | 0) == HEAP32[$2 + 8 >> 2]) {
                                                                                                                break label$326;
                                                                                                               }
                                                                                                               HEAP32[$2 + 8 >> 2] = $5;
                                                                                                               $1 = HEAPU8[$2 + 26 | 0];
                                                                                                               while (1) {
                                                                                                                if (($1 | 0) <= 0) {
                                                                                                                 break label$326;
                                                                                                                }
                                                                                                                $1 = $1 - 1 | 0;
                                                                                                                HEAP32[(($1 << 2) + $2 | 0) + 28 >> 2] = Math_imul(HEAP32[$3 + 8 >> 2] + $1 | 0, 40) + $15;
                                                                                                                continue;
                                                                                                               }
                                                                                                              }
                                                                                                              HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
                                                                                                              FUNCTION_TABLE[HEAP32[HEAP32[$2 + 4 >> 2] + (HEAP32[$3 + 4 >> 2] ? 28 : 16) >> 2]]($2, HEAPU8[$2 + 26 | 0], $2 + 28 | 0);
                                                                                                              $5 = HEAP32[$2 + 20 >> 2];
                                                                                                              if (!$5) {
                                                                                                               break label$10;
                                                                                                              }
                                                                                                              $1 = $6;
                                                                                                              if (($5 | 0) > 0) {
                                                                                                               HEAP32[$8 + 160 >> 2] = sqlite3_value_text(HEAP32[$2 >> 2]);
                                                                                                               sqlite3VdbeError($0, 8342, $8 + 160 | 0);
                                                                                                               $1 = HEAP32[$2 + 20 >> 2];
                                                                                                              }
                                                                                                              if (HEAPU8[$2 + 25 | 0]) {
                                                                                                               $6 = HEAP32[$3 - 16 >> 2];
                                                                                                               if ($6) {
                                                                                                                sqlite3VdbeMemSetInt64(Math_imul($6, 40) + $15 | 0, 1, 0);
                                                                                                               }
                                                                                                               HEAP8[$2 + 25 | 0] = 0;
                                                                                                              }
                                                                                                              sqlite3VdbeMemRelease(HEAP32[$2 >> 2]);
                                                                                                              HEAP16[HEAP32[$2 >> 2] + 16 >> 1] = 1;
                                                                                                              $6 = 0;
                                                                                                              HEAP32[$2 + 20 >> 2] = 0;
                                                                                                              if (!$1) {
                                                                                                               break label$10;
                                                                                                              }
                                                                                                              $6 = $1;
                                                                                                              break label$5;
                                                                                                             }
                                                                                                             $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                             $12 = HEAP32[$1 >> 2];
                                                                                                             $16 = $12;
                                                                                                             $14 = HEAP32[$1 + 4 >> 2];
                                                                                                             $17 = $14;
                                                                                                             $4 = $16;
                                                                                                             if (!$4 & ($14 | 0) == -2147483648) {
                                                                                                              break label$10;
                                                                                                             }
                                                                                                             $10 = $16;
                                                                                                             $9 = $10 - 1 | 0;
                                                                                                             $4 = $17;
                                                                                                             $7 = !$10;
                                                                                                             $7 = $4 - $7 | 0;
                                                                                                             HEAP32[$1 >> 2] = $9;
                                                                                                             HEAP32[$1 + 4 >> 2] = $7;
                                                                                                             if (!($7 | $9)) {
                                                                                                              break label$13;
                                                                                                             }
                                                                                                             break label$10;
                                                                                                            }
                                                                                                            $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                            $7 = HEAP32[$1 >> 2];
                                                                                                            $16 = $7;
                                                                                                            $10 = HEAP32[$1 + 4 >> 2];
                                                                                                            $17 = $10;
                                                                                                            if (!($10 | $7)) {
                                                                                                             break label$10;
                                                                                                            }
                                                                                                            $4 = $16;
                                                                                                            $10 = $17;
                                                                                                            if (!$4 & ($10 | 0) <= 0 | ($10 | 0) < 0) {
                                                                                                             break label$13;
                                                                                                            }
                                                                                                            $12 = $16;
                                                                                                            $14 = $12 - 1 | 0;
                                                                                                            HEAP32[$1 >> 2] = $14;
                                                                                                            $4 = $17;
                                                                                                            $9 = !$16;
                                                                                                            $9 = $4 - $9 | 0;
                                                                                                            HEAP32[$1 + 4 >> 2] = $9;
                                                                                                            break label$13;
                                                                                                           }
                                                                                                           $1 = HEAP32[$3 + 4 >> 2];
                                                                                                           $5 = HEAP32[$3 + 12 >> 2];
                                                                                                           $2 = out2Prerelease($0, $3);
                                                                                                           $4 = Math_imul($1, 40) + $15 | 0;
                                                                                                           $9 = HEAP32[$4 >> 2];
                                                                                                           $16 = $9;
                                                                                                           $12 = HEAP32[$4 + 4 >> 2];
                                                                                                           HEAP32[$8 + 296 >> 2] = $16;
                                                                                                           HEAP32[$8 + 300 >> 2] = $12;
                                                                                                           $4 = $16;
                                                                                                           if (!$4 & ($12 | 0) <= 0 | ($12 | 0) < 0) {
                                                                                                            $16 = -1;
                                                                                                            $10 = -1;
                                                                                                            $4 = -1;
                                                                                                           } else {
                                                                                                            $7 = Math_imul($5, 40) + $15 | 0;
                                                                                                            $4 = HEAP32[$7 >> 2];
                                                                                                            $12 = HEAP32[$7 + 4 >> 2];
                                                                                                            $10 = !!$4 & ($12 | 0) >= 0 | ($12 | 0) > 0;
                                                                                                            $4 = $10 ? $4 : 0;
                                                                                                            $7 = $12;
                                                                                                            $9 = $10 ? $7 : 0;
                                                                                                            $1 = sqlite3AddInt64($8 + 296 | 0, $4, $9);
                                                                                                            $9 = HEAP32[$8 + 296 >> 2];
                                                                                                            $7 = $1 ? -1 : $9;
                                                                                                            $16 = $7;
                                                                                                            $4 = HEAP32[$8 + 300 >> 2];
                                                                                                            $10 = $1 ? -1 : $4;
                                                                                                            $4 = -1;
                                                                                                           }
                                                                                                           $7 = $2;
                                                                                                           HEAP32[$7 >> 2] = $16;
                                                                                                           HEAP32[$7 + 4 >> 2] = $10;
                                                                                                           break label$10;
                                                                                                          }
                                                                                                          $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                          $10 = HEAP32[$1 >> 2];
                                                                                                          $16 = $10;
                                                                                                          $7 = HEAP32[$1 + 4 >> 2];
                                                                                                          $17 = $7;
                                                                                                          $12 = $16;
                                                                                                          if (!$12 & ($7 | 0) <= 0 | ($7 | 0) < 0) {
                                                                                                           break label$10;
                                                                                                          }
                                                                                                          $12 = HEAP32[$3 + 12 >> 2];
                                                                                                          $7 = $12 >> 31;
                                                                                                          $14 = $7;
                                                                                                          $4 = $16;
                                                                                                          $10 = $12;
                                                                                                          $9 = $4 - $10 | 0;
                                                                                                          HEAP32[$1 >> 2] = $9;
                                                                                                          $7 = $17;
                                                                                                          $12 = $14;
                                                                                                          $14 = $12 + ($10 >>> 0 > $16 >>> 0) | 0;
                                                                                                          $14 = $7 - $14 | 0;
                                                                                                          HEAP32[$1 + 4 >> 2] = $14;
                                                                                                          break label$13;
                                                                                                         }
                                                                                                         $2 = $15;
                                                                                                         $1 = HEAP32[$34 >> 2];
                                                                                                         if ($1) {
                                                                                                          while (1) {
                                                                                                           $2 = $1;
                                                                                                           $1 = HEAP32[$1 + 4 >> 2];
                                                                                                           if ($1) {
                                                                                                            continue;
                                                                                                           }
                                                                                                           break;
                                                                                                          }
                                                                                                          $2 = HEAP32[$2 + 16 >> 2];
                                                                                                         }
                                                                                                         $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $2 | 0;
                                                                                                         sqlite3VdbeMemIntegerify($1);
                                                                                                         $2 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                                         sqlite3VdbeMemIntegerify($2);
                                                                                                         $14 = HEAP32[$2 >> 2];
                                                                                                         $16 = $14;
                                                                                                         $4 = HEAP32[$2 + 4 >> 2];
                                                                                                         $17 = $4;
                                                                                                         $14 = HEAP32[$1 + 4 >> 2];
                                                                                                         $7 = $14;
                                                                                                         $4 = HEAP32[$1 >> 2];
                                                                                                         $10 = $4;
                                                                                                         $14 = $17;
                                                                                                         $4 = $7;
                                                                                                         $7 = $16;
                                                                                                         if (($14 | 0) <= ($4 | 0) & $7 >>> 0 <= $10 >>> 0 | ($4 | 0) > ($14 | 0)) {
                                                                                                          break label$10;
                                                                                                         }
                                                                                                         HEAP32[$1 >> 2] = $16;
                                                                                                         $7 = $17;
                                                                                                         HEAP32[$1 + 4 >> 2] = $7;
                                                                                                         break label$10;
                                                                                                        }
                                                                                                        if (HEAP32[$3 + 4 >> 2]) {
                                                                                                         $7 = HEAP32[$11 + 512 >> 2];
                                                                                                         $10 = $7;
                                                                                                         $14 = HEAP32[$11 + 516 >> 2];
                                                                                                         if ($14 | $10) {
                                                                                                          break label$10;
                                                                                                         }
                                                                                                         $10 = HEAP32[$11 + 520 >> 2];
                                                                                                         $14 = HEAP32[$11 + 524 >> 2];
                                                                                                         if (!($10 | $14)) {
                                                                                                          break label$13;
                                                                                                         }
                                                                                                         break label$10;
                                                                                                        }
                                                                                                        $14 = HEAP32[$0 + 64 >> 2];
                                                                                                        $4 = $14;
                                                                                                        $10 = HEAP32[$0 + 68 >> 2];
                                                                                                        if ($10 | $4) {
                                                                                                         break label$10;
                                                                                                        }
                                                                                                        $4 = HEAP32[$11 + 520 >> 2];
                                                                                                        $10 = HEAP32[$11 + 524 >> 2];
                                                                                                        if (!($4 | $10)) {
                                                                                                         break label$13;
                                                                                                        }
                                                                                                        break label$10;
                                                                                                       }
                                                                                                       if (HEAPU8[$11 + 34 | 0] & 8) {
                                                                                                        $10 = HEAP32[$11 + 520 >> 2];
                                                                                                        $7 = $10;
                                                                                                        $4 = HEAP32[$11 + 524 >> 2];
                                                                                                        $17 = $4;
                                                                                                        $4 = HEAP32[$3 + 8 >> 2];
                                                                                                        $10 = $4 >> 31;
                                                                                                        $14 = $4;
                                                                                                        $12 = $4 + $7 | 0;
                                                                                                        $4 = $10;
                                                                                                        $10 = $17;
                                                                                                        $9 = $4 + $10 | 0;
                                                                                                        HEAP32[$11 + 520 >> 2] = $12;
                                                                                                        $9 = $12 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
                                                                                                        HEAP32[$11 + 524 >> 2] = $9;
                                                                                                        break label$10;
                                                                                                       }
                                                                                                       $9 = HEAP32[$3 + 8 >> 2];
                                                                                                       $7 = $9 >> 31;
                                                                                                       $16 = $9;
                                                                                                       $17 = $7;
                                                                                                       if (HEAP32[$3 + 4 >> 2]) {
                                                                                                        $14 = $16;
                                                                                                        $7 = HEAP32[$11 + 512 >> 2];
                                                                                                        $4 = $14 + $7 | 0;
                                                                                                        $9 = HEAP32[$11 + 516 >> 2];
                                                                                                        $7 = $17;
                                                                                                        $12 = $9 + $7 | 0;
                                                                                                        HEAP32[$11 + 512 >> 2] = $4;
                                                                                                        $12 = $4 >>> 0 < $14 >>> 0 ? $12 + 1 | 0 : $12;
                                                                                                        HEAP32[$11 + 516 >> 2] = $12;
                                                                                                        break label$10;
                                                                                                       }
                                                                                                       $12 = HEAP32[$0 + 64 >> 2];
                                                                                                       $9 = $12;
                                                                                                       $14 = $16;
                                                                                                       $7 = $9 + $14 | 0;
                                                                                                       $10 = HEAP32[$0 + 68 >> 2];
                                                                                                       $12 = $17;
                                                                                                       $4 = $10 + $12 | 0;
                                                                                                       HEAP32[$0 + 64 >> 2] = $7;
                                                                                                       $4 = $7 >>> 0 < $14 >>> 0 ? $4 + 1 | 0 : $4;
                                                                                                       HEAP32[$0 + 68 >> 2] = $4;
                                                                                                       break label$10;
                                                                                                      }
                                                                                                      $4 = out2Prerelease($0, $3);
                                                                                                      $1 = HEAP32[$0 + 212 >> 2];
                                                                                                      sqlite3VdbeMemShallowCopy($4, HEAP32[$1 + 16 >> 2] + Math_imul(HEAP32[(HEAP32[$1 + 8 >> 2] + Math_imul(HEAP32[$1 + 48 >> 2], 20) | 0) + 4 >> 2] + HEAP32[$3 + 4 >> 2] | 0, 40) | 0, 16384);
                                                                                                      break label$10;
                                                                                                     }
                                                                                                     $18 = HEAP32[$3 + 12 >> 2];
                                                                                                     $13 = HEAP32[$3 + 16 >> 2];
                                                                                                     label$338: {
                                                                                                      if (!HEAPU16[$3 + 2 >> 1]) {
                                                                                                       break label$338;
                                                                                                      }
                                                                                                      $5 = HEAP32[$13 + 20 >> 2];
                                                                                                      $2 = $34;
                                                                                                      while (1) {
                                                                                                       $1 = HEAP32[$2 >> 2];
                                                                                                       if (!$1) {
                                                                                                        break label$338;
                                                                                                       }
                                                                                                       $2 = $1 + 4 | 0;
                                                                                                       if (HEAP32[$1 + 28 >> 2] != ($5 | 0)) {
                                                                                                        continue;
                                                                                                       }
                                                                                                       break;
                                                                                                      }
                                                                                                      break label$10;
                                                                                                     }
                                                                                                     $1 = HEAP32[$0 + 220 >> 2];
                                                                                                     if (($1 | 0) < HEAP32[$11 + 160 >> 2]) {
                                                                                                      label$341: {
                                                                                                       label$342: {
                                                                                                        $19 = Math_imul($18, 40) + $15 | 0;
                                                                                                        if (!(HEAPU8[$19 + 16 | 0] & 16)) {
                                                                                                         $1 = HEAP32[$13 + 12 >> 2];
                                                                                                         $5 = !$1 + (HEAP32[$13 + 8 >> 2] + $1 | 0) | 0;
                                                                                                         $20 = ((((HEAP32[$13 + 4 >> 2] + 7 | 0) / 8 | 0) + ($1 << 2) | 0) + Math_imul($5, 40) | 0) + 88 | 0;
                                                                                                         $9 = $20;
                                                                                                         $4 = $9 >> 31;
                                                                                                         $2 = sqlite3DbMallocZero($11, $9, $4);
                                                                                                         if (!$2) {
                                                                                                          break label$6;
                                                                                                         }
                                                                                                         sqlite3VdbeMemRelease(Math_imul($18, 40) + $15 | 0);
                                                                                                         HEAP16[$19 + 16 >> 1] = 4112;
                                                                                                         $1 = Math_imul($18, 40) + $15 | 0;
                                                                                                         HEAP32[$1 + 36 >> 2] = 4;
                                                                                                         HEAP32[$1 + 12 >> 2] = $20;
                                                                                                         HEAP32[$1 + 8 >> 2] = $2;
                                                                                                         HEAP32[$2 + 60 >> 2] = $5;
                                                                                                         HEAP32[$2 >> 2] = $0;
                                                                                                         $18 = HEAP32[$13 + 12 >> 2];
                                                                                                         HEAP32[$2 + 48 >> 2] = ($3 - $22 | 0) / 20;
                                                                                                         HEAP32[$2 + 64 >> 2] = $18;
                                                                                                         HEAP32[$2 + 16 >> 2] = HEAP32[$0 + 88 >> 2];
                                                                                                         HEAP32[$2 + 56 >> 2] = HEAP32[$0 + 20 >> 2];
                                                                                                         HEAP32[$2 + 20 >> 2] = HEAP32[$0 + 96 >> 2];
                                                                                                         HEAP32[$2 + 44 >> 2] = HEAP32[$0 + 24 >> 2];
                                                                                                         HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 104 >> 2];
                                                                                                         HEAP32[$2 + 52 >> 2] = HEAP32[$0 + 108 >> 2];
                                                                                                         HEAP32[$2 + 28 >> 2] = HEAP32[$13 + 20 >> 2];
                                                                                                         $1 = $2 + 88 | 0;
                                                                                                         $3 = $1 + Math_imul($5, 40) | 0;
                                                                                                         while (1) {
                                                                                                          if (($1 | 0) == ($3 | 0)) {
                                                                                                           break label$342;
                                                                                                          }
                                                                                                          HEAP32[$1 + 20 >> 2] = $11;
                                                                                                          HEAP16[$1 + 16 >> 1] = 0;
                                                                                                          $1 = $1 + 40 | 0;
                                                                                                          continue;
                                                                                                         }
                                                                                                        }
                                                                                                        $2 = HEAP32[$19 + 8 >> 2];
                                                                                                        $3 = HEAPU16[$2 + 64 >> 1];
                                                                                                        $5 = HEAP32[$2 + 60 >> 2];
                                                                                                        $18 = HEAP32[$13 + 12 >> 2];
                                                                                                        break label$341;
                                                                                                       }
                                                                                                       $1 = HEAP32[$0 + 220 >> 2];
                                                                                                       $3 = $18;
                                                                                                      }
                                                                                                      HEAP32[$0 + 220 >> 2] = $1 + 1;
                                                                                                      HEAP32[$2 + 4 >> 2] = HEAP32[$0 + 212 >> 2];
                                                                                                      $9 = HEAP32[$11 + 44 >> 2];
                                                                                                      $4 = HEAP32[$11 + 40 >> 2];
                                                                                                      HEAP32[$2 + 32 >> 2] = $4;
                                                                                                      HEAP32[$2 + 36 >> 2] = $9;
                                                                                                      $4 = HEAP32[$0 + 44 >> 2];
                                                                                                      $9 = HEAP32[$0 + 40 >> 2];
                                                                                                      HEAP32[$2 + 72 >> 2] = $9;
                                                                                                      HEAP32[$2 + 76 >> 2] = $4;
                                                                                                      $10 = HEAP32[$0 >> 2];
                                                                                                      $4 = HEAP32[$10 + 104 >> 2];
                                                                                                      $9 = HEAP32[$10 + 108 >> 2];
                                                                                                      HEAP32[$2 + 80 >> 2] = $4;
                                                                                                      HEAP32[$2 + 84 >> 2] = $9;
                                                                                                      HEAP32[$2 + 40 >> 2] = HEAP32[$0 + 232 >> 2];
                                                                                                      HEAP32[$0 + 212 >> 2] = $2;
                                                                                                      HEAP32[$0 + 40 >> 2] = 0;
                                                                                                      HEAP32[$0 + 44 >> 2] = 0;
                                                                                                      HEAP32[$0 + 232 >> 2] = 0;
                                                                                                      $15 = $2 + 88 | 0;
                                                                                                      HEAP32[$0 + 88 >> 2] = $15;
                                                                                                      $1 = Math_imul($5, 40) + $15 | 0;
                                                                                                      HEAP32[$0 + 96 >> 2] = $1;
                                                                                                      HEAP32[$0 + 24 >> 2] = $3 & 65535;
                                                                                                      HEAP32[$0 + 20 >> 2] = $5;
                                                                                                      $1 = ($18 << 2) + $1 | 0;
                                                                                                      HEAP32[$2 + 24 >> 2] = $1;
                                                                                                      memset($1, 0, (HEAP32[$13 + 4 >> 2] + 7 | 0) / 8 | 0);
                                                                                                      $22 = HEAP32[$13 >> 2];
                                                                                                      HEAP32[$0 + 104 >> 2] = $22;
                                                                                                      HEAP32[$0 + 108 >> 2] = HEAP32[$13 + 4 >> 2];
                                                                                                      $3 = $22 - 20 | 0;
                                                                                                      break label$11;
                                                                                                     }
                                                                                                     sqlite3VdbeError($0, 10350, 0);
                                                                                                     $6 = 1;
                                                                                                     break label$5;
                                                                                                    }
                                                                                                    $5 = HEAP32[$3 + 12 >> 2];
                                                                                                    $1 = HEAP32[$3 + 16 >> 2];
                                                                                                    $2 = HEAP32[$3 + 4 >> 2];
                                                                                                    $13 = Math_imul($2, 40) + $15 | 0;
                                                                                                    if (!(HEAPU8[$13 + 16 | 0] & 16)) {
                                                                                                     if (sqlite3VdbeMemSetRowSet($13)) {
                                                                                                      break label$6;
                                                                                                     }
                                                                                                    }
                                                                                                    $5 = Math_imul($5, 40) + $15 | 0;
                                                                                                    if ($1) {
                                                                                                     $9 = HEAP32[$5 >> 2];
                                                                                                     $4 = HEAP32[$5 + 4 >> 2];
                                                                                                     if (sqlite3RowSetTest(HEAP32[(Math_imul($2, 40) + $15 | 0) + 8 >> 2], $1, $9, $4)) {
                                                                                                      break label$13;
                                                                                                     }
                                                                                                     if (($1 | 0) < 0) {
                                                                                                      break label$10;
                                                                                                     }
                                                                                                    }
                                                                                                    $4 = HEAP32[$5 >> 2];
                                                                                                    $9 = HEAP32[$5 + 4 >> 2];
                                                                                                    sqlite3RowSetInsert(HEAP32[(Math_imul($2, 40) + $15 | 0) + 8 >> 2], $4, $9);
                                                                                                    break label$10;
                                                                                                   }
                                                                                                   label$347: {
                                                                                                    $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                    if (HEAPU8[$1 + 16 | 0] & 16) {
                                                                                                     if (sqlite3RowSetNext(HEAP32[$1 + 8 >> 2], $8 + 296 | 0)) {
                                                                                                      break label$347;
                                                                                                     }
                                                                                                    }
                                                                                                    sqlite3VdbeMemSetNull($1);
                                                                                                    break label$12;
                                                                                                   }
                                                                                                   $9 = HEAP32[$8 + 296 >> 2];
                                                                                                   $4 = HEAP32[$8 + 300 >> 2];
                                                                                                   sqlite3VdbeMemSetInt64(Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0, $9, $4);
                                                                                                   break label$11;
                                                                                                  }
                                                                                                  $2 = HEAP32[$3 + 8 >> 2];
                                                                                                  $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                                                                                  if (!(HEAPU8[$1 + 16 | 0] & 16)) {
                                                                                                   if (sqlite3VdbeMemSetRowSet($1)) {
                                                                                                    break label$6;
                                                                                                   }
                                                                                                  }
                                                                                                  $10 = Math_imul($2, 40) + $15 | 0;
                                                                                                  $4 = HEAP32[$10 >> 2];
                                                                                                  $9 = HEAP32[$10 + 4 >> 2];
                                                                                                  sqlite3RowSetInsert(HEAP32[$1 + 8 >> 2], $4, $9);
                                                                                                  break label$10;
                                                                                                 }
                                                                                                 $1 = HEAP32[$3 + 4 >> 2];
                                                                                                 $5 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                                                 $2 = sqlite3BtreeIntegrityCheck($11, HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAPU16[$3 + 2 >> 1] << 4) | 0) + 4 >> 2], HEAP32[$3 + 16 >> 2] + 4 | 0, HEAP32[$3 + 8 >> 2], HEAP32[$5 >> 2] + 1 | 0, $8 + 296 | 0);
                                                                                                 $1 = Math_imul($1, 40) + $15 | 0;
                                                                                                 sqlite3VdbeMemSetNull($1);
                                                                                                 $13 = HEAP32[$8 + 296 >> 2];
                                                                                                 if ($13) {
                                                                                                  if (!$2) {
                                                                                                   break label$6;
                                                                                                  }
                                                                                                  $9 = HEAP32[$5 >> 2];
                                                                                                  $10 = $9;
                                                                                                  $4 = HEAP32[$5 + 4 >> 2];
                                                                                                  $7 = $4;
                                                                                                  $9 = $13 - 1 | 0;
                                                                                                  $4 = $9 >> 31;
                                                                                                  $17 = $4;
                                                                                                  $14 = $9;
                                                                                                  $12 = $10 - $9 | 0;
                                                                                                  $4 = $7;
                                                                                                  $9 = $17;
                                                                                                  $7 = $9 + ($10 >>> 0 < $14 >>> 0) | 0;
                                                                                                  $7 = $4 - $7 | 0;
                                                                                                  HEAP32[$5 >> 2] = $12;
                                                                                                  HEAP32[$5 + 4 >> 2] = $7;
                                                                                                  sqlite3VdbeMemSetStr($1, $2, -1, -1, 1, 3);
                                                                                                 }
                                                                                                 sqlite3VdbeChangeEncoding($1, $25);
                                                                                                 break label$11;
                                                                                                }
                                                                                                sqlite3UnlinkAndDeleteTrigger($11, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 16 >> 2]);
                                                                                                break label$10;
                                                                                               }
                                                                                               sqlite3UnlinkAndDeleteIndex($11, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 16 >> 2]);
                                                                                               break label$10;
                                                                                              }
                                                                                              sqlite3UnlinkAndDeleteTable($11, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 16 >> 2]);
                                                                                              break label$10;
                                                                                             }
                                                                                             $6 = 0;
                                                                                             $1 = sqlite3AnalysisLoad($11, HEAP32[$3 + 4 >> 2]);
                                                                                             if (!$1) {
                                                                                              break label$10;
                                                                                             }
                                                                                             $6 = $1;
                                                                                             break label$5;
                                                                                            }
                                                                                            $1 = HEAP32[$3 + 4 >> 2];
                                                                                            label$351: {
                                                                                             label$352: {
                                                                                              if (!HEAP32[$3 + 16 >> 2]) {
                                                                                               sqlite3SchemaClear(HEAP32[(HEAP32[$11 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2]);
                                                                                               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] & -17;
                                                                                               $1 = sqlite3InitOne($11, $1, $31, HEAPU16[$3 + 2 >> 1]);
                                                                                               HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] | 1;
                                                                                               HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 252;
                                                                                               break label$352;
                                                                                              }
                                                                                              HEAP32[$8 + 296 >> 2] = $11;
                                                                                              HEAP32[$8 + 312 >> 2] = 0;
                                                                                              HEAP32[$8 + 300 >> 2] = $31;
                                                                                              HEAP32[$8 + 304 >> 2] = $1;
                                                                                              $1 = HEAP32[$11 + 16 >> 2] + ($1 << 4) | 0;
                                                                                              HEAP32[$8 + 320 >> 2] = sqlite3BtreeLastPage(HEAP32[$1 + 4 >> 2]);
                                                                                              $1 = HEAP32[$1 >> 2];
                                                                                              HEAP32[$8 + 152 >> 2] = HEAP32[$3 + 16 >> 2];
                                                                                              HEAP32[$8 + 148 >> 2] = 8690;
                                                                                              HEAP32[$8 + 144 >> 2] = $1;
                                                                                              $6 = sqlite3MPrintf($11, 14405, $8 + 144 | 0);
                                                                                              if (!$6) {
                                                                                               $1 = 7;
                                                                                               break label$351;
                                                                                              }
                                                                                              HEAP8[$11 + 177 | 0] = 1;
                                                                                              HEAP32[$8 + 316 >> 2] = 0;
                                                                                              HEAP32[$8 + 308 >> 2] = 0;
                                                                                              $1 = sqlite3_exec($11, $6, 5, $8 + 296 | 0, 0);
                                                                                              $1 = $1 ? $1 : HEAP32[$8 + 308 >> 2];
                                                                                              if (!($1 | HEAP32[$8 + 316 >> 2])) {
                                                                                               $1 = sqlite3CorruptError(95070);
                                                                                              }
                                                                                              sqlite3DbFreeNN($11, $6);
                                                                                              HEAP8[$11 + 177 | 0] = 0;
                                                                                             }
                                                                                             if (!$1) {
                                                                                              break label$26;
                                                                                             }
                                                                                            }
                                                                                            sqlite3ResetAllSchemasOfConnection($11);
                                                                                            $6 = $1;
                                                                                            if (($1 | 0) != 7) {
                                                                                             break label$5;
                                                                                            }
                                                                                            break label$6;
                                                                                           }
                                                                                           HEAP8[$11 + 96 | 0] = HEAPU8[$11 + 96 | 0] + 1;
                                                                                           $6 = 0;
                                                                                           $1 = sqlite3_exec($11, HEAP32[$3 + 16 >> 2], 0, 0, 0);
                                                                                           HEAP8[$11 + 96 | 0] = HEAPU8[$11 + 96 | 0] - 1;
                                                                                           if (!$1) {
                                                                                            break label$10;
                                                                                           }
                                                                                           $6 = $1;
                                                                                           break label$5;
                                                                                          }
                                                                                          $6 = 0;
                                                                                          $1 = out2Prerelease($0, $3);
                                                                                          HEAP32[$8 + 296 >> 2] = 0;
                                                                                          $2 = sqlite3BtreeCreateTable(HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2], $8 + 296 | 0, HEAP32[$3 + 12 >> 2]);
                                                                                          if (!$2) {
                                                                                           $7 = HEAP32[$8 + 296 >> 2];
                                                                                           HEAP32[$1 >> 2] = $7;
                                                                                           HEAP32[$1 + 4 >> 2] = 0;
                                                                                           break label$10;
                                                                                          }
                                                                                          $6 = $2;
                                                                                          break label$5;
                                                                                         }
                                                                                         $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                         $2 = HEAP32[$1 + 36 >> 2];
                                                                                         if (HEAPU8[$1 | 0] == 1) {
                                                                                          sqlite3VdbeSorterReset($11, $2);
                                                                                          break label$10;
                                                                                         }
                                                                                         $6 = 0;
                                                                                         $1 = sqlite3BtreeClearTableOfCursor($2);
                                                                                         if (!$1) {
                                                                                          break label$10;
                                                                                         }
                                                                                         $6 = $1;
                                                                                         break label$5;
                                                                                        }
                                                                                        HEAP32[$8 + 296 >> 2] = 0;
                                                                                        HEAP32[$8 + 300 >> 2] = 0;
                                                                                        $1 = sqlite3BtreeClearTable(HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 8 >> 2] << 4) | 0) + 4 >> 2], HEAP32[$3 + 4 >> 2], $8 + 296 | 0);
                                                                                        $6 = HEAP32[$3 + 12 >> 2];
                                                                                        label$358: {
                                                                                         if (!$6) {
                                                                                          break label$358;
                                                                                         }
                                                                                         $10 = HEAP32[$8 + 296 >> 2];
                                                                                         $16 = $10;
                                                                                         $7 = HEAP32[$8 + 300 >> 2];
                                                                                         $17 = $7;
                                                                                         $7 = HEAP32[$0 + 40 >> 2];
                                                                                         $14 = $7;
                                                                                         $10 = HEAP32[$0 + 44 >> 2];
                                                                                         $7 = $10;
                                                                                         $10 = $17;
                                                                                         $12 = $10 + $7 | 0;
                                                                                         $4 = $16;
                                                                                         $9 = $14 + $4 | 0;
                                                                                         $12 = $9 >>> 0 < $14 >>> 0 ? $12 + 1 | 0 : $12;
                                                                                         HEAP32[$0 + 40 >> 2] = $9;
                                                                                         HEAP32[$0 + 44 >> 2] = $12;
                                                                                         if (($6 | 0) <= 0) {
                                                                                          break label$358;
                                                                                         }
                                                                                         $6 = Math_imul($6, 40) + $15 | 0;
                                                                                         $14 = $16;
                                                                                         $10 = $6;
                                                                                         $12 = HEAP32[$10 >> 2];
                                                                                         $10 = $12;
                                                                                         $7 = $14 + $10 | 0;
                                                                                         $4 = HEAP32[$6 + 4 >> 2];
                                                                                         $12 = $17;
                                                                                         $9 = $4 + $12 | 0;
                                                                                         $10 = $6;
                                                                                         HEAP32[$10 >> 2] = $7;
                                                                                         $9 = $7 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
                                                                                         HEAP32[$10 + 4 >> 2] = $9;
                                                                                        }
                                                                                        $6 = 0;
                                                                                        if (!$1) {
                                                                                         break label$10;
                                                                                        }
                                                                                        $6 = $1;
                                                                                        break label$5;
                                                                                       }
                                                                                       $6 = out2Prerelease($0, $3);
                                                                                       HEAP16[$6 + 16 >> 1] = 1;
                                                                                       label$359: {
                                                                                        if (HEAP32[$11 + 188 >> 2] > (HEAP32[$11 + 200 >> 2] + 1 | 0)) {
                                                                                         HEAP8[$0 + 146 | 0] = 2;
                                                                                         $5 = 6;
                                                                                         break label$359;
                                                                                        }
                                                                                        $1 = HEAP32[$3 + 12 >> 2];
                                                                                        HEAP32[$8 + 296 >> 2] = 0;
                                                                                        $5 = sqlite3BtreeDropTable(HEAP32[(HEAP32[$11 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2], HEAP32[$3 + 4 >> 2], $8 + 296 | 0);
                                                                                        HEAP16[$6 + 16 >> 1] = 4;
                                                                                        $2 = HEAP32[$8 + 296 >> 2];
                                                                                        $10 = $6;
                                                                                        HEAP32[$10 >> 2] = $2;
                                                                                        $9 = $2 >> 31;
                                                                                        HEAP32[$10 + 4 >> 2] = $9;
                                                                                        if ($5) {
                                                                                         break label$359;
                                                                                        }
                                                                                        if (!$2) {
                                                                                         break label$26;
                                                                                        }
                                                                                        sqlite3RootPageMoved($11, $1, $2, HEAP32[$3 + 4 >> 2]);
                                                                                        $41 = $1 + 1 | 0;
                                                                                        break label$26;
                                                                                       }
                                                                                       $6 = $5;
                                                                                       break label$5;
                                                                                      }
                                                                                      $6 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                      HEAP32[$8 + 256 >> 2] = HEAP32[$6 + 40 >> 2];
                                                                                      $2 = HEAP32[$3 + 16 >> 2];
                                                                                      HEAP8[$8 + 278 | 0] = $1 >>> 0 < 41 ? -1 : 0;
                                                                                      HEAP16[$8 + 276 >> 1] = $2;
                                                                                      HEAP32[$8 + 260 >> 2] = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15;
                                                                                      label$361: {
                                                                                       $1 = HEAP32[$6 + 36 >> 2];
                                                                                       $6 = sqlite3BtreePayloadSize($1);
                                                                                       if (($6 | 0) <= 0) {
                                                                                        $1 = sqlite3CorruptError(94818);
                                                                                        break label$361;
                                                                                       }
                                                                                       sqlite3VdbeMemInit($8 + 296 | 0, $11, 0);
                                                                                       $1 = sqlite3VdbeMemFromBtreeZeroOffset($1, $6, $8 + 296 | 0);
                                                                                       if ($1) {
                                                                                        break label$361;
                                                                                       }
                                                                                       $6 = 0;
                                                                                       $1 = sqlite3VdbeRecordCompareWithSkip(HEAP32[$8 + 308 >> 2], HEAP32[$8 + 304 >> 2], $8 + 256 | 0, 0);
                                                                                       sqlite3VdbeMemReleaseMalloc($8 + 296 | 0);
                                                                                       if (((HEAP8[$3 | 0] & 1 ? 0 - $1 | 0 : $1 + 1 | 0) | 0) > 0) {
                                                                                        break label$13;
                                                                                       }
                                                                                       break label$10;
                                                                                      }
                                                                                      $6 = $1;
                                                                                      break label$5;
                                                                                     }
                                                                                     $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                     if (!HEAPU8[$1 + 3 | 0]) {
                                                                                      break label$10;
                                                                                     }
                                                                                     $6 = 0;
                                                                                     $1 = sqlite3VdbeFinishMoveto($1);
                                                                                     if (!$1) {
                                                                                      break label$10;
                                                                                     }
                                                                                     $6 = $1;
                                                                                     break label$5;
                                                                                    }
                                                                                    label$363: {
                                                                                     $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                     $6 = sqlite3VdbeCursorRestore($1);
                                                                                     if ($6) {
                                                                                      break label$363;
                                                                                     }
                                                                                     if (!HEAPU8[$1 + 2 | 0]) {
                                                                                      HEAP32[$8 + 296 >> 2] = 0;
                                                                                      HEAP32[$8 + 300 >> 2] = 0;
                                                                                      $6 = sqlite3VdbeIdxRowid($11, HEAP32[$1 + 36 >> 2], $8 + 296 | 0);
                                                                                      if ($6) {
                                                                                       break label$363;
                                                                                      }
                                                                                      if (HEAPU8[$3 | 0] == 141) {
                                                                                       $6 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2];
                                                                                       HEAP8[$6 + 2 | 0] = 0;
                                                                                       $9 = HEAP32[$8 + 296 >> 2];
                                                                                       $16 = $9;
                                                                                       $10 = HEAP32[$8 + 300 >> 2];
                                                                                       HEAP32[$6 + 24 >> 2] = 0;
                                                                                       HEAP8[$6 + 3 | 0] = 1;
                                                                                       $9 = $6;
                                                                                       HEAP32[$9 + 56 >> 2] = $16;
                                                                                       HEAP32[$9 + 60 >> 2] = $10;
                                                                                       $2 = HEAP32[$3 + 16 >> 2];
                                                                                       HEAP32[$9 + 32 >> 2] = $1;
                                                                                       HEAP32[$9 + 8 >> 2] = $2;
                                                                                       break label$26;
                                                                                      }
                                                                                      $17 = out2Prerelease($0, $3);
                                                                                      $9 = HEAP32[$8 + 300 >> 2];
                                                                                      $10 = HEAP32[$8 + 296 >> 2];
                                                                                      $4 = $10;
                                                                                      $10 = $17;
                                                                                      HEAP32[$10 >> 2] = $4;
                                                                                      HEAP32[$10 + 4 >> 2] = $9;
                                                                                      break label$26;
                                                                                     }
                                                                                     sqlite3VdbeMemSetNull(Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0);
                                                                                     break label$26;
                                                                                    }
                                                                                    break label$5;
                                                                                   }
                                                                                   $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                   $6 = HEAP32[$1 + 36 >> 2];
                                                                                   HEAP32[$8 + 296 >> 2] = HEAP32[$1 + 40 >> 2];
                                                                                   $2 = HEAP32[$3 + 12 >> 2];
                                                                                   HEAP8[$8 + 318 | 0] = 0;
                                                                                   HEAP16[$8 + 316 >> 1] = $2;
                                                                                   HEAP32[$8 + 300 >> 2] = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15;
                                                                                   label$366: {
                                                                                    $2 = sqlite3BtreeIndexMoveto($6, $8 + 296 | 0, $8 + 256 | 0);
                                                                                    label$367: {
                                                                                     if ($2) {
                                                                                      break label$367;
                                                                                     }
                                                                                     if (!HEAP32[$8 + 256 >> 2]) {
                                                                                      $2 = sqlite3BtreeDelete($6, 4);
                                                                                      if ($2) {
                                                                                       break label$367;
                                                                                      }
                                                                                      break label$366;
                                                                                     }
                                                                                     if (!HEAPU16[$3 + 2 >> 1]) {
                                                                                      break label$366;
                                                                                     }
                                                                                     if (sqlite3WritableSchema($11)) {
                                                                                      break label$366;
                                                                                     }
                                                                                     $2 = 779;
                                                                                     sqlite3ReportError(779, 94613, 9721);
                                                                                    }
                                                                                    $6 = $2;
                                                                                    break label$5;
                                                                                   }
                                                                                   HEAP32[$1 + 24 >> 2] = 0;
                                                                                   HEAP32[$1 + 28 >> 2] = 0;
                                                                                   break label$26;
                                                                                  }
                                                                                  $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                  label$369: {
                                                                                   $1 = Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0;
                                                                                   if (!(HEAPU8[$1 + 17 | 0] & 4)) {
                                                                                    break label$369;
                                                                                   }
                                                                                   $6 = sqlite3VdbeMemExpandBlob($1);
                                                                                   if (!$6) {
                                                                                    break label$369;
                                                                                   }
                                                                                   break label$5;
                                                                                  }
                                                                                  $6 = 0;
                                                                                  $1 = sqlite3VdbeSorterWrite($2, $1);
                                                                                  if (!$1) {
                                                                                   break label$10;
                                                                                  }
                                                                                  $6 = $1;
                                                                                  break label$5;
                                                                                 }
                                                                                 $5 = HEAP32[$3 + 8 >> 2];
                                                                                 $2 = Math_imul($5, 40) + $15 | 0;
                                                                                 $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                 $6 = HEAPU16[$3 + 2 >> 1];
                                                                                 if ($6 & 1) {
                                                                                  $9 = HEAP32[$0 + 40 >> 2];
                                                                                  $4 = $9;
                                                                                  $10 = HEAP32[$0 + 44 >> 2];
                                                                                  $7 = $10;
                                                                                  $12 = $4 + 1 | 0;
                                                                                  $7 = $12 ? $7 : $7 + 1 | 0;
                                                                                  HEAP32[$0 + 40 >> 2] = $12;
                                                                                  HEAP32[$0 + 44 >> 2] = $7;
                                                                                 }
                                                                                 label$371: {
                                                                                  if (HEAPU8[$2 + 17 | 0] & 4) {
                                                                                   $6 = sqlite3VdbeMemExpandBlob($2);
                                                                                   if ($6) {
                                                                                    break label$371;
                                                                                   }
                                                                                   $6 = HEAPU16[$3 + 2 >> 1];
                                                                                  }
                                                                                  $2 = Math_imul($5, 40) + $15 | 0;
                                                                                  $7 = HEAP32[$2 + 12 >> 2];
                                                                                  $4 = $7 >> 31;
                                                                                  HEAP32[$8 + 304 >> 2] = $7;
                                                                                  HEAP32[$8 + 308 >> 2] = $4;
                                                                                  HEAP32[$8 + 296 >> 2] = HEAP32[$2 + 8 >> 2];
                                                                                  HEAP32[$8 + 316 >> 2] = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15;
                                                                                  HEAP16[$8 + 320 >> 1] = HEAP32[$3 + 16 >> 2];
                                                                                  $2 = 0;
                                                                                  $13 = HEAP32[$1 + 36 >> 2];
                                                                                  $5 = $6 & 138;
                                                                                  $2 = $6 & 16 ? HEAP32[$1 + 28 >> 2] : $2;
                                                                                  $6 = sqlite3BtreeInsert($13, $8 + 296 | 0, $5, $2);
                                                                                  HEAP32[$1 + 24 >> 2] = 0;
                                                                                  if (!$6) {
                                                                                   break label$26;
                                                                                  }
                                                                                 }
                                                                                 break label$5;
                                                                                }
                                                                                $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                                $2 = sqlite3BtreeNext(HEAP32[$1 + 36 >> 2]);
                                                                                break label$81;
                                                                               }
                                                                               $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                               $2 = sqlite3BtreePrevious(HEAP32[$1 + 36 >> 2]);
                                                                               break label$81;
                                                                              }
                                                                              $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                              $2 = sqlite3VdbeSorterNext($11, $1);
                                                                             }
                                                                             $6 = 0;
                                                                             HEAP32[$1 + 24 >> 2] = 0;
                                                                             if (($2 | 0) != 101) {
                                                                              if ($2) {
                                                                               $6 = $2;
                                                                               break label$5;
                                                                              }
                                                                              HEAP8[$1 + 2 | 0] = 0;
                                                                              $4 = (HEAPU16[$3 + 2 >> 1] << 2) + $0 | 0;
                                                                              $1 = $4 + 160 | 0;
                                                                              HEAP32[$1 >> 2] = HEAP32[$4 + 160 >> 2] + 1;
                                                                              break label$12;
                                                                             }
                                                                             HEAP8[$1 + 2 | 0] = 1;
                                                                             break label$11;
                                                                            }
                                                                            HEAP32[$0 + 168 >> 2] = HEAP32[$0 + 168 >> 2] + 1;
                                                                           }
                                                                           $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                           HEAP32[$8 + 296 >> 2] = 1;
                                                                           label$376: {
                                                                            if (HEAPU8[$1 | 0] == 1) {
                                                                             $6 = sqlite3VdbeSorterRewind($1, $8 + 296 | 0);
                                                                             break label$376;
                                                                            }
                                                                            $6 = sqlite3BtreeFirst(HEAP32[$1 + 36 >> 2], $8 + 296 | 0);
                                                                            HEAP32[$1 + 24 >> 2] = 0;
                                                                            HEAP8[$1 + 3 | 0] = 0;
                                                                           }
                                                                           if (!$6) {
                                                                            $2 = HEAP32[$8 + 296 >> 2];
                                                                            HEAP8[$1 + 2 | 0] = $2;
                                                                            $6 = 0;
                                                                            if ($2) {
                                                                             break label$13;
                                                                            }
                                                                            break label$10;
                                                                           }
                                                                           break label$5;
                                                                          }
                                                                          $1 = HEAP32[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 36 >> 2];
                                                                          $6 = sqlite3BtreeFirst($1, $8 + 296 | 0);
                                                                          if (!$6) {
                                                                           if (HEAP32[$8 + 296 >> 2]) {
                                                                            break label$55;
                                                                           }
                                                                           $4 = sqlite3BtreeRowCountEst($1);
                                                                           $16 = $4;
                                                                           $7 = i64toi32_i32$HIGH_BITS;
                                                                           $17 = $7;
                                                                           if (($7 | 0) < 0) {
                                                                            break label$26;
                                                                           }
                                                                           $10 = $17;
                                                                           if (HEAP32[$3 + 12 >> 2] > (sqlite3LogEst($16, $10) | 0)) {
                                                                            break label$55;
                                                                           }
                                                                           break label$26;
                                                                          }
                                                                          break label$5;
                                                                         }
                                                                         $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                         $5 = HEAP32[$2 + 36 >> 2];
                                                                         HEAP32[$8 + 296 >> 2] = 0;
                                                                         if (($1 | 0) == 137) {
                                                                          HEAP32[$2 + 28 >> 2] = -1;
                                                                          if (sqlite3BtreeCursorIsValidNN($5)) {
                                                                           break label$10;
                                                                          }
                                                                         }
                                                                         $6 = sqlite3BtreeLast($5, $8 + 296 | 0);
                                                                         $1 = HEAP32[$8 + 296 >> 2];
                                                                         HEAP32[$2 + 24 >> 2] = 0;
                                                                         HEAP8[$2 + 3 | 0] = 0;
                                                                         HEAP8[$2 + 2 | 0] = $1;
                                                                         if (!$6) {
                                                                          $6 = 0;
                                                                          if (HEAP32[$3 + 8 >> 2] <= 0) {
                                                                           break label$10;
                                                                          }
                                                                          if ($1) {
                                                                           break label$55;
                                                                          }
                                                                          break label$10;
                                                                         }
                                                                         break label$5;
                                                                        }
                                                                        $2 = HEAP32[$3 + 4 >> 2];
                                                                        $1 = HEAP32[HEAP32[$0 + 96 >> 2] + ($2 << 2) >> 2];
                                                                        if (!$1) {
                                                                         $1 = allocateCursor($0, $2, 1, 3);
                                                                         if (!$1) {
                                                                          break label$6;
                                                                         }
                                                                         HEAP8[$1 + 4 | 0] = 1;
                                                                         HEAP32[$1 + 28 >> 2] = 0;
                                                                         HEAP32[$1 + 36 >> 2] = 70988;
                                                                         HEAP8[$1 + 5 | 0] = HEAPU8[$1 + 5 | 0] | 8;
                                                                        }
                                                                        HEAP32[$1 + 24 >> 2] = 0;
                                                                        HEAP8[$1 + 2 | 0] = 1;
                                                                        if (HEAPU8[$1 | 0]) {
                                                                         break label$10;
                                                                        }
                                                                        sqlite3BtreeClearCursor(HEAP32[$1 + 36 >> 2]);
                                                                        break label$10;
                                                                       }
                                                                       $1 = out2Prerelease($0, $3);
                                                                       $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                       if (HEAPU8[$2 + 2 | 0]) {
                                                                        HEAP16[$1 + 16 >> 1] = 1;
                                                                        break label$10;
                                                                       }
                                                                       label$384: {
                                                                        label$385: {
                                                                         if (HEAPU8[$2 + 3 | 0]) {
                                                                          $10 = HEAP32[$2 + 56 >> 2];
                                                                          $16 = $10;
                                                                          $7 = HEAP32[$2 + 60 >> 2];
                                                                          break label$385;
                                                                         }
                                                                         if (HEAPU8[$2 | 0] == 2) {
                                                                          $6 = HEAP32[$2 + 36 >> 2];
                                                                          $2 = HEAP32[$6 >> 2];
                                                                          $6 = FUNCTION_TABLE[HEAP32[HEAP32[$2 >> 2] + 48 >> 2]]($6, $8 + 296 | 0) | 0;
                                                                          sqlite3VtabImportErrmsg($0, $2);
                                                                          if ($6) {
                                                                           break label$384;
                                                                          }
                                                                          $6 = 0;
                                                                          $7 = HEAP32[$8 + 296 >> 2];
                                                                          $16 = $7;
                                                                          $10 = HEAP32[$8 + 300 >> 2];
                                                                          $7 = $10;
                                                                          break label$385;
                                                                         }
                                                                         $6 = sqlite3VdbeCursorRestore($2);
                                                                         if ($6) {
                                                                          break label$384;
                                                                         }
                                                                         if (HEAPU8[$2 + 2 | 0]) {
                                                                          HEAP16[$1 + 16 >> 1] = 1;
                                                                          break label$26;
                                                                         }
                                                                         $6 = 0;
                                                                         $10 = sqlite3BtreeIntegerKey(HEAP32[$2 + 36 >> 2]);
                                                                         $16 = $10;
                                                                         $7 = i64toi32_i32$HIGH_BITS;
                                                                        }
                                                                        $10 = $1;
                                                                        HEAP32[$10 >> 2] = $16;
                                                                        HEAP32[$10 + 4 >> 2] = $7;
                                                                        break label$10;
                                                                       }
                                                                       break label$5;
                                                                      }
                                                                      $1 = out2Prerelease($0, $3);
                                                                      $6 = HEAP32[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 36 >> 2];
                                                                      $2 = sqlite3BtreePayloadSize($6);
                                                                      if ($2 >>> 0 > HEAPU32[$11 + 120 >> 2]) {
                                                                       break label$25;
                                                                      }
                                                                      $6 = sqlite3VdbeMemFromBtreeZeroOffset($6, $2, $1);
                                                                      if ($6) {
                                                                       break label$5;
                                                                      }
                                                                      $6 = 0;
                                                                      if (HEAP32[$3 + 12 >> 2] | !(HEAPU8[$1 + 17 | 0] & 64)) {
                                                                       break label$10;
                                                                      }
                                                                      if (!sqlite3VdbeMemMakeWriteable($1)) {
                                                                       break label$10;
                                                                      }
                                                                      break label$6;
                                                                     }
                                                                     $1 = sqlite3VdbeSorterRowkey(HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2], Math_imul(HEAP32[$3 + 8 >> 2], 40) + $15 | 0);
                                                                     if ($1) {
                                                                      $6 = $1;
                                                                      break label$5;
                                                                     }
                                                                     $6 = 0;
                                                                     HEAP32[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 12 >> 2] << 2) >> 2] + 24 >> 2] = 0;
                                                                     break label$10;
                                                                    }
                                                                    $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                    $6 = HEAP32[$3 + 16 >> 2];
                                                                    $24 = HEAP32[$3 + 12 >> 2];
                                                                    HEAP32[$8 + 296 >> 2] = 0;
                                                                    $6 = sqlite3VdbeSorterCompare($1, Math_imul($24, 40) + $15 | 0, $6, $8 + 296 | 0);
                                                                    switch (($6 ? 12 : HEAP32[$8 + 296 >> 2] ? 13 : 7) - 7 | 0) {
                                                                    case 0:
                                                                     break label$10;

                                                                    case 6:
                                                                     break label$13;

                                                                    case 5:
                                                                     break label$5;

                                                                    default:
                                                                     break label$3;
                                                                    }
                                                                   }
                                                                   $7 = HEAP32[$0 + 40 >> 2];
                                                                   $10 = HEAP32[$0 + 44 >> 2];
                                                                   sqlite3VdbeSetChanges($11, $7, $10);
                                                                   HEAP32[$0 + 40 >> 2] = 0;
                                                                   HEAP32[$0 + 44 >> 2] = 0;
                                                                   break label$10;
                                                                  }
                                                                  $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                  $5 = HEAP32[$3 + 8 >> 2];
                                                                  $2 = 0;
                                                                  label$390: {
                                                                   if (HEAPU8[$3 + 1 | 0] != 251) {
                                                                    $13 = 0;
                                                                    break label$390;
                                                                   }
                                                                   $13 = 0;
                                                                   if (!HEAP32[$11 + 248 >> 2]) {
                                                                    break label$390;
                                                                   }
                                                                   $13 = HEAP32[HEAP32[$11 + 16 >> 2] + (HEAP8[$1 + 1 | 0] << 4) >> 2];
                                                                   $2 = HEAP32[$3 + 16 >> 2];
                                                                   if (!(HEAPU8[$3 + 2 | 0] & 2) | !HEAPU8[$1 + 4 | 0]) {
                                                                    break label$390;
                                                                   }
                                                                   $10 = sqlite3BtreeIntegerKey(HEAP32[$1 + 36 >> 2]);
                                                                   HEAP32[$1 + 56 >> 2] = $10;
                                                                   $7 = i64toi32_i32$HIGH_BITS;
                                                                   HEAP32[$1 + 60 >> 2] = $7;
                                                                  }
                                                                  $6 = sqlite3BtreeDelete(HEAP32[$1 + 36 >> 2], HEAPU8[$3 + 2 | 0]);
                                                                  HEAP32[$1 + 24 >> 2] = 0;
                                                                  HEAP32[$1 + 28 >> 2] = 0;
                                                                  if ($6) {
                                                                   break label$5;
                                                                  }
                                                                  $6 = 0;
                                                                  if (!($5 & 1)) {
                                                                   break label$10;
                                                                  }
                                                                  $7 = HEAP32[$0 + 40 >> 2];
                                                                  $14 = $7;
                                                                  $10 = HEAP32[$0 + 44 >> 2];
                                                                  $9 = $14 + 1 | 0;
                                                                  $12 = $9 ? $10 : $10 + 1 | 0;
                                                                  HEAP32[$0 + 40 >> 2] = $9;
                                                                  HEAP32[$0 + 44 >> 2] = $12;
                                                                  $5 = HEAP32[$11 + 248 >> 2];
                                                                  if (HEAPU8[$2 + 28 | 0] & 128 | (!$5 | !$2)) {
                                                                   break label$10;
                                                                  }
                                                                  $12 = HEAP32[$1 + 56 >> 2];
                                                                  $14 = HEAP32[$1 + 60 >> 2];
                                                                  FUNCTION_TABLE[$5 | 0](HEAP32[$11 + 244 >> 2], 9, $13, HEAP32[$2 >> 2], $12, $14);
                                                                  break label$10;
                                                                 }
                                                                 $1 = HEAP32[$0 + 96 >> 2];
                                                                 $2 = HEAP32[$1 + (HEAP32[$3 + 8 >> 2] << 2) >> 2];
                                                                 $1 = HEAP32[(HEAP32[$3 + 4 >> 2] << 2) + $1 >> 2];
                                                                 $6 = HEAP32[$3 + 12 >> 2];
                                                                 if ($6) {
                                                                  $10 = Math_imul($6, 40) + $15 | 0;
                                                                  $14 = HEAP32[$10 >> 2];
                                                                  $16 = $14;
                                                                  $12 = HEAP32[$10 + 4 >> 2];
                                                                 } else {
                                                                  $16 = 0;
                                                                  $12 = 0;
                                                                 }
                                                                 $6 = 0;
                                                                 $1 = sqlite3BtreeTransferRow(HEAP32[$1 + 36 >> 2], HEAP32[$2 + 36 >> 2], $16, $12);
                                                                 if (!$1) {
                                                                  break label$10;
                                                                 }
                                                                 $6 = $1;
                                                                 break label$5;
                                                                }
                                                                $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                                $13 = HEAP32[$3 + 8 >> 2];
                                                                $10 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                                $12 = HEAP32[$10 >> 2];
                                                                $16 = $12;
                                                                $14 = HEAP32[$10 + 4 >> 2];
                                                                $17 = $14;
                                                                HEAP32[$8 + 304 >> 2] = $16;
                                                                HEAP32[$8 + 308 >> 2] = $14;
                                                                $5 = 0;
                                                                $20 = 0;
                                                                label$394: {
                                                                 if (HEAPU8[$3 + 1 | 0] != 251) {
                                                                  break label$394;
                                                                 }
                                                                 $20 = 0;
                                                                 if (!HEAP32[$11 + 248 >> 2]) {
                                                                  break label$394;
                                                                 }
                                                                 $5 = HEAP32[$3 + 16 >> 2];
                                                                 $20 = HEAP32[HEAP32[$11 + 16 >> 2] + (HEAP8[$1 + 1 | 0] << 4) >> 2];
                                                                }
                                                                $6 = HEAPU16[$3 + 2 >> 1];
                                                                if ($6 & 1) {
                                                                 $14 = HEAP32[$0 + 40 >> 2];
                                                                 $10 = $14;
                                                                 $12 = HEAP32[$0 + 44 >> 2];
                                                                 $9 = $12;
                                                                 $7 = $10 + 1 | 0;
                                                                 $9 = $7 ? $9 : $9 + 1 | 0;
                                                                 HEAP32[$0 + 40 >> 2] = $7;
                                                                 HEAP32[$0 + 44 >> 2] = $9;
                                                                }
                                                                if ($6 & 32) {
                                                                 HEAP32[$11 + 40 >> 2] = $16;
                                                                 $9 = $17;
                                                                 HEAP32[$11 + 44 >> 2] = $9;
                                                                }
                                                                $2 = Math_imul($13, 40) + $15 | 0;
                                                                HEAP32[$8 + 312 >> 2] = HEAP32[$2 + 8 >> 2];
                                                                HEAP32[$8 + 324 >> 2] = HEAP32[$2 + 12 >> 2];
                                                                $18 = 0;
                                                                $19 = 0;
                                                                $19 = $6 & 16 ? HEAP32[$1 + 28 >> 2] : $19;
                                                                $18 = HEAPU8[$2 + 17 | 0] & 4 ? HEAP32[Math_imul($13, 40) + $15 >> 2] : $18;
                                                                HEAP32[$8 + 296 >> 2] = 0;
                                                                HEAP32[$8 + 328 >> 2] = $18;
                                                                $6 = sqlite3BtreeInsert(HEAP32[$1 + 36 >> 2], $8 + 296 | 0, $6 & 138, $19);
                                                                HEAP32[$1 + 24 >> 2] = 0;
                                                                HEAP8[$1 + 3 | 0] = 0;
                                                                if (!$6) {
                                                                 if (!$5) {
                                                                  break label$26;
                                                                 }
                                                                 $9 = $17;
                                                                 FUNCTION_TABLE[HEAP32[$11 + 248 >> 2]](HEAP32[$11 + 244 >> 2], HEAPU16[$3 + 2 >> 1] & 4 ? 23 : 18, $20, HEAP32[$5 >> 2], $16, $9);
                                                                 break label$26;
                                                                }
                                                                break label$5;
                                                               }
                                                               HEAP32[$8 + 296 >> 2] = 0;
                                                               HEAP32[$8 + 300 >> 2] = 0;
                                                               HEAP32[$8 + 256 >> 2] = 0;
                                                               $18 = out2Prerelease($0, $3);
                                                               $13 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                               label$400: {
                                                                if (!(HEAPU8[$13 + 5 | 0] & 2)) {
                                                                 $2 = sqlite3BtreeLast(HEAP32[$13 + 36 >> 2], $8 + 256 | 0);
                                                                 if ($2) {
                                                                  break label$400;
                                                                 }
                                                                 label$402: {
                                                                  if (HEAP32[$8 + 256 >> 2]) {
                                                                   HEAP32[$8 + 296 >> 2] = 1;
                                                                   HEAP32[$8 + 300 >> 2] = 0;
                                                                   break label$402;
                                                                  }
                                                                  $9 = sqlite3BtreeIntegerKey(HEAP32[$13 + 36 >> 2]);
                                                                  $16 = $9;
                                                                  $10 = i64toi32_i32$HIGH_BITS;
                                                                  $17 = $10;
                                                                  HEAP32[$8 + 296 >> 2] = $16;
                                                                  HEAP32[$8 + 300 >> 2] = $10;
                                                                  $12 = $16;
                                                                  if (($12 | 0) == -1 & ($10 | 0) == 2147483647) {
                                                                   HEAP8[$13 + 5 | 0] = HEAPU8[$13 + 5 | 0] | 2;
                                                                   break label$402;
                                                                  }
                                                                  $12 = $17;
                                                                  $7 = $12;
                                                                  $4 = $16;
                                                                  $14 = $4 + 1 | 0;
                                                                  $7 = $14 ? $7 : $7 + 1 | 0;
                                                                  HEAP32[$8 + 296 >> 2] = $14;
                                                                  HEAP32[$8 + 300 >> 2] = $7;
                                                                 }
                                                                 $6 = 0;
                                                                }
                                                                $5 = HEAP32[$3 + 12 >> 2];
                                                                if ($5) {
                                                                 $2 = $15;
                                                                 $1 = HEAP32[$34 >> 2];
                                                                 if ($1) {
                                                                  while (1) {
                                                                   $2 = $1;
                                                                   $1 = HEAP32[$1 + 4 >> 2];
                                                                   if ($1) {
                                                                    continue;
                                                                   }
                                                                   break;
                                                                  }
                                                                  $2 = HEAP32[$2 + 16 >> 2];
                                                                 }
                                                                 $1 = Math_imul($5, 40) + $2 | 0;
                                                                 sqlite3VdbeMemIntegerify($1);
                                                                 $2 = 13;
                                                                 $7 = HEAP32[$1 >> 2];
                                                                 $16 = $7;
                                                                 $4 = HEAP32[$1 + 4 >> 2];
                                                                 $17 = $4;
                                                                 $12 = $16;
                                                                 if (($12 | 0) == -1 & ($4 | 0) == 2147483647 | HEAPU8[$13 + 5 | 0] & 2) {
                                                                  break label$400;
                                                                 }
                                                                 $12 = HEAP32[$8 + 296 >> 2];
                                                                 $21 = $12;
                                                                 $4 = HEAP32[$8 + 300 >> 2];
                                                                 $20 = $4;
                                                                 $4 = $17;
                                                                 $12 = $20;
                                                                 $9 = $16;
                                                                 $7 = $21;
                                                                 if (($4 | 0) >= ($12 | 0) & $9 >>> 0 >= $7 >>> 0 | ($12 | 0) < ($4 | 0)) {
                                                                  $9 = $17;
                                                                  $7 = $16;
                                                                  $10 = $7 + 1 | 0;
                                                                  $14 = $10 ? $9 : $9 + 1 | 0;
                                                                  $21 = $10;
                                                                  HEAP32[$8 + 296 >> 2] = $10;
                                                                  HEAP32[$8 + 300 >> 2] = $14;
                                                                  $20 = $14;
                                                                 }
                                                                 HEAP32[$1 >> 2] = $21;
                                                                 $14 = $20;
                                                                 HEAP32[$1 + 4 >> 2] = $14;
                                                                }
                                                                label$409: {
                                                                 if (HEAPU8[$13 + 5 | 0] & 2) {
                                                                  $1 = 0;
                                                                  while (1) {
                                                                   label$412: {
                                                                    sqlite3_randomness(8, $8 + 296 | 0);
                                                                    $14 = HEAP32[$8 + 296 >> 2];
                                                                    $9 = $14;
                                                                    $7 = HEAP32[$8 + 300 >> 2];
                                                                    $14 = $7 & 1073741823;
                                                                    $7 = $9;
                                                                    $10 = $14;
                                                                    $4 = $7 + 1 | 0;
                                                                    $10 = $4 ? $10 : $10 + 1 | 0;
                                                                    HEAP32[$8 + 296 >> 2] = $4;
                                                                    HEAP32[$8 + 300 >> 2] = $10;
                                                                    $2 = sqlite3BtreeTableMoveto(HEAP32[$13 + 36 >> 2], $4, $10, 0, $8 + 256 | 0);
                                                                    $5 = HEAP32[$8 + 256 >> 2];
                                                                    if ($2 | $5) {
                                                                     break label$412;
                                                                    }
                                                                    $6 = $1 >>> 0 < 99;
                                                                    $1 = $1 + 1 | 0;
                                                                    if ($6) {
                                                                     continue;
                                                                    }
                                                                   }
                                                                   break;
                                                                  }
                                                                  if ($2) {
                                                                   break label$409;
                                                                  }
                                                                  $6 = 0;
                                                                  if (!$5) {
                                                                   break label$409;
                                                                  }
                                                                 }
                                                                 HEAP32[$13 + 24 >> 2] = 0;
                                                                 HEAP8[$13 + 3 | 0] = 0;
                                                                 $7 = HEAP32[$8 + 300 >> 2];
                                                                 $10 = HEAP32[$8 + 296 >> 2];
                                                                 $4 = $10;
                                                                 $10 = $18;
                                                                 HEAP32[$10 >> 2] = $4;
                                                                 HEAP32[$10 + 4 >> 2] = $7;
                                                                 break label$10;
                                                                }
                                                                $2 = $2 ? $2 : 13;
                                                               }
                                                               $6 = $2;
                                                               break label$5;
                                                              }
                                                              $1 = out2Prerelease($0, $3);
                                                              $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                              $7 = HEAP32[$2 + 16 >> 2];
                                                              $16 = $7;
                                                              $10 = HEAP32[$2 + 20 >> 2];
                                                              $4 = $10;
                                                              $14 = $16;
                                                              $9 = $14 + 1 | 0;
                                                              $4 = $9 ? $4 : $4 + 1 | 0;
                                                              HEAP32[$2 + 16 >> 2] = $9;
                                                              HEAP32[$2 + 20 >> 2] = $4;
                                                              HEAP32[$1 >> 2] = $16;
                                                              $4 = $10;
                                                              HEAP32[$1 + 4 >> 2] = $4;
                                                              break label$10;
                                                             }
                                                             $1 = HEAP32[$3 + 12 >> 2];
                                                             break label$63;
                                                            }
                                                            $1 = HEAP32[$3 + 12 >> 2];
                                                            $2 = Math_imul($1, 40) + $15 | 0;
                                                            if (HEAPU8[$2 + 16 | 0] & 36) {
                                                             break label$63;
                                                            }
                                                            __memcpy($8 + 296 | 0, $2, 40);
                                                            applyAffinity($8 + 296 | 0, 67, $25);
                                                            if (!(HEAPU16[$8 + 312 >> 1] & 4)) {
                                                             break label$13;
                                                            }
                                                            $4 = HEAP32[$8 + 296 >> 2];
                                                            $16 = $4;
                                                            $14 = HEAP32[$8 + 300 >> 2];
                                                            $4 = $14;
                                                            break label$62;
                                                           }
                                                           $10 = Math_imul($1, 40) + $15 | 0;
                                                           $14 = HEAP32[$10 >> 2];
                                                           $16 = $14;
                                                           $4 = HEAP32[$10 + 4 >> 2];
                                                          }
                                                          $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                          $2 = HEAP32[$1 + 36 >> 2];
                                                          $6 = 0;
                                                          HEAP32[$8 + 292 >> 2] = 0;
                                                          $2 = sqlite3BtreeTableMoveto($2, $16, $4, 0, $8 + 292 | 0);
                                                          HEAP32[$1 + 24 >> 2] = 0;
                                                          HEAP32[$1 + 56 >> 2] = $16;
                                                          HEAP32[$1 + 60 >> 2] = $4;
                                                          HEAP16[$1 + 2 >> 1] = 0;
                                                          $5 = HEAP32[$8 + 292 >> 2];
                                                          HEAP32[$1 + 28 >> 2] = $5;
                                                          if ($5) {
                                                           if (HEAP32[$3 + 8 >> 2]) {
                                                            $6 = $2;
                                                            break label$13;
                                                           }
                                                           $2 = sqlite3CorruptError(93552);
                                                          }
                                                          if (!$2) {
                                                           break label$10;
                                                          }
                                                          $6 = $2;
                                                          break label$5;
                                                         }
                                                         if (HEAP32[$3 + 16 >> 2] <= HEAPU16[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 6 >> 1]) {
                                                          break label$10;
                                                         }
                                                        }
                                                        $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                        $2 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                        HEAP32[$8 + 300 >> 2] = $2;
                                                        $6 = HEAP32[$3 + 16 >> 2];
                                                        HEAP16[$8 + 316 >> 1] = $6;
                                                        label$415: {
                                                         if ($6 & 65535) {
                                                          $6 = HEAP32[$1 + 40 >> 2];
                                                          HEAP8[$8 + 318 | 0] = 0;
                                                          HEAP32[$8 + 296 >> 2] = $6;
                                                          $6 = sqlite3BtreeIndexMoveto(HEAP32[$1 + 36 >> 2], $8 + 296 | 0, $1 + 28 | 0);
                                                          break label$415;
                                                         }
                                                         if (HEAPU8[$2 + 17 | 0] & 4) {
                                                          if (sqlite3VdbeMemExpandBlob($2)) {
                                                           break label$6;
                                                          }
                                                         }
                                                         $2 = sqlite3VdbeAllocUnpackedRecord(HEAP32[$1 + 40 >> 2]);
                                                         if (!$2) {
                                                          break label$6;
                                                         }
                                                         $6 = HEAP32[$8 + 300 >> 2];
                                                         sqlite3VdbeRecordUnpack(HEAP32[$1 + 40 >> 2], HEAP32[$6 + 12 >> 2], HEAP32[$6 + 8 >> 2], $2);
                                                         HEAP8[$2 + 22 | 0] = 0;
                                                         $6 = sqlite3BtreeIndexMoveto(HEAP32[$1 + 36 >> 2], $2, $1 + 28 | 0);
                                                         sqlite3DbFreeNN($11, $2);
                                                        }
                                                        if (!$6) {
                                                         HEAP32[$1 + 24 >> 2] = 0;
                                                         HEAP8[$1 + 3 | 0] = 0;
                                                         $6 = HEAP32[$1 + 28 >> 2];
                                                         HEAP8[$1 + 2 | 0] = ($6 | 0) != 0;
                                                         $2 = HEAPU8[$3 | 0];
                                                         if (($2 | 0) == 28) {
                                                          if (!$6) {
                                                           break label$55;
                                                          }
                                                          break label$26;
                                                         }
                                                         if ($6) {
                                                          break label$55;
                                                         }
                                                         label$420: {
                                                          switch ($2 - 25 | 0) {
                                                          case 1:
                                                           $1 = 0;
                                                           $5 = HEAP32[$8 + 300 >> 2];
                                                           $2 = HEAPU16[$8 + 316 >> 1];
                                                           while (1) {
                                                            if (($1 | 0) == ($2 | 0)) {
                                                             break label$26;
                                                            }
                                                            $6 = Math_imul($1, 40);
                                                            $1 = $1 + 1 | 0;
                                                            if (!(HEAP8[($6 + $5 | 0) + 16 | 0] & 1)) {
                                                             continue;
                                                            }
                                                            break;
                                                           }
                                                           ;
                                                           break label$55;

                                                          case 0:
                                                           break label$420;

                                                          default:
                                                           break label$26;
                                                          }
                                                         }
                                                         HEAP16[$1 + 6 >> 1] = HEAP32[$3 + 16 >> 2];
                                                         break label$26;
                                                        }
                                                        break label$5;
                                                       }
                                                       if (!HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2]) {
                                                        break label$12;
                                                       }
                                                       break label$10;
                                                      }
                                                      $2 = HEAP32[$3 + 8 >> 2];
                                                      $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                      $5 = HEAPU16[$1 + 6 >> 1];
                                                      if (($2 | 0) > ($5 | 0)) {
                                                       HEAP16[$1 + 6 >> 1] = $2;
                                                       break label$10;
                                                      }
                                                      $2 = HEAP32[$3 + 12 >> 2];
                                                      if (($5 | 0) <= ($2 | 0)) {
                                                       break label$10;
                                                      }
                                                      HEAP16[$1 + 6 >> 1] = $2;
                                                      break label$10;
                                                     }
                                                     $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 24 >> 2] << 2) >> 2];
                                                     if (!sqlite3BtreeCursorIsValidNN(HEAP32[$2 + 36 >> 2])) {
                                                      break label$10;
                                                     }
                                                     $13 = $3 + 20 | 0;
                                                     $1 = HEAP32[$3 + 4 >> 2];
                                                     HEAP32[$8 + 296 >> 2] = HEAP32[$2 + 40 >> 2];
                                                     $6 = HEAP32[$3 + 36 >> 2];
                                                     HEAP8[$8 + 318 | 0] = 0;
                                                     HEAP16[$8 + 316 >> 1] = $6;
                                                     $6 = HEAP32[$3 + 32 >> 2];
                                                     HEAP32[$8 + 256 >> 2] = 0;
                                                     HEAP32[$8 + 300 >> 2] = Math_imul($6, 40) + $15;
                                                     label$424: {
                                                      label$425: {
                                                       while (1) {
                                                        $5 = sqlite3VdbeIdxKeyCompare($11, $2, $8 + 296 | 0, $8 + 256 | 0);
                                                        if ($5) {
                                                         break label$424;
                                                        }
                                                        $6 = 0;
                                                        $5 = HEAP32[$8 + 256 >> 2];
                                                        if (($5 | 0) > 0) {
                                                         break label$425;
                                                        }
                                                        if (!$5) {
                                                         $13 = $3;
                                                         break label$425;
                                                        }
                                                        if (($1 | 0) <= 0) {
                                                         break label$40;
                                                        }
                                                        $1 = $1 - 1 | 0;
                                                        $5 = sqlite3BtreeNext(HEAP32[$2 + 36 >> 2]);
                                                        if (!$5) {
                                                         continue;
                                                        }
                                                        break;
                                                       }
                                                       if (($5 | 0) != 101) {
                                                        break label$424;
                                                       }
                                                      }
                                                      $3 = $13;
                                                      break label$13;
                                                     }
                                                     $6 = $5;
                                                     break label$5;
                                                    }
                                                    $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                    HEAP32[$2 + 24 >> 2] = 0;
                                                    HEAP16[$2 + 2 >> 1] = 0;
                                                    label$428: {
                                                     label$429: {
                                                      label$430: {
                                                       label$431: {
                                                        if (HEAPU8[$2 + 4 | 0]) {
                                                         $5 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                                                         $19 = HEAPU16[$5 + 16 >> 1];
                                                         if (($19 & 46) == 2) {
                                                          applyNumericAffinity($5, 0);
                                                         }
                                                         $4 = sqlite3VdbeIntValue($5);
                                                         $16 = $4;
                                                         $14 = i64toi32_i32$HIGH_BITS;
                                                         $17 = $14;
                                                         $18 = HEAPU16[$5 + 16 >> 1];
                                                         HEAP16[$5 + 16 >> 1] = $19;
                                                         label$434: {
                                                          if ($18 & 36) {
                                                           break label$434;
                                                          }
                                                          if (!($18 & 8)) {
                                                           if ($18 & 1 | $1 >>> 0 >= 22) {
                                                            break label$13;
                                                           }
                                                           $19 = 0;
                                                           $6 = sqlite3BtreeLast(HEAP32[$2 + 36 >> 2], $8 + 256 | 0);
                                                           if ($6) {
                                                            break label$5;
                                                           }
                                                           break label$430;
                                                          }
                                                          $14 = $17;
                                                          $6 = sqlite3IntFloatCompare($16, $14, HEAPF64[$5 >> 3]);
                                                          if (($6 | 0) > 0) {
                                                           $1 = $1 & 254;
                                                           break label$434;
                                                          }
                                                          $1 = (!($1 & 1) & ($6 | 0) != 0) + $1 | 0;
                                                         }
                                                         $5 = 0;
                                                         $14 = $17;
                                                         $6 = sqlite3BtreeTableMoveto(HEAP32[$2 + 36 >> 2], $16, $14, 0, $8 + 256 | 0);
                                                         HEAP32[$2 + 56 >> 2] = $16;
                                                         HEAP32[$2 + 60 >> 2] = $14;
                                                         if (!$6) {
                                                          break label$431;
                                                         }
                                                         break label$5;
                                                        }
                                                        $19 = 1;
                                                        $6 = HEAP32[$2 + 36 >> 2];
                                                        $13 = sqlite3BtreeCursorHasHint($6);
                                                        $5 = HEAP32[$2 + 40 >> 2];
                                                        $18 = HEAP32[$3 + 16 >> 2];
                                                        HEAP8[$8 + 318 | 0] = $1 & 1 ? -1 : 1;
                                                        HEAP16[$8 + 316 >> 1] = $18;
                                                        HEAP32[$8 + 296 >> 2] = $5;
                                                        $5 = HEAP32[$3 + 12 >> 2];
                                                        HEAP8[$8 + 322 | 0] = 0;
                                                        HEAP32[$8 + 300 >> 2] = Math_imul($5, 40) + $15;
                                                        $6 = sqlite3BtreeIndexMoveto($6, $8 + 296 | 0, $8 + 256 | 0);
                                                        if ($6) {
                                                         break label$5;
                                                        }
                                                        $5 = ($13 | 0) != 0;
                                                        if (!$13) {
                                                         break label$431;
                                                        }
                                                        if (!HEAPU8[$8 + 322 | 0]) {
                                                         break label$430;
                                                        }
                                                       }
                                                       $6 = HEAP32[$8 + 256 >> 2];
                                                       if ($1 >>> 0 >= 22) {
                                                        if (($1 | 0) != 23 | $6 ? ($6 | 0) >= 0 : 0) {
                                                         break label$428;
                                                        }
                                                        $6 = sqlite3BtreeNext(HEAP32[$2 + 36 >> 2]);
                                                        if (!$6) {
                                                         break label$428;
                                                        }
                                                        if (($6 | 0) != 101) {
                                                         break label$5;
                                                        }
                                                        break label$55;
                                                       }
                                                       if (!(($1 | 0) != 20 | $6 ? ($6 | 0) <= 0 : 0)) {
                                                        $6 = sqlite3BtreePrevious(HEAP32[$2 + 36 >> 2]);
                                                        if (!$6) {
                                                         break label$428;
                                                        }
                                                        if (($6 | 0) != 101) {
                                                         break label$5;
                                                        }
                                                        break label$55;
                                                       }
                                                       $1 = sqlite3BtreeEof(HEAP32[$2 + 36 >> 2]);
                                                       break label$429;
                                                      }
                                                      $5 = $19;
                                                      $1 = HEAP32[$8 + 256 >> 2];
                                                     }
                                                     if ($1) {
                                                      break label$55;
                                                     }
                                                    }
                                                    $3 = Math_imul($5, 20) + $3 | 0;
                                                    break label$26;
                                                   }
                                                   $6 = 0;
                                                   break label$13;
                                                  }
                                                  sqlite3VdbeFreeCursor($0, HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2]);
                                                  HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] = 0;
                                                  break label$10;
                                                 }
                                                 $1 = allocateCursor($0, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 12 >> 2], 3);
                                                 if (!$1) {
                                                  break label$6;
                                                 }
                                                 HEAP8[$1 + 2 | 0] = 1;
                                                 $2 = HEAP32[$3 + 8 >> 2];
                                                 HEAP32[$1 + 36 >> 2] = 70988;
                                                 HEAP8[$1 + 4 | 0] = 1;
                                                 HEAP32[$1 + 28 >> 2] = $2;
                                                 break label$10;
                                                }
                                                $1 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                                $14 = HEAP32[$1 + 16 >> 2];
                                                $16 = $14;
                                                $4 = HEAP32[$1 + 20 >> 2];
                                                $10 = $16;
                                                $7 = $10 + 1 | 0;
                                                $9 = $7 ? $4 : $4 + 1 | 0;
                                                HEAP32[$1 + 16 >> 2] = $7;
                                                HEAP32[$1 + 20 >> 2] = $9;
                                                if (!($4 | $16)) {
                                                 break label$13;
                                                }
                                                break label$10;
                                               }
                                               $1 = allocateCursor($0, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2], 1);
                                               if (!$1) {
                                                break label$6;
                                               }
                                               HEAP32[$1 + 40 >> 2] = HEAP32[$3 + 16 >> 2];
                                               $6 = 0;
                                               $1 = sqlite3VdbeSorterInit($11, HEAP32[$3 + 12 >> 2], $1);
                                               if (!$1) {
                                                break label$10;
                                               }
                                               $6 = $1;
                                               break label$5;
                                              }
                                              $1 = HEAP32[$3 + 12 >> 2];
                                              if (($1 | 0) > 0) {
                                               $1 = Math_imul($1, 40) + $15 | 0;
                                               HEAP32[$1 + 8 >> 2] = 29623;
                                               HEAP32[$1 + 12 >> 2] = 0;
                                              }
                                              label$440: {
                                               $6 = HEAP32[$3 + 4 >> 2];
                                               $1 = HEAP32[HEAP32[$0 + 96 >> 2] + ($6 << 2) >> 2];
                                               if (!(!(!$1 | HEAPU8[$1 + 5 | 0] & 8) & HEAP32[$3 + 8 >> 2] <= HEAP16[$1 + 52 >> 1])) {
                                                $1 = allocateCursor($0, $6, HEAP32[$3 + 8 >> 2], 0);
                                                if (!$1) {
                                                 break label$6;
                                                }
                                                HEAP8[$1 + 5 | 0] = HEAPU8[$1 + 5 | 0] | 1;
                                                $2 = $1 + 8 | 0;
                                                $6 = sqlite3BtreeOpen(HEAP32[$11 >> 2], 0, $11, $2, HEAPU16[$3 + 2 >> 1] | 5, 1054);
                                                if ($6) {
                                                 break label$5;
                                                }
                                                $6 = sqlite3BtreeBeginTrans(HEAP32[$1 + 8 >> 2], 1, 0);
                                                if (!$6) {
                                                 $5 = HEAP32[$3 + 16 >> 2];
                                                 HEAP32[$1 + 40 >> 2] = $5;
                                                 label$444: {
                                                  if ($5) {
                                                   $13 = 0;
                                                   $6 = sqlite3BtreeCreateTable(HEAP32[$1 + 8 >> 2], $1 + 48 | 0, HEAPU16[$3 + 2 >> 1] | 2);
                                                   if ($6) {
                                                    break label$444;
                                                   }
                                                   $6 = sqlite3BtreeCursor(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 48 >> 2], 4, $5, HEAP32[$1 + 36 >> 2]);
                                                   break label$444;
                                                  }
                                                  $13 = 1;
                                                  HEAP32[$1 + 48 >> 2] = 1;
                                                  $6 = sqlite3BtreeCursor(HEAP32[$1 + 8 >> 2], 1, 4, 0, HEAP32[$1 + 36 >> 2]);
                                                 }
                                                 HEAP8[$1 + 4 | 0] = $13;
                                                }
                                                HEAP8[$1 + 5 | 0] = HEAPU8[$1 + 5 | 0] & 251 | (HEAPU16[$3 + 2 >> 1] != 8) << 2;
                                                if (!$6) {
                                                 break label$440;
                                                }
                                                sqlite3BtreeClose(HEAP32[$1 + 8 >> 2]);
                                                break label$5;
                                               }
                                               HEAP32[$1 + 24 >> 2] = 0;
                                               HEAP32[$1 + 16 >> 2] = 0;
                                               HEAP32[$1 + 20 >> 2] = 0;
                                               $6 = sqlite3BtreeClearTable(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 48 >> 2], 0);
                                               if (!$6) {
                                                break label$440;
                                               }
                                               break label$5;
                                              }
                                              HEAP8[$1 + 2 | 0] = 1;
                                              break label$26;
                                             }
                                             $6 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 8 >> 2] << 2) >> 2];
                                             $1 = allocateCursor($0, HEAP32[$3 + 4 >> 2], HEAP16[$6 + 52 >> 1], 0);
                                             if (!$1) {
                                              break label$6;
                                             }
                                             HEAP8[$1 + 2 | 0] = 1;
                                             $2 = HEAPU8[$1 + 5 | 0] | 1;
                                             HEAP8[$1 + 5 | 0] = $2;
                                             HEAP32[$1 + 40 >> 2] = HEAP32[$6 + 40 >> 2];
                                             HEAP8[$1 + 4 | 0] = HEAPU8[$6 + 4 | 0];
                                             HEAP32[$1 + 48 >> 2] = HEAP32[$6 + 48 >> 2];
                                             $2 = HEAPU8[$6 + 5 | 0] & 4 | $2 & -5;
                                             HEAP8[$1 + 5 | 0] = $2;
                                             $5 = HEAP32[$6 + 8 >> 2];
                                             HEAP8[$1 + 5 | 0] = $2 | 8;
                                             HEAP32[$1 + 8 >> 2] = $5;
                                             HEAP8[$6 + 5 | 0] = HEAPU8[$6 + 5 | 0] | 8;
                                             $6 = sqlite3BtreeCursor(HEAP32[$1 + 8 >> 2], HEAP32[$1 + 48 >> 2], 4, HEAP32[$1 + 40 >> 2], HEAP32[$1 + 36 >> 2]);
                                             break label$10;
                                            }
                                            $2 = HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2];
                                            if (!$2 | HEAP32[$2 + 48 >> 2] != HEAP32[$3 + 8 >> 2]) {
                                             break label$47;
                                            }
                                            sqlite3BtreeClearCursor(HEAP32[$2 + 36 >> 2]);
                                            $5 = $6;
                                            break label$46;
                                           }
                                           if ((HEAPU8[$0 + 150 | 0] & 3) == 1) {
                                            $6 = 516;
                                            break label$5;
                                           }
                                           $13 = HEAP32[$3 + 12 >> 2];
                                           $19 = HEAP32[$11 + 16 >> 2] + ($13 << 4) | 0;
                                           $18 = HEAP32[$19 + 4 >> 2];
                                           $2 = HEAPU16[$3 + 2 >> 1];
                                           $6 = HEAP32[$3 + 8 >> 2];
                                           $5 = 0;
                                           label$447: {
                                            if (($1 | 0) != 113) {
                                             break label$447;
                                            }
                                            $5 = $2 & 8 | 4;
                                            $1 = HEAPU8[HEAP32[$19 + 12 >> 2] + 76 | 0];
                                            if ($1 >>> 0 >= HEAPU8[$0 + 147 | 0]) {
                                             break label$447;
                                            }
                                            HEAP8[$0 + 147 | 0] = $1;
                                           }
                                           if ($2 & 16) {
                                            $1 = Math_imul($6, 40) + $15 | 0;
                                            sqlite3VdbeMemIntegerify($1);
                                            $6 = HEAP32[$1 >> 2];
                                           }
                                           $4 = HEAP32[$3 + 4 >> 2];
                                           $19 = HEAPU8[$3 + 1 | 0];
                                           label$449: {
                                            if (($19 | 0) != 253) {
                                             $1 = 0;
                                             $2 = 0;
                                             if (($19 | 0) != 248) {
                                              break label$449;
                                             }
                                             $1 = HEAP32[$3 + 16 >> 2];
                                             $2 = HEAPU16[$1 + 8 >> 1];
                                             break label$449;
                                            }
                                            $1 = 0;
                                            $2 = HEAP32[$3 + 16 >> 2];
                                           }
                                           $2 = allocateCursor($0, $4, $2, 0);
                                           if (!$2) {
                                            break label$6;
                                           }
                                           HEAP8[$2 + 2 | 0] = 1;
                                           HEAP8[$2 + 1 | 0] = $13;
                                           HEAP32[$2 + 48 >> 2] = $6;
                                           HEAP8[$2 + 5 | 0] = HEAPU8[$2 + 5 | 0] | 4;
                                           $5 = sqlite3BtreeCursor($18, $6, $5, $1, HEAP32[$2 + 36 >> 2]);
                                           HEAP32[$2 + 40 >> 2] = $1;
                                           HEAP8[$2 + 4 | 0] = HEAPU8[$3 + 1 | 0] != 248;
                                          }
                                          sqlite3BtreeCursorHintFlags(HEAP32[$2 + 36 >> 2], HEAPU16[$3 + 2 >> 1] & 3);
                                          $6 = 0;
                                          if (!$5) {
                                           break label$10;
                                          }
                                          $6 = $5;
                                          break label$5;
                                         }
                                         $6 = HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0;
                                         $1 = sqlite3BtreeUpdateMeta(HEAP32[$6 + 4 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2]);
                                         label$451: {
                                          label$452: {
                                           switch (HEAP32[$3 + 8 >> 2] - 1 | 0) {
                                           case 0:
                                            HEAP32[HEAP32[$6 + 12 >> 2] >> 2] = HEAP32[$3 + 12 >> 2] - HEAPU16[$3 + 2 >> 1];
                                            HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] | 1;
                                            sqlite3FkClearTriggerCache($11, HEAP32[$3 + 4 >> 2]);
                                            break label$451;

                                           case 1:
                                            break label$452;

                                           default:
                                            break label$451;
                                           }
                                          }
                                          HEAP8[HEAP32[$6 + 12 >> 2] + 76 | 0] = HEAP32[$3 + 12 >> 2];
                                         }
                                         if (HEAP32[$3 + 4 >> 2] == 1) {
                                          sqlite3ExpirePreparedStatements($11, 0);
                                          HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 252;
                                         }
                                         $6 = 0;
                                         if (!$1) {
                                          break label$10;
                                         }
                                         $6 = $1;
                                         break label$5;
                                        }
                                        sqlite3BtreeGetMeta(HEAP32[(HEAP32[$11 + 16 >> 2] + (HEAP32[$3 + 4 >> 2] << 4) | 0) + 4 >> 2], HEAP32[$3 + 12 >> 2], $8 + 296 | 0);
                                        $17 = out2Prerelease($0, $3);
                                        $9 = HEAP32[$8 + 296 >> 2];
                                        $10 = $9 >> 31;
                                        $4 = $9;
                                        $9 = $17;
                                        HEAP32[$9 >> 2] = $4;
                                        HEAP32[$9 + 4 >> 2] = $10;
                                        break label$10;
                                       }
                                       HEAP32[$8 + 296 >> 2] = 0;
                                       label$455: {
                                        $2 = HEAP32[$3 + 8 >> 2];
                                        if (!$2) {
                                         break label$455;
                                        }
                                        $9 = HEAP32[$11 + 36 >> 2];
                                        $17 = $9;
                                        $10 = HEAP32[$11 + 32 >> 2];
                                        $16 = $10;
                                        $4 = $10;
                                        $10 = $9 & 2;
                                        if (!($4 & 1048576 | $10)) {
                                         break label$455;
                                        }
                                        $4 = 0;
                                        $9 = $16;
                                        $6 = $4 | $9 & 1048576 ? 8 : 11;
                                        break label$5;
                                       }
                                       $5 = HEAP32[$11 + 16 >> 2];
                                       $13 = HEAP32[$3 + 4 >> 2];
                                       $1 = HEAP32[($5 + ($13 << 4) | 0) + 4 >> 2];
                                       label$456: {
                                        if ($1) {
                                         $24 = sqlite3BtreeBeginTrans($1, $2, $8 + 296 | 0);
                                         if ($24) {
                                          if (($24 & 255) != 5) {
                                           $6 = $24;
                                           break label$5;
                                          }
                                          HEAP32[$0 + 36 >> 2] = $24;
                                          HEAP32[$0 + 32 >> 2] = ($3 - $22 | 0) / 20;
                                          break label$14;
                                         }
                                         if (!(HEAPU8[$0 + 150 | 0] & 32) | !HEAP32[$3 + 8 >> 2] | (HEAP32[$11 + 188 >> 2] < 2 ? HEAPU8[$11 + 85 | 0] : 0)) {
                                          break label$456;
                                         }
                                         $6 = HEAP32[$0 + 48 >> 2];
                                         if (!$6) {
                                          $6 = HEAP32[$11 + 504 >> 2] + 1 | 0;
                                          HEAP32[$11 + 504 >> 2] = $6;
                                          $6 = HEAP32[$11 + 500 >> 2] + $6 | 0;
                                          HEAP32[$0 + 48 >> 2] = $6;
                                         }
                                         $6 = sqlite3VtabSavepoint($11, 0, $6 - 1 | 0);
                                         if (!$6) {
                                          $6 = sqlite3BtreeBeginStmt($1, HEAP32[$0 + 48 >> 2]);
                                         }
                                         $9 = HEAP32[$11 + 516 >> 2];
                                         $4 = HEAP32[$11 + 512 >> 2];
                                         HEAP32[$0 + 72 >> 2] = $4;
                                         HEAP32[$0 + 76 >> 2] = $9;
                                         $4 = HEAP32[$11 + 524 >> 2];
                                         $9 = HEAP32[$11 + 520 >> 2];
                                         HEAP32[$0 + 80 >> 2] = $9;
                                         HEAP32[$0 + 84 >> 2] = $4;
                                        }
                                        if ($6) {
                                         break label$5;
                                        }
                                       }
                                       if (!HEAPU16[$3 + 2 >> 1] | HEAP32[$8 + 296 >> 2] == HEAP32[$3 + 12 >> 2] & HEAP32[HEAP32[(($13 << 4) + $5 | 0) + 12 >> 2] + 4 >> 2] == HEAP32[$3 + 16 >> 2]) {
                                        break label$26;
                                       }
                                       sqlite3DbFree($11, HEAP32[$31 >> 2]);
                                       HEAP32[$31 >> 2] = sqlite3DbStrDup($11, 15749);
                                       $1 = HEAP32[$3 + 4 >> 2];
                                       if (HEAP32[HEAP32[(HEAP32[$11 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] >> 2] != HEAP32[$8 + 296 >> 2]) {
                                        sqlite3ResetOneSchema($11, $1);
                                       }
                                       HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 236 | 1;
                                       $6 = 17;
                                       break label$5;
                                      }
                                      $1 = HEAP32[$3 + 8 >> 2];
                                      $15 = HEAP32[$3 + 4 >> 2];
                                      label$465: {
                                       if (($15 | 0) != HEAPU8[$11 + 85 | 0]) {
                                        label$467: {
                                         if ($1) {
                                          sqlite3RollbackAll($11, 516);
                                          $1 = 1;
                                          break label$467;
                                         }
                                         if (!(!$15 | HEAP32[$11 + 192 >> 2] <= 0)) {
                                          $4 = 5;
                                          $6 = 4057;
                                          break label$465;
                                         }
                                         $24 = sqlite3VdbeCheckFk($0, 1);
                                         if ($24) {
                                          break label$14;
                                         }
                                         $1 = $15;
                                        }
                                        HEAP8[$11 + 85 | 0] = $1;
                                        $24 = 5;
                                        if ((sqlite3VdbeHalt($0) | 0) == 5) {
                                         HEAP32[$0 + 32 >> 2] = ($3 - $22 | 0) / 20;
                                         HEAP8[$11 + 85 | 0] = 1 - $15;
                                         break label$15;
                                        }
                                        sqlite3CloseSavepoints($11);
                                        $24 = HEAP32[$0 + 36 >> 2] ? 1 : 101;
                                        break label$14;
                                       }
                                       $4 = 1;
                                       $6 = $15 ? $1 ? 12273 : 12232 : 9950;
                                      }
                                      sqlite3VdbeError($0, $6, 0);
                                      $1 = $4;
                                      $6 = $1;
                                      break label$5;
                                     }
                                     $5 = HEAP32[$3 + 16 >> 2];
                                     $2 = 0;
                                     $1 = $39;
                                     label$471: {
                                      $18 = HEAP32[$3 + 4 >> 2];
                                      if (!$18) {
                                       if (HEAP32[$11 + 192 >> 2] > 0) {
                                        sqlite3VdbeError($0, 3952, 0);
                                        $6 = 5;
                                        break label$5;
                                       }
                                       $2 = sqlite3Strlen30($5);
                                       $1 = sqlite3VtabSavepoint($11, 0, HEAP32[$11 + 500 >> 2] + HEAP32[$11 + 504 >> 2] | 0);
                                       if ($1) {
                                        $6 = $1;
                                        break label$5;
                                       }
                                       $1 = sqlite3DbMallocRawNN($11, $2 + 33 | 0, 0);
                                       if (!$1) {
                                        break label$471;
                                       }
                                       $13 = $1 + 32 | 0;
                                       HEAP32[$1 >> 2] = $13;
                                       __memcpy($13, $5, $2 + 1 | 0);
                                       label$475: {
                                        if (HEAPU8[$11 + 85 | 0]) {
                                         HEAP8[$11 + 93 | 0] = 1;
                                         HEAP8[$11 + 85 | 0] = 0;
                                         break label$475;
                                        }
                                        HEAP32[$11 + 500 >> 2] = HEAP32[$11 + 500 >> 2] + 1;
                                       }
                                       HEAP32[$1 + 24 >> 2] = HEAP32[$11 + 488 >> 2];
                                       HEAP32[$11 + 488 >> 2] = $1;
                                       $9 = HEAP32[$11 + 516 >> 2];
                                       $4 = HEAP32[$11 + 512 >> 2];
                                       HEAP32[$1 + 8 >> 2] = $4;
                                       HEAP32[$1 + 12 >> 2] = $9;
                                       $4 = HEAP32[$11 + 524 >> 2];
                                       $9 = HEAP32[$11 + 520 >> 2];
                                       HEAP32[$1 + 16 >> 2] = $9;
                                       HEAP32[$1 + 20 >> 2] = $4;
                                       break label$471;
                                      }
                                      label$477: {
                                       while (1) {
                                        $1 = HEAP32[$1 >> 2];
                                        if ($1) {
                                         if (!sqlite3StrICmp(HEAP32[$1 >> 2], $5)) {
                                          break label$477;
                                         }
                                         $1 = $1 + 24 | 0;
                                         $2 = $2 + 1 | 0;
                                         continue;
                                        }
                                        break;
                                       }
                                       HEAP32[$8 + 128 >> 2] = $5;
                                       sqlite3VdbeError($0, 7137, $8 + 128 | 0);
                                       $6 = 1;
                                       break label$5;
                                      }
                                      if (!(($18 | 0) != 1 | HEAP32[$11 + 192 >> 2] <= 0)) {
                                       sqlite3VdbeError($0, 4003, 0);
                                       $6 = 5;
                                       break label$5;
                                      }
                                      $23 = 0;
                                      $20 = 0;
                                      label$481: {
                                       label$482: {
                                        label$483: {
                                         label$484: {
                                          if (HEAP32[$1 + 24 >> 2]) {
                                           break label$484;
                                          }
                                          $5 = HEAPU8[$11 + 93 | 0];
                                          $20 = ($5 | 0) != 0;
                                          if (!$5 | ($18 | 0) != 1) {
                                           break label$484;
                                          }
                                          $24 = sqlite3VdbeCheckFk($0, 1);
                                          if ($24) {
                                           break label$14;
                                          }
                                          HEAP8[$11 + 85 | 0] = 1;
                                          $24 = 5;
                                          if ((sqlite3VdbeHalt($0) | 0) == 5) {
                                           HEAP32[$0 + 32 >> 2] = ($3 - $22 | 0) / 20;
                                           HEAP8[$11 + 85 | 0] = 0;
                                           break label$15;
                                          }
                                          $5 = HEAP32[$0 + 36 >> 2];
                                          if (!$5) {
                                           break label$483;
                                          }
                                          HEAP8[$11 + 85 | 0] = 0;
                                          $6 = $5;
                                          break label$5;
                                         }
                                         $28 = HEAP32[$11 + 500 >> 2];
                                         if (($18 | 0) != 2) {
                                          break label$482;
                                         }
                                         $23 = HEAP32[$11 + 24 >> 2] & 1;
                                         $19 = !$23;
                                         $5 = 0;
                                         while (1) {
                                          if (HEAP32[$11 + 20 >> 2] <= ($5 | 0)) {
                                           break label$482;
                                          }
                                          $13 = $5 << 4;
                                          $6 = 0;
                                          $5 = $5 + 1 | 0;
                                          $13 = sqlite3BtreeTripAllCursors(HEAP32[(HEAP32[$11 + 16 >> 2] + $13 | 0) + 4 >> 2], 516, $19);
                                          if (!$13) {
                                           continue;
                                          }
                                          break;
                                         }
                                         $6 = $13;
                                         break label$5;
                                        }
                                        HEAP8[$11 + 93 | 0] = 0;
                                        $20 = 1;
                                        break label$481;
                                       }
                                       $19 = $6;
                                       $2 = ($2 ^ -1) + $28 | 0;
                                       $5 = 0;
                                       label$487: {
                                        while (1) {
                                         if (HEAP32[$11 + 20 >> 2] <= ($5 | 0)) {
                                          break label$487;
                                         }
                                         $13 = $5 << 4;
                                         $19 = 0;
                                         $5 = $5 + 1 | 0;
                                         $13 = sqlite3BtreeSavepoint(HEAP32[(HEAP32[$11 + 16 >> 2] + $13 | 0) + 4 >> 2], $18, $2);
                                         if (!$13) {
                                          continue;
                                         }
                                         break;
                                        }
                                        $6 = $13;
                                        break label$5;
                                       }
                                       if ($23) {
                                        sqlite3ExpirePreparedStatements($11, 0);
                                        sqlite3ResetAllSchemasOfConnection($11);
                                        HEAP32[$11 + 24 >> 2] = HEAP32[$11 + 24 >> 2] | 1;
                                       }
                                       if (!$19) {
                                        break label$481;
                                       }
                                       $6 = $19;
                                       break label$5;
                                      }
                                      while (1) {
                                       $5 = HEAP32[$39 >> 2];
                                       if (($1 | 0) != ($5 | 0)) {
                                        HEAP32[$11 + 488 >> 2] = HEAP32[$5 + 24 >> 2];
                                        sqlite3DbFree($11, $5);
                                        HEAP32[$11 + 500 >> 2] = HEAP32[$11 + 500 >> 2] - 1;
                                        continue;
                                       }
                                       break;
                                      }
                                      label$492: {
                                       label$493: {
                                        if (($18 | 0) == 1) {
                                         HEAP32[$11 + 488 >> 2] = HEAP32[$1 + 24 >> 2];
                                         sqlite3DbFree($11, $1);
                                         if ($20) {
                                          break label$493;
                                         }
                                         HEAP32[$11 + 500 >> 2] = HEAP32[$11 + 500 >> 2] - 1;
                                         break label$492;
                                        }
                                        $9 = HEAP32[$1 + 12 >> 2];
                                        $4 = HEAP32[$1 + 8 >> 2];
                                        HEAP32[$11 + 512 >> 2] = $4;
                                        HEAP32[$11 + 516 >> 2] = $9;
                                        $4 = HEAP32[$1 + 20 >> 2];
                                        $9 = HEAP32[$1 + 16 >> 2];
                                        HEAP32[$11 + 520 >> 2] = $9;
                                        HEAP32[$11 + 524 >> 2] = $4;
                                       }
                                       if (!$20) {
                                        break label$492;
                                       }
                                       if (($18 | 0) != 2) {
                                        break label$471;
                                       }
                                      }
                                      $1 = sqlite3VtabSavepoint($11, $18, $2);
                                      if (!$1) {
                                       break label$471;
                                      }
                                      $6 = $1;
                                      break label$5;
                                     }
                                     if (HEAPU8[$0 + 149 | 0] == 3) {
                                      break label$39;
                                     }
                                    }
                                    $6 = 0;
                                    break label$10;
                                   }
                                   $24 = 101;
                                   break label$14;
                                  }
                                  $1 = HEAP32[HEAP32[HEAP32[$0 + 96 >> 2] + (HEAP32[$3 + 4 >> 2] << 2) >> 2] + 36 >> 2];
                                  label$495: {
                                   label$496: {
                                    if (HEAP32[$3 + 12 >> 2]) {
                                     $4 = sqlite3BtreeRowCountEst($1);
                                     $16 = $4;
                                     $9 = i64toi32_i32$HIGH_BITS;
                                     $17 = $9;
                                     HEAP32[$8 + 296 >> 2] = $16;
                                     HEAP32[$8 + 300 >> 2] = $9;
                                     break label$496;
                                    }
                                    HEAP32[$8 + 296 >> 2] = 0;
                                    HEAP32[$8 + 300 >> 2] = 0;
                                    $1 = sqlite3BtreeCount($11, $1, $8 + 296 | 0);
                                    if ($1) {
                                     break label$495;
                                    }
                                    $6 = 0;
                                    $9 = HEAP32[$8 + 296 >> 2];
                                    $16 = $9;
                                    $4 = HEAP32[$8 + 300 >> 2];
                                    $17 = $4;
                                   }
                                   $9 = out2Prerelease($0, $3);
                                   HEAP32[$9 >> 2] = $16;
                                   $4 = $17;
                                   HEAP32[$9 + 4 >> 2] = $4;
                                   break label$11;
                                  }
                                  $6 = $1;
                                  break label$5;
                                 }
                                 $13 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                 $18 = $13 + Math_imul(HEAP32[$3 + 8 >> 2], 40) | 0;
                                 $23 = HEAP32[$3 + 12 >> 2];
                                 $19 = Math_imul($23, 40);
                                 $5 = HEAP32[$3 + 16 >> 2];
                                 if ($5) {
                                  $2 = HEAPU8[$5 | 0];
                                  $1 = $13;
                                  while (1) {
                                   applyAffinity($1, $2 << 24 >> 24, $25);
                                   $2 = $5;
                                   label$500: {
                                    if (HEAPU8[$2 | 0] != 69) {
                                     break label$500;
                                    }
                                    $5 = HEAPU16[$1 + 16 >> 1];
                                    if (!($5 & 4)) {
                                     break label$500;
                                    }
                                    HEAP16[$1 + 16 >> 1] = $5 & 65499 | 32;
                                   }
                                   $1 = $1 + 40 | 0;
                                   $5 = $2 + 1 | 0;
                                   $2 = HEAPU8[$2 + 1 | 0];
                                   if ($2) {
                                    continue;
                                   }
                                   break;
                                  }
                                 }
                                 $28 = $15 + $19 | 0;
                                 $5 = 0;
                                 $33 = 0;
                                 $38 = 0;
                                 $16 = 0;
                                 $17 = 0;
                                 $19 = $18 - 40 | 0;
                                 $2 = $19;
                                 while (1) {
                                  $1 = $2;
                                  $2 = HEAPU16[$1 + 16 >> 1];
                                  label$502: {
                                   if ($2 & 1) {
                                    HEAP32[$1 + 28 >> 2] = $2 << 21 >> 31 & 10;
                                    $5 = $5 + 1 | 0;
                                    break label$502;
                                   }
                                   if ($2 & 36) {
                                    $5 = $5 + 1 | 0;
                                    $9 = HEAP32[$1 + 4 >> 2];
                                    $20 = $9;
                                    $4 = HEAP32[$1 >> 2];
                                    $21 = $4;
                                    $10 = $4;
                                    $4 = $9 >> 31;
                                    $9 = $9 >> 31;
                                    $26 = $9 ^ $10;
                                    $10 = $20;
                                    $10 = $10 ^ $4;
                                    $18 = $10;
                                    $4 = $26;
                                    if (!$10 & $4 >>> 0 <= 127) {
                                     $4 = $20;
                                     $12 = $21;
                                     if (!(!$4 & $12 >>> 0 > 1 | ($4 | 0) != 0 | HEAPU8[$0 + 147 | 0] < 4)) {
                                      HEAP32[$1 + 28 >> 2] = $26 + 8;
                                      break label$502;
                                     }
                                     HEAP32[$1 + 28 >> 2] = 1;
                                     $12 = $17;
                                     $7 = $12;
                                     $9 = $16;
                                     $14 = $9 + 1 | 0;
                                     $7 = $14 ? $7 : $7 + 1 | 0;
                                     $16 = $14;
                                     $17 = $7;
                                     break label$502;
                                    }
                                    $7 = $18;
                                    $12 = $26;
                                    if (!$7 & $12 >>> 0 <= 32767) {
                                     HEAP32[$1 + 28 >> 2] = 2;
                                     $12 = $17;
                                     $10 = $16;
                                     $4 = $10 + 2 | 0;
                                     $14 = $4 >>> 0 < 2 ? $12 + 1 | 0 : $12;
                                     $16 = $4;
                                     $17 = $14;
                                     break label$502;
                                    }
                                    $14 = $18;
                                    if (!$14 & $26 >>> 0 <= 8388607) {
                                     HEAP32[$1 + 28 >> 2] = 3;
                                     $12 = $17;
                                     $4 = $12;
                                     $9 = $16;
                                     $7 = $9 + 3 | 0;
                                     $4 = $7 >>> 0 < 3 ? $4 + 1 | 0 : $4;
                                     $16 = $7;
                                     $17 = $4;
                                     break label$502;
                                    }
                                    $4 = $18;
                                    if (!$4 & $26 >>> 0 <= 2147483647) {
                                     HEAP32[$1 + 28 >> 2] = 4;
                                     $12 = $17;
                                     $7 = $12;
                                     $10 = $16;
                                     $14 = $10 + 4 | 0;
                                     $7 = $14 >>> 0 < 4 ? $7 + 1 | 0 : $7;
                                     $16 = $14;
                                     $17 = $7;
                                     break label$502;
                                    }
                                    if (($18 | 0) == 32767 | $7 >>> 0 < 32767) {
                                     HEAP32[$1 + 28 >> 2] = 5;
                                     $12 = $17;
                                     $9 = $16;
                                     $4 = $9 + 6 | 0;
                                     $14 = $4 >>> 0 < 6 ? $12 + 1 | 0 : $12;
                                     $16 = $4;
                                     $17 = $14;
                                     break label$502;
                                    }
                                    $14 = $17;
                                    $4 = $14;
                                    $12 = $16;
                                    $7 = $12 + 8 | 0;
                                    $4 = $7 >>> 0 < 8 ? $4 + 1 | 0 : $4;
                                    $16 = $7;
                                    $17 = $4;
                                    if ($2 & 32) {
                                     HEAP32[$1 + 28 >> 2] = 7;
                                     $12 = $21;
                                     $4 = $20;
                                     HEAPF64[$1 >> 3] = +($12 >>> 0) + +($4 | 0) * 4294967296;
                                     HEAP16[$1 + 16 >> 1] = $2 & 65495 | 8;
                                     break label$502;
                                    }
                                    HEAP32[$1 + 28 >> 2] = 6;
                                    break label$502;
                                   }
                                   if ($2 & 8) {
                                    HEAP32[$1 + 28 >> 2] = 7;
                                    $4 = $17;
                                    $14 = $16;
                                    $9 = $14 + 8 | 0;
                                    $7 = $9 >>> 0 < 8 ? $4 + 1 | 0 : $4;
                                    $16 = $9;
                                    $17 = $7;
                                    $5 = $5 + 1 | 0;
                                    break label$502;
                                   }
                                   $20 = HEAP32[$1 + 12 >> 2];
                                   $18 = ($2 >>> 1 & 1 | $20 << 1) + 12 | 0;
                                   label$513: {
                                    if (!($2 & 1024)) {
                                     break label$513;
                                    }
                                    $2 = HEAP32[$1 >> 2];
                                    $18 = ($2 << 1) + $18 | 0;
                                    $7 = $17;
                                    if ($7 | $16) {
                                     if (sqlite3VdbeMemExpandBlob($1)) {
                                      break label$6;
                                     }
                                     $20 = HEAP32[$1 >> 2] + $20 | 0;
                                     break label$513;
                                    }
                                    $7 = $2 >> 31;
                                    $14 = $7;
                                    $7 = $38;
                                    $9 = $14 + $7 | 0;
                                    $4 = $33;
                                    $12 = $4 + $2 | 0;
                                    $33 = $12;
                                    $9 = $2 >>> 0 > $12 >>> 0 ? $9 + 1 | 0 : $9;
                                    $38 = $9;
                                   }
                                   HEAP32[$1 + 28 >> 2] = $18;
                                   $9 = $17;
                                   $10 = $20;
                                   $7 = $16;
                                   $14 = $10 + $7 | 0;
                                   $12 = $14 >>> 0 < $10 >>> 0 ? $9 + 1 | 0 : $9;
                                   $16 = $14;
                                   $17 = $12;
                                   $5 = sqlite3VarintLen($18, 0) + $5 | 0;
                                  }
                                  $2 = $1 - 40 | 0;
                                  if (($1 | 0) != ($13 | 0)) {
                                   continue;
                                  }
                                  break;
                                 }
                                 $12 = $17;
                                 $4 = $12;
                                 if (($5 | 0) <= 126) {
                                  $1 = $5 + 1 | 0;
                                 } else {
                                  $2 = sqlite3VarintLen($5, 0);
                                  $1 = $5 + $2 | 0;
                                  $12 = $1 >> 31;
                                  $1 = $1 + ((sqlite3VarintLen($1, $12) | 0) > ($2 | 0)) | 0;
                                 }
                                 $26 = $1;
                                 $12 = $1 >> 31;
                                 $18 = $12;
                                 $12 = $4;
                                 $7 = $18;
                                 $14 = $12 + $7 | 0;
                                 $9 = $16;
                                 $4 = $9 + $1 | 0;
                                 $14 = $4 >>> 0 < $1 >>> 0 ? $14 + 1 | 0 : $14;
                                 $16 = $4;
                                 $9 = $38;
                                 $17 = $14;
                                 $4 = $9 + $14 | 0;
                                 $10 = $33;
                                 $12 = $16;
                                 $7 = $10 + $12 | 0;
                                 $21 = $7;
                                 $4 = $7 >>> 0 < $10 >>> 0 ? $4 + 1 | 0 : $4;
                                 $20 = $4;
                                 $2 = Math_imul($23, 40) + $15 | 0;
                                 $4 = HEAP32[$2 + 24 >> 2];
                                 $12 = $4 >> 31;
                                 $10 = $4;
                                 $4 = $12;
                                 $12 = $20;
                                 label$515: {
                                  if ($7 >>> 0 <= $10 >>> 0 & ($4 | 0) >= ($12 | 0) | ($4 | 0) > ($12 | 0)) {
                                   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 32 >> 2];
                                   $5 = $16;
                                   break label$515;
                                  }
                                  $14 = HEAP32[$11 + 120 >> 2];
                                  $12 = $14 >> 31;
                                  $4 = $14;
                                  $10 = $21;
                                  $14 = $12;
                                  $12 = $20;
                                  if ($4 >>> 0 < $10 >>> 0 & ($14 | 0) <= ($12 | 0) | ($12 | 0) > ($14 | 0)) {
                                   break label$25;
                                  }
                                  $5 = $16;
                                  if (sqlite3VdbeMemClearAndResize($28, $5)) {
                                   break label$6;
                                  }
                                 }
                                 $2 = Math_imul($23, 40) + $15 | 0;
                                 HEAP16[$2 + 16 >> 1] = 16;
                                 HEAP32[$2 + 12 >> 2] = $5;
                                 $10 = $38;
                                 if ($10 | $33) {
                                  HEAP32[$28 >> 2] = $33;
                                  HEAP16[$2 + 16 >> 1] = 1040;
                                 }
                                 $2 = HEAP32[$2 + 8 >> 2];
                                 label$520: {
                                  if (($1 | 0) <= 127) {
                                   HEAP8[$2 | 0] = $1;
                                   $18 = $2 + 1 | 0;
                                   break label$520;
                                  }
                                  $10 = $18;
                                  $18 = sqlite3PutVarint($2, $26, $10) + $2 | 0;
                                 }
                                 $2 = $1 + $2 | 0;
                                 while (1) {
                                  $5 = $13;
                                  $1 = HEAP32[$5 + 28 >> 2];
                                  label$523: {
                                   if ($1 >>> 0 <= 7) {
                                    HEAP8[$18 | 0] = $1;
                                    $18 = $18 + 1 | 0;
                                    if (!$1) {
                                     break label$523;
                                    }
                                    $10 = HEAP32[$5 >> 2];
                                    $16 = $10;
                                    $12 = HEAP32[$5 + 4 >> 2];
                                    $17 = $12;
                                    $13 = HEAPU8[$1 + 33216 | 0];
                                    $1 = $13;
                                    while (1) {
                                     $1 = $1 - 1 | 0;
                                     HEAP8[$2 + $1 | 0] = $16;
                                     $4 = $16;
                                     $16 = ($17 & 255) << 24 | $4 >>> 8;
                                     $12 = $17;
                                     $10 = $12 >>> 8 | 0;
                                     $17 = $10;
                                     if ($1) {
                                      continue;
                                     }
                                     break;
                                    }
                                    $2 = $2 + $13 | 0;
                                    break label$523;
                                   }
                                   if ($1 >>> 0 <= 127) {
                                    HEAP8[$18 | 0] = $1;
                                    $18 = $18 + 1 | 0;
                                    if ($1 >>> 0 < 14) {
                                     break label$523;
                                    }
                                    $1 = HEAP32[$5 + 12 >> 2];
                                    if (($1 | 0) <= 0) {
                                     break label$523;
                                    }
                                    $2 = __memcpy($2, HEAP32[$5 + 8 >> 2], $1) + HEAP32[$5 + 12 >> 2] | 0;
                                    break label$523;
                                   }
                                   $18 = sqlite3PutVarint($18, $1, 0) + $18 | 0;
                                   $1 = HEAP32[$5 + 12 >> 2];
                                   if (!$1) {
                                    break label$523;
                                   }
                                   $2 = __memcpy($2, HEAP32[$5 + 8 >> 2], $1) + HEAP32[$5 + 12 >> 2] | 0;
                                  }
                                  $13 = $5 + 40 | 0;
                                  if (($5 | 0) != ($19 | 0)) {
                                   continue;
                                  }
                                  break;
                                 }
                                 break label$10;
                                }
                                $1 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                                $5 = HEAP32[$3 + 16 >> 2];
                                $2 = HEAPU8[$5 | 0];
                                while (1) {
                                 applyAffinity($1, $2 << 24 >> 24, $25);
                                 $2 = $5;
                                 label$528: {
                                  if (HEAPU8[$2 | 0] != 69) {
                                   break label$528;
                                  }
                                  $5 = HEAPU16[$1 + 16 >> 1];
                                  if (!($5 & 4)) {
                                   break label$528;
                                  }
                                  $10 = HEAP32[$1 >> 2];
                                  $16 = $10;
                                  $4 = HEAP32[$1 + 4 >> 2];
                                  $17 = $4;
                                  $7 = $4 + 32768 | 0;
                                  $12 = $16;
                                  $9 = $12;
                                  label$529: {
                                   if ($7 >>> 0 < 65536) {
                                    $13 = 32;
                                    $18 = 65499;
                                    break label$529;
                                   }
                                   $7 = $16;
                                   $4 = $17;
                                   HEAPF64[$1 >> 3] = +($7 >>> 0) + +($4 | 0) * 4294967296;
                                   $13 = 8;
                                   $18 = 65523;
                                  }
                                  HEAP16[$1 + 16 >> 1] = $13 | $5 & $18;
                                 }
                                 $1 = $1 + 40 | 0;
                                 $5 = $2 + 1 | 0;
                                 $2 = HEAPU8[$2 + 1 | 0];
                                 if ($2) {
                                  continue;
                                 }
                                 break;
                                }
                                break label$10;
                               }
                               $2 = Math_imul(HEAP32[$3 + 4 >> 2], 40) + $15 | 0;
                               $19 = HEAP32[$3 + 16 >> 2];
                               $18 = HEAP32[$19 + 4 >> 2];
                               $1 = 0;
                               while (1) {
                                if (HEAP16[$19 + 34 >> 1] <= ($1 | 0)) {
                                 break label$10;
                                }
                                label$532: {
                                 label$533: {
                                  $13 = Math_imul($1, 12) + $18 | 0;
                                  $5 = HEAPU16[$13 + 10 >> 1];
                                  if (!($5 & 96)) {
                                   break label$533;
                                  }
                                  if ($5 & 32) {
                                   break label$532;
                                  }
                                  if (!HEAP32[$3 + 12 >> 2]) {
                                   break label$533;
                                  }
                                  $2 = $2 + 40 | 0;
                                  break label$532;
                                 }
                                 applyAffinity($2, HEAP8[$13 + 5 | 0], $25);
                                 label$534: {
                                  $5 = HEAPU16[$2 + 16 >> 1];
                                  if ($5 & 1) {
                                   break label$534;
                                  }
                                  label$535: {
                                   label$536: {
                                    label$537: {
                                     label$538: {
                                      label$539: {
                                       $13 = HEAPU8[(Math_imul($1, 12) + $18 | 0) + 4 | 0] >>> 4 | 0;
                                       switch ($13 - 2 | 0) {
                                       case 0:
                                        break label$536;

                                       case 3:
                                        break label$537;

                                       case 4:
                                        break label$538;

                                       case 1:
                                       case 2:
                                        break label$539;

                                       default:
                                        break label$534;
                                       }
                                      }
                                      if ($5 & 4) {
                                       break label$534;
                                      }
                                      break label$535;
                                     }
                                     if ($5 & 2) {
                                      break label$534;
                                     }
                                     break label$535;
                                    }
                                    label$540: {
                                     label$541: {
                                      if ($5 & 4) {
                                       $4 = HEAP32[$2 >> 2];
                                       $16 = $4;
                                       $7 = HEAP32[$2 + 4 >> 2];
                                       $17 = $7;
                                       $9 = $7 + 32768 | 0;
                                       $14 = $16;
                                       $10 = $14;
                                       if (($9 | 0) == 65536 | $9 >>> 0 > 65536) {
                                        break label$541;
                                       }
                                       $13 = 32;
                                       $20 = 65499;
                                       break label$540;
                                      }
                                      if ($5 & 40) {
                                       break label$534;
                                      }
                                      break label$535;
                                     }
                                     $9 = $16;
                                     $7 = $17;
                                     HEAPF64[$2 >> 3] = +($9 >>> 0) + +($7 | 0) * 4294967296;
                                     $13 = 8;
                                     $20 = 65523;
                                    }
                                    HEAP16[$2 + 16 >> 1] = $13 | $5 & $20;
                                    break label$534;
                                   }
                                   if ($5 & 16) {
                                    break label$534;
                                   }
                                  }
                                  $6 = vdbeMemTypeName($2);
                                  $15 = HEAP32[($13 << 2) + 65324 >> 2];
                                  $2 = HEAP32[$19 >> 2];
                                  HEAP32[$8 + 124 >> 2] = HEAP32[Math_imul($1, 12) + $18 >> 2];
                                  HEAP32[$8 + 120 >> 2] = $2;
                                  HEAP32[$8 + 116 >> 2] = $15;
                                  HEAP32[$8 + 112 >> 2] = $6;
                                  sqlite3VdbeError($0, 5901, $8 + 112 | 0);
                                  $6 = 3091;
                                  break label$5;
                                 }
                                 $2 = $2 + 40 | 0;
                                }
                                $1 = $1 + 1 | 0;
                                continue;
                               }
                              }
                              HEAP32[$1 + 72 >> 2] = sqlite3BtreePayloadSize($2);
                              $5 = sqlite3BtreePayloadFetch($2, $1 + 76 | 0);
                              HEAP32[$1 + 68 >> 2] = $5;
                              $2 = HEAP32[$0 + 28 >> 2];
                             }
                             HEAP32[$1 + 24 >> 2] = $2;
                             $13 = HEAP8[$5 | 0];
                             HEAP32[$18 >> 2] = $13 & 255;
                             $2 = 1;
                             if (($13 | 0) < 0) {
                              $2 = sqlite3GetVarint32($5, $18);
                             }
                             $19 = 0;
                             HEAP16[$1 + 54 >> 1] = 0;
                             HEAP32[$1 + 44 >> 2] = $2;
                             $5 = HEAP32[$18 >> 2];
                             if ($5 >>> 0 > HEAPU32[$1 + 76 >> 2]) {
                              HEAP32[$1 + 76 >> 2] = 0;
                              HEAP32[$1 + 68 >> 2] = 0;
                              $2 = HEAP32[$18 >> 2];
                              if ($2 >>> 0 > 98307) {
                               break label$24;
                              }
                              if (HEAPU32[$1 + 72 >> 2] >= $2 >>> 0) {
                               break label$32;
                              }
                              break label$24;
                             }
                             $26 = HEAP32[$1 + 68 >> 2];
                             break label$31;
                            }
                            if (($19 & 65535) >>> 0 > $23 >>> 0) {
                             break label$28;
                            }
                            $2 = HEAP32[$1 + 44 >> 2];
                            $5 = HEAP32[$18 >> 2];
                            if ($2 >>> 0 >= $5 >>> 0) {
                             break label$30;
                            }
                            $26 = HEAP32[$1 + 68 >> 2];
                            if ($26) {
                             break label$31;
                            }
                            $6 = 0;
                            memset($8 + 296 | 0, 0, 40);
                            $5 = sqlite3VdbeMemFromBtreeZeroOffset(HEAP32[$1 + 36 >> 2], HEAP32[$18 >> 2], $8 + 296 | 0);
                            if ($5) {
                             break label$23;
                            }
                            $5 = HEAP32[$18 >> 2];
                            $2 = HEAP32[$1 + 44 >> 2];
                            $19 = HEAPU16[$1 + 54 >> 1];
                            $26 = HEAP32[$8 + 304 >> 2];
                           }
                           $28 = $5 + $26 | 0;
                           $2 = $2 + $26 | 0;
                           $5 = $19 & 65535;
                           $12 = ($5 << 2) + $18 | 0;
                           $7 = HEAP32[$12 >> 2];
                           $16 = $7;
                           $17 = 0;
                           while (1) {
                            $13 = HEAPU8[$2 | 0];
                            HEAP32[$8 + 256 >> 2] = $13;
                            $4 = ($5 << 2) + $1 | 0;
                            $20 = $4 + 80 | 0;
                            HEAP32[$20 >> 2] = $13;
                            $19 = $13 << 24 >> 24;
                            label$546: {
                             if (($19 | 0) >= 0) {
                              $21 = sqlite3VdbeOneByteSerialTypeLen($19 & 255);
                              $2 = $2 + 1 | 0;
                              $9 = 0;
                              break label$546;
                             }
                             $19 = sqlite3GetVarint32($2, $8 + 256 | 0);
                             $13 = HEAP32[$8 + 256 >> 2];
                             HEAP32[$4 + 80 >> 2] = $13;
                             $21 = sqlite3VdbeSerialTypeLen($13);
                             $2 = $2 + $19 | 0;
                             $9 = 0;
                            }
                            $19 = $5 + 1 | 0;
                            $9 = $17;
                            $14 = $21;
                            $12 = $16;
                            $4 = $14 + $12 | 0;
                            $16 = $4;
                            $10 = $4 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
                            $17 = $10;
                            HEAP32[($19 << 2) + $18 >> 2] = $4;
                            if ($5 >>> 0 < $23 >>> 0) {
                             $5 = $19;
                             if ($2 >>> 0 < $28 >>> 0) {
                              continue;
                             }
                            }
                            break;
                           }
                           label$549: {
                            label$550: {
                             label$551: {
                              label$552: {
                               if ($2 >>> 0 < $28 >>> 0) {
                                $10 = HEAP32[$1 + 72 >> 2];
                                $21 = $10;
                                break label$552;
                               }
                               if ($2 >>> 0 > $28 >>> 0) {
                                break label$551;
                               }
                               $12 = HEAP32[$1 + 72 >> 2];
                               $21 = $12;
                               $9 = $16;
                               $14 = $21;
                               $10 = $17;
                               if (($9 | 0) != ($14 | 0) | $10) {
                                break label$551;
                               }
                              }
                              $9 = $17;
                              $14 = $16;
                              $12 = $21;
                              if (!$9 & $14 >>> 0 <= $12 >>> 0) {
                               break label$550;
                              }
                             }
                             if (HEAP32[$18 >> 2]) {
                              break label$549;
                             }
                             $19 = 0;
                             $2 = $28;
                            }
                            HEAP16[$1 + 54 >> 1] = $19;
                            HEAP32[$1 + 44 >> 2] = $2 - $26;
                            if (HEAP32[$1 + 68 >> 2]) {
                             break label$29;
                            }
                            sqlite3VdbeMemRelease($8 + 296 | 0);
                            $19 = HEAPU16[$1 + 54 >> 1];
                            break label$29;
                           }
                           if (HEAP32[$1 + 68 >> 2]) {
                            break label$24;
                           }
                           sqlite3VdbeMemRelease($8 + 296 | 0);
                           break label$24;
                          }
                          $13 = 0;
                          HEAP32[$8 + 256 >> 2] = 0;
                         }
                         if (($19 & 65535) >>> 0 > $23 >>> 0) {
                          break label$27;
                         }
                         $1 = Math_imul(HEAP32[$3 + 12 >> 2], 40) + $15 | 0;
                         if (HEAPU8[$3 + 1 | 0] == 246) {
                          sqlite3VdbeMemShallowCopy($1, HEAP32[$3 + 16 >> 2], 8192);
                          break label$10;
                         }
                         sqlite3VdbeMemSetNull($1);
                         break label$10;
                        }
                        $13 = HEAP32[(($23 << 2) + $1 | 0) + 80 >> 2];
                        HEAP32[$8 + 256 >> 2] = $13;
                       }
                       $19 = HEAP32[$3 + 12 >> 2];
                       $2 = Math_imul($19, 40) + $15 | 0;
                       if (HEAPU8[$2 + 17 | 0] & 144) {
                        sqlite3VdbeMemSetNull($2);
                       }
                       $4 = $2;
                       $5 = ($23 << 2) + $18 | 0;
                       if (HEAPU32[$1 + 76 >> 2] >= HEAPU32[$5 + 4 >> 2]) {
                        $18 = HEAP32[$1 + 68 >> 2] + HEAP32[$5 >> 2] | 0;
                        if ($13 >>> 0 <= 11) {
                         sqlite3VdbeSerialGet($18, $13, $2);
                         break label$10;
                        }
                        $5 = Math_imul($19, 40) + $15 | 0;
                        HEAP8[$5 + 18 | 0] = $25;
                        $1 = $13 - 12 >>> 1 | 0;
                        HEAP32[$5 + 12 >> 2] = $1;
                        $13 = $1 + 2 | 0;
                        label$558: {
                         if (($13 | 0) > HEAP32[$5 + 24 >> 2]) {
                          if (HEAP32[$11 + 120 >> 2] < ($1 | 0)) {
                           break label$25;
                          }
                          HEAP16[$4 + 16 >> 1] = 1;
                          if (sqlite3VdbeMemGrow($2, $13, 0)) {
                           break label$6;
                          }
                          $2 = HEAP32[(Math_imul($19, 40) + $15 | 0) + 8 >> 2];
                          break label$558;
                         }
                         $2 = HEAP32[$5 + 32 >> 2];
                         HEAP32[$5 + 8 >> 2] = $2;
                        }
                        __memcpy($2, $18, $1);
                        $2 = Math_imul($19, 40) + $15 | 0;
                        HEAP8[HEAP32[$2 + 8 >> 2] + $1 | 0] = 0;
                        HEAP8[(HEAP32[$2 + 8 >> 2] + $1 | 0) + 1 | 0] = 0;
                        HEAP16[$4 + 16 >> 1] = HEAPU16[((HEAP32[$8 + 256 >> 2] & 1) << 1) + 33202 >> 1];
                        break label$10;
                       }
                       HEAP8[(Math_imul($19, 40) + $15 | 0) + 18 | 0] = $25;
                       label$560: {
                        $5 = HEAPU16[$3 + 2 >> 1];
                        if (!(!($13 & 1) & $13 >>> 0 > 11 | $5 & 128 ? $5 & 192 : 0)) {
                         $5 = sqlite3VdbeSerialTypeLen($13);
                         if ($5) {
                          break label$560;
                         }
                        }
                        sqlite3VdbeSerialGet(30288, $13, $2);
                        break label$10;
                       }
                       if (HEAP32[$11 + 120 >> 2] < ($5 | 0)) {
                        break label$25;
                       }
                       $5 = sqlite3VdbeMemFromBtree(HEAP32[$1 + 36 >> 2], HEAP32[($23 << 2) + $18 >> 2], $5, $2);
                       if ($5) {
                        break label$23;
                       }
                       sqlite3VdbeSerialGet(HEAP32[(Math_imul($19, 40) + $15 | 0) + 8 >> 2], $13, $2);
                       HEAP16[$4 + 16 >> 1] = HEAPU16[$4 + 16 >> 1] & 49151;
                      }
                      $6 = 0;
                      break label$10;
                     }
                     sqlite3VdbeError($0, 11976, 0);
                     $6 = 18;
                     break label$5;
                    }
                    $1 = HEAP32[$22 + 12 >> 2];
                    if (($1 | 0) > 0) {
                     $3 = (Math_imul($1, 20) + $22 | 0) - 20 | 0;
                     break label$10;
                    }
                    $5 = sqlite3CorruptError(91354);
                   }
                   $6 = $5;
                   break label$5;
                  }
                  $1 = $2;
                 }
                 if (!(!($2 & 44) | $2 & 2)) {
                  sqlite3VdbeMemStringify($5, $25, 1);
                  $2 = HEAPU16[$4 + 16 >> 1] & -3520 | $1 & 3519;
                  break label$20;
                 }
                 $2 = $1;
                }
                $27 = sqlite3MemCompare($5, $13, HEAP32[$3 + 16 >> 2]);
                if (($27 | 0) < 0) {
                 $1 = HEAPU8[$3 | 0];
                 $5 = 30108;
                 break label$17;
                }
                $1 = HEAPU8[$3 | 0];
                if (!$27) {
                 break label$18;
                }
               }
               $5 = 30120;
               break label$17;
              }
              $27 = 0;
              $5 = 30114;
             }
             $1 = HEAPU8[$5 + ($1 & 255) | 0];
             HEAP16[$4 + 16 >> 1] = $2;
             HEAP16[$13 + 16 >> 1] = $18;
             if ($1) {
              break label$13;
             }
             break label$10;
            }
            $27 = 0;
            break label$10;
           }
           HEAP32[$0 + 36 >> 2] = 5;
          }
          $1 = 3;
          break label$4;
         }
         $3 = (Math_imul(HEAP32[$3 + 8 >> 2], 20) + $22 | 0) - 20 | 0;
         break label$10;
        }
        $3 = (Math_imul(HEAP32[$3 + 8 >> 2], 20) + $22 | 0) - 20 | 0;
       }
       $1 = 0;
       if (HEAP32[$11 + 296 >> 2]) {
        break label$4;
       }
       while (1) {
        $9 = $35;
        $14 = $32;
        $10 = $36;
        $12 = $30;
        if (($9 | 0) == ($14 | 0) & $10 >>> 0 < $12 >>> 0 | $9 >>> 0 < $14 >>> 0) {
         break label$10;
        }
        $1 = HEAP32[$11 + 368 >> 2];
        if (!$1) {
         break label$10;
        }
        $12 = HEAP32[$11 + 376 >> 2];
        $4 = $32;
        $9 = $12;
        $10 = $30;
        $7 = $9 + $10 | 0;
        $30 = $7;
        $4 = $7 >>> 0 < $9 >>> 0 ? $4 + 1 | 0 : $4;
        $32 = $4;
        if (!(FUNCTION_TABLE[$1 | 0](HEAP32[$11 + 372 >> 2]) | 0)) {
         continue;
        }
        break;
       }
       $1 = 1;
       break label$4;
      }
      $3 = $3 + 20 | 0;
      continue;
     }
    }
    sqlite3OomFault($11);
    sqlite3VdbeError($0, 1141, 0);
    $6 = 7;
   }
   $1 = 2;
  }
  while (1) {
   label$567: {
    label$568: {
     label$569: {
      label$570: {
       label$571: {
        label$572: {
         switch ($1 | 0) {
         case 0:
          $6 = 9;
          break label$567;

         case 1:
          $30 = -1;
          $32 = -1;
          break label$569;

         case 2:
          $24 = $6;
          $1 = 7;
          label$576: {
           if (HEAPU8[$11 + 87 | 0]) {
            break label$576;
           }
           $1 = $24;
           if (($1 | 0) != 8458) {
            break label$576;
           }
           $1 = sqlite3CorruptError(97014);
          }
          if (!(HEAP32[$0 + 124 >> 2] | ($1 | 0) == 3082)) {
           HEAP32[$8 + 16 >> 2] = sqlite3ErrStr($1);
           sqlite3VdbeError($0, 8342, $8 + 16 | 0);
          }
          HEAP32[$0 + 36 >> 2] = $1;
          sqlite3SystemError($11, $1);
          $24 = HEAP32[$0 + 196 >> 2];
          HEAP32[$8 + 8 >> 2] = HEAP32[$0 + 124 >> 2];
          HEAP32[$8 + 4 >> 2] = $24;
          HEAP32[$8 >> 2] = ($3 - $22 | 0) / 20;
          sqlite3_log($1, 6810, $8);
          if (HEAPU8[$0 + 149 | 0] == 2) {
           sqlite3VdbeHalt($0);
          }
          label$579: {
           if (($1 | 0) != 11) {
            if (($1 | 0) != 3082) {
             break label$579;
            }
            sqlite3OomFault($11);
            break label$579;
           }
           if (HEAPU8[$11 + 85 | 0]) {
            break label$579;
           }
           $10 = HEAP32[$11 + 36 >> 2];
           $4 = HEAP32[$11 + 32 >> 2];
           HEAP32[$11 + 32 >> 2] = $4;
           $4 = $10 | 2;
           HEAP32[$11 + 36 >> 2] = $4;
          }
          $24 = 1;
          $1 = $41 & 255;
          if (!$1) {
           $41 = 0;
           break label$571;
          }
          sqlite3ResetOneSchema($11, $1 - 1 | 0);
          break label$571;

         default:
          break label$572;
         }
        }
        $14 = $35;
        $4 = $32;
        $9 = $36;
        $10 = $30;
        if (($14 | 0) == ($4 | 0) & $9 >>> 0 < $10 >>> 0 | $4 >>> 0 > $14 >>> 0) {
         break label$570;
        }
        $1 = HEAP32[$11 + 368 >> 2];
        if (!$1) {
         break label$570;
        }
        $10 = HEAP32[$11 + 376 >> 2];
        $7 = $32;
        $9 = $30;
        $14 = $10;
        $12 = $9 + $14 | 0;
        $30 = $12;
        $7 = $12 >>> 0 < $14 >>> 0 ? $7 + 1 | 0 : $7;
        $32 = $7;
        if (FUNCTION_TABLE[$1 | 0](HEAP32[$11 + 372 >> 2]) | 0) {
         break label$568;
        }
       }
       $1 = 3;
       continue;
      }
      $1 = $0 + 176 | 0;
      HEAP32[$1 >> 2] = $36 + HEAP32[$0 + 176 >> 2];
      break label$3;
     }
     $1 = 0;
     continue;
    }
    $1 = 1;
    continue;
   }
   $1 = 2;
   continue;
  }
 }
 __stack_pointer = $8 + 336 | 0;
 return $24;
}
function sqlite3Pragma($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $6 = __stack_pointer - 448 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$0 >> 2];
 $5 = sqlite3GetVdbe($0);
 label$1: {
  if (!$5) {
   break label$1;
  }
  sqlite3VdbeRunOnlyOnce($5);
  HEAP32[$0 + 44 >> 2] = 2;
  $8 = sqlite3TwoPartName($0, $1, $2, $6 + 444 | 0);
  if (($8 | 0) < 0) {
   break label$1;
  }
  $1 = HEAP32[$7 + 16 >> 2];
  if (($8 | 0) == 1) {
   if (sqlite3OpenTempDatabase($0)) {
    break label$1;
   }
  }
  $20 = sqlite3NameFromToken($7, HEAP32[$6 + 444 >> 2]);
  if (!$20) {
   break label$1;
  }
  label$3: {
   label$4: {
    if ($4) {
     HEAP32[$6 + 384 >> 2] = $3;
     $10 = sqlite3MPrintf($7, 18442, $6 + 384 | 0);
     break label$4;
    }
    $10 = sqlite3NameFromToken($7, $3);
   }
   $4 = HEAP32[$2 + 4 >> 2] ? HEAP32[($8 << 4) + $1 >> 2] : 0;
   if (sqlite3AuthCheck($0, 19, $20, $10, $4)) {
    break label$3;
   }
   HEAP32[$6 + 428 >> 2] = 0;
   HEAP32[$6 + 424 >> 2] = $10;
   HEAP32[$6 + 420 >> 2] = $20;
   HEAP32[$6 + 416 >> 2] = 0;
   HEAP32[$7 + 452 >> 2] = 0;
   $3 = sqlite3_file_control($7, $4, 14, $6 + 416 | 0);
   if (($3 | 0) != 12) {
    if (!$3) {
     sqlite3VdbeSetNumCols($5, 1);
     sqlite3VdbeSetColName($5, 0, 0, HEAP32[$6 + 416 >> 2], -1);
     returnSingleText($5, HEAP32[$6 + 416 >> 2]);
     sqlite3_free(HEAP32[$6 + 416 >> 2]);
     break label$3;
    }
    $2 = HEAP32[$6 + 416 >> 2];
    if ($2) {
     HEAP32[$6 >> 2] = $2;
     sqlite3ErrorMsg($0, 8342, $6);
     sqlite3_free(HEAP32[$6 + 416 >> 2]);
    }
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
    break label$3;
   }
   $3 = pragmaLocate($20);
   if (!$3) {
    break label$3;
   }
   $13 = HEAPU8[$3 + 5 | 0];
   if ($13 & 1) {
    if (sqlite3ReadSchema($0)) {
     break label$3;
    }
    $13 = HEAPU8[$3 + 5 | 0];
   }
   if (!($13 & 2 | ($10 ? $13 & 4 : 0))) {
    setPragmaResultColumnNames($5, $3);
   }
   $14 = -1;
   $13 = 0;
   label$13: {
    label$14: {
     label$15: {
      label$16: {
       label$17: {
        label$18: {
         label$19: {
          label$20: {
           label$21: {
            label$22: {
             label$23: {
              label$24: {
               label$25: {
                label$26: {
                 label$27: {
                  switch (HEAPU8[$3 + 4 | 0] - 1 | 0) {
                  case 12:
                   sqlite3VdbeUsesBtree($5, $8);
                   if (!$10) {
                    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 2;
                    $2 = sqlite3VdbeAddOpList($5, 9, 49248);
                    HEAP32[$2 + 4 >> 2] = $8;
                    HEAP32[$2 + 124 >> 2] = -2e3;
                    HEAP32[$2 + 24 >> 2] = $8;
                    break label$3;
                   }
                   $2 = sqlite3AbsInt32(sqlite3Atoi($10));
                   sqlite3BeginWriteOperation($0, 0, $8);
                   sqlite3VdbeAddOp3($5, 100, $8, 3, $2);
                   $5 = ($8 << 4) + $1 | 0;
                   HEAP32[HEAP32[$5 + 12 >> 2] + 80 >> 2] = $2;
                   sqlite3BtreeSetCacheSize(HEAP32[$5 + 4 >> 2], $2);
                   break label$3;

                  case 30:
                   $2 = HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2];
                   if (!$10) {
                    if ($2) {
                     $11 = sqlite3BtreeGetPageSize($2);
                     $9 = $11 >> 31;
                    } else {
                     $9 = 0;
                    }
                    $15 = $11;
                    returnSingleInt($5, $15, $9);
                    break label$3;
                   }
                   $5 = sqlite3Atoi($10);
                   HEAP32[$7 + 100 >> 2] = $5;
                   if ((sqlite3BtreeSetPageSize($2, $5, 0, 0) | 0) != 7) {
                    break label$3;
                   }
                   sqlite3OomFault($7);
                   break label$3;

                  case 32:
                   $1 = HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2];
                   label$59: {
                    if (!$10) {
                     break label$59;
                    }
                    if (!sqlite3_stricmp($10, 2289)) {
                     $14 = 2;
                     break label$59;
                    }
                    $14 = sqlite3GetBoolean($10, 0);
                   }
                   label$61: {
                    if (HEAP32[$2 + 4 >> 2]) {
                     break label$61;
                    }
                    $2 = 0;
                    if (($14 | 0) < 0) {
                     break label$61;
                    }
                    while (1) {
                     if (HEAP32[$7 + 20 >> 2] <= ($2 | 0)) {
                      break label$61;
                     }
                     sqlite3BtreeSecureDelete(HEAP32[(HEAP32[$7 + 16 >> 2] + ($2 << 4) | 0) + 4 >> 2], $14);
                     $2 = $2 + 1 | 0;
                     continue;
                    }
                   }
                   returnSingleInt($5, sqlite3BtreeSecureDelete($1, $14), 0);
                   break label$3;

                  case 26:
                   HEAP32[$6 + 408 >> 2] = 0;
                   HEAP32[$6 + 412 >> 2] = 0;
                   sqlite3CodeVerifySchema($0, $8);
                   $2 = HEAP32[$0 + 44 >> 2] + 1 | 0;
                   HEAP32[$0 + 44 >> 2] = $2;
                   label$63: {
                    if ((HEAPU8[$20 | 0] & 223) == 80) {
                     sqlite3VdbeAddOp2($5, 177, $8, $2);
                     break label$63;
                    }
                    $1 = 0;
                    label$65: {
                     if (!$10) {
                      break label$65;
                     }
                     if (sqlite3DecOrHexToI64($10, $6 + 408 | 0)) {
                      break label$65;
                     }
                     $11 = HEAP32[$6 + 412 >> 2];
                     $9 = HEAP32[$6 + 408 >> 2];
                     $15 = $9;
                     if (($11 | 0) < 0) {
                      break label$65;
                     }
                     $0 = $11;
                     $1 = $15;
                     $11 = !$0 & $1 >>> 0 < 4294967294;
                     $11 = $11 ? $15 : -2;
                     $1 = $11;
                    }
                    sqlite3VdbeAddOp3($5, 178, $8, $2, $1);
                   }
                   sqlite3VdbeAddOp2($5, 84, $2, 1);
                   break label$3;

                  case 25:
                   $4 = getLockingMode($10);
                   $2 = HEAP32[$2 + 4 >> 2];
                   if ($2 | ($4 | 0) != -1) {
                    if (!$2) {
                     $2 = 2;
                     while (1) {
                      if (($2 | 0) < HEAP32[$7 + 20 >> 2]) {
                       sqlite3PagerLockingMode(sqlite3BtreePager(HEAP32[(HEAP32[$7 + 16 >> 2] + ($2 << 4) | 0) + 4 >> 2]), $4);
                       $2 = $2 + 1 | 0;
                       continue;
                      }
                      break;
                     }
                     HEAP8[$7 + 89 | 0] = $4;
                    }
                    $2 = sqlite3PagerLockingMode(sqlite3BtreePager(HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2]), $4);
                   } else {
                    $2 = HEAPU8[$7 + 89 | 0];
                   }
                   returnSingleText($5, ($2 | 0) == 1 ? 12316 : 11288);
                   break label$3;

                  case 22:
                   label$71: {
                    label$72: {
                     if (!$10) {
                      break label$72;
                     }
                     $4 = 0;
                     $0 = sqlite3Strlen30($10);
                     while (1) {
                      $1 = sqlite3JournalModename($4);
                      if (!$1) {
                       break label$72;
                      }
                      if (sqlite3_strnicmp($10, $1, $0)) {
                       $4 = $4 + 1 | 0;
                       continue;
                      }
                      break;
                     }
                     if (($4 | 0) != 2) {
                      break label$71;
                     }
                     if (HEAPU8[$7 + 35 | 0] & 16) {
                      break label$72;
                     }
                     $4 = 2;
                     break label$71;
                    }
                    $4 = -1;
                    if (HEAP32[$2 + 4 >> 2]) {
                     break label$71;
                    }
                    HEAP32[$2 + 4 >> 2] = 1;
                    $8 = 0;
                   }
                   $1 = HEAP32[$7 + 20 >> 2];
                   while (1) {
                    if (($1 | 0) > 0) {
                     $1 = $1 - 1 | 0;
                     if (!HEAP32[(HEAP32[$7 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2] | (HEAP32[$2 + 4 >> 2] ? ($1 | 0) != ($8 | 0) : 0)) {
                      continue;
                     }
                     sqlite3VdbeUsesBtree($5, $1);
                     sqlite3VdbeAddOp3($5, 4, $1, 1, $4);
                     continue;
                    }
                    break;
                   }
                   ;
                   sqlite3VdbeAddOp2($5, 84, 1, 1);
                   break label$3;

                  case 23:
                   $2 = sqlite3BtreePager(HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2]);
                   $15 = -2;
                   $11 = -1;
                   HEAP32[$6 + 408 >> 2] = -2;
                   HEAP32[$6 + 412 >> 2] = -1;
                   if ($10) {
                    sqlite3DecOrHexToI64($10, $6 + 408 | 0);
                    $11 = HEAP32[$6 + 412 >> 2];
                    $0 = ($11 | 0) > 0 | ($11 | 0) >= 0;
                    $9 = HEAP32[$6 + 408 >> 2];
                    $9 = $0 ? $9 : -1;
                    $15 = $9;
                    $1 = $0 ? $11 : -1;
                    $11 = $1;
                   }
                   $1 = $11;
                   $1 = sqlite3PagerJournalSizeLimit($2, $15, $1);
                   $9 = i64toi32_i32$HIGH_BITS;
                   returnSingleInt($5, $1, $9);
                   break label$3;

                  case 2:
                   $2 = HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2];
                   if (!$10) {
                    returnSingleInt($5, sqlite3BtreeGetAutoVacuum($2), 0);
                    break label$3;
                   }
                   $1 = getAutoVacuum($10);
                   HEAP8[$7 + 90 | 0] = $1;
                   if (sqlite3BtreeSetAutoVacuum($2, $1)) {
                    break label$3;
                   }
                   $1 = $1 - 1 | 0;
                   if ($1 >>> 0 > 1) {
                    break label$3;
                   }
                   $4 = sqlite3VdbeCurrentAddr($5);
                   $2 = sqlite3VdbeAddOpList($5, 5, 49296);
                   HEAP32[$2 + 4 >> 2] = $8;
                   HEAP32[$2 + 92 >> 2] = $1;
                   HEAP32[$2 + 84 >> 2] = $8;
                   HEAP32[$2 + 48 >> 2] = $4 + 4;
                   HEAP32[$2 + 24 >> 2] = $8;
                   sqlite3VdbeUsesBtree($5, $8);
                   break label$3;

                  case 18:
                   HEAP32[$6 + 408 >> 2] = 0;
                   label$80: {
                    label$81: {
                     if (!$10) {
                      break label$81;
                     }
                     if (!sqlite3GetInt32($10, $6 + 408 | 0)) {
                      break label$81;
                     }
                     $2 = HEAP32[$6 + 408 >> 2];
                     if (($2 | 0) > 0) {
                      break label$80;
                     }
                    }
                    $2 = 2147483647;
                   }
                   sqlite3BeginWriteOperation($0, 0, $8);
                   sqlite3VdbeAddOp2($5, 71, $2, 1);
                   $2 = sqlite3VdbeAddOp1($5, 61, $8);
                   sqlite3VdbeAddOp1($5, 84, 1);
                   sqlite3VdbeAddOp2($5, 86, 1, -1);
                   sqlite3VdbeAddOp2($5, 49, 1, $2);
                   sqlite3VdbeJumpHere($5, $2);
                   break label$3;

                  case 5:
                   if (!$10) {
                    $0 = HEAP32[(($8 << 4) + $1 | 0) + 12 >> 2];
                    $9 = HEAP32[$0 + 80 >> 2];
                    $1 = $9 >> 31;
                    returnSingleInt($5, $9, $1);
                    break label$3;
                   }
                   $2 = sqlite3Atoi($10);
                   $5 = ($8 << 4) + $1 | 0;
                   HEAP32[HEAP32[$5 + 12 >> 2] + 80 >> 2] = $2;
                   sqlite3BtreeSetCacheSize(HEAP32[$5 + 4 >> 2], $2);
                   break label$3;

                  case 6:
                   if (!$10) {
                    if (HEAPU8[$7 + 32 | 0] & 32) {
                     $9 = sqlite3BtreeSetSpillSize(HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2], 0);
                     $1 = $9 >> 31;
                     $15 = $9;
                     $11 = $1;
                    }
                    $1 = $11;
                    returnSingleInt($5, $15, $1);
                    break label$3;
                   }
                   HEAP32[$6 + 408 >> 2] = 1;
                   label$85: {
                    if (!sqlite3GetInt32($10, $6 + 408 | 0)) {
                     $2 = HEAP32[$6 + 408 >> 2];
                     break label$85;
                    }
                    $2 = HEAP32[$6 + 408 >> 2];
                    sqlite3BtreeSetSpillSize(HEAP32[(($8 << 4) + $1 | 0) + 4 >> 2], $2);
                   }
                   $2 = sqlite3GetBoolean($10, ($2 | 0) != 0);
                   $1 = HEAP32[$7 + 32 >> 2];
                   $0 = $1;
                   $1 = $0 & -33;
                   $9 = HEAP32[$7 + 36 >> 2];
                   $3 = $9;
                   $9 = ($2 | 0) != 0;
                   $0 = $9 >>> 27 | 0;
                   $11 = $9 << 5;
                   $1 = $1 | $11;
                   HEAP32[$7 + 32 >> 2] = $1;
                   $9 = $0;
                   $0 = $3;
                   $9 = $9 | $0;
                   HEAP32[$7 + 36 >> 2] = $9;
                   setAllPagerFlags($7);
                   break label$3;

                  case 27:
                   returnSingleInt($5, 0, 0);
                   break label$3;

                  case 38:
                   if (!$10) {
                    $9 = HEAPU8[$7 + 86 | 0];
                    returnSingleInt($5, $9, 0);
                    break label$3;
                   }
                   changeTempStorage($0, $10);
                   break label$3;

                  case 39:
                   if (!$10) {
                    returnSingleText($5, HEAP32[17691]);
                    break label$3;
                   }
                   label$89: {
                    if (!HEAPU8[$10 | 0]) {
                     break label$89;
                    }
                    if (!(wasm2js_i32$0 = sqlite3OsAccess(HEAP32[$7 >> 2], $10, 1, $6 + 408 | 0), wasm2js_i32$1 = 1, 
                    wasm2js_i32$2 = HEAP32[$6 + 408 >> 2], wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
                     break label$89;
                    }
                    sqlite3ErrorMsg($0, 1088, 0);
                    break label$3;
                   }
                   if (HEAPU8[$7 + 86 | 0] <= 1) {
                    invalidateTempStorage($0);
                   }
                   sqlite3_free(HEAP32[17691]);
                   if (HEAPU8[$10 | 0]) {
                    HEAP32[$6 + 16 >> 2] = $10;
                    HEAP32[17691] = sqlite3_mprintf(8342, $6 + 16 | 0);
                    break label$3;
                   }
                   HEAP32[17691] = 0;
                   break label$3;

                  case 35:
                   if (!$10) {
                    $0 = ($8 << 4) + $1 | 0;
                    $1 = HEAPU8[$0 + 8 | 0];
                    $0 = $1;
                    $11 = $0 - 1 | 0;
                    $12 = !$0;
                    $12 = 0 - $12 | 0;
                    returnSingleInt($5, $11, $12);
                    break label$3;
                   }
                   if (!HEAPU8[$7 + 85 | 0]) {
                    sqlite3ErrorMsg($0, 10152, 0);
                    break label$3;
                   }
                   if (($8 | 0) == 1) {
                    break label$3;
                   }
                   $2 = getSafetyLevel($10, 0, 1);
                   $5 = ($8 << 4) + $1 | 0;
                   HEAP8[$5 + 9 | 0] = 1;
                   $2 = $2 + 1 & 7;
                   HEAP8[$5 + 8 | 0] = $2 ? $2 : 1;
                   setAllPagerFlags($7);
                   break label$3;

                  case 3:
                   if (!$10) {
                    setPragmaResultColumnNames($5, $3);
                    $12 = HEAP32[$3 + 8 >> 2];
                    $9 = $12;
                    $0 = HEAP32[$3 + 12 >> 2];
                    $1 = $0;
                    $0 = HEAP32[$7 + 32 >> 2];
                    $11 = $0;
                    $12 = HEAP32[$7 + 36 >> 2];
                    $0 = $12;
                    $12 = $1;
                    $0 = $0 & $12;
                    $12 = $11 & $9;
                    $0 = ($0 | $12) != 0;
                    returnSingleInt($5, $0, 0);
                    break label$3;
                   }
                   $0 = HEAP32[$3 + 12 >> 2];
                   $12 = HEAP32[$3 + 8 >> 2];
                   $15 = $12;
                   $1 = HEAPU8[$7 + 85 | 0];
                   $9 = $1 ? $15 : $15 & -16385;
                   $15 = $9;
                   $0 = $1 ? $0 : $0;
                   $11 = $0;
                   label$96: {
                    if (sqlite3GetBoolean($10, 0)) {
                     $9 = HEAP32[$7 + 36 >> 2];
                     $0 = HEAP32[$7 + 32 >> 2];
                     $12 = $15;
                     HEAP32[$7 + 32 >> 2] = $0 | $12;
                     $0 = $11;
                     $0 = $9 | $0;
                     HEAP32[$7 + 36 >> 2] = $0;
                     break label$96;
                    }
                    $0 = HEAP32[$7 + 32 >> 2];
                    $2 = $0;
                    $1 = HEAP32[$7 + 36 >> 2];
                    $3 = $1;
                    $1 = $11;
                    $0 = $1 ^ -1;
                    $1 = $2;
                    $9 = $15;
                    $12 = $9 ^ -1;
                    HEAP32[$7 + 32 >> 2] = $1 & $12;
                    $9 = $0;
                    $0 = $3;
                    $9 = $9 & $0;
                    HEAP32[$7 + 36 >> 2] = $9;
                    $9 = $11;
                    $0 = $15;
                    if (!$9 & ($0 | 0) == 524288) {
                     HEAP32[$7 + 520 >> 2] = 0;
                     HEAP32[$7 + 524 >> 2] = 0;
                     break label$96;
                    }
                    $9 = 0;
                    $12 = $15;
                    if (!($9 | $12 & 1)) {
                     break label$96;
                    }
                    if (sqlite3_stricmp($10, 3057)) {
                     break label$96;
                    }
                    sqlite3ResetAllSchemasOfConnection($7);
                   }
                   sqlite3VdbeAddOp0($5, 166);
                   setAllPagerFlags($7);
                   break label$3;

                  case 36:
                   if (!$10) {
                    break label$3;
                   }
                   sqlite3CodeVerifyNamedSchema($0, $4);
                   $13 = sqlite3LocateTable($0, 2, $10, $4);
                   if (!$13) {
                    break label$3;
                   }
                   $8 = sqlite3PrimaryKeyIndex($13);
                   HEAP32[$0 + 44 >> 2] = 7;
                   sqlite3ViewGetColumnNames($0, $13);
                   $0 = HEAP32[$13 + 4 >> 2];
                   $1 = 0;
                   while (1) {
                    $14 = HEAP16[$13 + 34 >> 1];
                    if (($14 | 0) <= ($1 | 0)) {
                     break label$3;
                    }
                    $2 = HEAPU16[$0 + 10 >> 1];
                    label$100: {
                     label$101: {
                      if (!($2 & 98)) {
                       $16 = 0;
                       $11 = 0;
                       break label$101;
                      }
                      $9 = HEAP32[$3 + 8 >> 2];
                      $12 = HEAP32[$3 + 12 >> 2];
                      if (!($9 | $12)) {
                       $22 = $22 + 1 | 0;
                       break label$100;
                      }
                      if ($2 & 32) {
                       $16 = 2;
                       $11 = 1;
                       break label$101;
                      }
                      $4 = $2 & 64;
                      $16 = $4 ? 3 : 1;
                      $11 = $4 >>> 6 | 0;
                     }
                     $4 = $2 & 1;
                     label$105: {
                      if (!$4 | !$8) {
                       break label$105;
                      }
                      $2 = 1;
                      $4 = (($14 | 0) > 0 ? $14 : 0) + 1 | 0;
                      while (1) {
                       if (($2 | 0) == ($4 | 0)) {
                        break label$105;
                       }
                       if (!(HEAP16[(HEAP32[$8 + 4 >> 2] + ($2 << 1) | 0) - 2 >> 1] == ($1 | 0))) {
                        $2 = $2 + 1 | 0;
                        continue;
                       }
                       break;
                      }
                      $4 = $2;
                     }
                     $2 = sqlite3ColumnExpr($13, $0);
                     $12 = HEAP32[$3 + 8 >> 2];
                     $9 = HEAP32[$3 + 12 >> 2];
                     $17 = $12 | $9 ? 11606 : 11575;
                     $15 = $1 - $22 | 0;
                     $18 = HEAP32[$0 >> 2];
                     $9 = sqlite3ColumnType($0, 29623);
                     $14 = 0;
                     $19 = (HEAPU8[$0 + 4 | 0] & 15) != 0;
                     $14 = !$2 | $11 ? $14 : HEAP32[$2 + 8 >> 2];
                     HEAP32[$6 + 56 >> 2] = $16;
                     HEAP32[$6 + 52 >> 2] = $4;
                     HEAP32[$6 + 48 >> 2] = $14;
                     HEAP32[$6 + 44 >> 2] = $19;
                     HEAP32[$6 + 40 >> 2] = $9;
                     HEAP32[$6 + 36 >> 2] = $18;
                     HEAP32[$6 + 32 >> 2] = $15;
                     sqlite3VdbeMultiLoad($5, 1, $17, $6 + 32 | 0);
                    }
                    $0 = $0 + 12 | 0;
                    $1 = $1 + 1 | 0;
                    continue;
                   }
                   ;

                  case 0:
                   label$110: {
                    if (!$10) {
                     break label$110;
                    }
                    if (sqlite3DecOrHexToI64($10, $6 + 408 | 0)) {
                     break label$110;
                    }
                    $12 = HEAP32[$6 + 412 >> 2];
                    $11 = $12;
                    $9 = HEAP32[$6 + 408 >> 2];
                    $15 = $9;
                    if (($12 | 0) < 0) {
                     break label$110;
                    }
                    HEAP32[$7 + 492 >> 2] = $15 & 2147483647;
                   }
                   $0 = HEAP32[$7 + 492 >> 2];
                   $12 = $0 >> 31;
                   returnSingleInt($5, $0, $12);
                   break label$3;

                  case 40:
                   label$111: {
                    if (!$10) {
                     break label$111;
                    }
                    if (sqlite3DecOrHexToI64($10, $6 + 408 | 0)) {
                     break label$111;
                    }
                    $0 = HEAP32[$6 + 412 >> 2];
                    $11 = $0;
                    $12 = HEAP32[$6 + 408 >> 2];
                    $15 = $12;
                    if (($0 | 0) < 0) {
                     break label$111;
                    }
                    sqlite3_limit($7, 11, $15 & 2147483647);
                   }
                   $0 = sqlite3_limit($7, 11, -1);
                   $1 = $0 >> 31;
                   returnSingleInt($5, $0, $1);
                   break label$3;

                  case 17:
                   label$112: {
                    if (!$10) {
                     break label$112;
                    }
                    if (sqlite3DecOrHexToI64($10, $6 + 408 | 0)) {
                     break label$112;
                    }
                    $1 = sqlite3_hard_heap_limit64(-1, -1);
                    $15 = $1;
                    $0 = i64toi32_i32$HIGH_BITS;
                    $11 = $0;
                    $1 = HEAP32[$6 + 412 >> 2];
                    $0 = HEAP32[$6 + 408 >> 2];
                    $9 = $0;
                    $2 = !$9 & ($1 | 0) <= 0 | ($1 | 0) < 0;
                    $9 = $11;
                    $12 = $15;
                    if ($2 | !!($9 | $12) & (($1 | 0) >= ($9 | 0) & $0 >>> 0 >= $12 >>> 0 | ($1 | 0) > ($9 | 0))) {
                     break label$112;
                    }
                    $12 = $1;
                    sqlite3_hard_heap_limit64($0, $12);
                   }
                   $9 = sqlite3_hard_heap_limit64(-1, -1);
                   $12 = i64toi32_i32$HIGH_BITS;
                   returnSingleInt($5, $9, $12);
                   break label$3;

                  case 34:
                   label$113: {
                    if (!$10) {
                     break label$113;
                    }
                    if (sqlite3DecOrHexToI64($10, $6 + 408 | 0)) {
                     break label$113;
                    }
                    $12 = HEAP32[$6 + 408 >> 2];
                    $9 = HEAP32[$6 + 412 >> 2];
                    sqlite3_soft_heap_limit64($12, $9);
                   }
                   $12 = sqlite3_soft_heap_limit64(-1, -1);
                   $9 = i64toi32_i32$HIGH_BITS;
                   returnSingleInt($5, $12, $9);
                   break label$3;

                  default:
                   if ($10) {
                    sqlite3_busy_timeout($7, sqlite3Atoi($10));
                   }
                   $9 = HEAP32[$7 + 496 >> 2];
                   $12 = $9 >> 31;
                   returnSingleInt($5, $9, $12);
                   break label$3;

                  case 29:
                   label$115: {
                    if (!$10) {
                     $2 = 65534;
                     break label$115;
                    }
                    $2 = sqlite3Atoi($10);
                    if (!($2 & 2)) {
                     break label$3;
                    }
                   }
                   $16 = HEAP32[$0 + 40 >> 2];
                   HEAP32[$0 + 40 >> 2] = $16 + 1;
                   $15 = $4 ? $8 : HEAP32[$7 + 20 >> 2] - 1 | 0;
                   $11 = $2 & 1;
                   $17 = $11 | 2;
                   while (1) {
                    if (($8 | 0) <= ($15 | 0)) {
                     label$120: {
                      if (($8 | 0) == 1) {
                       break label$120;
                      }
                      sqlite3CodeVerifySchema($0, $8);
                      $14 = $8 << 4;
                      $4 = HEAP32[($14 + HEAP32[$7 + 16 >> 2] | 0) + 12 >> 2] + 16 | 0;
                      while (1) {
                       $4 = HEAP32[$4 >> 2];
                       if (!$4) {
                        break label$120;
                       }
                       $3 = HEAP32[$4 + 8 >> 2];
                       if (!(HEAP8[$3 + 29 | 0] & 1)) {
                        continue;
                       }
                       $1 = $3 + 8 | 0;
                       $13 = HEAPU16[$3 + 38 >> 1] + 46 | 0;
                       label$122: {
                        while (1) {
                         $2 = HEAP32[$1 >> 2];
                         if ($2) {
                          $1 = $2 + 20 | 0;
                          if (HEAPU8[$2 + 55 | 0] & 128) {
                           continue;
                          }
                          break label$122;
                         }
                         break;
                        }
                        if (!($13 & 65535)) {
                         break label$122;
                        }
                        sqlite3OpenTable($0, $16, $8, $3, 112);
                        sqlite3VdbeAddOp3($5, 32, $16, sqlite3VdbeCurrentAddr($5) + $17 | 0, $13 << 16 >> 16);
                       }
                       $2 = HEAP32[HEAP32[$7 + 16 >> 2] + $14 >> 2];
                       HEAP32[$6 + 372 >> 2] = HEAP32[$3 >> 2];
                       HEAP32[$6 + 368 >> 2] = $2;
                       $2 = sqlite3MPrintf($7, 28355, $6 + 368 | 0);
                       if ($11) {
                        $1 = sqlite3GetTempReg($0);
                        sqlite3VdbeAddOp4($5, 117, 0, $1, 0, $2, -6);
                        sqlite3VdbeAddOp2($5, 84, $1, 1);
                       } else {
                        sqlite3VdbeAddOp4($5, 148, 0, 0, 0, $2, -6);
                       }
                       continue;
                      }
                     }
                     $8 = $8 + 1 | 0;
                     continue;
                    }
                    break;
                   }
                   ;
                   sqlite3VdbeAddOp0($5, 166);
                   break label$3;

                  case 33:
                   sqlite3_db_release_memory($7);
                   break label$3;

                  case 41:
                   if ($10) {
                    sqlite3_wal_autocheckpoint($7, sqlite3Atoi($10));
                   }
                   if (HEAP32[$7 + 268 >> 2] == 9) {
                    $12 = HEAP32[$7 + 272 >> 2];
                    $9 = $12 >> 31;
                    $15 = $12;
                    $11 = $9;
                   }
                   $9 = $11;
                   returnSingleInt($5, $15, $9);
                   break label$3;

                  case 42:
                   $2 = HEAP32[$2 >> 2] ? $8 : 12;
                   $1 = 0;
                   label$129: {
                    if (!$10) {
                     break label$129;
                    }
                    $1 = 1;
                    if (!sqlite3StrICmp($10, 11128)) {
                     break label$129;
                    }
                    $1 = 2;
                    if (!sqlite3StrICmp($10, 2355)) {
                     break label$129;
                    }
                    $1 = sqlite3StrICmp($10, 12554) ? 0 : 3;
                   }
                   HEAP32[$0 + 44 >> 2] = 3;
                   sqlite3VdbeAddOp3($5, 3, $2, $1, 1);
                   sqlite3VdbeAddOp2($5, 84, 1, 3);
                   break label$3;

                  case 9:
                   HEAP32[$0 + 44 >> 2] = 1;
                   $2 = 0;
                   while (1) {
                    $1 = sqlite3_compileoption_get($2);
                    if (!$1) {
                     break label$26;
                    }
                    sqlite3VdbeLoadString($5, 1, $1);
                    sqlite3VdbeAddOp2($5, 84, 1, 1);
                    $2 = $2 + 1 | 0;
                    continue;
                   }
                   ;

                  case 37:
                   break label$13;

                  case 19:
                   break label$14;

                  case 20:
                   break label$15;

                  case 11:
                   break label$16;

                  case 8:
                   break label$17;

                  case 16:
                   break label$18;

                  case 28:
                   break label$19;

                  case 31:
                   break label$20;

                  case 15:
                   break label$21;

                  case 14:
                   break label$22;

                  case 7:
                   break label$23;

                  case 21:
                   break label$24;

                  case 13:
                   break label$25;

                  case 1:
                   break label$27;
                  }
                 }
                 $1 = HEAP32[$3 + 8 >> 2];
                 sqlite3VdbeUsesBtree($5, $8);
                 if (!(!$10 | HEAPU8[$3 + 5 | 0] & 8)) {
                  $2 = sqlite3VdbeAddOpList($5, 2, 49448);
                  HEAP32[$2 + 4 >> 2] = $8;
                  HEAP32[$2 + 28 >> 2] = $1;
                  HEAP32[$2 + 24 >> 2] = $8;
                  $5 = sqlite3Atoi($10);
                  HEAP16[$2 + 22 >> 1] = 1;
                  HEAP32[$2 + 32 >> 2] = $5;
                  break label$3;
                 }
                 $2 = sqlite3VdbeAddOpList($5, 3, 49456);
                 HEAP32[$2 + 4 >> 2] = $8;
                 HEAP32[$2 + 32 >> 2] = $1;
                 HEAP32[$2 + 24 >> 2] = $8;
                }
                sqlite3VdbeReusable($5);
                break label$3;
               }
               if (!$10) {
                if (sqlite3ReadSchema($0)) {
                 break label$3;
                }
                returnSingleText($5, HEAP32[(HEAPU8[HEAP32[$0 >> 2] + 84 | 0] << 3) + 49376 >> 2]);
                break label$3;
               }
               if (HEAPU8[$7 + 24 | 0] & 64) {
                break label$3;
               }
               $2 = 49376;
               label$133: {
                while (1) {
                 $5 = HEAP32[$2 >> 2];
                 if (!$5) {
                  break label$133;
                 }
                 if (sqlite3StrICmp($10, $5)) {
                  $2 = $2 + 8 | 0;
                  continue;
                 }
                 break;
                }
                $5 = HEAPU8[$2 + 4 | 0];
                $5 = $5 ? $5 : 2;
                HEAP8[HEAP32[HEAP32[$7 + 16 >> 2] + 12 >> 2] + 77 | 0] = $5;
                sqlite3SetTextEncoding($7, $5);
                if (HEAP32[$2 >> 2]) {
                 break label$3;
                }
               }
               HEAP32[$6 + 352 >> 2] = $10;
               sqlite3ErrorMsg($0, 7470, $6 + 352 | 0);
               break label$3;
              }
              $1 = HEAPU8[$20 | 0];
              $2 = HEAP32[$2 >> 2];
              HEAP32[$0 + 44 >> 2] = 6;
              $23 = 100;
              HEAP32[$6 + 408 >> 2] = 100;
              $24 = $2 ? $8 : -1;
              label$136: {
               if (!$10) {
                break label$136;
               }
               if (sqlite3GetInt32($10, $6 + 408 | 0)) {
                $2 = HEAP32[$6 + 408 >> 2];
                $23 = ($2 | 0) <= 0 ? 100 : $2;
                HEAP32[$6 + 408 >> 2] = $23;
                break label$136;
               }
               $2 = 0;
               $2 = ($24 | 0) >= 0 ? HEAP32[HEAP32[$7 + 16 >> 2] + ($24 << 4) >> 2] : $2;
               $18 = sqlite3LocateTable($0, 0, $10, $2);
               $23 = HEAP32[$6 + 408 >> 2];
              }
              $25 = $1 & -33;
              sqlite3VdbeAddOp2($5, 71, $23 - 1 | 0, 1);
              $26 = ($18 | 0) != 0;
              while (1) {
               label$140: {
                if (HEAP32[$7 + 20 >> 2] <= ($21 | 0)) {
                 break label$140;
                }
                label$141: {
                 if (($21 | 0) != ($24 | 0) & ($24 | 0) >= 0) {
                  break label$141;
                 }
                 sqlite3CodeVerifySchema($0, $21);
                 $1 = 0;
                 $13 = $21 << 4;
                 $9 = HEAP32[($13 + HEAP32[$7 + 16 >> 2] | 0) + 12 >> 2] + 16 | 0;
                 $2 = $9;
                 $8 = 0;
                 while (1) {
                  $2 = HEAP32[$2 >> 2];
                  if ($2) {
                   $4 = HEAP32[$2 + 8 >> 2];
                   if (($18 | 0) != ($4 | 0) ? $18 : 0) {
                    continue;
                   }
                   $3 = $4 + 8 | 0;
                   $1 = ((HEAP32[$4 + 28 >> 2] ^ -1) >>> 7 & 1) + $1 | 0;
                   $4 = 0;
                   while (1) {
                    $3 = HEAP32[$3 >> 2];
                    if ($3) {
                     $4 = $4 + 1 | 0;
                     $3 = $3 + 20 | 0;
                     $1 = $1 + 1 | 0;
                     continue;
                    }
                    break;
                   }
                   $8 = ($4 | 0) > ($8 | 0) ? $4 : $8;
                   continue;
                  }
                  break;
                 }
                 if (!$1) {
                  break label$141;
                 }
                 $3 = sqlite3DbMallocRawNN($7, ($1 + $26 << 2) + 4 | 0, 0);
                 if (!$3) {
                  break label$140;
                 }
                 if ($18) {
                  HEAP32[$3 + 4 >> 2] = 0;
                  $4 = 1;
                 } else {
                  $4 = 0;
                 }
                 $2 = $9;
                 label$148: while (1) {
                  $2 = HEAP32[$2 >> 2];
                  if ($2) {
                   $1 = HEAP32[$2 + 8 >> 2];
                   if (($18 | 0) != ($1 | 0) ? $18 : 0) {
                    continue;
                   }
                   if (!(HEAPU8[$1 + 28 | 0] & 128)) {
                    $4 = $4 + 1 | 0;
                    HEAP32[($4 << 2) + $3 >> 2] = HEAP32[$1 + 20 >> 2];
                   }
                   $1 = $1 + 8 | 0;
                   while (1) {
                    $1 = HEAP32[$1 >> 2];
                    if (!$1) {
                     continue label$148;
                    }
                    $4 = $4 + 1 | 0;
                    HEAP32[($4 << 2) + $3 >> 2] = HEAP32[$1 + 44 >> 2];
                    $1 = $1 + 20 | 0;
                    continue;
                   }
                  }
                  break;
                 }
                 HEAP32[$3 >> 2] = $4;
                 $2 = HEAP32[$0 + 44 >> 2];
                 $1 = $8 + 8 | 0;
                 HEAP32[$0 + 44 >> 2] = ($1 | 0) < ($2 | 0) ? $2 : $1;
                 sqlite3ClearTempRegCache($0);
                 sqlite3VdbeAddOp4($5, 155, 2, $4, 1, $3, -14);
                 sqlite3VdbeChangeP5($5, $21 & 255);
                 $2 = sqlite3VdbeAddOp1($5, 50, 2);
                 HEAP32[$6 + 336 >> 2] = HEAP32[HEAP32[$7 + 16 >> 2] + $13 >> 2];
                 sqlite3VdbeAddOp4($5, 117, 0, 3, 0, sqlite3MPrintf($7, 29600, $6 + 336 | 0), -6);
                 sqlite3VdbeAddOp3($5, 111, 2, 3, 3);
                 integrityCheckResultRow($5);
                 sqlite3VdbeJumpHere($5, $2);
                 label$152: while (1) {
                  $9 = HEAP32[$9 >> 2];
                  if (!$9) {
                   break label$141;
                  }
                  $3 = HEAP32[$9 + 8 >> 2];
                  if (HEAPU8[$3 + 43 | 0] | !(!$18 | ($3 | 0) == ($18 | 0))) {
                   continue;
                  }
                  $2 = 0;
                  $16 = 0;
                  if (HEAPU8[$3 + 28 | 0] & 128) {
                   $16 = sqlite3PrimaryKeyIndex($3);
                  }
                  sqlite3OpenTableAndIndices($0, $3, 112, 0, 1, 0, $6 + 404 | 0, $6 + 400 | 0);
                  sqlite3VdbeAddOp2($5, 71, 0, 7);
                  $11 = $3 + 8 | 0;
                  $1 = $11;
                  while (1) {
                   $1 = HEAP32[$1 >> 2];
                   if ($1) {
                    sqlite3VdbeAddOp2($5, 71, 0, $2 + 8 | 0);
                    $2 = $2 + 1 | 0;
                    $1 = $1 + 20 | 0;
                    continue;
                   }
                   break;
                  }
                  sqlite3VdbeAddOp2($5, 35, HEAP32[$6 + 404 >> 2], 0);
                  $19 = sqlite3VdbeAddOp2($5, 86, 7, 1);
                  $22 = ($25 & 255) == 81;
                  if (!$22) {
                   sqlite3VdbeAddOp3($5, 94, HEAP32[$6 + 404 >> 2], HEAP16[$3 + 36 >> 1] - 1 | 0, 3);
                   sqlite3VdbeChangeP5($5, 128);
                  }
                  $4 = HEAP32[$3 + 28 >> 2] & 65536;
                  $2 = 0;
                  while (1) {
                   if (($2 | 0) < HEAP16[$3 + 34 >> 1]) {
                    label$159: {
                     if (HEAP16[$3 + 32 >> 1] == ($2 | 0)) {
                      break label$159;
                     }
                     $13 = Math_imul($2, 12);
                     $1 = $13 + HEAP32[$3 + 4 >> 2] | 0;
                     if (!($4 ? 1 : HEAPU8[$1 + 4 | 0] & 15)) {
                      break label$159;
                     }
                     $14 = 0;
                     if ($4) {
                      $14 = sqlite3VdbeMakeLabel($0);
                     }
                     $12 = $1;
                     sqlite3ExprCodeGetColumnOfTable($5, $3, HEAP32[$6 + 404 >> 2], $2, 3);
                     if (HEAPU8[sqlite3VdbeGetOp($5, -1) | 0] == 94) {
                      sqlite3VdbeChangeP5($5, 128);
                     }
                     if (HEAPU8[$12 + 4 | 0] & 15) {
                      $17 = sqlite3VdbeAddOp1($5, 51, 3);
                      $15 = HEAP32[$3 >> 2];
                      HEAP32[$6 + 308 >> 2] = HEAP32[$1 >> 2];
                      HEAP32[$6 + 304 >> 2] = $15;
                      sqlite3VdbeAddOp4($5, 117, 0, 3, 0, sqlite3MPrintf($7, 5964, $6 + 304 | 0), -6);
                      label$163: {
                       if (!(!$4 | (HEAPU8[$12 + 4 | 0] & 240) == 16)) {
                        sqlite3VdbeGoto($5, $14);
                        break label$163;
                       }
                       integrityCheckResultRow($5);
                      }
                      sqlite3VdbeJumpHere($5, $17);
                     }
                     if (!(HEAP8[$3 + 30 | 0] & 1)) {
                      break label$159;
                     }
                     $1 = HEAPU8[$12 + 4 | 0] >>> 4 | 0;
                     if (($1 | 0) == 1) {
                      break label$159;
                     }
                     $1 = sqlite3VdbeAddOp3($5, 17, 3, 0, HEAP8[$1 + 49327 | 0]);
                     $8 = HEAP32[(HEAPU8[$12 + 4 | 0] >>> 2 & 60) + 65324 >> 2];
                     $17 = HEAP32[$3 >> 2];
                     HEAP32[$6 + 296 >> 2] = HEAP32[HEAP32[$3 + 4 >> 2] + $13 >> 2];
                     HEAP32[$6 + 292 >> 2] = $17;
                     HEAP32[$6 + 288 >> 2] = $8;
                     sqlite3VdbeAddOp4($5, 117, 0, 3, 0, sqlite3MPrintf($7, 5942, $6 + 288 | 0), -6);
                     sqlite3VdbeResolveLabel($5, $14);
                     integrityCheckResultRow($5);
                     sqlite3VdbeJumpHere($5, $1);
                    }
                    $2 = $2 + 1 | 0;
                    continue;
                   }
                   break;
                  }
                  $2 = HEAP32[$3 + 16 >> 2];
                  if (!(!$2 | HEAPU8[$7 + 33 | 0] & 2)) {
                   $1 = sqlite3ExprListDup($7, $2, 0);
                   if (!HEAPU8[$7 + 87 | 0]) {
                    $4 = sqlite3VdbeMakeLabel($0);
                    $8 = sqlite3VdbeMakeLabel($0);
                    HEAP32[$0 + 52 >> 2] = HEAP32[$6 + 404 >> 2] + 1;
                    $2 = HEAP32[$1 >> 2];
                    while (1) {
                     if (($2 | 0) >= 2) {
                      $2 = $2 - 1 | 0;
                      sqlite3ExprIfFalse($0, HEAP32[(($2 << 4) + $1 | 0) + 8 >> 2], $4, 0);
                      continue;
                     }
                     break;
                    }
                    sqlite3ExprIfTrue($0, HEAP32[$1 + 8 >> 2], $8, 16);
                    sqlite3VdbeResolveLabel($5, $4);
                    HEAP32[$0 + 52 >> 2] = 0;
                    HEAP32[$6 + 320 >> 2] = HEAP32[$3 >> 2];
                    sqlite3VdbeAddOp4($5, 117, 0, 3, 0, sqlite3MPrintf($7, 6231, $6 + 320 | 0), -6);
                    integrityCheckResultRow($5);
                    sqlite3VdbeResolveLabel($5, $8);
                   }
                   sqlite3ExprListDelete($7, $1);
                  }
                  if ($22) {
                   sqlite3VdbeAddOp2($5, 38, HEAP32[$6 + 404 >> 2], $19);
                   sqlite3VdbeJumpHere($5, $19 - 1 | 0);
                   continue;
                  } else {
                   $8 = -1;
                   $14 = 0;
                   $2 = $11;
                   $4 = 0;
                   while (1) {
                    $1 = HEAP32[$2 >> 2];
                    if ($1) {
                     $2 = sqlite3VdbeMakeLabel($0);
                     if (($1 | 0) != ($16 | 0)) {
                      $8 = sqlite3GenerateIndexKey($0, $1, HEAP32[$6 + 404 >> 2], 0, 0, $6 + 396 | 0, $4, $8);
                      sqlite3VdbeAddOp2($5, 86, $14 + 8 | 0, 1);
                      $2 = sqlite3VdbeAddOp4Int($5, 28, HEAP32[$6 + 400 >> 2] + $14 | 0, $2, $8, HEAPU16[$1 + 52 >> 1]);
                      sqlite3VdbeLoadString($5, 3, 29034);
                      sqlite3VdbeAddOp3($5, 111, 7, 3, 3);
                      sqlite3VdbeLoadString($5, 4, 29013);
                      sqlite3VdbeAddOp3($5, 111, 4, 3, 3);
                      $15 = sqlite3VdbeLoadString($5, 4, HEAP32[$1 >> 2]);
                      sqlite3VdbeAddOp3($5, 111, 4, 3, 3);
                      $17 = integrityCheckResultRow($5);
                      sqlite3VdbeJumpHere($5, $2);
                      if (HEAPU8[$1 + 54 | 0]) {
                       $2 = 0;
                       $13 = sqlite3VdbeMakeLabel($0);
                       while (1) {
                        if ($2 >>> 0 < HEAPU16[$1 + 50 >> 1]) {
                         $4 = HEAP16[HEAP32[$1 + 4 >> 2] + ($2 << 1) >> 1];
                         if (!(HEAPU8[(HEAP32[$3 + 4 >> 2] + Math_imul($4 & 65535, 12) | 0) + 4 | 0] & 15 ? ($4 | 0) >= 0 : 0)) {
                          sqlite3VdbeAddOp2($5, 50, $2 + $8 | 0, $13);
                         }
                         $2 = $2 + 1 | 0;
                         continue;
                        }
                        break;
                       }
                       $2 = sqlite3VdbeAddOp1($5, 38, HEAP32[$6 + 400 >> 2] + $14 | 0);
                       sqlite3VdbeGoto($5, $13);
                       sqlite3VdbeJumpHere($5, $2);
                       sqlite3VdbeAddOp4Int($5, 40, HEAP32[$6 + 400 >> 2] + $14 | 0, $13, $8, HEAPU16[$1 + 50 >> 1]);
                       sqlite3VdbeLoadString($5, 3, 28957);
                       sqlite3VdbeGoto($5, $15);
                       sqlite3VdbeResolveLabel($5, $13);
                      }
                      sqlite3VdbeJumpHere($5, $17);
                      sqlite3ResolvePartIdxLabel($0, HEAP32[$6 + 396 >> 2]);
                      $4 = $1;
                     }
                     $14 = $14 + 1 | 0;
                     $2 = $1 + 20 | 0;
                     continue;
                    }
                    break;
                   }
                   sqlite3VdbeAddOp2($5, 38, HEAP32[$6 + 404 >> 2], $19);
                   sqlite3VdbeJumpHere($5, $19 - 1 | 0);
                   sqlite3VdbeLoadString($5, 2, 28984);
                   $1 = 0;
                   while (1) {
                    $2 = HEAP32[$11 >> 2];
                    if (!$2) {
                     continue label$152;
                    }
                    if (($2 | 0) != ($16 | 0)) {
                     sqlite3VdbeAddOp2($5, 98, HEAP32[$6 + 400 >> 2] + $1 | 0, 3);
                     $4 = sqlite3VdbeAddOp3($5, 53, $1 + 8 | 0, 0, 3);
                     sqlite3VdbeChangeP5($5, 144);
                     sqlite3VdbeLoadString($5, 4, HEAP32[$2 >> 2]);
                     sqlite3VdbeAddOp3($5, 111, 4, 2, 3);
                     integrityCheckResultRow($5);
                     sqlite3VdbeJumpHere($5, $4);
                    }
                    $1 = $1 + 1 | 0;
                    $11 = $2 + 20 | 0;
                    continue;
                   }
                  }
                 }
                }
                $21 = $21 + 1 | 0;
                continue;
               }
               break;
              }
              $2 = sqlite3VdbeAddOpList($5, 7, 49344);
              if ($2) {
               HEAP8[$2 + 101 | 0] = 255;
               HEAP32[$2 + 56 >> 2] = 11338;
               HEAP8[$2 + 41 | 0] = 255;
               HEAP32[$2 + 8 >> 2] = 1 - $23;
               HEAP32[$2 + 116 >> 2] = sqlite3ErrStr(11);
              }
              sqlite3VdbeChangeP3($5, 0, sqlite3VdbeCurrentAddr($5) - 2 | 0);
              break label$3;
             }
             if (!$10) {
              break label$3;
             }
             sqlite3RegisterLikeFunctions($7, sqlite3GetBoolean($10, 0));
             break label$3;
            }
            $2 = HEAP32[$0 + 44 >> 2];
            $14 = $2 + 5 | 0;
            HEAP32[$0 + 44 >> 2] = $14;
            $18 = $2 + 3 | 0;
            $9 = $2 + 2 | 0;
            $15 = $2 + 1 | 0;
            $11 = HEAP32[HEAP32[(HEAP32[$7 + 16 >> 2] + ($8 << 4) | 0) + 12 >> 2] + 16 >> 2];
            while (1) {
             if (!$11) {
              break label$3;
             }
             label$183: {
              if ($10) {
               $1 = 0;
               $8 = sqlite3LocateTable($0, 0, $10, $4);
               break label$183;
              }
              $1 = HEAP32[$11 >> 2];
              $8 = HEAP32[$11 + 8 >> 2];
             }
             $11 = $1;
             if (HEAPU8[$8 + 43 | 0] | !$8) {
              continue;
             }
             $2 = $8 + 48 | 0;
             if (!HEAP32[$2 >> 2]) {
              continue;
             }
             $1 = HEAP32[$7 + 16 >> 2];
             $16 = sqlite3SchemaToIndex($7, HEAP32[$8 + 60 >> 2]);
             $4 = HEAP32[$1 + ($16 << 4) >> 2];
             sqlite3CodeVerifySchema($0, $16);
             sqlite3TableLock($0, $16, HEAP32[$8 + 20 >> 2], 0, HEAP32[$8 >> 2]);
             $1 = HEAP16[$8 + 34 >> 1] + $14 | 0;
             if (($1 | 0) > HEAP32[$0 + 44 >> 2]) {
              HEAP32[$0 + 44 >> 2] = $1;
             }
             sqlite3OpenTable($0, 0, $16, $8, 112);
             sqlite3VdbeLoadString($5, $15, HEAP32[$8 >> 2]);
             $13 = 1;
             $1 = $2;
             while (1) {
              $1 = HEAP32[$1 >> 2];
              if ($1) {
               $3 = sqlite3FindTable($7, HEAP32[$1 + 8 >> 2], $4);
               label$188: {
                if (!$3) {
                 break label$188;
                }
                HEAP32[$6 + 408 >> 2] = 0;
                sqlite3TableLock($0, $16, HEAP32[$3 + 20 >> 2], 0, HEAP32[$3 >> 2]);
                if (sqlite3FkLocateIndex($0, $3, $1, $6 + 408 | 0, 0)) {
                 break label$3;
                }
                $17 = HEAP32[$6 + 408 >> 2];
                if (!$17) {
                 sqlite3OpenTable($0, $13, $16, $3, 112);
                 break label$188;
                }
                sqlite3VdbeAddOp3($5, 112, $13, HEAP32[$17 + 44 >> 2], $16);
                sqlite3VdbeSetP4KeyInfo($0, $17);
               }
               $1 = $1 + 4 | 0;
               $13 = $13 + 1 | 0;
               continue;
              }
              break;
             }
             if (HEAP32[$0 + 40 >> 2] < ($13 | 0)) {
              HEAP32[$0 + 40 >> 2] = $13;
             }
             $16 = 1;
             $19 = sqlite3VdbeAddOp1($5, 35, 0);
             while (1) {
              $1 = HEAP32[$2 >> 2];
              if ($1) {
               $17 = sqlite3FindTable($7, HEAP32[$1 + 8 >> 2], $4);
               HEAP32[$6 + 404 >> 2] = 0;
               HEAP32[$6 + 408 >> 2] = 0;
               if ($17) {
                sqlite3FkLocateIndex($0, $17, $1, $6 + 408 | 0, $6 + 404 | 0);
               }
               $13 = sqlite3VdbeMakeLabel($0);
               $3 = HEAP32[$1 + 20 >> 2];
               $2 = $14 + $3 | 0;
               if (($2 | 0) > HEAP32[$0 + 44 >> 2]) {
                HEAP32[$0 + 44 >> 2] = $2;
               }
               $2 = 0;
               while (1) {
                if (($2 | 0) < ($3 | 0)) {
                 $3 = HEAP32[$6 + 404 >> 2];
                 $12 = HEAP32[($3 ? $3 + ($2 << 2) | 0 : (($2 << 3) + $1 | 0) + 36 | 0) >> 2];
                 $3 = $2 + $14 | 0;
                 sqlite3ExprCodeGetColumnOfTable($5, $8, 0, $12, $3);
                 sqlite3VdbeAddOp2($5, 50, $3, $13);
                 $2 = $2 + 1 | 0;
                 $3 = HEAP32[$1 + 20 >> 2];
                 continue;
                }
                break;
               }
               $2 = HEAP32[$6 + 408 >> 2];
               label$197: {
                if ($2) {
                 sqlite3VdbeAddOp4($5, 96, $14, $3, 0, sqlite3IndexAffinityStr($7, $2), HEAP32[$1 + 20 >> 2]);
                 sqlite3VdbeAddOp4Int($5, 28, $16, $13, $14, HEAP32[$1 + 20 >> 2]);
                 break label$197;
                }
                if (!$17) {
                 break label$197;
                }
                sqlite3VdbeAddOp3($5, 29, $16, sqlite3VdbeCurrentAddr($5) + 2 | 0, $14);
                sqlite3VdbeGoto($5, $13);
               }
               sqlite3VdbeAddOp2($5, HEAP32[$8 + 28 >> 2] & 128 ? 75 : 135, 0, $9);
               $2 = HEAP32[$1 + 8 >> 2];
               HEAP32[$6 + 276 >> 2] = $16 - 1;
               HEAP32[$6 + 272 >> 2] = $2;
               sqlite3VdbeMultiLoad($5, $18, 18118, $6 + 272 | 0);
               sqlite3VdbeAddOp2($5, 84, $15, 4);
               sqlite3VdbeResolveLabel($5, $13);
               sqlite3DbFree($7, HEAP32[$6 + 404 >> 2]);
               $2 = $1 + 4 | 0;
               $16 = $16 + 1 | 0;
               continue;
              }
              break;
             }
             sqlite3VdbeAddOp2($5, 38, 0, $19 + 1 | 0);
             sqlite3VdbeJumpHere($5, $19);
             continue;
            }
           }
           if (!$10) {
            break label$3;
           }
           $11 = sqlite3FindTable($7, $10, $4);
           if (!$11 | HEAPU8[$11 + 43 | 0]) {
            break label$3;
           }
           $2 = HEAP32[$11 + 48 >> 2];
           if (!$2) {
            break label$3;
           }
           $1 = sqlite3SchemaToIndex($7, HEAP32[$11 + 60 >> 2]);
           HEAP32[$0 + 44 >> 2] = 8;
           sqlite3CodeVerifySchema($0, $1);
           $14 = 0;
           while (1) {
            if (!$2) {
             break label$3;
            }
            $1 = 0;
            while (1) {
             if (($1 | 0) < HEAP32[$2 + 20 >> 2]) {
              $4 = ($1 << 3) + $2 | 0;
              $0 = HEAP32[HEAP32[$11 + 4 >> 2] + Math_imul(HEAP32[$4 + 36 >> 2], 12) >> 2];
              $4 = HEAP32[$4 + 40 >> 2];
              $3 = HEAP32[$2 + 8 >> 2];
              $8 = actionName(HEAPU8[$2 + 26 | 0]);
              $13 = HEAPU8[$2 + 25 | 0];
              HEAP32[$6 + 268 >> 2] = 19779;
              HEAP32[$6 + 264 >> 2] = actionName($13);
              HEAP32[$6 + 260 >> 2] = $8;
              HEAP32[$6 + 256 >> 2] = $4;
              HEAP32[$6 + 252 >> 2] = $0;
              HEAP32[$6 + 248 >> 2] = $3;
              HEAP32[$6 + 244 >> 2] = $1;
              HEAP32[$6 + 240 >> 2] = $14;
              sqlite3VdbeMultiLoad($5, 1, 3923, $6 + 240 | 0);
              $1 = $1 + 1 | 0;
              continue;
             }
             break;
            }
            $14 = $14 + 1 | 0;
            $2 = HEAP32[$2 + 4 >> 2];
            continue;
           }
          }
          while (1) {
           if (($13 | 0) == 66) {
            break label$3;
           }
           HEAP32[$6 + 224 >> 2] = HEAP32[($13 << 4) + 34544 >> 2];
           sqlite3VdbeMultiLoad($5, 1, 8343, $6 + 224 | 0);
           $13 = $13 + 1 | 0;
           continue;
          }
         }
         HEAP32[$0 + 44 >> 2] = 1;
         $2 = $7 + 392 | 0;
         while (1) {
          $2 = HEAP32[$2 >> 2];
          if (!$2) {
           break label$3;
          }
          HEAP32[$6 + 208 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2];
          sqlite3VdbeMultiLoad($5, 1, 8343, $6 + 208 | 0);
          continue;
         }
        }
        $2 = HEAP32[$7 + 24 >> 2];
        HEAP32[$0 + 44 >> 2] = 6;
        $1 = $2 >>> 5 & 1;
        $4 = 0;
        while (1) {
         if (($4 | 0) != 23) {
          $2 = ($4 << 2) + 70768 | 0;
          while (1) {
           $2 = HEAP32[$2 >> 2];
           if ($2) {
            pragmaFunclistLine($5, $2, 1, $1);
            $2 = $2 + 36 | 0;
            continue;
           }
           break;
          }
          $4 = $4 + 1 | 0;
          continue;
         }
         break;
        }
        $2 = $7 + 420 | 0;
        while (1) {
         $2 = HEAP32[$2 >> 2];
         if (!$2) {
          break label$3;
         }
         pragmaFunclistLine($5, HEAP32[$2 + 8 >> 2], 0, $1);
         continue;
        }
       }
       HEAP32[$0 + 44 >> 2] = 2;
       $2 = $7 + 436 | 0;
       $1 = 0;
       while (1) {
        $2 = HEAP32[$2 >> 2];
        if (!$2) {
         break label$3;
        }
        HEAP32[$6 + 196 >> 2] = HEAP32[HEAP32[$2 + 8 >> 2] >> 2];
        HEAP32[$6 + 192 >> 2] = $1;
        sqlite3VdbeMultiLoad($5, 1, 5e3, $6 + 192 | 0);
        $1 = $1 + 1 | 0;
        continue;
       }
      }
      HEAP32[$0 + 44 >> 2] = 3;
      $2 = 0;
      while (1) {
       if (HEAP32[$7 + 20 >> 2] <= ($2 | 0)) {
        break label$3;
       }
       $1 = HEAP32[$7 + 16 >> 2] + ($2 << 4) | 0;
       $4 = HEAP32[$1 + 4 >> 2];
       if ($4) {
        $1 = HEAP32[$1 >> 2];
        HEAP32[$6 + 184 >> 2] = sqlite3BtreeGetFilename($4);
        HEAP32[$6 + 180 >> 2] = $1;
        HEAP32[$6 + 176 >> 2] = $2;
        sqlite3VdbeMultiLoad($5, 1, 3932, $6 + 176 | 0);
       }
       $2 = $2 + 1 | 0;
       continue;
      }
     }
     if (!$10) {
      break label$3;
     }
     $2 = sqlite3FindTable($7, $10, $4);
     if (!$2) {
      break label$3;
     }
     $1 = sqlite3SchemaToIndex($7, HEAP32[$2 + 60 >> 2]);
     HEAP32[$0 + 44 >> 2] = 5;
     sqlite3CodeVerifySchema($0, $1);
     $2 = $2 + 8 | 0;
     $1 = 0;
     while (1) {
      $2 = HEAP32[$2 >> 2];
      if (!$2) {
       break label$3;
      }
      $4 = HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8;
      $0 = HEAPU8[$2 + 54 | 0];
      $3 = HEAP32[$2 >> 2];
      HEAP32[$6 + 160 >> 2] = HEAP32[$2 + 36 >> 2] != 0;
      HEAP32[$6 + 148 >> 2] = $3;
      HEAP32[$6 + 152 >> 2] = ($0 | 0) != 0;
      HEAP32[$6 + 156 >> 2] = HEAP32[(($4 & 3) << 2) + 49316 >> 2];
      HEAP32[$6 + 144 >> 2] = $1;
      sqlite3VdbeMultiLoad($5, 1, 11582, $6 + 144 | 0);
      $2 = $2 + 20 | 0;
      $1 = $1 + 1 | 0;
      continue;
     }
    }
    if (!$10) {
     break label$3;
    }
    $1 = sqlite3FindIndex($7, $10, $4);
    if (!$1) {
     $2 = sqlite3LocateTable($0, 2, $10, $4);
     if (!$2 | !(HEAPU8[$2 + 28 | 0] & 128)) {
      break label$3;
     }
     $1 = sqlite3PrimaryKeyIndex($2);
     if (!$1) {
      break label$3;
     }
    }
    $2 = sqlite3SchemaToIndex($7, HEAP32[$1 + 24 >> 2]);
    $9 = HEAP32[$3 + 8 >> 2];
    $12 = HEAP32[$3 + 12 >> 2];
    $4 = !($9 | $12);
    $13 = HEAPU16[($4 ? 50 : 52) + $1 >> 1];
    HEAP32[$0 + 44 >> 2] = $4 ? 3 : 6;
    $14 = HEAP32[$1 + 12 >> 2];
    sqlite3CodeVerifySchema($0, $2);
    $2 = 0;
    while (1) {
     if (($2 | 0) == ($13 | 0)) {
      break label$3;
     }
     $4 = 0;
     $8 = HEAP16[HEAP32[$1 + 4 >> 2] + ($2 << 1) >> 1];
     if (($8 | 0) >= 0) {
      $4 = HEAP32[HEAP32[$14 + 4 >> 2] + Math_imul($8, 12) >> 2];
     }
     HEAP32[$6 + 136 >> 2] = $4;
     HEAP32[$6 + 132 >> 2] = $8;
     HEAP32[$6 + 128 >> 2] = $2;
     sqlite3VdbeMultiLoad($5, 1, 18112, $6 + 128 | 0);
     $12 = HEAP32[$3 + 8 >> 2];
     $9 = HEAP32[$3 + 12 >> 2];
     if ($12 | $9) {
      $4 = HEAPU8[HEAP32[$1 + 28 >> 2] + $2 | 0];
      $8 = HEAP32[HEAP32[$1 + 32 >> 2] + ($2 << 2) >> 2];
      HEAP32[$6 + 120 >> 2] = HEAPU16[$1 + 50 >> 1] > $2 >>> 0;
      HEAP32[$6 + 116 >> 2] = $8;
      HEAP32[$6 + 112 >> 2] = $4;
      sqlite3VdbeMultiLoad($5, 4, 18117, $6 + 112 | 0);
     }
     sqlite3VdbeAddOp2($5, 84, 1, HEAP32[$0 + 44 >> 2]);
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   HEAP32[$0 + 44 >> 2] = 6;
   sqlite3CodeVerifyNamedSchema($0, $4);
   while (1) {
    if (HEAP32[$7 + 20 >> 2] <= ($16 | 0)) {
     break label$3;
    }
    $2 = HEAP32[$7 + 16 >> 2];
    label$218: {
     if ($4) {
      if (sqlite3_stricmp($4, HEAP32[($16 << 4) + $2 >> 2])) {
       break label$218;
      }
     }
     $14 = $16 << 4;
     $8 = HEAP32[($14 + $2 | 0) + 12 >> 2];
     $0 = HEAP32[$8 + 12 >> 2];
     while (1) {
      $3 = $8 + 16 | 0;
      label$221: {
       label$222: while (1) {
        $2 = $3;
        if (!$0) {
         break label$221;
        }
        while (1) {
         $2 = HEAP32[$2 >> 2];
         if (!$2) {
          $0 = 0;
          continue label$222;
         }
         $1 = HEAP32[$2 + 8 >> 2];
         if (HEAPU16[$1 + 34 >> 1]) {
          continue;
         }
         break;
        }
        break;
       }
       HEAP32[$6 + 96 >> 2] = HEAP32[$1 >> 2];
       $2 = sqlite3MPrintf($7, 28301, $6 + 96 | 0);
       if ($2) {
        HEAP32[$6 + 408 >> 2] = 0;
        sqlite3_prepare($7, $2, -1, $6 + 408 | 0, 0);
        sqlite3_finalize(HEAP32[$6 + 408 >> 2]);
        sqlite3DbFree($7, $2);
       }
       if (HEAPU8[$7 + 87 | 0]) {
        sqlite3ErrorMsg(HEAP32[$7 + 264 >> 2], 1141, 0);
        HEAP32[HEAP32[$7 + 264 >> 2] + 12 >> 2] = 7;
       }
       $0 = $0 - 1 | 0;
       $8 = HEAP32[(HEAP32[$7 + 16 >> 2] + $14 | 0) + 12 >> 2];
       continue;
      }
      break;
     }
     $1 = $8 + 16 | 0;
     while (1) {
      $1 = HEAP32[$1 >> 2];
      if (!$1) {
       break label$218;
      }
      $2 = HEAP32[$1 + 8 >> 2];
      if ($10) {
       if (sqlite3_stricmp($10, HEAP32[$2 >> 2])) {
        continue;
       }
      }
      $0 = 1826;
      label$229: {
       label$230: {
        switch (HEAPU8[$2 + 43 | 0] - 1 | 0) {
        case 0:
         $0 = 11239;
         break label$229;

        case 1:
         break label$229;

        default:
         break label$230;
        }
       }
       $0 = HEAPU8[$2 + 29 | 0] & 16 ? 1698 : 13666;
      }
      $3 = HEAP32[HEAP32[$7 + 16 >> 2] + $14 >> 2];
      $8 = sqlite3PreferredTableName(HEAP32[$2 >> 2]);
      $13 = HEAP16[$2 + 34 >> 1];
      $2 = HEAP32[$2 + 28 >> 2];
      HEAP32[$6 + 84 >> 2] = $2 >>> 16 & 1;
      HEAP32[$6 + 80 >> 2] = $2 >>> 7 & 1;
      HEAP32[$6 + 76 >> 2] = $13;
      HEAP32[$6 + 72 >> 2] = $0;
      HEAP32[$6 + 68 >> 2] = $8;
      HEAP32[$6 + 64 >> 2] = $3;
      sqlite3VdbeMultiLoad($5, 1, 11614, $6 - -64 | 0);
      continue;
     }
    }
    $16 = $16 + 1 | 0;
    continue;
   }
  }
  sqlite3DbFree($7, $20);
  sqlite3DbFree($7, $10);
 }
 __stack_pointer = $6 + 448 | 0;
}

function sqlite3_str_vappendf($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 $4 = __stack_pointer - 368 | 0;
 __stack_pointer = $4;
 $28 = HEAPU8[$0 + 21 | 0] & 2;
 if ($28) {
  $32 = HEAP32[$2 >> 2];
  $2 = $2 + 4 | 0;
 }
 $25 = $2;
 while (1) {
  label$4: {
   label$5: {
    label$6: {
     label$7: {
      $18 = HEAPU8[$1 | 0];
      label$8: {
       if (($18 | 0) == 37) {
        $18 = $1;
        break label$8;
       }
       $2 = $1;
       if (!$18) {
        break label$7;
       }
       while (1) {
        label$11: {
         $18 = $2 + 1 | 0;
         $8 = HEAPU8[$2 + 1 | 0];
         if (($8 | 0) == 37) {
          break label$11;
         }
         $2 = $18;
         if ($8) {
          continue;
         }
        }
        break;
       }
       sqlite3_str_append($0, $1, $18 - $1 | 0);
       $9 = $1;
       if (!HEAPU8[$18 | 0]) {
        break label$7;
       }
      }
      label$12: {
       label$13: {
        label$14: {
         label$15: {
          label$16: {
           label$17: {
            label$18: {
             label$19: {
              label$20: {
               $2 = HEAPU8[$18 + 1 | 0];
               if ($2) {
                $18 = $18 + 1 | 0;
                $10 = -1;
                $29 = 0;
                $30 = 0;
                $36 = 0;
                $23 = 0;
                $33 = 0;
                $20 = 0;
                $34 = 0;
                $24 = 0;
                $17 = $25;
                label$22: {
                 while (1) {
                  $8 = 1;
                  label$24: {
                   label$25: {
                    label$26: {
                     label$27: {
                      label$28: {
                       label$29: {
                        label$30: {
                         label$31: {
                          label$32: {
                           label$33: {
                            label$34: {
                             label$35: {
                              label$36: {
                               label$37: {
                                $2 = $2 << 24 >> 24;
                                switch ($2 - 32 | 0) {
                                case 2:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 15:
                                 break label$22;

                                case 13:
                                 break label$24;

                                case 14:
                                 break label$26;

                                case 10:
                                 break label$27;

                                case 17:
                                case 18:
                                case 19:
                                case 20:
                                case 21:
                                case 22:
                                case 23:
                                case 24:
                                case 25:
                                 break label$28;

                                case 12:
                                 break label$31;

                                case 16:
                                 break label$32;

                                case 1:
                                 break label$33;

                                case 3:
                                 break label$34;

                                case 0:
                                 break label$35;

                                case 11:
                                 break label$36;

                                default:
                                 break label$37;
                                }
                               }
                               if (($2 | 0) != 108) {
                                break label$22;
                               }
                               $2 = HEAPU8[$18 + 1 | 0];
                               if (($2 | 0) == 108) {
                                break label$30;
                               }
                               $18 = $18 + 1 | 0;
                               $29 = 1;
                               break label$29;
                              }
                              $20 = 43;
                              break label$25;
                             }
                             $20 = 32;
                             break label$25;
                            }
                            $33 = 1;
                            break label$25;
                           }
                           $23 = 1;
                           break label$25;
                          }
                          $36 = 1;
                          break label$25;
                         }
                         $30 = 44;
                         break label$25;
                        }
                        $2 = HEAPU8[$18 + 2 | 0];
                        $18 = $18 + 2 | 0;
                        $29 = 2;
                       }
                       $2 = $2 << 24 >> 24;
                       break label$22;
                      }
                      while (1) {
                       $13 = $18 + 1 | 0;
                       $1 = $2 - 48 | 0;
                       $2 = HEAP8[$18 + 1 | 0];
                       $8 = $2 & 255;
                       if (($2 - 48 & 255) >>> 0 <= 9) {
                        $2 = Math_imul($1, 10) + $8 | 0;
                        $18 = $13;
                        continue;
                       }
                       break;
                      }
                      $24 = $1 & 2147483647;
                      if (($8 | 0) == 46 | ($8 | 0) == 108) {
                       break label$25;
                      }
                      $18 = $13;
                      break label$22;
                     }
                     label$40: {
                      if ($28) {
                       $11 = getIntArg($32);
                       $2 = $11;
                       break label$40;
                      }
                      $2 = HEAP32[$17 >> 2];
                      $17 = $17 + 4 | 0;
                     }
                     $8 = ($2 | 0) < 0;
                     $24 = $8 ? ($2 | 0) == -2147483648 ? 0 : 0 - $2 | 0 : $2;
                     $8 = $8 ? 1 : $34;
                     $2 = HEAPU8[$18 + 1 | 0];
                     if (($2 | 0) == 46 | ($2 | 0) == 108) {
                      break label$24;
                     }
                     $2 = $2 << 24 >> 24;
                     $18 = $18 + 1 | 0;
                     $34 = $8;
                     break label$22;
                    }
                    label$42: {
                     label$43: {
                      $8 = HEAPU8[$18 + 1 | 0];
                      if (($8 | 0) != 42) {
                       $1 = $18 + 1 | 0;
                       $18 = 0;
                       while (1) {
                        $2 = $8 << 24 >> 24;
                        if (($8 - 48 & 255) >>> 0 > 9) {
                         break label$43;
                        }
                        $18 = (Math_imul($18, 10) + $2 | 0) - 48 | 0;
                        $8 = HEAPU8[$1 + 1 | 0];
                        $1 = $1 + 1 | 0;
                        continue;
                       }
                      }
                      label$46: {
                       if ($28) {
                        $6 = getIntArg($32);
                        $2 = $6;
                        break label$46;
                       }
                       $2 = HEAP32[$17 >> 2];
                       $17 = $17 + 4 | 0;
                      }
                      $10 = ($2 | 0) < 0 ? ($2 | 0) == -2147483648 ? -1 : 0 - $2 | 0 : $2;
                      $1 = $18 + 2 | 0;
                      $2 = HEAP8[$18 + 2 | 0];
                      break label$42;
                     }
                     $10 = $18 & 2147483647;
                    }
                    if (($2 | 0) != 108) {
                     $18 = $1;
                     break label$22;
                    }
                    $18 = $1 - 1 | 0;
                   }
                   $8 = $34;
                  }
                  $2 = HEAPU8[$18 + 1 | 0];
                  $34 = $8;
                  $1 = $18 + 1 | 0;
                  $18 = $1;
                  if ($2) {
                   continue;
                  }
                  break;
                 }
                 $2 = 0;
                 $18 = $1;
                }
                $8 = 0;
                while (1) {
                 if (($8 | 0) == 23) {
                  break label$7;
                 }
                 $1 = Math_imul($8, 6);
                 if (HEAP8[$1 + 29632 | 0] != ($2 | 0)) {
                  $8 = $8 + 1 | 0;
                  continue;
                 }
                 break;
                }
                label$51: {
                 label$52: {
                  label$53: {
                   label$54: {
                    label$55: {
                     label$56: {
                      label$57: {
                       label$58: {
                        label$59: {
                         label$60: {
                          label$61: {
                           label$62: {
                            $25 = HEAPU8[$1 + 29635 | 0];
                            switch ($25 | 0) {
                            case 12:
                             break label$51;

                            case 11:
                             break label$53;

                            case 9:
                            case 10:
                            case 14:
                             break label$54;

                            case 5:
                            case 6:
                             break label$55;

                            case 8:
                             break label$56;

                            case 7:
                             break label$57;

                            case 4:
                             break label$58;

                            case 1:
                            case 2:
                            case 3:
                             break label$59;

                            case 16:
                             break label$60;

                            case 0:
                            case 15:
                             break label$61;

                            case 13:
                             break label$62;

                            default:
                             break label$7;
                            }
                           }
                           $29 = 1;
                          }
                          $30 = 0;
                         }
                         label$63: {
                          if (!(4067322 >>> $8 & 1)) {
                           label$65: {
                            if ($28) {
                             $25 = $17;
                             $11 = getIntArg($32);
                             $12 = $11;
                             $6 = i64toi32_i32$HIGH_BITS;
                             break label$65;
                            }
                            if (($29 | 0) == 2) {
                             $2 = $17 + 7 & -8;
                             $25 = $2 + 8 | 0;
                             $6 = HEAP32[$2 >> 2];
                             $12 = $6;
                             $11 = HEAP32[$2 + 4 >> 2];
                             $6 = $11;
                             break label$65;
                            }
                            $25 = $17 + 4 | 0;
                            $5 = $17;
                            $11 = HEAP32[$5 >> 2];
                            $6 = $11 >> 31;
                            $12 = $11;
                           }
                           $14 = $6;
                           $11 = $6 >> 31;
                           $19 = $11;
                           $5 = $6;
                           $5 = $11 ^ $5;
                           $16 = $6 >> 31;
                           $6 = $16;
                           $11 = $6 ^ $12;
                           $15 = $6;
                           $3 = $11 - $6 | 0;
                           $26 = $3;
                           $6 = $19;
                           $7 = $6 + ($11 >>> 0 < $15 >>> 0) | 0;
                           $7 = $5 - $7 | 0;
                           $27 = $7;
                           $7 = $14;
                           $23 = ($7 | 0) < 0 ? 45 : $20;
                           break label$63;
                          }
                          if ($28) {
                           $5 = getIntArg($32);
                           $26 = $5;
                           $7 = i64toi32_i32$HIGH_BITS;
                           $27 = $7;
                           $25 = $17;
                           $23 = 0;
                           break label$63;
                          }
                          label$69: {
                           if (($29 | 0) == 2) {
                            $2 = $17 + 7 & -8;
                            $25 = $2 + 8 | 0;
                            $5 = HEAP32[$2 + 4 >> 2];
                            $3 = $5;
                            $7 = HEAP32[$2 >> 2];
                            $5 = $7;
                            break label$69;
                           }
                           $25 = $17 + 4 | 0;
                           $3 = 0;
                           $5 = HEAP32[$17 >> 2];
                          }
                          $26 = $5;
                          $7 = $3;
                          $27 = $7;
                          $23 = 0;
                         }
                         if ($36) {
                          $2 = $24 - (($23 & 255) != 0) | 0;
                          $10 = ($2 | 0) < ($10 | 0) ? $10 : $2;
                         }
                         label$71: {
                          if (($10 | 0) < 37) {
                           $2 = $4 + 272 | 0;
                           $12 = 70;
                           $20 = 0;
                           break label$71;
                          }
                          $3 = 0;
                          $6 = $10 + 10 | 0;
                          $3 = $6 >>> 0 < 10 ? 1 : $3;
                          $11 = ($10 >>> 0) / 3 | 0;
                          $7 = $6;
                          $5 = $11 + $6 | 0;
                          $6 = $5 >>> 0 < $11 >>> 0 ? $3 + 1 | 0 : $3;
                          $15 = $30 & 255;
                          $11 = $15 ? $5 : $7;
                          $12 = $11;
                          $3 = $15 ? $6 : $3;
                          $14 = $3;
                          $2 = printfTempBuf($0, $12, $3);
                          if (!$2) {
                           break label$7;
                          }
                          $20 = $2;
                         }
                         $13 = $12;
                         $17 = ($13 + $2 | 0) - 1 | 0;
                         $9 = $17;
                         if (($8 | 0) == 22) {
                          $3 = $27;
                          $11 = __wasm_i64_udiv($26, $3, 10, 0);
                          $12 = $11;
                          $3 = i64toi32_i32$HIGH_BITS;
                          $14 = $3;
                          $11 = __wasm_i64_mul($12, $3, 10, 0);
                          $3 = i64toi32_i32$HIGH_BITS;
                          $2 = $3;
                          $15 = $26;
                          $6 = $11;
                          $7 = $15 - $6 | 0;
                          $3 = $27;
                          $11 = $2;
                          $5 = $11 + ($6 >>> 0 > $15 >>> 0) | 0;
                          $5 = $14;
                          $15 = __wasm_i64_urem($12, $5, 10, 0);
                          $3 = $15;
                          $9 = $17 - 2 | 0;
                          $2 = $7;
                          $5 = i64toi32_i32$HIGH_BITS;
                          $2 = ($2 >>> 0 > 3 ? 0 : !$5 & ($3 | 0) == 1 ? 0 : $2) << 1;
                          HEAP8[$9 | 0] = HEAPU8[$2 + 14232 | 0];
                          HEAP8[$17 - 1 | 0] = HEAPU8[$2 + 14233 | 0];
                         }
                         $13 = HEAPU8[$1 + 29636 | 0] + 29776 | 0;
                         $6 = $1 + 29633 | 0;
                         $3 = HEAPU8[$6 | 0];
                         $16 = $3;
                         $12 = $26;
                         $5 = $27;
                         $14 = $5;
                         while (1) {
                          $5 = $14;
                          $3 = __wasm_i64_udiv($12, $5, $16, 0);
                          $21 = $3;
                          $5 = i64toi32_i32$HIGH_BITS;
                          $22 = $5;
                          $3 = __wasm_i64_mul($3, $5, $16, 0);
                          $5 = i64toi32_i32$HIGH_BITS;
                          $2 = $5;
                          $6 = $12;
                          $15 = $3;
                          $11 = $6 - $3 | 0;
                          $5 = $14;
                          $3 = $2;
                          $7 = $3 + ($6 >>> 0 < $15 >>> 0) | 0;
                          $9 = $9 - 1 | 0;
                          HEAP8[$9 | 0] = HEAPU8[$13 + $11 | 0];
                          $7 = $5;
                          $5 = $12;
                          $2 = !$7 & $5 >>> 0 >= $16 >>> 0 | ($7 | 0) != 0;
                          $12 = $21;
                          $5 = $22;
                          $14 = $5;
                          if ($2) {
                           continue;
                          }
                          break;
                         }
                         $2 = $17 - $9 | 0;
                         while (1) {
                          if (($2 | 0) < ($10 | 0)) {
                           $9 = $9 - 1 | 0;
                           HEAP8[$9 | 0] = 48;
                           $2 = $2 + 1 | 0;
                           continue;
                          }
                          break;
                         }
                         label$78: {
                          if (!($30 & 255)) {
                           break label$78;
                          }
                          $2 = $2 - 1 | 0;
                          $13 = ($2 | 0) / 3 | 0;
                          $10 = ($2 - Math_imul($13, 3) | 0) + 1 | 0;
                          $9 = $9 - $13 | 0;
                          $2 = 0;
                          while (1) {
                           if (($13 | 0) <= 0) {
                            break label$78;
                           }
                           HEAP8[$2 + $9 | 0] = HEAPU8[($2 + $13 | 0) + $9 | 0];
                           $10 = $10 - 1 | 0;
                           if (!$10) {
                            $2 = $2 + 1 | 0;
                            HEAP8[$9 + $2 | 0] = $30;
                            $13 = $13 - 1 | 0;
                            $10 = 3;
                           }
                           $2 = $2 + 1 | 0;
                           continue;
                          }
                         }
                         if ($23 & 255) {
                          $9 = $9 - 1 | 0;
                          HEAP8[$9 | 0] = $23;
                         }
                         label$82: {
                          $5 = $27;
                          if (7860991 >>> $8 & 1 | (!$33 | !($5 | $26))) {
                           break label$82;
                          }
                          $2 = HEAPU8[$1 + 29637 | 0] + 29809 | 0;
                          while (1) {
                           $8 = HEAPU8[$2 | 0];
                           if (!$8) {
                            break label$82;
                           }
                           $9 = $9 - 1 | 0;
                           HEAP8[$9 | 0] = $8;
                           $2 = $2 + 1 | 0;
                           continue;
                          }
                         }
                         $10 = $17 - $9 | 0;
                         break label$4;
                        }
                        $3 = $4 + 224 | 0;
                        label$84: {
                         if ($28) {
                          $31 = getDoubleArg($32);
                          break label$84;
                         }
                         $2 = $17 + 7 & -8;
                         $17 = $2 + 8 | 0;
                         $31 = HEAPF64[$2 >> 3];
                        }
                        __extenddftf2($3, $31);
                        $5 = HEAP32[$4 + 224 >> 2];
                        $12 = $5;
                        $7 = HEAP32[$4 + 228 >> 2];
                        $14 = $7;
                        HEAP32[$4 + 352 >> 2] = $12;
                        HEAP32[$4 + 356 >> 2] = $7;
                        $5 = HEAP32[$4 + 236 >> 2];
                        $7 = HEAP32[$4 + 232 >> 2];
                        $13 = $31 < 0;
                        $3 = $13;
                        $6 = $3 ? $7 : $7;
                        $16 = $6;
                        $7 = $5 ^ -2147483648;
                        $5 = $3 ? $7 : $5;
                        $19 = $5;
                        HEAP32[$4 + 360 >> 2] = $16;
                        HEAP32[$4 + 364 >> 2] = $5;
                        $2 = ($10 | 0) < 0 ? 6 : ($10 | 0) < 1e8 ? $10 : 1e8;
                        $30 = ($8 | 0) == 15;
                        $10 = $2 - (($30 | ($8 | 0) == 2) & ($2 | 0) > 0) | 0;
                        $2 = $10 & 4095;
                        $31 = HEAPF64[(($2 >>> 0) % 10 << 3) + 29824 >> 3];
                        while (1) {
                         if (($2 | 0) >= 10) {
                          $2 = $2 - 10 | 0;
                          $31 = $31 * 1e-10;
                          continue;
                         }
                         break;
                        }
                        if (($8 | 0) == 12) {
                         $5 = $14;
                         $6 = $19;
                         wasm2js_scratch_store_f64(+__trunctfdf2($12, $5, $16, $6));
                         $6 = wasm2js_scratch_load_i32(1) | 0;
                         wasm2js_scratch_load_i32(0) | 0;
                         if ((((($6 >>> 20 & 2047) - 1023 | 0) / 3 << 16 >> 16) + $10 | 0) <= 14) {
                          __extenddftf2($4 + 208 | 0, $31);
                          $5 = $14;
                          $3 = $19;
                          __multf3($4 + 192 | 0, $12, $5, $16, $3, 0, -805306368, 1595811444, 1070291424);
                          $7 = HEAP32[$4 + 192 >> 2];
                          $11 = $7;
                          $6 = HEAP32[$4 + 196 >> 2];
                          $2 = $6;
                          $6 = HEAP32[$4 + 200 >> 2];
                          $22 = $6;
                          $7 = HEAP32[$4 + 204 >> 2];
                          $3 = $7;
                          $7 = HEAP32[$4 + 208 >> 2];
                          $27 = $7;
                          $6 = HEAP32[$4 + 212 >> 2];
                          $5 = $6;
                          $6 = HEAP32[$4 + 216 >> 2];
                          $21 = $6;
                          $7 = HEAP32[$4 + 220 >> 2];
                          $15 = $7;
                          $7 = $2;
                          $6 = $3;
                          $3 = $5;
                          $5 = $15;
                          __addtf3($4 + 176 | 0, $11, $7, $22, $6, $27, $3, $21, $5);
                          $5 = HEAP32[$4 + 176 >> 2];
                          $6 = $5;
                          $5 = HEAP32[$4 + 188 >> 2];
                          $2 = $5;
                          $3 = HEAP32[$4 + 180 >> 2];
                          $5 = $3;
                          $3 = HEAP32[$4 + 184 >> 2];
                          $7 = $3;
                          $3 = $2;
                          $31 = __trunctfdf2($6, $5, $7, $3);
                         }
                         __extenddftf2($4 + 160 | 0, $31);
                         $3 = HEAP32[$4 + 160 >> 2];
                         $2 = $3;
                         $5 = HEAP32[$4 + 164 >> 2];
                         $6 = $5;
                         $5 = HEAP32[$4 + 168 >> 2];
                         $15 = $5;
                         $3 = HEAP32[$4 + 172 >> 2];
                         $7 = $3;
                         $3 = $14;
                         $5 = $19;
                         __addtf3($4 + 144 | 0, $12, $3, $16, $5, $2, $6, $15, $7);
                         $6 = HEAP32[$4 + 156 >> 2];
                         $19 = $6;
                         $7 = HEAP32[$4 + 152 >> 2];
                         $16 = $7;
                         HEAP32[$4 + 360 >> 2] = $7;
                         HEAP32[$4 + 364 >> 2] = $6;
                         $7 = HEAP32[$4 + 148 >> 2];
                         $14 = $7;
                         $6 = HEAP32[$4 + 144 >> 2];
                         $12 = $6;
                         HEAP32[$4 + 352 >> 2] = $6;
                         HEAP32[$4 + 356 >> 2] = $7;
                        }
                        $7 = $14;
                        $6 = $19;
                        if (sqlite3IsNaN(__trunctfdf2($12, $7, $16, $6))) {
                         $9 = 19381;
                         $10 = 3;
                         break label$6;
                        }
                        $29 = $13 ? 45 : $20;
                        $20 = 0;
                        $15 = 0;
                        $35 = 0;
                        $11 = 1073676288;
                        $13 = 0;
                        label$91: {
                         $6 = $14;
                         $7 = $19;
                         if ((__getf2($12, $6, $16, $7, 0, 0, 0, 0) | 0) <= 0) {
                          break label$91;
                         }
                         while (1) {
                          label$93: {
                           $2 = $13;
                           $3 = $15;
                           $22 = $3;
                           $3 = $11;
                           $27 = $3;
                           $21 = $20;
                           $3 = $22;
                           $26 = $35;
                           $5 = $27;
                           __multf3($4 + 128 | 0, $21, $3, $26, $5, 0, -805306368, -765899721, 1095443610);
                           $6 = HEAP32[$4 + 128 >> 2];
                           $20 = $6;
                           $7 = HEAP32[$4 + 132 >> 2];
                           $15 = $7;
                           $7 = HEAP32[$4 + 136 >> 2];
                           $35 = $7;
                           $6 = HEAP32[$4 + 140 >> 2];
                           $11 = $6;
                           $6 = $14;
                           $7 = $19;
                           $5 = $15;
                           $3 = $11;
                           if ((__getf2($12, $6, $16, $7, $20, $5, $35, $3) | 0) < 0) {
                            break label$93;
                           }
                           $13 = $2 + 100 | 0;
                           if ($2 >>> 0 < 351) {
                            continue;
                           }
                          }
                          break;
                         }
                         while (1) {
                          label$95: {
                           $9 = $2;
                           $3 = $22;
                           $15 = $3;
                           $3 = $27;
                           $11 = $3;
                           $20 = $21;
                           $3 = $22;
                           $35 = $26;
                           $5 = $27;
                           __multf3($4 + 112 | 0, $21, $3, $26, $5, 0, 0, -234881024, 1075849733);
                           $6 = HEAP32[$4 + 112 >> 2];
                           $21 = $6;
                           $7 = HEAP32[$4 + 116 >> 2];
                           $22 = $7;
                           $7 = HEAP32[$4 + 120 >> 2];
                           $26 = $7;
                           $6 = HEAP32[$4 + 124 >> 2];
                           $27 = $6;
                           $6 = $14;
                           $7 = $19;
                           $5 = $22;
                           $3 = $27;
                           if ((__getf2($12, $6, $16, $7, $21, $5, $26, $3) | 0) < 0) {
                            break label$95;
                           }
                           $2 = $9 + 10 | 0;
                           if ($9 >>> 0 < 351) {
                            continue;
                           }
                          }
                          break;
                         }
                         while (1) {
                          label$97: {
                           $13 = $9;
                           $3 = $15;
                           $22 = $3;
                           $3 = $11;
                           $27 = $3;
                           $21 = $20;
                           $3 = $22;
                           $26 = $35;
                           $5 = $27;
                           __multf3($4 + 96 | 0, $21, $3, $26, $5, 0, 0, 0, 1073889280);
                           $6 = HEAP32[$4 + 96 >> 2];
                           $20 = $6;
                           $7 = HEAP32[$4 + 100 >> 2];
                           $15 = $7;
                           $7 = HEAP32[$4 + 104 >> 2];
                           $35 = $7;
                           $6 = HEAP32[$4 + 108 >> 2];
                           $11 = $6;
                           $6 = $14;
                           $7 = $19;
                           $5 = $15;
                           $3 = $11;
                           if ((__getf2($12, $6, $16, $7, $20, $5, $35, $3) | 0) < 0) {
                            break label$97;
                           }
                           $9 = $13 + 1 | 0;
                           if ($13 >>> 0 < 351) {
                            continue;
                           }
                          }
                          break;
                         }
                         $3 = $14;
                         $5 = $19;
                         $7 = $22;
                         $6 = $27;
                         __divtf3($4 + 80 | 0, $12, $3, $16, $5, $21, $7, $26, $6);
                         $6 = HEAP32[$4 + 88 >> 2];
                         $16 = $6;
                         $7 = HEAP32[$4 + 92 >> 2];
                         $19 = $7;
                         $7 = HEAP32[$4 + 80 >> 2];
                         $12 = $7;
                         $6 = HEAP32[$4 + 84 >> 2];
                         $14 = $6;
                         while (1) {
                          $6 = $14;
                          $7 = $19;
                          if ((__letf2($12, $6, $16, $7, 0, -1610612736, -299693885, 1071929240) | 0) < 0) {
                           $3 = $14;
                           $5 = $19;
                           __multf3($4, $12, $3, $16, $5, 0, 0, 1073741824, 1075412344);
                           $13 = $13 - 8 | 0;
                           $6 = HEAP32[$4 + 8 >> 2];
                           $16 = $6;
                           $7 = HEAP32[$4 + 12 >> 2];
                           $19 = $7;
                           $7 = HEAP32[$4 >> 2];
                           $12 = $7;
                           $6 = HEAP32[$4 + 4 >> 2];
                           $14 = $6;
                           continue;
                          }
                          break;
                         }
                         while (1) {
                          $6 = $14;
                          $7 = $19;
                          if ((__letf2($12, $6, $16, $7, 0, 0, 0, 1073676288) | 0) < 0) {
                           $3 = $14;
                           $5 = $19;
                           __multf3($4 + 16 | 0, $12, $3, $16, $5, 0, 0, 0, 1073889280);
                           $13 = $13 - 1 | 0;
                           $6 = HEAP32[$4 + 24 >> 2];
                           $16 = $6;
                           $7 = HEAP32[$4 + 28 >> 2];
                           $19 = $7;
                           $7 = HEAP32[$4 + 16 >> 2];
                           $12 = $7;
                           $6 = HEAP32[$4 + 20 >> 2];
                           $14 = $6;
                           continue;
                          }
                          break;
                         }
                         HEAP32[$4 + 352 >> 2] = $12;
                         HEAP32[$4 + 356 >> 2] = $14;
                         HEAP32[$4 + 360 >> 2] = $16;
                         $6 = $19;
                         HEAP32[$4 + 364 >> 2] = $6;
                         if (($13 | 0) < 351) {
                          break label$91;
                         }
                         HEAP8[$4 + 272 | 0] = $29;
                         $20 = 0;
                         $2 = $29 & 255;
                         $1 = $4 + 272 | ($2 | 0) != 0;
                         HEAP8[$1 | 0] = 73;
                         HEAP8[$1 + 1 | 0] = 110;
                         HEAP8[$1 + 2 | 0] = 102;
                         HEAP8[$1 + 3 | 0] = 0;
                         $10 = $2 ? 4 : 3;
                         $9 = $4 + 272 | 0;
                         break label$5;
                        }
                        if (($8 | 0) == 12) {
                         break label$13;
                        }
                        __extenddftf2($4 - -64 | 0, $31);
                        $6 = HEAP32[$4 + 64 >> 2];
                        $2 = $6;
                        $7 = HEAP32[$4 + 68 >> 2];
                        $5 = $7;
                        $7 = HEAP32[$4 + 72 >> 2];
                        $15 = $7;
                        $6 = HEAP32[$4 + 76 >> 2];
                        $3 = $6;
                        $6 = $14;
                        $7 = $19;
                        __addtf3($4 + 48 | 0, $12, $6, $16, $7, $2, $5, $15, $3);
                        $3 = HEAP32[$4 + 56 >> 2];
                        $12 = $3;
                        $5 = HEAP32[$4 + 60 >> 2];
                        $14 = $5;
                        HEAP32[$4 + 360 >> 2] = $12;
                        HEAP32[$4 + 364 >> 2] = $5;
                        $5 = HEAP32[$4 + 48 >> 2];
                        $16 = $5;
                        $3 = HEAP32[$4 + 52 >> 2];
                        $19 = $3;
                        HEAP32[$4 + 352 >> 2] = $16;
                        HEAP32[$4 + 356 >> 2] = $3;
                        $5 = $14;
                        if ((__getf2($16, $3, $12, $5, 0, 0, 0, 1073889280) | 0) >= 0) {
                         $6 = $19;
                         $7 = $14;
                         __multf3($4 + 32 | 0, $16, $6, $12, $7, 0, -1610612736, -1717986919, 1073453465);
                         $5 = HEAP32[$4 + 44 >> 2];
                         $3 = HEAP32[$4 + 40 >> 2];
                         HEAP32[$4 + 360 >> 2] = $3;
                         HEAP32[$4 + 364 >> 2] = $5;
                         $3 = HEAP32[$4 + 36 >> 2];
                         $5 = HEAP32[$4 + 32 >> 2];
                         HEAP32[$4 + 352 >> 2] = $5;
                         HEAP32[$4 + 356 >> 2] = $3;
                         $13 = $13 + 1 | 0;
                        }
                        if (!$30 & ($8 | 0) != 2) {
                         break label$13;
                        }
                        $2 = ($13 | 0) < -4 | ($10 | 0) < ($13 | 0);
                        $25 = $2 ? 2 : 1;
                        $10 = $10 - ($2 ? 0 : $13) | 0;
                        $2 = !$33;
                        break label$12;
                       }
                       $20 = 0;
                       if ($28) {
                        $24 = 0;
                        $10 = 0;
                        break label$5;
                       }
                       HEAP32[HEAP32[$17 >> 2] >> 2] = HEAP32[$0 + 16 >> 2];
                       break label$52;
                      }
                      HEAP8[$4 + 272 | 0] = 37;
                      $9 = $4 + 272 | 0;
                      $10 = 1;
                      break label$6;
                     }
                     label$104: {
                      if ($28) {
                       $2 = getTextArg($32);
                       if ($2) {
                        $1 = HEAPU8[$2 | 0];
                        HEAP8[$4 + 272 | 0] = $1;
                        $8 = 1;
                        if ($1 >>> 0 < 192) {
                         break label$104;
                        }
                        while (1) {
                         $1 = HEAPU8[$2 + 1 | 0];
                         if (($1 & 192) != 128) {
                          break label$104;
                         }
                         $2 = $2 + 1 | 0;
                         HEAP8[($4 + 272 | 0) + $8 | 0] = $1;
                         $8 = $8 + 1 | 0;
                         if (($8 | 0) != 4) {
                          continue;
                         }
                         break;
                        }
                        $8 = 4;
                        break label$104;
                       }
                       HEAP8[$4 + 272 | 0] = 0;
                       $8 = 1;
                       break label$104;
                      }
                      $1 = $17 + 4 | 0;
                      $2 = HEAP32[$17 >> 2];
                      label$108: {
                       if ($2 >>> 0 <= 127) {
                        HEAP8[$4 + 272 | 0] = $2;
                        $8 = 1;
                        break label$108;
                       }
                       if ($2 >>> 0 <= 2047) {
                        HEAP8[$4 + 273 | 0] = $2 & 63 | 128;
                        HEAP8[$4 + 272 | 0] = $2 >>> 6 | 192;
                        $8 = 2;
                        break label$108;
                       }
                       if ($2 >>> 0 <= 65535) {
                        HEAP8[$4 + 274 | 0] = $2 & 63 | 128;
                        HEAP8[$4 + 272 | 0] = $2 >>> 12 | 224;
                        HEAP8[$4 + 273 | 0] = $2 >>> 6 & 63 | 128;
                        $8 = 3;
                        break label$108;
                       }
                       HEAP8[$4 + 275 | 0] = $2 & 63 | 128;
                       HEAP8[$4 + 274 | 0] = $2 >>> 6 & 63 | 128;
                       HEAP8[$4 + 273 | 0] = $2 >>> 12 & 63 | 128;
                       HEAP8[$4 + 272 | 0] = $2 >>> 18 & 7 | 240;
                       $8 = 4;
                      }
                      $17 = $1;
                     }
                     $9 = $4 + 272 | 0;
                     $23 = 1;
                     $20 = 0;
                     if (($10 | 0) < 2) {
                      break label$15;
                     }
                     $24 = ($24 - $10 | 0) + 1 | 0;
                     if (!($34 & 255 | ($24 | 0) < 2)) {
                      sqlite3_str_appendchar($0, $24 - 1 | 0, 32);
                      $24 = 0;
                     }
                     while (1) {
                      if (($10 | 0) < 2) {
                       break label$15;
                      }
                      sqlite3_str_append($0, $4 + 272 | 0, $8);
                      $10 = $10 - 1 | 0;
                      continue;
                     }
                    }
                    if (!$28) {
                     $25 = $17 + 4 | 0;
                     $20 = 0;
                     $9 = HEAP32[$17 >> 2];
                     if (!$9) {
                      $9 = 29623;
                      break label$17;
                     }
                     if (($8 | 0) != 3) {
                      break label$17;
                     }
                     if (HEAP32[$0 + 16 >> 2] | (!HEAP32[$0 + 12 >> 2] | $24 | ($10 | 0) >= 0)) {
                      break label$18;
                     }
                     if (HEAPU8[$0 + 20 | 0]) {
                      $20 = $9;
                      break label$16;
                     }
                     HEAP32[$0 + 4 >> 2] = $9;
                     HEAP32[$0 + 8 >> 2] = sqlite3DbMallocSize(HEAP32[$0 >> 2], $9);
                     HEAP32[$0 + 16 >> 2] = strlen($9) & 2147483647;
                     HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] | 4;
                     break label$19;
                    }
                    $2 = getTextArg($32);
                    $9 = $2 ? $2 : 29623;
                    $20 = 0;
                    $25 = $17;
                    break label$17;
                   }
                   $2 = ($8 | 0) == 6;
                   $1 = $2 ? 34 : 39;
                   label$117: {
                    if ($28) {
                     $13 = getTextArg($32);
                     break label$117;
                    }
                    $13 = HEAP32[$17 >> 2];
                    $17 = $17 + 4 | 0;
                   }
                   $25 = $17;
                   $17 = ($8 | 0) == 5;
                   $2 = $13 ? $13 : $17 ? 19646 : 25508;
                   $16 = $10;
                   $5 = $10;
                   $3 = $5 >> 31;
                   $19 = $3;
                   $12 = 0;
                   $14 = 0;
                   $21 = 0;
                   $22 = 0;
                   while (1) {
                    label$120: {
                     $3 = $19;
                     if (!($3 | $16)) {
                      break label$120;
                     }
                     $8 = HEAPU8[$2 + $12 | 0];
                     if (!$8) {
                      break label$120;
                     }
                     $26 = ($1 | 0) == ($8 | 0);
                     label$121: {
                      if (!($8 >>> 0 > 191 ? $23 & 255 : 0)) {
                       $3 = $14;
                       $7 = $12;
                       $15 = $7 + 1 | 0;
                       $11 = $15 ? $3 : $3 + 1 | 0;
                       $12 = $15;
                       $14 = $11;
                       break label$121;
                      }
                      while (1) {
                       $3 = $12;
                       $5 = $3 + 1 | 0;
                       $15 = $5 ? $14 : $14 + 1 | 0;
                       $12 = $5;
                       $14 = $15;
                       if ((HEAPU8[$5 + $2 | 0] & 192) == 128) {
                        continue;
                       }
                       break;
                      }
                     }
                     $15 = $22;
                     $5 = $15;
                     $11 = $21;
                     $6 = $26;
                     $7 = $11 + $6 | 0;
                     $21 = $7;
                     $5 = $6 >>> 0 > $7 >>> 0 ? $5 + 1 | 0 : $5;
                     $22 = $5;
                     $15 = $16;
                     $3 = $16 - 1 | 0;
                     $16 = $3;
                     $5 = $19;
                     $7 = !$15;
                     $7 = $5 - $7 | 0;
                     $19 = $7;
                     continue;
                    }
                    break;
                   }
                   $9 = $4 + 272 | 0;
                   $20 = 0;
                   $15 = $22;
                   $7 = $14;
                   $3 = $15 + $7 | 0;
                   $6 = $21;
                   $5 = $12;
                   $11 = $6 + $5 | 0;
                   $3 = $11 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
                   $7 = $11;
                   $15 = $7 + 3 | 0;
                   $11 = $15 >>> 0 < 3 ? $3 + 1 | 0 : $3;
                   $16 = $15;
                   $19 = $11;
                   $3 = $16;
                   if (($11 | 0) >= 0 & $3 >>> 0 >= 71 | ($11 | 0) > 0) {
                    $3 = $19;
                    $20 = printfTempBuf($0, $16, $3);
                    $9 = $20;
                    if (!$9) {
                     break label$7;
                    }
                   }
                   $16 = 0;
                   $19 = 0;
                   $3 = 0;
                   $21 = 0;
                   $22 = 0;
                   $13 = ($13 | 0) != 0 & $17;
                   if ($13) {
                    HEAP8[$9 | 0] = $1;
                    $21 = 1;
                    $3 = 0;
                   }
                   $6 = $12;
                   $3 = $14;
                   $5 = !!$6 & ($3 | 0) >= 0 | ($3 | 0) > 0;
                   $6 = $3;
                   $11 = $5 ? $12 : 0;
                   $26 = $11;
                   $7 = $5 ? $6 : 0;
                   $27 = $7;
                   while (1) {
                    $6 = $26;
                    $5 = $16;
                    $11 = $27;
                    $7 = $19;
                    if (!(($6 | 0) == ($5 | 0) & ($11 | 0) == ($7 | 0))) {
                     $8 = HEAPU8[$2 + $16 | 0];
                     HEAP8[$9 + $21 | 0] = $8;
                     $5 = $22;
                     $6 = $21;
                     $3 = $6 + 1 | 0;
                     $15 = $3 ? $5 : $5 + 1 | 0;
                     $12 = $3;
                     $14 = $15;
                     if (($1 | 0) != ($8 | 0)) {
                      $21 = $12;
                      $3 = $14;
                     } else {
                      HEAP8[$9 + $12 | 0] = $1;
                      $15 = $22;
                      $3 = $15;
                      $5 = $21;
                      $7 = $5 + 2 | 0;
                      $3 = $7 >>> 0 < 2 ? $3 + 1 | 0 : $3;
                      $21 = $7;
                     }
                     $22 = $3;
                     $3 = $19;
                     $6 = $16 + 1 | 0;
                     $7 = $6 ? $3 : $3 + 1 | 0;
                     $16 = $6;
                     $19 = $7;
                     continue;
                    }
                    break;
                   }
                   if ($13) {
                    HEAP8[$9 + $21 | 0] = $1;
                    $7 = $22;
                    $6 = $7;
                    $3 = $21;
                    $5 = $3 + 1 | 0;
                    $6 = $5 ? $6 : $6 + 1 | 0;
                    $21 = $5;
                    $22 = $6;
                   }
                   $8 = $21;
                   HEAP8[$9 + $8 | 0] = 0;
                   break label$14;
                  }
                  if (!(HEAP8[$0 + 21 | 0] & 1)) {
                   break label$7;
                  }
                  $2 = HEAP32[$17 >> 2];
                  if ($33) {
                   if (!$2 | HEAPU8[$2 + 5 | 0] & 8) {
                    break label$52;
                   }
                   sqlite3_str_appendall($0, HEAP32[$2 + 8 >> 2]);
                   sqlite3RecordErrorOffsetOfExpr(HEAP32[$0 >> 2], $2);
                   break label$52;
                  }
                  if (!$2) {
                   break label$52;
                  }
                  $8 = HEAP32[$2 + 4 >> 2];
                  if (!$8) {
                   break label$52;
                  }
                  sqlite3_str_append($0, HEAP32[$2 >> 2], $8);
                  sqlite3RecordErrorByteOffset(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
                 }
                 $25 = $17 + 4 | 0;
                 break label$19;
                }
                if (!(HEAP8[$0 + 21 | 0] & 1)) {
                 break label$7;
                }
                $25 = $17 + 4 | 0;
                $2 = HEAP32[$17 >> 2];
                $8 = HEAP32[$2 + 12 >> 2];
                if ($23 & 255 ? 0 : $8) {
                 break label$20;
                }
                $1 = HEAP32[$2 + 8 >> 2];
                if ($1) {
                 $8 = HEAP32[$2 + 4 >> 2];
                 if ($8) {
                  sqlite3_str_appendall($0, $8);
                  sqlite3_str_append($0, 24266, 1);
                  $1 = HEAP32[$2 + 8 >> 2];
                 }
                 sqlite3_str_appendall($0, $1);
                 break label$19;
                }
                if ($8) {
                 break label$20;
                }
                $2 = HEAP32[$2 + 20 >> 2];
                $8 = HEAP32[$2 + 16 >> 2];
                if (HEAPU8[$2 + 5 | 0] & 8) {
                 HEAP32[$4 + 256 >> 2] = $8;
                 sqlite3_str_appendf($0, 24320, $4 + 256 | 0);
                 break label$19;
                }
                HEAP32[$4 + 240 >> 2] = $8;
                sqlite3_str_appendf($0, 24306, $4 + 240 | 0);
                break label$19;
               }
               sqlite3_str_append($0, 28297, 1);
               break label$7;
              }
              sqlite3_str_appendall($0, $8);
             }
             $20 = 0;
             $24 = 0;
             $10 = 0;
             break label$4;
            }
            $20 = $9;
           }
           if (($10 | 0) < 0) {
            break label$16;
           }
           if ($23 & 255) {
            $2 = $9;
            while (1) {
             label$137: {
              if (($10 | 0) <= 0) {
               break label$137;
              }
              $8 = HEAPU8[$2 | 0];
              if (!$8) {
               break label$137;
              }
              $10 = $10 - 1 | 0;
              $2 = $2 + 1 | 0;
              if ($8 >>> 0 < 192) {
               continue;
              }
              while (1) {
               $8 = $2;
               $2 = $2 + 1 | 0;
               if ((HEAPU8[$8 | 0] & 192) == 128) {
                continue;
               }
               break;
              }
              $2 = $8;
              continue;
             }
             break;
            }
            $8 = $2 - $9 | 0;
            $23 = 1;
            break label$14;
           }
           $2 = 0;
           while (1) {
            if (($2 | 0) == ($10 | 0)) {
             break label$4;
            }
            if (HEAPU8[$2 + $9 | 0]) {
             $2 = $2 + 1 | 0;
             continue;
            } else {
             $10 = $2;
             break label$4;
            }
           }
          }
          $8 = strlen($9) & 2147483647;
          break label$14;
         }
         $25 = $17;
        }
        label$142: {
         if (!($23 & 255)) {
          break label$142;
         }
         $2 = $8;
         if (($24 | 0) <= 0) {
          break label$142;
         }
         while (1) {
          if (($2 | 0) <= 0) {
           break label$142;
          }
          $2 = $2 - 1 | 0;
          $24 = ((HEAPU8[$9 + $2 | 0] & 192) == 128) + $24 | 0;
          continue;
         }
        }
        $10 = $8;
        break label$4;
       }
       $2 = $23;
      }
      $30 = $2;
      $20 = 0;
      $9 = $4 + 272 | 0;
      $8 = ($25 | 0) == 2 ? 0 : $13;
      $3 = $10;
      $6 = $3 >> 31;
      $2 = $6;
      $3 = $24;
      $6 = $3 >> 31;
      $3 = $6;
      $6 = $2;
      $5 = $6 + $3 | 0;
      $11 = $24;
      $7 = $10;
      $15 = $11 + $7 | 0;
      $5 = $15 >>> 0 < $11 >>> 0 ? $5 + 1 | 0 : $5;
      $11 = $15;
      $6 = ($8 | 0) > 0 ? $8 : 0;
      $3 = $11 + $6 | 0;
      $7 = $5;
      $15 = $3 >>> 0 < $11 >>> 0 ? $7 + 1 | 0 : $7;
      $12 = $3;
      $14 = $15;
      if (($14 | 0) >= 0 & $3 >>> 0 >= 56 | ($14 | 0) > 0) {
       $5 = $14;
       $3 = $5;
       $7 = $12 + 15 | 0;
       $3 = $7 >>> 0 < 15 ? $3 + 1 | 0 : $3;
       $20 = printfTempBuf($0, $7, $3);
       $9 = $20;
       if (!$9) {
        break label$7;
       }
      }
      $3 = $23 & 255;
      HEAP32[$4 + 348 >> 2] = Math_imul($3, 10) + 16;
      $23 = $23 | $33;
      $2 = $9;
      $5 = $29 & 255;
      if ($5) {
       HEAP8[$9 | 0] = $29;
       $2 = $9 + 1 | 0;
      }
      $23 = ($10 | 0) > 0 | $23;
      label$146: {
       if (($8 | 0) < 0) {
        HEAP8[$2 | 0] = 48;
        $2 = $2 + 1 | 0;
        $8 = $13;
        break label$146;
       }
       while (1) {
        if (($8 | 0) >= 0) {
         HEAP8[$2 | 0] = et_getdigit($4 + 352 | 0, $4 + 348 | 0);
         $8 = $8 - 1 | 0;
         $2 = $2 + 1 | 0;
         continue;
        }
        break;
       }
       $8 = -1;
      }
      $33 = $23 & 255;
      if ($33) {
       HEAP8[$2 | 0] = 46;
       $2 = $2 + 1 | 0;
      }
      $23 = ($8 | 0) >= 0 ? $8 : -1;
      while (1) {
       if (($8 | 0) != ($23 | 0)) {
        HEAP8[$2 | 0] = 48;
        $10 = $10 - 1 | 0;
        $2 = $2 + 1 | 0;
        $8 = $8 + 1 | 0;
        continue;
       }
       break;
      }
      while (1) {
       if (($10 | 0) > 0) {
        HEAP8[$2 | 0] = et_getdigit($4 + 352 | 0, $4 + 348 | 0);
        $2 = $2 + 1 | 0;
        $10 = $10 - 1 | 0;
        continue;
       }
       break;
      }
      label$155: {
       if (!($30 & 255) | !$33) {
        break label$155;
       }
       while (1) {
        label$157: {
         label$158: {
          $8 = $2 - 1 | 0;
          switch (HEAPU8[$8 | 0] - 46 | 0) {
          case 0:
           break label$157;

          case 2:
           break label$158;

          default:
           break label$155;
          }
         }
         HEAP8[$8 | 0] = 0;
         $2 = $8;
         continue;
        }
        break;
       }
       if ($3) {
        HEAP8[$2 | 0] = 48;
        $2 = $2 + 1 | 0;
        break label$155;
       }
       HEAP8[$8 | 0] = 0;
       $2 = $8;
      }
      if (($25 | 0) == 2) {
       HEAP8[$2 | 0] = HEAPU8[HEAPU8[$1 + 29636 | 0] + 29776 | 0];
       label$161: {
        if (($13 | 0) < 0) {
         HEAP8[$2 + 1 | 0] = 45;
         $13 = 0 - $13 | 0;
         break label$161;
        }
        HEAP8[$2 + 1 | 0] = 43;
       }
       if ($13 >>> 0 < 100) {
        $2 = $2 + 2 | 0;
       } else {
        $8 = ($13 >>> 0) / 100 | 0;
        HEAP8[$2 + 2 | 0] = $8 + 48;
        $13 = $13 - Math_imul($8, 100) | 0;
        $2 = $2 + 3 | 0;
       }
       $8 = (($13 & 255) >>> 0) / 10 | 0;
       HEAP8[$2 | 0] = $8 | 48;
       HEAP8[$2 + 1 | 0] = $13 - Math_imul($8, 10) | 48;
       $2 = $2 + 2 | 0;
      }
      HEAP8[$2 | 0] = 0;
      $10 = $2 - $9 | 0;
      if (!$36 | $34 & 255 | ($24 | 0) <= ($10 | 0)) {
       break label$5;
      }
      $2 = $24 - $10 | 0;
      $8 = $24;
      while (1) {
       if (($2 | 0) <= ($8 | 0)) {
        HEAP8[$8 + $9 | 0] = HEAPU8[($8 - $2 | 0) + $9 | 0];
        $8 = $8 - 1 | 0;
        continue;
       }
       break;
      }
      $8 = ($5 | 0) != 0;
      while (1) if ($2) {
       HEAP8[$8 + $9 | 0] = 48;
       $8 = $8 + 1 | 0;
       $2 = $2 - 1 | 0;
       continue;
      } else {
       $10 = $24;
       break label$5;
      }
     }
     __stack_pointer = $4 + 368 | 0;
     return;
    }
    $20 = 0;
   }
   $25 = $17;
  }
  label$170: {
   label$171: {
    $2 = $24 - $10 | 0;
    if (($2 | 0) > 0) {
     if ($34 & 255) {
      break label$171;
     }
     sqlite3_str_appendchar($0, $2, 32);
    }
    sqlite3_str_append($0, $9, $10);
    break label$170;
   }
   sqlite3_str_append($0, $9, $10);
   sqlite3_str_appendchar($0, $2, 32);
  }
  if ($20) {
   sqlite3DbFree(HEAP32[$0 >> 2], $20);
  }
  $1 = $18 + 1 | 0;
  continue;
 }
}

function yy_reduce($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = __stack_pointer - 176 | 0;
 __stack_pointer = $7;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   switch ($1 | 0) {
   case 0:
    HEAP8[$3 + 207 | 0] = 1;
    break label$1;

   case 1:
    HEAP8[$3 + 207 | 0] = 2;
    break label$1;

   case 2:
    sqlite3FinishCoding($3);
    break label$1;

   case 3:
    sqlite3BeginTransaction($3, HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 4:
    HEAP32[$4 + 16 >> 2] = 7;
    break label$1;

   case 5:
   case 6:
   case 7:
   case 323:
    HEAP32[$4 + 4 >> 2] = HEAPU16[$4 + 2 >> 1];
    break label$1;

   case 8:
   case 9:
    sqlite3EndTransaction($3, HEAPU16[$4 - 10 >> 1]);
    break label$1;

   case 10:
    sqlite3Savepoint($3, 0, $4 + 4 | 0);
    break label$1;

   case 11:
    sqlite3Savepoint($3, 1, $4 + 4 | 0);
    break label$1;

   case 12:
    sqlite3Savepoint($3, 2, $4 + 4 | 0);
    break label$1;

   case 13:
    sqlite3StartTable($3, $4 - 8 | 0, $4 + 4 | 0, HEAP32[$4 - 44 >> 2], 0, 0, HEAP32[$4 - 20 >> 2]);
    break label$1;

   case 14:
    disableLookaside($3);
    break label$1;

   case 15:
   case 18:
   case 47:
   case 62:
   case 72:
   case 81:
   case 98:
   case 244:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 16:
    HEAP32[$4 - 20 >> 2] = 1;
    break label$1;

   case 17:
    HEAP32[$4 + 4 >> 2] = !HEAPU8[HEAP32[$3 >> 2] + 177 | 0];
    break label$1;

   case 19:
    sqlite3EndTable($3, $4 - 20 | 0, $4 - 8 | 0, HEAP32[$4 + 4 >> 2], 0);
    break label$1;

   case 20:
    sqlite3EndTable($3, 0, 0, 0, HEAP32[$4 + 4 >> 2]);
    sqlite3SelectDelete(HEAP32[$3 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 21:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 22:
    $3 = $4 - 20 | 0;
    HEAP32[$3 >> 2] = HEAP32[$4 + 4 >> 2] | HEAP32[$3 >> 2];
    break label$1;

   case 23:
    $2 = HEAP32[$4 + 4 >> 2];
    label$272: {
     $5 = HEAP32[$4 + 8 >> 2];
     if (($5 | 0) != 5) {
      break label$272;
     }
     if (sqlite3_strnicmp($2, 14442, 5)) {
      break label$272;
     }
     HEAP32[$4 - 8 >> 2] = 640;
     break label$1;
    }
    HEAP32[$4 - 8 >> 2] = 0;
    HEAP32[$7 + 4 >> 2] = $2;
    HEAP32[$7 >> 2] = $5;
    sqlite3ErrorMsg($3, 5733, $7);
    break label$1;

   case 24:
    $2 = HEAP32[$4 + 4 >> 2];
    label$273: {
     label$274: {
      $5 = HEAP32[$4 + 8 >> 2];
      if (($5 | 0) != 6) {
       break label$274;
      }
      if (sqlite3_strnicmp($2, 3206, 6)) {
       break label$274;
      }
      $3 = 65536;
      break label$273;
     }
     HEAP32[$7 + 20 >> 2] = $2;
     HEAP32[$7 + 16 >> 2] = $5;
     sqlite3ErrorMsg($3, 5733, $7 + 16 | 0);
     $3 = 0;
    }
    HEAP32[$4 + 4 >> 2] = $3;
    break label$1;

   case 25:
    $10 = $4 - 8 | 0;
    $8 = HEAP32[$10 >> 2];
    $6 = HEAP32[$10 + 4 >> 2];
    HEAP32[$7 + 40 >> 2] = $8;
    HEAP32[$7 + 44 >> 2] = $6;
    $8 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 4 >> 2];
    HEAP32[$7 + 32 >> 2] = $6;
    HEAP32[$7 + 36 >> 2] = $8;
    sqlite3AddColumn($3, $7 + 40 | 0, $7 + 32 | 0);
    break label$1;

   case 26:
   case 65:
   case 104:
    HEAP32[$4 + 16 >> 2] = 0;
    HEAP32[$4 + 20 >> 2] = 0;
    break label$1;

   case 27:
    $3 = $4 - 36 | 0;
    HEAP32[$3 + 8 >> 2] = (HEAP32[$4 + 4 >> 2] + HEAP32[$4 + 8 >> 2] | 0) - HEAP32[$3 + 4 >> 2];
    break label$1;

   case 28:
    $3 = $4 - 60 | 0;
    HEAP32[$3 + 8 >> 2] = (HEAP32[$4 + 4 >> 2] + HEAP32[$4 + 8 >> 2] | 0) - HEAP32[$3 + 4 >> 2];
    break label$1;

   case 29:
    $3 = $4 - 12 | 0;
    HEAP32[$3 + 8 >> 2] = (HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 4 >> 2] | 0) - HEAP32[$3 + 4 >> 2];
    break label$1;

   case 30:
    HEAP32[$4 + 16 >> 2] = HEAP32[$2 >> 2];
    break label$1;

   case 31:
    $6 = HEAP32[$2 + 4 >> 2];
    $8 = HEAP32[$2 >> 2];
    HEAP32[$4 + 16 >> 2] = $8;
    HEAP32[$4 + 20 >> 2] = $6;
    break label$1;

   case 32:
   case 67:
    $8 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 4 >> 2];
    HEAP32[$3 + 72 >> 2] = $6;
    HEAP32[$3 + 76 >> 2] = $8;
    break label$1;

   case 33:
    $2 = $4 - 12 | 0;
    $5 = HEAP32[$2 + 4 >> 2];
    sqlite3AddDefaultValue($3, HEAP32[$4 + 4 >> 2], $5, HEAP32[$2 + 8 >> 2] + $5 | 0);
    break label$1;

   case 34:
    sqlite3AddDefaultValue($3, HEAP32[$4 - 8 >> 2], HEAP32[$4 - 20 >> 2] + 1 | 0, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 35:
    $2 = $4 - 12 | 0;
    sqlite3AddDefaultValue($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$2 + 4 >> 2] + HEAP32[$2 + 8 >> 2] | 0);
    break label$1;

   case 36:
    $2 = $4 - 12 | 0;
    sqlite3AddDefaultValue($3, sqlite3PExpr($3, 173, HEAP32[$4 + 4 >> 2], 0), HEAP32[$4 - 20 >> 2], HEAP32[$2 + 4 >> 2] + HEAP32[$2 + 8 >> 2] | 0);
    break label$1;

   case 37:
    $6 = HEAP32[$4 + 8 >> 2];
    $8 = HEAP32[$4 + 4 >> 2];
    HEAP32[$7 + 48 >> 2] = $8;
    HEAP32[$7 + 52 >> 2] = $6;
    $2 = tokenExpr($3, 117, $7 + 48 | 0);
    if ($2) {
     sqlite3ExprIdToTrueFalse($2);
    }
    $5 = HEAP32[$4 + 4 >> 2];
    sqlite3AddDefaultValue($3, $2, $5, HEAP32[$4 + 8 >> 2] + $5 | 0);
    break label$1;

   case 38:
    sqlite3AddNotNull($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 39:
    sqlite3AddPrimaryKey($3, 0, HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 - 20 >> 2]);
    break label$1;

   case 40:
    sqlite3CreateIndex($3, 0, 0, 0, 0, HEAP32[$4 + 4 >> 2], 0, 0, 0, 0, 1);
    break label$1;

   case 41:
    sqlite3AddCheckConstraint($3, HEAP32[$4 - 8 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 42:
    sqlite3CreateForeignKey($3, 0, $4 - 20 | 0, HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 43:
    sqlite3DeferForeignKey($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 44:
    sqlite3AddCollateType($3, $4 + 4 | 0);
    break label$1;

   case 45:
    sqlite3AddGenerated($3, HEAP32[$4 - 8 >> 2], 0);
    break label$1;

   case 46:
    sqlite3AddGenerated($3, HEAP32[$4 - 20 >> 2], $4 + 4 | 0);
    break label$1;

   case 48:
    HEAP32[$4 + 4 >> 2] = 1;
    break label$1;

   case 49:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 50:
    $3 = $4 - 8 | 0;
    HEAP32[$3 >> 2] = HEAP32[$4 + 4 >> 2] | HEAP32[$3 >> 2] & (HEAP32[$4 + 8 >> 2] ^ -1);
    break label$1;

   case 51:
    $8 = $4 - 8 | 0;
    HEAP32[$8 >> 2] = 0;
    HEAP32[$8 + 4 >> 2] = 0;
    break label$1;

   case 52:
    $8 = $4 - 20 | 0;
    HEAP32[$8 >> 2] = 0;
    HEAP32[$8 + 4 >> 2] = 0;
    break label$1;

   case 53:
    $3 = $4 - 24 | 0;
    HEAP32[$3 + 8 >> 2] = 255;
    HEAP32[$3 + 4 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 54:
    $3 = $4 - 24 | 0;
    HEAP32[$3 + 8 >> 2] = 65280;
    HEAP32[$3 + 4 >> 2] = HEAP32[$4 + 4 >> 2] << 8;
    break label$1;

   case 55:
    HEAP32[$4 - 8 >> 2] = 8;
    break label$1;

   case 56:
    HEAP32[$4 - 8 >> 2] = 9;
    break label$1;

   case 57:
    HEAP32[$4 + 4 >> 2] = 10;
    break label$1;

   case 58:
    HEAP32[$4 + 4 >> 2] = 7;
    break label$1;

   case 59:
    HEAP32[$4 - 8 >> 2] = 0;
    break label$1;

   case 60:
    HEAP32[$4 - 20 >> 2] = 0;
    break label$1;

   case 61:
   case 76:
   case 171:
    HEAP32[$4 - 8 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 63:
   case 80:
   case 216:
   case 219:
   case 245:
    HEAP32[$4 - 8 >> 2] = 1;
    break label$1;

   case 64:
    HEAP32[$4 - 8 >> 2] = 0;
    break label$1;

   case 66:
    HEAP32[$3 + 76 >> 2] = 0;
    break label$1;

   case 68:
    sqlite3AddPrimaryKey($3, HEAP32[$4 - 32 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 - 20 >> 2], 0);
    break label$1;

   case 69:
    sqlite3CreateIndex($3, 0, 0, 0, HEAP32[$4 - 20 >> 2], HEAP32[$4 + 4 >> 2], 0, 0, 0, 0, 1);
    break label$1;

   case 70:
    sqlite3AddCheckConstraint($3, HEAP32[$4 - 20 >> 2], HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 71:
    sqlite3CreateForeignKey($3, HEAP32[$4 - 68 >> 2], $4 - 32 | 0, HEAP32[$4 - 20 >> 2], HEAP32[$4 - 8 >> 2]);
    sqlite3DeferForeignKey($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 73:
   case 75:
    HEAP32[$4 + 16 >> 2] = 11;
    break label$1;

   case 74:
    HEAP32[$4 - 20 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 77:
    HEAP32[$4 + 4 >> 2] = 4;
    break label$1;

   case 78:
   case 172:
    HEAP32[$4 + 4 >> 2] = 5;
    break label$1;

   case 79:
    sqlite3DropTable($3, HEAP32[$4 + 4 >> 2], 0, HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 82:
    sqlite3CreateView($3, $4 - 92 | 0, $4 - 44 | 0, $4 - 32 | 0, HEAP32[$4 - 20 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 - 80 >> 2], HEAP32[$4 - 56 >> 2]);
    break label$1;

   case 83:
    sqlite3DropTable($3, HEAP32[$4 + 4 >> 2], 1, HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 84:
    HEAP32[$7 + 168 >> 2] = HEAP32[11938];
    $8 = HEAP32[11937];
    $6 = HEAP32[11936];
    HEAP32[$7 + 160 >> 2] = $6;
    HEAP32[$7 + 164 >> 2] = $8;
    $6 = HEAP32[11935];
    $8 = HEAP32[11934];
    HEAP32[$7 + 152 >> 2] = $8;
    HEAP32[$7 + 156 >> 2] = $6;
    $8 = HEAP32[11933];
    $6 = HEAP32[11932];
    HEAP32[$7 + 144 >> 2] = $6;
    HEAP32[$7 + 148 >> 2] = $8;
    sqlite3Select($3, HEAP32[$4 + 4 >> 2], $7 + 144 | 0);
    sqlite3SelectDelete(HEAP32[$3 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 85:
    HEAP32[$4 - 20 >> 2] = attachWithToSelect($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 86:
    HEAP32[$4 - 32 >> 2] = attachWithToSelect($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 87:
    $2 = HEAP32[$4 + 4 >> 2];
    if ($2) {
     parserDoubleLinkSelect($3, $2);
    }
    HEAP32[$4 + 4 >> 2] = $2;
    break label$1;

   case 88:
    $9 = $4 - 20 | 0;
    $5 = HEAP32[$9 >> 2];
    label$277: {
     label$278: {
      $2 = HEAP32[$4 + 4 >> 2];
      if (!$2) {
       break label$278;
      }
      if (HEAP32[$2 + 52 >> 2]) {
       HEAP32[$7 + 148 >> 2] = 0;
       parserDoubleLinkSelect($3, $2);
       $2 = sqlite3SelectNew($3, 0, sqlite3SrcListAppendFromTerm($3, 0, 0, 0, $7 + 144 | 0, $2, 0), 0, 0, 0, 0, 0, 0);
       if (!$2) {
        break label$278;
       }
      }
      $6 = $4 - 8 | 0;
      $10 = HEAP32[$6 >> 2];
      HEAP32[$2 + 52 >> 2] = $5;
      HEAP8[$2 | 0] = $10;
      if ($5) {
       HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] & -1025;
      }
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] & -1025;
      if (HEAP32[$6 >> 2] == 135) {
       break label$277;
      }
      HEAP8[$3 + 22 | 0] = 1;
      break label$277;
     }
     sqlite3SelectDelete(HEAP32[$3 >> 2], $5);
     $2 = 0;
    }
    HEAP32[$9 >> 2] = $2;
    break label$1;

   case 89:
   case 91:
    HEAP32[$4 + 4 >> 2] = HEAPU16[$4 + 2 >> 1];
    break label$1;

   case 90:
    HEAP32[$4 - 8 >> 2] = 135;
    break label$1;

   case 92:
    HEAP32[$4 - 92 >> 2] = sqlite3SelectNew($3, HEAP32[$4 - 68 >> 2], HEAP32[$4 - 56 >> 2], HEAP32[$4 - 44 >> 2], HEAP32[$4 - 32 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$4 - 8 >> 2], HEAP32[$4 - 80 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 93:
    $2 = sqlite3SelectNew($3, HEAP32[$4 - 80 >> 2], HEAP32[$4 - 68 >> 2], HEAP32[$4 - 56 >> 2], HEAP32[$4 - 44 >> 2], HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2], HEAP32[$4 - 92 >> 2], HEAP32[$4 + 4 >> 2]);
    HEAP32[$4 - 104 >> 2] = $2;
    if ($2) {
     HEAP32[$2 + 72 >> 2] = HEAP32[$4 - 20 >> 2];
     break label$1;
    }
    sqlite3WindowListDelete(HEAP32[$3 >> 2], HEAP32[$4 - 20 >> 2]);
    break label$1;

   case 94:
    HEAP32[$4 - 32 >> 2] = sqlite3SelectNew($3, HEAP32[$4 - 8 >> 2], 0, 0, 0, 0, 0, 512, 0);
    break label$1;

   case 95:
    $5 = $4 - 44 | 0;
    $2 = HEAP32[$5 >> 2];
    $3 = sqlite3SelectNew($3, HEAP32[$4 - 8 >> 2], 0, 0, 0, 0, 0, 1536, 0);
    if ($2) {
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] & -1025;
    }
    label$283: {
     if (!$3) {
      $3 = $2;
      break label$283;
     }
     HEAP32[$3 + 52 >> 2] = $2;
     HEAP8[$3 | 0] = 135;
    }
    HEAP32[$5 >> 2] = $3;
    break label$1;

   case 96:
    HEAP32[$4 + 4 >> 2] = 1;
    break label$1;

   case 97:
    HEAP32[$4 + 4 >> 2] = 2;
    break label$1;

   case 99:
   case 132:
   case 142:
   case 232:
   case 235:
   case 240:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 100:
    $2 = $4 - 44 | 0;
    $5 = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], HEAP32[$4 - 20 >> 2]);
    HEAP32[$2 >> 2] = $5;
    if (HEAP32[$4 + 8 >> 2]) {
     sqlite3ExprListSetName($3, $5, $4 + 4 | 0, 1);
     $5 = HEAP32[$2 >> 2];
    }
    sqlite3ExprListSetSpan($3, $5, HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 101:
    $5 = sqlite3Expr(HEAP32[$3 >> 2], 180, 0);
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], $5);
    break label$1;

   case 102:
    $5 = sqlite3PExpr($3, 180, 0, 0);
    $10 = $4 - 20 | 0;
    $8 = HEAP32[$10 >> 2];
    $6 = HEAP32[$10 + 4 >> 2];
    HEAP32[$7 + 56 >> 2] = $8;
    HEAP32[$7 + 60 >> 2] = $6;
    $5 = sqlite3PExpr($3, 141, tokenExpr($3, 59, $7 + 56 | 0), $5);
    $2 = $4 - 44 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], $5);
    break label$1;

   case 103:
   case 115:
   case 256:
   case 257:
    $8 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 4 >> 2];
    $2 = $6;
    $6 = $4 - 8 | 0;
    HEAP32[$6 >> 2] = $2;
    HEAP32[$6 + 4 >> 2] = $8;
    break label$1;

   case 105:
   case 108:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 106:
    $3 = HEAP32[$4 + 4 >> 2];
    HEAP32[$4 - 8 >> 2] = $3;
    sqlite3SrcListShiftJoinType($3);
    break label$1;

   case 107:
    $3 = HEAP32[$4 - 8 >> 2];
    if (!$3) {
     break label$1;
    }
    $2 = HEAP32[$3 >> 2];
    if (($2 | 0) <= 0) {
     break label$1;
    }
    HEAP8[(($2 << 6) + $3 | 0) - 20 | 0] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 109:
    $2 = $4 - 44 | 0;
    HEAP32[$2 >> 2] = sqlite3SrcListAppendFromTerm($3, HEAP32[$2 >> 2], $4 - 32 | 0, $4 - 20 | 0, $4 - 8 | 0, 0, $4 + 4 | 0);
    break label$1;

   case 110:
    $2 = $4 - 56 | 0;
    $5 = sqlite3SrcListAppendFromTerm($3, HEAP32[$2 >> 2], $4 - 44 | 0, $4 - 32 | 0, $4 - 20 | 0, 0, $4 + 4 | 0);
    HEAP32[$2 >> 2] = $5;
    sqlite3SrcListIndexedBy($3, $5, $4 - 8 | 0);
    break label$1;

   case 111:
    $2 = $4 - 80 | 0;
    $5 = sqlite3SrcListAppendFromTerm($3, HEAP32[$2 >> 2], $4 - 68 | 0, $4 - 56 | 0, $4 - 8 | 0, 0, $4 + 4 | 0);
    HEAP32[$2 >> 2] = $5;
    sqlite3SrcListFuncArgs($3, $5, HEAP32[$4 - 32 >> 2]);
    break label$1;

   case 112:
    $2 = $4 - 56 | 0;
    HEAP32[$2 >> 2] = sqlite3SrcListAppendFromTerm($3, HEAP32[$2 >> 2], 0, 0, $4 - 8 | 0, HEAP32[$4 - 32 >> 2], $4 + 4 | 0);
    break label$1;

   case 113:
    $2 = $4 - 56 | 0;
    $9 = HEAP32[$2 >> 2];
    if (!($9 | HEAP32[$4 - 4 >> 2] | (HEAP32[$4 + 4 >> 2] | HEAP32[$4 + 8 >> 2]))) {
     HEAP32[$2 >> 2] = HEAP32[$4 - 32 >> 2];
     break label$1;
    }
    $5 = $4 - 32 | 0;
    $6 = HEAP32[$5 >> 2];
    if (HEAP32[$6 >> 2] == 1) {
     $9 = sqlite3SrcListAppendFromTerm($3, $9, 0, 0, $4 - 8 | 0, 0, $4 + 4 | 0);
     HEAP32[$2 >> 2] = $9;
     if ($9) {
      $10 = HEAP32[$9 >> 2] - 1 | 0;
      $6 = ($10 << 6) + $9 | 0;
      $2 = HEAP32[$5 >> 2];
      HEAP32[$6 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
      HEAP32[$6 + 12 >> 2] = HEAP32[$2 + 12 >> 2];
      $8 = $6;
      $6 = HEAP32[$2 + 28 >> 2];
      HEAP32[$8 + 28 >> 2] = $6;
      if (!(!$6 | !(HEAPU8[$6 + 5 | 0] & 8))) {
       $8 = ($10 << 6) + $9 | 0;
       $6 = $8 + 45 | 0;
       $8 = HEAPU8[$8 + 45 | 0] | HEAPU8[$8 + 46 | 0] << 8 | 8192;
       HEAP8[$6 | 0] = $8;
       HEAP8[$6 + 1 | 0] = $8 >>> 8;
      }
      if (HEAPU8[$2 + 45 | 0] & 4) {
       $9 = ($10 << 6) + $9 | 0;
       $6 = $2 - -64 | 0;
       HEAP32[$9 - -64 >> 2] = HEAP32[$6 >> 2];
       HEAP32[$6 >> 2] = 0;
       $6 = (HEAPU8[$2 + 45 | 0] | HEAPU8[$2 + 46 | 0] << 8) & 65531;
       HEAP8[$2 + 45 | 0] = $6;
       HEAP8[$2 + 46 | 0] = $6 >>> 8;
       $6 = $9;
       $9 = $9 + 45 | 0;
       $6 = HEAPU8[$6 + 45 | 0] | HEAPU8[$6 + 46 | 0] << 8 | 4;
       HEAP8[$9 | 0] = $6;
       HEAP8[$9 + 1 | 0] = $6 >>> 8;
      }
      HEAP32[$2 + 28 >> 2] = 0;
      HEAP32[$2 + 12 >> 2] = 0;
      HEAP32[$2 + 16 >> 2] = 0;
     }
     sqlite3SrcListDelete(HEAP32[$3 >> 2], HEAP32[$5 >> 2]);
     break label$1;
    }
    sqlite3SrcListShiftJoinType($6);
    $5 = sqlite3SelectNew($3, 0, HEAP32[$5 >> 2], 0, 0, 0, 0, 2048, 0);
    HEAP32[$2 >> 2] = sqlite3SrcListAppendFromTerm($3, HEAP32[$2 >> 2], 0, 0, $4 - 8 | 0, $5, $4 + 4 | 0);
    break label$1;

   case 114:
   case 129:
    HEAP32[$4 + 16 >> 2] = 0;
    HEAP32[$4 + 20 >> 2] = 0;
    break label$1;

   case 116:
    $5 = $4 + 4 | 0;
    $2 = sqlite3SrcListAppend($3, 0, $5, 0);
    if (!(!$2 | HEAPU8[$3 + 208 | 0] < 2)) {
     sqlite3RenameTokenMap($3, HEAP32[$2 + 16 >> 2], $5);
    }
    HEAP32[$5 >> 2] = $2;
    break label$1;

   case 117:
    $5 = $4 - 20 | 0;
    $9 = $4 + 4 | 0;
    $2 = sqlite3SrcListAppend($3, 0, $5, $9);
    if (!(!$2 | HEAPU8[$3 + 208 | 0] < 2)) {
     sqlite3RenameTokenMap($3, HEAP32[$2 + 16 >> 2], $9);
    }
    HEAP32[$5 >> 2] = $2;
    break label$1;

   case 118:
    HEAP32[$4 + 4 >> 2] = sqlite3SrcListAppend($3, 0, $4 + 4 | 0, 0);
    break label$1;

   case 119:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3SrcListAppend($3, 0, $2, $4 + 4 | 0);
    break label$1;

   case 120:
    $2 = $4 - 44 | 0;
    $5 = sqlite3SrcListAppend($3, 0, $2, $4 - 20 | 0);
    HEAP32[$2 >> 2] = $5;
    if (!$5) {
     break label$1;
    }
    $3 = sqlite3NameFromToken(HEAP32[$3 >> 2], $4 + 4 | 0);
    HEAP32[HEAP32[$2 >> 2] + 20 >> 2] = $3;
    break label$1;

   case 121:
    $2 = $4 - 20 | 0;
    $5 = sqlite3SrcListAppend($3, 0, $2, 0);
    HEAP32[$2 >> 2] = $5;
    if (!$5) {
     break label$1;
    }
    $3 = sqlite3NameFromToken(HEAP32[$3 >> 2], $4 + 4 | 0);
    HEAP32[HEAP32[$2 >> 2] + 20 >> 2] = $3;
    break label$1;

   case 122:
    HEAP32[$4 + 4 >> 2] = 1;
    break label$1;

   case 123:
    $2 = $4 - 8 | 0;
    HEAP32[$2 >> 2] = sqlite3JoinType($3, $2, 0, 0);
    break label$1;

   case 124:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3JoinType($3, $2, $4 - 8 | 0, 0);
    break label$1;

   case 125:
    $2 = $4 - 32 | 0;
    HEAP32[$2 >> 2] = sqlite3JoinType($3, $2, $4 - 20 | 0, $4 - 8 | 0);
    break label$1;

   case 126:
    $3 = $4 - 12 | 0;
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$3 + 4 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 127:
    $3 = $4 - 36 | 0;
    HEAP32[$3 + 4 >> 2] = 0;
    HEAP32[$3 + 8 >> 2] = HEAP32[$4 - 8 >> 2];
    break label$1;

   case 128:
    HEAP32[$4 + 16 >> 2] = 0;
    HEAP32[$4 + 20 >> 2] = 0;
    break label$1;

   case 130:
    $6 = HEAP32[$4 + 8 >> 2];
    $8 = HEAP32[$4 + 4 >> 2];
    $2 = $8;
    $8 = $4 - 20 | 0;
    HEAP32[$8 >> 2] = $2;
    HEAP32[$8 + 4 >> 2] = $6;
    break label$1;

   case 131:
    $8 = $4 - 8 | 0;
    HEAP32[$8 >> 2] = 0;
    HEAP32[$8 + 4 >> 2] = 1;
    break label$1;

   case 133:
   case 143:
    HEAP32[$4 - 20 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 134:
    $2 = $4 - 44 | 0;
    $3 = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], HEAP32[$4 - 20 >> 2]);
    HEAP32[$2 >> 2] = $3;
    sqlite3ExprListSetSortOrder($3, HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 135:
    $2 = $4 - 20 | 0;
    $3 = sqlite3ExprListAppend($3, 0, HEAP32[$2 >> 2]);
    HEAP32[$2 >> 2] = $3;
    sqlite3ExprListSetSortOrder($3, HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 136:
    HEAP32[$4 + 4 >> 2] = 0;
    break label$1;

   case 137:
    HEAP32[$4 + 4 >> 2] = 1;
    break label$1;

   case 138:
   case 141:
    HEAP32[$4 + 16 >> 2] = -1;
    break label$1;

   case 139:
    HEAP32[$4 - 8 >> 2] = 0;
    break label$1;

   case 140:
    HEAP32[$4 - 8 >> 2] = 1;
    break label$1;

   case 144:
   case 146:
   case 151:
   case 153:
   case 229:
   case 231:
   case 250:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 145:
   case 152:
   case 154:
   case 228:
   case 249:
    HEAP32[$4 - 8 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 147:
    HEAP32[$4 - 8 >> 2] = sqlite3PExpr($3, 148, HEAP32[$4 + 4 >> 2], 0);
    break label$1;

   case 148:
    HEAP32[$4 - 32 >> 2] = sqlite3PExpr($3, 148, HEAP32[$4 - 20 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 149:
    HEAP32[$4 - 32 >> 2] = sqlite3PExpr($3, 148, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 20 >> 2]);
    break label$1;

   case 150:
    $2 = $4 - 20 | 0;
    sqlite3SrcListIndexedBy($3, HEAP32[$2 >> 2], $4 - 8 | 0);
    sqlite3DeleteFrom($3, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 155:
    sqlite3AddReturning($3, HEAP32[$4 + 4 >> 2]);
    HEAP32[$4 - 8 >> 2] = 0;
    break label$1;

   case 156:
    sqlite3AddReturning($3, HEAP32[$4 + 4 >> 2]);
    HEAP32[$4 - 32 >> 2] = HEAP32[$4 - 20 >> 2];
    break label$1;

   case 157:
    $5 = $4 - 56 | 0;
    sqlite3SrcListIndexedBy($3, HEAP32[$5 >> 2], $4 - 44 | 0);
    $9 = $4 - 20 | 0;
    sqlite3ExprListCheckLength($3, HEAP32[$9 >> 2], 2227);
    $2 = HEAP32[$4 - 8 >> 2];
    label$293: {
     if (!$2) {
      $2 = HEAP32[$5 >> 2];
      break label$293;
     }
     if (HEAP32[$2 >> 2] >= 2) {
      $2 = sqlite3SelectNew($3, 0, $2, 0, 0, 0, 0, 2048, 0);
      HEAP32[$7 + 144 >> 2] = 0;
      HEAP32[$7 + 148 >> 2] = 0;
      $2 = sqlite3SrcListAppendFromTerm($3, 0, 0, 0, $7 + 144 | 0, $2, 0);
     }
     $2 = sqlite3SrcListAppendList($3, HEAP32[$5 >> 2], $2);
     HEAP32[$5 >> 2] = $2;
    }
    sqlite3Update($3, $2, HEAP32[$9 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$4 - 68 >> 2], 0);
    break label$1;

   case 158:
    $2 = $4 - 44 | 0;
    $5 = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    sqlite3ExprListSetName($3, $5, $4 - 20 | 0, 1);
    break label$1;

   case 159:
    $2 = $4 - 68 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprListAppendVector($3, HEAP32[$2 >> 2], HEAP32[$4 - 32 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 160:
    $2 = sqlite3ExprListAppend($3, 0, HEAP32[$4 + 4 >> 2]);
    $5 = $4 - 20 | 0;
    sqlite3ExprListSetName($3, $2, $5, 1);
    HEAP32[$5 >> 2] = $2;
    break label$1;

   case 161:
    HEAP32[$4 - 44 >> 2] = sqlite3ExprListAppendVector($3, 0, HEAP32[$4 - 32 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 162:
    sqlite3Insert($3, HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$4 - 56 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 163:
    sqlite3Insert($3, HEAP32[$4 - 44 >> 2], 0, HEAP32[$4 - 32 >> 2], HEAP32[$4 - 68 >> 2], 0);
    break label$1;

   case 164:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 165:
    HEAP32[$4 - 8 >> 2] = 0;
    sqlite3AddReturning($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 166:
    HEAP32[$4 - 128 >> 2] = sqlite3UpsertNew(HEAP32[$3 >> 2], HEAP32[$4 - 92 >> 2], HEAP32[$4 - 68 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 167:
    HEAP32[$4 - 92 >> 2] = sqlite3UpsertNew(HEAP32[$3 >> 2], HEAP32[$4 - 56 >> 2], HEAP32[$4 - 32 >> 2], 0, 0, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 168:
    HEAP32[$4 - 44 >> 2] = sqlite3UpsertNew(HEAP32[$3 >> 2], 0, 0, 0, 0, 0);
    break label$1;

   case 169:
    HEAP32[$4 - 80 >> 2] = sqlite3UpsertNew(HEAP32[$3 >> 2], 0, 0, HEAP32[$4 - 20 >> 2], HEAP32[$4 - 8 >> 2], 0);
    break label$1;

   case 170:
    sqlite3AddReturning($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 173:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 174:
    HEAP32[$4 - 20 >> 2] = HEAP32[$4 - 8 >> 2];
    break label$1;

   case 175:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3IdListAppend($3, HEAP32[$2 >> 2], $4 + 4 | 0);
    break label$1;

   case 176:
    HEAP32[$4 + 4 >> 2] = sqlite3IdListAppend($3, 0, $4 + 4 | 0);
    break label$1;

   case 177:
    HEAP32[$4 - 20 >> 2] = HEAP32[$4 - 8 >> 2];
    break label$1;

   case 178:
   case 179:
    $8 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 4 >> 2];
    HEAP32[$7 + 64 >> 2] = $6;
    HEAP32[$7 + 68 >> 2] = $8;
    HEAP32[$4 + 4 >> 2] = tokenExpr($3, 59, $7 - -64 | 0);
    break label$1;

   case 180:
    $2 = $4 - 20 | 0;
    $6 = HEAP32[$2 + 4 >> 2];
    $8 = HEAP32[$2 >> 2];
    HEAP32[$7 + 80 >> 2] = $8;
    HEAP32[$7 + 84 >> 2] = $6;
    $5 = tokenExpr($3, 59, $7 + 80 | 0);
    $8 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 4 >> 2];
    HEAP32[$7 + 72 >> 2] = $6;
    HEAP32[$7 + 76 >> 2] = $8;
    HEAP32[$2 >> 2] = sqlite3PExpr($3, 141, $5, tokenExpr($3, 59, $7 + 72 | 0));
    break label$1;

   case 181:
    $5 = $4 - 44 | 0;
    $6 = HEAP32[$5 + 4 >> 2];
    $8 = HEAP32[$5 >> 2];
    HEAP32[$7 + 104 >> 2] = $8;
    HEAP32[$7 + 108 >> 2] = $6;
    $2 = tokenExpr($3, 59, $7 + 104 | 0);
    $10 = $4 - 20 | 0;
    $6 = HEAP32[$10 >> 2];
    $8 = HEAP32[$10 + 4 >> 2];
    HEAP32[$7 + 96 >> 2] = $6;
    HEAP32[$7 + 100 >> 2] = $8;
    $9 = tokenExpr($3, 59, $7 + 96 | 0);
    $6 = HEAP32[$4 + 8 >> 2];
    $8 = HEAP32[$4 + 4 >> 2];
    HEAP32[$7 + 88 >> 2] = $8;
    HEAP32[$7 + 92 >> 2] = $6;
    $9 = sqlite3PExpr($3, 141, $9, tokenExpr($3, 59, $7 + 88 | 0));
    if (HEAPU8[$3 + 208 | 0] >= 2) {
     sqlite3RenameTokenRemap($3, 0, $2);
    }
    HEAP32[$5 >> 2] = sqlite3PExpr($3, 141, $2, $9);
    break label$1;

   case 182:
   case 183:
    $2 = HEAPU16[$4 + 2 >> 1];
    $8 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 4 >> 2];
    HEAP32[$7 + 112 >> 2] = $6;
    HEAP32[$7 + 116 >> 2] = $8;
    HEAP32[$4 + 4 >> 2] = tokenExpr($3, $2, $7 + 112 | 0);
    break label$1;

   case 184:
    $2 = $4 + 4 | 0;
    $5 = sqlite3ExprAlloc(HEAP32[$3 >> 2], 155, $2, 1);
    if ($5) {
     HEAP32[$5 + 36 >> 2] = HEAP32[$4 + 4 >> 2] - HEAP32[$3 + 232 >> 2];
    }
    HEAP32[$4 + 4 >> 2] = $5;
    break label$1;

   case 185:
    $10 = $4;
    $5 = HEAP32[$4 + 4 >> 2];
    if (!(HEAPU8[$5 | 0] == 35 & HEAPU8[$5 + 1 | 0] - 58 >>> 0 > 4294967285)) {
     $5 = HEAP32[$4 + 8 >> 2];
     $8 = HEAP32[$10 + 4 >> 2];
     $6 = HEAP32[$10 + 8 >> 2];
     HEAP32[$7 + 120 >> 2] = $8;
     HEAP32[$7 + 124 >> 2] = $6;
     $2 = tokenExpr($3, 156, $7 + 120 | 0);
     HEAP32[$4 + 4 >> 2] = $2;
     sqlite3ExprAssignVarNumber($3, $2, $5);
     break label$1;
    }
    $6 = HEAP32[$10 + 4 >> 2];
    $2 = $6;
    $8 = HEAP32[$10 + 8 >> 2];
    HEAP32[$7 + 144 >> 2] = $2;
    HEAP32[$7 + 148 >> 2] = $8;
    if (!HEAPU8[$3 + 18 | 0]) {
     HEAP32[$7 + 128 >> 2] = $7 + 144;
     sqlite3ErrorMsg($3, 8506, $7 + 128 | 0);
     HEAP32[$10 + 4 >> 2] = 0;
     break label$1;
    }
    $3 = sqlite3PExpr($3, 176, 0, 0);
    HEAP32[$10 + 4 >> 2] = $3;
    if (!$3) {
     break label$1;
    }
    sqlite3GetInt32($2 + 1 | 0, $3 + 28 | 0);
    break label$1;

   case 186:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprAddCollateToken($3, HEAP32[$2 >> 2], $4 + 4 | 0, 1);
    break label$1;

   case 187:
    $2 = sqlite3ExprAlloc(HEAP32[$3 >> 2], 36, $4 - 8 | 0, 1);
    HEAP32[$4 - 56 >> 2] = $2;
    sqlite3ExprAttachSubtrees(HEAP32[$3 >> 2], $2, HEAP32[$4 - 32 >> 2], 0);
    break label$1;

   case 188:
    $2 = $4 - 44 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprFunction($3, HEAP32[$4 - 8 >> 2], $2, HEAP32[$4 - 20 >> 2]);
    break label$1;

   case 189:
    $2 = $4 - 32 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprFunction($3, 0, $2, 0);
    break label$1;

   case 190:
    $2 = $4 - 56 | 0;
    $5 = sqlite3ExprFunction($3, HEAP32[$4 - 20 >> 2], $2, HEAP32[$4 - 32 >> 2]);
    sqlite3WindowAttach($3, $5, HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    break label$1;

   case 191:
    $2 = $4 - 44 | 0;
    $5 = sqlite3ExprFunction($3, 0, $2, 0);
    sqlite3WindowAttach($3, $5, HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    break label$1;

   case 192:
    HEAP32[$4 + 4 >> 2] = sqlite3ExprFunction($3, 0, $4 + 4 | 0, 0);
    break label$1;

   case 193:
    $2 = sqlite3ExprListAppend($3, HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2]);
    $9 = $4 - 44 | 0;
    $5 = sqlite3PExpr($3, 177, 0, 0);
    HEAP32[$9 >> 2] = $5;
    if ($5) {
     HEAP32[$5 + 20 >> 2] = $2;
     if (!HEAP32[$2 >> 2]) {
      break label$1;
     }
     $3 = HEAP32[$9 >> 2];
     HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] | HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] & 4194824;
     break label$1;
    }
    sqlite3ExprListDelete(HEAP32[$3 >> 2], $2);
    break label$1;

   case 194:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprAnd($3, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 195:
   case 196:
   case 197:
   case 198:
   case 199:
   case 200:
   case 201:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3PExpr($3, HEAPU16[$4 - 10 >> 1], HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 202:
    $8 = HEAP32[$4 + 4 >> 2];
    $2 = $8;
    $6 = HEAP32[$4 + 8 >> 2];
    $3 = $4 - 12 | 0;
    HEAP32[$3 + 4 >> 2] = $2;
    HEAP32[$3 + 8 >> 2] = $6;
    HEAP32[$3 + 8 >> 2] = $6 | -2147483648;
    break label$1;

   case 203:
    $2 = $4 - 4 | 0;
    $9 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $9 & 2147483647;
    $5 = $4 - 20 | 0;
    $2 = sqlite3ExprFunction($3, sqlite3ExprListAppend($3, sqlite3ExprListAppend($3, 0, HEAP32[$4 + 4 >> 2]), HEAP32[$5 >> 2]), $4 - 8 | 0, 0);
    HEAP32[$5 >> 2] = $2;
    if (($9 | 0) < 0) {
     $2 = sqlite3PExpr($3, 19, $2, 0);
     HEAP32[$5 >> 2] = $2;
    }
    if (!$2) {
     break label$1;
    }
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 256;
    break label$1;

   case 204:
    $2 = $4 - 28 | 0;
    $9 = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = $9 & 2147483647;
    $5 = $4 - 44 | 0;
    $2 = sqlite3ExprFunction($3, sqlite3ExprListAppend($3, sqlite3ExprListAppend($3, sqlite3ExprListAppend($3, 0, HEAP32[$4 - 20 >> 2]), HEAP32[$5 >> 2]), HEAP32[$4 + 4 >> 2]), $4 - 32 | 0, 0);
    HEAP32[$5 >> 2] = $2;
    if (($9 | 0) < 0) {
     $2 = sqlite3PExpr($3, 19, $2, 0);
     HEAP32[$5 >> 2] = $2;
    }
    if (!$2) {
     break label$1;
    }
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 256;
    break label$1;

   case 205:
    $2 = $4 - 8 | 0;
    HEAP32[$2 >> 2] = sqlite3PExpr($3, HEAPU16[$4 + 2 >> 1], HEAP32[$2 >> 2], 0);
    break label$1;

   case 206:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3PExpr($3, 51, HEAP32[$2 >> 2], 0);
    break label$1;

   case 207:
    $2 = $4 - 20 | 0;
    $5 = sqlite3PExpr($3, 45, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    binaryToUnaryIfNull($3, HEAP32[$4 + 4 >> 2], $5, 50);
    break label$1;

   case 208:
    $2 = $4 - 32 | 0;
    $5 = sqlite3PExpr($3, 171, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    binaryToUnaryIfNull($3, HEAP32[$4 + 4 >> 2], $5, 51);
    break label$1;

   case 209:
    $2 = $4 - 56 | 0;
    $5 = sqlite3PExpr($3, 45, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    binaryToUnaryIfNull($3, HEAP32[$4 + 4 >> 2], $5, 50);
    break label$1;

   case 210:
    $2 = $4 - 44 | 0;
    $5 = sqlite3PExpr($3, 171, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    HEAP32[$2 >> 2] = $5;
    binaryToUnaryIfNull($3, HEAP32[$4 + 4 >> 2], $5, 51);
    break label$1;

   case 211:
   case 212:
    $2 = $4 - 12 | 0;
    HEAP32[$2 + 4 >> 2] = sqlite3PExpr($3, HEAPU16[$2 + 2 >> 1], HEAP32[$4 + 4 >> 2], 0);
    break label$1;

   case 213:
    $2 = $4 - 12 | 0;
    HEAP32[$2 + 4 >> 2] = sqlite3PExpr($3, HEAPU16[$2 + 2 >> 1] == 106 ? 174 : 173, HEAP32[$4 + 4 >> 2], 0);
    break label$1;

   case 214:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprFunction($3, sqlite3ExprListAppend($3, sqlite3ExprListAppend($3, 0, HEAP32[$2 >> 2]), HEAP32[$4 + 4 >> 2]), $4 - 8 | 0, 0);
    break label$1;

   case 215:
   case 218:
    HEAP32[$4 + 4 >> 2] = 0;
    break label$1;

   case 217:
    $9 = sqlite3ExprListAppend($3, sqlite3ExprListAppend($3, 0, HEAP32[$4 - 20 >> 2]), HEAP32[$4 + 4 >> 2]);
    $2 = $4 - 44 | 0;
    $5 = sqlite3PExpr($3, 48, HEAP32[$2 >> 2], 0);
    HEAP32[$2 >> 2] = $5;
    label$304: {
     if ($5) {
      HEAP32[$5 + 20 >> 2] = $9;
      break label$304;
     }
     sqlite3ExprListDelete(HEAP32[$3 >> 2], $9);
    }
    if (!HEAP32[$4 - 32 >> 2]) {
     break label$1;
    }
    HEAP32[$2 >> 2] = sqlite3PExpr($3, 19, HEAP32[$2 >> 2], 0);
    break label$1;

   case 220:
    $5 = $4 - 8 | 0;
    $2 = HEAP32[$5 >> 2];
    if (!$2) {
     $2 = $4 - 44 | 0;
     sqlite3ExprUnmapAndDelete($3, HEAP32[$2 >> 2]);
     $3 = sqlite3Expr(HEAP32[$3 >> 2], 117, HEAP32[$4 - 32 >> 2] ? 12326 : 12859);
     HEAP32[$2 >> 2] = $3;
     if (!$3) {
      break label$1;
     }
     sqlite3ExprIdToTrueFalse($3);
     break label$1;
    }
    label$307: {
     label$308: {
      if (HEAP32[$2 >> 2] != 1) {
       break label$308;
      }
      $2 = HEAP32[$2 + 8 >> 2];
      if (!sqlite3ExprIsConstant($2)) {
       break label$308;
      }
      $9 = $4 - 44 | 0;
      if (HEAPU8[HEAP32[$9 >> 2]] == 177) {
       break label$308;
      }
      HEAP32[HEAP32[$5 >> 2] + 8 >> 2] = 0;
      sqlite3ExprListDelete(HEAP32[$3 >> 2], HEAP32[$5 >> 2]);
      $2 = sqlite3PExpr($3, 174, $2, 0);
      HEAP32[$9 >> 2] = sqlite3PExpr($3, 53, HEAP32[$9 >> 2], $2);
      break label$307;
     }
     $2 = $4 - 44 | 0;
     $9 = sqlite3PExpr($3, 49, HEAP32[$2 >> 2], 0);
     HEAP32[$2 >> 2] = $9;
     if (!$9) {
      sqlite3ExprListDelete(HEAP32[$3 >> 2], HEAP32[$5 >> 2]);
      break label$307;
     }
     $6 = HEAP32[$9 + 12 >> 2];
     if (HEAPU8[$6 | 0] == 177) {
      $5 = sqlite3ExprListToValues($3, HEAP32[HEAP32[$6 + 20 >> 2] >> 2], HEAP32[$5 >> 2]);
      if (!$5) {
       break label$307;
      }
      parserDoubleLinkSelect($3, $5);
      sqlite3PExprAddSelect($3, HEAP32[$2 >> 2], $5);
      break label$307;
     }
     HEAP32[$9 + 20 >> 2] = HEAP32[$5 >> 2];
     sqlite3ExprSetHeightAndFlags($3, HEAP32[$2 >> 2]);
    }
    if (!HEAP32[$4 - 32 >> 2]) {
     break label$1;
    }
    $2 = $4 - 44 | 0;
    HEAP32[$2 >> 2] = sqlite3PExpr($3, 19, HEAP32[$2 >> 2], 0);
    break label$1;

   case 221:
    $2 = sqlite3PExpr($3, 138, 0, 0);
    HEAP32[$4 - 20 >> 2] = $2;
    sqlite3PExprAddSelect($3, $2, HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 222:
    $2 = $4 - 44 | 0;
    $5 = sqlite3PExpr($3, 49, HEAP32[$2 >> 2], 0);
    HEAP32[$2 >> 2] = $5;
    sqlite3PExprAddSelect($3, $5, HEAP32[$4 - 8 >> 2]);
    if (!HEAP32[$4 - 32 >> 2]) {
     break label$1;
    }
    HEAP32[$2 >> 2] = sqlite3PExpr($3, 19, HEAP32[$2 >> 2], 0);
    break label$1;

   case 223:
    $2 = sqlite3SrcListAppend($3, 0, $4 - 20 | 0, $4 - 8 | 0);
    $5 = sqlite3SelectNew($3, 0, $2, 0, 0, 0, 0, 0, 0);
    $9 = HEAP32[$4 + 4 >> 2];
    if ($9) {
     sqlite3SrcListFuncArgs($3, $5 ? $2 : 0, $9);
    }
    $2 = $4 - 44 | 0;
    $9 = sqlite3PExpr($3, 49, HEAP32[$2 >> 2], 0);
    HEAP32[$2 >> 2] = $9;
    sqlite3PExprAddSelect($3, $9, $5);
    if (!HEAP32[$4 - 32 >> 2]) {
     break label$1;
    }
    HEAP32[$2 >> 2] = sqlite3PExpr($3, 19, HEAP32[$2 >> 2], 0);
    break label$1;

   case 224:
    $2 = sqlite3PExpr($3, 20, 0, 0);
    HEAP32[$4 - 32 >> 2] = $2;
    sqlite3PExprAddSelect($3, $2, HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 225:
    $9 = $4 - 44 | 0;
    $2 = sqlite3PExpr($3, 157, HEAP32[$4 - 32 >> 2], 0);
    HEAP32[$9 >> 2] = $2;
    if ($2) {
     $5 = HEAP32[$4 - 20 >> 2];
     $6 = HEAP32[$4 - 8 >> 2];
     if ($6) {
      $5 = sqlite3ExprListAppend($3, $5, $6);
      $2 = HEAP32[$9 >> 2];
     }
     HEAP32[$2 + 20 >> 2] = $5;
     sqlite3ExprSetHeightAndFlags($3, HEAP32[$9 >> 2]);
     break label$1;
    }
    sqlite3ExprListDelete(HEAP32[$3 >> 2], HEAP32[$4 - 20 >> 2]);
    sqlite3ExprDelete(HEAP32[$3 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 226:
    $2 = $4 - 44 | 0;
    $5 = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], HEAP32[$4 - 20 >> 2]);
    HEAP32[$2 >> 2] = $5;
    HEAP32[$2 >> 2] = sqlite3ExprListAppend($3, $5, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 227:
    $2 = $4 - 32 | 0;
    $5 = sqlite3ExprListAppend($3, 0, HEAP32[$4 - 20 >> 2]);
    HEAP32[$2 >> 2] = $5;
    HEAP32[$2 >> 2] = sqlite3ExprListAppend($3, $5, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 233:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3ExprListAppend($3, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 234:
    HEAP32[$4 + 4 >> 2] = sqlite3ExprListAppend($3, 0, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 236:
   case 241:
    HEAP32[$4 - 20 >> 2] = HEAP32[$4 - 8 >> 2];
    break label$1;

   case 237:
    $2 = $4 - 44 | 0;
    sqlite3CreateIndex($3, $4 - 80 | 0, $4 - 68 | 0, sqlite3SrcListAppend($3, 0, $2, 0), HEAP32[$4 - 20 >> 2], HEAP32[$4 - 116 >> 2], $4 - 128 | 0, HEAP32[$4 + 4 >> 2], 0, HEAP32[$4 - 92 >> 2], 0);
    if (HEAPU8[$3 + 208 | 0] < 2) {
     break label$1;
    }
    $5 = HEAP32[$3 + 240 >> 2];
    if (!$5) {
     break label$1;
    }
    sqlite3RenameTokenMap($3, HEAP32[$5 >> 2], $2);
    break label$1;

   case 238:
   case 280:
    HEAP32[$4 + 4 >> 2] = 2;
    break label$1;

   case 239:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 242:
    $2 = $4 - 44 | 0;
    HEAP32[$2 >> 2] = parserAddExprIdListTerm($3, HEAP32[$2 >> 2], $4 - 20 | 0, HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 243:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = parserAddExprIdListTerm($3, 0, $2, HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 246:
    sqlite3DropIndex($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 247:
    sqlite3Vacuum($3, 0, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 248:
    sqlite3Vacuum($3, $4 - 8 | 0, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 251:
    sqlite3Pragma($3, $4 - 8 | 0, $4 + 4 | 0, 0, 0);
    break label$1;

   case 252:
    sqlite3Pragma($3, $4 - 32 | 0, $4 - 20 | 0, $4 + 4 | 0, 0);
    break label$1;

   case 253:
    sqlite3Pragma($3, $4 - 44 | 0, $4 - 32 | 0, $4 - 8 | 0, 0);
    break label$1;

   case 254:
    sqlite3Pragma($3, $4 - 32 | 0, $4 - 20 | 0, $4 + 4 | 0, 1);
    break label$1;

   case 255:
    sqlite3Pragma($3, $4 - 44 | 0, $4 - 32 | 0, $4 - 8 | 0, 1);
    break label$1;

   case 258:
    $2 = HEAP32[$4 - 32 >> 2];
    HEAP32[$7 + 144 >> 2] = $2;
    HEAP32[$7 + 148 >> 2] = HEAP32[$4 + 8 >> 2] + (HEAP32[$4 + 4 >> 2] - $2 | 0);
    sqlite3FinishTrigger($3, HEAP32[$4 - 8 >> 2], $7 + 144 | 0);
    break label$1;

   case 259:
    $9 = $4 - 80 | 0;
    $5 = $4 - 68 | 0;
    $2 = $4 - 48 | 0;
    $6 = HEAP32[$2 + 4 >> 2];
    $8 = HEAP32[$2 + 8 >> 2];
    $2 = $4 - 116 | 0;
    sqlite3BeginTrigger($3, $9, $5, HEAP32[$4 - 56 >> 2], $6, $8, HEAP32[$4 - 20 >> 2], HEAP32[$4 + 4 >> 2], HEAP32[$2 >> 2], HEAP32[$4 - 92 >> 2]);
    if (!HEAP32[$4 + -64 >> 2]) {
     $10 = HEAP32[$9 + 4 >> 2];
     $8 = HEAP32[$9 >> 2];
     HEAP32[$2 >> 2] = $8;
     HEAP32[$2 + 4 >> 2] = $10;
     break label$1;
    }
    $8 = HEAP32[$5 + 4 >> 2];
    $10 = HEAP32[$5 >> 2];
    HEAP32[$2 >> 2] = $10;
    HEAP32[$2 + 4 >> 2] = $8;
    break label$1;

   case 260:
    HEAP32[$4 + 4 >> 2] = HEAPU16[$4 + 2 >> 1];
    break label$1;

   case 261:
    HEAP32[$4 - 8 >> 2] = 65;
    break label$1;

   case 262:
    HEAP32[$4 + 16 >> 2] = 33;
    break label$1;

   case 263:
   case 264:
    HEAP32[$4 + 8 >> 2] = 0;
    HEAP32[$4 + 4 >> 2] = HEAPU16[$4 + 2 >> 1];
    break label$1;

   case 265:
    $3 = $4 - 24 | 0;
    HEAP32[$3 + 4 >> 2] = 129;
    HEAP32[$3 + 8 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 266:
   case 285:
    HEAP32[$4 + 16 >> 2] = 0;
    break label$1;

   case 267:
   case 286:
    HEAP32[$4 - 8 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 268:
    $3 = $4 - 20 | 0;
    $2 = $4 - 8 | 0;
    HEAP32[HEAP32[HEAP32[$3 >> 2] + 44 >> 2] + 40 >> 2] = HEAP32[$2 >> 2];
    HEAP32[HEAP32[$3 >> 2] + 44 >> 2] = HEAP32[$2 >> 2];
    break label$1;

   case 269:
    $3 = HEAP32[$4 - 8 >> 2];
    HEAP32[$3 + 44 >> 2] = $3;
    break label$1;

   case 270:
    $10 = HEAP32[$4 + 8 >> 2];
    $8 = HEAP32[$4 + 4 >> 2];
    $2 = $8;
    $8 = $4 - 20 | 0;
    HEAP32[$8 >> 2] = $2;
    HEAP32[$8 + 4 >> 2] = $10;
    sqlite3ErrorMsg($3, 4361, 0);
    break label$1;

   case 271:
    sqlite3ErrorMsg($3, 4192, 0);
    break label$1;

   case 272:
    sqlite3ErrorMsg($3, 4276, 0);
    break label$1;

   case 273:
    $2 = $4 - 92 | 0;
    HEAP32[$2 >> 2] = sqlite3TriggerUpdateStep($3, $4 - 68 | 0, HEAP32[$4 - 20 >> 2], HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2], HEAPU8[$4 - 80 | 0], HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 274:
    $2 = $4 - 80 | 0;
    HEAP32[$2 >> 2] = sqlite3TriggerInsertStep($3, $4 - 44 | 0, HEAP32[$4 - 32 >> 2], HEAP32[$4 - 20 >> 2], HEAPU8[$4 - 68 | 0], HEAP32[$4 - 8 >> 2], HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 275:
    $2 = $4 - 56 | 0;
    HEAP32[$2 >> 2] = sqlite3TriggerDeleteStep($3, $4 - 32 | 0, HEAP32[$4 - 8 >> 2], HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 276:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3TriggerSelectStep(HEAP32[$3 >> 2], HEAP32[$4 - 8 >> 2], HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 277:
    $3 = sqlite3PExpr($3, 71, 0, 0);
    HEAP32[$4 - 32 >> 2] = $3;
    if (!$3) {
     break label$1;
    }
    HEAP8[$3 + 1 | 0] = 4;
    break label$1;

   case 278:
    $3 = sqlite3ExprAlloc(HEAP32[$3 >> 2], 71, $4 - 8 | 0, 1);
    HEAP32[$4 - 56 >> 2] = $3;
    if (!$3) {
     break label$1;
    }
    HEAP8[$3 + 1 | 0] = HEAP32[$4 - 32 >> 2];
    break label$1;

   case 279:
    HEAP32[$4 + 4 >> 2] = 1;
    break label$1;

   case 281:
    HEAP32[$4 + 4 >> 2] = 3;
    break label$1;

   case 282:
    sqlite3DropTrigger($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 8 >> 2]);
    break label$1;

   case 283:
    sqlite3Attach($3, HEAP32[$4 - 32 >> 2], HEAP32[$4 - 8 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 284:
    sqlite3Detach($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 287:
    sqlite3Reindex($3, 0, 0);
    break label$1;

   case 288:
    sqlite3Reindex($3, $4 - 8 | 0, $4 + 4 | 0);
    break label$1;

   case 289:
    sqlite3Analyze($3, 0, 0);
    break label$1;

   case 290:
    sqlite3Analyze($3, $4 - 8 | 0, $4 + 4 | 0);
    break label$1;

   case 291:
    sqlite3AlterRenameTable($3, HEAP32[$4 - 32 >> 2], $4 + 4 | 0);
    break label$1;

   case 292:
    $2 = $4 - 12 | 0;
    $6 = $2;
    $2 = $2 + 4 | 0;
    HEAP32[$6 + 8 >> 2] = HEAP32[$3 + 200 >> 2] + (HEAP32[$3 + 196 >> 2] - HEAP32[$2 >> 2] | 0);
    sqlite3AlterFinishAddColumn($3, $2);
    break label$1;

   case 293:
    sqlite3AlterDropColumn($3, HEAP32[$4 - 32 >> 2], $4 + 4 | 0);
    break label$1;

   case 294:
    disableLookaside($3);
    sqlite3AlterBeginAddColumn($3, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 295:
    sqlite3AlterRenameColumn($3, HEAP32[$4 - 56 >> 2], $4 - 20 | 0, $4 + 4 | 0);
    break label$1;

   case 296:
    sqlite3VtabFinishParse($3, 0);
    break label$1;

   case 297:
    sqlite3VtabFinishParse($3, $4 + 4 | 0);
    break label$1;

   case 298:
    sqlite3VtabBeginParse($3, $4 - 32 | 0, $4 - 20 | 0, $4 + 4 | 0, HEAP32[$4 - 44 >> 2]);
    break label$1;

   case 299:
    sqlite3VtabArgInit($3);
    break label$1;

   case 300:
   case 301:
   case 302:
    sqlite3VtabArgExtend($3, $4 + 4 | 0);
    break label$1;

   case 303:
   case 304:
    sqlite3WithPush($3, HEAP32[$4 + 4 >> 2], 1);
    break label$1;

   case 305:
    HEAP8[$4 + 4 | 0] = 1;
    break label$1;

   case 306:
    HEAP8[$4 - 8 | 0] = 0;
    break label$1;

   case 307:
    HEAP8[$4 - 20 | 0] = 2;
    break label$1;

   case 308:
    $2 = $4 - 56 | 0;
    HEAP32[$2 >> 2] = sqlite3CteNew($3, $2, HEAP32[$4 - 44 >> 2], HEAP32[$4 - 8 >> 2], HEAPU8[$4 - 32 | 0]);
    break label$1;

   case 309:
    HEAP32[$4 + 4 >> 2] = sqlite3WithAdd($3, 0, HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 310:
    $2 = $4 - 20 | 0;
    HEAP32[$2 >> 2] = sqlite3WithAdd($3, HEAP32[$2 >> 2], HEAP32[$4 + 4 >> 2]);
    break label$1;

   case 312:
    $2 = $4 - 20 | 0;
    sqlite3WindowChain($3, HEAP32[$4 + 4 >> 2], HEAP32[$2 >> 2]);
    HEAP32[HEAP32[$4 + 4 >> 2] + 36 >> 2] = HEAP32[$2 >> 2];
    HEAP32[$2 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 313:
    $6 = $4 - 44 | 0;
    $2 = $4 - 8 | 0;
    if (HEAP32[$2 >> 2]) {
     $8 = HEAP32[$3 >> 2];
     $3 = $4 - 48 | 0;
     $10 = HEAP32[$3 + 8 >> 2];
     $3 = sqlite3DbStrNDup($8, HEAP32[$3 + 4 >> 2], $10, 0);
     HEAP32[HEAP32[$2 >> 2] >> 2] = $3;
     $3 = HEAP32[$2 >> 2];
    } else {
     $3 = 0;
    }
    HEAP32[$6 >> 2] = $3;
    break label$1;

   case 314:
    HEAP32[$4 - 44 >> 2] = sqlite3WindowAssemble($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$4 - 8 >> 2], 0);
    break label$1;

   case 315:
    $2 = $4 - 56 | 0;
    HEAP32[$2 >> 2] = sqlite3WindowAssemble($3, HEAP32[$4 + 4 >> 2], HEAP32[$4 - 20 >> 2], HEAP32[$4 - 8 >> 2], $2);
    break label$1;

   case 316:
    HEAP32[$4 - 32 >> 2] = sqlite3WindowAssemble($3, HEAP32[$4 + 4 >> 2], 0, HEAP32[$4 - 8 >> 2], 0);
    break label$1;

   case 317:
    $2 = $4 - 44 | 0;
    HEAP32[$2 >> 2] = sqlite3WindowAssemble($3, HEAP32[$4 + 4 >> 2], 0, HEAP32[$4 - 8 >> 2], $2);
    break label$1;

   case 319:
    $2 = $4 - 8 | 0;
    HEAP32[$2 >> 2] = sqlite3WindowAssemble($3, HEAP32[$4 + 4 >> 2], 0, 0, $2);
    break label$1;

   case 320:
    HEAP32[$4 + 16 >> 2] = sqlite3WindowAlloc($3, 0, 90, 0, 85, 0, 0);
    break label$1;

   case 321:
    $2 = $4 - 20 | 0;
    $5 = $4 - 12 | 0;
    HEAP32[$2 >> 2] = sqlite3WindowAlloc($3, HEAP32[$2 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], 85, 0, HEAPU8[$4 + 4 | 0]);
    break label$1;

   case 322:
    $2 = $4 - 56 | 0;
    $5 = $4 - 36 | 0;
    $6 = HEAP32[$5 + 4 >> 2];
    $8 = HEAP32[$5 + 8 >> 2];
    $5 = $4 - 12 | 0;
    HEAP32[$2 >> 2] = sqlite3WindowAlloc($3, HEAP32[$2 >> 2], $6, $8, HEAP32[$5 + 4 >> 2], HEAP32[$5 + 8 >> 2], HEAPU8[$4 + 4 | 0]);
    break label$1;

   case 325:
   case 327:
   case 329:
    $3 = $4 - 12 | 0;
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$3 + 4 >> 2] = HEAPU16[$3 + 2 >> 1];
    break label$1;

   case 328:
    $3 = $4 - 12 | 0;
    $2 = $3;
    $3 = $3 + 4 | 0;
    HEAP32[$2 + 8 >> 2] = HEAP32[$3 >> 2];
    HEAP32[$2 + 4 >> 2] = HEAPU16[$4 + 2 >> 1];
    break label$1;

   case 330:
    HEAP8[$4 + 16 | 0] = 0;
    break label$1;

   case 331:
    HEAP8[$4 - 8 | 0] = HEAPU8[$4 + 4 | 0];
    break label$1;

   case 332:
   case 333:
    $3 = $4 - 12 | 0;
    HEAP8[$3 + 4 | 0] = HEAPU8[$3 + 2 | 0];
    break label$1;

   case 334:
    HEAP8[$4 + 4 | 0] = HEAPU8[$4 + 2 | 0];
    break label$1;

   case 335:
    HEAP32[$4 - 8 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 336:
    $2 = HEAP32[$4 + 4 >> 2];
    label$317: {
     if ($2) {
      HEAP32[$2 + 40 >> 2] = HEAP32[$4 - 8 >> 2];
      break label$317;
     }
     sqlite3ExprDelete(HEAP32[$3 >> 2], HEAP32[$4 - 8 >> 2]);
    }
    HEAP32[$4 - 8 >> 2] = HEAP32[$4 + 4 >> 2];
    break label$1;

   case 338:
    $2 = sqlite3DbMallocZero(HEAP32[$3 >> 2], 100, 0);
    label$319: {
     if ($2) {
      HEAP8[$2 + 16 | 0] = 166;
      HEAP32[$2 + 40 >> 2] = HEAP32[$4 + 4 >> 2];
      break label$319;
     }
     sqlite3ExprDelete(HEAP32[$3 >> 2], HEAP32[$4 + 4 >> 2]);
    }
    HEAP32[$4 + 4 >> 2] = $2;
    break label$1;

   case 339:
    HEAP32[$4 - 32 >> 2] = HEAP32[$4 - 8 >> 2];
    break label$1;

   case 340:
    $5 = $4 - 8 | 0;
    $2 = sqlite3DbMallocZero(HEAP32[$3 >> 2], 100, 0);
    HEAP32[$5 >> 2] = $2;
    if (!$2) {
     break label$1;
    }
    $8 = HEAP32[$4 + 8 >> 2];
    $3 = sqlite3DbStrNDup(HEAP32[$3 >> 2], HEAP32[$4 + 4 >> 2], $8, 0);
    HEAP32[HEAP32[$5 >> 2] >> 2] = $3;
    break label$1;

   case 341:
    break label$2;

   default:
    break label$1;
   }
  }
  HEAP32[$4 - 44 >> 2] = HEAP32[$4 - 8 >> 2];
 }
 $4 = Math_imul(HEAP8[$1 + 36224 | 0], 12) + $4 | 0;
 $3 = HEAPU16[$4 >> 1];
 $2 = $4 + 12 | 0;
 HEAP32[$0 >> 2] = $2;
 $0 = $4;
 $4 = HEAPU16[($1 << 1) + 47760 >> 1];
 HEAP16[$0 + 14 >> 1] = $4;
 $4 = yy_find_reduce_action($3, $4);
 HEAP16[$0 + 12 >> 1] = $4;
 __stack_pointer = $7 + 176 | 0;
 return $4;
}

function sqlite3Select($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;
 $7 = __stack_pointer - 160 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 100 >> 2] = 0;
 $13 = HEAP32[$0 >> 2];
 $4 = 1;
 $8 = sqlite3GetVdbe($0);
 label$1: {
  if (HEAP32[$0 + 36 >> 2] | !$1) {
   break label$1;
  }
  if (sqlite3AuthCheck($0, 21, 0, 0, 0)) {
   break label$1;
  }
  if (HEAPU8[$2 | 0] <= 6) {
   $4 = HEAP32[$1 + 48 >> 2];
   if ($4) {
    sqlite3ParserAddCleanup($0, 33, $4);
    HEAP32[$1 + 48 >> 2] = 0;
   }
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -4194306 | 4194304;
  }
  sqlite3SelectPrep($0, $1, 0);
  $4 = 1;
  label$4: {
   label$5: {
    if (HEAP32[$0 + 36 >> 2]) {
     break label$5;
    }
    $5 = HEAP32[$1 + 4 >> 2];
    if ($5 & 8388608) {
     $3 = HEAP32[$1 + 32 >> 2];
     if (sameSrcAlias($3 + 8 | 0, $3)) {
      $1 = HEAP32[$3 + 20 >> 2];
      if (!$1) {
       $1 = HEAP32[HEAP32[$3 + 24 >> 2] >> 2];
      }
      HEAP32[$7 + 48 >> 2] = $1;
      sqlite3ErrorMsg($0, 7535, $7 + 48 | 0);
      break label$5;
     }
     HEAP32[$1 + 4 >> 2] = $5 & -8388609;
    }
    if (HEAPU8[$2 | 0] == 9) {
     sqlite3GenerateColumnNames($0, $1);
    }
    if (sqlite3WindowRewrite($0, $1)) {
     break label$5;
    }
    $4 = HEAP32[$1 + 32 >> 2];
    $3 = HEAP32[$1 + 4 >> 2];
    memset($7 + 104 | 0, 0, 40);
    $14 = $3 >>> 3 & 1;
    $18 = HEAP32[$1 + 48 >> 2];
    $3 = 0;
    while (1) {
     label$11: {
      label$12: {
       label$13: {
        label$14: {
         label$15: {
          label$16: {
           label$17: {
            label$19: {
             label$20: {
              label$21: {
               label$23: {
                label$24: {
                 label$25: {
                  if (!HEAP32[$1 + 52 >> 2]) {
                   if (HEAP32[$4 >> 2] <= ($3 | 0)) {
                    break label$25;
                   }
                   $11 = ($3 << 6) + $4 | 0;
                   $6 = HEAP32[$11 + 24 >> 2];
                   $5 = HEAP32[$11 + 28 >> 2];
                   $9 = $11 + 44 | 0;
                   label$27: {
                    if ((HEAPU8[$9 | 0] & 24) != 8) {
                     break label$27;
                    }
                    $9 = $11;
                    $9 = $11;
                    $11 = $11 + 48 | 0;
                    if (!sqlite3ExprImpliesNonNullRow(HEAP32[$1 + 36 >> 2], HEAP32[$11 >> 2]) | HEAPU8[$13 + 81 | 0] & 32) {
                     break label$27;
                    }
                    HEAP8[$9 + 44 | 0] = HEAPU8[$9 + 44 | 0] & 215;
                    unsetJoinExpr(HEAP32[$1 + 36 >> 2], HEAP32[$9 + 48 >> 2], HEAPU8[$4 + 44 | 0] & 64);
                   }
                   if (!$5) {
                    break label$11;
                   }
                   $9 = HEAP16[$6 + 34 >> 1];
                   $11 = HEAP32[HEAP32[$5 + 28 >> 2] >> 2];
                   if (($9 | 0) != ($11 | 0)) {
                    HEAP32[$7 + 104 >> 2] = $18;
                    $1 = HEAP32[$6 >> 2];
                    HEAP32[$7 + 8 >> 2] = $11;
                    HEAP32[$7 + 4 >> 2] = $1;
                    HEAP32[$7 >> 2] = $9;
                    sqlite3ErrorMsg($0, 16421, $7);
                    break label$13;
                   }
                   $11 = HEAP32[$5 + 4 >> 2];
                   if ($11 & 8) {
                    break label$11;
                   }
                   $6 = HEAP32[$5 + 48 >> 2];
                   label$29: {
                    if (!$6) {
                     break label$29;
                    }
                    if (!(!HEAP32[$1 + 48 >> 2] & HEAP32[$4 >> 2] < 2 | (HEAP32[$5 + 60 >> 2] | $11 & 134217728) | (HEAPU8[$1 + 7 | 0] & 8 | HEAPU8[$13 + 82 | 0] & 4))) {
                     sqlite3ParserAddCleanup($0, 33, $6);
                     HEAP32[$5 + 48 >> 2] = 0;
                     break label$29;
                    }
                    if (!(HEAPU8[$1 + 6 | 0] & 4) | $3) {
                     break label$29;
                    }
                    if (HEAPU8[$4 + 108 | 0] & 34 | HEAP32[$4 >> 2] == 1) {
                     break label$12;
                    }
                   }
                   if (flattenSubquery($0, $1, $3, $14)) {
                    $3 = -1;
                    if (HEAP32[$0 + 36 >> 2]) {
                     break label$24;
                    }
                   }
                   if (HEAPU8[$13 + 87 | 0]) {
                    break label$24;
                   }
                   $4 = HEAP32[$1 + 32 >> 2];
                   if (HEAPU8[$2 | 0] < 9) {
                    break label$11;
                   }
                   $18 = HEAP32[$1 + 48 >> 2];
                   break label$11;
                  }
                  $4 = multiSelect($0, $1, $2);
                  if (!HEAP32[$1 + 56 >> 2]) {
                   break label$4;
                  }
                  break label$1;
                 }
                 HEAP32[$7 + 104 >> 2] = $18;
                 $3 = HEAP32[$1 + 36 >> 2];
                 if (!(HEAPU8[$13 + 81 | 0] & 128 | (!$3 | HEAPU8[$3 | 0] != 44))) {
                  propagateConstants($0, $1);
                 }
                 $5 = 0;
                 while (1) {
                  if (HEAP32[$4 >> 2] > ($5 | 0)) {
                   $3 = ($5 << 6) + $4 | 0;
                   label$36: {
                    if (HEAP32[$3 + 56 >> 2] | HEAP32[$3 + 60 >> 2]) {
                     break label$36;
                    }
                    $11 = HEAP32[$3 + 16 >> 2];
                    if (!$11) {
                     break label$36;
                    }
                    sqlite3AuthCheck($0, 20, $11, 29623, HEAP32[$3 + 12 >> 2]);
                   }
                   $11 = HEAP32[$3 + 28 >> 2];
                   if ($11) {
                    $6 = $3 + 8 | 0;
                    HEAP32[$0 + 216 >> 2] = sqlite3SelectExprHeight($1) + HEAP32[$0 + 216 >> 2];
                    label$38: {
                     if (HEAPU8[$13 + 81 | 0] & 16) {
                      break label$38;
                     }
                     if (HEAP8[$3 + 46 | 0] & 1) {
                      $9 = HEAP32[$3 + 68 >> 2];
                      if (!HEAPU8[$9 + 18 | 0] | HEAP32[$9 >> 2] > 1) {
                       break label$38;
                      }
                     }
                     pushDownWhereTerms($0, $11, HEAP32[$1 + 36 >> 2], $6);
                    }
                    $9 = HEAP32[$0 + 248 >> 2];
                    HEAP32[$0 + 248 >> 2] = HEAP32[$3 + 16 >> 2];
                    label$40: {
                     if (!((HEAPU8[$4 + 108 | 0] & 34 ? 0 : HEAP32[$4 >> 2] != 1) | $5 | (HEAPU8[$4 + 44 | 0] & 64 | (HEAPU8[HEAP32[$4 + 68 >> 2] + 18 | 0] ? 0 : HEAP8[$4 + 46 | 0] & 1)))) {
                      $3 = sqlite3VdbeCurrentAddr($8);
                      $10 = HEAP32[$0 + 44 >> 2] + 1 | 0;
                      HEAP32[$0 + 44 >> 2] = $10;
                      HEAP32[$4 + 36 >> 2] = $10;
                      $12 = $3 + 1 | 0;
                      sqlite3VdbeAddOp3($8, 10, $10, 0, $12);
                      HEAP32[$4 + 32 >> 2] = $12;
                      sqlite3SelectDestInit($7 - -64 | 0, 13, HEAP32[$4 + 36 >> 2]);
                      HEAP32[$7 + 16 >> 2] = $6;
                      sqlite3VdbeExplain($0, 1, 18882, $7 + 16 | 0);
                      sqlite3Select($0, $11, $7 - -64 | 0);
                      HEAP16[HEAP32[$4 + 24 >> 2] + 38 >> 1] = HEAPU16[$11 + 2 >> 1];
                      $11 = HEAPU8[$4 + 45 | 0] | HEAPU8[$4 + 46 | 0] << 8 | 32;
                      HEAP8[$4 + 45 | 0] = $11;
                      HEAP8[$4 + 46 | 0] = $11 >>> 8;
                      HEAP32[$4 + 40 >> 2] = HEAP32[$7 + 76 >> 2];
                      sqlite3VdbeEndCoroutine($8, HEAP32[$4 + 36 >> 2]);
                      sqlite3VdbeJumpHere($8, $3);
                      sqlite3ClearTempRegCache($0);
                      break label$40;
                     }
                     label$44: {
                      if (!(HEAP8[$3 + 46 | 0] & 1)) {
                       break label$44;
                      }
                      $10 = HEAP32[$3 + 68 >> 2];
                      $12 = HEAP32[$10 + 4 >> 2];
                      if (($12 | 0) <= 0) {
                       break label$44;
                      }
                      sqlite3VdbeAddOp2($8, 9, HEAP32[$10 + 8 >> 2], $12);
                      $3 = HEAP32[$3 + 48 >> 2];
                      $6 = HEAP32[$10 + 12 >> 2];
                      if (($3 | 0) != ($6 | 0)) {
                       sqlite3VdbeAddOp2($8, 115, $3, $6);
                      }
                      HEAP16[$11 + 2 >> 1] = HEAPU16[$10 + 16 >> 1];
                      break label$40;
                     }
                     $10 = isSelfJoinView($4, $6);
                     if ($10) {
                      $6 = HEAP32[$10 + 24 >> 2];
                      if ($6) {
                       sqlite3VdbeAddOp2($8, 9, HEAP32[$10 + 28 >> 2], $6);
                      }
                      sqlite3VdbeAddOp2($8, 115, HEAP32[$3 + 48 >> 2], HEAP32[$10 + 40 >> 2]);
                      HEAP16[$11 + 2 >> 1] = HEAPU16[HEAP32[$10 + 20 >> 2] + 2 >> 1];
                      break label$40;
                     }
                     $10 = HEAP32[$0 + 44 >> 2] + 1 | 0;
                     HEAP32[$0 + 44 >> 2] = $10;
                     $22 = $3;
                     $19 = $3 + 36 | 0;
                     HEAP32[$19 >> 2] = $10;
                     $17 = $3 + 32 | 0;
                     $16 = sqlite3VdbeAddOp0($8, 8);
                     $15 = $16 + 1 | 0;
                     HEAP32[$17 >> 2] = $15;
                     $12 = $3 + 45 | 0;
                     $20 = HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8;
                     $10 = $20 | 16;
                     HEAP8[$12 | 0] = $10;
                     HEAP8[$12 + 1 | 0] = $10 >>> 8;
                     $10 = 0;
                     if (!($20 & 8)) {
                      $10 = sqlite3VdbeAddOp0($8, 14);
                     }
                     $20 = $3 + 48 | 0;
                     sqlite3SelectDestInit($7 - -64 | 0, 12, HEAP32[$20 >> 2]);
                     HEAP32[$7 + 32 >> 2] = $6;
                     sqlite3VdbeExplain($0, 1, 18866, $7 + 32 | 0);
                     sqlite3Select($0, $11, $7 - -64 | 0);
                     HEAP16[HEAP32[$3 + 24 >> 2] + 38 >> 1] = HEAPU16[$11 + 2 >> 1];
                     if ($10) {
                      sqlite3VdbeJumpHere($8, $10);
                     }
                     sqlite3VdbeAddOp2($8, 67, HEAP32[$22 + 36 >> 2], $15);
                     sqlite3VdbeJumpHere($8, $16);
                     sqlite3ClearTempRegCache($0);
                     if (((HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8) & 264) != 256) {
                      break label$40;
                     }
                     $6 = $3;
                     $3 = HEAP32[$3 + 68 >> 2];
                     HEAP32[$3 + 4 >> 2] = HEAP32[$6 + 32 >> 2];
                     HEAP32[$3 + 8 >> 2] = HEAP32[$22 + 36 >> 2];
                     HEAP32[$3 + 12 >> 2] = HEAP32[$6 + 48 >> 2];
                     HEAP16[$3 + 16 >> 1] = HEAPU16[$11 + 2 >> 1];
                    }
                    if (HEAPU8[$13 + 87 | 0]) {
                     break label$13;
                    }
                    $3 = sqlite3SelectExprHeight($1);
                    HEAP32[$0 + 248 >> 2] = $9;
                    HEAP32[$0 + 216 >> 2] = HEAP32[$0 + 216 >> 2] - $3;
                   }
                   $5 = $5 + 1 | 0;
                   continue;
                  }
                  break;
                 }
                 $19 = HEAP32[$1 + 44 >> 2];
                 $9 = HEAP32[$1 + 40 >> 2];
                 $12 = HEAP32[$1 + 36 >> 2];
                 $11 = HEAP32[$1 + 28 >> 2];
                 $5 = HEAP32[$1 + 4 >> 2];
                 HEAP8[$7 + 144 | 0] = $5 & 1;
                 $3 = HEAP32[$7 + 104 >> 2];
                 label$50: {
                  if (($5 & 9) != 1) {
                   break label$50;
                  }
                  if (sqlite3ExprListCompare($3, $11, -1) | HEAP32[$1 + 68 >> 2]) {
                   break label$50;
                  }
                  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -2;
                  $9 = sqlite3ExprListDup($13, $11, 0);
                  HEAP32[$1 + 40 >> 2] = $9;
                  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 8;
                  HEAP8[$7 + 144 | 0] = 2;
                 }
                 if ($3) {
                  $6 = sqlite3KeyInfoFromExprList($0, $3, 0, HEAP32[$11 >> 2]);
                  $5 = HEAP32[$0 + 40 >> 2];
                  HEAP32[$0 + 40 >> 2] = $5 + 1;
                  HEAP32[$7 + 112 >> 2] = $5;
                  $3 = sqlite3VdbeAddOp4($8, 118, $5, (HEAP32[$3 >> 2] + HEAP32[$11 >> 2] | 0) + 1 | 0, 0, $6, -8);
                 } else {
                  $3 = -1;
                 }
                 HEAP32[$7 + 124 >> 2] = $3;
                 label$53: {
                  if (HEAPU8[$2 | 0] != 12) {
                   break label$53;
                  }
                  sqlite3VdbeAddOp2($8, 118, HEAP32[$2 + 4 >> 2], HEAP32[$11 >> 2]);
                  if (!(HEAPU8[$1 + 5 | 0] & 8)) {
                   break label$53;
                  }
                  $6 = HEAP32[$11 >> 2];
                  $3 = $6;
                  while (1) {
                   label$55: {
                    if (($3 | 0) < 2) {
                     break label$55;
                    }
                    $3 = $3 - 1 | 0;
                    $5 = ($3 << 4) + $11 | 0;
                    if (HEAPU8[$5 + 17 | 0] & 64) {
                     break label$55;
                    }
                    sqlite3ExprDelete($13, HEAP32[$5 + 8 >> 2]);
                    sqlite3DbFree($13, HEAP32[$5 + 12 >> 2]);
                    $6 = HEAP32[$11 >> 2] - 1 | 0;
                    HEAP32[$11 >> 2] = $6;
                    continue;
                   }
                   break;
                  }
                  $3 = 0;
                  $6 = ($6 | 0) > 0 ? $6 : 0;
                  while (1) {
                   if (($3 | 0) == ($6 | 0)) {
                    break label$53;
                   }
                   $5 = ($3 << 4) + $11 | 0;
                   if (!(HEAPU8[$5 + 17 | 0] & 64)) {
                    HEAP8[HEAP32[$5 + 8 >> 2]] = 121;
                   }
                   $3 = $3 + 1 | 0;
                   continue;
                  }
                 }
                 $18 = sqlite3VdbeMakeLabel($0);
                 if (!(HEAPU8[$1 + 5 | 0] & 64)) {
                  HEAP16[$1 + 2 >> 1] = 320;
                 }
                 computeLimitRegisters($0, $1, $18);
                 label$59: {
                  if (HEAP32[$1 + 8 >> 2]) {
                   break label$59;
                  }
                  $3 = HEAP32[$7 + 124 >> 2];
                  if (($3 | 0) < 0) {
                   break label$59;
                  }
                  sqlite3VdbeChangeOpcode($8, $3, 119);
                  HEAP8[$7 + 136 | 0] = HEAPU8[$7 + 136 | 0] | 1;
                 }
                 $3 = 0;
                 if (HEAP8[$1 + 4 | 0] & 1) {
                  $3 = HEAP32[$0 + 40 >> 2];
                  HEAP32[$0 + 40 >> 2] = $3 + 1;
                  HEAP32[$7 + 148 >> 2] = $3;
                  HEAP32[$7 + 152 >> 2] = sqlite3VdbeAddOp4($8, 118, $3, 0, 0, sqlite3KeyInfoFromExprList($0, HEAP32[$1 + 28 >> 2], 0, 0), -8);
                  sqlite3VdbeChangeP5($8, 8);
                  $3 = 3;
                 }
                 HEAP8[$7 + 145 | 0] = $3;
                 if (!($9 | $14)) {
                  $6 = HEAPU8[$7 + 144 | 0];
                  $5 = HEAP32[$1 + 4 >> 2] & 16384 | (($6 | 0) != 0) << 8;
                  $9 = HEAP32[$1 + 68 >> 2];
                  if ($9) {
                   sqlite3WindowCodeInit($0, $1);
                  }
                  $3 = HEAP32[$7 + 104 >> 2];
                  $4 = sqlite3WhereBegin($0, $4, $12, $3, HEAP32[$1 + 28 >> 2], $1, $5, HEAP16[$1 + 2 >> 1]);
                  if (!$4) {
                   break label$13;
                  }
                  $5 = sqlite3WhereOutputRowCount($4);
                  if (($5 | 0) < HEAP16[$1 + 2 >> 1]) {
                   HEAP16[$1 + 2 >> 1] = $5;
                  }
                  label$64: {
                   if (!$6) {
                    break label$64;
                   }
                   $5 = sqlite3WhereIsDistinct($4);
                   if (!$5) {
                    break label$64;
                   }
                   HEAP8[$7 + 145 | 0] = $5;
                  }
                  $5 = 0;
                  label$65: {
                   if (!$3) {
                    break label$65;
                   }
                   $6 = sqlite3WhereIsOrdered($4);
                   HEAP32[$7 + 108 >> 2] = $6;
                   HEAP32[$7 + 132 >> 2] = sqlite3WhereOrderByLimitOptLabel($4);
                   $5 = $3;
                   if (HEAP32[$3 >> 2] != ($6 | 0)) {
                    break label$65;
                   }
                   HEAP32[$7 + 104 >> 2] = 0;
                   $5 = 0;
                  }
                  $3 = HEAP32[$7 + 124 >> 2];
                  if (!($5 | ($3 | 0) < 0)) {
                   sqlite3VdbeChangeToNoop($8, $3);
                  }
                  if ($9) {
                   $5 = sqlite3VdbeMakeLabel($0);
                   $6 = sqlite3VdbeMakeLabel($0);
                   $3 = sqlite3VdbeMakeLabel($0);
                   $9 = HEAP32[$0 + 44 >> 2] + 1 | 0;
                   HEAP32[$0 + 44 >> 2] = $9;
                   sqlite3WindowCodeStep($0, $1, $4, $9, $5);
                   sqlite3VdbeAddOp2($8, 8, 0, $3);
                   sqlite3VdbeResolveLabel($8, $5);
                   HEAP32[$7 + 132 >> 2] = 0;
                   selectInnerLoop($0, $1, -1, $7 + 104 | 0, $7 + 144 | 0, $2, $6, $3);
                   sqlite3VdbeResolveLabel($8, $6);
                   sqlite3VdbeAddOp1($8, 67, $9);
                   sqlite3VdbeResolveLabel($8, $3);
                   break label$14;
                  }
                  selectInnerLoop($0, $1, -1, $7 + 104 | 0, $7 + 144 | 0, $2, sqlite3WhereContinueLabel($4), sqlite3WhereBreakLabel($4));
                  sqlite3WhereEnd($4);
                  break label$14;
                 }
                 label$68: {
                  if ($9) {
                   $3 = HEAP32[$1 + 28 >> 2];
                   $5 = $3 + 8 | 0;
                   $3 = HEAP32[$3 >> 2];
                   while (1) {
                    if (($3 | 0) > 0) {
                     HEAP16[$5 + 14 >> 1] = 0;
                     $5 = $5 + 16 | 0;
                     $3 = $3 - 1 | 0;
                     continue;
                    }
                    break;
                   }
                   $5 = $9 + 8 | 0;
                   $3 = HEAP32[$9 >> 2];
                   while (1) {
                    if (($3 | 0) > 0) {
                     HEAP16[$5 + 14 >> 1] = 0;
                     $5 = $5 + 16 | 0;
                     $3 = $3 - 1 | 0;
                     continue;
                    }
                    break;
                   }
                   if (HEAP16[$1 + 2 >> 1] >= 67) {
                    HEAP16[$1 + 2 >> 1] = 66;
                   }
                   $15 = 0;
                   $6 = HEAP32[$7 + 104 >> 2];
                   if (!$6) {
                    break label$68;
                   }
                   $5 = HEAP32[$9 >> 2];
                   if (($5 | 0) != HEAP32[$6 >> 2]) {
                    break label$68;
                   }
                   $3 = 0;
                   $10 = ($5 | 0) > 0 ? $5 : 0;
                   while (1) {
                    if (($3 | 0) != ($10 | 0)) {
                     $5 = $3 << 4;
                     HEAP8[($9 + $5 | 0) + 16 | 0] = HEAP8[($5 + $6 | 0) + 16 | 0] & 1;
                     $3 = $3 + 1 | 0;
                     continue;
                    }
                    break;
                   }
                   $15 = !sqlite3ExprListCompare($9, $6, -1);
                   break label$68;
                  }
                  $15 = 0;
                  HEAP16[$1 + 2 >> 1] = 0;
                 }
                 $16 = sqlite3VdbeMakeLabel($0);
                 $6 = sqlite3DbMallocZero($13, 52, 0);
                 if ($6) {
                  sqlite3ParserAddCleanup($0, 34, $6);
                 }
                 if (HEAPU8[$13 + 87 | 0]) {
                  break label$13;
                 }
                 HEAP32[$6 + 48 >> 2] = HEAP32[$1 + 16 >> 2];
                 $3 = 0;
                 HEAP32[$7 + 92 >> 2] = 0;
                 HEAP32[$7 + 84 >> 2] = 0;
                 HEAP32[$7 + 88 >> 2] = 0;
                 HEAP32[$7 + 76 >> 2] = 0;
                 HEAP32[$7 + 80 >> 2] = 0;
                 HEAP32[$7 + 72 >> 2] = $6;
                 HEAP32[$7 + 68 >> 2] = $4;
                 HEAP32[$7 + 64 >> 2] = $0;
                 HEAP32[$6 + 16 >> 2] = HEAP32[$0 + 44 >> 2] + 1;
                 $3 = $9 ? HEAP32[$9 >> 2] : $3;
                 HEAP32[$6 + 24 >> 2] = $9;
                 HEAP32[$6 + 12 >> 2] = $3;
                 sqlite3ExprAnalyzeAggList($7 - -64 | 0, $11);
                 sqlite3ExprAnalyzeAggList($7 - -64 | 0, HEAP32[$7 + 104 >> 2]);
                 if ($19) {
                  if ($9) {
                   havingToWhere($0, $1);
                   $12 = HEAP32[$1 + 36 >> 2];
                  }
                  sqlite3ExprAnalyzeAggregates($7 - -64 | 0, $19);
                 }
                 HEAP32[$6 + 36 >> 2] = HEAP32[$6 + 32 >> 2];
                 $3 = 0;
                 $10 = 0;
                 label$81: {
                  if (HEAP32[$1 + 40 >> 2]) {
                   break label$81;
                  }
                  $10 = 0;
                  if (HEAP32[$1 + 44 >> 2]) {
                   break label$81;
                  }
                  $10 = 0;
                  if (HEAP32[$6 + 44 >> 2] != 1) {
                   break label$81;
                  }
                  $10 = minMaxQuery($13, HEAP32[HEAP32[$6 + 40 >> 2] >> 2], $7 + 100 | 0);
                 }
                 while (1) {
                  $5 = HEAP32[$6 + 44 >> 2];
                  if (($5 | 0) > ($3 | 0)) {
                   $5 = HEAP32[HEAP32[$6 + 40 >> 2] + Math_imul($3, 20) >> 2];
                   HEAP32[$7 + 88 >> 2] = HEAP32[$7 + 88 >> 2] | 131072;
                   sqlite3ExprAnalyzeAggList($7 - -64 | 0, HEAP32[$5 + 20 >> 2]);
                   if (HEAP8[$5 + 7 | 0] & 1) {
                    sqlite3ExprAnalyzeAggregates($7 - -64 | 0, HEAP32[HEAP32[$5 + 44 >> 2] + 40 >> 2]);
                   }
                   HEAP32[$7 + 88 >> 2] = HEAP32[$7 + 88 >> 2] & -131073;
                   $3 = $3 + 1 | 0;
                   continue;
                  }
                  break;
                 }
                 $14 = HEAP32[$0 + 44 >> 2];
                 HEAP32[$6 + 20 >> 2] = $14;
                 if (HEAPU8[$13 + 87 | 0]) {
                  break label$13;
                 }
                 if ($9) {
                  $10 = 0;
                  if (($5 | 0) != 1) {
                   break label$16;
                  }
                  $3 = HEAP32[$6 + 40 >> 2];
                  if (HEAP32[$3 + 12 >> 2] < 0) {
                   break label$17;
                  }
                  $3 = HEAP32[$3 >> 2];
                  if (!$3) {
                   break label$17;
                  }
                  $10 = 0;
                  if (HEAPU8[$3 + 5 | 0] & 16) {
                   break label$16;
                  }
                  $3 = HEAP32[$3 + 20 >> 2];
                  if (!$3) {
                   break label$17;
                  }
                  $3 = sqlite3ExprDup($13, HEAP32[$3 + 8 >> 2], 0);
                  $23 = sqlite3ExprListAppend($0, sqlite3ExprListDup($13, $9, 0), $3);
                  $10 = $23 ? 1280 : 0;
                  break label$16;
                 }
                 $3 = isSimpleCount($1, $6);
                 if ($3) {
                  $10 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$3 + 60 >> 2]);
                  $14 = HEAP32[$0 + 40 >> 2];
                  HEAP32[$0 + 40 >> 2] = $14 + 1;
                  $12 = HEAP32[$3 + 20 >> 2];
                  sqlite3CodeVerifySchema($0, $10);
                  $9 = 0;
                  sqlite3TableLock($0, $10, HEAP32[$3 + 20 >> 2], 0, HEAP32[$3 >> 2]);
                  if (HEAPU8[$3 + 28 | 0] & 128) {
                   $9 = sqlite3PrimaryKeyIndex($3);
                  }
                  label$88: {
                   if (HEAP8[HEAP32[$1 + 32 >> 2] + 45 | 0] & 1) {
                    break label$88;
                   }
                   $4 = $3 + 8 | 0;
                   while (1) {
                    $4 = HEAP32[$4 >> 2];
                    if (!$4) {
                     break label$88;
                    }
                    label$90: {
                     if (HEAPU8[$4 + 55 | 0] & 4) {
                      break label$90;
                     }
                     $5 = HEAP16[$4 + 48 >> 1];
                     if (HEAP32[$4 + 36 >> 2] | ($5 | 0) >= HEAP16[$3 + 40 >> 1] | (HEAP16[$9 + 48 >> 1] <= ($5 | 0) ? $9 : 0)) {
                      break label$90;
                     }
                     $9 = $4;
                    }
                    $4 = $4 + 20 | 0;
                    continue;
                   }
                  }
                  if ($9) {
                   $12 = HEAP32[$9 + 44 >> 2];
                   $4 = sqlite3KeyInfoOfIndex($0, $9);
                  } else {
                   $4 = 0;
                  }
                  sqlite3VdbeAddOp4Int($8, 112, $14, $12, $10, 1);
                  if ($4) {
                   sqlite3VdbeChangeP4($8, -1, $4, -8);
                  }
                  sqlite3VdbeAddOp2($8, 98, $14, HEAP32[HEAP32[$6 + 40 >> 2] + 8 >> 2]);
                  sqlite3VdbeAddOp1($8, 122, $14);
                  explainSimpleCount($0, $3, $9);
                  break label$19;
                 }
                 if (!HEAP32[$6 + 36 >> 2]) {
                  break label$23;
                 }
                 $3 = 0;
                 $15 = ($5 | 0) > 0 ? $5 : 0;
                 while (1) {
                  label$96: {
                   if (($3 | 0) != ($15 | 0)) {
                    $9 = HEAP32[$6 + 40 >> 2] + Math_imul($3, 20) | 0;
                    if (HEAP8[HEAP32[$9 >> 2] + 7 | 0] & 1 | !(HEAPU8[HEAP32[$9 + 4 >> 2] + 4 | 0] & 32)) {
                     break label$96;
                    }
                    $15 = $3;
                   }
                   if (($5 | 0) != ($15 | 0)) {
                    break label$21;
                   }
                   $3 = $14 + 1 | 0;
                   HEAP32[$0 + 44 >> 2] = $3;
                   $5 = 0;
                   sqlite3VdbeAddOp2($8, 71, 0, $3);
                   $9 = 0;
                   break label$20;
                  }
                  $3 = $3 + 1 | 0;
                  continue;
                 }
                }
                HEAP32[$7 + 104 >> 2] = $18;
                break label$13;
               }
               if (($5 | 0) != 1) {
                break label$21;
               }
               $3 = 0;
               $5 = HEAP32[$6 + 40 >> 2];
               if (HEAP32[$5 + 12 >> 2] < 0) {
                break label$21;
               }
               $5 = HEAP32[HEAP32[$5 >> 2] + 20 >> 2];
               $9 = $5 ? 1280 : 0;
               break label$20;
              }
              $3 = 0;
              $5 = 0;
              $9 = 0;
             }
             resetAccumulator($0, $6);
             $4 = sqlite3WhereBegin($0, $4, $12, HEAP32[$7 + 100 >> 2], $5, 0, $10 | $9, 0);
             if (!$4) {
              break label$13;
             }
             $5 = sqlite3WhereIsDistinct($4);
             updateAccumulator($0, $3, $6, $5);
             label$98: {
              if (!$5) {
               break label$98;
              }
              $9 = HEAP32[$6 + 40 >> 2];
              if (!$9) {
               break label$98;
              }
              fixDistinctOpenEph($0, $5, HEAP32[$9 + 12 >> 2], HEAP32[$9 + 16 >> 2]);
             }
             if ($3) {
              sqlite3VdbeAddOp2($8, 71, 1, $3);
             }
             if ($10) {
              sqlite3WhereMinMaxOptEarlyOut($8, $4);
             }
             sqlite3WhereEnd($4);
             finalizeAggFunctions($0, $6);
            }
            HEAP32[$7 + 104 >> 2] = 0;
            sqlite3ExprIfFalse($0, $19, $16, 16);
            selectInnerLoop($0, $1, -1, 0, 0, $2, $16, $16);
            break label$15;
           }
           $10 = 0;
          }
          $22 = $10;
          $3 = HEAP32[$0 + 40 >> 2];
          HEAP32[$0 + 40 >> 2] = $3 + 1;
          HEAP32[$6 + 4 >> 2] = $3;
          $31 = sqlite3KeyInfoFromExprList($0, $9, 0, HEAP32[$6 + 32 >> 2]);
          $35 = sqlite3VdbeAddOp4($8, 119, HEAP32[$6 + 4 >> 2], HEAP32[$6 + 12 >> 2], 0, $31, -8);
          $25 = HEAP32[$0 + 44 >> 2];
          $17 = $25 + 3 | 0;
          HEAP32[$0 + 44 >> 2] = $17;
          $26 = sqlite3VdbeMakeLabel($0);
          $24 = HEAP32[$0 + 44 >> 2] + 1 | 0;
          HEAP32[$0 + 44 >> 2] = $24;
          $27 = sqlite3VdbeMakeLabel($0);
          $3 = HEAP32[$0 + 44 >> 2];
          $5 = HEAP32[$9 >> 2];
          $32 = $3 + $5 | 0;
          HEAP32[$0 + 44 >> 2] = $5 + $32;
          $28 = $25 + 2 | 0;
          sqlite3VdbeAddOp2($8, 71, 0, $28);
          $29 = $3 + 1 | 0;
          sqlite3VdbeAddOp3($8, 75, 0, $29, HEAP32[$9 >> 2] + $3 | 0);
          sqlite3VdbeAddOp2($8, 9, $24, $27);
          $3 = HEAPU8[$7 + 144 | 0];
          $21 = sqlite3WhereBegin($0, $4, $12, $9, $23, 0, $15 << 9 | (($3 | 0) == 2 ? 128 : 64) | $10, 0);
          if (!$21) {
           sqlite3ExprListDelete($13, $23);
           break label$13;
          }
          $30 = sqlite3WhereIsDistinct($21);
          $4 = 0;
          $12 = 0;
          $33 = sqlite3WhereIsOrdered($21);
          $34 = HEAP32[$9 >> 2];
          $10 = ($33 | 0) == ($34 | 0);
          if (!$10) {
           $4 = $3 ? HEAP32[$1 + 4 >> 2] & 1 ? 18103 : 18350 : 18103;
           explainTempTable($0, $4);
           $4 = 0;
           $3 = HEAP32[$6 + 32 >> 2];
           $20 = ($3 | 0) > 0 ? $3 : 0;
           $5 = HEAP32[$9 >> 2];
           $14 = $5;
           $3 = $5;
           while (1) {
            if (($4 | 0) != ($20 | 0)) {
             $12 = HEAP16[(HEAP32[$6 + 28 >> 2] + Math_imul($4, 20) | 0) + 18 >> 1] >= ($3 | 0);
             $3 = $12 + $3 | 0;
             $14 = $12 + $14 | 0;
             $4 = $4 + 1 | 0;
             continue;
            }
            break;
           }
           $4 = 0;
           $12 = sqlite3GetTempRange($0, $14);
           sqlite3ExprCodeExprList($0, $9, $12, 0, 0);
           while (1) {
            if (($4 | 0) < HEAP32[$6 + 32 >> 2]) {
             $3 = HEAP32[$6 + 28 >> 2] + Math_imul($4, 20) | 0;
             if (HEAP16[$3 + 18 >> 1] >= ($5 | 0)) {
              sqlite3ExprCodeGetColumnOfTable($8, HEAP32[$3 >> 2], HEAP32[$3 + 8 >> 2], HEAP16[$3 + 16 >> 1], $5 + $12 | 0);
              $5 = $5 + 1 | 0;
             }
             $4 = $4 + 1 | 0;
             continue;
            }
            break;
           }
           $4 = sqlite3GetTempReg($0);
           sqlite3VdbeAddOp3($8, 97, $12, $14, $4);
           sqlite3VdbeAddOp2($8, 139, HEAP32[$6 + 4 >> 2], $4);
           sqlite3ReleaseTempReg($0, $4);
           sqlite3ReleaseTempRange($0, $12, $14);
           sqlite3WhereEnd($21);
           $12 = HEAP32[$0 + 40 >> 2];
           HEAP32[$0 + 40 >> 2] = $12 + 1;
           HEAP32[$6 + 8 >> 2] = $12;
           $4 = sqlite3GetTempReg($0);
           sqlite3VdbeAddOp3($8, 121, $12, $4, $14);
           sqlite3VdbeAddOp2($8, 33, HEAP32[$6 + 4 >> 2], $16);
           HEAP8[$6 + 1 | 0] = 1;
          }
          label$110: {
           if (!$15 | HEAPU8[$13 + 80 | 0] & 4) {
            break label$110;
           }
           if (($33 | 0) == ($34 | 0)) {
            if (!sqlite3WhereIsSorted($21)) {
             break label$110;
            }
           }
           HEAP32[$7 + 104 >> 2] = 0;
           sqlite3VdbeChangeToNoop($8, HEAP32[$7 + 124 >> 2]);
          }
          $15 = sqlite3VdbeCurrentAddr($8);
          if (!$10) {
           sqlite3VdbeAddOp3($8, 133, HEAP32[$6 + 4 >> 2], $4, $12);
          }
          $14 = $25 + 1 | 0;
          $3 = $32 + 1 | 0;
          $4 = 0;
          while (1) {
           $5 = HEAP32[$9 >> 2];
           if (($4 | 0) < ($5 | 0)) {
            label$115: {
             if (!$10) {
              sqlite3VdbeAddOp3($8, 94, $12, $4, $3 + $4 | 0);
              break label$115;
             }
             HEAP8[$6 | 0] = 1;
             sqlite3ExprCode($0, HEAP32[(($4 << 4) + $9 | 0) + 8 >> 2], $3 + $4 | 0);
            }
            $4 = $4 + 1 | 0;
            continue;
           }
           break;
          }
          sqlite3VdbeAddOp4($8, 90, $29, $3, $5, sqlite3KeyInfoRef($31), -8);
          $4 = sqlite3VdbeCurrentAddr($8);
          $5 = $4 + 1 | 0;
          sqlite3VdbeAddOp3($8, 13, $5, 0, $5);
          sqlite3ExprCodeMove($0, $3, $29, HEAP32[$9 >> 2]);
          sqlite3VdbeAddOp2($8, 9, $17, $26);
          sqlite3VdbeAddOp2($8, 49, $28, $16);
          sqlite3VdbeAddOp2($8, 9, $24, $27);
          sqlite3VdbeJumpHere($8, $4);
          updateAccumulator($0, $14, $6, $30);
          sqlite3VdbeAddOp2($8, 71, 1, $14);
          label$117: {
           if (!$10) {
            sqlite3VdbeAddOp2($8, 36, HEAP32[$6 + 4 >> 2], $15);
            break label$117;
           }
           sqlite3WhereEnd($21);
           sqlite3VdbeChangeToNoop($8, $35);
          }
          sqlite3ExprListDelete($13, $23);
          sqlite3VdbeAddOp2($8, 9, $17, $26);
          sqlite3VdbeGoto($8, $16);
          $4 = sqlite3VdbeCurrentAddr($8);
          sqlite3VdbeAddOp2($8, 71, 1, $28);
          sqlite3VdbeAddOp1($8, 67, $17);
          sqlite3VdbeResolveLabel($8, $26);
          $3 = sqlite3VdbeCurrentAddr($8);
          sqlite3VdbeAddOp2($8, 49, $14, $3 + 2 | 0);
          sqlite3VdbeAddOp1($8, 67, $17);
          finalizeAggFunctions($0, $6);
          $3 = $3 + 1 | 0;
          sqlite3ExprIfFalse($0, $19, $3, 16);
          selectInnerLoop($0, $1, -1, $7 + 104 | 0, $7 + 144 | 0, $2, $3, $4);
          sqlite3VdbeAddOp1($8, 67, $17);
          sqlite3VdbeResolveLabel($8, $27);
          resetAccumulator($0, $6);
          sqlite3VdbeAddOp2($8, 71, 0, $14);
          sqlite3VdbeAddOp1($8, 67, $24);
          if (!$22 | !$30) {
           break label$15;
          }
          $4 = HEAP32[$6 + 40 >> 2];
          fixDistinctOpenEph($0, $30, HEAP32[$4 + 12 >> 2], HEAP32[$4 + 16 >> 2]);
         }
         sqlite3VdbeResolveLabel($8, $16);
        }
        if (HEAPU8[$7 + 145 | 0] == 3) {
         explainTempTable($0, 18350);
        }
        if (HEAP32[$7 + 104 >> 2]) {
         explainTempTable($0, HEAP32[$7 + 108 >> 2] > 0 ? 18080 : 18094);
         generateSortTail($0, $1, $7 + 104 | 0, HEAP32[$11 >> 2], $2);
        }
        sqlite3VdbeResolveLabel($8, $18);
        $4 = HEAP32[$0 + 36 >> 2] > 0;
        break label$5;
       }
       $4 = 1;
       break label$5;
      }
      $3 = 0;
     }
     $3 = $3 + 1 | 0;
     continue;
    }
   }
   sqlite3ExprListDelete($13, HEAP32[$7 + 100 >> 2]);
  }
  sqlite3VdbeExplainPop($0);
 }
 __stack_pointer = $7 + 160 | 0;
 return $4;
}

function dlmalloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$10: {
           label$11: {
            if ($0 >>> 0 <= 244) {
             $6 = HEAP32[17790];
             $5 = $0 >>> 0 < 11 ? 16 : $0 + 11 & -8;
             $1 = $5 >>> 3 | 0;
             $0 = $6 >>> $1 | 0;
             if ($0 & 3) {
              $2 = (($0 ^ -1) & 1) + $1 | 0;
              $1 = $2 << 3;
              $0 = $1 + 71200 | 0;
              $1 = HEAP32[$1 + 71208 >> 2];
              $5 = HEAP32[$1 + 8 >> 2];
              label$14: {
               if (($0 | 0) == ($5 | 0)) {
                HEAP32[17790] = __wasm_rotl_i32(-2, $2) & $6;
                break label$14;
               }
               HEAP32[$5 + 12 >> 2] = $0;
               HEAP32[$0 + 8 >> 2] = $5;
              }
              $0 = $1 + 8 | 0;
              $2 = $2 << 3;
              HEAP32[$1 + 4 >> 2] = $2 | 3;
              $1 = $1 + $2 | 0;
              HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
              break label$1;
             }
             $8 = HEAP32[17792];
             if ($8 >>> 0 >= $5 >>> 0) {
              break label$11;
             }
             if ($0) {
              $2 = $0 << $1;
              $0 = 2 << $1;
              $0 = $2 & ($0 | 0 - $0);
              $0 = ($0 & 0 - $0) - 1 | 0;
              $2 = $0;
              $0 = $0 >>> 12 & 16;
              $1 = $2 >>> $0 | 0;
              $2 = $1 >>> 5 & 8;
              $3 = $0 | $2;
              $0 = $1 >>> $2 | 0;
              $1 = $0 >>> 2 & 4;
              $2 = $3 | $1;
              $0 = $0 >>> $1 | 0;
              $1 = $0 >>> 1 & 2;
              $2 = $2 | $1;
              $0 = $0 >>> $1 | 0;
              $1 = $0 >>> 1 & 1;
              $1 = ($2 | $1) + ($0 >>> $1 | 0) | 0;
              $0 = $1 << 3;
              $2 = $0 + 71200 | 0;
              $0 = HEAP32[$0 + 71208 >> 2];
              $3 = HEAP32[$0 + 8 >> 2];
              label$17: {
               if (($2 | 0) == ($3 | 0)) {
                $6 = __wasm_rotl_i32(-2, $1) & $6;
                HEAP32[17790] = $6;
                break label$17;
               }
               HEAP32[$3 + 12 >> 2] = $2;
               HEAP32[$2 + 8 >> 2] = $3;
              }
              HEAP32[$0 + 4 >> 2] = $5 | 3;
              $3 = $0 + $5 | 0;
              $1 = $1 << 3;
              $2 = $1 - $5 | 0;
              HEAP32[$3 + 4 >> 2] = $2 | 1;
              HEAP32[$0 + $1 >> 2] = $2;
              if ($8) {
               $5 = ($8 & -8) + 71200 | 0;
               $1 = HEAP32[17795];
               $4 = 1 << ($8 >>> 3);
               label$20: {
                if (!($6 & $4)) {
                 HEAP32[17790] = $4 | $6;
                 $4 = $5;
                 break label$20;
                }
                $4 = HEAP32[$5 + 8 >> 2];
               }
               HEAP32[$5 + 8 >> 2] = $1;
               HEAP32[$4 + 12 >> 2] = $1;
               HEAP32[$1 + 12 >> 2] = $5;
               HEAP32[$1 + 8 >> 2] = $4;
              }
              $0 = $0 + 8 | 0;
              HEAP32[17795] = $3;
              HEAP32[17792] = $2;
              break label$1;
             }
             $9 = HEAP32[17791];
             if (!$9) {
              break label$11;
             }
             $0 = (0 - $9 & $9) - 1 | 0;
             $2 = $0;
             $0 = $0 >>> 12 & 16;
             $1 = $2 >>> $0 | 0;
             $2 = $1 >>> 5 & 8;
             $3 = $0 | $2;
             $0 = $1 >>> $2 | 0;
             $1 = $0 >>> 2 & 4;
             $2 = $3 | $1;
             $0 = $0 >>> $1 | 0;
             $1 = $0 >>> 1 & 2;
             $2 = $2 | $1;
             $0 = $0 >>> $1 | 0;
             $1 = $0 >>> 1 & 1;
             $3 = HEAP32[(($2 | $1) + ($0 >>> $1 | 0) << 2) + 71464 >> 2];
             $1 = (HEAP32[$3 + 4 >> 2] & -8) - $5 | 0;
             $2 = $3;
             while (1) {
              label$23: {
               $0 = HEAP32[$2 + 16 >> 2];
               if (!$0) {
                $0 = HEAP32[$2 + 20 >> 2];
                if (!$0) {
                 break label$23;
                }
               }
               $2 = (HEAP32[$0 + 4 >> 2] & -8) - $5 | 0;
               $4 = $2;
               $2 = $1 >>> 0 > $2 >>> 0;
               $1 = $2 ? $4 : $1;
               $3 = $2 ? $0 : $3;
               $2 = $0;
               continue;
              }
              break;
             }
             $10 = HEAP32[$3 + 24 >> 2];
             $4 = HEAP32[$3 + 12 >> 2];
             if (($4 | 0) != ($3 | 0)) {
              $0 = HEAP32[$3 + 8 >> 2];
              HEAP32[$0 + 12 >> 2] = $4;
              HEAP32[$4 + 8 >> 2] = $0;
              break label$2;
             }
             $2 = $3 + 20 | 0;
             $0 = HEAP32[$2 >> 2];
             if (!$0) {
              $0 = HEAP32[$3 + 16 >> 2];
              if (!$0) {
               break label$10;
              }
              $2 = $3 + 16 | 0;
             }
             while (1) {
              $7 = $2;
              $4 = $0;
              $2 = $0 + 20 | 0;
              $0 = HEAP32[$2 >> 2];
              if ($0) {
               continue;
              }
              $2 = $4 + 16 | 0;
              $0 = HEAP32[$4 + 16 >> 2];
              if ($0) {
               continue;
              }
              break;
             }
             HEAP32[$7 >> 2] = 0;
             break label$2;
            }
            $5 = -1;
            if ($0 >>> 0 > 4294967231) {
             break label$11;
            }
            $0 = $0 + 11 | 0;
            $5 = $0 & -8;
            $8 = HEAP32[17791];
            if (!$8) {
             break label$11;
            }
            $7 = 0;
            label$28: {
             if ($5 >>> 0 < 256) {
              break label$28;
             }
             $7 = 31;
             if ($5 >>> 0 > 16777215) {
              break label$28;
             }
             $0 = $0 >>> 8 | 0;
             $2 = $0;
             $0 = $0 + 1048320 >>> 16 & 8;
             $1 = $2 << $0;
             $2 = $1;
             $1 = $1 + 520192 >>> 16 & 4;
             $2 = $2 << $1;
             $3 = $2;
             $2 = $2 + 245760 >>> 16 & 2;
             $0 = ($3 << $2 >>> 15 | 0) - ($0 | $1 | $2) | 0;
             $7 = ($0 << 1 | $5 >>> $0 + 21 & 1) + 28 | 0;
            }
            $1 = 0 - $5 | 0;
            $2 = HEAP32[($7 << 2) + 71464 >> 2];
            label$29: {
             label$30: {
              label$31: {
               if (!$2) {
                $0 = 0;
                break label$31;
               }
               $0 = 0;
               $3 = $5 << (($7 | 0) == 31 ? 0 : 25 - ($7 >>> 1 | 0) | 0);
               while (1) {
                label$34: {
                 $6 = (HEAP32[$2 + 4 >> 2] & -8) - $5 | 0;
                 if ($6 >>> 0 >= $1 >>> 0) {
                  break label$34;
                 }
                 $4 = $2;
                 $1 = $6;
                 if ($1) {
                  break label$34;
                 }
                 $1 = 0;
                 $0 = $2;
                 break label$30;
                }
                $6 = HEAP32[$2 + 20 >> 2];
                $2 = HEAP32[(($3 >>> 29 & 4) + $2 | 0) + 16 >> 2];
                $0 = $6 ? ($6 | 0) == ($2 | 0) ? $0 : $6 : $0;
                $3 = $3 << 1;
                if ($2) {
                 continue;
                }
                break;
               }
              }
              if (!($0 | $4)) {
               $4 = 0;
               $0 = 2 << $7;
               $0 = ($0 | 0 - $0) & $8;
               if (!$0) {
                break label$11;
               }
               $0 = (0 - $0 & $0) - 1 | 0;
               $2 = $0;
               $0 = $0 >>> 12 & 16;
               $2 = $2 >>> $0 | 0;
               $3 = $2 >>> 5 & 8;
               $7 = $0 | $3;
               $0 = $2 >>> $3 | 0;
               $2 = $0 >>> 2 & 4;
               $3 = $7 | $2;
               $0 = $0 >>> $2 | 0;
               $2 = $0 >>> 1 & 2;
               $3 = $3 | $2;
               $0 = $0 >>> $2 | 0;
               $2 = $0 >>> 1 & 1;
               $0 = HEAP32[(($3 | $2) + ($0 >>> $2 | 0) << 2) + 71464 >> 2];
              }
              if (!$0) {
               break label$29;
              }
             }
             while (1) {
              $6 = (HEAP32[$0 + 4 >> 2] & -8) - $5 | 0;
              $3 = $6 >>> 0 < $1 >>> 0;
              $1 = $3 ? $6 : $1;
              $4 = $3 ? $0 : $4;
              $2 = HEAP32[$0 + 16 >> 2];
              if (!$2) {
               $2 = HEAP32[$0 + 20 >> 2];
              }
              $0 = $2;
              if ($0) {
               continue;
              }
              break;
             }
            }
            if (!$4 | HEAP32[17792] - $5 >>> 0 <= $1 >>> 0) {
             break label$11;
            }
            $7 = HEAP32[$4 + 24 >> 2];
            $3 = HEAP32[$4 + 12 >> 2];
            if (($4 | 0) != ($3 | 0)) {
             $0 = HEAP32[$4 + 8 >> 2];
             HEAP32[$0 + 12 >> 2] = $3;
             HEAP32[$3 + 8 >> 2] = $0;
             break label$3;
            }
            $2 = $4 + 20 | 0;
            $0 = HEAP32[$2 >> 2];
            if (!$0) {
             $0 = HEAP32[$4 + 16 >> 2];
             if (!$0) {
              break label$9;
             }
             $2 = $4 + 16 | 0;
            }
            while (1) {
             $6 = $2;
             $3 = $0;
             $2 = $0 + 20 | 0;
             $0 = HEAP32[$2 >> 2];
             if ($0) {
              continue;
             }
             $2 = $3 + 16 | 0;
             $0 = HEAP32[$3 + 16 >> 2];
             if ($0) {
              continue;
             }
             break;
            }
            HEAP32[$6 >> 2] = 0;
            break label$3;
           }
           $0 = HEAP32[17792];
           if ($5 >>> 0 <= $0 >>> 0) {
            $1 = HEAP32[17795];
            $2 = $0 - $5 | 0;
            label$42: {
             if ($2 >>> 0 >= 16) {
              HEAP32[17792] = $2;
              $3 = $1 + $5 | 0;
              HEAP32[17795] = $3;
              HEAP32[$3 + 4 >> 2] = $2 | 1;
              HEAP32[$0 + $1 >> 2] = $2;
              HEAP32[$1 + 4 >> 2] = $5 | 3;
              break label$42;
             }
             HEAP32[17795] = 0;
             HEAP32[17792] = 0;
             HEAP32[$1 + 4 >> 2] = $0 | 3;
             $0 = $0 + $1 | 0;
             HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
            }
            $0 = $1 + 8 | 0;
            break label$1;
           }
           $3 = HEAP32[17793];
           if ($5 >>> 0 < $3 >>> 0) {
            $1 = $3 - $5 | 0;
            HEAP32[17793] = $1;
            $0 = HEAP32[17796];
            $2 = $5 + $0 | 0;
            HEAP32[17796] = $2;
            HEAP32[$2 + 4 >> 2] = $1 | 1;
            HEAP32[$0 + 4 >> 2] = $5 | 3;
            $0 = $0 + 8 | 0;
            break label$1;
           }
           $0 = 0;
           $8 = $5 + 47 | 0;
           if (HEAP32[17908]) {
            $1 = HEAP32[17910];
           } else {
            HEAP32[17911] = -1;
            HEAP32[17912] = -1;
            HEAP32[17909] = 4096;
            HEAP32[17910] = 4096;
            HEAP32[17908] = $11 + 12 & -16 ^ 1431655768;
            HEAP32[17913] = 0;
            HEAP32[17901] = 0;
            $1 = 4096;
           }
           $6 = $8 + $1 | 0;
           $7 = 0 - $1 | 0;
           $4 = $6 & $7;
           if ($5 >>> 0 >= $4 >>> 0) {
            break label$1;
           }
           $1 = HEAP32[17900];
           if ($1) {
            $2 = HEAP32[17898];
            $9 = $4 + $2 | 0;
            if ($1 >>> 0 < $9 >>> 0 | $2 >>> 0 >= $9 >>> 0) {
             break label$1;
            }
           }
           if (HEAPU8[71604] & 4) {
            break label$6;
           }
           label$48: {
            label$49: {
             $1 = HEAP32[17796];
             if ($1) {
              $0 = 71608;
              while (1) {
               $2 = HEAP32[$0 >> 2];
               if ($2 >>> 0 <= $1 >>> 0 & HEAP32[$0 + 4 >> 2] + $2 >>> 0 > $1 >>> 0) {
                break label$49;
               }
               $0 = HEAP32[$0 + 8 >> 2];
               if ($0) {
                continue;
               }
               break;
              }
             }
             $3 = sbrk(0);
             if (($3 | 0) == -1) {
              break label$7;
             }
             $6 = $4;
             $0 = HEAP32[17909];
             $1 = $0 - 1 | 0;
             if ($3 & $1) {
              $6 = ($4 - $3 | 0) + ($1 + $3 & 0 - $0) | 0;
             }
             if ($6 >>> 0 > 2147483646 | $5 >>> 0 >= $6 >>> 0) {
              break label$7;
             }
             $0 = HEAP32[17900];
             if ($0) {
              $1 = HEAP32[17898];
              $2 = $6 + $1 | 0;
              if ($0 >>> 0 < $2 >>> 0 | $1 >>> 0 >= $2 >>> 0) {
               break label$7;
              }
             }
             $0 = sbrk($6);
             if (($3 | 0) != ($0 | 0)) {
              break label$48;
             }
             break label$5;
            }
            $6 = $6 - $3 & $7;
            if ($6 >>> 0 > 2147483646) {
             break label$7;
            }
            $3 = sbrk($6);
            if (($3 | 0) == (HEAP32[$0 >> 2] + HEAP32[$0 + 4 >> 2] | 0)) {
             break label$8;
            }
            $0 = $3;
           }
           if (!(($0 | 0) == -1 | $5 + 48 >>> 0 <= $6 >>> 0)) {
            $1 = HEAP32[17910];
            $1 = $1 + ($8 - $6 | 0) & 0 - $1;
            if ($1 >>> 0 > 2147483646) {
             $3 = $0;
             break label$5;
            }
            if ((sbrk($1) | 0) != -1) {
             $6 = $1 + $6 | 0;
             $3 = $0;
             break label$5;
            }
            sbrk(0 - $6 | 0);
            break label$7;
           }
           $3 = $0;
           if (($0 | 0) != -1) {
            break label$5;
           }
           break label$7;
          }
          $4 = 0;
          break label$2;
         }
         $3 = 0;
         break label$3;
        }
        if (($3 | 0) != -1) {
         break label$5;
        }
       }
       HEAP32[17901] = HEAP32[17901] | 4;
      }
      if ($4 >>> 0 > 2147483646) {
       break label$4;
      }
      $1 = $4 + 7 & -8;
      $3 = HEAP32[17592];
      $0 = $1 + $3 | 0;
      label$58: {
       label$59: {
        if (!$1 | $0 >>> 0 > $3 >>> 0) {
         if (emscripten_get_heap_size() >>> 0 >= $0 >>> 0) {
          break label$59;
         }
         if (emscripten_resize_heap($0 | 0) | 0) {
          break label$59;
         }
         $0 = HEAP32[17592];
        } else {
         $0 = $3;
        }
        HEAP32[17757] = 48;
        $3 = -1;
        break label$58;
       }
       HEAP32[17592] = $0;
      }
      if (emscripten_get_heap_size() >>> 0 < $0 >>> 0) {
       if (!(emscripten_resize_heap($0 | 0) | 0)) {
        break label$4;
       }
      }
      HEAP32[17592] = $0;
      if (($3 | 0) == -1 | ($0 | 0) == -1 | $0 >>> 0 <= $3 >>> 0) {
       break label$4;
      }
      $6 = $0 - $3 | 0;
      if ($6 >>> 0 <= $5 + 40 >>> 0) {
       break label$4;
      }
     }
     $0 = HEAP32[17898] + $6 | 0;
     HEAP32[17898] = $0;
     if (HEAPU32[17899] < $0 >>> 0) {
      HEAP32[17899] = $0;
     }
     label$64: {
      label$65: {
       label$66: {
        $1 = HEAP32[17796];
        if ($1) {
         $0 = 71608;
         while (1) {
          $2 = HEAP32[$0 >> 2];
          $4 = HEAP32[$0 + 4 >> 2];
          if (($2 + $4 | 0) == ($3 | 0)) {
           break label$66;
          }
          $0 = HEAP32[$0 + 8 >> 2];
          if ($0) {
           continue;
          }
          break;
         }
         break label$65;
        }
        $0 = HEAP32[17794];
        if (!($0 >>> 0 <= $3 >>> 0 ? $0 : 0)) {
         HEAP32[17794] = $3;
        }
        $0 = 0;
        HEAP32[17903] = $6;
        HEAP32[17902] = $3;
        HEAP32[17798] = -1;
        HEAP32[17799] = HEAP32[17908];
        HEAP32[17905] = 0;
        while (1) {
         $1 = $0 << 3;
         $2 = $1 + 71200 | 0;
         HEAP32[$1 + 71208 >> 2] = $2;
         HEAP32[$1 + 71212 >> 2] = $2;
         $0 = $0 + 1 | 0;
         if (($0 | 0) != 32) {
          continue;
         }
         break;
        }
        $0 = $6 - 40 | 0;
        $1 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
        $2 = $0 - $1 | 0;
        HEAP32[17793] = $2;
        $1 = $1 + $3 | 0;
        HEAP32[17796] = $1;
        HEAP32[$1 + 4 >> 2] = $2 | 1;
        HEAP32[($0 + $3 | 0) + 4 >> 2] = 40;
        HEAP32[17797] = HEAP32[17912];
        break label$64;
       }
       if (HEAPU8[$0 + 12 | 0] & 8 | $1 >>> 0 < $2 >>> 0 | $1 >>> 0 >= $3 >>> 0) {
        break label$65;
       }
       HEAP32[$0 + 4 >> 2] = $4 + $6;
       $0 = $1 + 8 & 7 ? -8 - $1 & 7 : 0;
       $2 = $1 + $0 | 0;
       HEAP32[17796] = $2;
       $3 = HEAP32[17793] + $6 | 0;
       $0 = $3 - $0 | 0;
       HEAP32[17793] = $0;
       HEAP32[$2 + 4 >> 2] = $0 | 1;
       HEAP32[($1 + $3 | 0) + 4 >> 2] = 40;
       HEAP32[17797] = HEAP32[17912];
       break label$64;
      }
      $7 = HEAP32[17794];
      if ($7 >>> 0 > $3 >>> 0) {
       HEAP32[17794] = $3;
      }
      $4 = $3 + $6 | 0;
      $2 = 71608;
      label$72: {
       while (1) {
        if (HEAP32[$2 >> 2] != ($4 | 0)) {
         $0 = 71608;
         $2 = HEAP32[$2 + 8 >> 2];
         if ($2) {
          continue;
         }
         break label$72;
        }
        break;
       }
       $0 = 71608;
       if (HEAPU8[$2 + 12 | 0] & 8) {
        break label$72;
       }
       HEAP32[$2 >> 2] = $3;
       HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + $6;
       $6 = ($3 + 8 & 7 ? -8 - $3 & 7 : 0) + $3 | 0;
       HEAP32[$6 + 4 >> 2] = $5 | 3;
       $4 = ($4 + 8 & 7 ? -8 - $4 & 7 : 0) + $4 | 0;
       $5 = $5 + $6 | 0;
       $0 = $4 - $5 | 0;
       label$75: {
        if (($1 | 0) == ($4 | 0)) {
         HEAP32[17796] = $5;
         $0 = HEAP32[17793] + $0 | 0;
         HEAP32[17793] = $0;
         HEAP32[$5 + 4 >> 2] = $0 | 1;
         break label$75;
        }
        if (HEAP32[17795] == ($4 | 0)) {
         HEAP32[17795] = $5;
         $0 = HEAP32[17792] + $0 | 0;
         HEAP32[17792] = $0;
         HEAP32[$5 + 4 >> 2] = $0 | 1;
         HEAP32[$0 + $5 >> 2] = $0;
         break label$75;
        }
        $1 = HEAP32[$4 + 4 >> 2];
        if (($1 & 3) == 1) {
         $8 = $1 & -8;
         label$79: {
          if ($1 >>> 0 <= 255) {
           $2 = HEAP32[$4 + 8 >> 2];
           $7 = $1 >>> 3 | 0;
           $3 = ($7 << 3) + 71200 | 0;
           $1 = HEAP32[$4 + 12 >> 2];
           if (($2 | 0) == ($1 | 0)) {
            HEAP32[17790] = HEAP32[17790] & __wasm_rotl_i32(-2, $7);
            break label$79;
           }
           HEAP32[$2 + 12 >> 2] = $1;
           HEAP32[$1 + 8 >> 2] = $2;
           break label$79;
          }
          $9 = HEAP32[$4 + 24 >> 2];
          $3 = HEAP32[$4 + 12 >> 2];
          label$82: {
           if (($4 | 0) != ($3 | 0)) {
            $1 = HEAP32[$4 + 8 >> 2];
            HEAP32[$1 + 12 >> 2] = $3;
            HEAP32[$3 + 8 >> 2] = $1;
            break label$82;
           }
           label$84: {
            $1 = $4 + 20 | 0;
            $2 = HEAP32[$1 >> 2];
            if ($2) {
             break label$84;
            }
            $1 = $4 + 16 | 0;
            $2 = HEAP32[$1 >> 2];
            if ($2) {
             break label$84;
            }
            $3 = 0;
            break label$82;
           }
           while (1) {
            $7 = $1;
            $3 = $2;
            $1 = $3 + 20 | 0;
            $2 = HEAP32[$1 >> 2];
            if ($2) {
             continue;
            }
            $1 = $3 + 16 | 0;
            $2 = HEAP32[$3 + 16 >> 2];
            if ($2) {
             continue;
            }
            break;
           }
           HEAP32[$7 >> 2] = 0;
          }
          if (!$9) {
           break label$79;
          }
          $2 = HEAP32[$4 + 28 >> 2];
          $1 = ($2 << 2) + 71464 | 0;
          label$86: {
           if (HEAP32[$1 >> 2] == ($4 | 0)) {
            HEAP32[$1 >> 2] = $3;
            if ($3) {
             break label$86;
            }
            HEAP32[17791] = HEAP32[17791] & __wasm_rotl_i32(-2, $2);
            break label$79;
           }
           HEAP32[(HEAP32[$9 + 16 >> 2] == ($4 | 0) ? 16 : 20) + $9 >> 2] = $3;
           if (!$3) {
            break label$79;
           }
          }
          HEAP32[$3 + 24 >> 2] = $9;
          $1 = HEAP32[$4 + 16 >> 2];
          if ($1) {
           HEAP32[$3 + 16 >> 2] = $1;
           HEAP32[$1 + 24 >> 2] = $3;
          }
          $1 = HEAP32[$4 + 20 >> 2];
          if (!$1) {
           break label$79;
          }
          HEAP32[$3 + 20 >> 2] = $1;
          HEAP32[$1 + 24 >> 2] = $3;
         }
         $4 = $4 + $8 | 0;
         $1 = HEAP32[$4 + 4 >> 2];
         $0 = $0 + $8 | 0;
        }
        HEAP32[$4 + 4 >> 2] = $1 & -2;
        HEAP32[$5 + 4 >> 2] = $0 | 1;
        HEAP32[$0 + $5 >> 2] = $0;
        if ($0 >>> 0 <= 255) {
         $1 = ($0 & -8) + 71200 | 0;
         $0 = 1 << ($0 >>> 3);
         $2 = HEAP32[17790];
         label$90: {
          if (!($0 & $2)) {
           HEAP32[17790] = $0 | $2;
           $0 = $1;
           break label$90;
          }
          $0 = HEAP32[$1 + 8 >> 2];
         }
         HEAP32[$1 + 8 >> 2] = $5;
         HEAP32[$0 + 12 >> 2] = $5;
         HEAP32[$5 + 12 >> 2] = $1;
         HEAP32[$5 + 8 >> 2] = $0;
         break label$75;
        }
        $1 = 31;
        if ($0 >>> 0 <= 16777215) {
         $1 = $0 >>> 8 | 0;
         $2 = $1;
         $1 = $1 + 1048320 >>> 16 & 8;
         $2 = $2 << $1;
         $3 = $2;
         $2 = $2 + 520192 >>> 16 & 4;
         $3 = $3 << $2;
         $4 = $3;
         $3 = $3 + 245760 >>> 16 & 2;
         $1 = ($4 << $3 >>> 15 | 0) - ($1 | $2 | $3) | 0;
         $1 = ($1 << 1 | $0 >>> $1 + 21 & 1) + 28 | 0;
        }
        HEAP32[$5 + 28 >> 2] = $1;
        HEAP32[$5 + 16 >> 2] = 0;
        HEAP32[$5 + 20 >> 2] = 0;
        $2 = ($1 << 2) + 71464 | 0;
        label$93: {
         $3 = HEAP32[17791];
         $4 = 1 << $1;
         label$94: {
          if (!($3 & $4)) {
           HEAP32[17791] = $3 | $4;
           HEAP32[$2 >> 2] = $5;
           break label$94;
          }
          $1 = $0 << (($1 | 0) == 31 ? 0 : 25 - ($1 >>> 1 | 0) | 0);
          $3 = HEAP32[$2 >> 2];
          while (1) {
           $2 = $3;
           if ((HEAP32[$3 + 4 >> 2] & -8) == ($0 | 0)) {
            break label$93;
           }
           $3 = $1 >>> 29 | 0;
           $1 = $1 << 1;
           $7 = ($3 & 4) + $2 | 0;
           $4 = $7 + 16 | 0;
           $3 = HEAP32[$4 >> 2];
           if ($3) {
            continue;
           }
           break;
          }
          HEAP32[$7 + 16 >> 2] = $5;
         }
         HEAP32[$5 + 24 >> 2] = $2;
         HEAP32[$5 + 12 >> 2] = $5;
         HEAP32[$5 + 8 >> 2] = $5;
         break label$75;
        }
        $0 = HEAP32[$2 + 8 >> 2];
        HEAP32[$0 + 12 >> 2] = $5;
        HEAP32[$2 + 8 >> 2] = $5;
        HEAP32[$5 + 24 >> 2] = 0;
        HEAP32[$5 + 12 >> 2] = $2;
        HEAP32[$5 + 8 >> 2] = $0;
       }
       $0 = $6 + 8 | 0;
       break label$1;
      }
      while (1) {
       label$98: {
        $2 = HEAP32[$0 >> 2];
        if ($2 >>> 0 <= $1 >>> 0) {
         $2 = HEAP32[$0 + 4 >> 2] + $2 | 0;
         if ($2 >>> 0 > $1 >>> 0) {
          break label$98;
         }
        }
        $0 = HEAP32[$0 + 8 >> 2];
        continue;
       }
       break;
      }
      $0 = $6 - 40 | 0;
      $4 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
      $7 = $0 - $4 | 0;
      HEAP32[17793] = $7;
      $4 = $3 + $4 | 0;
      HEAP32[17796] = $4;
      HEAP32[$4 + 4 >> 2] = $7 | 1;
      HEAP32[($0 + $3 | 0) + 4 >> 2] = 40;
      HEAP32[17797] = HEAP32[17912];
      $0 = (($2 - 39 & 7 ? 39 - $2 & 7 : 0) + $2 | 0) - 47 | 0;
      $4 = $1 + 16 >>> 0 > $0 >>> 0 ? $1 : $0;
      HEAP32[$4 + 4 >> 2] = 27;
      $0 = HEAP32[17905];
      $7 = HEAP32[17904];
      HEAP32[$4 + 16 >> 2] = $7;
      HEAP32[$4 + 20 >> 2] = $0;
      $7 = HEAP32[17903];
      $0 = HEAP32[17902];
      HEAP32[$4 + 8 >> 2] = $0;
      HEAP32[$4 + 12 >> 2] = $7;
      HEAP32[17904] = $4 + 8;
      HEAP32[17903] = $6;
      HEAP32[17902] = $3;
      HEAP32[17905] = 0;
      $0 = $4 + 24 | 0;
      while (1) {
       HEAP32[$0 + 4 >> 2] = 7;
       $3 = $0 + 8 | 0;
       $0 = $0 + 4 | 0;
       if ($2 >>> 0 > $3 >>> 0) {
        continue;
       }
       break;
      }
      if (($1 | 0) == ($4 | 0)) {
       break label$64;
      }
      HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] & -2;
      $3 = $4 - $1 | 0;
      HEAP32[$1 + 4 >> 2] = $3 | 1;
      HEAP32[$4 >> 2] = $3;
      if ($3 >>> 0 <= 255) {
       $0 = ($3 & -8) + 71200 | 0;
       $2 = HEAP32[17790];
       $3 = 1 << ($3 >>> 3);
       label$102: {
        if (!($2 & $3)) {
         HEAP32[17790] = $2 | $3;
         $2 = $0;
         break label$102;
        }
        $2 = HEAP32[$0 + 8 >> 2];
       }
       HEAP32[$0 + 8 >> 2] = $1;
       HEAP32[$2 + 12 >> 2] = $1;
       HEAP32[$1 + 12 >> 2] = $0;
       HEAP32[$1 + 8 >> 2] = $2;
       break label$64;
      }
      $0 = 31;
      if ($3 >>> 0 <= 16777215) {
       $0 = $3 >>> 8 | 0;
       $2 = $0;
       $0 = $0 + 1048320 >>> 16 & 8;
       $2 = $2 << $0;
       $4 = $2;
       $2 = $2 + 520192 >>> 16 & 4;
       $4 = $4 << $2;
       $7 = $4;
       $4 = $4 + 245760 >>> 16 & 2;
       $0 = ($7 << $4 >>> 15 | 0) - ($0 | $2 | $4) | 0;
       $0 = ($0 << 1 | $3 >>> $0 + 21 & 1) + 28 | 0;
      }
      HEAP32[$1 + 28 >> 2] = $0;
      HEAP32[$1 + 16 >> 2] = 0;
      HEAP32[$1 + 20 >> 2] = 0;
      $2 = ($0 << 2) + 71464 | 0;
      label$105: {
       $4 = HEAP32[17791];
       $6 = 1 << $0;
       label$106: {
        if (!($4 & $6)) {
         HEAP32[17791] = $4 | $6;
         HEAP32[$2 >> 2] = $1;
         break label$106;
        }
        $0 = $3 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
        $4 = HEAP32[$2 >> 2];
        while (1) {
         $2 = $4;
         if ((HEAP32[$2 + 4 >> 2] & -8) == ($3 | 0)) {
          break label$105;
         }
         $4 = $0 >>> 29 | 0;
         $0 = $0 << 1;
         $7 = ($4 & 4) + $2 | 0;
         $6 = $7 + 16 | 0;
         $4 = HEAP32[$6 >> 2];
         if ($4) {
          continue;
         }
         break;
        }
        HEAP32[$7 + 16 >> 2] = $1;
       }
       HEAP32[$1 + 24 >> 2] = $2;
       HEAP32[$1 + 12 >> 2] = $1;
       HEAP32[$1 + 8 >> 2] = $1;
       break label$64;
      }
      $0 = HEAP32[$2 + 8 >> 2];
      HEAP32[$0 + 12 >> 2] = $1;
      HEAP32[$2 + 8 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = 0;
      HEAP32[$1 + 12 >> 2] = $2;
      HEAP32[$1 + 8 >> 2] = $0;
     }
     $0 = HEAP32[17793];
     if ($5 >>> 0 >= $0 >>> 0) {
      break label$4;
     }
     $1 = $0 - $5 | 0;
     HEAP32[17793] = $1;
     $0 = HEAP32[17796];
     $2 = $5 + $0 | 0;
     HEAP32[17796] = $2;
     HEAP32[$2 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + 4 >> 2] = $5 | 3;
     $0 = $0 + 8 | 0;
     break label$1;
    }
    $0 = 0;
    HEAP32[17757] = 48;
    break label$1;
   }
   label$109: {
    if (!$7) {
     break label$109;
    }
    $2 = HEAP32[$4 + 28 >> 2];
    $0 = ($2 << 2) + 71464 | 0;
    label$110: {
     if (HEAP32[$0 >> 2] == ($4 | 0)) {
      HEAP32[$0 >> 2] = $3;
      if ($3) {
       break label$110;
      }
      $8 = __wasm_rotl_i32(-2, $2) & $8;
      HEAP32[17791] = $8;
      break label$109;
     }
     HEAP32[(HEAP32[$7 + 16 >> 2] == ($4 | 0) ? 16 : 20) + $7 >> 2] = $3;
     if (!$3) {
      break label$109;
     }
    }
    HEAP32[$3 + 24 >> 2] = $7;
    $0 = HEAP32[$4 + 16 >> 2];
    if ($0) {
     HEAP32[$3 + 16 >> 2] = $0;
     HEAP32[$0 + 24 >> 2] = $3;
    }
    $0 = HEAP32[$4 + 20 >> 2];
    if (!$0) {
     break label$109;
    }
    HEAP32[$3 + 20 >> 2] = $0;
    HEAP32[$0 + 24 >> 2] = $3;
   }
   label$113: {
    if ($1 >>> 0 <= 15) {
     $0 = $1 + $5 | 0;
     HEAP32[$4 + 4 >> 2] = $0 | 3;
     $0 = $0 + $4 | 0;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
     break label$113;
    }
    HEAP32[$4 + 4 >> 2] = $5 | 3;
    $3 = $4 + $5 | 0;
    HEAP32[$3 + 4 >> 2] = $1 | 1;
    HEAP32[$1 + $3 >> 2] = $1;
    if ($1 >>> 0 <= 255) {
     $0 = ($1 & -8) + 71200 | 0;
     $1 = 1 << ($1 >>> 3);
     $2 = HEAP32[17790];
     label$116: {
      if (!($1 & $2)) {
       HEAP32[17790] = $1 | $2;
       $1 = $0;
       break label$116;
      }
      $1 = HEAP32[$0 + 8 >> 2];
     }
     HEAP32[$0 + 8 >> 2] = $3;
     HEAP32[$1 + 12 >> 2] = $3;
     HEAP32[$3 + 12 >> 2] = $0;
     HEAP32[$3 + 8 >> 2] = $1;
     break label$113;
    }
    $0 = 31;
    if ($1 >>> 0 <= 16777215) {
     $0 = $1 >>> 8 | 0;
     $2 = $0;
     $0 = $0 + 1048320 >>> 16 & 8;
     $2 = $2 << $0;
     $5 = $2;
     $2 = $2 + 520192 >>> 16 & 4;
     $5 = $5 << $2;
     $7 = $5;
     $5 = $5 + 245760 >>> 16 & 2;
     $0 = ($7 << $5 >>> 15 | 0) - ($0 | $2 | $5) | 0;
     $0 = ($0 << 1 | $1 >>> $0 + 21 & 1) + 28 | 0;
    }
    HEAP32[$3 + 28 >> 2] = $0;
    HEAP32[$3 + 16 >> 2] = 0;
    HEAP32[$3 + 20 >> 2] = 0;
    $2 = ($0 << 2) + 71464 | 0;
    label$119: {
     $5 = 1 << $0;
     label$120: {
      if (!($8 & $5)) {
       HEAP32[17791] = $5 | $8;
       HEAP32[$2 >> 2] = $3;
       break label$120;
      }
      $0 = $1 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
      $5 = HEAP32[$2 >> 2];
      while (1) {
       $2 = $5;
       if ((HEAP32[$2 + 4 >> 2] & -8) == ($1 | 0)) {
        break label$119;
       }
       $5 = $0 >>> 29 | 0;
       $0 = $0 << 1;
       $7 = ($5 & 4) + $2 | 0;
       $6 = $7 + 16 | 0;
       $5 = HEAP32[$6 >> 2];
       if ($5) {
        continue;
       }
       break;
      }
      HEAP32[$7 + 16 >> 2] = $3;
     }
     HEAP32[$3 + 24 >> 2] = $2;
     HEAP32[$3 + 12 >> 2] = $3;
     HEAP32[$3 + 8 >> 2] = $3;
     break label$113;
    }
    $0 = HEAP32[$2 + 8 >> 2];
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$2 + 8 >> 2] = $3;
    HEAP32[$3 + 24 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = $2;
    HEAP32[$3 + 8 >> 2] = $0;
   }
   $0 = $4 + 8 | 0;
   break label$1;
  }
  label$123: {
   if (!$10) {
    break label$123;
   }
   $2 = HEAP32[$3 + 28 >> 2];
   $0 = ($2 << 2) + 71464 | 0;
   label$124: {
    if (HEAP32[$0 >> 2] == ($3 | 0)) {
     HEAP32[$0 >> 2] = $4;
     if ($4) {
      break label$124;
     }
     HEAP32[17791] = __wasm_rotl_i32(-2, $2) & $9;
     break label$123;
    }
    HEAP32[(HEAP32[$10 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $10 >> 2] = $4;
    if (!$4) {
     break label$123;
    }
   }
   HEAP32[$4 + 24 >> 2] = $10;
   $0 = HEAP32[$3 + 16 >> 2];
   if ($0) {
    HEAP32[$4 + 16 >> 2] = $0;
    HEAP32[$0 + 24 >> 2] = $4;
   }
   $0 = HEAP32[$3 + 20 >> 2];
   if (!$0) {
    break label$123;
   }
   HEAP32[$4 + 20 >> 2] = $0;
   HEAP32[$0 + 24 >> 2] = $4;
  }
  label$127: {
   if ($1 >>> 0 <= 15) {
    $0 = $1 + $5 | 0;
    HEAP32[$3 + 4 >> 2] = $0 | 3;
    $0 = $0 + $3 | 0;
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
    break label$127;
   }
   HEAP32[$3 + 4 >> 2] = $5 | 3;
   $2 = $3 + $5 | 0;
   HEAP32[$2 + 4 >> 2] = $1 | 1;
   HEAP32[$1 + $2 >> 2] = $1;
   if ($8) {
    $5 = ($8 & -8) + 71200 | 0;
    $0 = HEAP32[17795];
    $4 = 1 << ($8 >>> 3);
    label$130: {
     if (!($6 & $4)) {
      HEAP32[17790] = $4 | $6;
      $4 = $5;
      break label$130;
     }
     $4 = HEAP32[$5 + 8 >> 2];
    }
    HEAP32[$5 + 8 >> 2] = $0;
    HEAP32[$4 + 12 >> 2] = $0;
    HEAP32[$0 + 12 >> 2] = $5;
    HEAP32[$0 + 8 >> 2] = $4;
   }
   HEAP32[17795] = $2;
   HEAP32[17792] = $1;
  }
  $0 = $3 + 8 | 0;
 }
 __stack_pointer = $11 + 16 | 0;
 return $0 | 0;
}

function sqlite3ExprCodeTarget($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $6 = __stack_pointer - 128 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 + 8 >> 2];
 HEAP32[$6 + 124 >> 2] = 0;
 HEAP32[$6 + 120 >> 2] = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         while (1) {
          label$10: {
           label$11: {
            label$12: {
             label$13: {
              label$14: {
               label$15: {
                label$16: {
                 label$17: {
                  label$18: {
                   label$19: {
                    label$20: {
                     label$21: {
                      label$22: {
                       label$23: {
                        label$24: {
                         label$25: {
                          label$26: {
                           label$27: {
                            label$28: {
                             label$29: {
                              label$30: {
                               label$31: {
                                label$32: {
                                 label$33: {
                                  label$34: {
                                   label$35: {
                                    label$36: {
                                     label$37: {
                                      if (!$1) {
                                       break label$37;
                                      }
                                      label$38: {
                                       $3 = HEAPU8[$1 | 0];
                                       switch ($3 - 102 | 0) {
                                       case 72:
                                       case 79:
                                        break label$11;

                                       case 11:
                                        break label$12;

                                       case 76:
                                        break label$15;

                                       case 36:
                                        break label$16;

                                       case 70:
                                        break label$17;

                                       case 66:
                                        break label$18;

                                       case 73:
                                        break label$20;

                                       case 12:
                                        break label$21;

                                       case 71:
                                        break label$22;

                                       case 0:
                                       case 1:
                                       case 2:
                                       case 3:
                                       case 4:
                                       case 5:
                                       case 6:
                                       case 7:
                                       case 8:
                                       case 9:
                                        break label$23;

                                       case 69:
                                        break label$26;

                                       case 74:
                                        break label$28;

                                       case 54:
                                        break label$29;

                                       case 52:
                                        break label$30;

                                       case 15:
                                        break label$31;

                                       case 51:
                                        break label$32;

                                       case 68:
                                        break label$33;

                                       case 53:
                                        break label$34;

                                       case 65:
                                        break label$35;

                                       case 67:
                                        break label$36;

                                       case 10:
                                       case 13:
                                       case 14:
                                       case 16:
                                       case 17:
                                       case 18:
                                       case 19:
                                       case 20:
                                       case 21:
                                       case 22:
                                       case 23:
                                       case 24:
                                       case 25:
                                       case 26:
                                       case 27:
                                       case 28:
                                       case 29:
                                       case 30:
                                       case 31:
                                       case 32:
                                       case 33:
                                       case 34:
                                       case 35:
                                       case 37:
                                       case 38:
                                       case 39:
                                       case 40:
                                       case 41:
                                       case 42:
                                       case 43:
                                       case 44:
                                       case 45:
                                       case 46:
                                       case 47:
                                       case 48:
                                       case 49:
                                       case 50:
                                       case 56:
                                       case 57:
                                       case 58:
                                       case 59:
                                       case 60:
                                       case 61:
                                       case 62:
                                       case 63:
                                       case 64:
                                       case 78:
                                        break label$37;

                                       case 55:
                                        break label$6;

                                       case 77:
                                        break label$7;

                                       case 75:
                                        break label$8;

                                       default:
                                        break label$38;
                                       }
                                      }
                                      label$39: {
                                       switch ($3 - 19 | 0) {
                                       case 29:
                                        break label$13;

                                       case 30:
                                        break label$14;

                                       case 1:
                                        break label$16;

                                       case 31:
                                       case 32:
                                        break label$19;

                                       case 0:
                                        break label$21;

                                       case 24:
                                       case 25:
                                        break label$23;

                                       case 33:
                                       case 34:
                                       case 35:
                                       case 36:
                                       case 37:
                                       case 38:
                                        break label$25;

                                       case 26:
                                        break label$26;

                                       case 17:
                                        break label$27;

                                       case 2:
                                       case 3:
                                       case 4:
                                       case 5:
                                       case 6:
                                       case 7:
                                       case 8:
                                       case 9:
                                       case 10:
                                       case 11:
                                       case 12:
                                       case 13:
                                       case 14:
                                       case 15:
                                       case 16:
                                       case 18:
                                       case 19:
                                       case 20:
                                       case 21:
                                       case 22:
                                       case 23:
                                       case 27:
                                       case 28:
                                        break label$37;

                                       default:
                                        break label$39;
                                       }
                                      }
                                      if (($3 | 0) == 71) {
                                       break label$5;
                                      }
                                      if (($3 | 0) == 77) {
                                       break label$10;
                                      }
                                     }
                                     sqlite3VdbeAddOp2($5, 75, 0, $2);
                                     break label$2;
                                    }
                                    $3 = HEAP32[$1 + 40 >> 2];
                                    $7 = HEAP32[$3 + 28 >> 2];
                                    $8 = HEAP16[$1 + 34 >> 1];
                                    $4 = $7 + Math_imul($8, 20) | 0;
                                    if (!HEAPU8[$3 | 0]) {
                                     $4 = HEAP32[$4 + 12 >> 2];
                                     break label$1;
                                    }
                                    if (!HEAPU8[$3 + 1 | 0]) {
                                     break label$35;
                                    }
                                    $0 = HEAP32[$4 >> 2];
                                    $1 = Math_imul($8, 20) + $7 | 0;
                                    sqlite3VdbeAddOp3($5, 94, HEAP32[$3 + 8 >> 2], HEAP16[$1 + 18 >> 1], $2);
                                    $1 = HEAP16[$1 + 16 >> 1];
                                    if (($1 | 0) < 0 | HEAPU8[(HEAP32[$0 + 4 >> 2] + Math_imul($1 & 65535, 12) | 0) + 5 | 0] != 69) {
                                     break label$2;
                                    }
                                    sqlite3VdbeAddOp1($5, 87, $2);
                                    break label$2;
                                   }
                                   if (HEAPU8[$1 + 4 | 0] & 32) {
                                    $4 = sqlite3ExprCodeTarget($0, HEAP32[$1 + 12 >> 2], $2);
                                    $0 = HEAP32[$1 + 44 >> 2];
                                    label$42: {
                                     if ($0) {
                                      $1 = sqlite3TableColumnAffinity($0, HEAP16[$1 + 32 >> 1]);
                                      break label$42;
                                     }
                                     $1 = HEAPU8[$1 + 1 | 0];
                                    }
                                    if ($1 << 24 >> 24 < 66) {
                                     break label$1;
                                    }
                                    sqlite3VdbeAddOp4($5, 96, $4, 1, 0, (($1 & 255) << 1) + 48492 | 0, -1);
                                    break label$1;
                                   }
                                   $3 = HEAP32[$1 + 28 >> 2];
                                   if (($3 | 0) < 0) {
                                    $3 = HEAP32[$0 + 52 >> 2];
                                    if (($3 | 0) < 0) {
                                     $7 = HEAPU16[$1 + 32 >> 1];
                                     $4 = $7 << 16 >> 16;
                                     if (($4 | 0) < 0) {
                                      $4 = $3 ^ -1;
                                      break label$1;
                                     }
                                     $8 = HEAP32[$1 + 44 >> 2];
                                     $4 = sqlite3TableColumnToStorage($8, $4) - $3 | 0;
                                     $3 = HEAP32[$8 + 4 >> 2] + Math_imul($7, 12) | 0;
                                     $1 = HEAPU16[$3 + 10 >> 1];
                                     if ($1 & 96) {
                                      if ($1 & 256) {
                                       HEAP32[$6 >> 2] = HEAP32[$3 >> 2];
                                       sqlite3ErrorMsg($0, 28522, $6);
                                       $4 = 0;
                                       break label$1;
                                      }
                                      $2 = $3 + 10 | 0;
                                      $5 = $1 | 256;
                                      HEAP16[$2 >> 1] = $5;
                                      if ($1 & 128) {
                                       sqlite3ExprCodeGeneratedColumn($0, $8, $3, $4);
                                       $5 = HEAPU16[$3 + 10 >> 1];
                                      }
                                      HEAP16[$3 + 10 >> 1] = $5 & 65151;
                                      break label$1;
                                     }
                                     if (HEAPU8[$3 + 5 | 0] != 69) {
                                      break label$1;
                                     }
                                     sqlite3VdbeAddOp2($5, 81, $4, $2);
                                     sqlite3VdbeAddOp1($5, 87, $2);
                                     break label$2;
                                    }
                                    $3 = $3 - 1 | 0;
                                   }
                                   $4 = sqlite3ExprCodeGetColumn($0, HEAP32[$1 + 44 >> 2], HEAP16[$1 + 32 >> 1], $3, $2, HEAPU8[$1 + 2 | 0]);
                                   if (HEAP32[$1 + 44 >> 2] | HEAPU8[$1 + 1 | 0] != 69) {
                                    break label$1;
                                   }
                                   sqlite3VdbeAddOp1($5, 87, $4);
                                   break label$1;
                                  }
                                  codeInteger($0, $1, 0, $2);
                                  break label$2;
                                 }
                                 sqlite3VdbeAddOp2($5, 71, sqlite3ExprTruthValue($1), $2);
                                 break label$2;
                                }
                                codeReal($5, HEAP32[$1 + 8 >> 2], 0, $2);
                                break label$2;
                               }
                               sqlite3VdbeLoadString($5, $2, HEAP32[$1 + 8 >> 2]);
                               break label$2;
                              }
                              $1 = HEAP32[$1 + 8 >> 2] + 2 | 0;
                              $0 = sqlite3Strlen30($1) - 1 | 0;
                              sqlite3VdbeAddOp4($5, 77, ($0 | 0) / 2 | 0, $2, 0, sqlite3HexToBlob(sqlite3VdbeDb($5), $1, $0), -6);
                              break label$2;
                             }
                             sqlite3VdbeAddOp2($5, 78, HEAP16[$1 + 32 >> 1], $2);
                             if (!HEAPU8[HEAP32[$1 + 8 >> 2] + 1 | 0]) {
                              break label$2;
                             }
                             $0 = HEAP32[$0 + 224 >> 2];
                             $1 = sqlite3VListNumToName($0, HEAP16[$1 + 32 >> 1]);
                             HEAP32[$0 >> 2] = 0;
                             sqlite3VdbeAppendP4($5, $1, -1);
                             break label$2;
                            }
                            $4 = HEAP32[$1 + 28 >> 2];
                            break label$1;
                           }
                           $0 = sqlite3ExprCodeTarget($0, HEAP32[$1 + 12 >> 2], $2);
                           if (($2 | 0) != ($0 | 0)) {
                            sqlite3VdbeAddOp2($5, 81, $0, $2);
                           }
                           sqlite3VdbeAddOp2($5, 88, $2, sqlite3AffinityType(HEAP32[$1 + 8 >> 2], 0));
                           break label$2;
                          }
                          $3 = ($3 | 0) == 45 ? 53 : 52;
                          $8 = 1;
                          $4 = 128;
                          break label$24;
                         }
                         $4 = 0;
                        }
                        $7 = HEAP32[$1 + 12 >> 2];
                        if (sqlite3ExprIsVector($7)) {
                         codeVectorCompare($0, $1, $2, $3, $4);
                         break label$4;
                        }
                        $10 = sqlite3ExprCodeTemp($0, $7, $6 + 124 | 0);
                        $9 = sqlite3ExprCodeTemp($0, HEAP32[$1 + 16 >> 2], $6 + 120 | 0);
                        sqlite3VdbeAddOp2($5, 71, 1, $2);
                        codeCompare($0, $7, HEAP32[$1 + 16 >> 2], $3, $10, $9, sqlite3VdbeCurrentAddr($5) + 2 | 0, $4, HEAP32[$1 + 4 >> 2] >>> 10 & 1);
                        if ($8) {
                         sqlite3VdbeAddOp2($5, 71, 0, $2);
                         break label$4;
                        }
                        sqlite3VdbeAddOp3($5, 92, $10, $2, $9);
                        break label$4;
                       }
                       $4 = sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 124 | 0);
                       sqlite3VdbeAddOp3($5, $3, sqlite3ExprCodeTemp($0, HEAP32[$1 + 16 >> 2], $6 + 120 | 0), $4, $2);
                       break label$4;
                      }
                      label$53: {
                       label$54: {
                        label$55: {
                         $3 = HEAP32[$1 + 12 >> 2];
                         switch (HEAPU8[$3 | 0] - 153 | 0) {
                         case 0:
                          break label$54;

                         case 2:
                          break label$55;

                         default:
                          break label$53;
                         }
                        }
                        codeInteger($0, $3, 1, $2);
                        break label$2;
                       }
                       codeReal($5, HEAP32[$3 + 8 >> 2], 1, $2);
                       break label$2;
                      }
                      HEAP32[$6 + 68 >> 2] = 67584;
                      HEAP32[$6 + 72 >> 2] = 0;
                      HEAP8[$6 + 64 | 0] = 155;
                      $3 = sqlite3ExprCodeTemp($0, $6 - -64 | 0, $6 + 124 | 0);
                      sqlite3VdbeAddOp3($5, 107, sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 120 | 0), $3, $2);
                      break label$4;
                     }
                     sqlite3VdbeAddOp2($5, $3, sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 124 | 0), $2);
                     break label$4;
                    }
                    $4 = sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 124 | 0);
                    $3 = sqlite3ExprTruthValue(HEAP32[$1 + 16 >> 2]);
                    sqlite3VdbeAddOp4Int($5, 91, $4, $2, !$3, HEAPU8[$1 + 2 | 0] == 45 ^ $3);
                    break label$4;
                   }
                   sqlite3VdbeAddOp2($5, 71, 1, $2);
                   $1 = sqlite3VdbeAddOp1($5, $3, sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 124 | 0));
                   sqlite3VdbeAddOp2($5, 71, 0, $2);
                   sqlite3VdbeJumpHere($5, $1);
                   break label$4;
                  }
                  label$56: {
                   $3 = HEAP32[$1 + 40 >> 2];
                   label$57: {
                    if (!$3) {
                     break label$57;
                    }
                    $5 = HEAP16[$1 + 34 >> 1];
                    if (($5 | 0) < 0) {
                     break label$57;
                    }
                    if (HEAP32[$3 + 44 >> 2] > ($5 | 0)) {
                     break label$56;
                    }
                   }
                   HEAP32[$6 + 16 >> 2] = $1;
                   sqlite3ErrorMsg($0, 26217, $6 + 16 | 0);
                   break label$4;
                  }
                  $4 = HEAP32[(HEAP32[$3 + 40 >> 2] + Math_imul($5, 20) | 0) + 8 >> 2];
                  break label$1;
                 }
                 if (HEAP8[$1 + 7 | 0] & 1) {
                  $4 = HEAP32[HEAP32[$1 + 44 >> 2] + 56 >> 2];
                  break label$1;
                 }
                 $12 = HEAP32[$0 >> 2];
                 $3 = HEAPU8[$12 + 84 | 0];
                 label$59: {
                  if (!HEAPU8[$0 + 23 | 0]) {
                   break label$59;
                  }
                  if (!sqlite3ExprIsConstantNotJoin($1)) {
                   break label$59;
                  }
                  $4 = sqlite3ExprCodeRunJustOnce($0, $1, -1);
                  break label$1;
                 }
                 $7 = HEAP32[$1 + 20 >> 2];
                 if ($7) {
                  $9 = HEAP32[$7 >> 2];
                 }
                 $4 = sqlite3FindFunction($12, HEAP32[$1 + 8 >> 2], $9, $3 & 255, 0);
                 if (!(!$4 | HEAP32[$4 + 20 >> 2])) {
                  $3 = HEAP32[$4 + 4 >> 2];
                  if ($3 & 4194304) {
                   $4 = exprCodeInlineFunction($0, $7, HEAP32[$4 + 8 >> 2], $2);
                   break label$1;
                  }
                  if ($3 & 2621440) {
                   sqlite3ExprFunctionUsable($0, $1, $4);
                  }
                  $10 = ($9 | 0) > 0 ? $9 : 0;
                  $3 = 0;
                  while (1) {
                   if (($3 | 0) != ($10 | 0)) {
                    label$66: {
                     if ($3 >>> 0 > 31) {
                      break label$66;
                     }
                     if (!sqlite3ExprIsConstant(HEAP32[(($3 << 4) + $7 | 0) + 8 >> 2])) {
                      break label$66;
                     }
                     $11 = 1 << $3 | $11;
                    }
                    if (!(!(HEAPU8[$4 + 4 | 0] & 32) | $8)) {
                     $8 = sqlite3ExprCollSeq($0, HEAP32[(($3 << 4) + $7 | 0) + 8 >> 2]);
                    }
                    $3 = $3 + 1 | 0;
                    continue;
                   }
                   break;
                  }
                  label$68: {
                   if (!$7) {
                    $3 = 0;
                    break label$68;
                   }
                   label$70: {
                    if ($11) {
                     $3 = HEAP32[$0 + 44 >> 2];
                     HEAP32[$0 + 44 >> 2] = $9 + $3;
                     $3 = $3 + 1 | 0;
                     break label$70;
                    }
                    $3 = sqlite3GetTempRange($0, $9);
                   }
                   $10 = HEAP32[$4 + 4 >> 2] & 192;
                   label$72: {
                    if (!$10) {
                     break label$72;
                    }
                    label$73: {
                     $13 = HEAP32[$7 + 8 >> 2];
                     switch (HEAPU8[$13 | 0] - 167 | 0) {
                     case 0:
                     case 2:
                      break label$73;

                     default:
                      break label$72;
                     }
                    }
                    HEAP8[$13 + 2 | 0] = $10;
                   }
                   sqlite3ExprCodeExprList($0, $7, $3, 0, 3);
                  }
                  label$74: {
                   label$75: {
                    label$76: {
                     if (($9 | 0) >= 2) {
                      if (!(HEAP8[$1 + 5 | 0] & 1)) {
                       break label$76;
                      }
                      $7 = $7 + 24 | 0;
                      break label$75;
                     }
                     if (($9 | 0) != 1) {
                      break label$74;
                     }
                    }
                    $7 = $7 + 8 | 0;
                   }
                   $4 = sqlite3VtabOverloadFunction($12, $4, $9, HEAP32[$7 >> 2]);
                  }
                  if (HEAPU8[$4 + 4 | 0] & 32) {
                   $8 = $8 ? $8 : HEAP32[$12 + 8 >> 2];
                   sqlite3VdbeAddOp4($5, 85, 0, 0, 0, $8, -2);
                  }
                  sqlite3VdbeAddFunctionCall($0, $11, $3, $2, $9, $4, HEAPU8[$1 + 2 | 0]);
                  if (!$9 | $11) {
                   break label$2;
                  }
                  sqlite3ReleaseTempRange($0, $3, $9);
                  break label$2;
                 }
                 HEAP32[$6 + 32 >> 2] = $1;
                 sqlite3ErrorMsg($0, 26193, $6 + 32 | 0);
                 break label$4;
                }
                if (HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
                 break label$1;
                }
                label$80: {
                 if (!(!(HEAPU8[$1 + 5 | 0] & 16) | ($3 | 0) != 138)) {
                  $3 = HEAP32[HEAP32[HEAP32[$1 + 20 >> 2] + 28 >> 2] >> 2];
                  if (($3 | 0) != 1) {
                   break label$80;
                  }
                 }
                 $4 = sqlite3CodeSubselect($0, $1);
                 break label$1;
                }
                sqlite3SubselectError($0, $3, 1);
                break label$4;
               }
               $3 = HEAP32[$1 + 12 >> 2];
               $2 = HEAP32[$3 + 28 >> 2];
               if (!(HEAPU8[$0 + 26 | 0] <= HEAPU8[$3 + 2 | 0] ? $2 : 0)) {
                $2 = sqlite3CodeSubselect($0, $3);
                HEAP32[$3 + 28 >> 2] = $2;
                HEAP8[$3 + 2 | 0] = HEAPU8[$0 + 26 | 0];
               }
               $5 = HEAP32[$1 + 28 >> 2];
               $4 = sqlite3ExprVectorSize($3);
               if (($5 | 0) != ($4 | 0)) {
                HEAP32[$6 + 52 >> 2] = $4;
                HEAP32[$6 + 48 >> 2] = $5;
                sqlite3ErrorMsg($0, 5018, $6 + 48 | 0);
                $2 = HEAP32[$3 + 28 >> 2];
               }
               $4 = HEAP16[$1 + 32 >> 1] + $2 | 0;
               break label$1;
              }
              $3 = sqlite3VdbeMakeLabel($0);
              $4 = sqlite3VdbeMakeLabel($0);
              sqlite3VdbeAddOp2($5, 75, 0, $2);
              sqlite3ExprCodeIN($0, $1, $3, $4);
              sqlite3VdbeAddOp2($5, 71, 1, $2);
              sqlite3VdbeResolveLabel($5, $3);
              sqlite3VdbeAddOp2($5, 86, $2, 0);
              sqlite3VdbeResolveLabel($5, $4);
              break label$2;
             }
             exprCodeBetween($0, $1, $2, 0, 0);
             break label$2;
            }
            if (HEAPU8[$1 + 5 | 0] & 2) {
             break label$11;
            }
            $3 = HEAP32[$1 + 12 >> 2];
            if (!$3 | HEAPU8[$3 | 0] != 172) {
             break label$11;
            }
            $1 = sqlite3ExprCodeTarget($0, $3, $2);
            if (($2 | 0) != ($1 | 0)) {
             sqlite3VdbeAddOp2($5, 81, $1, $2);
            }
            sqlite3VdbeAddOp1($5, 179, $2);
            break label$2;
           }
           $1 = HEAP32[$1 + 12 >> 2];
           continue;
          }
          break;
         }
         $3 = HEAP32[$1 + 44 >> 2];
         $4 = HEAP16[$1 + 32 >> 1];
         sqlite3VdbeAddOp2($5, 157, (sqlite3TableColumnToStorage($3, $4) + Math_imul(HEAP32[$1 + 28 >> 2], HEAP16[$3 + 34 >> 1] + 1 | 0) | 0) + 1 | 0, $2);
         if (HEAPU8[(HEAP32[$3 + 4 >> 2] + Math_imul($4 & 65535, 12) | 0) + 5 | 0] != 69 | ($4 | 0) < 0) {
          break label$4;
         }
         sqlite3VdbeAddOp1($5, 87, $2);
         break label$4;
        }
        sqlite3ErrorMsg($0, 14966, 0);
        break label$4;
       }
       $7 = HEAPU8[$0 + 23 | 0];
       $3 = sqlite3VdbeAddOp1($5, 18, HEAP32[$1 + 28 >> 2]);
       HEAP8[$0 + 23 | 0] = 0;
       $4 = sqlite3ExprCodeTarget($0, HEAP32[$1 + 12 >> 2], $2);
       HEAP8[$0 + 23 | 0] = $7;
       sqlite3VdbeJumpHere($5, $3);
       sqlite3VdbeChangeP3($5, $3, $4);
       break label$3;
      }
      $13 = HEAP32[$0 >> 2];
      $14 = HEAP32[$1 + 20 >> 2];
      $15 = HEAP32[$14 >> 2];
      $9 = sqlite3VdbeMakeLabel($0);
      $3 = 0;
      $10 = HEAP32[$1 + 12 >> 2];
      if ($10) {
       $11 = sqlite3ExprDup($13, $10, 0);
       if (HEAPU8[$13 + 87 | 0]) {
        sqlite3ExprDelete($13, $11);
        break label$4;
       }
       exprToRegister($11, exprCodeVector($0, $11, $6 + 124 | 0));
       memset($6 - -64 | 0, 0, 52);
       HEAP32[$6 + 76 >> 2] = $11;
       HEAP8[$6 + 64 | 0] = 53;
       HEAP32[$6 + 124 >> 2] = 0;
       $8 = $6 - -64 | 0;
      }
      $1 = $14 + 8 | 0;
      $12 = $15 - 1 | 0;
      while (1) {
       if (($3 | 0) < ($12 | 0)) {
        $4 = $3 << 4;
        $7 = HEAP32[$4 + $1 >> 2];
        label$90: {
         if (!$10) {
          $8 = $7;
          break label$90;
         }
         HEAP32[$6 + 80 >> 2] = $7;
        }
        $7 = sqlite3VdbeMakeLabel($0);
        sqlite3ExprIfFalse($0, $8, $7, 16);
        sqlite3ExprCode($0, HEAP32[($4 | 16) + $1 >> 2], $2);
        sqlite3VdbeGoto($5, $9);
        sqlite3VdbeResolveLabel($5, $7);
        $3 = $3 + 2 | 0;
        continue;
       }
       break;
      }
      label$92: {
       if ($15 & 1) {
        sqlite3ExprCode($0, HEAP32[(($12 << 4) + $14 | 0) + 8 >> 2], $2);
        break label$92;
       }
       sqlite3VdbeAddOp2($5, 75, 0, $2);
      }
      sqlite3ExprDelete($13, $11);
      setDoNotMergeFlagOnCopy($5);
      sqlite3VdbeResolveLabel($5, $9);
      break label$4;
     }
     if (!(HEAP32[$0 + 120 >> 2] | HEAPU8[$0 + 18 | 0])) {
      sqlite3ErrorMsg($0, 10976, 0);
      break label$1;
     }
     $3 = HEAPU8[$1 + 1 | 0];
     if (($3 | 0) == 2) {
      sqlite3MayAbort($0);
      $3 = HEAPU8[$1 + 1 | 0];
     }
     if (($3 & 255) == 4) {
      sqlite3VdbeAddOp4($5, 70, 0, 4, 0, HEAP32[$1 + 8 >> 2], 0);
      break label$4;
     }
     sqlite3HaltConstraint($0, HEAP32[$0 + 120 >> 2] ? 1811 : 1, $3 << 24 >> 24, HEAP32[$1 + 8 >> 2], 0, 0);
    }
    $4 = $2;
   }
   sqlite3ReleaseTempReg($0, HEAP32[$6 + 124 >> 2]);
   sqlite3ReleaseTempReg($0, HEAP32[$6 + 120 >> 2]);
   break label$1;
  }
  $4 = $2;
 }
 __stack_pointer = $6 + 128 | 0;
 return $4;
}

function sqlite3WhereCodeOneLoopStart($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
 $26 = __stack_pointer + -64 | 0;
 __stack_pointer = $26;
 $9 = HEAP32[$4 + 80 >> 2];
 $24 = HEAP32[$0 >> 2];
 $33 = $2 + 504 | 0;
 $11 = HEAP32[$2 + 4 >> 2];
 $12 = HEAPU8[$4 + 60 | 0];
 $7 = $11 + ($12 << 6) | 0;
 $19 = HEAP32[$7 + 48 >> 2];
 $10 = sqlite3WhereGetMask($33, $19);
 $17 = $10;
 $15 = i64toi32_i32$HIGH_BITS;
 $10 = $15 ^ -1;
 $15 = $17 ^ -1;
 $16 = $5;
 HEAP32[$4 + 88 >> 2] = $15 & $16;
 $17 = $6;
 $17 = $10 & $17;
 HEAP32[$4 + 92 >> 2] = $17;
 $17 = HEAP32[$2 + 80 >> 2];
 $15 = HEAP32[$2 + 84 >> 2];
 $13 = sqlite3VdbeMakeLabel($0);
 HEAP32[$4 + 12 >> 2] = $13;
 HEAP32[$4 + 16 >> 2] = $13;
 $32 = sqlite3VdbeMakeLabel($0);
 HEAP32[$4 + 24 >> 2] = $32;
 $10 = $17;
 $17 = $3 & 31;
 if (($3 & 63) >>> 0 >= 32) {
  $18 = $15 >>> $17 | 0;
 } else {
  $18 = ((1 << $17) - 1 & $15) << 32 - $17 | $10 >>> $17;
 }
 if (!(!HEAPU8[$4 + 60 | 0] | !(HEAPU8[$7 + 44 | 0] & 8))) {
  $8 = HEAP32[$0 + 44 >> 2] + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $8;
  HEAP32[$4 >> 2] = $8;
  sqlite3VdbeAddOp2($1, 71, 0, $8);
 }
 $34 = $2 + 88 | 0;
 $10 = $7 + 8 | 0;
 $16 = $18 & 1;
 $14 = $3 >> 31 & $3;
 $7 = $3;
 label$2: {
  while (1) {
   if (($7 | 0) <= 0) {
    break label$2;
   }
   $8 = Math_imul($7, 96) + $2 | 0;
   if (!(HEAP32[$8 + 768 >> 2] | HEAP32[$8 + 824 >> 2])) {
    $7 = $7 - 1 | 0;
    continue;
   }
   break;
  }
  $14 = $7;
 }
 $29 = ($12 << 6) + $11 | 0;
 $8 = HEAPU8[$29 + 45 | 0] | HEAPU8[$29 + 46 | 0] << 8;
 label$5: {
  label$6: {
   if ($8 & 32) {
    $14 = 0;
    $7 = HEAP32[$29 + 36 >> 2];
    sqlite3VdbeAddOp3($1, 10, $7, 0, HEAP32[$29 + 32 >> 2]);
    $7 = sqlite3VdbeAddOp2($1, 11, $7, $13);
    HEAP8[$4 + 61 | 0] = 8;
    HEAP32[$4 + 68 >> 2] = $7;
    break label$6;
   }
   $7 = HEAP32[$9 + 40 >> 2];
   if ($7 & 1024) {
    $3 = HEAPU16[$9 + 44 >> 1];
    $10 = sqlite3GetTempRange($0, $3 + 2 | 0);
    $18 = $10 + 2 | 0;
    $14 = HEAP32[$4 + 12 >> 2];
    $7 = 0;
    while (1) {
     if (($3 | 0) != ($7 | 0)) {
      $8 = HEAP32[HEAP32[$9 + 52 >> 2] + ($7 << 2) >> 2];
      label$11: {
       if (!$8) {
        break label$11;
       }
       $13 = $7 + $18 | 0;
       if (HEAP8[$8 + 12 | 0] & 1) {
        if (HEAP32[$9 + 36 >> 2] & ($7 >>> 0 < 32 ? 1 << $7 : 0)) {
         $11 = HEAP32[$0 + 40 >> 2];
         HEAP32[$0 + 40 >> 2] = $11 + 1;
         $12 = HEAP32[$0 + 44 >> 2] + 1 | 0;
         HEAP32[$0 + 44 >> 2] = $12;
         sqlite3CodeRhsOfIN($0, HEAP32[$8 >> 2], $11);
         sqlite3VdbeAddOp3($1, 174, $11, $13, $12);
         break label$11;
        }
        codeEqualityTerm($0, $8, $4, $7, $16, $13);
        $14 = HEAP32[$4 + 16 >> 2];
        break label$11;
       }
       codeExprOrVector($0, HEAP32[HEAP32[$8 >> 2] + 16 >> 2], $13, 1);
       if (!(HEAPU8[$9 + 28 | 0] & 2) | HEAPU8[$8 + 15 | 0] != 74) {
        break label$11;
       }
       sqlite3VdbeAddOp2($1, 71, 0, HEAP32[HEAP32[$2 + 20 >> 2] + 12 >> 2]);
      }
      $7 = $7 + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3VdbeAddOp2($1, 71, HEAP32[$9 + 24 >> 2], $10);
    sqlite3VdbeAddOp2($1, 71, $3, $10 + 1 | 0);
    sqlite3VdbeAddOp4($1, 6, $19, $14, $10, HEAP32[$9 + 32 >> 2], HEAP8[$9 + 28 | 0] & 1 ? -6 : -1);
    HEAP8[$9 + 28 | 0] = HEAPU8[$9 + 28 | 0] & 254;
    if (HEAPU8[$24 + 87 | 0]) {
     HEAP32[$9 + 32 >> 2] = 0;
    }
    HEAP32[$4 + 64 >> 2] = $19;
    HEAP8[$4 + 61 | 0] = HEAPU8[$2 + 50 | 0] ? -72 : 62;
    HEAP32[$4 + 68 >> 2] = sqlite3VdbeCurrentAddr($1);
    $14 = 0;
    $7 = 0;
    while (1) {
     if (($3 | 0) == ($7 | 0)) {
      break label$6;
     }
     $13 = HEAP32[HEAP32[$9 + 52 >> 2] + ($7 << 2) >> 2];
     label$16: {
      if (!(!(HEAPU16[$9 + 30 >> 1] >>> $7 & 1) | $7 >>> 0 > 15)) {
       disableTerm($4, $13);
       break label$16;
      }
      if (HEAPU8[$24 + 87 | 0] | (!(HEAP8[$13 + 12 | 0] & 1) | HEAP32[$9 + 36 >> 2] & ($7 >>> 0 < 32 ? 1 << $7 : 0))) {
       break label$16;
      }
      $8 = 0;
      $11 = HEAP32[$4 + 72 >> 2];
      $16 = ($11 | 0) > 0 ? $11 : 0;
      $10 = $7 + $18 | 0;
      while (1) {
       label$19: {
        if (($8 | 0) != ($16 | 0)) {
         $11 = sqlite3VdbeGetOp($1, HEAP32[(HEAP32[$4 + 76 >> 2] + Math_imul($8, 20) | 0) + 4 >> 2]);
         $12 = HEAPU8[$11 | 0];
         label$21: {
          if (($12 | 0) != 135) {
           if (($12 | 0) != 94 | HEAP32[$11 + 12 >> 2] != ($10 | 0)) {
            break label$19;
           }
           $8 = HEAP32[$11 + 8 >> 2];
           $17 = $10;
           break label$21;
          }
          if (HEAP32[$11 + 8 >> 2] != ($10 | 0)) {
           break label$19;
          }
          $8 = $10;
          $17 = HEAP32[$11 + 12 >> 2];
         }
         $16 = $17;
         sqlite3VdbeAddOp3($1, $12, HEAP32[$11 + 4 >> 2], $8, $16);
        }
        $8 = sqlite3PExpr($0, 53, 0, 0);
        if (!HEAPU8[$24 + 87 | 0]) {
         $11 = HEAP32[HEAP32[$13 >> 2] + 12 >> 2];
         $13 = HEAP32[$13 + 28 >> 2];
         if (($13 | 0) > 0) {
          $11 = HEAP32[(HEAP32[$11 + 20 >> 2] + ($13 << 4) | 0) - 8 >> 2];
         }
         HEAP32[$8 + 12 >> 2] = $11;
         $13 = sqlite3Expr($24, 176, 0);
         HEAP32[$8 + 16 >> 2] = $13;
         if ($13) {
          HEAP32[$13 + 28 >> 2] = $10;
          sqlite3ExprIfFalse($0, $8, HEAP32[$4 + 24 >> 2], 16);
         }
         HEAP32[$8 + 12 >> 2] = 0;
        }
        sqlite3ExprDelete($24, $8);
        break label$16;
       }
       $8 = $8 + 1 | 0;
       continue;
      }
     }
     $7 = $7 + 1 | 0;
     continue;
    }
   }
   $14 = HEAP32[(Math_imul($14, 96) + $2 | 0) + 780 >> 2];
   label$26: {
    label$27: {
     label$28: {
      if (!(!($7 & 256) | !($7 & 5))) {
       $9 = HEAP32[HEAP32[$9 + 52 >> 2] >> 2];
       $7 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $7;
       $9 = codeEqualityTerm($0, $9, $4, 0, $16, $7);
       if (($9 | 0) != ($7 | 0)) {
        sqlite3ReleaseTempReg($0, $7);
       }
       $7 = HEAP32[$4 + 16 >> 2];
       $8 = HEAP32[$4 + 52 >> 2];
       if ($8) {
        sqlite3VdbeAddOp4Int($1, 63, $8, $7, $9, 1);
        $17 = $6;
        filterPullDown($0, $2, $3, $7, $5, $17);
       }
       sqlite3VdbeAddOp3($1, 29, $19, $7, $9);
       HEAP8[$4 + 61 | 0] = 184;
       break label$28;
      }
      if (($7 & 258) == 258) {
       $8 = 0;
       $3 = 0;
       $11 = 0;
       if ($7 & 32) {
        $11 = 1;
        $3 = HEAP32[HEAP32[$9 + 52 >> 2] >> 2];
       }
       $8 = $7 & 16 ? HEAP32[HEAP32[$9 + 52 >> 2] + ($11 << 2) >> 2] : $8;
       $9 = $16 ? $3 : $8;
       $7 = $16 ? $8 : $3;
       label$35: {
        if ($7) {
         $8 = HEAP32[$7 >> 2];
         $3 = HEAP32[$8 + 16 >> 2];
         label$37: {
          if (sqlite3ExprIsVector($3)) {
           $7 = sqlite3GetTempReg($0);
           codeExprOrVector($0, HEAP32[$8 + 16 >> 2], $7, 1);
           $3 = $7;
           $8 = HEAPU8[$8 | 0] + 1 & 2 | 1;
           break label$37;
          }
          $3 = sqlite3ExprCodeTemp($0, $3, $26 + 8 | 0);
          disableTerm($4, $7);
          $7 = HEAP32[$26 + 8 >> 2];
          $8 = HEAPU8[$8 | 0] - 54 | 0;
         }
         sqlite3VdbeAddOp3($1, HEAPU8[$8 + 49024 | 0], $19, $13, $3);
         sqlite3ReleaseTempReg($0, $7);
         break label$35;
        }
        sqlite3VdbeAddOp2($1, $16 ? 31 : 35, $19, $14);
       }
       $14 = 0;
       $8 = 0;
       $7 = 184;
       label$39: {
        if (!$9) {
         break label$39;
        }
        $7 = HEAP32[$9 >> 2];
        $8 = HEAP32[$0 + 44 >> 2] + 1 | 0;
        HEAP32[$0 + 44 >> 2] = $8;
        codeExprOrVector($0, HEAP32[$7 + 16 >> 2], $8, 1);
        label$40: {
         label$41: {
          if (!sqlite3ExprIsVector(HEAP32[$7 + 16 >> 2])) {
           label$43: {
            switch (HEAPU8[$7 | 0] - 54 | 0) {
            case 0:
            case 2:
             break label$43;

            default:
             break label$41;
            }
           }
           $7 = $16 ? 55 : 57;
           break label$40;
          }
          $7 = $16 ? 56 : 54;
          break label$39;
         }
         $7 = $16 ? 56 : 54;
        }
        disableTerm($4, $9);
       }
       HEAP32[$4 + 68 >> 2] = sqlite3VdbeCurrentAddr($1);
       HEAP32[$4 + 64 >> 2] = $19;
       HEAP8[$4 + 61 | 0] = $16 ? 37 : 38;
       if (($7 | 0) == 184) {
        break label$6;
       }
       $9 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $9;
       sqlite3VdbeAddOp2($1, 135, $19, $9);
       sqlite3VdbeAddOp3($1, $7, $8, $13, $9);
       sqlite3VdbeChangeP5($1, 83);
       break label$6;
      }
      if ($7 & 512) {
       $15 = HEAPU16[$9 + 26 >> 1];
       $14 = 0;
       $8 = HEAPU16[$9 + 24 >> 1];
       $12 = $8;
       if ($7 & 32) {
        $20 = HEAP32[HEAP32[$9 + 52 >> 2] + ($8 << 2) >> 2];
        $21 = $15;
        $12 = $8 + 1 | 0;
       }
       $10 = HEAPU16[$9 + 28 >> 1];
       $13 = HEAP32[$9 + 32 >> 2];
       $11 = HEAP32[$4 + 8 >> 2];
       label$46: {
        if (!($7 & 16)) {
         $12 = 0;
         break label$46;
        }
        $7 = $10 >>> 0 < $21 >>> 0;
        $12 = HEAP32[HEAP32[$9 + 52 >> 2] + ($12 << 2) >> 2];
        if (HEAP8[$12 + 11 | 0] & 1) {
         $14 = HEAP32[$0 + 44 >> 2] + 1 | 0;
         HEAP32[$0 + 44 >> 2] = $14;
         HEAP32[$4 + 44 >> 2] = $14;
         sqlite3VdbeAddOp2($1, 71, 1, $14);
         HEAP32[$4 + 48 >> 2] = sqlite3VdbeCurrentAddr($1);
         $14 = HEAP32[$4 + 44 >> 2] << 1;
         HEAP32[$4 + 44 >> 2] = $14;
         HEAP32[$4 + 44 >> 2] = HEAPU8[HEAP32[$13 + 28 >> 2] + $8 | 0] == 1 ^ $16 | $14;
        }
        $21 = $7 ? $21 : $10;
        $14 = 0;
        if ($20) {
         break label$46;
        }
        $7 = HEAPU16[HEAP32[$13 + 4 >> 2] + ($8 << 1) >> 1];
        $25 = $7 << 16 >> 16;
        label$49: {
         if (($25 | 0) >= 0) {
          if (!(HEAPU8[(HEAP32[HEAP32[$13 + 12 >> 2] + 4 >> 2] + Math_imul($7, 12) | 0) + 4 | 0] & 15)) {
           break label$49;
          }
          break label$46;
         }
         if (($25 | 0) != -2) {
          break label$46;
         }
        }
        $14 = 1;
       }
       $7 = 0;
       if ((HEAP32[$9 + 40 >> 2] & 524336) == 524288) {
        $14 = 1;
        $7 = HEAP32[$0 + 44 >> 2] + 1 | 0;
        HEAP32[$0 + 44 >> 2] = $7;
        HEAP32[$4 + 36 >> 2] = $7;
        if (HEAP32[$4 >> 2]) {
         sqlite3VdbeAddOp2($1, 71, 0, $7);
        }
        HEAP32[$4 + 40 >> 2] = sqlite3VdbeMakeLabel($0);
        $21 = 1;
       }
       if (($18 & 1) == (HEAPU8[HEAP32[$13 + 28 >> 2] + $8 | 0] != 0 | 0) | HEAPU16[$13 + 52 >> 1] <= $8 >>> 0) {
        break label$27;
       }
       $25 = $15 & 255;
       $30 = $14;
       $14 = $20;
       break label$26;
      }
      if ($7 & 8192) {
       $15 = HEAP32[$0 + 40 >> 2];
       HEAP32[$0 + 40 >> 2] = $15 + 1;
       $22 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $22;
       $28 = sqlite3VdbeMakeLabel($0);
       $13 = HEAP32[(($12 << 6) + $11 | 0) + 24 >> 2];
       $21 = HEAP32[HEAP32[$9 + 52 >> 2] >> 2];
       $8 = HEAP32[$21 + 24 >> 2];
       HEAP32[$4 + 64 >> 2] = $22;
       HEAP8[$4 + 61 | 0] = 67;
       $7 = HEAPU8[$2 + 48 | 0];
       label$54: {
        if ($7 >>> 0 >= 2) {
         $17 = 0;
         $7 = $7 - $3 | 0;
         $14 = sqlite3DbMallocRaw($24, $7 << 6 | 8, 0);
         if (!$14) {
          break label$5;
         }
         $9 = $7 & 255;
         HEAP32[$14 >> 2] = $9;
         HEAP32[$14 + 4 >> 2] = $9;
         __memcpy($14 + 8 | 0, $10, 64);
         $9 = ($7 | 0) > 1 ? $7 : 1;
         $3 = HEAP32[$2 + 4 >> 2] + 8 | 0;
         $7 = 1;
         while (1) {
          if (($7 | 0) == ($9 | 0)) {
           break label$54;
          }
          __memcpy((($7 << 6) + $14 | 0) + 8 | 0, (HEAPU8[(Math_imul($7, 96) + $4 | 0) + 60 | 0] << 6) + $3 | 0, 64);
          $7 = $7 + 1 | 0;
          continue;
         }
        }
        $14 = HEAP32[$2 + 4 >> 2];
       }
       $10 = 0;
       if (!(HEAPU8[$2 + 44 | 0] & 16)) {
        label$58: {
         if (!(HEAPU8[$13 + 28 | 0] & 128)) {
          $23 = HEAP32[$0 + 44 >> 2] + 1 | 0;
          HEAP32[$0 + 44 >> 2] = $23;
          sqlite3VdbeAddOp2($1, 75, 0, $23);
          break label$58;
         }
         $7 = sqlite3PrimaryKeyIndex($13);
         $23 = HEAP32[$0 + 40 >> 2];
         HEAP32[$0 + 40 >> 2] = $23 + 1;
         sqlite3VdbeAddOp2($1, 118, $23, HEAPU16[$7 + 50 >> 1]);
         sqlite3VdbeSetP4KeyInfo($0, $7);
        }
        $30 = HEAP32[$0 + 44 >> 2] + 1 | 0;
        HEAP32[$0 + 44 >> 2] = $30;
       }
       $31 = sqlite3VdbeAddOp2($1, 71, 0, $22);
       $3 = HEAP32[$2 + 100 >> 2];
       label$60: {
        if (($3 | 0) < 2) {
         break label$60;
        }
        $11 = 0;
        $7 = 0;
        while (1) {
         if (($3 | 0) > ($7 | 0)) {
          $9 = HEAP32[$2 + 112 >> 2] + Math_imul($7, 48) | 0;
          label$63: {
           if (($21 | 0) == ($9 | 0) | HEAPU16[$9 + 10 >> 1] & 32774 | !(HEAPU16[$9 + 12 >> 1] & 16383)) {
            break label$63;
           }
           $9 = HEAP32[$9 >> 2];
           if (HEAPU8[$9 + 6 | 0] & 64) {
            break label$63;
           }
           $11 = sqlite3ExprAnd($0, $11, sqlite3ExprDup($24, $9, 0));
           $3 = HEAP32[$2 + 100 >> 2];
          }
          $7 = $7 + 1 | 0;
          continue;
         }
         break;
        }
        if (!$11) {
         break label$60;
        }
        $10 = sqlite3PExpr($0, 65580, 0, $11);
       }
       sqlite3VdbeExplain($0, 1, 18975, 0);
       $9 = 0;
       while (1) {
        if (($9 | 0) < HEAP32[$8 + 12 >> 2]) {
         $7 = HEAP32[$8 + 24 >> 2] + Math_imul($9, 48) | 0;
         if (!(HEAPU8[$7 + 13 | 0] & 4 ? 0 : HEAP32[$7 + 20 >> 2] != ($19 | 0))) {
          $3 = sqlite3ExprDup($24, HEAP32[$7 >> 2], 0);
          label$69: {
           if (HEAPU8[$24 + 87 | 0]) {
            break label$69;
           }
           $7 = $3;
           if ($10) {
            HEAP32[$10 + 12 >> 2] = $3;
            $7 = $10;
           }
           HEAP32[$26 >> 2] = $9 + 1;
           sqlite3VdbeExplain($0, 1, 16902, $26);
           $18 = sqlite3WhereBegin($0, $14, $7, 0, 0, 0, 32, $15);
           if (!$18) {
            break label$69;
           }
           $7 = 0;
           sqlite3WhereExplainOneScan($0, $14, $18 + 768 | 0, 0);
           label$71: {
            if (HEAPU8[$2 + 44 | 0] & 16) {
             break label$71;
            }
            $27 = (HEAP32[$8 + 12 >> 2] - 1 | 0) == ($9 | 0) ? -1 : $9;
            if (!(HEAPU8[$13 + 28 | 0] & 128)) {
             sqlite3ExprCodeGetColumnOfTable($1, $13, $19, -1, $30);
             $7 = sqlite3VdbeAddOp4Int($1, 46, $23, 0, $30, $27);
             break label$71;
            }
            $16 = sqlite3PrimaryKeyIndex($13);
            $11 = HEAPU16[$16 + 50 >> 1];
            $12 = sqlite3GetTempRange($0, $11);
            while (1) {
             if (($7 | 0) != ($11 | 0)) {
              sqlite3ExprCodeGetColumnOfTable($1, $13, $19, HEAP16[HEAP32[$16 + 4 >> 2] + ($7 << 1) >> 1], $7 + $12 | 0);
              $7 = $7 + 1 | 0;
              continue;
             }
             break;
            }
            label$75: {
             label$76: {
              if (!$27) {
               $7 = 0;
               break label$76;
              }
              $7 = sqlite3VdbeAddOp4Int($1, 28, $23, 0, $12, $11);
              if (($27 | 0) < 0) {
               break label$75;
              }
             }
             sqlite3VdbeAddOp3($1, 97, $12, $11, $30);
             sqlite3VdbeAddOp4Int($1, 138, $23, $30, $12, $11);
             if (!$27) {
              break label$75;
             }
             sqlite3VdbeChangeP5($1, 16);
            }
            sqlite3ReleaseTempRange($0, $12, $11);
           }
           sqlite3VdbeAddOp2($1, 9, $22, $28);
           if ($7) {
            sqlite3VdbeJumpHere($1, $7);
           }
           $11 = HEAPU8[$18 + 52 | 0];
           $7 = 0;
           $12 = HEAP32[$18 + 848 >> 2];
           label$79: {
            if (!(HEAPU8[$12 + 41 | 0] & 2) | (HEAP32[$12 + 32 >> 2] != ($25 | 0) ? $9 : 0)) {
             break label$79;
            }
            $12 = HEAP32[$12 + 32 >> 2];
            if (((HEAPU8[$12 + 55 | 0] | HEAPU8[$12 + 56 | 0] << 8) & 3) == 2 ? HEAPU8[$13 + 28 | 0] & 128 : 0) {
             break label$79;
            }
            $7 = $12;
           }
           $11 = $11 & 2;
           if (sqlite3WhereUsesDeferredSeek($18)) {
            HEAP8[$2 + 52 | 0] = HEAPU8[$2 + 52 | 0] | 1;
           }
           $20 = $11 ? 1 : $20;
           sqlite3WhereEnd($18);
           sqlite3VdbeExplainPop($0);
           $25 = $7;
          }
          sqlite3ExprDelete($24, $3);
         }
         $9 = $9 + 1 | 0;
         continue;
        }
        break;
       }
       sqlite3VdbeExplainPop($0);
       HEAP32[$4 + 72 >> 2] = $25;
       if ($25) {
        HEAP32[$4 + 8 >> 2] = $15;
       }
       if ($10) {
        HEAP32[$10 + 12 >> 2] = 0;
        sqlite3ExprDelete($24, $10);
       }
       sqlite3VdbeChangeP1($1, $31, sqlite3VdbeCurrentAddr($1));
       sqlite3VdbeGoto($1, HEAP32[$4 + 12 >> 2]);
       sqlite3VdbeResolveLabel($1, $28);
       HEAP32[$4 + 68 >> 2] = sqlite3VdbeCurrentAddr($1);
       if (HEAPU8[$2 + 48 | 0] >= 2) {
        sqlite3DbFree($24, $14);
       }
       $14 = 0;
       if ($20) {
        break label$6;
       }
       disableTerm($4, $21);
       break label$6;
      }
      if ($8 & 64) {
       HEAP8[$4 + 61 | 0] = 184;
       break label$28;
      }
      HEAP32[$4 + 64 >> 2] = $19;
      HEAP8[$4 + 61 | 0] = HEAPU8[$16 + 49040 | 0];
      $7 = sqlite3VdbeAddOp2($1, HEAPU8[$16 + 49042 | 0], $19, $14);
      HEAP8[$4 + 63 | 0] = 1;
      HEAP32[$4 + 68 >> 2] = $7 + 1;
     }
     $14 = 0;
     break label$6;
    }
    $22 = $14;
    $14 = $12;
    $12 = $20;
    $25 = $10;
    $10 = $15;
   }
   if (!(!(HEAPU8[$9 + 42 | 0] & 16) | ($3 | 0) <= 0)) {
    sqlite3VdbeAddOp1($1, 136, $11);
   }
   $15 = 0;
   $18 = codeAllEqualityTerms($0, $4, $16, $21, $26 + 8 | 0);
   $21 = HEAP32[$26 + 8 >> 2];
   if (!(!$21 | !$25)) {
    $15 = sqlite3DbStrDup($24, $8 + $21 | 0);
   }
   $20 = $7 ? 40 : 16;
   $27 = 1;
   $28 = 1;
   $28 = $12 ? (HEAPU8[$12 + 12 | 0] & 40) != 0 : $28;
   $20 = $4 + $20 | 0;
   $27 = $14 ? (HEAPU8[$14 + 12 | 0] & 40) != 0 : $27;
   $20 = HEAP32[$20 >> 2];
   label$91: {
    if ($12) {
     $23 = HEAP32[HEAP32[$12 >> 2] + 16 >> 2];
     $22 = $8 + $18 | 0;
     codeExprOrVector($0, $23, $22, $10);
     whereLikeOptimizationStringFixup($1, $4, $12);
     label$93: {
      if (HEAPU8[$12 + 10 | 0] & 128) {
       break label$93;
      }
      if (!sqlite3ExprCanBeNull($23)) {
       break label$93;
      }
      sqlite3VdbeAddOp2($1, 50, $22, $20);
     }
     if ($21) {
      updateRangeAffinityStr($23, $10, $8 + $21 | 0);
     }
     $10 = $8 + $10 | 0;
     $31 = 1;
     $22 = 0;
     if (sqlite3ExprIsVector($23)) {
      $28 = 1;
      break label$91;
     }
     disableTerm($4, $12);
     break label$91;
    }
    if ($22) {
     $28 = 0;
     sqlite3VdbeAddOp2($1, 75, 0, $8 + $18 | 0);
     $22 = 1;
     $10 = $8 + 1 | 0;
     $31 = 1;
     break label$91;
    }
    if (!$7) {
     $31 = ($8 | 0) != 0;
     $22 = 0;
     $10 = $8;
     break label$91;
    }
    $22 = 0;
    sqlite3VdbeAddOp2($1, 75, 0, $8 + $18 | 0);
    $31 = 1;
    $10 = $8 + 1 | 0;
   }
   codeApplyAffinity($0, $18, $10 - $22 | 0, $21);
   label$98: {
    label$99: {
     label$100: {
      label$101: {
       label$102: {
        $12 = HEAPU16[$9 + 46 >> 1];
        label$103: {
         if (!(($12 | 0) == ($10 | 0) ? $12 : 0)) {
          if ($7) {
           sqlite3VdbeAddOp2($1, 71, 1, $7);
          }
          $12 = HEAP32[$4 + 52 >> 2];
          if ($12) {
           sqlite3VdbeAddOp4Int($1, 63, $12, $20, $18, $8);
           $17 = $6;
           filterPullDown($0, $2, $3, $20, $5, $17);
          }
          $12 = 0;
          $23 = ($31 ? 4 : 0) | ($28 ? 2 : 0) | $16;
          $3 = HEAPU8[$23 + 49028 | 0];
          if (!(!(HEAPU8[$9 + 42 | 0] & 16) | ($23 | 0) != 6)) {
           $12 = sqlite3VdbeAddOp1($1, 124, (HEAP16[HEAP32[$13 + 8 >> 2] >> 1] + 9 | 0) / 10 | 0);
          }
          sqlite3VdbeAddOp4Int($1, $3, $11, $20, $18, $10);
          if ($7) {
           sqlite3VdbeAddOp2($1, 8, 0, sqlite3VdbeCurrentAddr($1) + 2 | 0);
           sqlite3VdbeAddOp4Int($1, HEAPU8[(($10 >>> 0 < 2 ? 2 : 6) | $16) + 49028 | 0], $11, $20, $18, $10 - $28 | 0);
          }
          if (!$14) {
           break label$103;
          }
          $10 = HEAP32[HEAP32[$14 >> 2] + 16 >> 2];
          if (!$12) {
           break label$101;
          }
          HEAP32[$4 + 68 >> 2] = sqlite3VdbeCurrentAddr($1);
          break label$100;
         }
         if ($14) {
          break label$102;
         }
         $12 = 0;
        }
        if ($30) {
         break label$99;
        }
        $3 = $8;
        break label$98;
       }
       $10 = HEAP32[HEAP32[$14 >> 2] + 16 >> 2];
      }
      $12 = 0;
     }
     $3 = $8 + $18 | 0;
     codeExprOrVector($0, $10, $3, $25);
     whereLikeOptimizationStringFixup($1, $4, $14);
     label$109: {
      if (HEAPU8[$14 + 10 | 0] & 128) {
       break label$109;
      }
      if (!sqlite3ExprCanBeNull($10)) {
       break label$109;
      }
      sqlite3VdbeAddOp2($1, 50, $3, $20);
     }
     if ($15) {
      updateRangeAffinityStr($10, $25, $15);
      codeApplyAffinity($0, $3, $25, $15);
     }
     $3 = $8 + $25 | 0;
     if (sqlite3ExprIsVector($10)) {
      $27 = 1;
      break label$98;
     }
     disableTerm($4, $14);
     break label$98;
    }
    if (!$7) {
     sqlite3VdbeAddOp2($1, 75, 0, $8 + $18 | 0);
     $27 = 0;
    }
    $3 = $8 + 1 | 0;
   }
   sqlite3DbFree($24, $21);
   sqlite3DbFree($24, $15);
   if (!HEAP32[$4 + 68 >> 2]) {
    HEAP32[$4 + 68 >> 2] = sqlite3VdbeCurrentAddr($1);
   }
   label$114: {
    if (!$3) {
     break label$114;
    }
    if ($7) {
     sqlite3VdbeAddOp2($1, 16, $7, sqlite3VdbeCurrentAddr($1) + 3 | 0);
    }
    sqlite3VdbeAddOp4Int($1, HEAPU8[($16 << 1 | $27) + 49036 | 0], $11, $20, $18, $3);
    if (!$12) {
     break label$114;
    }
    sqlite3VdbeJumpHere($1, $12);
   }
   if ($7) {
    sqlite3VdbeAddOp2($1, 15, $7, sqlite3VdbeCurrentAddr($1) + 2 | 0);
    sqlite3VdbeAddOp4Int($1, HEAPU8[($16 << 1 | $22) + 49036 | 0], $11, $20, $18, $3 + $22 | 0);
   }
   $7 = HEAP32[$9 + 40 >> 2];
   if ($7 & 262144) {
    sqlite3VdbeAddOp3($1, 125, $11, $8, $8);
    $7 = HEAP32[$9 + 40 >> 2];
   }
   $8 = 1;
   label$117: {
    if (!(!($7 & 64) | HEAPU16[$2 + 44 >> 1] & 4128)) {
     break label$117;
    }
    $3 = HEAP32[$13 + 12 >> 2];
    label$120: {
     if (!(HEAPU8[$3 + 28 | 0] & 128)) {
      codeDeferredSeek($2, $13, $19, $11);
      break label$120;
     }
     $8 = 0;
     if (($11 | 0) == ($19 | 0)) {
      break label$117;
     }
     $7 = 0;
     $8 = sqlite3PrimaryKeyIndex($3);
     $12 = sqlite3GetTempRange($0, HEAPU16[$8 + 50 >> 1]);
     while (1) {
      $3 = HEAPU16[$8 + 50 >> 1];
      if ($3 >>> 0 > $7 >>> 0) {
       sqlite3VdbeAddOp3($1, 94, $11, sqlite3TableColumnToIndex($13, HEAP16[HEAP32[$8 + 4 >> 2] + ($7 << 1) >> 1]), $7 + $12 | 0);
       $7 = $7 + 1 | 0;
       continue;
      }
      break;
     }
     sqlite3VdbeAddOp4Int($1, 27, $19, $32, $12, $3);
    }
    $8 = 0;
   }
   label$124: {
    if (HEAP32[$4 >> 2]) {
     break label$124;
    }
    if (!(HEAPU16[$2 + 44 >> 1] & 4128)) {
     whereIndexExprTrans($13, $19, $11, $2);
    }
    $7 = HEAP32[$13 + 36 >> 2];
    if (!$7) {
     break label$124;
    }
    whereApplyPartialIndexConstraints($7, $19, $34);
   }
   $7 = HEAP32[$9 + 40 >> 2];
   label$126: {
    if ($7 & 4096) {
     HEAP8[$4 + 61 | 0] = 184;
     break label$126;
    }
    if ($16) {
     HEAP8[$4 + 61 | 0] = 37;
     break label$126;
    }
    HEAP8[$4 + 61 | 0] = 38;
   }
   HEAP32[$4 + 64 >> 2] = $11;
   HEAP8[$4 + 62 | 0] = $7 >>> 16 & 1;
   if (!($7 & 15)) {
    HEAP8[$4 + 63 | 0] = 1;
   }
   $14 = $8 ? 0 : $13;
  }
  $18 = $14 ? 1 : 2;
  while (1) {
   $9 = HEAP32[$2 + 100 >> 2];
   $7 = HEAP32[$2 + 112 >> 2];
   $11 = 0;
   while (1) {
    if (($9 | 0) > 0) {
     $8 = HEAPU16[$7 + 10 >> 1];
     label$133: {
      if ($8 & 6) {
       break label$133;
      }
      $10 = HEAP32[$4 + 92 >> 2];
      $12 = $10;
      $17 = HEAP32[$4 + 88 >> 2];
      $20 = $17;
      $15 = $17;
      $10 = HEAP32[$7 + 40 >> 2];
      $16 = $10;
      $17 = HEAP32[$7 + 44 >> 2];
      $10 = $17;
      $17 = $12;
      $10 = $10 & $17;
      if ($15 & $16 | $10) {
       HEAP8[$2 + 52 | 0] = HEAPU8[$2 + 52 | 0] | 2;
       break label$133;
      }
      $3 = HEAP32[$7 >> 2];
      $13 = HEAPU8[$29 + 44 | 0];
      if ($13 & 88) {
       $16 = HEAP32[$3 + 4 >> 2];
       if (!($16 & 3) | ($16 & 1 ? 0 : $13 & 8)) {
        break label$133;
       }
       $10 = sqlite3WhereGetMask($33, HEAP32[$3 + 36 >> 2]);
       $17 = $10;
       $10 = $12;
       $15 = i64toi32_i32$HIGH_BITS;
       $10 = $10 & $15;
       $16 = $20;
       $15 = $17 & $16;
       if ($10 | $15) {
        break label$133;
       }
      }
      label$136: {
       label$137: {
        if (($18 | 0) == 1) {
         if (!sqlite3ExprCoveredByIndex($3, HEAP32[$4 + 4 >> 2], $14)) {
          $11 = 2;
          break label$133;
         }
         $8 = HEAPU16[$7 + 10 >> 1];
         break label$137;
        }
        if ($18 >>> 0 > 2) {
         break label$136;
        }
       }
       if (!($8 & 4096)) {
        break label$136;
       }
       $11 = $11 ? $11 : 3;
       break label$133;
      }
      $13 = 0;
      label$140: {
       if (!($8 & 512)) {
        break label$140;
       }
       $8 = HEAP32[$4 + 44 >> 2];
       if (!$8) {
        break label$140;
       }
       $13 = sqlite3VdbeAddOp1($1, $8 & 1 ? 16 : 15, $8 >>> 1 | 0);
      }
      sqlite3ExprIfFalse($0, $3, $32, 16);
      if ($13) {
       sqlite3VdbeJumpHere($1, $13);
      }
      HEAP16[$7 + 10 >> 1] = HEAPU16[$7 + 10 >> 1] | 4;
     }
     $7 = $7 + 48 | 0;
     $9 = $9 - 1 | 0;
     continue;
    }
    break;
   }
   $18 = $11;
   if (($11 | 0) > 0) {
    continue;
   }
   break;
  }
  $9 = HEAP32[$2 + 108 >> 2];
  $7 = HEAP32[$2 + 112 >> 2];
  while (1) {
   if (($9 | 0) > 0) {
    label$144: {
     if (HEAPU8[$7 + 10 | 0] & 6) {
      break label$144;
     }
     $8 = HEAPU16[$7 + 12 >> 1];
     if (HEAPU8[$29 + 44 | 0] & 88 | (!($8 & 130) | !($8 & 2048) | HEAP32[$7 + 20 >> 2] != ($19 | 0))) {
      break label$144;
     }
     $3 = HEAP32[$7 >> 2];
     $15 = $6;
     $8 = sqlite3WhereFindTerm($34, $19, HEAP32[$7 + 24 >> 2], $5, $15, 131, 0);
     if (!$8 | HEAPU8[$8 + 10 | 0] & 4) {
      break label$144;
     }
     $13 = HEAP32[$8 >> 2];
     if (!(!(HEAP8[$8 + 12 | 0] & 1) | !(HEAPU8[$13 + 5 | 0] & 16)) & HEAP32[HEAP32[HEAP32[$13 + 20 >> 2] + 28 >> 2] >> 2] > 1) {
      break label$144;
     }
     __memcpy($26 + 8 | 0, $13, 52);
     HEAP32[$26 + 20 >> 2] = HEAP32[$3 + 12 >> 2];
     sqlite3ExprIfFalse($0, $26 + 8 | 0, $32, 16);
     HEAP16[$8 + 10 >> 1] = HEAPU16[$8 + 10 >> 1] | 4;
    }
    $7 = $7 + 48 | 0;
    $9 = $9 - 1 | 0;
    continue;
   }
   break;
  }
  $11 = HEAP32[$4 + 56 >> 2];
  if ($11) {
   $3 = HEAP32[(HEAP32[$2 + 4 >> 2] + (HEAPU8[$4 + 60 | 0] << 6) | 0) + 24 >> 2];
   label$147: {
    if (!(HEAPU8[$3 + 28 | 0] & 128)) {
     $9 = 1;
     $8 = sqlite3GetTempRange($0, 2);
     $7 = $8 + 1 | 0;
     sqlite3ExprCodeGetColumnOfTable($1, $3, HEAP32[$4 + 4 >> 2], -1, $7);
     break label$147;
    }
    $7 = 0;
    $13 = sqlite3PrimaryKeyIndex($3);
    $9 = HEAPU16[$13 + 50 >> 1];
    $8 = sqlite3GetTempRange($0, $9 + 1 | 0);
    while (1) {
     if (($7 | 0) != ($9 | 0)) {
      $5 = HEAP16[HEAP32[$13 + 4 >> 2] + ($7 << 1) >> 1];
      $7 = $7 + 1 | 0;
      sqlite3ExprCodeGetColumnOfTable($1, $3, $19, $5, $8 + $7 | 0);
      continue;
     }
     break;
    }
    $7 = $8 + 1 | 0;
   }
   $3 = sqlite3VdbeAddOp4Int($1, 28, HEAP32[$11 >> 2], 0, $7, $9);
   sqlite3VdbeAddOp3($1, 97, $7, $9, $8);
   sqlite3VdbeAddOp4Int($1, 138, HEAP32[$11 >> 2], $8, $7, $9);
   sqlite3VdbeAddOp4Int($1, 180, HEAP32[$11 + 4 >> 2], 0, $7, $9);
   sqlite3VdbeChangeP5($1, 16);
   sqlite3VdbeJumpHere($1, $3);
   sqlite3ReleaseTempRange($0, $8, $9 + 1 | 0);
  }
  label$151: {
   $7 = HEAP32[$4 >> 2];
   label$152: {
    label$153: {
     if ($7) {
      HEAP32[$4 + 28 >> 2] = sqlite3VdbeCurrentAddr($1);
      sqlite3VdbeAddOp2($1, 71, 1, $7);
      $7 = HEAP32[$4 + 56 >> 2];
      if ($7) {
       break label$153;
      }
      break label$152;
     }
     $7 = HEAP32[$4 + 56 >> 2];
     if (!$7) {
      break label$151;
     }
    }
    sqlite3VdbeAddOp2($1, 74, 0, HEAP32[$7 + 8 >> 2]);
    HEAP32[$7 + 12 >> 2] = sqlite3VdbeCurrentAddr($1);
    HEAP8[$0 + 26 | 0] = HEAPU8[$0 + 26 | 0] + 1;
   }
   $7 = HEAP32[$2 + 112 >> 2];
   $9 = 0;
   while (1) {
    if (HEAP32[$2 + 108 >> 2] <= ($9 | 0)) {
     break label$151;
    }
    label$156: {
     if (HEAPU8[$7 + 10 | 0] & 6) {
      break label$156;
     }
     $15 = HEAP32[$4 + 88 >> 2];
     $16 = $15;
     $10 = HEAP32[$4 + 92 >> 2];
     $1 = $10;
     $10 = HEAP32[$7 + 40 >> 2];
     $17 = $10;
     $15 = HEAP32[$7 + 44 >> 2];
     $10 = $15;
     $15 = $1;
     $10 = $10 & $15;
     $15 = $16 & $17;
     if (HEAPU8[$29 + 44 | 0] & 64 | ($10 | $15)) {
      break label$156;
     }
     sqlite3ExprIfFalse($0, HEAP32[$7 >> 2], $32, 16);
     HEAP16[$7 + 10 >> 1] = HEAPU16[$7 + 10 >> 1] | 4;
    }
    $7 = $7 + 48 | 0;
    $9 = $9 + 1 | 0;
    continue;
   }
  }
  $15 = HEAP32[$4 + 88 >> 2];
  $5 = $15;
  $10 = HEAP32[$4 + 92 >> 2];
  $6 = $10;
  $17 = $4;
 }
 __stack_pointer = $26 - -64 | 0;
 $10 = $6;
 i64toi32_i32$HIGH_BITS = $10;
 $15 = $5;
 return $15;
}

function __divtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0;
 $15 = __stack_pointer - 336 | 0;
 __stack_pointer = $15;
 $12 = $7;
 $20 = $12;
 $10 = $8;
 $9 = $10 & 65535;
 $18 = $9;
 $10 = $3;
 $30 = $10;
 $9 = $4;
 $12 = $9 & 65535;
 $27 = $12;
 $12 = $9;
 $9 = $10;
 $10 = $8;
 $10 = $12 ^ $10;
 $13 = $7;
 $9 = $10 & -2147483648;
 $23 = $9;
 $9 = $8;
 $25 = $9 >>> 16 & 32767;
 $12 = $4;
 $22 = $12 >>> 16 & 32767;
 label$1: {
  label$2: {
   if ($25 - 32767 >>> 0 > 4294934529 & $22 - 32767 >>> 0 >= 4294934530) {
    break label$2;
   }
   $10 = $2;
   $11 = !($10 | $1);
   $10 = $4;
   $9 = $10 & 2147483647;
   $16 = $9;
   $14 = $9 >>> 0 < 2147418112;
   $10 = $9;
   $12 = $3;
   $17 = $12;
   $13 = $12;
   if (!(!$13 & ($10 | 0) == 2147418112 ? $11 : $14)) {
    $12 = $3;
    $21 = $12;
    $13 = $4;
    $10 = $13 | 32768;
    $23 = $10;
    break label$1;
   }
   $10 = $6;
   $11 = !($10 | $5);
   $10 = $8;
   $12 = $10 & 2147483647;
   $4 = $12;
   $14 = $12 >>> 0 < 2147418112;
   $10 = $12;
   $13 = $7;
   $3 = $13;
   $9 = $13;
   if (!(!$9 & ($10 | 0) == 2147418112 ? $11 : $14)) {
    $13 = $7;
    $21 = $13;
    $9 = $8;
    $10 = $9 | 32768;
    $23 = $10;
    $1 = $5;
    $10 = $6;
    $2 = $10;
    break label$1;
   }
   $10 = $16;
   $13 = $10 ^ 2147418112;
   $10 = $1;
   $9 = $17;
   $12 = $9;
   $9 = $13;
   $13 = $2;
   $9 = $9 | $13;
   if (!($10 | $12 | $9)) {
    $9 = $4;
    $10 = $9 ^ 2147418112;
    $1 = $10;
    $9 = $5;
    $13 = $3;
    $12 = $13;
    $10 = $6;
    $13 = $1;
    $13 = $10 | $13;
    if (!($9 | $12 | $13)) {
     $1 = 0;
     $2 = 0;
     $23 = 2147450880;
     break label$1;
    }
    $10 = $21;
    $21 = $10;
    $13 = $23;
    $9 = $13 | 2147418112;
    $23 = $9;
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $9 = $4;
   $10 = $9 ^ 2147418112;
   $7 = $10;
   $9 = $5;
   $13 = $3;
   $12 = $13;
   $10 = $6;
   $13 = $7;
   $13 = $10 | $13;
   if (!($9 | $12 | $13)) {
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $9 = $16;
   $13 = $2;
   $9 = $9 | $13;
   $10 = $1;
   $12 = $17;
   if (!($9 | ($10 | $12))) {
    $10 = $6;
    $9 = $4;
    $10 = $10 | $9;
    $12 = $5;
    $13 = $3;
    $11 = !($10 | ($12 | $13));
    $12 = $11 ? 0 : $21;
    $21 = $12;
    $13 = $23;
    $9 = $11 ? 2147450880 : $13;
    $23 = $9;
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $9 = $4;
   $12 = $6;
   $12 = $9 | $12;
   $10 = $5;
   $11 = $3;
   if (!($12 | ($10 | $11))) {
    $9 = $21;
    $21 = $9;
    $12 = $23;
    $11 = $12 | 2147418112;
    $23 = $11;
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $11 = $16;
   if (($11 | 0) == 65535 | $11 >>> 0 < 65535) {
    $12 = $27;
    $19 = !($12 | $30);
    $13 = $19;
    $9 = $13 ? $1 : $30;
    $12 = $2;
    $11 = $27;
    $10 = $13 ? $12 : $11;
    $12 = Math_clz32($10);
    $9 = ($12 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $12;
    $12 = $19 << 6;
    $11 = $9 + $12 | 0;
    $14 = $2;
    $9 = $27;
    __ashlti3($15 + 320 | 0, $1, $14, $30, $9, $11 - 15 | 0);
    $19 = 16 - $11 | 0;
    $13 = $15;
    $9 = HEAP32[$13 + 328 >> 2];
    $30 = $9;
    $14 = HEAP32[$13 + 332 >> 2];
    $27 = $14;
    $9 = HEAP32[$13 + 324 >> 2];
    $2 = $9;
    $14 = HEAP32[$13 + 320 >> 2];
    $1 = $14;
   }
   $9 = $4;
   if ($9 >>> 0 > 65535) {
    break label$2;
   }
   $13 = $18;
   $10 = !($13 | $20);
   $14 = $10 ? $5 : $20;
   $13 = $6;
   $9 = $18;
   $12 = $10 ? $13 : $9;
   $13 = Math_clz32($12);
   $14 = ($13 | 0) == 32 ? Math_clz32($14) + 32 | 0 : $13;
   $11 = 0;
   $13 = $10 << 6;
   $9 = $13 + $14 | 0;
   $11 = $6;
   $14 = $18;
   __ashlti3($15 + 304 | 0, $5, $11, $20, $14, $9 - 15 | 0);
   $19 = ($19 + $9 | 0) - 16 | 0;
   $10 = $15;
   $14 = HEAP32[$10 + 312 >> 2];
   $20 = $14;
   $11 = HEAP32[$10 + 316 >> 2];
   $18 = $11;
   $11 = HEAP32[$10 + 304 >> 2];
   $5 = $11;
   $14 = HEAP32[$10 + 308 >> 2];
   $6 = $14;
  }
  $14 = $18;
  $11 = $14 | 65536;
  $34 = $11;
  $10 = $20;
  $32 = $10;
  $14 = $10;
  $10 = $11 << 15 | $10 >>> 17;
  $4 = $10;
  $10 = $6;
  $13 = $10 >>> 17 | 0;
  $10 = $14 << 15;
  $3 = $10 | $13;
  $13 = $3;
  $12 = 0 - $13 | 0;
  $7 = $12;
  $14 = 0;
  $11 = $14;
  $14 = $4;
  $11 = $11 | $14;
  $4 = $11;
  $10 = $11;
  $9 = $10 + (($13 | 0) != 0) | 0;
  $9 = 1963258675 - $9 | 0;
  $8 = $9;
  __multi3($15 + 288 | 0, $13, $10, 0, 0, $12, $9, 0, 0);
  $14 = $15;
  $13 = HEAP32[$14 + 296 >> 2];
  $9 = $13;
  $10 = 0 - $9 | 0;
  $11 = HEAP32[$14 + 300 >> 2];
  $12 = $11 + (($9 | 0) != 0) | 0;
  $12 = 0 - $12 | 0;
  $11 = $8;
  __multi3($14 + 272 | 0, $10, $12, 0, 0, $7, $11, 0, 0);
  $10 = $14 + 256 | 0;
  $11 = HEAP32[$14 + 284 >> 2];
  $9 = HEAP32[$14 + 280 >> 2];
  $7 = $9 << 1;
  $9 = $11 << 1 | $9 >>> 31;
  $8 = $9;
  $11 = $15;
  $9 = HEAP32[$11 + 272 >> 2];
  $14 = HEAP32[$11 + 276 >> 2];
  $9 = 0;
  $11 = $9;
  $12 = $14 >>> 31 | 0;
  $14 = $7;
  $7 = $12 | $14;
  $9 = $8;
  $11 = $9 | $11;
  $8 = $11;
  $9 = $4;
  __multi3($10, $7, $11, 0, 0, $3, $9, 0, 0);
  $14 = $15;
  $12 = HEAP32[$14 + 264 >> 2];
  $11 = $12;
  $13 = 0 - $11 | 0;
  $9 = HEAP32[$14 + 268 >> 2];
  $10 = $9 + (($11 | 0) != 0) | 0;
  $10 = 0 - $10 | 0;
  $9 = $10;
  $10 = $8;
  __multi3($14 + 240 | 0, $7, $10, 0, 0, $13, $9, 0, 0);
  $12 = $14 + 224 | 0;
  $9 = HEAP32[$14 + 252 >> 2];
  $11 = HEAP32[$14 + 248 >> 2];
  $7 = $11 << 1;
  $11 = $9 << 1 | $11 >>> 31;
  $8 = $11;
  $9 = $15;
  $11 = HEAP32[$9 + 240 >> 2];
  $14 = HEAP32[$9 + 244 >> 2];
  $10 = $14 >>> 31 | 0;
  $14 = $7;
  $7 = $10 | $14;
  $11 = 0;
  $9 = $11;
  $11 = $8;
  $9 = $9 | $11;
  $8 = $9;
  $11 = $4;
  __multi3($12, $7, $9, 0, 0, $3, $11, 0, 0);
  $14 = $15;
  $10 = HEAP32[$14 + 232 >> 2];
  $9 = $10;
  $12 = 0 - $9 | 0;
  $11 = HEAP32[$14 + 236 >> 2];
  $10 = $11;
  $13 = $10 + (($9 | 0) != 0) | 0;
  $13 = 0 - $13 | 0;
  $11 = $13;
  $13 = $8;
  __multi3($14 + 208 | 0, $7, $13, 0, 0, $12, $11, 0, 0);
  $10 = $14 + 192 | 0;
  $11 = HEAP32[$14 + 220 >> 2];
  $9 = HEAP32[$14 + 216 >> 2];
  $7 = $9 << 1;
  $9 = $11 << 1 | $9 >>> 31;
  $8 = $9;
  $11 = $15;
  $9 = HEAP32[$11 + 208 >> 2];
  $14 = HEAP32[$11 + 212 >> 2];
  $9 = 0;
  $11 = $9;
  $13 = $14 >>> 31 | 0;
  $14 = $7;
  $7 = $13 | $14;
  $9 = $8;
  $11 = $9 | $11;
  $8 = $11;
  $9 = $4;
  __multi3($10, $7, $11, 0, 0, $3, $9, 0, 0);
  $14 = $15;
  $13 = HEAP32[$14 + 200 >> 2];
  $11 = $13;
  $10 = 0 - $11 | 0;
  $9 = HEAP32[$14 + 204 >> 2];
  $12 = $9 + (($11 | 0) != 0) | 0;
  $12 = 0 - $12 | 0;
  $9 = $12;
  $12 = $8;
  __multi3($14 + 176 | 0, $7, $12, 0, 0, $10, $9, 0, 0);
  $16 = $14 + 160 | 0;
  $9 = HEAP32[$14 + 188 >> 2];
  $11 = HEAP32[$14 + 184 >> 2];
  $8 = $11 << 1;
  $11 = $9 << 1 | $11 >>> 31;
  $7 = $11;
  $9 = $15;
  $11 = HEAP32[$9 + 176 >> 2];
  $14 = HEAP32[$9 + 180 >> 2];
  $11 = 0;
  $9 = $11;
  $11 = $7;
  $9 = $9 | $11;
  $12 = $14 >>> 31 | 0;
  $14 = $8;
  $11 = $12 | $14;
  $13 = $11 - 1 | 0;
  $7 = $13;
  $10 = !$11;
  $10 = $9 - $10 | 0;
  $8 = $10;
  $10 = $4;
  $9 = $8;
  __multi3($16, $3, $10, 0, 0, $13, $9, 0, 0);
  $11 = $5;
  $12 = $6;
  $9 = $12 << 15 | $11 >>> 17;
  $12 = $8;
  __multi3($15 + 144 | 0, $11 << 15, $9, 0, 0, $13, $12, 0, 0);
  $11 = $15;
  $10 = HEAP32[$11 + 168 >> 2];
  $16 = $10;
  $12 = HEAP32[$11 + 172 >> 2];
  $17 = $12;
  $12 = HEAP32[$11 + 160 >> 2];
  $20 = $12;
  $10 = HEAP32[$11 + 164 >> 2];
  $18 = $10;
  $12 = HEAP32[$11 + 156 >> 2];
  $10 = HEAP32[$11 + 152 >> 2];
  $9 = $10;
  $11 = $20;
  $14 = $9 + $11 | 0;
  $10 = $12;
  $12 = $18;
  $13 = $10 + $12 | 0;
  $3 = $14;
  $13 = $9 >>> 0 > $14 >>> 0 ? $13 + 1 | 0 : $13;
  $4 = $13;
  $11 = $12;
  $9 = $20;
  $12 = $14;
  $11 = ($13 | 0) == ($11 | 0) & $9 >>> 0 > $12 >>> 0 | $11 >>> 0 > $13 >>> 0;
  $12 = $17;
  $9 = $16;
  $10 = $9 + $11 | 0;
  $14 = $10 >>> 0 < $11 >>> 0 ? $12 + 1 | 0 : $12;
  $11 = $14;
  $14 = $4;
  $12 = $3;
  $9 = !$14 & $12 >>> 0 > 1 | ($14 | 0) != 0;
  $13 = $9 + $10 | 0;
  $12 = $11;
  $10 = $12;
  $10 = $9 >>> 0 > $13 >>> 0 ? $10 + 1 | 0 : $10;
  $9 = $13;
  $14 = 0 - $9 | 0;
  $13 = $10 + (($9 | 0) != 0) | 0;
  $13 = 0 - $13 | 0;
  $10 = $13;
  $13 = $8;
  __multi3($15 + 112 | 0, $7, $13, 0, 0, $14, $10, 0, 0);
  $13 = $3;
  $11 = 1 - $13 | 0;
  $10 = $4;
  $14 = $10 + ($13 >>> 0 > 1) | 0;
  $14 = 0 - $14 | 0;
  $9 = $8;
  __multi3($15 + 128 | 0, $11, $14, 0, 0, $7, $9, 0, 0);
  $25 = ($22 - $25 | 0) + $19 | 0;
  $12 = $15;
  $13 = HEAP32[$12 + 112 >> 2];
  $9 = HEAP32[$12 + 116 >> 2];
  $19 = $9;
  $12 = $13;
  $13 = $9 << 1 | $12 >>> 31;
  $28 = $12 << 1;
  $22 = $13;
  $9 = $15;
  $13 = HEAP32[$9 + 136 >> 2];
  $12 = HEAP32[$9 + 140 >> 2];
  $31 = $12;
  $9 = $13;
  $13 = $12 << 1 | $9 >>> 31;
  $4 = $9 << 1;
  $3 = $13;
  $12 = $15;
  $13 = HEAP32[$12 + 128 >> 2];
  $9 = HEAP32[$12 + 132 >> 2];
  $14 = $9 >>> 31 | 0;
  $13 = 0;
  $12 = $13;
  $13 = $3;
  $12 = $12 | $13;
  $13 = $28;
  $9 = $4;
  $14 = $9 | $14;
  $10 = $13 + $14 | 0;
  $9 = $12;
  $12 = $22;
  $11 = $9 + $12 | 0;
  $17 = $10;
  $11 = $10 >>> 0 < $14 >>> 0 ? $11 + 1 | 0 : $11;
  $16 = $11;
  $9 = $10 - 13927 | 0;
  $35 = $9;
  $10 = $10 >>> 0 < 13927;
  $10 = $11 - $10 | 0;
  $3 = $10;
  $12 = 0;
  $4 = $12;
  $12 = $27;
  $11 = $12 | 65536;
  $41 = $11;
  $10 = $30;
  $42 = $10;
  $45 = $10 << 1;
  $10 = $11 << 1 | $10 >>> 31;
  $46 = $10;
  $12 = 0;
  $8 = $12;
  $7 = $10;
  $11 = $12;
  $11 = __wasm_i64_mul($3, $21, $10, $11);
  $24 = $11;
  $12 = i64toi32_i32$HIGH_BITS;
  $26 = $12;
  $10 = $1;
  $38 = $10 << 1;
  $12 = $2;
  $11 = $12 << 1 | $10 >>> 31;
  $43 = $11;
  $10 = 0;
  $18 = $10;
  $20 = $11;
  $10 = $16;
  $12 = $3;
  $11 = $17;
  $16 = ($10 | 0) == ($12 | 0) & $11 >>> 0 > $9 >>> 0 | $10 >>> 0 > $12 >>> 0;
  $11 = $10;
  $14 = $17;
  $10 = $22;
  $12 = $13;
  $17 = ($11 | 0) == ($10 | 0) & $14 >>> 0 < $12 >>> 0 | $10 >>> 0 > $11 >>> 0;
  $12 = $15;
  $14 = HEAP32[$12 + 120 >> 2];
  $11 = HEAP32[$12 + 124 >> 2];
  $12 = $14;
  $13 = $12 << 1;
  $14 = $11 << 1 | $12 >>> 31;
  $9 = $14;
  $12 = 0;
  $11 = $12;
  $14 = $19;
  $10 = $14 >>> 31 | 0;
  $14 = $13;
  $13 = $10 | $14;
  $12 = $9;
  $11 = $12 | $11;
  $14 = 0;
  $12 = $14;
  $9 = $12 + $11 | 0;
  $11 = $31;
  $10 = $11 >>> 31 | 0;
  $11 = $13;
  $13 = $10 + $11 | 0;
  $9 = $10 >>> 0 > $13 >>> 0 ? $9 + 1 | 0 : $9;
  $11 = $9;
  $10 = $13;
  $14 = $17;
  $12 = $10 + $14 | 0;
  $9 = $12;
  $13 = $10 >>> 0 > $12 >>> 0 ? $11 + 1 | 0 : $11;
  $12 = $13;
  $10 = $9;
  $9 = $16;
  $11 = $10 + $9 | 0;
  $14 = $11 - 1 | 0;
  $29 = $14;
  $12 = $10 >>> 0 > $11 >>> 0 ? $12 + 1 | 0 : $12;
  $11 = !$11;
  $11 = $12 - $11 | 0;
  $13 = 0;
  $16 = $13;
  $17 = $11;
  $12 = $13;
  $12 = __wasm_i64_mul($20, $21, $11, $12);
  $10 = $12;
  $11 = $24;
  $9 = $10 + $11 | 0;
  $13 = i64toi32_i32$HIGH_BITS;
  $12 = $13;
  $13 = $26;
  $14 = $12 + $13 | 0;
  $28 = $9;
  $11 = $13;
  $14 = $9 >>> 0 < $10 >>> 0 ? $14 + 1 | 0 : $14;
  $22 = $14;
  $10 = $24;
  $26 = ($11 | 0) == ($14 | 0) & $10 >>> 0 > $9 >>> 0 | $11 >>> 0 > $14 >>> 0;
  $10 = $29;
  $29 = $10;
  $14 = 0;
  $19 = $14;
  $14 = $2;
  $44 = $14 >>> 31 | 0;
  $10 = 0;
  $18 = $10;
  $14 = $30;
  $11 = $14 << 1;
  $10 = $27;
  $13 = $10 << 1 | $14 >>> 31;
  $14 = $13;
  $13 = $21;
  $10 = $44;
  $13 = $10 | $11;
  $30 = $13;
  $10 = 0;
  $27 = $10;
  $13 = __wasm_i64_mul($29, $21, $30, $10);
  $11 = $13;
  $10 = i64toi32_i32$HIGH_BITS;
  $13 = $10;
  $10 = $22;
  $9 = $10 + $13 | 0;
  $14 = $28;
  $12 = $11 + $14 | 0;
  $9 = $12 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
  $33 = $12;
  $31 = $9;
  $14 = $10;
  $10 = $12;
  $11 = $28;
  $14 = ($9 | 0) == ($14 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 < $14 >>> 0;
  $12 = 0;
  $11 = $26;
  $13 = $11 + $14 | 0;
  $12 = $13 >>> 0 < $14 >>> 0 ? 1 : $12;
  $10 = $13;
  $9 = $12;
  $12 = $8;
  $11 = $16;
  $11 = __wasm_i64_mul($7, $12, $17, $11);
  $14 = $11;
  $12 = i64toi32_i32$HIGH_BITS;
  $11 = $12;
  $12 = $9;
  $13 = $12 + $11 | 0;
  $9 = $10 + $14 | 0;
  $13 = $9 >>> 0 < $14 >>> 0 ? $13 + 1 | 0 : $13;
  $36 = $9;
  $37 = $13;
  $13 = $8;
  $10 = $19;
  $10 = __wasm_i64_mul($7, $13, $29, $10);
  $24 = $10;
  $13 = i64toi32_i32$HIGH_BITS;
  $26 = $13;
  $13 = $16;
  $10 = $27;
  $10 = __wasm_i64_mul($17, $13, $30, $10);
  $14 = $10;
  $13 = i64toi32_i32$HIGH_BITS;
  $10 = $13;
  $13 = $26;
  $9 = $10 + $13 | 0;
  $12 = $24;
  $11 = $12 + $14 | 0;
  $9 = $11 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
  $28 = $11;
  $22 = $9;
  $12 = $13;
  $14 = $24;
  $14 = ($9 | 0) == ($12 | 0) & $11 >>> 0 < $14 >>> 0 | $9 >>> 0 < $12 >>> 0;
  $9 = $14;
  $14 = 0;
  $13 = $14;
  $14 = $9;
  $13 = $13 | $14;
  $9 = 0;
  $12 = $22;
  $12 = $9 | $12;
  $14 = $36;
  $10 = $12 + $14 | 0;
  $9 = $13;
  $13 = $37;
  $11 = $9 + $13 | 0;
  $26 = $10;
  $11 = $10 >>> 0 < $12 >>> 0 ? $11 + 1 | 0 : $11;
  $24 = $11;
  $13 = $28;
  $11 = $31;
  $14 = $11;
  $10 = $13 + $11 | 0;
  $12 = 0;
  $11 = $33;
  $9 = $12 + $11 | 0;
  $10 = $9 >>> 0 < $12 >>> 0 ? $10 + 1 | 0 : $10;
  $28 = $9;
  $22 = $10;
  $11 = $14;
  $12 = $33;
  $11 = ($10 | 0) == ($11 | 0) & $12 >>> 0 > $9 >>> 0 | $10 >>> 0 < $11 >>> 0;
  $14 = $24;
  $9 = $14;
  $12 = $26;
  $13 = $12 + $11 | 0;
  $9 = $13 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
  $39 = $13;
  $40 = $9;
  $9 = $3;
  $14 = $35;
  $35 = $14;
  $12 = 0;
  $18 = $12;
  $14 = $27;
  $14 = __wasm_i64_mul($35, $12, $30, $14);
  $24 = $14;
  $12 = i64toi32_i32$HIGH_BITS;
  $26 = $12;
  $12 = $4;
  $14 = $18;
  $14 = __wasm_i64_mul($9, $12, $20, $14);
  $11 = $14;
  $12 = i64toi32_i32$HIGH_BITS;
  $14 = $12;
  $12 = $26;
  $13 = $12 + $14 | 0;
  $9 = $24;
  $10 = $9 + $11 | 0;
  $13 = $10 >>> 0 < $11 >>> 0 ? $13 + 1 | 0 : $13;
  $33 = $10;
  $9 = $12;
  $31 = $13;
  $12 = $10;
  $11 = $24;
  $47 = ($9 | 0) == ($13 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 > $13 >>> 0;
  $13 = 0;
  $26 = $13;
  $13 = $19;
  $11 = $38;
  $24 = $11 & -2;
  $11 = $26;
  $11 = __wasm_i64_mul($29, $13, $24, $11);
  $9 = $11;
  $13 = i64toi32_i32$HIGH_BITS;
  $11 = $13;
  $13 = $31;
  $10 = $13 + $11 | 0;
  $14 = $12 + $9 | 0;
  $36 = $14;
  $10 = $9 >>> 0 > $14 >>> 0 ? $10 + 1 | 0 : $10;
  $37 = $10;
  $12 = $13;
  $9 = $33;
  $13 = $14;
  $12 = ($10 | 0) == ($12 | 0) & $9 >>> 0 > $13 >>> 0 | $10 >>> 0 < $12 >>> 0;
  $14 = 0;
  $9 = $47;
  $11 = $9 + $12 | 0;
  $10 = $11;
  $14 = $11 >>> 0 < $12 >>> 0 ? 1 : $14;
  $9 = $14;
  $14 = $22;
  $11 = $9 + $14 | 0;
  $12 = $10;
  $13 = $28;
  $10 = $12 + $13 | 0;
  $11 = $10 >>> 0 < $12 >>> 0 ? $11 + 1 | 0 : $11;
  $33 = $10;
  $13 = $14;
  $31 = $11;
  $12 = $28;
  $13 = ($13 | 0) == ($11 | 0) & $12 >>> 0 > $10 >>> 0 | $11 >>> 0 < $13 >>> 0;
  $14 = $40;
  $10 = $14;
  $12 = $39;
  $9 = $12 + $13 | 0;
  $10 = $9 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
  $39 = $9;
  $40 = $10;
  $10 = $8;
  $12 = $18;
  $12 = __wasm_i64_mul($7, $10, $35, $12);
  $28 = $12;
  $10 = i64toi32_i32$HIGH_BITS;
  $22 = $10;
  $10 = $16;
  $12 = $26;
  $12 = __wasm_i64_mul($17, $10, $24, $12);
  $13 = $12;
  $10 = i64toi32_i32$HIGH_BITS;
  $12 = $10;
  $10 = $22;
  $9 = $10 + $12 | 0;
  $14 = $28;
  $11 = $13 + $14 | 0;
  $7 = $11;
  $9 = $11 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
  $8 = $9;
  $9 = $4;
  $14 = $27;
  $14 = __wasm_i64_mul($3, $9, $30, $14);
  $13 = $14;
  $9 = i64toi32_i32$HIGH_BITS;
  $14 = $9;
  $9 = $8;
  $11 = $9 + $14 | 0;
  $10 = $7;
  $12 = $10 + $13 | 0;
  $11 = $12 >>> 0 < $13 >>> 0 ? $11 + 1 | 0 : $11;
  $17 = $12;
  $16 = $11;
  $9 = $12;
  $11 = $18;
  $10 = $19;
  $10 = __wasm_i64_mul($20, $11, $29, $10);
  $13 = $10;
  $14 = $9 + $10 | 0;
  $11 = i64toi32_i32$HIGH_BITS;
  $10 = $11;
  $11 = $16;
  $12 = $10 + $11 | 0;
  $29 = $14;
  $12 = $13 >>> 0 > $14 >>> 0 ? $12 + 1 | 0 : $12;
  $9 = 0;
  $4 = $9;
  $9 = $11;
  $19 = $12;
  $11 = $12;
  $12 = $17;
  $13 = $14;
  $27 = ($9 | 0) == ($11 | 0) & $12 >>> 0 > $13 >>> 0 | $9 >>> 0 > $11 >>> 0;
  $9 = $22;
  $12 = $8;
  $13 = $7;
  $11 = $28;
  $8 = ($9 | 0) == ($12 | 0) & $13 >>> 0 < $11 >>> 0 | $9 >>> 0 > $12 >>> 0;
  $13 = $12;
  $11 = $7;
  $12 = $16;
  $9 = $17;
  $12 = ($13 | 0) == ($12 | 0) & $11 >>> 0 > $9 >>> 0 | $12 >>> 0 < $13 >>> 0;
  $14 = 0;
  $9 = $8;
  $10 = $9 + $12 | 0;
  $14 = $10 >>> 0 < $12 >>> 0 ? 1 : $14;
  $9 = $14;
  $11 = $27;
  $13 = $10 + $11 | 0;
  $11 = $4;
  $14 = $11 | $13;
  $10 = $19;
  $12 = $21;
  $12 = $10 | $12;
  $11 = $33;
  $9 = $12 + $11 | 0;
  $10 = $14;
  $14 = $31;
  $13 = $10 + $14 | 0;
  $7 = $9;
  $13 = $9 >>> 0 < $12 >>> 0 ? $13 + 1 | 0 : $13;
  $8 = $13;
  $11 = $14;
  $12 = $33;
  $11 = ($13 | 0) == ($11 | 0) & $12 >>> 0 > $9 >>> 0 | $11 >>> 0 > $13 >>> 0;
  $14 = $40;
  $9 = $14;
  $12 = $39;
  $10 = $12 + $11 | 0;
  $9 = $10 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
  $16 = $10;
  $17 = $9;
  $9 = $4;
  $12 = $26;
  $12 = __wasm_i64_mul($3, $9, $24, $12);
  $3 = $12;
  $9 = i64toi32_i32$HIGH_BITS;
  $4 = $9;
  $9 = $18;
  $12 = $18;
  $12 = __wasm_i64_mul($20, $9, $35, $12);
  $11 = $12;
  $9 = i64toi32_i32$HIGH_BITS;
  $12 = $9;
  $9 = $4;
  $10 = $9 + $12 | 0;
  $14 = $3;
  $13 = $11 + $14 | 0;
  $10 = $13 >>> 0 < $11 >>> 0 ? $10 + 1 | 0 : $10;
  $14 = 0;
  $12 = $14;
  $9 = $10;
  $14 = $4;
  $10 = $3;
  $11 = $13;
  $11 = ($9 | 0) == ($14 | 0) & $10 >>> 0 > $11 >>> 0 | $9 >>> 0 < $14 >>> 0;
  $14 = $12;
  $11 = $11 | $14;
  $10 = $9;
  $9 = 0;
  $9 = $10 | $9;
  $14 = $36;
  $12 = $9 + $14 | 0;
  $10 = $11;
  $11 = $37;
  $13 = $10 + $11 | 0;
  $3 = $12;
  $13 = $9 >>> 0 > $12 >>> 0 ? $13 + 1 | 0 : $13;
  $4 = $13;
  $14 = $11;
  $9 = $36;
  $11 = $12;
  $19 = ($13 | 0) == ($14 | 0) & $9 >>> 0 > $11 >>> 0 | $13 >>> 0 < $14 >>> 0;
  $9 = $29;
  $13 = $4;
  $12 = $9 + $13 | 0;
  $14 = 0;
  $10 = $14 + $11 | 0;
  $12 = $10 >>> 0 < $14 >>> 0 ? $12 + 1 | 0 : $12;
  $11 = $13;
  $14 = $3;
  $11 = ($11 | 0) == ($12 | 0) & $10 >>> 0 < $14 >>> 0 | $11 >>> 0 > $12 >>> 0;
  $10 = 0;
  $14 = $19;
  $9 = $11 + $14 | 0;
  $10 = $9 >>> 0 < $11 >>> 0 ? 1 : $10;
  $11 = $9;
  $14 = $10;
  $10 = $8;
  $9 = $10 + $14 | 0;
  $13 = $7;
  $12 = $13 + $11 | 0;
  $9 = $12 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
  $3 = $12;
  $4 = $9;
  $13 = $10;
  $10 = $12;
  $11 = $7;
  $13 = ($9 | 0) == ($13 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 < $13 >>> 0;
  $10 = $17;
  $11 = $16;
  $14 = $13 + $11 | 0;
  $7 = $14;
  $12 = $13 >>> 0 > $14 >>> 0 ? $10 + 1 | 0 : $10;
  $8 = $12;
  label$12: {
   if (($12 | 0) == 131071 | $12 >>> 0 < 131071) {
    $13 = $45;
    $11 = $44;
    $42 = $13 | $11;
    $10 = $46;
    $12 = $18;
    $12 = $10 | $12;
    $41 = $12;
    $12 = $4;
    $13 = $8;
    $10 = $6;
    $11 = $34;
    __multi3($15 + 80 | 0, $3, $12, $7, $13, $5, $10, $32, $11);
    $13 = $1;
    $10 = $13 << 17;
    $1 = $10;
    $11 = $15;
    $10 = HEAP32[$11 + 88 >> 2];
    $13 = HEAP32[$11 + 92 >> 2];
    $2 = $13;
    $11 = 0;
    $12 = $10;
    $9 = $11 - $10 | 0;
    $13 = $1;
    $10 = $2;
    $14 = $10 + ($11 >>> 0 < $12 >>> 0) | 0;
    $14 = $13 - $14 | 0;
    $12 = $14;
    $13 = $15;
    $14 = HEAP32[$13 + 80 >> 2];
    $1 = $14;
    $11 = HEAP32[$13 + 84 >> 2];
    $2 = $11;
    $13 = $14;
    $14 = ($11 | $13) != 0;
    $10 = $9 - $14 | 0;
    $17 = $10;
    $13 = $12;
    $9 = $9 >>> 0 < $14 >>> 0;
    $9 = $13 - $9 | 0;
    $16 = $9;
    $25 = $25 + 16382 | 0;
    $14 = $1;
    $11 = 0 - $14 | 0;
    $20 = $11;
    $12 = $2;
    $10 = $12 + (($14 | 0) != 0) | 0;
    $10 = 0 - $10 | 0;
    $9 = 0;
    break label$12;
   }
   $9 = $7;
   $13 = $9 << 31;
   $12 = $13;
   $13 = $4;
   $9 = $13 >>> 1 | 0;
   $10 = $3;
   $14 = ($13 & 1) << 31 | $10 >>> 1;
   $10 = $9;
   $9 = $12;
   $10 = $10 | $9;
   $4 = $10;
   $13 = 0;
   $3 = $13 | $14;
   $10 = $8;
   $13 = $10 >>> 1 | 0;
   $9 = $7;
   $7 = ($10 & 1) << 31 | $9 >>> 1;
   $8 = $13;
   $13 = $4;
   $9 = $8;
   $10 = $6;
   $14 = $34;
   __multi3($15 + 96 | 0, $3, $13, $7, $9, $5, $10, $32, $14);
   $9 = $1;
   $10 = $9 << 16;
   $11 = $10;
   $14 = $15;
   $10 = HEAP32[$14 + 104 >> 2];
   $9 = HEAP32[$14 + 108 >> 2];
   $16 = $9;
   $14 = 0;
   $13 = $10;
   $12 = $14 - $10 | 0;
   $9 = $11;
   $10 = $16;
   $11 = $10 + ($13 >>> 0 > $14 >>> 0) | 0;
   $11 = $9 - $11 | 0;
   $13 = $11;
   $9 = $15;
   $11 = HEAP32[$9 + 96 >> 2];
   $20 = $11;
   $14 = HEAP32[$9 + 100 >> 2];
   $18 = $14;
   $9 = $11;
   $11 = ($14 | $9) != 0;
   $10 = $12 - $11 | 0;
   $17 = $10;
   $9 = $13;
   $12 = $11 >>> 0 > $12 >>> 0;
   $12 = $9 - $12 | 0;
   $16 = $12;
   $25 = $25 + 16383 | 0;
   $38 = $1;
   $12 = $2;
   $43 = $12;
   $11 = $20;
   $14 = 0 - $11 | 0;
   $20 = $14;
   $13 = $18;
   $10 = $13 + (($11 | 0) != 0) | 0;
   $10 = 0 - $10 | 0;
   $9 = 0;
  }
  $18 = $10;
  if (($25 | 0) >= 32767) {
   $12 = $21;
   $21 = $12;
   $10 = $23;
   $9 = $10 | 2147418112;
   $23 = $9;
   $1 = 0;
   $2 = 0;
   break label$1;
  }
  label$15: {
   if (($25 | 0) > 0) {
    $10 = $17;
    $2 = $10 << 1;
    $9 = $16;
    $12 = $9 << 1 | $10 >>> 31;
    $1 = $12;
    $12 = $18;
    $11 = $12 >>> 31 | 0;
    $10 = 0;
    $9 = $10;
    $12 = $2;
    $17 = $12 | $11;
    $10 = $1;
    $9 = $10 | $9;
    $16 = $9;
    $9 = $8;
    $12 = $9 & 65535;
    $1 = $12;
    $9 = $25;
    $10 = $9 << 16;
    $9 = $10;
    $12 = $7;
    $11 = 0;
    $29 = $12 | $11;
    $10 = $1;
    $9 = $10 | $9;
    $19 = $9;
    $10 = $20;
    $7 = $10 << 1;
    $9 = $18;
    $12 = $9 << 1 | $10 >>> 31;
    $10 = $12;
    break label$15;
   }
   if (($25 | 0) <= -113) {
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $12 = $4;
   $10 = $8;
   __lshrti3($15 - -64 | 0, $3, $12, $7, $10, 1 - $25 | 0);
   $10 = $43;
   $12 = $41;
   __ashlti3($15 + 48 | 0, $38, $10, $42, $12, $25 + 112 | 0);
   $9 = $15;
   $12 = HEAP32[$9 + 64 >> 2];
   $3 = $12;
   $10 = HEAP32[$9 + 68 >> 2];
   $4 = $10;
   $10 = HEAP32[$9 + 72 >> 2];
   $29 = $10;
   $12 = HEAP32[$9 + 76 >> 2];
   $19 = $12;
   $1 = $9 + 32 | 0;
   $12 = $6;
   $10 = $34;
   $9 = $4;
   $11 = $19;
   __multi3($1, $5, $12, $32, $10, $3, $9, $29, $11);
   $10 = $15;
   $11 = HEAP32[$10 + 56 >> 2];
   $7 = $11;
   $9 = HEAP32[$10 + 60 >> 2];
   $8 = $9;
   $11 = HEAP32[$10 + 44 >> 2];
   $9 = HEAP32[$10 + 40 >> 2];
   $10 = $9;
   $13 = $10 << 1;
   $9 = $11 << 1 | $10 >>> 31;
   $12 = $9;
   $11 = $15;
   $9 = HEAP32[$11 + 32 >> 2];
   $1 = $9;
   $10 = HEAP32[$11 + 36 >> 2];
   $2 = $10;
   $16 = $10 >>> 31 | 0;
   $9 = 0;
   $11 = $9;
   $9 = $12;
   $11 = $9 | $11;
   $14 = $11;
   $9 = $7;
   $10 = $13;
   $12 = $16;
   $12 = $10 | $12;
   $13 = $9 - $12 | 0;
   $11 = $8;
   $10 = $14;
   $14 = $10 + ($9 >>> 0 < $12 >>> 0) | 0;
   $14 = $11 - $14 | 0;
   $16 = $14;
   $11 = $15;
   $14 = HEAP32[$11 + 48 >> 2];
   $7 = $14;
   $9 = HEAP32[$11 + 52 >> 2];
   $8 = $9;
   $11 = $1;
   $1 = $11 << 1;
   $9 = $2;
   $14 = $9 << 1 | $11 >>> 31;
   $2 = $14;
   $11 = $14;
   $14 = $8;
   $9 = $7;
   $12 = $1;
   $11 = ($11 | 0) == ($14 | 0) & $9 >>> 0 < $12 >>> 0 | $11 >>> 0 > $14 >>> 0;
   $12 = $13;
   $10 = $12 - $11 | 0;
   $17 = $10;
   $9 = $16;
   $13 = $11 >>> 0 > $12 >>> 0;
   $13 = $9 - $13 | 0;
   $16 = $13;
   $9 = $7;
   $11 = $1;
   $14 = $9 - $11 | 0;
   $7 = $14;
   $13 = $8;
   $12 = $2;
   $10 = $12 + ($9 >>> 0 < $11 >>> 0) | 0;
   $10 = $13 - $10 | 0;
  }
  $8 = $10;
  $10 = $6;
  $9 = $34;
  __multi3($15 + 16 | 0, $5, $10, $32, $9, 3, 0, 0, 0);
  __multi3($15, $5, $10, $32, $9, 5, 0, 0, 0);
  $13 = $3;
  $1 = $13 & 1;
  $10 = $1;
  $11 = $7;
  $12 = $10 + $11 | 0;
  $9 = 0;
  $2 = $9;
  $13 = $8;
  $14 = $9 + $13 | 0;
  $7 = $12;
  $10 = $6;
  $14 = $11 >>> 0 > $12 >>> 0 ? $14 + 1 | 0 : $14;
  $8 = $14;
  $9 = $12;
  $11 = $5;
  $5 = ($10 | 0) == ($14 | 0) & $9 >>> 0 > $11 >>> 0 | $10 >>> 0 < $14 >>> 0;
  $9 = $2;
  $10 = $12;
  $11 = $1;
  $14 = ($14 | 0) == ($9 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 > $14 >>> 0;
  $11 = $16;
  $10 = $17;
  $13 = $10 + $14 | 0;
  $12 = $13 >>> 0 < $14 >>> 0 ? $11 + 1 | 0 : $11;
  $1 = $13;
  $10 = $34;
  $2 = $12;
  $11 = $13;
  $14 = $32;
  $6 = ($10 | 0) == ($12 | 0) & $11 >>> 0 > $14 >>> 0 | $10 >>> 0 < $12 >>> 0;
  $11 = $12;
  $12 = $10;
  $10 = $32;
  $12 = ($13 | 0) == ($10 | 0) & ($11 | 0) == ($12 | 0) ? $5 : $6;
  $14 = $4;
  $13 = $14;
  $10 = $3;
  $9 = $10 + $12 | 0;
  $13 = $9 >>> 0 < $12 >>> 0 ? $13 + 1 | 0 : $13;
  $5 = $9;
  $10 = $14;
  $6 = $13;
  $12 = $3;
  $10 = ($10 | 0) == ($13 | 0) & $12 >>> 0 > $9 >>> 0 | $10 >>> 0 > $13 >>> 0;
  $14 = $19;
  $9 = $14;
  $12 = $29;
  $11 = $10 + $12 | 0;
  $16 = $11;
  $9 = $10 >>> 0 > $11 >>> 0 ? $9 + 1 | 0 : $9;
  $18 = $9;
  $4 = $9 >>> 0 < 2147418112;
  $10 = $15;
  $14 = HEAP32[$10 + 16 >> 2];
  $12 = $14;
  $9 = HEAP32[$10 + 20 >> 2];
  $14 = $9;
  $9 = $8;
  $10 = $7;
  $13 = ($9 | 0) == ($14 | 0) & $10 >>> 0 > $12 >>> 0 | $9 >>> 0 > $14 >>> 0;
  $12 = $15;
  $10 = HEAP32[$12 + 24 >> 2];
  $3 = $10;
  $9 = HEAP32[$12 + 28 >> 2];
  $10 = $9;
  $9 = $2;
  $12 = $1;
  $14 = $3;
  $11 = ($10 | 0) == ($9 | 0) & $12 >>> 0 > $14 >>> 0 | $9 >>> 0 > $10 >>> 0;
  $12 = $9;
  $14 = $1;
  $9 = $10;
  $10 = $3;
  $9 = (($14 | 0) == ($10 | 0) & ($9 | 0) == ($12 | 0) ? $13 : $11) & $4;
  $10 = $5;
  $13 = $10 + $9 | 0;
  $3 = $13;
  $14 = $6;
  $11 = $14;
  $10 = $11;
  $11 = $9 >>> 0 > $13 >>> 0 ? $10 + 1 | 0 : $10;
  $4 = $11;
  $9 = $5;
  $10 = ($10 | 0) == ($11 | 0) & $9 >>> 0 > $13 >>> 0 | $10 >>> 0 > $11 >>> 0;
  $14 = $18;
  $13 = $14;
  $9 = $16;
  $12 = $10 + $9 | 0;
  $5 = $12;
  $13 = $10 >>> 0 > $12 >>> 0 ? $13 + 1 | 0 : $13;
  $6 = $13;
  $10 = $15;
  $14 = HEAP32[$10 >> 2];
  $9 = $14;
  $13 = HEAP32[$10 + 4 >> 2];
  $14 = $13;
  $13 = $8;
  $10 = $7;
  $8 = ($13 | 0) == ($14 | 0) & $10 >>> 0 > $9 >>> 0 | $13 >>> 0 > $14 >>> 0;
  $9 = $15;
  $10 = HEAP32[$9 + 8 >> 2];
  $7 = $10;
  $13 = HEAP32[$9 + 12 >> 2];
  $10 = $13;
  $13 = $2;
  $9 = $1;
  $14 = $7;
  $2 = ($10 | 0) == ($13 | 0) & $9 >>> 0 > $14 >>> 0 | $10 >>> 0 < $13 >>> 0;
  $9 = $13;
  $14 = $1;
  $13 = $10;
  $10 = $7;
  $13 = (($14 | 0) == ($10 | 0) & ($9 | 0) == ($13 | 0) ? $8 : $2) & $6 >>> 0 < 2147418112;
  $14 = $4;
  $12 = $14;
  $10 = $3;
  $11 = $10 + $13 | 0;
  $1 = $11;
  $10 = $12;
  $12 = $11 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
  $2 = $12;
  $13 = $3;
  $10 = ($10 | 0) == ($12 | 0) & $13 >>> 0 > $11 >>> 0 | $10 >>> 0 > $12 >>> 0;
  $13 = $5;
  $9 = $10 + $13 | 0;
  $14 = $6;
  $11 = $14;
  $11 = $9 >>> 0 < $10 >>> 0 ? $11 + 1 | 0 : $11;
  $10 = $21;
  $21 = $10 | $9;
  $13 = $23;
  $13 = $11 | $13;
  $23 = $13;
 }
 $14 = $0;
 HEAP32[$14 >> 2] = $1;
 $13 = $2;
 HEAP32[$14 + 4 >> 2] = $13;
 HEAP32[$14 + 8 >> 2] = $21;
 $13 = $23;
 HEAP32[$14 + 12 >> 2] = $13;
 __stack_pointer = $15 + 336 | 0;
}

function balance_nonroot($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0;
 $7 = __stack_pointer - 320 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 316 >> 2] = 0;
 HEAP8[$7 + 168 | 0] = 0;
 HEAP32[$7 + 164 >> 2] = 0;
 memset($7 + 32 | 0, 0, 64);
 if ($2) {
  $8 = HEAP32[$0 + 56 >> 2];
  $5 = HEAPU16[$0 + 24 >> 1];
  $6 = HEAPU8[$0 + 12 | 0];
  $18 = $5 + $6 | 0;
  if ($18 >>> 0 >= 2) {
   $9 = 0;
   label$4: {
    if (!$1) {
     break label$4;
    }
    $9 = ($1 + $4 | 0) - 2 | 0;
    if (($1 | 0) == ($18 | 0)) {
     break label$4;
    }
    $9 = $1 - 1 | 0;
   }
   $24 = $9;
   $18 = 2 - $4 | 0;
  }
  $6 = ($24 - $6 | 0) + $18 | 0;
  $9 = HEAPU8[$0 + 9 | 0] + 8 | 0;
  label$2: {
   if (($6 | 0) == ($5 | 0)) {
    break label$2;
   }
   $5 = HEAP32[$0 + 64 >> 2] + ($6 << 1) | 0;
   $9 = HEAPU16[$0 + 26 >> 1] & (HEAPU8[$5 | 0] << 8 | HEAPU8[$5 + 1 | 0]);
  }
  $21 = HEAP32[$0 + 52 >> 2];
  $28 = $18 + 1 | 0;
  $5 = $9;
  $30 = $8 + $5 | 0;
  $10 = sqlite3Get4byte($30);
  $6 = 0;
  $5 = $18;
  label$6: {
   while (1) {
    label$8: {
     if (!$6) {
      $8 = ($7 + 304 | 0) + ($5 << 2) | 0;
      $6 = getAndInitPage($21, $10, $8, 0, 0);
      HEAP32[$7 + 316 >> 2] = $6;
      if (!$6) {
       break label$8;
      }
     }
     HEAP32[$7 + 172 >> 2] = $10;
     $8 = 0;
     memset($7 + 304 | 0, 0, ($5 << 2) + 4 | 0);
     break label$6;
    }
    label$10: {
     $6 = HEAP32[$8 >> 2];
     if (HEAP32[$6 + 20 >> 2] >= 0) {
      break label$10;
     }
     $8 = btreeComputeFreeSpace($6);
     HEAP32[$7 + 316 >> 2] = $8;
     if (!$8) {
      break label$10;
     }
     HEAP32[$7 + 172 >> 2] = $10;
     $8 = 0;
     memset($7 + 304 | 0, 0, $5 << 2);
     break label$6;
    }
    $12 = (HEAPU16[$6 + 24 >> 1] + $12 | 0) + 4 | 0;
    if ($5) {
     $8 = HEAPU8[$0 + 12 | 0];
     $5 = $5 - 1 | 0;
     $6 = $24 + $5 | 0;
     if (!(!$8 | ($6 | 0) != HEAPU16[$0 + 28 >> 1])) {
      $8 = $5 << 2;
      $6 = HEAP32[$0 + 36 >> 2];
      HEAP32[$8 + ($7 + 264 | 0) >> 2] = $6;
      $10 = sqlite3Get4byte($6);
      HEAP32[($7 + 176 | 0) + $8 >> 2] = FUNCTION_TABLE[HEAP32[$0 + 76 >> 2]]($0, $6);
      $6 = 0;
      HEAP8[$0 + 12 | 0] = 0;
      continue;
     }
     $11 = $5 << 2;
     $20 = $11 + ($7 + 264 | 0) | 0;
     $8 = HEAP32[$0 + 64 >> 2] + ($6 - $8 << 1) | 0;
     $8 = HEAP32[$0 + 56 >> 2] + (HEAPU16[$0 + 26 >> 1] & (HEAPU8[$8 | 0] << 8 | HEAPU8[$8 + 1 | 0])) | 0;
     HEAP32[$20 >> 2] = $8;
     $10 = sqlite3Get4byte($8);
     $9 = ($7 + 176 | 0) + $11 | 0;
     $11 = FUNCTION_TABLE[HEAP32[$0 + 76 >> 2]]($0, $8) | 0;
     HEAP32[$9 >> 2] = $11;
     label$13: {
      if (!(HEAPU8[$21 + 24 | 0] & 12)) {
       break label$13;
      }
      $9 = $8 - HEAP32[$0 + 56 >> 2] | 0;
      if (HEAP32[$21 + 40 >> 2] < ($11 + $9 | 0)) {
       break label$13;
      }
      __memcpy($2 + $9 | 0, $8, $11);
      HEAP32[$20 >> 2] = ($8 - HEAP32[$0 + 56 >> 2] | 0) + $2;
     }
     dropCell($0, $6 - HEAPU8[$0 + 12 | 0] | 0, $11, $7 + 316 | 0);
     $6 = HEAP32[$7 + 316 >> 2];
     continue;
    }
    break;
   }
   HEAP32[$7 + 172 >> 2] = $10;
   $5 = $12 + 3 & 2147483644;
   $6 = HEAP32[$21 + 36 >> 2] + Math_imul($5, 6) | 0;
   $9 = $6 >> 31;
   $10 = sqlite3DbMallocRaw(0, $6, $9);
   HEAP32[$7 + 40 >> 2] = $10;
   if (!$10) {
    HEAP32[$7 + 316 >> 2] = 7;
    $8 = 0;
    break label$6;
   }
   $26 = HEAP32[$7 + 304 >> 2];
   HEAP32[$7 + 36 >> 2] = $26;
   $19 = ($5 << 2) + $10 | 0;
   HEAP32[$7 + 44 >> 2] = $19;
   $17 = ($5 << 1) + $19 | 0;
   $16 = (($18 | 0) >= 0 ? $18 : -1) + 1 | 0;
   $29 = HEAPU8[$26 + 8 | 0];
   $27 = $29 << 2;
   $23 = HEAPU8[$26 + 2 | 0];
   $6 = 0;
   $20 = 0;
   while (1) {
    label$16: {
     if (($13 | 0) != ($16 | 0)) {
      $14 = $13 << 2;
      $9 = HEAP32[$14 + ($7 + 304 | 0) >> 2];
      $12 = HEAP32[$9 + 56 >> 2];
      if (HEAPU8[$12 | 0] != HEAPU8[HEAP32[$26 + 56 >> 2]]) {
       HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(74923);
       $8 = 0;
       break label$6;
      }
      $5 = HEAPU16[$9 + 18 >> 1] + $12 | 0;
      $11 = HEAPU16[$9 + 26 >> 1];
      $8 = HEAPU16[$9 + 24 >> 1];
      memset(($6 << 1) + $19 | 0, 0, $8 + HEAPU8[$9 + 12 | 0] << 1);
      $15 = HEAPU8[$9 + 12 | 0];
      if (!$15) {
       break label$16;
      }
      $22 = HEAPU16[$9 + 28 >> 1];
      if ($22 >>> 0 <= $8 >>> 0) {
       $8 = 0;
       while (1) if (($8 | 0) == ($22 | 0)) {
        $8 = 0;
        while (1) {
         if (($8 | 0) != ($15 | 0)) {
          HEAP32[($6 << 2) + $10 >> 2] = HEAP32[(($8 << 2) + $9 | 0) + 36 >> 2];
          $8 = $8 + 1 | 0;
          $6 = $6 + 1 | 0;
          continue;
         }
         break;
        }
        HEAP32[$7 + 32 >> 2] = $6;
        break label$16;
       } else {
        HEAP32[($6 << 2) + $10 >> 2] = ((HEAPU8[$5 + 1 | 0] | HEAPU8[$5 | 0] << 8) & $11) + $12;
        $8 = $8 + 1 | 0;
        $6 = $6 + 1 | 0;
        $5 = $5 + 2 | 0;
        continue;
       }
      }
      HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(74947);
      $8 = 0;
      break label$6;
     }
     $20 = (HEAP32[$21 + 40 >> 2] + $27 | 0) - 12 | 0;
     $6 = 0;
     $12 = 0;
     while (1) {
      label$26: {
       if (($12 | 0) == ($16 | 0)) {
        $22 = HEAP32[$7 + 32 >> 2];
        $9 = $28;
        $13 = 0;
        break label$26;
       }
       $8 = ($7 + 32 | 0) + ($6 << 2) | 0;
       $11 = $12 << 2;
       $5 = HEAP32[$11 + ($7 + 304 | 0) >> 2];
       HEAP32[$8 + 16 >> 2] = HEAP32[$5 + 60 >> 2];
       $9 = HEAP32[($7 + 208 | 0) + $11 >> 2];
       HEAP32[$8 + 40 >> 2] = $9;
       if ($6) {
        $8 = $6 - 1 | 0;
        $15 = HEAP32[(($8 << 2) + $7 | 0) + 72 >> 2] == ($9 | 0) ? $8 : $6;
       } else {
        $15 = 0;
       }
       if (!$23) {
        $6 = HEAP32[$0 + 60 >> 2];
        $15 = $15 + 1 | 0;
        $8 = ($7 + 32 | 0) + ($15 << 2) | 0;
        HEAP32[$8 + 40 >> 2] = $9 + 1;
        HEAP32[$8 + 16 >> 2] = $6;
       }
       $10 = ($7 + 176 | 0) + $11 | 0;
       $8 = $20 - HEAP32[$5 + 20 >> 2] | 0;
       HEAP32[$10 >> 2] = $8;
       $6 = 0;
       while (1) {
        if ($6 >>> 0 < HEAPU8[$5 + 12 | 0]) {
         $8 = ((FUNCTION_TABLE[HEAP32[$5 + 76 >> 2]]($5, HEAP32[(($6 << 2) + $5 | 0) + 36 >> 2]) | 0) + $8 | 0) + 2 | 0;
         HEAP32[$10 >> 2] = $8;
         $6 = $6 + 1 | 0;
         continue;
        }
        break;
       }
       HEAP32[($7 + 240 | 0) + $11 >> 2] = $9;
       $6 = $15 + 1 | 0;
       $12 = $12 + 1 | 0;
       continue;
      }
      break;
     }
     while (1) {
      label$34: {
       if (($9 | 0) > ($13 | 0)) {
        $16 = $13 + 2 | 0;
        $25 = $13 << 2;
        $10 = $25 + ($7 + 240 | 0) | 0;
        $17 = $13 + 1 | 0;
        $5 = $17 << 2;
        $19 = $5 + ($7 + 240 | 0) | 0;
        $6 = ($7 + 176 | 0) + $5 | 0;
        $14 = ($7 + 176 | 0) + $25 | 0;
        $5 = HEAP32[$14 >> 2];
        while (1) {
         label$37: {
          if (($5 | 0) <= ($20 | 0)) {
           HEAP32[$14 >> 2] = $5;
           $8 = HEAP32[$10 >> 2];
           $11 = ($8 | 0) > ($22 | 0) ? $8 : $22;
           while (1) {
            if (($8 | 0) == ($11 | 0)) {
             break label$34;
            }
            $12 = cachedCellSize($7 + 32 | 0, $8) + 2 | 0;
            $5 = $12 + $5 | 0;
            if (($20 | 0) < ($5 | 0)) {
             break label$37;
            }
            HEAP32[$14 >> 2] = $5;
            $8 = $8 + 1 | 0;
            label$40: {
             if ($23) {
              break label$40;
             }
             $12 = 0;
             if (($8 | 0) >= ($22 | 0)) {
              break label$40;
             }
             $12 = cachedCellSize($7 + 32 | 0, $8) + 2 | 0;
            }
            HEAP32[$6 >> 2] = HEAP32[$6 >> 2] - $12;
            continue;
           }
          }
          if (($9 | 0) <= ($17 | 0)) {
           if ($13 >>> 0 >= 4) {
            HEAP32[$14 >> 2] = $5;
            HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(75048);
            $8 = 0;
            break label$6;
           }
           HEAP32[$6 >> 2] = 0;
           HEAP32[$19 >> 2] = $22;
           $9 = $16;
          }
          $15 = HEAP32[$10 >> 2];
          $12 = $15 - 1 | 0;
          $11 = cachedCellSize($7 + 32 | 0, $12) + 2 | 0;
          $8 = $11;
          label$43: {
           if ($23) {
            break label$43;
           }
           $8 = 0;
           if (($15 | 0) >= ($22 | 0)) {
            break label$43;
           }
           $8 = cachedCellSize($7 + 32 | 0, $15) + 2 | 0;
          }
          $5 = $5 - $11 | 0;
          HEAP32[$6 >> 2] = $8 + HEAP32[$6 >> 2];
          HEAP32[$10 >> 2] = $12;
          continue;
         }
         break;
        }
        HEAP32[$10 >> 2] = $8;
        $5 = $13 ? HEAP32[($7 + $25 | 0) + 236 >> 2] : 0;
        $13 = $17;
        if (($8 | 0) > ($5 | 0)) {
         continue;
        }
        HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(75081);
        $8 = 0;
        break label$6;
       }
       $15 = HEAP32[$7 + 44 >> 2];
       $31 = $9 - 1 | 0;
       $16 = $31;
       while (1) {
        label$47: {
         label$48: {
          if (($16 | 0) > 0) {
           $32 = $16 << 2;
           $19 = $32 + ($7 + 176 | 0) | 0;
           $10 = HEAP32[$19 >> 2];
           $25 = $16 - 1 | 0;
           $5 = $25 << 2;
           $33 = $5 + ($7 + 176 | 0) | 0;
           $12 = HEAP32[$33 >> 2];
           $13 = ($7 + 240 | 0) + $5 | 0;
           $6 = HEAP32[$13 >> 2];
           $8 = $6 - $23 | 0;
           cachedCellSize($7 + 32 | 0, $8);
           $14 = ($16 | 0) == ($31 | 0) ? 0 : -2;
           while (1) {
            $5 = $6 - 1 | 0;
            cachedCellSize($7 + 32 | 0, $5);
            label$51: {
             if (!$10) {
              $11 = HEAPU16[($8 << 1) + $15 >> 1] + 2 | 0;
              $17 = HEAPU16[($5 << 1) + $15 >> 1];
              break label$51;
             }
             if ($4) {
              break label$48;
             }
             $11 = (HEAPU16[($8 << 1) + $15 >> 1] + $10 | 0) + 2 | 0;
             $17 = HEAPU16[($5 << 1) + $15 >> 1];
             if (($11 | 0) > (($12 + $14 | 0) - $17 | 0)) {
              break label$48;
             }
            }
            HEAP32[$13 >> 2] = $5;
            $8 = $8 - 1 | 0;
            $12 = ($12 - $17 | 0) - 2 | 0;
            $17 = ($6 | 0) > 1;
            $10 = $11;
            $6 = $5;
            if ($17) {
             continue;
            }
            break;
           }
           break label$47;
          }
          $12 = ($9 | 0) > 0 ? $9 : 0;
          $11 = $1 - $24 | 0;
          $9 = HEAPU8[HEAP32[$26 + 56 >> 2]];
          $5 = 0;
          $8 = 0;
          while (1) {
           label$54: {
            if (($5 | 0) == ($12 | 0)) {
             $10 = 0;
             $17 = ($8 | 0) > 0 ? $8 : 0;
             break label$54;
            }
            label$56: {
             if (($5 | 0) <= ($18 | 0)) {
              $6 = $5 << 2;
              $1 = $6 + ($7 + 272 | 0) | 0;
              $6 = ($7 + 304 | 0) + $6 | 0;
              $10 = HEAP32[$6 >> 2];
              HEAP32[$1 >> 2] = $10;
              HEAP32[$6 >> 2] = 0;
              $6 = sqlite3PagerWrite(HEAP32[$10 + 72 >> 2]);
              HEAP32[$7 + 316 >> 2] = $6;
              if (!((sqlite3PagerPageRefcount(HEAP32[$10 + 72 >> 2]) | 0) == ((($5 | 0) == ($11 | 0) ? 2 : 1) | 0) | $6)) {
               $6 = sqlite3CorruptError(75156);
               HEAP32[$7 + 316 >> 2] = $6;
              }
              $8 = $8 + 1 | 0;
              if (!$6) {
               break label$56;
              }
              break label$6;
             }
             $6 = allocateBtreePage($21, $7 + 8 | 0, $7 + 172 | 0, $4 ? 1 : HEAP32[$7 + 172 >> 2], 0);
             HEAP32[$7 + 316 >> 2] = $6;
             if ($6) {
              break label$6;
             }
             $6 = HEAP32[$7 + 8 >> 2];
             zeroPage($6, $9);
             $10 = $5 << 2;
             HEAP32[$10 + ($7 + 208 | 0) >> 2] = $22;
             HEAP32[($7 + 272 | 0) + $10 >> 2] = $6;
             $8 = $8 + 1 | 0;
             if (!HEAPU8[$21 + 17 | 0]) {
              break label$56;
             }
             ptrmapPut($21, HEAP32[$6 + 4 >> 2], 5, HEAP32[$0 + 4 >> 2], $7 + 316 | 0);
             if (HEAP32[$7 + 316 >> 2]) {
              break label$6;
             }
            }
            $5 = $5 + 1 | 0;
            continue;
           }
           break;
          }
          while (1) {
           label$60: {
            label$61: {
             if (($10 | 0) == ($17 | 0)) {
              $12 = HEAP32[$7 + 172 >> 2];
              $10 = 0;
              while (1) {
               label$64: {
                $6 = 0;
                $5 = 1;
                if (($10 | 0) == ($17 | 0)) {
                 HEAP32[$7 + 172 >> 2] = $12;
                 $1 = $8 - 1 | 0;
                 $5 = HEAP32[($7 + 272 | 0) + ($1 << 2) >> 2];
                 sqlite3Put4byte($30, HEAP32[$5 + 4 >> 2]);
                 if (!($9 & 8 | ($8 | 0) == ($28 | 0))) {
                  $5 = HEAP32[$5 + 56 >> 2];
                  $4 = HEAP32[HEAP32[($18 << 2) + (($8 | 0) > ($28 | 0) ? $7 + 272 | 0 : $7 + 304 | 0) >> 2] + 56 >> 2];
                  $4 = HEAPU8[$4 + 8 | 0] | HEAPU8[$4 + 9 | 0] << 8 | (HEAPU8[$4 + 10 | 0] << 16 | HEAPU8[$4 + 11 | 0] << 24);
                  HEAP8[$5 + 8 | 0] = $4;
                  HEAP8[$5 + 9 | 0] = $4 >>> 8;
                  HEAP8[$5 + 10 | 0] = $4 >>> 16;
                  HEAP8[$5 + 11 | 0] = $4 >>> 24;
                 }
                 if (HEAPU8[$21 + 17 | 0]) {
                  break label$64;
                 }
                 $4 = HEAP32[$7 + 40 >> 2];
                 break label$61;
                }
                while (1) {
                 if (($5 | 0) != ($8 | 0)) {
                  $6 = HEAPU32[($7 + 112 | 0) + ($5 << 2) >> 2] < HEAPU32[($7 + 112 | 0) + ($6 << 2) >> 2] ? $5 : $6;
                  $5 = $5 + 1 | 0;
                  continue;
                 }
                 break;
                }
                $11 = $6 << 2;
                $5 = $11 + ($7 + 112 | 0) | 0;
                $12 = HEAP32[$5 >> 2];
                HEAP32[$5 >> 2] = -1;
                if (($6 | 0) != ($10 | 0)) {
                 if (($6 | 0) > ($10 | 0)) {
                  sqlite3PagerRekey(HEAP32[HEAP32[($7 + 272 | 0) + $11 >> 2] + 72 >> 2], (HEAP32[$21 + 48 >> 2] + $6 | 0) + 1 | 0, 0);
                 }
                 $5 = HEAP32[($7 + 272 | 0) + ($10 << 2) >> 2];
                 sqlite3PagerRekey(HEAP32[$5 + 72 >> 2], $12, HEAPU16[($7 + 102 | 0) + ($6 << 1) >> 1]);
                 HEAP32[$5 + 4 >> 2] = $12;
                }
                $10 = $10 + 1 | 0;
                continue;
               }
               break;
              }
              $13 = 0;
              $16 = ($22 | 0) > 0 ? $22 : 0;
              $10 = HEAP32[$7 + 272 >> 2];
              $6 = HEAPU8[$10 + 12 | 0] + HEAPU16[$10 + 24 >> 1] | 0;
              $19 = !$23;
              $4 = HEAP32[$7 + 40 >> 2];
              $9 = $10;
              $5 = 0;
              $12 = 0;
              while (1) {
               if (($12 | 0) == ($16 | 0)) {
                break label$61;
               }
               $11 = $12 + $19 | 0;
               $14 = HEAP32[($12 << 2) + $4 >> 2];
               while (1) {
                if (($6 | 0) == ($12 | 0)) {
                 $5 = $5 + 1 | 0;
                 $10 = HEAP32[(($8 | 0) > ($5 | 0) ? $7 + 272 | 0 : $7 + 304 | 0) + ($5 << 2) >> 2];
                 $6 = (HEAPU16[$10 + 24 >> 1] + $11 | 0) + HEAPU8[$10 + 12 | 0] | 0;
                 continue;
                }
                break;
               }
               label$74: {
                if (HEAP32[($7 + 240 | 0) + ($13 << 2) >> 2] == ($12 | 0)) {
                 $13 = $13 + 1 | 0;
                 $9 = HEAP32[($7 + 272 | 0) + ($13 << 2) >> 2];
                 if (!$23) {
                  break label$74;
                 }
                }
                if (!(HEAP32[$9 + 4 >> 2] != HEAP32[($7 + 144 | 0) + ($5 << 2) >> 2] | ($5 | 0) >= ($8 | 0) | HEAPU32[$10 + 56 >> 2] > $14 >>> 0)) {
                 if (HEAPU32[$10 + 60 >> 2] > $14 >>> 0) {
                  break label$74;
                 }
                }
                if (!$29) {
                 ptrmapPut($21, sqlite3Get4byte($14), 5, HEAP32[$9 + 4 >> 2], $7 + 316 | 0);
                }
                if (cachedCellSize($7 + 32 | 0, $12) >>> 0 > HEAPU16[$9 + 16 >> 1]) {
                 ptrmapPutOvflPtr($9, $10, $14, $7 + 316 | 0);
                }
                if (HEAP32[$7 + 316 >> 2]) {
                 break label$6;
                }
               }
               $12 = $12 + 1 | 0;
               continue;
              }
             }
             $5 = $10 << 2;
             $6 = HEAP32[$5 + ($7 + 272 | 0) >> 2];
             $12 = HEAP32[$6 + 4 >> 2];
             HEAP32[($7 + 144 | 0) + $5 >> 2] = $12;
             HEAP32[($7 + 112 | 0) + $5 >> 2] = $12;
             HEAP16[($7 + 102 | 0) + ($10 << 1) >> 1] = HEAPU16[HEAP32[$6 + 72 >> 2] + 28 >> 1];
             $5 = 0;
             while (1) {
              if (($5 | 0) == ($10 | 0)) {
               break label$60;
              }
              $6 = $5 << 2;
              $5 = $5 + 1 | 0;
              if (HEAP32[($7 + 144 | 0) + $6 >> 2] != ($12 | 0)) {
               continue;
              }
              break;
             }
             HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(75202);
             break label$6;
            }
            $19 = 0;
            $1 = ($1 | 0) > 0 ? $1 : 0;
            $11 = 0;
            while (1) {
             if (($1 | 0) != ($11 | 0)) {
              $14 = $2 + $19 | 0;
              $5 = $11 << 2;
              $10 = HEAP32[$5 + ($7 + 240 | 0) >> 2];
              $6 = HEAPU16[($10 << 1) + $15 >> 1];
              $13 = $27 + $6 | 0;
              $9 = HEAP32[($10 << 2) + $4 >> 2];
              $16 = HEAP32[($7 + 272 | 0) + $5 >> 2];
              label$82: {
               if (!HEAPU8[$16 + 8 | 0]) {
                $6 = HEAP32[$16 + 56 >> 2];
                $5 = HEAPU8[$9 | 0] | HEAPU8[$9 + 1 | 0] << 8 | (HEAPU8[$9 + 2 | 0] << 16 | HEAPU8[$9 + 3 | 0] << 24);
                HEAP8[$6 + 8 | 0] = $5;
                HEAP8[$6 + 9 | 0] = $5 >>> 8;
                HEAP8[$6 + 10 | 0] = $5 >>> 16;
                HEAP8[$6 + 11 | 0] = $5 >>> 24;
                break label$82;
               }
               if ($23) {
                $10 = $10 - 1 | 0;
                FUNCTION_TABLE[HEAP32[$16 + 80 >> 2]]($16, HEAP32[($10 << 2) + $4 >> 2], $7 + 8 | 0);
                $9 = HEAP32[$7 + 8 >> 2];
                $6 = HEAP32[$7 + 12 >> 2];
                $13 = sqlite3PutVarint($14 + 4 | 0, $9, $6) + 4 | 0;
                $9 = $14;
                $14 = 0;
                break label$82;
               }
               $9 = $9 - 4 | 0;
               if (($6 | 0) != 4) {
                break label$82;
               }
               $13 = FUNCTION_TABLE[HEAP32[$0 + 76 >> 2]]($0, $9) | 0;
              }
              $5 = 0;
              while (1) {
               $12 = ($7 + 32 | 0) + ($5 << 2) | 0;
               if (HEAP32[$12 + 40 >> 2] <= ($10 | 0)) {
                $6 = $5 >>> 0 < 6;
                $5 = $5 + 1 | 0;
                if ($6) {
                 continue;
                }
               }
               break;
              }
              $5 = HEAP32[$12 + 16 >> 2];
              if (!($9 >>> 0 > $5 >>> 0 | $9 + $13 >>> 0 <= $5 >>> 0)) {
               HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(75359);
               break label$6;
              }
              insertCell($0, $11 + $24 | 0, $9, $13, $14, HEAP32[$16 + 4 >> 2], $7 + 316 | 0);
              $11 = $11 + 1 | 0;
              $19 = $13 + $19 | 0;
              if (!HEAP32[$7 + 316 >> 2]) {
               continue;
              }
              break label$6;
             }
             break;
            }
            $5 = 1 - $8 | 0;
            $12 = ($5 | 0) < ($8 | 0) ? $8 : $5;
            $13 = !$23;
            $23 = HEAP32[$7 + 240 >> 2];
            while (1) {
             label$89: {
              label$90: {
               label$91: {
                label$92: {
                 if (($5 | 0) != ($12 | 0)) {
                  $6 = $5 >> 31;
                  $6 = ($6 ^ $5) - $6 | 0;
                  $10 = $6 + ($7 + 164 | 0) | 0;
                  if (HEAPU8[$10 | 0]) {
                   break label$90;
                  }
                  if (($5 | 0) < 0) {
                   $11 = ($6 << 2) - 4 | 0;
                   if (HEAP32[$11 + ($7 + 208 | 0) >> 2] < HEAP32[($7 + 240 | 0) + $11 >> 2]) {
                    break label$90;
                   }
                   break label$92;
                  }
                  if ($5) {
                   break label$92;
                  }
                  $9 = 0;
                  $11 = 0;
                  $1 = $23;
                  break label$91;
                 }
                 $6 = 0;
                 HEAP32[$7 + 316 >> 2] = 0;
                 label$95: {
                  label$96: {
                   label$97: {
                    if (HEAPU16[$0 + 24 >> 1] | !$3) {
                     break label$97;
                    }
                    $5 = HEAP32[$7 + 272 >> 2];
                    if (HEAP32[$5 + 20 >> 2] < HEAPU8[$0 + 9 | 0]) {
                     break label$97;
                    }
                    HEAP32[$7 + 316 >> 2] = defragmentPage($5, -1);
                    copyNodeContent($5, $0, $7 + 316 | 0);
                    freePage($5, $7 + 316 | 0);
                    break label$96;
                   }
                   $5 = $8;
                   if (!HEAPU8[$21 + 17 | 0]) {
                    break label$95;
                   }
                   $5 = $8;
                   if ($29) {
                    break label$95;
                   }
                   while (1) {
                    if (($6 | 0) == ($17 | 0)) {
                     break label$96;
                    }
                    $5 = HEAP32[($7 + 272 | 0) + ($6 << 2) >> 2];
                    ptrmapPut($21, sqlite3Get4byte(HEAP32[$5 + 56 >> 2] + 8 | 0), 5, HEAP32[$5 + 4 >> 2], $7 + 316 | 0);
                    $6 = $6 + 1 | 0;
                    continue;
                   }
                  }
                  $5 = $8;
                 }
                 while (1) {
                  if (($5 | 0) > ($18 | 0)) {
                   break label$6;
                  }
                  freePage(HEAP32[($7 + 304 | 0) + ($5 << 2) >> 2], $7 + 316 | 0);
                  $5 = $5 + 1 | 0;
                  continue;
                 }
                }
                $9 = $6 - 1 | 0;
                $11 = $22;
                $11 = ($6 | 0) <= ($18 | 0) ? HEAP32[($7 + 208 | 0) + ($9 << 2) >> 2] + $13 | 0 : $11;
                $9 = HEAP32[($7 + 240 | 0) + ($9 << 2) >> 2] + $13 | 0;
                $1 = HEAP32[($7 + 240 | 0) + ($6 << 2) >> 2] - $9 | 0;
               }
               $6 = $6 << 2;
               $24 = HEAP32[$6 + ($7 + 272 | 0) >> 2];
               $15 = $1;
               $11 = editPage($24, $11, $9, $15, $7 + 32 | 0);
               if ($11) {
                break label$89;
               }
               HEAP8[$10 | 0] = 1;
               HEAP32[$24 + 20 >> 2] = $20 - HEAP32[($7 + 176 | 0) + $6 >> 2];
              }
              $5 = $5 + 1 | 0;
              continue;
             }
             break;
            }
            HEAP32[$7 + 316 >> 2] = $11;
            break label$6;
           }
           $10 = $10 + 1 | 0;
           continue;
          }
         }
         $5 = $6;
         $11 = $10;
        }
        HEAP32[$19 >> 2] = $11;
        HEAP32[$33 >> 2] = $12;
        $6 = 0;
        $6 = ($16 | 0) >= 2 ? HEAP32[($7 + $32 | 0) + 232 >> 2] : $6;
        $16 = $25;
        if (($5 | 0) > ($6 | 0)) {
         continue;
        }
        break;
       }
       HEAP32[$7 + 316 >> 2] = sqlite3CorruptError(75123);
       $8 = 0;
       break label$6;
      }
      HEAP32[$10 >> 2] = $11;
      $9 = $17;
      $13 = $9;
      continue;
     }
    }
    $8 = (HEAPU16[$9 + 18 >> 1] + $12 | 0) + (HEAPU16[$9 + 24 >> 1] << 1) | 0;
    while (1) {
     if ($5 >>> 0 < $8 >>> 0) {
      HEAP32[($6 << 2) + $10 >> 2] = ((HEAPU8[$5 + 1 | 0] | HEAPU8[$5 | 0] << 8) & $11) + $12;
      $6 = $6 + 1 | 0;
      HEAP32[$7 + 32 >> 2] = $6;
      $5 = $5 + 2 | 0;
      continue;
     }
     break;
    }
    HEAP32[($7 + 208 | 0) + $14 >> 2] = $6;
    if (!(($13 | 0) >= ($18 | 0) | $23)) {
     $5 = ($6 << 1) + $19 | 0;
     $8 = HEAP32[($7 + 176 | 0) + $14 >> 2];
     HEAP16[$5 >> 1] = $8;
     $12 = $8 & 65535;
     $11 = __memcpy($17 + $20 | 0, HEAP32[($7 + 264 | 0) + $14 >> 2], $12) + $27 | 0;
     HEAP32[($6 << 2) + $10 >> 2] = $11;
     $8 = HEAPU16[$5 >> 1] - $27 | 0;
     HEAP16[$5 >> 1] = $8;
     $20 = $12 + $20 | 0;
     label$105: {
      if (!HEAPU8[$9 + 8 | 0]) {
       $5 = HEAP32[$9 + 56 >> 2];
       $5 = HEAPU8[$5 + 8 | 0] | HEAPU8[$5 + 9 | 0] << 8 | (HEAPU8[$5 + 10 | 0] << 16 | HEAPU8[$5 + 11 | 0] << 24);
       HEAP8[$11 | 0] = $5;
       HEAP8[$11 + 1 | 0] = $5 >>> 8;
       HEAP8[$11 + 2 | 0] = $5 >>> 16;
       HEAP8[$11 + 3 | 0] = $5 >>> 24;
       break label$105;
      }
      while (1) {
       if (($8 & 65535) >>> 0 > 3) {
        break label$105;
       }
       HEAP8[$17 + $20 | 0] = 0;
       $8 = HEAPU16[$5 >> 1] + 1 | 0;
       HEAP16[$5 >> 1] = $8;
       $20 = $20 + 1 | 0;
       continue;
      }
     }
     $6 = $6 + 1 | 0;
     HEAP32[$7 + 32 >> 2] = $6;
    }
    $13 = $13 + 1 | 0;
    continue;
   }
  }
  $5 = 0;
  sqlite3DbFree(0, HEAP32[$7 + 40 >> 2]);
  $6 = (($18 | 0) >= 0 ? $18 : -1) + 1 | 0;
  while (1) {
   if (($5 | 0) == ($6 | 0)) {
    $5 = 0;
    $6 = ($8 | 0) > 0 ? $8 : 0;
    while (1) {
     if (($5 | 0) != ($6 | 0)) {
      releasePage(HEAP32[($7 + 272 | 0) + ($5 << 2) >> 2]);
      $5 = $5 + 1 | 0;
      continue;
     }
     break;
    }
    $5 = HEAP32[$7 + 316 >> 2];
   } else {
    releasePage(HEAP32[($7 + 304 | 0) + ($5 << 2) >> 2]);
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
 } else {
  $5 = 7;
 }
 __stack_pointer = $7 + 320 | 0;
 return $5;
}

function sqlite3Update($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0;
 $10 = __stack_pointer - 80 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 72 >> 2] = 0;
 HEAP32[$10 + 76 >> 2] = 0;
 $34 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $8 = sqlite3SrcListLookup($0, $1);
  if (!$8) {
   break label$1;
  }
  $22 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$8 + 60 >> 2]);
  $35 = sqlite3TriggersExist($0, $8, 129, $2, $10 + 36 | 0);
  $26 = HEAP32[$1 >> 2] >= 2 ? HEAP32[$2 >> 2] : $26;
  $36 = HEAPU8[$8 + 43 | 0];
  if (sqlite3ViewGetColumnNames($0, $8)) {
   break label$1;
  }
  if (sqlite3IsReadOnly($0, $8, HEAP32[$10 + 36 >> 2])) {
   break label$1;
  }
  $15 = HEAP32[$0 + 40 >> 2];
  $37 = $15 + 1 | 0;
  HEAP32[$0 + 40 >> 2] = $37;
  if (HEAPU8[$8 + 28 | 0] & 128) {
   $21 = sqlite3PrimaryKeyIndex($8);
  }
  $6 = $37;
  $13 = $15;
  $23 = $8 + 8 | 0;
  $7 = $23;
  while (1) {
   $7 = HEAP32[$7 >> 2];
   if ($7) {
    $16 = $6 + 1 | 0;
    HEAP32[$0 + 40 >> 2] = $16;
    $13 = ($7 | 0) == ($21 | 0) ? $6 : $13;
    $27 = $27 + 1 | 0;
    $7 = $7 + 20 | 0;
    $6 = $16;
    continue;
   }
   break;
  }
  if ($5) {
   $37 = HEAP32[$5 + 44 >> 2];
   $13 = HEAP32[$5 + 40 >> 2];
   HEAP32[$0 + 40 >> 2] = $15;
  }
  HEAP32[$1 + 48 >> 2] = $13;
  $16 = sqlite3DbMallocRawNN($34, ((HEAP16[$8 + 34 >> 1] + $27 << 2) + $27 | 0) + 6 | 0, 0);
  if (!$16) {
   $16 = 0;
   break label$1;
  }
  $6 = 0;
  $38 = (HEAP16[$8 + 34 >> 1] << 2) + $16 | 0;
  $28 = $27 + 1 | 0;
  $39 = memset(($38 + ($27 << 2) | 0) + 4 | 0, 1, $28);
  HEAP8[$28 + $39 | 0] = 0;
  $7 = HEAP16[$8 + 34 >> 1];
  $7 = ($7 | 0) > 0 ? $7 : 0;
  while (1) {
   if (($6 | 0) != ($7 | 0)) {
    HEAP32[($6 << 2) + $16 >> 2] = -1;
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$10 + 60 >> 2] = 0;
  HEAP32[$10 + 64 >> 2] = 0;
  HEAP32[$10 + 68 >> 2] = 0;
  HEAP32[$10 + 52 >> 2] = 0;
  HEAP32[$10 + 56 >> 2] = 0;
  HEAP32[$10 + 48 >> 2] = $5;
  HEAP32[$10 + 44 >> 2] = $1;
  HEAP32[$10 + 40 >> 2] = $0;
  HEAP32[$10 + 64 >> 2] = 512;
  $9 = sqlite3GetVdbe($0);
  if (!$9) {
   break label$1;
  }
  $44 = -1;
  while (1) {
   label$11: {
    label$12: {
     if (HEAP32[$2 >> 2] > ($14 | 0)) {
      $6 = ($14 << 4) + $2 | 0;
      $24 = $6;
      $24 = $6;
      $12 = $6 + 12 | 0;
      $25 = sqlite3StrIHash(HEAP32[$12 >> 2]);
      if (!$26) {
       if (sqlite3ResolveExprNames($10 + 40 | 0, HEAP32[$24 + 8 >> 2])) {
        break label$1;
       }
      }
      $6 = 0;
      $7 = HEAP16[$8 + 34 >> 1];
      $11 = ($7 | 0) > 0 ? $7 : 0;
      while (1) {
       if (($6 | 0) != ($11 | 0)) {
        label$17: {
         $7 = HEAP32[$8 + 4 >> 2] + Math_imul($6, 12) | 0;
         if (HEAPU8[$7 + 7 | 0] != ($25 | 0)) {
          break label$17;
         }
         $18 = HEAP32[$7 >> 2];
         if (sqlite3StrICmp($18, HEAP32[$24 + 12 >> 2])) {
          break label$17;
         }
         if (HEAP16[$8 + 32 >> 1] == ($6 | 0)) {
          $45 = HEAP32[$24 + 8 >> 2];
          $41 = 1;
          $44 = $14;
          break label$12;
         }
         $7 = HEAPU16[$7 + 10 >> 1];
         if (!(!$21 | !($7 & 1))) {
          $46 = 1;
          break label$12;
         }
         if (!($7 & 96)) {
          break label$12;
         }
         HEAP32[$10 + 16 >> 2] = $18;
         sqlite3ErrorMsg($0, 28624, $10 + 16 | 0);
         break label$1;
        }
        $6 = $6 + 1 | 0;
        continue;
       }
       break;
      }
      $6 = HEAP32[$24 + 12 >> 2];
      label$20: {
       if ($21) {
        break label$20;
       }
       if (!sqlite3IsRowid($6)) {
        break label$20;
       }
       $45 = HEAP32[$24 + 8 >> 2];
       $18 = 19859;
       $41 = 1;
       $6 = -1;
       $44 = $14;
       break label$11;
      }
      HEAP32[$10 >> 2] = $6;
      sqlite3ErrorMsg($0, 7394, $10);
      HEAP8[$0 + 17 | 0] = 1;
      break label$1;
     }
     $40 = $41 + $46 | 0;
     $25 = $41;
     label$21: {
      if (!(HEAPU8[$8 + 28 | 0] & 96)) {
       break label$21;
      }
      $7 = 0;
      $6 = 0;
      while (1) {
       $11 = $7;
       label$23: {
        label$24: {
         if (HEAP16[$8 + 34 >> 1] > ($6 | 0)) {
          $12 = ($6 << 2) + $16 | 0;
          if (HEAP32[$12 >> 2] >= 0) {
           break label$24;
          }
          $18 = HEAP32[$8 + 4 >> 2] + Math_imul($6, 12) | 0;
          if (!(HEAPU8[$18 + 10 | 0] & 96)) {
           break label$24;
          }
          if (!sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr($8, $18), $16, $25)) {
           break label$23;
          }
          HEAP32[$12 >> 2] = 99999;
          $11 = 1;
          break label$23;
         }
         $7 = 0;
         $6 = 0;
         if ($11) {
          continue;
         }
         break label$21;
        }
       }
       $7 = $11;
       $6 = $6 + 1 | 0;
       continue;
      }
     }
     $7 = HEAPU8[$8 + 43 | 0] == 1;
     HEAP32[$1 + 56 >> 2] = $7 ? -1 : 0;
     HEAP32[$1 + 60 >> 2] = $7 ? -1 : 0;
     $12 = 0;
     $42 = $40 & 255;
     $31 = sqlite3FkRequired($0, $8, $16, $42);
     $18 = ($42 | 0) != 0 | ($31 | 0) > 1;
     $14 = ($4 | 0) == 5;
     $17 = ($4 | 0) != 11;
     while (1) {
      label$27: {
       label$28: {
        label$29: {
         label$30: {
          label$31: {
           label$33: {
            label$34: {
             $7 = HEAP32[$23 >> 2];
             if ($7) {
              if (($7 | 0) == ($21 | 0) | $18) {
               break label$34;
              }
              if (indexWhereClauseMightChange($7, $16, $25)) {
               break label$34;
              }
              $6 = 0;
              while (1) {
               if (HEAPU16[$7 + 50 >> 1] <= $6 >>> 0) {
                break label$28;
               }
               $11 = indexColumnIsBeingUpdated($7, $6, $16, $25);
               $6 = $6 + 1 | 0;
               if (!$11) {
                continue;
               }
               break;
              }
              $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
              HEAP32[$0 + 44 >> 2] = $6 + HEAPU16[$7 + 52 >> 1];
              if ($17) {
               break label$29;
              }
              $14 = HEAPU8[$7 + 54 | 0] == 5 ? 1 : $14;
              break label$29;
             }
             HEAP32[$10 + 24 >> 2] = $14;
             $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
             HEAP32[$0 + 44 >> 2] = $6;
             $11 = ($12 << 2) + $38 | 0;
             HEAP32[$11 >> 2] = $6;
             if ($14) {
              memset($39, 1, $28);
             }
             if (!HEAPU8[$0 + 18 | 0]) {
              sqlite3VdbeCountChanges($9);
             }
             $12 = 0;
             $20 = $31 | $35;
             sqlite3BeginWriteOperation($0, ($20 | 0) != 0, $22);
             $22 = 0;
             $18 = 0;
             $25 = 0;
             $6 = 0;
             if (HEAPU8[$8 + 43 | 0] != 1) {
              $6 = HEAP32[$0 + 44 >> 2];
              $12 = $6 + 1 | 0;
              label$40: {
               if (!($35 | $46 | $31)) {
                $18 = HEAP16[$8 + 34 >> 1];
                $7 = $12;
                break label$40;
               }
               $25 = $6 + 2 | 0;
               $18 = HEAP16[$8 + 34 >> 1];
               $7 = $18 + $12 | 0;
              }
              $6 = HEAP32[$11 >> 2];
              $22 = $7 + 1 | 0;
              $23 = $40 & 255 | $35 | $31;
              $7 = $23 ? $22 : $7;
              HEAP32[$0 + 44 >> 2] = $18 + $7;
              $22 = $23 ? $22 : $12;
              $18 = $7 + 1 | 0;
             }
             label$42: {
              label$43: {
               if (($36 | 0) != 2) {
                $23 = 0;
                if (!$26) {
                 break label$43;
                }
                break label$42;
               }
               sqlite3AuthContextPush($0, $10 + 72 | 0, HEAP32[$8 >> 2]);
               $23 = 0;
               if ($26) {
                break label$42;
               }
               sqlite3MaterializeView($0, $8, $3, $13);
              }
              if (sqlite3ResolveExprNames($10 + 40 | 0, $3)) {
               break label$1;
              }
              $23 = 1;
             }
             if (HEAPU8[$8 + 43 | 0] == 1) {
              updateVirtualTable($0, $1, $8, $2, $45, $16, $3, $4);
              break label$1;
             }
             $24 = sqlite3VdbeMakeLabel($0);
             $28 = 0;
             if (!(HEAP32[$0 + 120 >> 2] | !(HEAP8[$34 + 36 | 0] & 1) | (HEAPU8[$0 + 149 | 0] | (HEAPU8[$0 + 18 | 0] | $5)))) {
              $28 = HEAP32[$0 + 44 >> 2] + 1 | 0;
              HEAP32[$0 + 44 >> 2] = $28;
              sqlite3VdbeAddOp2($9, 71, 0, $28);
             }
             label$47: {
              label$48: {
               label$49: {
                label$50: {
                 label$51: {
                  label$52: {
                   label$53: {
                    if (!(!$23 | HEAPU8[$8 + 28 | 0] & 128)) {
                     $7 = 0;
                     sqlite3VdbeAddOp3($9, 75, 0, $6, $12);
                     $17 = HEAP32[$0 + 40 >> 2];
                     HEAP32[$0 + 40 >> 2] = $17 + 1;
                     $32 = sqlite3VdbeAddOp3($9, 118, $17, 0, $6);
                     break label$53;
                    }
                    $7 = HEAP32[$0 + 44 >> 2];
                    $43 = $21 ? HEAP16[$21 + 50 >> 1] : 0;
                    $19 = $43 << 16 >> 16;
                    $29 = $7 + $19 | 0;
                    $30 = ($26 + $29 | 0) + 1 | 0;
                    HEAP32[$0 + 44 >> 2] = $30;
                    $7 = $7 + 1 | 0;
                    if ($5) {
                     break label$52;
                    }
                    $33 = $19 + $26 | 0;
                    $19 = 0;
                    $19 = ($36 | 0) == 2 ? HEAP16[$8 + 34 >> 1] : $19;
                    $17 = HEAP32[$0 + 40 >> 2];
                    HEAP32[$0 + 40 >> 2] = $17 + 1;
                    $19 = $19 + $33 | 0;
                    if ($21) {
                     sqlite3VdbeAddOp3($9, 75, 0, $7, $29);
                    }
                    $32 = sqlite3VdbeAddOp2($9, 118, $17, $19);
                    label$59: {
                     if (!$21) {
                      break label$59;
                     }
                     $29 = sqlite3KeyInfoOfIndex($0, $21);
                     if (!$29) {
                      break label$59;
                     }
                     HEAP16[$29 + 8 >> 1] = $19;
                     sqlite3VdbeAppendP4($9, $29, -8);
                    }
                    if ($23) {
                     break label$53;
                    }
                    updateFromSelect($0, $17, $21, $2, $1, $3);
                    $13 = ($36 | 0) == 2 ? $17 : $13;
                   }
                   if (!$26) {
                    break label$50;
                   }
                   $19 = $43 << 16 >> 16;
                   break label$51;
                  }
                  $17 = 0;
                  if (!$26) {
                   break label$49;
                  }
                 }
                 sqlite3MultiWrite($0);
                 $20 = 0;
                 $26 = 1;
                 $29 = 1;
                 $30 = $7;
                 $33 = 0;
                 break label$30;
                }
                if (!$5) {
                 break label$48;
                }
               }
               sqlite3ExprIfFalse($0, $3, $24, 16);
               $29 = 0;
               $20 = 1;
               $33 = 0;
               break label$47;
              }
              $33 = sqlite3WhereBegin($0, $1, $3, 0, 0, 0, HEAPU8[$0 + 18 | 0] ? 4 : $20 ? 4 : $40 & 255 ? 4 : $14 ? 4 : 12, $37);
              if (!$33) {
               break label$1;
              }
              $20 = 1;
              $14 = sqlite3WhereOkOnePass($33, $10 + 28 | 0);
              $29 = sqlite3WhereUsesDeferredSeek($33);
              if (($14 | 0) == 1) {
               break label$47;
              }
              sqlite3MultiWrite($0);
              $20 = 2;
              if (($14 | 0) != 2) {
               $20 = $14;
               break label$47;
              }
              $14 = HEAP32[$10 + 32 >> 2];
              if (($14 | 0) < 0 | ($13 | 0) == ($14 | 0)) {
               break label$47;
              }
              $20 = !HEAPU8[($14 - $15 | 0) + $39 | 0] << 1;
             }
             label$61: {
              label$62: {
               if (HEAPU8[$8 + 28 | 0] & 128) {
                $6 = 0;
                $19 = $43 << 16 >> 16;
                $11 = ($19 | 0) > 0 ? $19 : 0;
                while (1) {
                 if (($6 | 0) == ($11 | 0)) {
                  break label$62;
                 }
                 sqlite3ExprCodeGetColumnOfTable($9, $8, $13, HEAP16[HEAP32[$21 + 4 >> 2] + ($6 << 1) >> 1], $6 + $7 | 0);
                 $6 = $6 + 1 | 0;
                 continue;
                }
               }
               sqlite3VdbeAddOp2($9, 135, $13, $12);
               if (!$20) {
                $14 = HEAP32[$0 + 44 >> 2] + 1 | 0;
                HEAP32[$0 + 44 >> 2] = $14;
                HEAP32[$11 >> 2] = $14;
                sqlite3VdbeAddOp3($9, 128, $17, $6, $12);
                break label$61;
               }
               if (!$32) {
                break label$31;
               }
               sqlite3VdbeChangeToNoop($9, $32);
               break label$31;
              }
              if ($20) {
               $26 = 0;
               if (!$32) {
                break label$33;
               }
               sqlite3VdbeChangeToNoop($9, $32);
               break label$33;
              }
              sqlite3VdbeAddOp4($9, 97, $7, $19, $30, sqlite3IndexAffinityStr($34, $21), $19);
              sqlite3VdbeAddOp4Int($9, 138, $17, $30, $7, $19);
             }
             $20 = 0;
             break label$31;
            }
            $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
            HEAP32[$0 + 44 >> 2] = $6 + HEAPU16[$7 + 52 >> 1];
            break label$29;
           }
           $30 = $7;
           break label$30;
          }
          $26 = 0;
          $19 = 0;
         }
         $32 = 0;
         label$67: {
          if ($5) {
           $15 = $24;
           break label$67;
          }
          if (($20 | 0) != 2 & $23) {
           sqlite3WhereEnd($33);
          }
          label$70: {
           if (($36 | 0) == 2) {
            break label$70;
           }
           $6 = 0;
           label$71: {
            if (!$20) {
             break label$71;
            }
            $6 = HEAP32[$10 + 28 >> 2];
            if (($6 | 0) >= 0) {
             HEAP8[($6 - $15 | 0) + $39 | 0] = 0;
            }
            $11 = HEAP32[$10 + 32 >> 2];
            if (($11 | 0) >= 0) {
             HEAP8[($11 - $15 | 0) + $39 | 0] = 0;
            }
            $6 = 0;
            if (($20 | 0) != 2 | (($11 >> 31 ^ -1) + $27 | 0) <= 0) {
             break label$71;
            }
            $6 = sqlite3VdbeAddOp0($9, 14);
           }
           sqlite3OpenTableAndIndices($0, $8, 113, 0, $15, $39, 0, 0);
           if (!$6) {
            break label$70;
           }
           sqlite3VdbeJumpHereOrPopInst($9, $6);
          }
          if ($20) {
           if (!(HEAP32[$10 + 28 >> 2] == ($13 | 0) | HEAP32[$10 + 32 >> 2] == ($13 | 0))) {
            sqlite3VdbeAddOp4Int($9, 27, $13, $24, $30, $19);
           }
           $15 = $24;
           if (($20 | 0) != 1) {
            $15 = sqlite3VdbeMakeLabel($0);
           }
           sqlite3VdbeAddOp2($9, 50, $21 ? $30 : $12, $24);
           break label$67;
          }
          if (!(!$21 & ($26 ^ 1))) {
           $15 = sqlite3VdbeMakeLabel($0);
           sqlite3VdbeAddOp2($9, 35, $17, $24);
           $32 = sqlite3VdbeCurrentAddr($9);
           if ($26) {
            if (($36 | 0) == 2) {
             break label$67;
            }
            if ($21) {
             $6 = 0;
             $27 = $43 << 16 >> 16;
             $11 = ($27 | 0) > 0 ? $27 : 0;
             while (1) {
              if (($6 | 0) != ($11 | 0)) {
               sqlite3VdbeAddOp3($9, 94, $17, $6, $6 + $7 | 0);
               $6 = $6 + 1 | 0;
               continue;
              }
              break;
             }
             sqlite3VdbeAddOp4Int($9, 27, $13, $15, $7, $27);
             break label$67;
            }
            sqlite3VdbeAddOp2($9, 135, $17, $12);
            sqlite3VdbeAddOp3($9, 30, $13, $15, $12);
            break label$67;
           }
           sqlite3VdbeAddOp2($9, 134, $17, $30);
           sqlite3VdbeAddOp4Int($9, 27, $13, $15, $30, 0);
           break label$67;
          }
          sqlite3VdbeAddOp2($9, 35, $17, $24);
          $15 = sqlite3VdbeMakeLabel($0);
          $32 = sqlite3VdbeAddOp2($9, 135, $17, $12);
          sqlite3VdbeAddOp3($9, 30, $13, $15, $12);
         }
         if ($41) {
          label$83: {
           if ($23) {
            sqlite3ExprCode($0, $45, $22);
            break label$83;
           }
           sqlite3VdbeAddOp3($9, 94, $17, $44, $22);
          }
          sqlite3VdbeAddOp1($9, 12, $22);
         }
         label$85: {
          if (!($35 ? 1 : $31 | $46)) {
           break label$85;
          }
          $6 = 0;
          if ($31) {
           $6 = sqlite3FkOldmask($0, $8);
          }
          $14 = sqlite3TriggerColmask($0, $35, $2, 0, 3, $8, $4) | $6;
          $27 = ($14 | 0) == -1;
          $6 = 0;
          while (1) {
           label$88: {
            label$89: {
             if (HEAP16[$8 + 34 >> 1] > ($6 | 0)) {
              $11 = HEAPU16[(HEAP32[$8 + 4 >> 2] + Math_imul($6, 12) | 0) + 10 >> 1];
              $7 = sqlite3TableColumnToStorage($8, $6 << 16 >> 16) + $25 | 0;
              label$91: {
               if ($27) {
                break label$91;
               }
               if ($6 >>> 0 <= 31) {
                if ($14 >>> $6 & 1 | $11 & 1) {
                 break label$91;
                }
                break label$89;
               }
               if (!($11 & 1)) {
                break label$89;
               }
              }
              sqlite3ExprCodeGetColumnOfTable($9, $8, $13, $6, $7);
              break label$88;
             }
             if ($21 | $41) {
              break label$85;
             }
             sqlite3VdbeAddOp2($9, 80, $12, $22);
             break label$85;
            }
            sqlite3VdbeAddOp2($9, 75, 0, $7);
           }
           $6 = $6 + 1 | 0;
           continue;
          }
         }
         $27 = $43 << 16 >> 16;
         $23 = sqlite3TriggerColmask($0, $35, $2, 1, 1, $8, $4);
         $14 = ($36 | 0) == 2;
         $7 = $18;
         $6 = 0;
         while (1) {
          $11 = HEAP16[$8 + 34 >> 1];
          if (($6 | 0) < ($11 | 0)) {
           label$95: {
            if (HEAP16[$8 + 32 >> 1] == ($6 | 0)) {
             sqlite3VdbeAddOp2($9, 75, 0, $7);
             break label$95;
            }
            $25 = HEAPU16[(HEAP32[$8 + 4 >> 2] + Math_imul($6, 12) | 0) + 10 >> 1];
            if ($25 & 96) {
             $7 = ($25 << 26 >> 31) + $7 | 0;
             break label$95;
            }
            $25 = HEAP32[($6 << 2) + $16 >> 2];
            if (($25 | 0) >= 0) {
             if ($26) {
              sqlite3VdbeAddOp3($9, 94, $17, ($14 ? $11 : $27) + $25 | 0, $7);
              break label$95;
             }
             sqlite3ExprCode($0, HEAP32[(($25 << 4) + $2 | 0) + 8 >> 2], $7);
             break label$95;
            }
            if ($23 >>> $6 & 1 | (!(HEAP8[$10 + 36 | 0] & 1) | $6 >>> 0 > 31)) {
             sqlite3ExprCodeGetColumnOfTable($9, $8, $13, $6, $7);
             $29 = 0;
             break label$95;
            }
            sqlite3VdbeAddOp2($9, 75, 0, $7);
           }
           $7 = $7 + 1 | 0;
           $6 = $6 + 1 | 0;
           continue;
          }
          break;
         }
         if (HEAPU8[$8 + 28 | 0] & 96) {
          sqlite3ComputeGeneratedColumns($0, $18, $8);
         }
         label$102: {
          label$103: {
           if (!(HEAP8[$10 + 36 | 0] & 1)) {
            break label$103;
           }
           sqlite3TableAffinity($9, $8, $18);
           sqlite3CodeRowTrigger($0, $35, 129, $2, 1, $8, $12, $4, $15);
           if (($36 | 0) == 2) {
            break label$102;
           }
           label$104: {
            if ($21) {
             sqlite3VdbeAddOp4Int($9, 27, $13, $15, $30, $19);
             break label$104;
            }
            sqlite3VdbeAddOp3($9, 30, $13, $15, $12);
           }
           $6 = 0;
           $7 = $18;
           while (1) {
            if (($6 | 0) < HEAP16[$8 + 34 >> 1]) {
             $11 = HEAPU16[(HEAP32[$8 + 4 >> 2] + Math_imul($6, 12) | 0) + 10 >> 1];
             label$108: {
              if ($11 & 96) {
               $7 = ($11 << 26 >> 31) + $7 | 0;
               break label$108;
              }
              if (HEAP16[$8 + 32 >> 1] == ($6 | 0) | HEAP32[($6 << 2) + $16 >> 2] >= 0) {
               break label$108;
              }
              sqlite3ExprCodeGetColumnOfTable($9, $8, $13, $6, $7);
             }
             $7 = $7 + 1 | 0;
             $6 = $6 + 1 | 0;
             continue;
            }
            break;
           }
           if (!(HEAPU8[$8 + 28 | 0] & 96)) {
            break label$103;
           }
           sqlite3ComputeGeneratedColumns($0, $18, $8);
          }
          if (($36 | 0) == 2) {
           break label$102;
          }
          sqlite3GenerateConstraintChecks($0, $8, $38, $13, $37, $22, $12, $40 & 255, $4 & 255, $15, $10 + 24 | 0, $16, 0);
          label$110: {
           if (!($40 & 255 ? 1 : HEAP32[$10 + 24 >> 2])) {
            break label$110;
           }
           if ($21) {
            sqlite3VdbeAddOp4Int($9, 27, $13, $15, $30, $19);
            break label$110;
           }
           sqlite3VdbeAddOp3($9, 30, $13, $15, $12);
          }
          if ($31) {
           sqlite3FkCheck($0, $8, $12, 0, $16, $42);
          }
          sqlite3GenerateRowIndexDelete($0, $8, $13, $37, $38, -1);
          if ($29) {
           sqlite3VdbeAddOp1($9, 143, $13);
          }
          if (!($40 & 255 ? 0 : ($31 | 0) <= 1)) {
           sqlite3VdbeAddOp2($9, 130, $13, 0);
          }
          if ($31) {
           sqlite3FkCheck($0, $8, 0, $22, $16, $42);
           sqlite3CompleteInsertion($0, $8, $13, $37, $22, $38, ($20 | 0) == 2 ? 6 : 4, 0, 0);
           sqlite3FkActions($0, $8, $2, $12, $16, $42);
           break label$102;
          }
          sqlite3CompleteInsertion($0, $8, $13, $37, $22, $38, ($20 | 0) == 2 ? 6 : 4, 0, 0);
         }
         if ($28) {
          sqlite3VdbeAddOp2($9, 86, $28, 1);
         }
         sqlite3CodeRowTrigger($0, $35, 129, $2, 2, $8, $12, $4, $15);
         label$117: {
          label$118: {
           switch ($20 - 1 | 0) {
           case 1:
            sqlite3VdbeResolveLabel($9, $15);
            sqlite3WhereEnd($33);
            break label$117;

           case 0:
            break label$117;

           default:
            break label$118;
           }
          }
          sqlite3VdbeResolveLabel($9, $15);
          sqlite3VdbeAddOp2($9, 38, $17, $32);
         }
         sqlite3VdbeResolveLabel($9, $24);
         if (!(HEAPU8[$0 + 18 | 0] | (HEAP32[$0 + 120 >> 2] | $5))) {
          sqlite3AutoincrementEnd($0);
         }
         if (!$28) {
          break label$1;
         }
         sqlite3CodeChangeCount($9, $28, 14945);
         break label$1;
        }
        if (!$6) {
         break label$28;
        }
        $11 = $12 + 1 | 0;
        break label$27;
       }
       $6 = 0;
       $11 = $12 + 1 | 0;
       HEAP8[$39 + $11 | 0] = 0;
      }
      HEAP32[($12 << 2) + $38 >> 2] = $6;
      $23 = $7 + 20 | 0;
      $12 = $11;
      continue;
     }
    }
    HEAP32[($6 << 2) + $16 >> 2] = $14;
   }
   label$121: {
    switch (sqlite3AuthCheck($0, 23, HEAP32[$8 >> 2], $18, HEAP32[HEAP32[$34 + 16 >> 2] + ($22 << 4) >> 2]) - 1 | 0) {
    case 1:
     HEAP32[($6 << 2) + $16 >> 2] = -1;
     break;

    case 0:
     break label$1;

    default:
     break label$121;
    }
   }
   $14 = $14 + 1 | 0;
   continue;
  }
 }
 sqlite3AuthContextPop($10 + 72 | 0);
 sqlite3DbFree($34, $16);
 sqlite3SrcListDelete($34, $1);
 sqlite3ExprListDelete($34, $2);
 sqlite3ExprDelete($34, $3);
 __stack_pointer = $10 + 80 | 0;
}

function lookupName($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $9 = __stack_pointer - 96 | 0;
 __stack_pointer = $9;
 $13 = HEAP32[$0 >> 2];
 HEAP32[$9 + 92 >> 2] = 0;
 HEAP32[$5 + 28 >> 2] = -1;
 label$1: {
  if (!$1 | HEAPU8[$4 + 24 | 0] & 6) {
   break label$1;
  }
  $8 = HEAP32[$13 + 20 >> 2];
  $10 = ($8 | 0) > 0 ? $8 : 0;
  while (1) {
   label$3: {
    label$4: {
     if (($6 | 0) == ($10 | 0)) {
      $6 = $10;
      break label$4;
     }
     $7 = HEAP32[$13 + 16 >> 2];
     if (sqlite3StrICmp(HEAP32[$7 + ($6 << 4) >> 2], $1)) {
      break label$3;
     }
     $17 = HEAP32[(($6 << 4) + $7 | 0) + 12 >> 2];
    }
    if (($6 | 0) != ($8 | 0)) {
     $16 = $1;
     break label$1;
    }
    $16 = $1;
    if (sqlite3StrICmp(10765, $1)) {
     break label$1;
    }
    $6 = HEAP32[$13 + 16 >> 2];
    $16 = HEAP32[$6 >> 2];
    $17 = HEAP32[$6 + 12 >> 2];
    break label$1;
   }
   $6 = $6 + 1 | 0;
   continue;
  }
 }
 $23 = $5 + 44 | 0;
 $20 = 167;
 $12 = $4;
 label$7: {
  label$8: {
   label$9: {
    label$10: {
     label$11: {
      label$12: {
       label$13: {
        while (1) {
         label$15: {
          $21 = HEAP32[$12 + 4 >> 2];
          if (!$21) {
           $10 = 0;
           break label$15;
          }
          $7 = $21 + 8 | 0;
          $10 = 0;
          $22 = 0;
          while (1) {
           label$18: {
            label$19: {
             label$20: {
              if (HEAP32[$21 >> 2] > ($22 | 0)) {
               $18 = HEAP32[$7 + 16 >> 2];
               label$22: {
                label$23: {
                 if (HEAPU8[$7 + 38 | 0] & 32) {
                  $1 = HEAP32[HEAP32[$7 + 20 >> 2] + 28 >> 2];
                  $15 = 0;
                  $6 = 0;
                  while (1) {
                   if (HEAP32[$1 >> 2] > ($6 | 0)) {
                    label$27: {
                     $8 = ($6 << 4) + $1 | 0;
                     if (!sqlite3MatchEName($8 + 8 | 0, $3, $2, $16)) {
                      break label$27;
                     }
                     label$28: {
                      if (($10 | 0) <= 0) {
                       break label$28;
                      }
                      label$29: {
                       if (HEAPU8[$7 + 38 | 0] & 4) {
                        if ((sqlite3IdListIndex(HEAP32[$7 + 44 >> 2], $3) | 0) >= 0) {
                         break label$29;
                        }
                       }
                       sqlite3ExprListDelete($13, HEAP32[$9 + 92 >> 2]);
                       HEAP32[$9 + 92 >> 2] = 0;
                       break label$28;
                      }
                      $19 = HEAPU8[$7 + 36 | 0];
                      if (!($19 & 16)) {
                       break label$27;
                      }
                      if (!($19 & 8)) {
                       sqlite3ExprListDelete($13, HEAP32[$9 + 92 >> 2]);
                       $10 = 0;
                       HEAP32[$9 + 92 >> 2] = 0;
                       break label$28;
                      }
                      extendFJMatch($0, $9 + 92 | 0, $11, HEAP16[$5 + 32 >> 1]);
                     }
                     HEAP16[$5 + 32 >> 1] = $6;
                     $14 = $8;
                     $8 = $8 + 17 | 0;
                     $11 = $8;
                     $8 = HEAPU8[$14 + 17 | 0] | HEAPU8[$14 + 18 | 0] << 8;
                     $14 = $8 | 64;
                     HEAP8[$11 | 0] = $14;
                     HEAP8[$11 + 1 | 0] = $14 >>> 8;
                     $15 = 1;
                     $10 = $10 + 1 | 0;
                     $14 = 2;
                     $11 = $7;
                     if (!($8 & 128)) {
                      break label$27;
                     }
                     break label$18;
                    }
                    $6 = $6 + 1 | 0;
                    continue;
                   }
                   break;
                  }
                  if (!$2) {
                   break label$18;
                  }
                  if (!$15) {
                   break label$23;
                  }
                  break label$18;
                 }
                 if (!$2) {
                  break label$22;
                 }
                }
                label$32: {
                 if (!$16) {
                  break label$32;
                 }
                 if (HEAP32[$18 + 60 >> 2] != ($17 | 0)) {
                  break label$18;
                 }
                 if ($17) {
                  break label$32;
                 }
                 if (strcmp($16, 24304)) {
                  break label$18;
                 }
                }
                $1 = HEAP32[$7 + 12 >> 2];
                $6 = $1;
                if (!$6) {
                 $6 = HEAP32[$18 >> 2];
                }
                if (sqlite3StrICmp($6, $2)) {
                 break label$18;
                }
                if (!$1 | HEAPU8[$0 + 208 | 0] < 2) {
                 break label$22;
                }
                sqlite3RenameTokenRemap($0, 0, $23);
               }
               $15 = sqlite3StrIHash($3);
               $1 = 0;
               $6 = HEAP16[$18 + 34 >> 1];
               $8 = ($6 | 0) > 0 ? $6 : 0;
               $6 = HEAP32[$18 + 4 >> 2];
               while (1) {
                if (($1 | 0) == ($8 | 0)) {
                 break label$19;
                }
                label$35: {
                 if (HEAPU8[$6 + 7 | 0] != ($15 | 0)) {
                  break label$35;
                 }
                 if (sqlite3StrICmp(HEAP32[$6 >> 2], $3)) {
                  break label$35;
                 }
                 label$36: {
                  if (($10 | 0) <= 0) {
                   break label$36;
                  }
                  label$37: {
                   if (HEAPU8[$7 + 38 | 0] & 4) {
                    if ((sqlite3IdListIndex(HEAP32[$7 + 44 >> 2], $3) | 0) >= 0) {
                     break label$37;
                    }
                   }
                   sqlite3ExprListDelete($13, HEAP32[$9 + 92 >> 2]);
                   HEAP32[$9 + 92 >> 2] = 0;
                   break label$36;
                  }
                  $19 = HEAPU8[$7 + 36 | 0];
                  if (!($19 & 16)) {
                   break label$35;
                  }
                  if (!($19 & 8)) {
                   sqlite3ExprListDelete($13, HEAP32[$9 + 92 >> 2]);
                   $10 = 0;
                   HEAP32[$9 + 92 >> 2] = 0;
                   break label$36;
                  }
                  extendFJMatch($0, $9 + 92 | 0, $11, HEAP16[$5 + 32 >> 1]);
                 }
                 HEAP16[$5 + 32 >> 1] = HEAP16[$18 + 32 >> 1] == ($1 | 0) ? -1 : $1;
                 $10 = $10 + 1 | 0;
                 if (!(HEAPU8[$7 + 38 | 0] & 32)) {
                  break label$20;
                 }
                 sqlite3SrcItemColumnUsed($7, $1);
                 break label$20;
                }
                $6 = $6 + 12 | 0;
                $1 = $1 + 1 | 0;
                continue;
               }
              }
              if (!$11) {
               $11 = 0;
               break label$15;
              }
              HEAP32[$5 + 28 >> 2] = HEAP32[$11 + 40 >> 2];
              $6 = HEAP32[$11 + 16 >> 2];
              HEAP32[$5 + 44 >> 2] = $6;
              if (HEAPU8[$11 + 36 | 0] & 72) {
               HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] | 2097152;
              }
              $17 = HEAP32[$6 + 60 >> 2];
              break label$15;
             }
             $11 = $7;
            }
            if ($10) {
             break label$18;
            }
            $6 = HEAP32[$18 + 28 >> 2] & 512;
            $11 = $6 ? $11 : $7;
            $14 = ($6 >>> 9 ^ 1) + $14 | 0;
            $10 = 0;
           }
           $7 = $7 - -64 | 0;
           $22 = $22 + 1 | 0;
           continue;
          }
         }
         label$42: {
          if ($10 | $16) {
           break label$42;
          }
          $8 = 0;
          $6 = HEAP32[$0 + 120 >> 2];
          label$43: {
           if (!$6) {
            break label$43;
           }
           $1 = HEAPU8[$0 + 148 | 0];
           label$44: {
            if (HEAPU8[$0 + 149 | 0]) {
             if (!(HEAPU8[$12 + 25 | 0] & 4)) {
              break label$43;
             }
             if ($2) {
              if (sqlite3StrICmp($2, HEAP32[$6 >> 2])) {
               break label$43;
              }
             }
             $8 = ($1 & 255) != 128;
             break label$44;
            }
            label$47: {
             if (!$2 | ($1 & 255) == 128) {
              break label$47;
             }
             if (sqlite3StrICmp(1725, $2)) {
              break label$47;
             }
             $8 = 1;
             break label$44;
            }
            if (!$2 | ($1 & 255) == 127) {
             break label$43;
            }
            if (sqlite3StrICmp(14296, $2)) {
             break label$43;
            }
           }
           HEAP32[$5 + 28 >> 2] = $8;
           $8 = $6;
          }
          label$48: {
           if (!$2 | !(HEAP32[$12 + 24 >> 2] & 512)) {
            break label$48;
           }
           $6 = HEAP32[$12 + 8 >> 2];
           if (!$6) {
            break label$48;
           }
           if (sqlite3StrICmp(15777, $2)) {
            break label$48;
           }
           $8 = HEAP32[HEAP32[$6 + 32 >> 2] + 24 >> 2];
           HEAP32[$5 + 28 >> 2] = 2;
          }
          if (!$8) {
           $10 = 0;
           break label$42;
          }
          $10 = sqlite3StrIHash($3);
          $1 = 0;
          $15 = HEAP16[$8 + 34 >> 1];
          $7 = ($15 | 0) > 0 ? $15 : 0;
          $14 = $14 + 1 | 0;
          $6 = HEAP32[$8 + 4 >> 2];
          $17 = HEAP32[$8 + 60 >> 2];
          label$50: {
           label$51: {
            while (1) {
             if (($1 | 0) == ($7 | 0)) {
              break label$51;
             }
             label$53: {
              if (HEAPU8[$6 + 7 | 0] == ($10 | 0)) {
               if (!sqlite3StrICmp(HEAP32[$6 >> 2], $3)) {
                break label$53;
               }
              }
              $6 = $6 + 12 | 0;
              $1 = $1 + 1 | 0;
              continue;
             }
             break;
            }
            $7 = HEAP16[$8 + 32 >> 1] == ($1 | 0) ? -1 : $1;
            if (($15 | 0) > ($7 | 0)) {
             break label$50;
            }
           }
           if (!sqlite3IsRowid($3)) {
            break label$50;
           }
           $7 = HEAPU8[$8 + 29 | 0] & 2 ? $7 : -1;
          }
          $10 = 0;
          if (($7 | 0) >= ($15 | 0)) {
           break label$42;
          }
          label$55: {
           label$56: {
            $6 = HEAP32[$5 + 28 >> 2];
            if (($6 | 0) == 2) {
             if (HEAPU8[$0 + 208 | 0] >= 2) {
              HEAP32[$5 + 44 >> 2] = $8;
              HEAP16[$5 + 32 >> 1] = $7;
              $10 = 1;
              $20 = 167;
              break label$55;
             }
             HEAP32[$5 + 28 >> 2] = HEAP32[HEAP32[$12 + 8 >> 2] + 36 >> 2] + sqlite3TableColumnToStorage($8, $7 << 16 >> 16);
             $10 = 1;
             break label$56;
            }
            HEAP32[$23 >> 2] = $8;
            if (HEAPU8[$0 + 149 | 0]) {
             HEAP8[$5 + 2 | 0] = 167;
             $10 = 1;
             HEAP32[$5 + 28 >> 2] = ((HEAP32[$12 + 8 >> 2] + sqlite3TableColumnToStorage($8, $7 << 16 >> 16) | 0) + Math_imul(HEAP16[$8 + 34 >> 1] + 1 | 0, $6) | 0) + 1;
             break label$56;
            }
            HEAP16[$5 + 32 >> 1] = $7;
            label$60: {
             if (($7 | 0) < 0) {
              HEAP8[$5 + 1 | 0] = 68;
              break label$60;
             }
             $1 = $7 >>> 0 > 31 ? -1 : 1 << $7;
             if (!$6) {
              HEAP32[$0 + 140 >> 2] = HEAP32[$0 + 140 >> 2] | $1;
              break label$60;
             }
             HEAP32[$0 + 144 >> 2] = HEAP32[$0 + 144 >> 2] | $1;
            }
            $10 = 1;
            $20 = 77;
            break label$55;
           }
           $20 = 176;
          }
          $11 = 0;
         }
         label$63: {
          if (!(!$11 | (($14 | 0) != 1 | $10))) {
           $8 = HEAP32[$12 + 24 >> 2];
           if ($8 & 40) {
            break label$63;
           }
           if (!sqlite3IsRowid($3) | HEAPU8[HEAP32[$11 + 16 >> 2] + 29 | 0] & 2) {
            break label$63;
           }
           HEAP8[$5 + 1 | 0] = 68;
           HEAP16[$5 + 32 >> 1] = 65535;
           $1 = 1;
           break label$9;
          }
          if ($10) {
           break label$13;
          }
          $8 = HEAP32[$12 + 24 >> 2];
         }
         label$65: {
          if (!($8 & 128) | $2) {
           break label$65;
          }
          $6 = 0;
          $7 = HEAP32[$12 + 8 >> 2];
          $1 = HEAP32[$7 >> 2];
          $10 = ($1 | 0) > 0 ? $1 : 0;
          while (1) {
           if (($6 | 0) == ($10 | 0)) {
            break label$65;
           }
           label$67: {
            $1 = ($6 << 4) + $7 | 0;
            if (HEAPU8[$1 + 17 | 0] & 3) {
             break label$67;
            }
            $1 = HEAP32[$1 + 12 >> 2];
            if (sqlite3_stricmp($1, $3)) {
             break label$67;
            }
            $3 = HEAP32[(($6 << 4) + $7 | 0) + 8 >> 2];
            $10 = HEAP32[$3 + 4 >> 2];
            if (!(!($10 & 16) | $8 & 1)) {
             HEAP32[$9 + 80 >> 2] = $1;
             sqlite3ErrorMsg($0, 6324, $9 + 80 | 0);
             break label$10;
            }
            if (!(!($10 & 32768) | (($4 | 0) == ($12 | 0) ? $8 & 16384 : 0))) {
             HEAP32[$9 + 64 >> 2] = $1;
             sqlite3ErrorMsg($0, 6128, $9 - -64 | 0);
             break label$10;
            }
            if ((sqlite3ExprVectorSize($3) | 0) != 1) {
             sqlite3ErrorMsg($0, 14966, 0);
             break label$10;
            }
            resolveAlias($0, $7, $6, $5, $24);
            if (HEAPU8[$0 + 208 | 0] < 2) {
             break label$8;
            }
            sqlite3RenameTokenRemap($0, 0, $5);
            break label$8;
           }
           $6 = $6 + 1 | 0;
           continue;
          }
         }
         $24 = $24 + 1 | 0;
         $12 = HEAP32[$12 + 12 >> 2];
         if ($12) {
          continue;
         }
         break;
        }
        $7 = 10501;
        $12 = 0;
        if ($2) {
         break label$12;
        }
        label$71: {
         if (!(HEAPU8[$5 + 4 | 0] & 128)) {
          break label$71;
         }
         if (!areDoubleQuotedStringsEnabled($13, $4)) {
          break label$71;
         }
         HEAP32[$9 + 48 >> 2] = $3;
         sqlite3_log(28, 28418, $9 + 48 | 0);
         sqlite3VdbeAddDblquoteStr($13, HEAP32[$0 + 8 >> 2], $3);
         HEAP32[$5 + 44 >> 2] = 0;
         HEAP32[$5 + 48 >> 2] = 0;
         HEAP8[$5 | 0] = 117;
         $6 = 1;
         break label$7;
        }
        $6 = 1;
        if (sqlite3ExprIdToTrueFalse($5)) {
         break label$7;
        }
        break label$12;
       }
       $1 = 1;
       $7 = 13289;
       if (($10 | 0) == 1) {
        break label$9;
       }
       break label$11;
      }
      $10 = 0;
     }
     label$72: {
      label$73: {
       $6 = HEAP32[$9 + 92 >> 2];
       if ($6) {
        if (HEAP32[$6 >> 2] == ($10 - 1 | 0)) {
         $6 = HEAP32[$5 + 4 >> 2];
         if (!($6 & 8388608)) {
          break label$73;
         }
         HEAP32[$5 + 4 >> 2] = $6 & -8388609;
         break label$72;
        }
        sqlite3ExprListDelete($13, $6);
        HEAP32[$9 + 92 >> 2] = 0;
       }
       label$76: {
        if ($16) {
         HEAP32[$9 + 44 >> 2] = $3;
         HEAP32[$9 + 40 >> 2] = $2;
         HEAP32[$9 + 36 >> 2] = $16;
         HEAP32[$9 + 32 >> 2] = $7;
         sqlite3ErrorMsg($0, 5861, $9 + 32 | 0);
         break label$76;
        }
        if ($2) {
         HEAP32[$9 + 24 >> 2] = $3;
         HEAP32[$9 + 20 >> 2] = $2;
         HEAP32[$9 + 16 >> 2] = $7;
         sqlite3ErrorMsg($0, 5984, $9 + 16 | 0);
         break label$76;
        }
        HEAP32[$9 + 4 >> 2] = $3;
        HEAP32[$9 >> 2] = $7;
        sqlite3ErrorMsg($0, 7253, $9);
       }
       sqlite3RecordErrorOffsetOfExpr(HEAP32[$0 >> 2], $5);
       HEAP8[$0 + 17 | 0] = 1;
       HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
       $1 = $10;
       break label$9;
      }
      sqlite3ExprDelete($13, HEAP32[$5 + 12 >> 2]);
      HEAP32[$5 + 12 >> 2] = 0;
      sqlite3ExprDelete($13, HEAP32[$5 + 16 >> 2]);
      HEAP32[$5 + 16 >> 2] = 0;
     }
     extendFJMatch($0, $9 + 92 | 0, $11, HEAP16[$5 + 32 >> 1]);
     HEAP32[$5 + 8 >> 2] = 14079;
     HEAP8[$5 | 0] = 172;
     HEAP32[$5 + 20 >> 2] = HEAP32[$9 + 92 >> 2];
     break label$8;
    }
    $6 = 2;
    break label$7;
   }
   if (!(HEAPU8[$5 + 6 | 0] & 129)) {
    sqlite3ExprDelete($13, HEAP32[$5 + 12 >> 2]);
    HEAP32[$5 + 12 >> 2] = 0;
    sqlite3ExprDelete($13, HEAP32[$5 + 16 >> 2]);
    HEAP32[$5 + 16 >> 2] = 0;
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] | 8388608;
   }
   if (!(!$11 | HEAP16[$5 + 32 >> 1] < 0)) {
    $2 = HEAP32[$11 + 52 >> 2];
    HEAP32[$11 + 48 >> 2] = HEAP32[$11 + 48 >> 2] | sqlite3ExprColUsed($5);
    HEAP32[$11 + 52 >> 2] = i64toi32_i32$HIGH_BITS | $2;
   }
   HEAP8[$5 | 0] = $20;
   $6 = 2;
   if (($1 | 0) != 1) {
    break label$7;
   }
  }
  label$81: {
   if (!HEAP32[HEAP32[$0 >> 2] + 360 >> 2]) {
    break label$81;
   }
   $6 = HEAPU8[$5 | 0];
   if (($6 | 0) != 167 & ($6 | 0) != 77) {
    break label$81;
   }
   sqlite3AuthRead($0, $5, $17, HEAP32[$12 + 4 >> 2]);
  }
  while (1) {
   $6 = 1;
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] + 1;
   if (($4 | 0) == ($12 | 0)) {
    break label$7;
   }
   $4 = HEAP32[$4 + 12 >> 2];
   continue;
  }
 }
 __stack_pointer = $9 + 96 | 0;
 return $6;
}

function sqlite3GetToken($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = 1;
 $5 = 1;
 $2 = 1;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$10: {
           label$11: {
            label$12: {
             label$13: {
              label$14: {
               label$15: {
                label$16: {
                 label$17: {
                  label$18: {
                   label$19: {
                    label$20: {
                     label$21: {
                      label$22: {
                       label$23: {
                        label$24: {
                         label$25: {
                          label$26: {
                           label$27: {
                            label$28: {
                             label$29: {
                              label$30: {
                               label$31: {
                                label$32: {
                                 label$33: {
                                  label$34: {
                                   label$35: {
                                    $6 = HEAPU8[$0 | 0];
                                    $4 = HEAPU8[$6 + 33504 | 0];
                                    switch ($4 | 0) {
                                    case 30:
                                     break label$10;

                                    case 0:
                                     break label$11;

                                    case 1:
                                     break label$12;

                                    case 4:
                                    case 5:
                                     break label$13;

                                    case 6:
                                     break label$14;

                                    case 9:
                                     break label$15;

                                    case 3:
                                     break label$16;

                                    case 26:
                                     break label$17;

                                    case 8:
                                     break label$18;

                                    case 25:
                                     break label$19;

                                    case 24:
                                     break label$20;

                                    case 23:
                                     break label$21;

                                    case 10:
                                     break label$22;

                                    case 15:
                                     break label$23;

                                    case 13:
                                     break label$24;

                                    case 12:
                                     break label$25;

                                    case 14:
                                     break label$26;

                                    case 22:
                                     break label$27;

                                    case 16:
                                     break label$28;

                                    case 21:
                                     break label$29;

                                    case 20:
                                     break label$30;

                                    case 19:
                                     break label$31;

                                    case 18:
                                     break label$32;

                                    case 17:
                                     break label$33;

                                    case 11:
                                     break label$34;

                                    case 7:
                                     break label$35;

                                    case 2:
                                    case 27:
                                     break label$5;

                                    case 29:
                                     break label$9;

                                    default:
                                     break label$8;
                                    }
                                   }
                                   while (1) {
                                    $2 = $5;
                                    $5 = $2 + 1 | 0;
                                    if (HEAP8[HEAPU8[$0 + $2 | 0] + 30288 | 0] & 1) {
                                     continue;
                                    }
                                    break;
                                   }
                                   HEAP32[$1 >> 2] = 183;
                                   return $2;
                                  }
                                  label$37: {
                                   $2 = HEAPU8[$0 + 1 | 0];
                                   if (($2 | 0) != 62) {
                                    if (($2 | 0) != 45) {
                                     break label$37;
                                    }
                                    $2 = 2;
                                    while (1) {
                                     $3 = HEAPU8[$0 + $2 | 0];
                                     if (!(!$3 | ($3 | 0) == 10)) {
                                      $2 = $2 + 1 | 0;
                                      continue;
                                     }
                                     break;
                                    }
                                    HEAP32[$1 >> 2] = 183;
                                    return $2;
                                   }
                                   HEAP32[$1 >> 2] = 112;
                                   return HEAPU8[$0 + 2 | 0] == 62 ? 3 : 2;
                                  }
                                  HEAP32[$1 >> 2] = 107;
                                  break label$6;
                                 }
                                 HEAP32[$1 >> 2] = 22;
                                 break label$6;
                                }
                                HEAP32[$1 >> 2] = 23;
                                break label$6;
                               }
                               HEAP32[$1 >> 2] = 1;
                               return 1;
                              }
                              HEAP32[$1 >> 2] = 106;
                              break label$6;
                             }
                             HEAP32[$1 >> 2] = 108;
                             break label$6;
                            }
                            if (HEAPU8[$0 + 1 | 0] != 42) {
                             break label$7;
                            }
                            $2 = HEAPU8[$0 + 2 | 0];
                            if (!$2) {
                             break label$7;
                            }
                            $3 = 3;
                            label$41: {
                             while (1) {
                              $4 = $2 & 255;
                              $2 = HEAPU8[$0 + $3 | 0];
                              if (!(($4 | 0) == 42 & ($2 | 0) == 47)) {
                               if (!($2 & 255)) {
                                break label$41;
                               }
                               $3 = $3 + 1 | 0;
                               continue;
                              }
                              break;
                             }
                             $3 = $3 + 1 | 0;
                            }
                            HEAP32[$1 >> 2] = 183;
                            break label$2;
                           }
                           HEAP32[$1 >> 2] = 110;
                           break label$6;
                          }
                          HEAP32[$1 >> 2] = 53;
                          return HEAPU8[$0 + 1 | 0] == 61 ? 2 : 1;
                         }
                         label$44: {
                          switch (HEAPU8[$0 + 1 | 0] - 60 | 0) {
                          case 1:
                           HEAP32[$1 >> 2] = 55;
                           break label$1;

                          case 2:
                           HEAP32[$1 >> 2] = 52;
                           break label$1;

                          case 0:
                           HEAP32[$1 >> 2] = 104;
                           break label$1;

                          default:
                           break label$44;
                          }
                         }
                         HEAP32[$1 >> 2] = 56;
                         break label$6;
                        }
                        label$48: {
                         switch (HEAPU8[$0 + 1 | 0] - 61 | 0) {
                         case 0:
                          HEAP32[$1 >> 2] = 57;
                          break label$1;

                         case 1:
                          HEAP32[$1 >> 2] = 105;
                          break label$1;

                         default:
                          break label$48;
                         }
                        }
                        HEAP32[$1 >> 2] = 54;
                        break label$6;
                       }
                       if (HEAPU8[$0 + 1 | 0] != 61) {
                        HEAP32[$1 >> 2] = 184;
                        break label$6;
                       }
                       HEAP32[$1 >> 2] = 52;
                       break label$1;
                      }
                      if (HEAPU8[$0 + 1 | 0] != 124) {
                       HEAP32[$1 >> 2] = 103;
                       break label$6;
                      }
                      HEAP32[$1 >> 2] = 111;
                      break label$1;
                     }
                     HEAP32[$1 >> 2] = 25;
                     break label$6;
                    }
                    HEAP32[$1 >> 2] = 102;
                    break label$6;
                   }
                   HEAP32[$1 >> 2] = 114;
                   break label$6;
                  }
                  label$53: {
                   while (1) {
                    $2 = HEAPU8[$0 + $3 | 0];
                    if (!$2) {
                     break label$53;
                    }
                    label$55: {
                     if (($2 | 0) == ($6 | 0)) {
                      $3 = $3 + 1 | 0;
                      if (HEAPU8[$3 + $0 | 0] != ($6 | 0)) {
                       break label$55;
                      }
                     }
                     $3 = $3 + 1 | 0;
                     continue;
                    }
                    break;
                   }
                   if (($6 | 0) == 39) {
                    HEAP32[$1 >> 2] = 117;
                    break label$2;
                   }
                   HEAP32[$1 >> 2] = 59;
                   break label$2;
                  }
                  HEAP32[$1 >> 2] = 184;
                  break label$2;
                 }
                 if (HEAPU8[$0 + 1 | 0] - 58 >>> 0 > 4294967285) {
                  break label$16;
                 }
                 HEAP32[$1 >> 2] = 141;
                 break label$6;
                }
                HEAP32[$1 >> 2] = 155;
                if (!(HEAPU8[HEAPU8[$0 + 2 | 0] + 30288 | 0] & 8) | (HEAPU8[$0 | 0] != 48 | (HEAPU8[$0 + 1 | 0] | 32) != 120)) {
                 break label$4;
                }
                $3 = 3;
                while (1) {
                 $2 = $3;
                 $3 = $2 + 1 | 0;
                 if (HEAPU8[HEAPU8[$0 + $2 | 0] + 30288 | 0] & 8) {
                  continue;
                 }
                 break;
                }
                break label$3;
               }
               label$59: {
                while (1) {
                 $2 = 59;
                 if (($6 | 0) == 93) {
                  break label$59;
                 }
                 $6 = HEAPU8[$0 + $3 | 0];
                 if ($6) {
                  $3 = $3 + 1 | 0;
                  continue;
                 }
                 break;
                }
                $2 = 184;
               }
               $0 = $2;
               HEAP32[$1 >> 2] = $0;
               break label$2;
              }
              HEAP32[$1 >> 2] = 156;
              while (1) {
               $2 = $3;
               $3 = $2 + 1 | 0;
               if (HEAPU8[$0 + $2 | 0] - 58 >>> 0 >= 4294967286) {
                continue;
               }
               break;
              }
              break label$3;
             }
             HEAP32[$1 >> 2] = 156;
             $4 = 0;
             label$63: {
              while (1) {
               $3 = HEAPU8[$0 + $2 | 0];
               if (!$3) {
                break label$63;
               }
               label$65: {
                label$66: {
                 if (HEAPU8[$3 + 30288 | 0] & 70) {
                  $4 = $4 + 1 | 0;
                  break label$66;
                 }
                 if (!(($3 | 0) != 40 | ($4 | 0) <= 0)) {
                  while (1) {
                   $5 = $2;
                   $2 = $2 + 1 | 0;
                   $3 = HEAPU8[$2 + $0 | 0];
                   if (!$3) {
                    break label$65;
                   }
                   if (!(HEAP8[$3 + 30288 | 0] & 1) & ($3 | 0) != 41) {
                    continue;
                   }
                   break;
                  }
                  if (($3 | 0) != 41) {
                   break label$65;
                  }
                  $2 = $5 + 2 | 0;
                  break label$63;
                 }
                 if (($3 | 0) != 58) {
                  break label$63;
                 }
                 $3 = $2 + 1 | 0;
                 if (HEAPU8[$3 + $0 | 0] != 58) {
                  break label$63;
                 }
                 $2 = $3;
                }
                $2 = $2 + 1 | 0;
                continue;
               }
               break;
              }
              HEAP32[$1 >> 2] = 184;
             }
             if ($4) {
              break label$3;
             }
             HEAP32[$1 >> 2] = 184;
             return $2;
            }
            while (1) {
             $3 = $4;
             $4 = $3 + 1 | 0;
             $5 = HEAPU8[$0 + $3 | 0];
             if (HEAPU8[$5 + 33504 | 0] < 3) {
              continue;
             }
             break;
            }
            $2 = $4;
            if (HEAPU8[$5 + 30288 | 0] & 70) {
             break label$5;
            }
            HEAP32[$1 >> 2] = 59;
            return keywordCode($0, $3, $1);
           }
           if (HEAPU8[$0 + 1 | 0] != 39) {
            break label$5;
           }
           HEAP32[$1 >> 2] = 154;
           $3 = 2;
           while (1) {
            $2 = $3;
            $3 = $2 + 1 | 0;
            $4 = HEAPU8[$0 + $2 | 0];
            if (HEAPU8[$4 + 30288 | 0] & 8) {
             continue;
            }
            break;
           }
           label$72: {
            if (($4 | 0) == 39) {
             $3 = 1;
             if (!($2 & 1)) {
              break label$72;
             }
            }
            HEAP32[$1 >> 2] = 184;
            while (1) {
             $3 = HEAPU8[$0 + $2 | 0];
             if (!(!$3 | ($3 | 0) == 39)) {
              $2 = $2 + 1 | 0;
              continue;
             }
             break;
            }
            $3 = ($3 | 0) != 0;
           }
           return $3 + $2 | 0;
          }
          if (HEAPU8[$0 + 1 | 0] != 187 | HEAPU8[$0 + 2 | 0] != 191) {
           break label$5;
          }
          HEAP32[$1 >> 2] = 183;
          return 3;
         }
         HEAP32[$1 >> 2] = 184;
         return 0;
        }
        HEAP32[$1 >> 2] = 184;
        break label$6;
       }
       HEAP32[$1 >> 2] = 109;
      }
      $2 = 1;
      break label$3;
     }
     while (1) {
      $3 = $2;
      $2 = $2 + 1 | 0;
      if (HEAPU8[HEAPU8[$0 + $3 | 0] + 30288 | 0] & 70) {
       continue;
      }
      break;
     }
     HEAP32[$1 >> 2] = 59;
     break label$2;
    }
    $3 = 0;
    while (1) {
     $2 = $3;
     $3 = $2 + 1 | 0;
     $4 = HEAPU8[$0 + $2 | 0];
     if ($4 - 58 >>> 0 > 4294967285) {
      continue;
     }
     break;
    }
    if (($4 | 0) == 46) {
     while (1) {
      $2 = $2 + 1 | 0;
      $3 = $2 + $0 | 0;
      if (HEAPU8[$3 | 0] - 58 >>> 0 > 4294967285) {
       continue;
      }
      break;
     }
     HEAP32[$1 >> 2] = 153;
     $4 = HEAPU8[$3 | 0];
    }
    label$80: {
     if ((($4 | 32) & 255) != 101) {
      break label$80;
     }
     $3 = HEAPU8[($0 + $2 | 0) + 1 | 0];
     label$81: {
      if ($3 - 58 >>> 0 >= 4294967286) {
       $3 = $2 + 2 | 0;
       break label$81;
      }
      label$83: {
       switch ($3 - 43 | 0) {
       case 0:
       case 2:
        break label$83;

       default:
        break label$80;
       }
      }
      $3 = $2 + 2 | 0;
      if (HEAPU8[$3 + $0 | 0] - 58 >>> 0 < 4294967286) {
       break label$80;
      }
     }
     while (1) {
      $2 = $3;
      $3 = $2 + 1 | 0;
      if (HEAPU8[$0 + $2 | 0] - 58 >>> 0 > 4294967285) {
       continue;
      }
      break;
     }
     HEAP32[$1 >> 2] = 153;
    }
    while (1) {
     if (!(HEAPU8[HEAPU8[$0 + $2 | 0] + 30288 | 0] & 70)) {
      break label$3;
     }
     HEAP32[$1 >> 2] = 184;
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   return $2;
  }
  return $3;
 }
 return 2;
}

function __multf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0;
 $19 = __stack_pointer - 96 | 0;
 __stack_pointer = $19;
 $13 = $7;
 $25 = $13;
 $9 = $8;
 $12 = $9 & 65535;
 $24 = $12;
 $12 = $4;
 $13 = $12 ^ $9;
 $9 = $3;
 $11 = $7;
 $9 = $13 & -2147483648;
 $15 = $9;
 $9 = $4;
 $12 = $9 & 65535;
 $22 = $12;
 $13 = $3;
 $23 = $13;
 $9 = $13;
 $32 = $12;
 $13 = 0;
 $33 = $13;
 $13 = $8;
 $20 = $13 >>> 16 & 32767;
 $9 = $4;
 $29 = $9 >>> 16 & 32767;
 label$1: {
  label$2: {
   if ($20 - 32767 >>> 0 > 4294934529 & $29 - 32767 >>> 0 >= 4294934530) {
    break label$2;
   }
   $12 = $2;
   $10 = !($12 | $1);
   $12 = $4;
   $13 = $12 & 2147483647;
   $17 = $13;
   $14 = $13 >>> 0 < 2147418112;
   $12 = $13;
   $9 = $3;
   $16 = $9;
   $11 = $9;
   if (!(!$11 & ($12 | 0) == 2147418112 ? $10 : $14)) {
    $9 = $3;
    $18 = $9;
    $11 = $4;
    $12 = $11 | 32768;
    $15 = $12;
    break label$1;
   }
   $12 = $6;
   $10 = !($12 | $5);
   $12 = $8;
   $9 = $12 & 2147483647;
   $4 = $9;
   $14 = $9 >>> 0 < 2147418112;
   $12 = $9;
   $11 = $7;
   $3 = $11;
   $13 = $11;
   if (!(!$13 & ($12 | 0) == 2147418112 ? $10 : $14)) {
    $11 = $7;
    $18 = $11;
    $13 = $8;
    $12 = $13 | 32768;
    $15 = $12;
    $1 = $5;
    $12 = $6;
    $2 = $12;
    break label$1;
   }
   $12 = $17;
   $11 = $12 ^ 2147418112;
   $13 = $16;
   $9 = $13;
   $12 = $1;
   $13 = $11;
   $11 = $2;
   $13 = $13 | $11;
   if (!($9 | $12 | $13)) {
    $12 = $6;
    $13 = $4;
    $12 = $12 | $13;
    $9 = $5;
    $11 = $3;
    if (!($12 | ($9 | $11))) {
     $15 = 2147450880;
     $1 = 0;
     $2 = 0;
     break label$1;
    }
    $13 = $18;
    $18 = $13;
    $12 = $15;
    $11 = $12 | 2147418112;
    $15 = $11;
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $11 = $4;
   $13 = $11 ^ 2147418112;
   $12 = $3;
   $9 = $12;
   $11 = $5;
   $12 = $13;
   $13 = $6;
   $12 = $12 | $13;
   if (!($9 | $11 | $12)) {
    $9 = $16;
    $13 = $1;
    $3 = $9 | $13;
    $12 = $2;
    $11 = $17;
    $11 = $12 | $11;
    $1 = 0;
    $2 = 0;
    if (!($11 | $3)) {
     $15 = 2147450880;
     break label$1;
    }
    $12 = $18;
    $18 = $12;
    $11 = $15;
    $13 = $11 | 2147418112;
    $15 = $13;
    break label$1;
   }
   $12 = $17;
   $13 = $2;
   $12 = $12 | $13;
   $9 = $16;
   $11 = $1;
   if (!($12 | ($9 | $11))) {
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $12 = $4;
   $11 = $6;
   $11 = $12 | $11;
   $9 = $5;
   $13 = $3;
   if (!($11 | ($9 | $13))) {
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $11 = $17;
   if (($11 | 0) == 65535 | $11 >>> 0 < 65535) {
    $12 = $22;
    $21 = !($12 | $23);
    $14 = $21;
    $13 = $14 ? $1 : $23;
    $12 = $2;
    $11 = $22;
    $9 = $14 ? $12 : $11;
    $12 = Math_clz32($9);
    $13 = ($12 | 0) == 32 ? Math_clz32($13) + 32 | 0 : $12;
    $12 = $21 << 6;
    $11 = $12 + $13 | 0;
    $10 = $2;
    $13 = $22;
    __ashlti3($19 + 80 | 0, $1, $10, $23, $13, $11 - 15 | 0);
    $21 = 16 - $11 | 0;
    $14 = $19;
    $13 = HEAP32[$14 + 88 >> 2];
    $23 = $13;
    $10 = HEAP32[$14 + 92 >> 2];
    $22 = $10;
    $32 = $10;
    $13 = 0;
    $33 = $13;
    $10 = $14;
    $13 = HEAP32[$10 + 80 >> 2];
    $1 = $13;
    $14 = HEAP32[$10 + 84 >> 2];
    $2 = $14;
   }
   $14 = $4;
   if ($14 >>> 0 > 65535) {
    break label$2;
   }
   $10 = $24;
   $9 = !($10 | $25);
   $13 = $9 ? $5 : $25;
   $10 = $6;
   $14 = $24;
   $12 = $9 ? $10 : $14;
   $10 = Math_clz32($12);
   $11 = 0;
   $13 = ($10 | 0) == 32 ? Math_clz32($13) + 32 | 0 : $10;
   $10 = $9 << 6;
   $14 = $13 + $10 | 0;
   $11 = $6;
   $13 = $24;
   __ashlti3($19 - -64 | 0, $5, $11, $25, $13, $14 - 15 | 0);
   $21 = ($21 - $14 | 0) + 16 | 0;
   $9 = $19;
   $13 = HEAP32[$9 + 72 >> 2];
   $25 = $13;
   $11 = HEAP32[$9 + 76 >> 2];
   $24 = $11;
   $11 = HEAP32[$9 + 64 >> 2];
   $5 = $11;
   $13 = HEAP32[$9 + 68 >> 2];
   $6 = $13;
  }
  $9 = $5;
  $16 = $9 << 15;
  $13 = $6;
  $11 = $13 << 15 | $9 >>> 17;
  $17 = $11;
  $9 = 0;
  $4 = $9;
  $13 = $16;
  $3 = $13 & -32768;
  $13 = 0;
  $8 = $13;
  $9 = $2;
  $7 = $9;
  $11 = $13;
  $11 = __wasm_i64_mul($3, $4, $9, $11);
  $34 = $11;
  $13 = i64toi32_i32$HIGH_BITS;
  $35 = $13;
  $13 = $17;
  $16 = $13;
  $11 = 0;
  $17 = $11;
  $13 = $1;
  $1 = $13;
  $9 = 0;
  $2 = $9;
  $9 = $17;
  $13 = $2;
  $13 = __wasm_i64_mul($16, $9, $1, $13);
  $10 = $13;
  $9 = i64toi32_i32$HIGH_BITS;
  $13 = $9;
  $9 = $35;
  $14 = $9 + $13 | 0;
  $11 = $34;
  $12 = $11 + $10 | 0;
  $14 = $12 >>> 0 < $10 >>> 0 ? $14 + 1 | 0 : $14;
  $30 = $12;
  $27 = $14;
  $9 = $12;
  $11 = $2;
  $9 = $4;
  $9 = __wasm_i64_mul($1, $11, $3, $9);
  $10 = $9;
  $11 = i64toi32_i32$HIGH_BITS;
  $9 = $11;
  $11 = $12;
  $12 = $9 + $11 | 0;
  $14 = 0;
  $13 = $14 + $10 | 0;
  $12 = $13 >>> 0 < $10 >>> 0 ? $12 + 1 | 0 : $12;
  $28 = $13;
  $26 = $12;
  $14 = $11;
  $11 = $13;
  $10 = $37;
  $38 = ($12 | 0) == ($14 | 0) & $11 >>> 0 < $10 >>> 0 | $12 >>> 0 < $14 >>> 0;
  $10 = $23;
  $23 = $10;
  $12 = 0;
  $22 = $12;
  $12 = $4;
  $10 = $22;
  $10 = __wasm_i64_mul($3, $12, $23, $10);
  $39 = $10;
  $12 = i64toi32_i32$HIGH_BITS;
  $40 = $12;
  $12 = $8;
  $10 = $17;
  $10 = __wasm_i64_mul($7, $12, $16, $10);
  $14 = $10;
  $12 = i64toi32_i32$HIGH_BITS;
  $10 = $12;
  $12 = $40;
  $13 = $12 + $10 | 0;
  $11 = $39;
  $9 = $11 + $14 | 0;
  $13 = $9 >>> 0 < $14 >>> 0 ? $13 + 1 | 0 : $13;
  $37 = $9;
  $41 = $13;
  $12 = $25;
  $36 = $12 << 15;
  $13 = $24;
  $11 = $13 << 15 | $12 >>> 17;
  $31 = $11;
  $11 = $6;
  $14 = $11 >>> 17 | 0;
  $12 = 0;
  $13 = $12;
  $12 = $31;
  $11 = $36;
  $12 = $11 | $14;
  $5 = $12;
  $11 = 0;
  $6 = $11;
  $12 = $2;
  $12 = __wasm_i64_mul($5, $11, $1, $12);
  $14 = $12;
  $11 = i64toi32_i32$HIGH_BITS;
  $12 = $11;
  $11 = $41;
  $9 = $12 + $11 | 0;
  $13 = $37;
  $10 = $13 + $14 | 0;
  $25 = $10;
  $9 = $10 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
  $24 = $9;
  $9 = $27;
  $13 = $35;
  $11 = $30;
  $14 = $34;
  $14 = ($9 | 0) == ($13 | 0) & $11 >>> 0 < $14 >>> 0 | $9 >>> 0 < $13 >>> 0;
  $9 = $14;
  $14 = 0;
  $11 = $14;
  $14 = $9;
  $11 = $11 | $14;
  $9 = 0;
  $13 = $27;
  $13 = $9 | $13;
  $12 = $13 + $10 | 0;
  $9 = $11;
  $11 = $24;
  $10 = $9 + $11 | 0;
  $34 = $12;
  $10 = $12 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
  $35 = $10;
  $10 = $33;
  $27 = $10;
  $14 = $4;
  $11 = $32;
  $30 = $11 | 65536;
  $11 = __wasm_i64_mul($3, $14, $30, $10);
  $42 = $11;
  $14 = i64toi32_i32$HIGH_BITS;
  $43 = $14;
  $14 = $17;
  $11 = $22;
  $11 = __wasm_i64_mul($16, $14, $23, $11);
  $13 = $11;
  $14 = i64toi32_i32$HIGH_BITS;
  $11 = $14;
  $14 = $43;
  $12 = $11 + $14 | 0;
  $10 = $42;
  $9 = $13 + $10 | 0;
  $12 = $9 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
  $32 = $9;
  $33 = $12;
  $12 = $31;
  $3 = $12 | -2147483648;
  $10 = 0;
  $4 = $10;
  $12 = $2;
  $12 = __wasm_i64_mul($3, $10, $1, $12);
  $13 = $12;
  $11 = $13 + $9 | 0;
  $14 = i64toi32_i32$HIGH_BITS;
  $12 = $14;
  $14 = $33;
  $9 = $12 + $14 | 0;
  $36 = $11;
  $9 = $11 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
  $31 = $9;
  $9 = $6;
  $10 = $8;
  $10 = __wasm_i64_mul($5, $9, $7, $10);
  $13 = $10;
  $9 = i64toi32_i32$HIGH_BITS;
  $10 = $9;
  $9 = $31;
  $11 = $9 + $10 | 0;
  $14 = $36;
  $12 = $13 + $14 | 0;
  $11 = $12 >>> 0 < $13 >>> 0 ? $11 + 1 | 0 : $11;
  $46 = $12;
  $44 = $11;
  $9 = $12;
  $14 = $35;
  $12 = $9 + $14 | 0;
  $13 = 0;
  $11 = $34;
  $10 = $13 + $11 | 0;
  $45 = $10;
  $12 = $10 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
  $47 = $12;
  $11 = $12;
  $10 = $11;
  $13 = $45;
  $14 = $38;
  $9 = $13 + $14 | 0;
  $10 = $9 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
  $1 = $9;
  $2 = $10;
  $20 = (($20 + $29 | 0) + $21 | 0) - 16383 | 0;
  $10 = $4;
  $14 = $8;
  $14 = __wasm_i64_mul($3, $10, $7, $14);
  $21 = $14;
  $10 = i64toi32_i32$HIGH_BITS;
  $7 = $10;
  $12 = $14;
  $10 = $17;
  $14 = $27;
  $14 = __wasm_i64_mul($16, $10, $30, $14);
  $13 = $14;
  $11 = $12 + $13 | 0;
  $10 = i64toi32_i32$HIGH_BITS;
  $14 = $10;
  $10 = $7;
  $9 = $14 + $10 | 0;
  $7 = $11;
  $9 = $11 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
  $8 = $9;
  $12 = $10;
  $13 = $21;
  $10 = $11;
  $21 = ($9 | 0) == ($12 | 0) & $13 >>> 0 > $10 >>> 0 | $9 >>> 0 < $12 >>> 0;
  $10 = $6;
  $9 = $22;
  $9 = __wasm_i64_mul($5, $10, $23, $9);
  $12 = $9;
  $14 = $9 + $11 | 0;
  $10 = i64toi32_i32$HIGH_BITS;
  $9 = $10;
  $10 = $8;
  $11 = $9 + $10 | 0;
  $16 = $14;
  $13 = $10;
  $11 = $12 >>> 0 > $14 >>> 0 ? $11 + 1 | 0 : $11;
  $17 = $11;
  $12 = $7;
  $10 = $14;
  $13 = ($13 | 0) == ($11 | 0) & $12 >>> 0 > $10 >>> 0 | $11 >>> 0 < $13 >>> 0;
  $14 = 0;
  $12 = $21;
  $9 = $12 + $13 | 0;
  $14 = $9 >>> 0 < $13 >>> 0 ? 1 : $14;
  $7 = $14;
  $14 = $4;
  $12 = $27;
  $12 = __wasm_i64_mul($3, $14, $30, $12);
  $13 = $12;
  $11 = $13 + $9 | 0;
  $14 = i64toi32_i32$HIGH_BITS;
  $12 = $14;
  $14 = $7;
  $9 = $12 + $14 | 0;
  $21 = $11;
  $9 = $11 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
  $38 = $9;
  $9 = $41;
  $10 = $40;
  $13 = $39;
  $14 = $37;
  $7 = ($9 | 0) == ($10 | 0) & $13 >>> 0 > $14 >>> 0 | $9 >>> 0 < $10 >>> 0;
  $14 = $24;
  $13 = $25;
  $10 = $37;
  $9 = ($14 | 0) == ($9 | 0) & $13 >>> 0 < $10 >>> 0 | $9 >>> 0 > $14 >>> 0;
  $11 = 0;
  $10 = $7;
  $12 = $9 + $10 | 0;
  $7 = $12;
  $11 = $9 >>> 0 > $12 >>> 0 ? 1 : $11;
  $10 = $11;
  $11 = $17;
  $12 = $11 + $10 | 0;
  $9 = $7;
  $13 = $16;
  $14 = $9 + $13 | 0;
  $7 = $14;
  $12 = $9 >>> 0 > $14 >>> 0 ? $12 + 1 | 0 : $12;
  $8 = $12;
  $13 = $11;
  $9 = $16;
  $11 = $14;
  $13 = ($12 | 0) == ($13 | 0) & $9 >>> 0 > $11 >>> 0 | $12 >>> 0 < $13 >>> 0;
  $11 = $38;
  $9 = $21;
  $10 = $9 + $13 | 0;
  $17 = $10;
  $14 = $10 >>> 0 < $13 >>> 0 ? $11 + 1 | 0 : $11;
  $16 = $14;
  $14 = $6;
  $9 = $27;
  $9 = __wasm_i64_mul($5, $14, $30, $9);
  $5 = $9;
  $14 = i64toi32_i32$HIGH_BITS;
  $6 = $14;
  $14 = $4;
  $9 = $22;
  $9 = __wasm_i64_mul($3, $14, $23, $9);
  $13 = $9;
  $14 = i64toi32_i32$HIGH_BITS;
  $9 = $14;
  $14 = $6;
  $10 = $9 + $14 | 0;
  $11 = $5;
  $12 = $13 + $11 | 0;
  $10 = $12 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
  $3 = $12;
  $11 = $14;
  $4 = $10;
  $13 = $5;
  $13 = ($11 | 0) == ($10 | 0) & $13 >>> 0 > $12 >>> 0 | $10 >>> 0 < $11 >>> 0;
  $10 = $13;
  $13 = 0;
  $14 = $13;
  $14 = $10 | $14;
  $5 = $14;
  $13 = $17;
  $10 = $4;
  $11 = $10;
  $10 = 0;
  $11 = $11 | $10;
  $9 = $13 + $11 | 0;
  $14 = $16;
  $10 = $5;
  $12 = $14 + $10 | 0;
  $5 = $9;
  $12 = $9 >>> 0 < $11 >>> 0 ? $12 + 1 | 0 : $12;
  $6 = $12;
  $14 = $3;
  $12 = $8;
  $13 = $12;
  $9 = $12 + $14 | 0;
  $12 = $7;
  $11 = 0;
  $10 = $12 + $11 | 0;
  $3 = $10;
  $9 = $10 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
  $4 = $9;
  $12 = $13;
  $11 = $7;
  $12 = ($9 | 0) == ($12 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 < $12 >>> 0;
  $13 = $6;
  $10 = $13;
  $11 = $5;
  $14 = $12 + $11 | 0;
  $5 = $14;
  $10 = $12 >>> 0 > $14 >>> 0 ? $10 + 1 | 0 : $10;
  $6 = $10;
  $11 = $44;
  $10 = $31;
  $12 = $46;
  $13 = $36;
  $7 = ($11 | 0) == ($10 | 0) & $12 >>> 0 < $13 >>> 0 | $10 >>> 0 > $11 >>> 0;
  $13 = $33;
  $10 = $43;
  $12 = $32;
  $11 = $42;
  $8 = ($13 | 0) == ($10 | 0) & $12 >>> 0 < $11 >>> 0 | $10 >>> 0 > $13 >>> 0;
  $12 = $13;
  $13 = $31;
  $11 = $32;
  $10 = $36;
  $13 = ($12 | 0) == ($13 | 0) & $11 >>> 0 > $10 >>> 0 | $12 >>> 0 > $13 >>> 0;
  $14 = 0;
  $10 = $8;
  $9 = $13 + $10 | 0;
  $14 = $9 >>> 0 < $13 >>> 0 ? 1 : $14;
  $13 = $9;
  $10 = $14;
  $9 = $10;
  $11 = $7;
  $12 = $13 + $11 | 0;
  $11 = $12;
  $14 = 0;
  $9 = $14;
  $9 = $9 | $11;
  $7 = $9;
  $11 = $44;
  $13 = $11;
  $11 = $18;
  $13 = $13 | $11;
  $14 = $3;
  $10 = $13 + $14 | 0;
  $9 = $4;
  $11 = $7;
  $12 = $9 + $11 | 0;
  $7 = $10;
  $12 = $10 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
  $8 = $12;
  $14 = $9;
  $9 = $10;
  $13 = $3;
  $14 = ($12 | 0) == ($14 | 0) & $9 >>> 0 < $13 >>> 0 | $12 >>> 0 < $14 >>> 0;
  $9 = $6;
  $13 = $5;
  $11 = $13 + $14 | 0;
  $10 = $11 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
  $5 = $11;
  $6 = $10;
  $13 = $35;
  $10 = $24;
  $9 = $25;
  $14 = $34;
  $3 = ($13 | 0) == ($10 | 0) & $9 >>> 0 > $14 >>> 0 | $10 >>> 0 > $13 >>> 0;
  $9 = $13;
  $10 = $47;
  $13 = $45;
  $10 = ($9 | 0) == ($10 | 0) & $14 >>> 0 > $13 >>> 0 | $9 >>> 0 > $10 >>> 0;
  $11 = 0;
  $13 = $3;
  $12 = $13 + $10 | 0;
  $11 = $12 >>> 0 < $10 >>> 0 ? 1 : $11;
  $10 = $12;
  $13 = $11;
  $11 = $8;
  $12 = $13 + $11 | 0;
  $14 = $7;
  $9 = $14 + $10 | 0;
  $12 = $9 >>> 0 < $10 >>> 0 ? $12 + 1 | 0 : $12;
  $3 = $9;
  $4 = $12;
  $14 = $11;
  $10 = $7;
  $14 = ($12 | 0) == ($14 | 0) & $9 >>> 0 < $10 >>> 0 | $12 >>> 0 < $14 >>> 0;
  $11 = $6;
  $9 = $11;
  $10 = $5;
  $13 = $14 + $10 | 0;
  $9 = $13 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
  $7 = $13;
  $8 = $9;
  $10 = $9 & 65536;
  label$13: {
   if ($10) {
    $20 = $20 + 1 | 0;
    break label$13;
   }
   $10 = $26;
   $5 = $10 >>> 31 | 0;
   $11 = 0;
   $6 = $11;
   $10 = $7;
   $11 = $8;
   $9 = $11 << 1 | $10 >>> 31;
   $8 = $9;
   $9 = $4;
   $14 = $9 >>> 31 | 0;
   $9 = $10 << 1;
   $7 = $9 | $14;
   $10 = 0;
   $11 = $10;
   $10 = $8;
   $11 = $11 | $10;
   $8 = $11;
   $10 = $3;
   $11 = $4;
   $9 = $11 << 1 | $10 >>> 31;
   $4 = $9;
   $9 = $2;
   $14 = $9 >>> 31 | 0;
   $9 = $10 << 1;
   $3 = $9 | $14;
   $10 = 0;
   $11 = $10;
   $10 = $4;
   $11 = $11 | $10;
   $4 = $11;
   $10 = $28;
   $28 = $10 << 1;
   $11 = $26;
   $9 = $11 << 1 | $10 >>> 31;
   $26 = $9;
   $9 = $2;
   $11 = $1;
   $10 = $9 << 1 | $11 >>> 31;
   $9 = $5;
   $14 = $11 << 1;
   $1 = $9 | $14;
   $11 = $10;
   $10 = $6;
   $11 = $11 | $10;
   $2 = $11;
  }
  if (($20 | 0) >= 32767) {
   $10 = $18;
   $18 = $10;
   $11 = $15;
   $9 = $11 | 2147418112;
   $15 = $9;
   $1 = 0;
   $2 = 0;
   break label$1;
  }
  $9 = $15;
  $5 = $9;
  label$16: {
   if (($20 | 0) <= 0) {
    $29 = 1 - $20 | 0;
    if ($29 >>> 0 >= 128) {
     $1 = 0;
     $2 = 0;
     break label$1;
    }
    $9 = $26;
    $10 = $2;
    $20 = $20 + 127 | 0;
    __ashlti3($19 + 48 | 0, $28, $9, $1, $10, $20);
    $10 = $4;
    $9 = $8;
    __ashlti3($19 + 32 | 0, $3, $10, $7, $9, $20);
    $9 = $26;
    $10 = $2;
    __lshrti3($19 + 16 | 0, $28, $9, $1, $10, $29);
    $10 = $4;
    $9 = $8;
    __lshrti3($19, $3, $10, $7, $9, $29);
    $11 = $19;
    $9 = HEAP32[$11 + 48 >> 2];
    $1 = $9;
    $10 = HEAP32[$11 + 52 >> 2];
    $2 = $10;
    $10 = HEAP32[$11 + 56 >> 2];
    $14 = $10;
    $9 = HEAP32[$11 + 60 >> 2];
    $10 = $9;
    $9 = $2;
    $10 = $9 | $10;
    $11 = $1;
    $9 = $11 | $14;
    $3 = ($10 | $9) != 0;
    $14 = $19;
    $9 = HEAP32[$14 + 32 >> 2];
    $1 = $9;
    $10 = HEAP32[$14 + 36 >> 2];
    $2 = $10;
    $10 = HEAP32[$14 + 16 >> 2];
    $11 = $10;
    $9 = HEAP32[$14 + 20 >> 2];
    $10 = $9;
    $9 = $2;
    $10 = $9 | $10;
    $9 = $3;
    $14 = $1;
    $11 = $11 | $14;
    $28 = $9 | $11;
    $26 = $10;
    $10 = $19;
    $14 = HEAP32[$10 + 40 >> 2];
    $1 = $14;
    $9 = HEAP32[$10 + 44 >> 2];
    $2 = $9;
    $14 = HEAP32[$10 + 28 >> 2];
    $9 = HEAP32[$10 + 24 >> 2];
    $10 = $1;
    $1 = $9 | $10;
    $9 = $14;
    $14 = $2;
    $9 = $9 | $14;
    $2 = $9;
    $14 = $19;
    $9 = HEAP32[$14 >> 2];
    $3 = $9;
    $10 = HEAP32[$14 + 4 >> 2];
    $4 = $10;
    $10 = HEAP32[$14 + 8 >> 2];
    $7 = $10;
    $9 = HEAP32[$14 + 12 >> 2];
    break label$16;
   }
   $9 = $8;
   $10 = $9 & 65535;
   $6 = $10;
   $11 = 0;
   $14 = $7;
   $10 = $14;
   $7 = $11 | $10;
   $9 = $20;
   $14 = $9 << 16;
   $9 = $14;
   $14 = $6;
   $9 = $9 | $14;
  }
  $8 = $9;
  $11 = $7;
  $14 = $18;
  $18 = $11 | $14;
  $9 = $5;
  $10 = $8;
  $10 = $9 | $10;
  $15 = $10;
  $10 = $26;
  $5 = !($10 | $28);
  $10 = $2;
  $6 = ($10 | 0) > 0 | ($10 | 0) >= 0;
  $11 = $1;
  $9 = $2;
  if (!(!$11 & ($9 | 0) == -2147483648 ? $5 : $6)) {
   $11 = $4;
   $14 = $3;
   $12 = $14 + 1 | 0;
   $13 = $12 ? $11 : $11 + 1 | 0;
   $1 = $12;
   $2 = $13;
   $14 = $11;
   $11 = $12;
   $10 = $3;
   $14 = ($13 | 0) == ($14 | 0) & $11 >>> 0 < $10 >>> 0 | $13 >>> 0 < $14 >>> 0;
   $11 = $15;
   $10 = $18;
   $9 = $14 + $10 | 0;
   $12 = $9 >>> 0 < $14 >>> 0 ? $11 + 1 | 0 : $11;
   $18 = $9;
   $15 = $12;
   break label$1;
  }
  $12 = $2;
  $10 = $12 ^ -2147483648;
  $12 = $28;
  $14 = $1;
  $11 = $10;
  $10 = $26;
  $11 = $11 | $10;
  if ($12 | $14 | $11) {
   $1 = $3;
   $11 = $4;
   $2 = $11;
   break label$1;
  }
  $12 = 0;
  $1 = $12;
  $11 = $4;
  $12 = $11;
  $11 = $3;
  $10 = $11;
  $14 = $10 & 1;
  $13 = $10 + $14 | 0;
  $10 = $1;
  $9 = $10 + $12 | 0;
  $1 = $13;
  $9 = $13 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
  $2 = $9;
  $11 = $12;
  $12 = $13;
  $14 = $3;
  $11 = ($9 | 0) == ($11 | 0) & $12 >>> 0 < $14 >>> 0 | $9 >>> 0 < $11 >>> 0;
  $12 = $15;
  $14 = $18;
  $10 = $11 + $14 | 0;
  $18 = $10;
  $13 = $10 >>> 0 < $11 >>> 0 ? $12 + 1 | 0 : $12;
  $15 = $13;
 }
 $14 = $0;
 HEAP32[$14 >> 2] = $1;
 $13 = $2;
 HEAP32[$14 + 4 >> 2] = $13;
 HEAP32[$14 + 8 >> 2] = $18;
 $13 = $15;
 HEAP32[$14 + 12 >> 2] = $13;
 __stack_pointer = $19 + 96 | 0;
}

function sqlite3CreateIndex($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $11 = __stack_pointer - 224 | 0;
 __stack_pointer = $11;
 $12 = HEAP32[$0 >> 2];
 HEAP32[$11 + 164 >> 2] = 0;
 HEAP32[$11 + 160 >> 2] = 0;
 label$1: {
  if (HEAP32[$0 + 36 >> 2] | HEAPU8[$0 + 208 | 0] == 1 & ($10 | 0) != 2) {
   break label$1;
  }
  if (sqlite3ReadSchema($0)) {
   break label$1;
  }
  if (sqlite3HasExplicitNulls($0, $4)) {
   break label$1;
  }
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      if ($3) {
       $17 = sqlite3TwoPartName($0, $1, $2, $11 + 164 | 0);
       if (($17 | 0) < 0) {
        break label$1;
       }
       label$8: {
        if (HEAPU8[$12 + 177 | 0]) {
         break label$8;
        }
        $14 = sqlite3SrcListLookup($0, $3);
        if (HEAP32[$2 + 4 >> 2] | !$14) {
         break label$8;
        }
        $17 = HEAP32[$14 + 60 >> 2] == HEAP32[HEAP32[$12 + 16 >> 2] + 28 >> 2] ? 1 : $17;
       }
       $19 = HEAP32[$11 + 164 >> 2];
       sqlite3FixInit($11 + 168 | 0, $0, $17, 1513, $19);
       sqlite3FixSrcList($11 + 168 | 0, $3);
       $14 = 0;
       $2 = sqlite3LocateTableItem($0, 0, $3 + 8 | 0);
       if (!$2) {
        break label$1;
       }
       if (!(HEAP32[HEAP32[$12 + 16 >> 2] + 28 >> 2] == HEAP32[$2 + 60 >> 2] | ($17 | 0) != 1)) {
        HEAP32[$11 + 144 >> 2] = HEAP32[$2 >> 2];
        sqlite3ErrorMsg($0, 28750, $11 + 144 | 0);
        break label$5;
       }
       $18 = 0;
       if (!(HEAPU8[$2 + 28 | 0] & 128)) {
        break label$6;
       }
       $18 = sqlite3PrimaryKeyIndex($2);
       break label$6;
      }
      $2 = HEAP32[$0 + 236 >> 2];
      if (!$2) {
       break label$1;
      }
      $17 = sqlite3SchemaToIndex($12, HEAP32[$2 + 60 >> 2]);
      $18 = 0;
     }
     $16 = HEAP32[$12 + 16 >> 2];
     $15 = HEAP32[$2 >> 2];
     if (!(sqlite3_strnicmp($15, 17751, 7) | !$3 | HEAPU8[$12 + 177 | 0])) {
      HEAP32[$11 >> 2] = $15;
      sqlite3ErrorMsg($0, 14724, $11);
      break label$5;
     }
     label$11: {
      switch (HEAPU8[$2 + 43 | 0] - 1 | 0) {
      case 1:
       sqlite3ErrorMsg($0, 14665, 0);
       break label$4;

      case 0:
       sqlite3ErrorMsg($0, 14690, 0);
       break label$4;

      default:
       break label$11;
      }
     }
     $13 = ($17 << 4) + $16 | 0;
     label$14: {
      label$15: {
       label$16: {
        if ($19) {
         $14 = sqlite3NameFromToken($12, $19);
         if (!$14) {
          break label$5;
         }
         if (sqlite3CheckObjectName($0, $14, 1513, HEAP32[$2 >> 2])) {
          break label$4;
         }
         if (HEAPU8[$0 + 208 | 0] > 1) {
          break label$14;
         }
         label$18: {
          if (HEAPU8[$12 + 177 | 0]) {
           break label$18;
          }
          if (!sqlite3FindTable($12, $14, 0)) {
           break label$18;
          }
          HEAP32[$11 + 128 >> 2] = $14;
          sqlite3ErrorMsg($0, 6776, $11 + 128 | 0);
          break label$4;
         }
         if (!sqlite3FindIndex($12, $14, HEAP32[$13 >> 2])) {
          break label$16;
         }
         if (!$9) {
          HEAP32[$11 + 112 >> 2] = $14;
          sqlite3ErrorMsg($0, 3440, $11 + 112 | 0);
          break label$4;
         }
         sqlite3CodeVerifySchema($0, $17);
         sqlite3ForceNotReadOnly($0);
         break label$4;
        }
        $14 = $2 + 8 | 0;
        $1 = 1;
        while (1) {
         $14 = HEAP32[$14 >> 2];
         if ($14) {
          $1 = $1 + 1 | 0;
          $14 = $14 + 20 | 0;
          continue;
         }
         break;
        }
        HEAP32[$11 + 100 >> 2] = $1;
        HEAP32[$11 + 96 >> 2] = $15;
        $14 = sqlite3MPrintf($12, 15916, $11 + 96 | 0);
        if (!$14) {
         break label$5;
        }
        if (!HEAPU8[$0 + 208 | 0]) {
         break label$15;
        }
        HEAP8[$14 + 7 | 0] = HEAPU8[$14 + 7 | 0] + 1;
       }
       if (HEAPU8[$0 + 208 | 0] > 1) {
        break label$14;
       }
      }
      $1 = ($17 | 0) == 1;
      $9 = HEAP32[$13 >> 2];
      if (sqlite3AuthCheck($0, 18, $1 ? 8671 : 8690, 0, $9)) {
       break label$4;
      }
      if (sqlite3AuthCheck($0, $1 ? 3 : 1, $14, HEAP32[$2 >> 2], $9)) {
       break label$4;
      }
     }
     label$22: {
      if (!$4) {
       $4 = (HEAP32[$2 + 4 >> 2] + Math_imul(HEAP16[$2 + 34 >> 1], 12) | 0) - 12 | 0;
       HEAP16[$4 + 10 >> 1] = HEAPU16[$4 + 10 >> 1] | 8;
       sqlite3TokenInit($11 + 152 | 0, HEAP32[$4 >> 2]);
       $1 = 0;
       $4 = sqlite3ExprListAppend($0, 0, sqlite3ExprAlloc($12, 59, $11 + 152 | 0, 0));
       if (!$4) {
        break label$3;
       }
       sqlite3ExprListSetSortOrder($4, $8, -1);
       break label$22;
      }
      sqlite3ExprListCheckLength($0, $4, 1513);
      if (HEAP32[$0 + 36 >> 2]) {
       break label$4;
      }
     }
     $15 = 0;
     $13 = HEAP32[$4 >> 2];
     $9 = ($13 | 0) > 0 ? $13 : 0;
     $1 = 0;
     while (1) {
      if (($1 | 0) != ($9 | 0)) {
       $8 = HEAP32[(($1 << 4) + $4 | 0) + 8 >> 2];
       if (HEAPU8[$8 | 0] == 113) {
        $15 = (sqlite3Strlen30(HEAP32[$8 + 8 >> 2]) + $15 | 0) + 1 | 0;
       }
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     $9 = sqlite3Strlen30($14);
     $1 = 1;
     $1 = $18 ? HEAPU16[$18 + 50 >> 1] : $1;
     $8 = sqlite3AllocateIndexObject($12, $13 + $1 << 16 >> 16, ($9 + $15 | 0) + 1 | 0, $11 + 160 | 0);
     label$28: {
      label$29: {
       if (HEAPU8[$12 + 87 | 0]) {
        $1 = $4;
        break label$29;
       }
       $1 = HEAP32[$11 + 160 >> 2];
       HEAP32[$8 >> 2] = $1;
       $9 = $9 + 1 | 0;
       $15 = $9 + $1 | 0;
       HEAP32[$11 + 160 >> 2] = $15;
       __memcpy($1, $14, $9);
       HEAP8[$8 + 54 | 0] = $5;
       HEAP32[$8 + 12 >> 2] = $2;
       $20 = $10 & 3;
       $1 = $20 | ((HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8) & 65524 | (($5 | 0) != 0) << 3);
       HEAP8[$8 + 55 | 0] = $1;
       HEAP8[$8 + 56 | 0] = $1 >>> 8;
       $1 = $17 << 4;
       HEAP32[$8 + 24 >> 2] = HEAP32[($1 + HEAP32[$12 + 16 >> 2] | 0) + 12 >> 2];
       HEAP16[$8 + 50 >> 1] = HEAP32[$4 >> 2];
       if ($7) {
        sqlite3ResolveSelfReference($0, $2, 2, $7, 0);
        HEAP32[$8 + 36 >> 2] = $7;
       }
       $7 = HEAPU8[HEAP32[($1 + $16 | 0) + 12 >> 2] + 76 | 0];
       $1 = $4;
       if (HEAPU8[$0 + 208 | 0] >= 2) {
        HEAP32[$8 + 40 >> 2] = $4;
        $1 = 0;
       }
       $9 = $4 + 8 | 0;
       $22 = ($7 & 255) >>> 0 > 3;
       $4 = 0;
       while (1) {
        if (HEAPU16[$8 + 50 >> 1] > $4 >>> 0) {
         sqlite3StringToId(HEAP32[$9 >> 2]);
         $7 = 0;
         sqlite3ResolveSelfReference($0, $2, 32, HEAP32[$9 >> 2], 0);
         if (HEAP32[$0 + 36 >> 2]) {
          break label$28;
         }
         $16 = sqlite3ExprSkipCollate(HEAP32[$9 >> 2]);
         label$35: {
          if (HEAPU8[$16 | 0] != 167) {
           if (HEAP32[$0 + 236 >> 2] == ($2 | 0)) {
            sqlite3ErrorMsg($0, 3591, 0);
            break label$28;
           }
           if (!HEAP32[$8 + 40 >> 2]) {
            HEAP32[$8 + 40 >> 2] = $1;
            $1 = 0;
           }
           HEAP16[HEAP32[$8 + 4 >> 2] + ($4 << 1) >> 1] = 65534;
           $13 = (HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8) & 65527;
           HEAP8[$8 + 55 | 0] = $13;
           HEAP8[$8 + 56 | 0] = $13 >>> 8;
           $16 = -2;
           break label$35;
          }
          $16 = HEAP16[$16 + 32 >> 1];
          label$39: {
           if (($16 | 0) < 0) {
            $16 = HEAP16[$2 + 32 >> 1];
            break label$39;
           }
           $13 = HEAP32[$2 + 4 >> 2];
           $21 = Math_imul($16, 12);
           if (!(HEAPU8[($13 + $21 | 0) + 4 | 0] & 15)) {
            $13 = (HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8) & 65527;
            HEAP8[$8 + 55 | 0] = $13;
            HEAP8[$8 + 56 | 0] = $13 >>> 8;
            $13 = HEAP32[$2 + 4 >> 2];
           }
           if (!(HEAPU8[($13 + $21 | 0) + 10 | 0] & 32)) {
            break label$39;
           }
           $13 = HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8 | 1024;
           HEAP8[$8 + 55 | 0] = $13;
           HEAP8[$8 + 56 | 0] = $13 >>> 8;
          }
          HEAP16[HEAP32[$8 + 4 >> 2] + ($4 << 1) >> 1] = $16;
         }
         $13 = HEAP32[$9 >> 2];
         label$42: {
          if (HEAPU8[$13 | 0] == 113) {
           $16 = HEAP32[$13 + 8 >> 2];
           $13 = sqlite3Strlen30($16) + 1 | 0;
           $13 = $13 + __memcpy($15, $16, $13) | 0;
           HEAP32[$11 + 160 >> 2] = $13;
           break label$42;
          }
          if (($16 | 0) < 0) {
           $13 = $15;
           $15 = 0;
           break label$42;
          }
          $13 = $15;
          $15 = sqlite3ColumnColl(HEAP32[$2 + 4 >> 2] + Math_imul($16, 12) | 0);
         }
         $15 = $15 ? $15 : 32384;
         if (!HEAPU8[$12 + 177 | 0]) {
          if (!sqlite3LocateCollSeq($0, $15)) {
           break label$28;
          }
         }
         HEAP32[HEAP32[$8 + 32 >> 2] + ($4 << 2) >> 2] = $15;
         HEAP8[HEAP32[$8 + 28 >> 2] + $4 | 0] = $22 ? HEAPU8[$9 + 8 | 0] : 0;
         $9 = $9 + 16 | 0;
         $4 = $4 + 1 | 0;
         $15 = $13;
         continue;
        }
        break;
       }
       label$46: {
        if ($18) {
         $7 = 0;
         while (1) {
          if (HEAPU16[$18 + 50 >> 1] <= $7 >>> 0) {
           break label$46;
          }
          label$49: {
           if (isDupColumn($8, HEAPU16[$8 + 50 >> 1], $18, $7)) {
            HEAP16[$8 + 52 >> 1] = HEAPU16[$8 + 52 >> 1] - 1;
            break label$49;
           }
           HEAP16[HEAP32[$8 + 4 >> 2] + ($4 << 1) >> 1] = HEAPU16[HEAP32[$18 + 4 >> 2] + ($7 << 1) >> 1];
           HEAP32[HEAP32[$8 + 32 >> 2] + ($4 << 2) >> 2] = HEAP32[HEAP32[$18 + 32 >> 2] + ($7 << 2) >> 2];
           HEAP8[HEAP32[$8 + 28 >> 2] + $4 | 0] = HEAPU8[HEAP32[$18 + 28 >> 2] + $7 | 0];
           $4 = $4 + 1 | 0;
          }
          $7 = $7 + 1 | 0;
          continue;
         }
        }
        HEAP16[HEAP32[$8 + 4 >> 2] + ($4 << 1) >> 1] = 65535;
        HEAP32[HEAP32[$8 + 32 >> 2] + ($4 << 2) >> 2] = 32384;
       }
       sqlite3DefaultRowEst($8);
       if (!HEAP32[$0 + 236 >> 2]) {
        estimateIndexWidth($8);
       }
       recomputeColumnsNotIndexed($8);
       label$52: {
        if (!$3 | HEAPU16[$8 + 52 >> 1] < HEAP16[$2 + 34 >> 1]) {
         break label$52;
        }
        $9 = HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8;
        $4 = $9 | 32;
        HEAP8[$8 + 55 | 0] = $4;
        HEAP8[$8 + 56 | 0] = $4 >>> 8;
        $4 = 0;
        $7 = HEAP16[$2 + 34 >> 1];
        $7 = ($7 | 0) > 0 ? $7 : 0;
        while (1) {
         if (($4 | 0) == ($7 | 0)) {
          break label$52;
         }
         label$54: {
          if (HEAP16[$2 + 32 >> 1] == ($4 | 0)) {
           break label$54;
          }
          if ((sqlite3TableColumnToIndex($8, $4 << 16 >> 16) | 0) >= 0) {
           break label$54;
          }
          $4 = $9 & 65503;
          HEAP8[$8 + 55 | 0] = $4;
          HEAP8[$8 + 56 | 0] = $4 >>> 8;
          break label$52;
         }
         $4 = $4 + 1 | 0;
         continue;
        }
       }
       label$55: {
        label$56: {
         label$57: {
          if (HEAP32[$0 + 236 >> 2] != ($2 | 0)) {
           break label$57;
          }
          $4 = $2 + 8 | 0;
          while (1) {
           $9 = HEAP32[$4 >> 2];
           if (!$9) {
            break label$57;
           }
           label$59: {
            $18 = HEAPU16[$9 + 50 >> 1];
            label$60: {
             if (($18 | 0) != HEAPU16[$8 + 50 >> 1]) {
              break label$60;
             }
             $4 = 0;
             while (1) {
              if (($4 | 0) == ($18 | 0)) {
               break label$59;
              }
              $7 = $4 << 1;
              if (HEAPU16[$7 + HEAP32[$9 + 4 >> 2] >> 1] != HEAPU16[HEAP32[$8 + 4 >> 2] + $7 >> 1]) {
               break label$60;
              }
              $7 = $4 << 2;
              $4 = $4 + 1 | 0;
              if (!sqlite3StrICmp(HEAP32[HEAP32[$9 + 32 >> 2] + $7 >> 2], HEAP32[HEAP32[$8 + 32 >> 2] + $7 >> 2])) {
               continue;
              }
              break;
             }
            }
            $4 = $9 + 20 | 0;
            continue;
           }
           break;
          }
          $4 = HEAPU8[$9 + 54 | 0];
          $7 = HEAPU8[$8 + 54 | 0];
          label$62: {
           if (($4 | 0) == ($7 | 0)) {
            break label$62;
           }
           if (!(($4 | 0) == 11 | ($7 | 0) == 11)) {
            HEAP32[$11 + 80 >> 2] = 0;
            sqlite3ErrorMsg($0, 15658, $11 + 80 | 0);
            $4 = HEAPU8[$9 + 54 | 0];
           }
           if (($4 & 255) != 11) {
            break label$62;
           }
           HEAP8[$9 + 54 | 0] = HEAPU8[$8 + 54 | 0];
          }
          if (($10 | 0) == 2) {
           $4 = (HEAPU8[$9 + 55 | 0] | HEAPU8[$9 + 56 | 0] << 8) & 65532 | $20;
           HEAP8[$9 + 55 | 0] = $4;
           HEAP8[$9 + 56 | 0] = $4 >>> 8;
          }
          $7 = 0;
          if (HEAPU8[$0 + 208 | 0] < 2) {
           break label$28;
          }
          HEAP32[$8 + 20 >> 2] = HEAP32[$0 + 240 >> 2];
          break label$56;
         }
         label$65: {
          if (HEAPU8[$0 + 208 | 0] > 1) {
           break label$65;
          }
          if (HEAPU8[$12 + 177 | 0]) {
           label$67: {
            if (!$3) {
             break label$67;
            }
            HEAP32[$8 + 44 >> 2] = HEAP32[$12 + 172 >> 2];
            if (!sqlite3IndexHasDuplicateRootPage($8)) {
             break label$67;
            }
            $7 = 0;
            sqlite3ErrorMsg($0, 13952, 0);
            HEAP32[$0 + 12 >> 2] = sqlite3CorruptError(119527);
            break label$28;
           }
           if (sqlite3HashInsert(HEAP32[$8 + 24 >> 2] + 24 | 0, HEAP32[$8 >> 2], $8)) {
            sqlite3OomFault($12);
            $7 = 0;
            break label$28;
           }
           HEAP32[$12 + 24 >> 2] = HEAP32[$12 + 24 >> 2] | 1;
           break label$65;
          }
          if (!(HEAP32[$2 + 28 >> 2] & 128 ? $3 : 1)) {
           break label$65;
          }
          $7 = HEAP32[$0 + 44 >> 2] + 1 | 0;
          HEAP32[$0 + 44 >> 2] = $7;
          $4 = sqlite3GetVdbe($0);
          if (!$4) {
           $7 = 0;
           break label$29;
          }
          sqlite3BeginWriteOperation($0, 1, $17);
          HEAP32[$8 + 44 >> 2] = sqlite3VdbeAddOp0($4, 184);
          sqlite3VdbeAddOp3($4, 147, $17, $7, 2);
          if ($6) {
           $10 = HEAP32[$19 >> 2];
           $9 = HEAP32[$0 + 200 >> 2] + (HEAP32[$0 + 196 >> 2] - $10 | 0) | 0;
           $6 = $9 - 1 | 0;
           $19 = HEAPU8[$6 + $10 | 0];
           HEAP32[$11 + 72 >> 2] = $10;
           HEAP32[$11 + 64 >> 2] = $5 ? 19731 : 29623;
           HEAP32[$11 + 68 >> 2] = ($19 | 0) == 59 ? $6 : $9;
           $10 = sqlite3MPrintf($12, 5685, $11 - -64 | 0);
          } else {
           $10 = 0;
          }
          $5 = HEAP32[HEAP32[$12 + 16 >> 2] + ($17 << 4) >> 2];
          $9 = HEAP32[$8 >> 2];
          $6 = HEAP32[$2 >> 2];
          HEAP32[$11 + 48 >> 2] = $10;
          HEAP32[$11 + 44 >> 2] = $7;
          HEAP32[$11 + 40 >> 2] = $6;
          HEAP32[$11 + 36 >> 2] = $9;
          HEAP32[$11 + 32 >> 2] = $5;
          sqlite3NestedParse($0, 21265, $11 + 32 | 0);
          sqlite3DbFree($12, $10);
          if ($3) {
           sqlite3RefillIndex($0, $8, $7);
           sqlite3ChangeCookie($0, $17);
           HEAP32[$11 + 16 >> 2] = HEAP32[$8 >> 2];
           sqlite3VdbeAddParseSchemaOp($4, $17, sqlite3MPrintf($12, 27047, $11 + 16 | 0), 0);
           sqlite3VdbeAddOp2($4, 166, 0, 1);
          }
          sqlite3VdbeJumpHere($4, HEAP32[$8 + 44 >> 2]);
         }
         if (!(HEAPU8[$12 + 177 | 0] ? 0 : $3)) {
          HEAP32[$8 + 20 >> 2] = HEAP32[$2 + 8 >> 2];
          HEAP32[$2 + 8 >> 2] = $8;
          break label$55;
         }
         $7 = 0;
         if (HEAPU8[$0 + 208 | 0] < 2) {
          break label$29;
         }
        }
        HEAP32[$0 + 240 >> 2] = $8;
       }
       $7 = 0;
       break label$3;
      }
      if (!$8) {
       break label$3;
      }
     }
     sqlite3FreeIndex($12, $8);
     break label$3;
    }
    $14 = 0;
   }
   $1 = $4;
  }
  $10 = $2 + 8 | 0;
  label$76: {
   while (1) {
    $2 = $10;
    $0 = HEAP32[$2 >> 2];
    if (!$0) {
     break label$76;
    }
    $10 = $0 + 20 | 0;
    if (HEAPU8[$0 + 54 | 0] != 5) {
     continue;
    }
    break;
   }
   while (1) {
    $4 = HEAP32[$10 >> 2];
    if (!$4 | HEAPU8[$4 + 54 | 0] == 5) {
     break label$76;
    }
    HEAP32[$2 >> 2] = $4;
    HEAP32[$0 + 20 >> 2] = HEAP32[$4 + 20 >> 2];
    HEAP32[$4 + 20 >> 2] = $0;
    $2 = $4 + 20 | 0;
    continue;
   }
  }
  $4 = $1;
 }
 sqlite3ExprDelete($12, $7);
 sqlite3ExprListDelete($12, $4);
 sqlite3SrcListDelete($12, $3);
 sqlite3DbFree($12, $14);
 __stack_pointer = $11 + 224 | 0;
}

function sqlite3GenerateConstraintChecks($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) {
 var $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0;
 $19 = __stack_pointer - 32 | 0;
 __stack_pointer = $19;
 $15 = HEAPU16[$1 + 34 >> 1];
 $14 = HEAP32[$0 + 8 >> 2];
 $27 = HEAP32[$0 >> 2];
 $13 = HEAP32[$1 + 28 >> 2];
 if ($13 & 128) {
  $21 = sqlite3PrimaryKeyIndex($1);
  $31 = HEAPU16[$21 + 50 >> 1];
 } else {
  $31 = 1;
 }
 label$3: {
  if (!($13 & 2048)) {
   break label$3;
  }
  $13 = $15 << 16 >> 16;
  $18 = ($13 | 0) > 0 ? $13 : 0;
  $29 = $5 + 1 | 0;
  $23 = 1;
  while (1) {
   $13 = 0;
   while (1) {
    if (($13 | 0) != ($18 | 0)) {
     $15 = HEAP32[$1 + 4 >> 2] + Math_imul($13, 12) | 0;
     $16 = HEAPU8[$15 + 4 | 0] & 15;
     label$7: {
      if (!$16 | HEAP16[$1 + 32 >> 1] == ($13 | 0)) {
       break label$7;
      }
      $17 = HEAPU16[$15 + 10 >> 1] & 96;
      if (!((!$17 | $20) & 1)) {
       $22 = $22 + 1 | 0;
       break label$7;
      }
      if (!($17 ? 1 : !$11 | HEAP32[($13 << 2) + $11 >> 2] >= 0)) {
       break label$7;
      }
      label$10: {
       label$11: {
        label$12: {
         label$13: {
          $16 = ($8 | 0) == 11 ? ($16 | 0) == 11 ? 2 : $16 : $8;
          if (($16 | 0) == 5) {
           if (!HEAPU16[$15 + 8 >> 1] | $20 & 1) {
            break label$13;
           }
           $16 = sqlite3TableColumnToStorage($1, $13 << 16 >> 16) + $29 | 0;
           $17 = sqlite3VdbeAddOp1($14, 51, $16);
           sqlite3ExprCodeCopy($0, sqlite3ColumnExpr($1, $15), $16);
           sqlite3VdbeJumpHere($14, $17);
           $24 = $24 + 1 | 0;
           break label$7;
          }
          if (!((($17 | 0) != 0 | $23) & 1)) {
           break label$7;
          }
          $17 = sqlite3TableColumnToStorage($1, $13 << 16 >> 16) + $29 | 0;
          switch ($16 - 1 | 0) {
          case 0:
          case 2:
           break label$11;

          case 1:
           break label$12;

          default:
           break label$10;
          }
         }
         $17 = sqlite3TableColumnToStorage($1, $13 << 16 >> 16) + $29 | 0;
        }
        sqlite3MayAbort($0);
        $16 = 2;
       }
       $26 = HEAP32[$1 >> 2];
       HEAP32[$19 + 4 >> 2] = HEAP32[$15 >> 2];
       HEAP32[$19 >> 2] = $26;
       $15 = sqlite3MPrintf($27, 6016, $19);
       sqlite3VdbeAddOp3($14, 69, 1299, $16, $17);
       sqlite3VdbeAppendP4($14, $15, -6);
       sqlite3VdbeChangeP5($14, 1);
       break label$7;
      }
      sqlite3VdbeAddOp2($14, 50, $17, $9);
     }
     $13 = $13 + 1 | 0;
     continue;
    }
    break;
   }
   if ((!($22 | $24) | $20) & 1) {
    break label$3;
   }
   $20 = 1;
   $23 = 0;
   if (!(HEAPU8[$1 + 28 | 0] & 96) | ($24 | 0) <= 0) {
    continue;
   }
   sqlite3ComputeGeneratedColumns($0, $29, $1);
   continue;
  }
 }
 $18 = HEAP32[$1 + 16 >> 2];
 if (!(!$18 | HEAPU8[$27 + 33 | 0] & 2)) {
  HEAP32[$0 + 52 >> 2] = $5 ^ -1;
  $16 = ($8 | 0) == 11 ? 2 : $8;
  $22 = $5 + 1 | 0;
  $13 = 0;
  while (1) {
   if (($13 | 0) < HEAP32[$18 >> 2]) {
    $20 = ($13 << 4) + $18 | 0;
    $15 = HEAP32[$20 + 8 >> 2];
    label$18: {
     if ($11) {
      if (!sqlite3ExprReferencesUpdatedColumn($15, $11, $7)) {
       break label$18;
      }
     }
     if (!$35) {
      sqlite3TableAffinity($14, $1, $22);
      $35 = 1;
     }
     $17 = sqlite3VdbeMakeLabel($0);
     $15 = sqlite3ExprDup($27, $15, 0);
     if (!HEAPU8[$27 + 87 | 0]) {
      sqlite3ExprIfTrue($0, $15, $17, 16);
     }
     sqlite3ExprDelete($27, $15);
     label$22: {
      if (($16 | 0) == 4) {
       sqlite3VdbeGoto($14, $9);
       $16 = 4;
       break label$22;
      }
      $16 = ($16 | 0) == 5 ? 2 : $16;
      sqlite3HaltConstraint($0, 275, $16, HEAP32[$20 + 12 >> 2], 0, 3);
     }
     sqlite3VdbeResolveLabel($14, $17);
    }
    $13 = $13 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$0 + 52 >> 2] = 0;
 }
 HEAP32[$19 + 20 >> 2] = 0;
 HEAP32[$19 + 8 >> 2] = 0;
 HEAP32[$19 + 12 >> 2] = 0;
 $13 = HEAP32[$1 + 8 >> 2];
 HEAP32[$19 + 16 >> 2] = $13;
 $22 = $1 + 8 | 0;
 label$24: {
  label$25: {
   if (!$12) {
    $12 = 0;
    break label$25;
   }
   if (!HEAP32[$12 >> 2]) {
    $13 = HEAPU8[$12 + 20 | 0];
    $8 = $13 ? 6 : 4;
    $12 = $13 ? $12 : 0;
    break label$25;
   }
   if (!$13) {
    break label$25;
   }
   $15 = 0;
   while (1) {
    if ($13) {
     $15 = $15 + 1 | 0;
     $13 = HEAP32[$13 + 20 >> 2];
     continue;
    }
    break;
   }
   HEAP32[$19 + 8 >> 2] = 1;
   HEAP32[$19 + 16 >> 2] = $15;
   $11 = sqlite3DbMallocZero($27, Math_imul($15, 10), 0);
   HEAP32[$19 + 20 >> 2] = $11;
   if (!$11) {
    break label$24;
   }
   HEAP32[$12 + 24 >> 2] = $11;
   $20 = ($15 << 3) + $11 | 0;
   $17 = 0;
   $18 = $12;
   while (1) {
    if (!(!$18 | !HEAP32[$18 >> 2])) {
     $15 = 0;
     $13 = $22;
     $16 = HEAP32[$18 + 28 >> 2];
     label$32: {
      if (!$16) {
       break label$32;
      }
      while (1) {
       $13 = HEAP32[$13 >> 2];
       if (!(!$13 | ($13 | 0) == ($16 | 0))) {
        $15 = $15 + 1 | 0;
        $13 = $13 + 20 | 0;
        continue;
       }
       break;
      }
      $16 = $15 + $20 | 0;
      if (HEAPU8[$16 | 0]) {
       break label$32;
      }
      HEAP8[$16 | 0] = 1;
      $16 = ($17 << 3) + $11 | 0;
      HEAP32[$16 + 4 >> 2] = $15;
      HEAP32[$16 >> 2] = $13;
      $17 = $17 + 1 | 0;
     }
     $18 = HEAP32[$18 + 16 >> 2];
     continue;
    }
    break;
   }
   $13 = 0;
   $15 = $22;
   while (1) {
    $15 = HEAP32[$15 >> 2];
    if (!$15) {
     break label$25;
    }
    if (!HEAPU8[$13 + $20 | 0]) {
     $16 = ($17 << 3) + $11 | 0;
     HEAP32[$16 + 4 >> 2] = $13;
     HEAP32[$16 >> 2] = $15;
     $17 = $17 + 1 | 0;
    }
    $13 = $13 + 1 | 0;
    $15 = $15 + 20 | 0;
    continue;
   }
  }
  label$37: {
   label$38: {
    $11 = HEAP32[$27 + 32 >> 2];
    if ($11 & 24576) {
     label$41: {
      if ($11 & 8192) {
       $32 = sqlite3TriggersExist($0, $1, 128, 0, 0);
       $13 = 1;
       if ($32) {
        break label$41;
       }
       $13 = (sqlite3FkRequired($0, $1, 0, 0) | 0) != 0;
       break label$41;
      }
      $13 = sqlite3FkRequired($0, $1, 0, 0);
     }
     if ($13) {
      break label$38;
     }
    }
    $33 = 0;
    break label$37;
   }
   $28 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $28;
   sqlite3VdbeAddOp2($14, 71, 0, $28);
   $33 = sqlite3VdbeMakeLabel($0);
  }
  label$43: {
   if ($21 | !$7) {
    break label$43;
   }
   $15 = sqlite3VdbeMakeLabel($0);
   $13 = $8;
   if (($13 | 0) == 11) {
    $13 = HEAPU8[$1 + 42 | 0];
    $13 = ($13 | 0) == 11 ? 2 : $13;
   }
   label$46: {
    if (!$12) {
     break label$46;
    }
    $25 = sqlite3UpsertOfIndex($12, 0);
    if ($25) {
     $13 = HEAPU8[$25 + 20 | 0] ? 6 : 4;
    }
    if (($12 | 0) == ($25 | 0)) {
     $25 = $12;
     break label$46;
    }
    $36 = sqlite3VdbeAddOp0($14, 8);
   }
   if (!(($8 | 0) == 5 | ($13 | 0) != 5 | (!HEAP32[$22 >> 2] | $36))) {
    $34 = sqlite3VdbeAddOp0($14, 8) + 1 | 0;
   }
   if ($6) {
    sqlite3VdbeAddOp3($14, 53, $5, $15, $6);
    sqlite3VdbeChangeP5($14, 144);
   }
   sqlite3VdbeAddOp3($14, 30, $3, $15, $5);
   label$52: {
    label$53: {
     label$54: {
      switch ($13 - 1 | 0) {
      default:
       $13 = 2;

      case 0:
      case 1:
      case 2:
       sqlite3RowidConstraint($0, $13, $1);
       break label$53;

      case 4:
       if ($28) {
        sqlite3MultiWrite($0);
        sqlite3GenerateRowDelete($0, $1, $32, $3, $4, $5, 1, 0, 5, 1, -1);
        sqlite3VdbeAddOp2($14, 86, $28, 1);
        $40 = 1;
        $11 = 1;
        break label$52;
       }
       $40 = 1;
       $11 = 0;
       if (!HEAP32[$22 >> 2]) {
        break label$52;
       }
       sqlite3MultiWrite($0);
       sqlite3GenerateRowIndexDelete($0, $1, $3, $4, 0, -1);
       $11 = 0;
       break label$52;

      case 5:
       sqlite3UpsertDoUpdate($0, $12, $1, 0, $3);
       break;

      case 3:
       break label$54;
      }
     }
     sqlite3VdbeGoto($14, $9);
    }
    $11 = 0;
   }
   $41 = $11;
   sqlite3VdbeResolveLabel($14, $15);
   if (!(!$12 | ($12 | 0) == ($25 | 0))) {
    $42 = sqlite3VdbeAddOp0($14, 8);
    break label$43;
   }
   if (!$34) {
    $34 = 0;
    break label$43;
   }
   $44 = sqlite3VdbeAddOp0($14, 8);
   sqlite3VdbeJumpHere($14, $34 - 1 | 0);
  }
  $45 = ($6 | 0) != 0 & ($32 | 0) != 0;
  $46 = $36 + 1 | 0;
  $47 = $6 + 1 | 0;
  $17 = $5 ^ -1;
  $22 = $5 + 1 | 0;
  $15 = indexIteratorFirst($19 + 8 | 0, $19 + 28 | 0);
  $30 = $33;
  while (1) {
   label$63: {
    label$64: {
     label$65: {
      if ($15) {
       $26 = HEAP32[$19 + 28 >> 2];
       $11 = ($26 << 2) + $2 | 0;
       if (!HEAP32[$11 >> 2]) {
        break label$63;
       }
       label$67: {
        if (!$12) {
         break label$67;
        }
        $25 = sqlite3UpsertOfIndex($12, $15);
        if (!$36 | ($25 | 0) != ($12 | 0)) {
         break label$67;
        }
        sqlite3VdbeJumpHere($14, $36);
        $25 = $12;
       }
       $20 = sqlite3VdbeMakeLabel($0);
       if (!$35) {
        sqlite3TableAffinity($14, $1, $22);
        $35 = 1;
       }
       if (HEAP32[$15 + 36 >> 2]) {
        sqlite3VdbeAddOp2($14, 75, 0, HEAP32[$11 >> 2]);
        HEAP32[$0 + 52 >> 2] = $17;
        sqlite3ExprIfFalseDup($0, HEAP32[$15 + 36 >> 2], $20);
        HEAP32[$0 + 52 >> 2] = 0;
       }
       $24 = $4 + $26 | 0;
       $43 = HEAP32[$11 >> 2];
       $18 = $43 + 1 | 0;
       $13 = 0;
       while (1) {
        $16 = HEAPU16[$15 + 52 >> 1];
        if ($13 >>> 0 < $16 >>> 0) {
         label$72: {
          label$73: {
           label$74: {
            label$75: {
             label$76: {
              $16 = HEAPU16[HEAP32[$15 + 4 >> 2] + ($13 << 1) >> 1];
              switch ($16 - 65534 | 0) {
              case 1:
               break label$74;

              case 0:
               break label$76;

              default:
               break label$75;
              }
             }
             HEAP32[$0 + 52 >> 2] = $17;
             sqlite3ExprCodeCopy($0, HEAP32[(HEAP32[$15 + 40 >> 2] + ($13 << 4) | 0) + 8 >> 2], $13 + $18 | 0);
             HEAP32[$0 + 52 >> 2] = 0;
             break label$72;
            }
            if (HEAPU16[$1 + 32 >> 1] != ($16 | 0)) {
             break label$73;
            }
           }
           sqlite3VdbeAddOp2($14, 82, $5, $13 + $18 | 0);
           break label$72;
          }
          sqlite3VdbeAddOp2($14, 81, sqlite3TableColumnToStorage($1, $16 << 16 >> 16) + $22 | 0, $13 + $18 | 0);
         }
         $13 = $13 + 1 | 0;
         continue;
        }
        break;
       }
       sqlite3VdbeAddOp3($14, 97, $18, $16, HEAP32[$11 >> 2]);
       if (!(!$6 | $7) & ($15 | 0) == ($21 | 0)) {
        break label$64;
       }
       $13 = HEAPU8[$15 + 54 | 0];
       if (!$13) {
        break label$64;
       }
       $37 = $25 ? HEAPU8[$25 + 20 | 0] ? 6 : 4 : ($8 | 0) == 11 ? ($13 | 0) == 11 ? 2 : $13 : $8;
       label$79: {
        if (HEAP32[$15 + 20 >> 2] | ($15 | 0) != ($21 | 0) | ($37 | 0) != 5 | $26) {
         break label$79;
        }
        $11 = HEAP32[$27 + 32 >> 2];
        if ($11 & 8192) {
         if (sqlite3TriggersExist($0, $1, 128, 0, 0)) {
          break label$79;
         }
         $11 = HEAP32[$27 + 32 >> 2];
        }
        if (!($11 & 16384)) {
         break label$64;
        }
        if (HEAP32[$1 + 48 >> 2]) {
         break label$79;
        }
        if (!sqlite3FkReferences($1)) {
         break label$64;
        }
       }
       $38 = sqlite3VdbeAddOp4Int($14, 26, $24, $20, $18, HEAPU16[$15 + 50 >> 1]);
       $23 = $18;
       $39 = ($15 | 0) == ($21 | 0);
       if (!$39) {
        $23 = sqlite3GetTempRange($0, $31);
       }
       if (!$6 & ($37 | 0) != 5) {
        break label$65;
       }
       if (!(HEAPU8[$1 + 28 | 0] & 128)) {
        sqlite3VdbeAddOp2($14, 142, $24, $23);
        if (!$6) {
         break label$65;
        }
        sqlite3VdbeAddOp3($14, 53, $23, $20, $6);
        sqlite3VdbeChangeP5($14, 144);
        break label$65;
       }
       $13 = 0;
       label$83: {
        if ($39) {
         break label$83;
        }
        while (1) {
         if (HEAPU16[$21 + 50 >> 1] <= $13 >>> 0) {
          break label$83;
         }
         sqlite3VdbeAddOp3($14, 94, $24, sqlite3TableColumnToIndex($15, HEAP16[HEAP32[$21 + 4 >> 2] + ($13 << 1) >> 1]), $13 + $23 | 0);
         $13 = $13 + 1 | 0;
         continue;
        }
       }
       if (!$6) {
        break label$65;
       }
       $48 = ((HEAPU8[$15 + 55 | 0] | HEAPU8[$15 + 56 | 0] << 8) & 3) == 2 ? $18 : $23;
       $11 = sqlite3VdbeCurrentAddr($14);
       $16 = HEAPU16[$21 + 50 >> 1];
       $11 = $11 + $16 | 0;
       $13 = 0;
       $26 = 52;
       while (1) {
        if (($16 & 65535) >>> 0 <= $13 >>> 0) {
         break label$65;
        }
        $16 = sqlite3LocateCollSeq($0, HEAP32[HEAP32[$21 + 32 >> 2] + ($13 << 2) >> 2]);
        $29 = (HEAPU16[$21 + 50 >> 1] - 1 | 0) == ($13 | 0);
        $26 = $29 ? 53 : $26;
        $11 = $29 ? $20 : $11;
        sqlite3VdbeAddOp4($14, $26, sqlite3TableColumnToStorage($1, HEAP16[HEAP32[$21 + 4 >> 2] + ($13 << 1) >> 1]) + $47 | 0, $11, $13 + $48 | 0, $16, -2);
        sqlite3VdbeChangeP5($14, 144);
        $13 = $13 + 1 | 0;
        $16 = HEAPU16[$21 + 50 >> 1];
        continue;
       }
      }
      if ($34) {
       sqlite3VdbeGoto($14, $34);
       sqlite3VdbeJumpHere($14, $44);
      }
      if ($41) {
       sqlite3VdbeAddOp2($14, 16, $28, $30);
       label$88: {
        if (!$21) {
         if ($6) {
          sqlite3VdbeAddOp3($14, 53, $5, $33, $6);
          sqlite3VdbeChangeP5($14, 144);
         }
         sqlite3VdbeAddOp3($14, 30, $3, $33, $5);
         sqlite3RowidConstraint($0, 2, $1);
         break label$88;
        }
        sqlite3VdbeGoto($14, $33);
       }
       sqlite3VdbeResolveLabel($14, $30);
      }
      label$91: {
       if (HEAPU8[$1 + 28 | 0] & 128) {
        break label$91;
       }
       sqlite3VdbeAddOp3($14, 97, $22, HEAP16[$1 + 36 >> 1], HEAP32[(HEAP32[$19 + 28 >> 2] << 2) + $2 >> 2]);
       if ($35) {
        break label$91;
       }
       sqlite3TableAffinity($14, $1, 0);
      }
      HEAP32[$10 >> 2] = $40;
      break label$24;
     }
     label$92: {
      label$93: {
       switch ($37 - 1 | 0) {
       case 0:
       case 1:
       case 2:
        sqlite3UniqueConstraint($0, $37, $15);
        break label$92;

       case 5:
        sqlite3UpsertDoUpdate($0, $12, $1, $15, $24);

       case 3:
        sqlite3VdbeGoto($14, $9);
        break label$92;

       default:
        break label$93;
       }
      }
      $13 = sqlite3VdbeCurrentAddr($14);
      if ($28) {
       sqlite3MultiWrite($0);
       $41 = $41 + 1 | 0;
      }
      label$98: {
       if ($45) {
        sqlite3VdbeAddOp1($14, 167, $3);
        sqlite3GenerateRowDelete($0, $1, $32, $3, $4, $23, $31 << 16 >> 16, 0, 5, $39, $24);
        sqlite3VdbeAddOp1($14, 168, $3);
        break label$98;
       }
       sqlite3GenerateRowDelete($0, $1, $32, $3, $4, $23, $31 << 16 >> 16, 0, 5, $39, $24);
      }
      $40 = 1;
      if (!$28) {
       break label$92;
      }
      sqlite3VdbeAddOp2($14, 86, $28, 1);
      $24 = sqlite3VdbeAddOp0($14, 8);
      sqlite3VdbeResolveLabel($14, $30);
      $30 = sqlite3VdbeMakeLabel($0);
      if (HEAP32[$15 + 36 >> 2]) {
       sqlite3VdbeAddOp2($14, 50, $43, $30);
      }
      $16 = $13 - $38 | 0;
      while (1) {
       if (($16 | 0) > 0) {
        $13 = sqlite3VdbeGetOp($14, $38);
        $11 = HEAPU8[$13 | 0];
        if (($11 | 0) != 142) {
         $26 = HEAPU16[$13 + 2 >> 1];
         sqlite3VdbeAddOp4($14, $11, HEAP32[$13 + 4 >> 2], HEAP8[$11 + 34208 | 0] & 1 ? $30 : HEAP32[$13 + 8 >> 2], HEAP32[$13 + 12 >> 2], HEAP32[$13 + 16 >> 2], HEAP8[$13 + 1 | 0]);
         sqlite3VdbeChangeP5($14, $26);
        }
        $38 = $38 + 1 | 0;
        $16 = $16 - 1 | 0;
        continue;
       }
       break;
      }
      sqlite3UniqueConstraint($0, 2, $15);
      sqlite3VdbeJumpHere($14, $24);
     }
     sqlite3VdbeResolveLabel($14, $20);
     if (($18 | 0) != ($23 | 0)) {
      sqlite3ReleaseTempRange($0, $23, $31);
     }
     if (!$25 | !$42) {
      break label$63;
     }
     if (!sqlite3UpsertNextIsIPK($25)) {
      break label$63;
     }
     sqlite3VdbeGoto($14, $46);
     sqlite3VdbeJumpHere($14, $42);
     $42 = 0;
     break label$63;
    }
    sqlite3VdbeResolveLabel($14, $20);
   }
   $15 = indexIteratorNext($19 + 8 | 0, $19 + 28 | 0);
   continue;
  }
 }
 __stack_pointer = $19 + 32 | 0;
}

function sqlite3Insert($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0;
 $7 = __stack_pointer - 160 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 156 >> 2] = 0;
 HEAP32[$7 + 152 >> 2] = 0;
 $18 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   $13 = $2;
   break label$1;
  }
  HEAP32[$7 + 124 >> 2] = 0;
  $13 = 0;
  label$3: {
   if (!$2) {
    break label$3;
   }
   if (!(HEAP32[$2 + 52 >> 2] | !(HEAPU8[$2 + 5 | 0] & 2))) {
    $22 = HEAP32[$2 + 28 >> 2];
    HEAP32[$2 + 28 >> 2] = 0;
    sqlite3SelectDelete($18, $2);
    $13 = 0;
    break label$3;
   }
   $13 = $2;
  }
  $2 = sqlite3SrcListLookup($0, $1);
  if (!$2) {
   break label$1;
  }
  $12 = HEAP32[$2 >> 2];
  $6 = HEAP32[$18 + 16 >> 2];
  $16 = sqlite3SchemaToIndex($18, HEAP32[$2 + 60 >> 2]);
  if (sqlite3AuthCheck($0, 18, $12, 0, HEAP32[$6 + ($16 << 4) >> 2])) {
   break label$1;
  }
  $32 = HEAP32[$2 + 28 >> 2];
  $25 = sqlite3TriggersExist($0, $2, 127, 0, $7 + 116 | 0);
  $30 = HEAPU8[$2 + 43 | 0];
  if (sqlite3ViewGetColumnNames($0, $2)) {
   break label$1;
  }
  if (sqlite3IsReadOnly($0, $2, HEAP32[$7 + 116 >> 2])) {
   break label$1;
  }
  $8 = sqlite3GetVdbe($0);
  if (!$8) {
   break label$1;
  }
  if (!HEAPU8[$0 + 18 | 0]) {
   sqlite3VdbeCountChanges($8);
  }
  sqlite3BeginWriteOperation($0, ($13 | $25) != 0, $16);
  label$6: {
   if (!(!$13 | $3 | $25)) {
    if (xferOptimization($0, $2, $13, $4, $16)) {
     break label$6;
    }
   }
   $26 = autoIncBegin($0, $16, $2);
   $9 = HEAP32[$0 + 44 >> 2];
   $23 = $9 + 1 | 0;
   $6 = $23 + HEAP16[$2 + 34 >> 1] | 0;
   HEAP32[$0 + 44 >> 2] = $6;
   $14 = $23;
   if (HEAPU8[$2 + 43 | 0] == 1) {
    HEAP32[$0 + 44 >> 2] = $6 + 1;
    $14 = $9 + 2 | 0;
   }
   $21 = !(HEAPU16[$2 + 28 >> 1] & 1088);
   label$9: {
    label$10: {
     label$11: {
      label$12: {
       if (!$3) {
        $12 = -1;
        break label$12;
       }
       HEAP8[$3 + 4 | 0] = 1;
       $9 = 0;
       $6 = HEAP32[$3 >> 2];
       $20 = ($6 | 0) > 0 ? $6 : 0;
       while (1) if (($9 | 0) == ($20 | 0)) {
        $12 = -1;
        while (1) {
         if (($15 | 0) == ($20 | 0)) {
          break label$12;
         }
         $9 = 0;
         $6 = HEAP16[$2 + 34 >> 1];
         $10 = ($6 | 0) > 0 ? $6 : 0;
         $17 = ($15 << 3) + $3 | 0;
         $6 = HEAP32[$17 + 8 >> 2];
         label$17: {
          label$18: {
           while (1) {
            if (($9 | 0) == ($10 | 0)) {
             break label$18;
            }
            label$20: {
             $11 = Math_imul($9, 12);
             if (!sqlite3StrICmp($6, HEAP32[$11 + HEAP32[$2 + 4 >> 2] >> 2])) {
              HEAP32[$17 + 12 >> 2] = $9;
              $10 = HEAP32[$2 + 4 >> 2];
              if (!(HEAPU8[($11 + $10 | 0) + 10 | 0] & 96)) {
               break label$20;
              }
              HEAP32[$7 + 64 >> 2] = HEAP32[Math_imul($9, 12) + $10 >> 2];
              sqlite3ErrorMsg($0, 28552, $7 - -64 | 0);
              break label$11;
             }
             $9 = $9 + 1 | 0;
             continue;
            }
            break;
           }
           if (HEAP16[$2 + 34 >> 1] <= ($9 | 0)) {
            break label$18;
           }
           $21 = ($9 | 0) == ($15 | 0) ? $21 : 0;
           $12 = HEAP16[$2 + 32 >> 1] == ($9 | 0) ? $15 : $12;
           break label$17;
          }
          if (sqlite3IsRowid($6)) {
           $21 = 0;
           $12 = $15;
           if ($32 << 24 >> 24 >= 0) {
            break label$17;
           }
          }
          HEAP32[$7 + 52 >> 2] = $6;
          HEAP32[$7 + 48 >> 2] = $1 + 8;
          sqlite3ErrorMsg($0, 6744, $7 + 48 | 0);
          HEAP8[$0 + 17 | 0] = 1;
          break label$11;
         }
         $15 = $15 + 1 | 0;
         continue;
        }
       } else {
        HEAP32[(($9 << 3) + $3 | 0) + 12 >> 2] = -1;
        $9 = $9 + 1 | 0;
        continue;
       }
      }
      $20 = $14 + 1 | 0;
      label$24: {
       label$25: {
        if ($13) {
         $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
         HEAP32[$0 + 44 >> 2] = $6;
         $9 = 0;
         $10 = sqlite3VdbeCurrentAddr($8);
         sqlite3VdbeAddOp3($8, 10, $6, 0, $10 + 1 | 0);
         sqlite3SelectDestInit($7 + 120 | 0, 13, $6);
         HEAP32[$7 + 132 >> 2] = $21 & 255 ? $20 : 0;
         HEAP32[$7 + 136 >> 2] = HEAP16[$2 + 34 >> 1];
         if (sqlite3Select($0, $13, $7 + 120 | 0) | HEAP32[$0 + 36 >> 2]) {
          break label$1;
         }
         $27 = HEAP32[$7 + 132 >> 2];
         sqlite3VdbeEndCoroutine($8, $6);
         sqlite3VdbeJumpHere($8, $10);
         $17 = HEAP32[HEAP32[$13 + 28 >> 2] >> 2];
         if ($25) {
          break label$25;
         }
         if (readsTable($0, $16, $2)) {
          break label$25;
         }
         $24 = 1;
         break label$24;
        }
        HEAP32[$7 + 108 >> 2] = 0;
        HEAP32[$7 + 100 >> 2] = 0;
        HEAP32[$7 + 104 >> 2] = 0;
        HEAP32[$7 + 92 >> 2] = 0;
        HEAP32[$7 + 96 >> 2] = 0;
        HEAP32[$7 + 84 >> 2] = 0;
        HEAP32[$7 + 88 >> 2] = 0;
        HEAP32[$7 + 80 >> 2] = $0;
        $17 = 0;
        label$27: {
         if ($22) {
          $17 = HEAP32[$22 >> 2];
          if (sqlite3ResolveExprListNames($7 + 80 | 0, $22)) {
           break label$27;
          }
         }
         $19 = -1;
         $24 = 1;
         break label$24;
        }
        $9 = 0;
        $13 = 0;
        break label$1;
       }
       $19 = HEAP32[$0 + 40 >> 2];
       HEAP32[$0 + 40 >> 2] = $19 + 1;
       $9 = sqlite3GetTempReg($0);
       $6 = sqlite3GetTempReg($0);
       sqlite3VdbeAddOp2($8, 118, $19, $17);
       $10 = sqlite3VdbeAddOp1($8, 11, HEAP32[$7 + 124 >> 2]);
       sqlite3VdbeAddOp3($8, 97, $27, $17, $9);
       sqlite3VdbeAddOp2($8, 127, $19, $6);
       sqlite3VdbeAddOp3($8, 128, $19, $9, $6);
       sqlite3VdbeGoto($8, $10);
       sqlite3VdbeJumpHere($8, $10);
       sqlite3ReleaseTempReg($0, $9);
       sqlite3ReleaseTempReg($0, $6);
       $24 = 0;
      }
      label$29: {
       if (($17 | 0) <= 0 | $3) {
        break label$29;
       }
       $6 = 0;
       label$30: {
        $10 = HEAP32[$2 + 28 >> 2];
        $12 = HEAP16[$2 + 32 >> 1];
        if (!($10 & 96) | ($12 | 0) < 0) {
         break label$30;
        }
        $9 = $12;
        while (1) {
         if (($9 | 0) <= 0) {
          break label$30;
         }
         $9 = $9 - 1 | 0;
         $12 = $12 - ((HEAPU8[(HEAP32[$2 + 4 >> 2] + Math_imul($9, 12) | 0) + 10 | 0] & 96) != 0) | 0;
         continue;
        }
       }
       $11 = HEAP16[$2 + 34 >> 1];
       label$32: {
        if (!($10 & 98)) {
         break label$32;
        }
        $10 = ($11 | 0) > 0 ? $11 : 0;
        $9 = 0;
        while (1) {
         if (($9 | 0) == ($10 | 0)) {
          break label$32;
         }
         $6 = ((HEAPU8[(HEAP32[$2 + 4 >> 2] + Math_imul($9, 12) | 0) + 10 | 0] & 98) != 0) + $6 | 0;
         $9 = $9 + 1 | 0;
         continue;
        }
       }
       $9 = $11 - $6 | 0;
       if (($17 | 0) == ($9 | 0)) {
        break label$29;
       }
       HEAP32[$7 + 40 >> 2] = $17;
       HEAP32[$7 + 36 >> 2] = $9;
       HEAP32[$7 + 32 >> 2] = $1 + 8;
       sqlite3ErrorMsg($0, 15536, $7 + 32 | 0);
       break label$11;
      }
      label$34: {
       if (!$3) {
        break label$34;
       }
       $9 = HEAP32[$3 >> 2];
       if (($17 | 0) == ($9 | 0)) {
        break label$34;
       }
       HEAP32[$7 + 20 >> 2] = $9;
       HEAP32[$7 + 16 >> 2] = $17;
       sqlite3ErrorMsg($0, 4888, $7 + 16 | 0);
       break label$11;
      }
      $9 = 0;
      $15 = 0;
      if (!(HEAPU8[$0 + 18 | 0] | !(HEAP8[$18 + 36 | 0] & 1) | (HEAP32[$0 + 120 >> 2] | HEAPU8[$0 + 149 | 0]))) {
       $15 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $15;
       sqlite3VdbeAddOp2($8, 71, 0, $15);
      }
      if (($30 | 0) == 2) {
       break label$9;
      }
      $10 = sqlite3OpenTableAndIndices($0, $2, 113, 0, -1, 0, $7 + 156 | 0, $7 + 152 | 0);
      $9 = sqlite3DbMallocRawNN($18, ($10 << 2) + 8 | 0, 0);
      if ($9) {
       break label$10;
      }
     }
     $9 = 0;
     break label$1;
    }
    $6 = 0;
    $16 = ($10 | 0) > 0 ? $10 : 0;
    $10 = $2 + 8 | 0;
    while (1) {
     if (($6 | 0) != ($16 | 0)) {
      $10 = HEAP32[$10 >> 2];
      $11 = HEAP32[$0 + 44 >> 2] + 1 | 0;
      HEAP32[$0 + 44 >> 2] = $11;
      HEAP32[($6 << 2) + $9 >> 2] = $11;
      HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + HEAPU16[$10 + 52 >> 1];
      $6 = $6 + 1 | 0;
      $10 = $10 + 20 | 0;
      continue;
     }
     break;
    }
    $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
    HEAP32[$0 + 44 >> 2] = $6;
    HEAP32[($16 << 2) + $9 >> 2] = $6;
   }
   if ($5) {
    label$39: {
     switch (HEAPU8[$2 + 43 | 0] - 1 | 0) {
     case 0:
      HEAP32[$7 >> 2] = HEAP32[$2 >> 2];
      sqlite3ErrorMsg($0, 28671, $7);
      break label$1;

     case 1:
      sqlite3ErrorMsg($0, 1810, 0);
      break label$1;

     default:
      break label$39;
     }
    }
    if (sqlite3HasExplicitNulls($0, HEAP32[$5 >> 2])) {
     break label$1;
    }
    HEAP32[$1 + 48 >> 2] = HEAP32[$7 + 156 >> 2];
    $6 = $5;
    while (1) {
     HEAP32[$6 + 36 >> 2] = $20;
     HEAP32[$6 + 32 >> 2] = $1;
     HEAP32[$6 + 40 >> 2] = HEAP32[$7 + 156 >> 2];
     HEAP32[$6 + 44 >> 2] = HEAP32[$7 + 152 >> 2];
     if (HEAP32[$6 >> 2]) {
      if (sqlite3UpsertAnalyzeTarget($0, $1, $6)) {
       break label$1;
      }
     }
     $6 = HEAP32[$6 + 16 >> 2];
     if ($6) {
      continue;
     }
     break;
    }
   }
   label$44: {
    if (!$24) {
     $31 = sqlite3VdbeAddOp1($8, 35, $19);
     $28 = sqlite3VdbeCurrentAddr($8);
     break label$44;
    }
    if (!$13) {
     break label$44;
    }
    $28 = sqlite3VdbeAddOp1($8, 11, HEAP32[$7 + 124 >> 2]);
    if (($12 | 0) >= 0) {
     sqlite3VdbeAddOp2($8, 80, $12 + $27 | 0, $14);
    }
    $31 = $28;
   }
   $21 = 0;
   $11 = $20;
   $10 = 0;
   while (1) {
    if (($10 | 0) < HEAP16[$2 + 34 >> 1]) {
     label$50: {
      if (HEAP16[$2 + 32 >> 1] == ($10 | 0)) {
       sqlite3VdbeAddOp1($8, 76, $11);
       break label$50;
      }
      label$52: {
       label$53: {
        $29 = HEAP32[$2 + 4 >> 2] + Math_imul($10, 12) | 0;
        $6 = HEAPU16[$29 + 10 >> 1];
        label$54: {
         if ($6 & 98) {
          $21 = $21 + 1 | 0;
          if ($6 & 32) {
           $11 = $11 - 1 | 0;
           break label$50;
          }
          if ($6 & 64) {
           if (!(HEAP8[$7 + 116 | 0] & 1)) {
            break label$50;
           }
           sqlite3VdbeAddOp1($8, 76, $11);
           break label$50;
          }
          if ($3) {
           break label$54;
          }
          sqlite3ExprCodeFactorable($0, sqlite3ColumnExpr($2, $29), $11);
          break label$50;
         }
         if (!$3) {
          break label$53;
         }
        }
        $6 = 0;
        $16 = HEAP32[$3 >> 2];
        $16 = ($16 | 0) > 0 ? $16 : 0;
        while (1) {
         if (($6 | 0) != ($16 | 0)) {
          if (HEAP32[(($6 << 3) + $3 | 0) + 12 >> 2] == ($10 | 0)) {
           break label$52;
          }
          $6 = $6 + 1 | 0;
          continue;
         }
         break;
        }
        sqlite3ExprCodeFactorable($0, sqlite3ColumnExpr($2, $29), $11);
        break label$50;
       }
       if (!$17) {
        sqlite3ExprCodeFactorable($0, sqlite3ColumnExpr($2, $29), $11);
        break label$50;
       }
       $6 = $10 - $21 | 0;
      }
      if (!$24) {
       sqlite3VdbeAddOp3($8, 94, $19, $6, $11);
       break label$50;
      }
      if ($13) {
       if (($20 | 0) == ($27 | 0)) {
        break label$50;
       }
       sqlite3VdbeAddOp2($8, 81, $6 + $27 | 0, $11);
       break label$50;
      }
      sqlite3ExprCode($0, HEAP32[(($6 << 4) + $22 | 0) + 8 >> 2], $11);
     }
     $11 = $11 + 1 | 0;
     $10 = $10 + 1 | 0;
     continue;
    }
    break;
   }
   $10 = sqlite3VdbeMakeLabel($0);
   if (HEAP8[$7 + 116 | 0] & 1) {
    $6 = sqlite3GetTempRange($0, HEAP16[$2 + 34 >> 1] + 1 | 0);
    label$64: {
     if (($12 | 0) < 0) {
      sqlite3VdbeAddOp2($8, 71, -1, $6);
      break label$64;
     }
     label$66: {
      if (!$24) {
       sqlite3VdbeAddOp3($8, 94, $19, $12, $6);
       break label$66;
      }
      sqlite3ExprCode($0, HEAP32[(($12 << 4) + $22 | 0) + 8 >> 2], $6);
     }
     $11 = sqlite3VdbeAddOp1($8, 51, $6);
     sqlite3VdbeAddOp2($8, 71, -1, $6);
     sqlite3VdbeJumpHere($8, $11);
     sqlite3VdbeAddOp1($8, 12, $6);
    }
    $11 = $6 + 1 | 0;
    sqlite3VdbeAddOp3($8, 80, $20, $11, HEAP16[$2 + 36 >> 1] - 1 | 0);
    if (HEAPU8[$2 + 28 | 0] & 96) {
     sqlite3ComputeGeneratedColumns($0, $11, $2);
    }
    if (($30 | 0) != 2) {
     sqlite3TableAffinity($8, $2, $11);
    }
    sqlite3CodeRowTrigger($0, $25, 127, 0, 1, $2, (HEAP16[$2 + 34 >> 1] ^ -1) + $6 | 0, $4, $10);
    sqlite3ReleaseTempRange($0, $6, HEAP16[$2 + 34 >> 1] + 1 | 0);
   }
   label$70: {
    if (($30 | 0) == 2) {
     break label$70;
    }
    if (HEAPU8[$2 + 43 | 0] == 1) {
     sqlite3VdbeAddOp2($8, 75, 0, $23);
    }
    label$72: {
     label$73: {
      if (($12 | 0) >= 0) {
       label$75: {
        if (!$24) {
         sqlite3VdbeAddOp3($8, 94, $19, $12, $14);
         break label$75;
        }
        if ($13) {
         break label$75;
        }
        $6 = HEAP32[(($12 << 4) + $22 | 0) + 8 >> 2];
        if (HEAPU8[$6 | 0] == 121) {
         $11 = 1;
         if (HEAPU8[$2 + 43 | 0] != 1) {
          break label$73;
         }
        }
        sqlite3ExprCode($0, $6, $14);
       }
       label$78: {
        if (HEAPU8[$2 + 43 | 0] != 1) {
         $6 = sqlite3VdbeAddOp1($8, 51, $14);
         sqlite3VdbeAddOp3($8, 127, HEAP32[$7 + 156 >> 2], $14, $26);
         sqlite3VdbeJumpHere($8, $6);
         break label$78;
        }
        sqlite3VdbeAddOp2($8, 50, $14, sqlite3VdbeCurrentAddr($8) + 2 | 0);
       }
       sqlite3VdbeAddOp1($8, 12, $14);
       $11 = 0;
       break label$72;
      }
      if (!(HEAPU8[$2 + 43 | 0] != 1 & $32 << 24 >> 24 >= 0)) {
       $11 = 0;
       sqlite3VdbeAddOp2($8, 75, 0, $14);
       break label$72;
      }
      sqlite3VdbeAddOp3($8, 127, HEAP32[$7 + 156 >> 2], $14, $26);
      $11 = 1;
      break label$72;
     }
     sqlite3VdbeAddOp3($8, 127, HEAP32[$7 + 156 >> 2], $14, $26);
    }
    autoIncStep($0, $26, $14);
    if (HEAPU8[$2 + 28 | 0] & 96) {
     sqlite3ComputeGeneratedColumns($0, $20, $2);
    }
    $6 = 1;
    if (HEAPU8[$2 + 43 | 0] == 1) {
     $6 = sqlite3GetVTable($18, $2);
     sqlite3VtabMakeWritable($0, $2);
     sqlite3VdbeAddOp4($8, 7, 1, HEAP16[$2 + 34 >> 1] + 2 | 0, $23, $6, -11);
     sqlite3VdbeChangeP5($8, (($4 | 0) == 11 ? 2 : $4) & 65535);
     sqlite3MayAbort($0);
     break label$70;
    }
    HEAP32[$7 + 80 >> 2] = 0;
    sqlite3GenerateConstraintChecks($0, $2, $9, HEAP32[$7 + 156 >> 2], HEAP32[$7 + 152 >> 2], $23, 0, ($12 ^ -1) >>> 31 | 0, $4 & 255, $10, $7 + 80 | 0, 0, $5);
    sqlite3FkCheck($0, $2, 0, $23, 0, 0);
    if (HEAP32[$7 + 80 >> 2]) {
     $6 = !sqlite3VdbeHasSubProgram($8);
    }
    sqlite3CompleteInsertion($0, $2, HEAP32[$7 + 156 >> 2], HEAP32[$7 + 152 >> 2], $23, $9, 0, $11, $6);
   }
   if ($15) {
    sqlite3VdbeAddOp2($8, 86, $15, 1);
   }
   if ($25) {
    sqlite3CodeRowTrigger($0, $25, 127, 0, 2, $2, (HEAP16[$2 + 34 >> 1] ^ -1) + $14 | 0, $4, $10);
   }
   sqlite3VdbeResolveLabel($8, $10);
   if (!$24) {
    sqlite3VdbeAddOp2($8, 38, $19, $28);
    sqlite3VdbeJumpHere($8, $31);
    sqlite3VdbeAddOp1($8, 122, $19);
    break label$6;
   }
   if (!$13) {
    break label$6;
   }
   sqlite3VdbeGoto($8, $28);
   sqlite3VdbeJumpHere($8, $31);
  }
  if (!(HEAPU8[$0 + 18 | 0] | HEAP32[$0 + 120 >> 2])) {
   sqlite3AutoincrementEnd($0);
  }
  if (!$15) {
   break label$1;
  }
  sqlite3CodeChangeCount($8, $15, 14825);
 }
 sqlite3SrcListDelete($18, $1);
 sqlite3ExprListDelete($18, $22);
 sqlite3UpsertDelete($18, $5);
 sqlite3SelectDelete($18, $13);
 sqlite3IdListDelete($18, $3);
 sqlite3DbFree($18, $9);
 __stack_pointer = $7 + 160 | 0;
}

function resolveExprStep($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $6 = __stack_pointer - 144 | 0;
 __stack_pointer = $6;
 $4 = HEAP32[$0 + 24 >> 2];
 $5 = HEAP32[$4 >> 2];
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$10: {
           label$11: {
            label$12: {
             label$13: {
              label$14: {
               label$15: {
                label$16: {
                 $2 = HEAPU8[$1 | 0];
                 switch ($2 - 45 | 0) {
                 case 14:
                  break label$13;

                 case 5:
                 case 6:
                  break label$14;

                 case 30:
                  break label$15;

                 case 1:
                 case 2:
                 case 13:
                 case 15:
                 case 16:
                 case 17:
                 case 18:
                 case 19:
                 case 20:
                 case 21:
                 case 22:
                 case 23:
                 case 24:
                 case 25:
                 case 26:
                 case 27:
                 case 28:
                 case 29:
                  break label$3;

                 case 3:
                 case 7:
                 case 8:
                 case 9:
                 case 10:
                 case 11:
                 case 12:
                  break label$7;

                 case 0:
                  break label$8;

                 case 4:
                  break label$9;

                 default:
                  break label$16;
                 }
                }
                label$17: {
                 switch ($2 - 138 | 0) {
                 case 3:
                  break label$12;

                 case 1:
                 case 2:
                  break label$3;

                 case 0:
                  break label$9;

                 default:
                  break label$17;
                 }
                }
                label$18: {
                 switch ($2 - 171 | 0) {
                 case 1:
                  break label$10;

                 case 0:
                  break label$8;

                 default:
                  break label$18;
                 }
                }
                if (($2 | 0) == 20) {
                 break label$9;
                }
                if (!(HEAPU8[$4 + 24 | 0] & 46) | ($2 | 0) != 156) {
                 break label$3;
                }
                notValidImpl($5, $4, 4162, $1, $1);
                break label$3;
               }
               $2 = HEAP32[$4 + 4 >> 2];
               HEAP8[$1 | 0] = 167;
               HEAP32[$1 + 44 >> 2] = HEAP32[$2 + 24 >> 2];
               HEAP32[$1 + 28 >> 2] = HEAP32[$2 + 48 >> 2];
               HEAP16[$1 + 32 >> 1] = HEAPU16[$1 + 32 >> 1] - 1;
               HEAP8[$1 + 1 | 0] = 68;
               break label$3;
              }
              $2 = $4;
              while (1) {
               if (!(!$2 | $3 >>> 0 > 7)) {
                HEAP32[($6 + 112 | 0) + ($3 << 2) >> 2] = HEAP32[$2 + 16 >> 2];
                $3 = $3 + 1 | 0;
                $2 = HEAP32[$2 + 12 >> 2];
                continue;
               }
               break;
              }
              sqlite3WalkExpr($0, HEAP32[$1 + 12 >> 2]);
              $3 = HEAP32[$1 + 12 >> 2];
              if (sqlite3ExprCanBeNull($3) | HEAPU8[$5 + 208 | 0] > 1) {
               break label$2;
              }
              $2 = HEAPU8[$1 | 0];
              HEAP8[$1 | 0] = 170;
              $2 = ($2 | 0) == 51;
              HEAP32[$1 + 8 >> 2] = $2 ? 12326 : 12859;
              HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | ($2 ? 268435456 : 536870912);
              $2 = 0;
              while (1) {
               if (!(!$4 | $2 >>> 0 > 7)) {
                HEAP32[$4 + 16 >> 2] = HEAP32[($6 + 112 | 0) + ($2 << 2) >> 2];
                $2 = $2 + 1 | 0;
                $4 = HEAP32[$4 + 12 >> 2];
                continue;
               }
               break;
              }
              sqlite3ExprDelete(HEAP32[$5 >> 2], $3);
              HEAP32[$1 + 12 >> 2] = 0;
              break label$2;
             }
             $3 = HEAP32[$1 + 8 >> 2];
             $2 = 0;
             $0 = 0;
             break label$11;
            }
            $0 = HEAP32[$1 + 12 >> 2];
            if (HEAPU8[$4 + 24 | 0] & 40) {
             notValidImpl($5, $4, 8478, 0, $1);
            }
            $2 = 0;
            $3 = HEAP32[$1 + 16 >> 2];
            label$24: {
             if (HEAPU8[$3 | 0] == 59) {
              break label$24;
             }
             $2 = HEAP32[$0 + 8 >> 2];
             $0 = HEAP32[$3 + 12 >> 2];
             $3 = HEAP32[$3 + 16 >> 2];
            }
            $9 = $3;
            $3 = HEAP32[$9 + 8 >> 2];
            $7 = $0;
            $0 = HEAP32[$7 + 8 >> 2];
            if (HEAPU8[$5 + 208 | 0] < 2) {
             break label$11;
            }
            sqlite3RenameTokenRemap($5, $1, $9);
            sqlite3RenameTokenRemap($5, $1 + 44 | 0, $7);
           }
           $2 = lookupName($5, $2, $0, $3, $4, $1);
           break label$1;
          }
          $9 = HEAP32[$1 + 20 >> 2];
          if ($9) {
           $3 = HEAP32[$9 >> 2];
          }
          $2 = HEAP32[$5 >> 2];
          $8 = HEAPU8[$2 + 84 | 0];
          if (HEAP8[$1 + 7 | 0] & 1) {
           $7 = HEAP32[$1 + 44 >> 2];
           $7 = HEAPU8[$7 + 16 | 0] == 166 ? 0 : $7;
          }
          $16 = HEAP32[$4 + 24 >> 2];
          $10 = $4 + 24 | 0;
          label$28: {
           label$29: {
            label$30: {
             label$31: {
              label$32: {
               label$33: {
                label$34: {
                 label$35: {
                  label$36: {
                   $12 = HEAP32[$1 + 8 >> 2];
                   $8 = $8 & 255;
                   $2 = sqlite3FindFunction($2, $12, $3, $8, 0);
                   label$37: {
                    if (!$2) {
                     $2 = sqlite3FindFunction(HEAP32[$5 >> 2], $12, -2, $8, 0);
                     $15 = ($2 | 0) != 0;
                     $13 = !$2;
                     break label$37;
                    }
                    $8 = HEAP32[$2 + 20 >> 2];
                    label$39: {
                     if (!(HEAPU8[$2 + 5 | 0] & 4)) {
                      break label$39;
                     }
                     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 524288;
                     if (($3 | 0) == 2) {
                      $3 = exprProbability(HEAP32[$9 + 24 >> 2]);
                      HEAP32[$1 + 28 >> 2] = $3;
                      if (($3 | 0) >= 0) {
                       break label$39;
                      }
                      HEAP32[$6 + 96 >> 2] = $1;
                      sqlite3ErrorMsg($5, 24157, $6 + 96 | 0);
                      HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
                      break label$39;
                     }
                     HEAP32[$1 + 28 >> 2] = HEAPU8[HEAP32[$2 + 32 >> 2]] == 117 ? 8388608 : 125829120;
                    }
                    label$41: {
                     switch (sqlite3AuthCheck($5, 31, 0, HEAP32[$2 + 32 >> 2], 0) | 0) {
                     case 1:
                      HEAP32[$6 + 80 >> 2] = $1;
                      sqlite3ErrorMsg($5, 18636, $6 + 80 | 0);
                      HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;

                     default:
                      HEAP8[$1 | 0] = 121;
                      break label$2;

                     case 0:
                      break label$41;
                     }
                    }
                    $3 = HEAP32[$2 + 4 >> 2];
                    if ($3 & 10240) {
                     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1048576;
                    }
                    $11 = HEAP32[$10 >> 2];
                    label$45: {
                     if (!($3 & 2048)) {
                      if (!($11 & 42)) {
                       break label$45;
                      }
                      notValidImpl($5, $4, 4686, 0, $1);
                      $3 = HEAP32[$2 + 4 >> 2];
                      break label$45;
                     }
                     HEAP8[$1 + 2 | 0] = $11 & 46;
                     if (!($11 & 262144)) {
                      break label$45;
                     }
                     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1073741824;
                    }
                    $11 = ($8 | 0) != 0;
                    if (!(HEAPU8[HEAP32[$5 >> 2] + 24 | 0] & 32 ? 1 : HEAPU8[$5 + 18 | 0] | !($3 & 262144))) {
                     break label$36;
                    }
                    label$48: {
                     if (!($3 & 2621440)) {
                      $13 = 1;
                      break label$48;
                     }
                     $13 = 1;
                     if (HEAPU8[$5 + 208 | 0] > 1) {
                      break label$48;
                     }
                     sqlite3ExprFunctionUsable($5, $1, $2);
                    }
                    $15 = 1;
                   }
                   $12 = $5 + 208 | 0;
                   if (HEAPU8[$5 + 208 | 0] < 2) {
                    break label$35;
                   }
                   $3 = $2;
                   break label$5;
                  }
                  $12 = $5 + 208 | 0;
                  $13 = 1;
                  $3 = 0;
                  if (HEAPU8[$5 + 208 | 0] > 1) {
                   break label$5;
                  }
                  if ($8) {
                   break label$34;
                  }
                  break label$32;
                 }
                 $3 = 0;
                 if ($2) {
                  if (!($7 ? HEAP32[$2 + 24 >> 2] : 1)) {
                   break label$29;
                  }
                  $3 = $2;
                 }
                 if (!$11) {
                  break label$33;
                 }
                }
                $8 = HEAP32[$10 >> 2];
                $2 = HEAP32[$3 + 4 >> 2] & 65536;
                if (!(!($8 & 1) | ($7 ? 0 : $2))) {
                 $14 = 1;
                 if (!$7 | $8 & 16384) {
                  break label$33;
                 }
                }
                HEAP32[$6 + 4 >> 2] = $1;
                HEAP32[$6 >> 2] = $2 | $7 ? 1691 : 12494;
                sqlite3ErrorMsg($5, 26053, $6);
                break label$30;
               }
               if ($15) {
                break label$31;
               }
              }
              if (HEAPU8[HEAP32[$5 >> 2] + 177 | 0]) {
               break label$31;
              }
              HEAP32[$6 + 48 >> 2] = $1;
              sqlite3ErrorMsg($5, 18614, $6 + 48 | 0);
              HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
              if ($14) {
               break label$28;
              }
              break label$6;
             }
             if (!$13) {
              HEAP32[$6 + 32 >> 2] = $1;
              sqlite3ErrorMsg($5, 26081, $6 + 32 | 0);
              HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
              if (!$14) {
               break label$6;
              }
              break label$28;
             }
             if ($14) {
              break label$28;
             }
             if (!(HEAP8[$1 + 7 | 0] & 1)) {
              break label$6;
             }
             HEAP32[$6 + 16 >> 2] = $1;
             sqlite3ErrorMsg($5, 26145, $6 + 16 | 0);
            }
            HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
            break label$6;
           }
           HEAP32[$6 + 64 >> 2] = $1;
           sqlite3ErrorMsg($5, 9875, $6 - -64 | 0);
           HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
           $3 = $2;
           if (!$11) {
            break label$6;
           }
          }
          HEAP32[$10 >> 2] = HEAP32[$10 >> 2] & (!$7 ^ -16385);
          sqlite3WalkExprList($0, $9);
          break label$4;
         }
         if (!(HEAPU8[$1 + 5 | 0] & 16)) {
          break label$3;
         }
         $2 = HEAP32[$4 + 16 >> 2];
         label$53: {
          if (HEAPU8[$4 + 24 | 0] & 46) {
           notValidImpl($5, $4, 5498, $1, $1);
           break label$53;
          }
          sqlite3WalkSelect($0, HEAP32[$1 + 20 >> 2]);
         }
         if (HEAP32[$4 + 16 >> 2] == ($2 | 0)) {
          break label$3;
         }
         HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 64;
         HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] | 64;
         break label$3;
        }
        $3 = sqlite3ExprSkipCollateAndLikely(HEAP32[$1 + 16 >> 2]);
        if (!$3) {
         break label$7;
        }
        $2 = HEAPU8[$3 | 0];
        if (($2 | 0) != 170 & ($2 | 0) != 59) {
         break label$7;
        }
        $2 = 2;
        if ((resolveExprStep($0, $3) | 0) == 2) {
         break label$1;
        }
        if (HEAPU8[$3 | 0] != 170) {
         break label$7;
        }
        HEAP8[$1 + 2 | 0] = HEAPU8[$1 | 0];
        HEAP8[$1 | 0] = 175;
        $2 = 0;
        break label$1;
       }
       if (HEAPU8[HEAP32[$5 >> 2] + 87 | 0]) {
        break label$3;
       }
       $2 = sqlite3ExprVectorSize(HEAP32[$1 + 12 >> 2]);
       label$55: {
        label$56: {
         if (HEAPU8[$1 | 0] == 48) {
          $4 = HEAP32[$1 + 20 >> 2];
          $3 = sqlite3ExprVectorSize(HEAP32[$4 + 8 >> 2]);
          if (($3 | 0) != ($2 | 0)) {
           break label$55;
          }
          $3 = $4 + 24 | 0;
          break label$56;
         }
         $3 = $1 + 16 | 0;
        }
        $3 = sqlite3ExprVectorSize(HEAP32[$3 >> 2]);
       }
       if (($2 | 0) == ($3 | 0)) {
        break label$3;
       }
       sqlite3ErrorMsg($5, 14966, 0);
       sqlite3RecordErrorOffsetOfExpr(HEAP32[$5 >> 2], $1);
       break label$3;
      }
      sqlite3WalkExprList($0, $9);
      break label$2;
     }
     $2 = HEAP32[$1 + 4 >> 2];
     sqlite3WalkExprList($0, $9);
     if ($2 & 16777216) {
      break label$4;
     }
     $2 = 1;
     if (!$11) {
      break label$1;
     }
    }
    label$58: {
     label$59: {
      if ($7) {
       $2 = HEAP32[$4 + 28 >> 2];
       if (HEAPU8[$12 | 0] <= 1) {
        $4 = $2 ? HEAP32[$2 + 72 >> 2] : 0;
        sqlite3WindowUpdate($5, $4, $7, $3);
        if (HEAPU8[HEAP32[$5 >> 2] + 87 | 0]) {
         break label$3;
        }
       }
       sqlite3WalkExprList($0, HEAP32[$7 + 8 >> 2]);
       sqlite3WalkExprList($0, HEAP32[$7 + 12 >> 2]);
       sqlite3WalkExpr($0, HEAP32[$7 + 40 >> 2]);
       sqlite3WindowLink($2, $7);
       $2 = HEAP32[$10 >> 2];
       $1 = $10;
       $3 = 32768;
       break label$59;
      }
      HEAP8[$1 + 2 | 0] = 0;
      HEAP8[$1 | 0] = 168;
      if (HEAP8[$1 + 7 | 0] & 1) {
       sqlite3WalkExpr($0, HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2]);
      }
      while (1) {
       if (!$4) {
        break label$58;
       }
       if (!sqlite3ReferencesSrcList($5, $1, HEAP32[$4 + 4 >> 2])) {
        HEAP8[$1 + 2 | 0] = HEAPU8[$1 + 2 | 0] + 1;
        $4 = HEAP32[$4 + 12 >> 2];
        continue;
       }
       break;
      }
      if (!$3) {
       break label$58;
      }
      $2 = HEAP32[$3 + 4 >> 2] & 134221824 ^ 134217744;
      $1 = $4 + 24 | 0;
      $3 = HEAP32[$4 + 24 >> 2];
     }
     HEAP32[$1 >> 2] = $2 | $3;
    }
    HEAP32[$10 >> 2] = HEAP32[$10 >> 2] | $16 & 16385;
    break label$2;
   }
   $2 = (HEAP32[$5 + 36 >> 2] != 0) << 1;
   break label$1;
  }
  $2 = 1;
 }
 __stack_pointer = $6 + 144 | 0;
 return $2 | 0;
}

function wherePathSatisfiesOrderBy($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0;
 label$1: {
  if (HEAPU8[HEAP32[HEAP32[$0 >> 2] >> 2] + 80 | 0] & 64 ? $4 : 0) {
   break label$1;
  }
  $21 = HEAPU16[$1 >> 1];
  if ($21 >>> 0 > 63) {
   break label$1;
  }
  $37 = $3 & 2051 ? 387 : 386;
  $43 = $0 + 504 | 0;
  $44 = $3 & 64;
  $45 = $3 & 192;
  $46 = $0 + 88 | 0;
  $38 = $3 & 128;
  $47 = $3 & 2048;
  $7 = $21;
  $10 = $7 & 31;
  if (($7 & 63) >>> 0 >= 32) {
   $8 = -1 << $10;
   $12 = 0;
  } else {
   $8 = (1 << $10) - 1 & -1 >>> 32 - $10 | -1 << $10;
   $12 = -1 << $10;
  }
  $32 = $12 ^ -1;
  $9 = $8 ^ -1;
  $33 = $9;
  $39 = $4;
  $16 = 1;
  while (1) {
   label$4: {
    label$5: {
     label$6: {
      label$7: {
       label$8: {
        label$9: {
         $12 = $33;
         $9 = $18;
         $8 = $19;
         $7 = $32;
         $4 = !($16 & 255) | (($12 | 0) == ($9 | 0) & $8 >>> 0 >= $7 >>> 0 | $9 >>> 0 > $12 >>> 0);
         $8 = $24;
         $12 = $39;
         $7 = $25;
         if (!($4 | (!$8 & $12 >>> 0 < $7 >>> 0 | ($8 | 0) != 0))) {
          $7 = $24;
          if ($7 | $25) {
           $12 = $15;
           $7 = HEAP32[$12 + 8 >> 2];
           $4 = $7;
           $8 = HEAP32[$12 + 12 >> 2];
           $7 = $40;
           $7 = $8 | $7;
           $40 = $7;
           $12 = $4;
           $9 = $41;
           $41 = $12 | $9;
          }
          $15 = $5;
          $7 = $24;
          $8 = $25;
          $9 = $39;
          if (!$7 & $8 >>> 0 < $9 >>> 0) {
           $15 = HEAP32[HEAP32[$2 + 24 >> 2] + ($25 << 2) >> 2];
           if ($47) {
            break label$4;
           }
          }
          if (!(HEAPU8[$15 + 41 | 0] & 4)) {
           break label$9;
          }
          $10 = HEAPU8[$15 + 29 | 0];
          $12 = $10 ? $32 : $19;
          $8 = $33;
          $7 = $18;
          $9 = $10 ? $8 : $7;
          $0 = $9;
          $7 = ($3 & 640) == 128;
          $8 = $7 ? $19 : $12;
          $19 = $8;
          $9 = $18;
          $12 = $0;
          $10 = $7 ? $9 : $12;
          $18 = $10;
         }
         $9 = $32;
         $7 = $19;
         $8 = $33;
         $10 = $18;
         if (($9 | 0) != ($7 | 0) | ($8 | 0) != ($10 | 0)) {
          break label$8;
         }
         $7 = $21;
         break label$1;
        }
        if ($38) {
         HEAP16[$15 + 30 >> 1] = 0;
        }
        $9 = $41;
        $27 = $9 ^ -1;
        $7 = $40;
        $10 = $7 ^ -1;
        $26 = $10;
        $29 = HEAP32[(HEAP32[$0 + 4 >> 2] + (HEAPU8[$15 + 16 | 0] << 6) | 0) + 48 >> 2];
        $14 = 0;
        $17 = 0;
        while (1) {
         $10 = $17;
         $8 = $21;
         $7 = $14;
         if (!(!$10 & ($8 | 0) == ($7 | 0))) {
          $9 = $14;
          $12 = $9 & 31;
          if (($9 & 63) >>> 0 >= 32) {
           $10 = 1 << $12;
           $22 = 0;
          } else {
           $10 = (1 << $12) - 1 & 1 >>> 32 - $12;
           $22 = 1 << $12;
          }
          $8 = $18;
          $28 = $10;
          $8 = $8 & $10;
          $9 = $19;
          $7 = $22;
          $10 = $9 & $7;
          label$16: {
           if ($8 | $10) {
            break label$16;
           }
           $9 = ($14 << 4) + $1 | 0;
           $20 = $9 + 8 | 0;
           $11 = sqlite3ExprSkipCollateAndLikely(HEAP32[$20 >> 2]);
           if (!$11) {
            break label$16;
           }
           label$17: {
            switch (HEAPU8[$11 | 0] - 167 | 0) {
            case 0:
            case 2:
             break label$17;

            default:
             break label$16;
            }
           }
           if (HEAP32[$11 + 28 >> 2] != ($29 | 0)) {
            break label$16;
           }
           $10 = $26;
           $13 = sqlite3WhereFindTerm($46, $29, HEAP16[$11 + 32 >> 1], $27, $10, $37, 0);
           if (!$13) {
            break label$16;
           }
           $8 = HEAPU16[$13 + 12 >> 1];
           if (($8 | 0) == 1) {
            $10 = HEAPU16[$15 + 44 >> 1];
            $4 = 0;
            while (1) {
             if (($4 | 0) == ($10 | 0)) {
              break label$16;
             }
             $7 = $4 << 2;
             $4 = $4 + 1 | 0;
             if (HEAP32[HEAP32[$15 + 52 >> 2] + $7 >> 2] != ($13 | 0)) {
              continue;
             }
             break;
            }
           }
           if (!(!($8 & 130) | HEAP16[$11 + 32 >> 1] < 0)) {
            $4 = HEAP32[$0 >> 2];
            $7 = sqlite3ExprNNCollSeq($4, HEAP32[$9 + 8 >> 2]);
            $4 = sqlite3ExprCompareCollSeq($4, HEAP32[$13 >> 2]);
            if (!$4) {
             break label$16;
            }
            if (sqlite3StrICmp(HEAP32[$7 >> 2], HEAP32[$4 >> 2])) {
             break label$16;
            }
           }
           $9 = $19;
           $7 = $22;
           $19 = $9 | $7;
           $8 = $28;
           $10 = $18;
           $8 = $8 | $10;
           $18 = $8;
          }
          $8 = $17;
          $10 = $14;
          $12 = $10 + 1 | 0;
          $11 = $12 ? $8 : $8 + 1 | 0;
          $14 = $12;
          $17 = $11;
          continue;
         }
         break;
        }
        $4 = HEAP32[$15 + 40 >> 2];
        if ($4 & 4096) {
         break label$5;
        }
        $13 = 0;
        label$21: {
         if ($4 & 256) {
          $20 = 0;
          $4 = 1;
          $26 = 0;
          break label$21;
         }
         $7 = 0;
         $20 = HEAP32[$15 + 32 >> 2];
         if (!$20 | HEAPU8[$20 + 55 | 0] & 4) {
          break label$1;
         }
         $16 = !($4 & 32768) & HEAPU8[$20 + 54 | 0] != 0;
         $4 = HEAPU16[$20 + 52 >> 1];
         $26 = HEAPU16[$20 + 50 >> 1];
        }
        $7 = $25;
        $9 = $7 & 31;
        if (($7 & 63) >>> 0 >= 32) {
         $10 = 1 << $9;
         $22 = 0;
        } else {
         $10 = (1 << $9) - 1 & 1 >>> 32 - $9;
         $22 = 1 << $9;
        }
        $28 = $10;
        $27 = $4 & 65535;
        $34 = 0;
        $30 = 0;
        $35 = 0;
        while (1) {
         if (($13 | 0) == ($27 | 0)) {
          break label$6;
         }
         $4 = 1;
         label$24: {
          $11 = HEAPU16[$15 + 24 >> 1];
          label$25: {
           if ($11 >>> 0 <= $13 >>> 0 | HEAPU16[$15 + 46 >> 1] > $13 >>> 0) {
            break label$25;
           }
           $10 = HEAP32[$15 + 52 >> 2];
           $7 = HEAP32[$10 + ($13 << 2) >> 2];
           $4 = HEAPU16[$7 + 12 >> 1];
           if ($37 & $4) {
            $16 = $4 & 384 ? 0 : $16;
            break label$24;
           }
           label$27: {
            if (!($4 & 1)) {
             break label$27;
            }
            $8 = $11 - 1 | 0;
            $23 = HEAP32[$7 >> 2];
            $7 = $13;
            while (1) {
             if (($7 | 0) == ($8 | 0)) {
              break label$27;
             }
             $4 = 0;
             $7 = $7 + 1 | 0;
             if (HEAP32[HEAP32[($7 << 2) + $10 >> 2] >> 2] != ($23 | 0)) {
              continue;
             }
             break;
            }
            break label$25;
           }
           $4 = 1;
          }
          label$29: {
           label$30: {
            label$31: {
             label$32: {
              if ($20) {
               $7 = HEAPU16[HEAP32[$20 + 4 >> 2] + ($13 << 1) >> 1];
               $10 = HEAP32[$20 + 12 >> 2];
               $23 = (HEAPU16[$10 + 32 >> 1] == ($7 | 0) ? -1 : $7) << 16 >> 16;
               $36 = HEAP8[HEAP32[$20 + 28 >> 2] + $13 | 0] & 1;
               if ($16 & 255) {
                break label$32;
               }
               $16 = 0;
               break label$29;
              }
              $11 = $16 & 255;
              $23 = -1;
              $36 = 0;
              $16 = 0;
              $7 = 1;
              if ($11) {
               break label$31;
              }
              break label$29;
             }
             if (($23 | 0) < 0) {
              break label$30;
             }
             $7 = 1;
             if ($13 >>> 0 < $11 >>> 0) {
              break label$31;
             }
             $7 = (HEAPU8[(HEAP32[$10 + 4 >> 2] + Math_imul($23, 12) | 0) + 4 | 0] & 15) != 0;
            }
            $16 = $7;
            break label$29;
           }
           $16 = ($23 | 0) != -2;
          }
          $14 = 0;
          $17 = 0;
          while (1) {
           $10 = $17;
           $7 = $21;
           $11 = $14;
           if (!($4 & 255) | (!$10 & $7 >>> 0 <= $11 >>> 0 | $10)) {
            break label$7;
           }
           $11 = $18;
           $7 = $19;
           $8 = $14;
           $9 = $8 & 31;
           label$35: {
            if (($8 & 63) >>> 0 >= 32) {
             $7 = $11 >>> $9 | 0;
            } else {
             $7 = ((1 << $9) - 1 & $11) << 32 - $9 | $7 >>> $9;
            }
            if ($7 & 1) {
             break label$35;
            }
            $8 = ($14 << 4) + $1 | 0;
            $10 = $8 + 8 | 0;
            $11 = HEAP32[$10 >> 2];
            $7 = sqlite3ExprSkipCollateAndLikely($11);
            if (!$7) {
             break label$35;
            }
            $4 = $45 ? $4 : 0;
            label$36: {
             label$37: {
              if (($23 | 0) >= -1) {
               label$39: {
                switch (HEAPU8[$7 | 0] - 167 | 0) {
                case 0:
                case 2:
                 break label$39;

                default:
                 break label$35;
                }
               }
               if (HEAP32[$7 + 28 >> 2] != ($29 | 0) | HEAP16[$7 + 32 >> 1] != ($23 | 0)) {
                break label$35;
               }
               if (($23 | 0) != -1) {
                break label$37;
               }
               break label$36;
              }
              if (sqlite3ExprCompareSkip($7, HEAP32[(HEAP32[$20 + 40 >> 2] + ($13 << 4) | 0) + 8 >> 2], $29)) {
               break label$35;
              }
              $11 = HEAP32[$8 + 8 >> 2];
             }
             if (sqlite3StrICmp(HEAP32[sqlite3ExprNNCollSeq(HEAP32[$0 >> 2], $11) >> 2], HEAP32[HEAP32[$20 + 32 >> 2] + ($13 << 2) >> 2])) {
              break label$35;
             }
            }
            if ($38) {
             HEAP16[$15 + 30 >> 1] = $13 + 1;
            }
            label$41: {
             if ($44) {
              $4 = HEAPU8[$8 + 16 | 0];
              break label$41;
             }
             if ($35) {
              $35 = 1;
              $4 = HEAPU8[$8 + 16 | 0];
              if ((($30 ^ $36) & 255) == ($4 & 1)) {
               break label$41;
              }
              break label$7;
             }
             $35 = 1;
             $4 = HEAPU8[$8 + 16 | 0];
             $30 = $4 & 1 ^ $36;
             if (!$30) {
              $30 = 0;
              break label$41;
             }
             $11 = $6;
             $10 = HEAP32[$11 >> 2];
             $7 = HEAP32[$11 + 4 >> 2];
             $8 = $22;
             $11 = $6;
             HEAP32[$11 >> 2] = $8 | $10;
             $10 = $28;
             $10 = $7 | $10;
             HEAP32[$11 + 4 >> 2] = $10;
            }
            if ($4 & 2) {
             if (HEAPU16[$15 + 24 >> 1] != ($13 | 0)) {
              break label$7;
             }
             HEAP32[$15 + 40 >> 2] = HEAP32[$15 + 40 >> 2] | 524288;
            }
            $34 = ($23 | 0) == -1 ? 1 : $34;
            $8 = $14;
            $9 = $8 & 31;
            if (($8 & 63) >>> 0 >= 32) {
             $11 = 1 << $9;
             $10 = 0;
            } else {
             $11 = (1 << $9) - 1 & 1 >>> 32 - $9;
             $10 = 1 << $9;
            }
            $8 = $19;
            $19 = $8 | $10;
            $7 = $18;
            $7 = $11 | $7;
            $18 = $7;
            break label$24;
           }
           $7 = $17;
           $11 = $14;
           $9 = $11 + 1 | 0;
           $12 = $9 ? $7 : $7 + 1 | 0;
           $14 = $9;
           $17 = $12;
           continue;
          }
         }
         $13 = $13 + 1 | 0;
         continue;
        }
       }
       $7 = 255;
       if ($16 & 255) {
        break label$1;
       }
       while (1) {
        $7 = $21;
        $12 = $31;
        if ($7 >>> 0 < 2 & ($12 | 0) <= 0 | ($12 | 0) < 0) {
         $7 = 0;
         break label$1;
        }
        $7 = $18;
        $0 = $7;
        $8 = $21;
        $10 = $8 - 1 | 0;
        $21 = $10;
        $7 = $31;
        $9 = !$8;
        $9 = $7 - $9 | 0;
        $31 = $9;
        $12 = $10 & 31;
        if (($10 & 63) >>> 0 >= 32) {
         $8 = -1 << $12;
         $9 = 0;
        } else {
         $8 = (1 << $12) - 1 & -1 >>> 32 - $12 | -1 << $12;
         $9 = -1 << $12;
        }
        $14 = $9 ^ -1;
        $7 = $8 ^ -1;
        $17 = $7;
        $9 = $7;
        $7 = $0;
        $9 = $9 & $7;
        $8 = $19;
        $11 = $14;
        $7 = $8 & $11;
        $8 = $17;
        if (($11 | 0) != ($7 | 0) | ($8 | 0) != ($9 | 0)) {
         continue;
        }
        break;
       }
       $7 = $21;
       break label$1;
      }
      $16 = $13 ? $13 >>> 0 < $26 >>> 0 ? 0 : $16 : 0;
     }
     $4 = $16 | $34;
     $16 = 0;
     if (!($4 & 255)) {
      break label$4;
     }
    }
    $8 = $42;
    $11 = $15;
    $7 = HEAP32[$11 + 8 >> 2];
    $42 = $8 | $7;
    $9 = HEAP32[$15 + 12 >> 2];
    $7 = $48;
    $7 = $9 | $7;
    $48 = $7;
    $9 = $42;
    $13 = $9 ^ -1;
    $11 = $7 ^ -1;
    $16 = $11;
    $14 = 0;
    $17 = 0;
    while (1) {
     $11 = $17;
     $8 = $21;
     $7 = $14;
     if (!(!$11 & ($8 | 0) == ($7 | 0))) {
      $9 = $14;
      $12 = $9 & 31;
      if (($9 & 63) >>> 0 >= 32) {
       $11 = 1 << $12;
       $22 = 0;
      } else {
       $11 = (1 << $12) - 1 & 1 >>> 32 - $12;
       $22 = 1 << $12;
      }
      $8 = $18;
      $28 = $11;
      $8 = $8 & $11;
      $9 = $19;
      $7 = $22;
      $11 = $9 & $7;
      label$51: {
       if ($8 | $11) {
        break label$51;
       }
       $4 = HEAP32[(($14 << 4) + $1 | 0) + 8 >> 2];
       $11 = sqlite3WhereExprUsage($43, $4);
       $27 = $11;
       $8 = i64toi32_i32$HIGH_BITS;
       $26 = $8;
       if (!($8 | $11)) {
        if (!sqlite3ExprIsConstant($4)) {
         break label$51;
        }
       }
       $8 = $26;
       $11 = $16;
       $11 = $8 & $11;
       $9 = $27;
       $7 = $13;
       $12 = !($11 | $9 & $7);
       $7 = $12 ? $22 : 0;
       $11 = $28;
       $8 = $12 ? $11 : 0;
       $11 = $19;
       $19 = $7 | $11;
       $7 = $18;
       $7 = $8 | $7;
       $18 = $7;
      }
      $7 = $17;
      $8 = $14;
      $9 = $8 + 1 | 0;
      $10 = $9 ? $7 : $7 + 1 | 0;
      $14 = $9;
      $17 = $10;
      continue;
     }
     break;
    }
    $16 = 1;
   }
   $10 = $24;
   $9 = $10;
   $7 = $25;
   $12 = $7 + 1 | 0;
   $9 = $12 ? $9 : $9 + 1 | 0;
   $25 = $12;
   $24 = $9;
   continue;
  }
 }
 return $7 << 24 >> 24;
}

function exprAnalyze($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 $12 = __stack_pointer - 32 | 0;
 __stack_pointer = $12;
 $3 = HEAP32[$1 >> 2];
 HEAP32[$12 + 28 >> 2] = 0;
 HEAP32[$12 + 24 >> 2] = 0;
 HEAP32[$12 + 20 >> 2] = 0;
 $13 = HEAP32[$3 >> 2];
 $15 = HEAP32[$13 >> 2];
 HEAP8[$12 + 19 | 0] = 0;
 label$1: {
  if (HEAPU8[$15 + 87 | 0]) {
   break label$1;
  }
  $6 = HEAP32[$1 + 24 >> 2];
  $10 = Math_imul($2, 48);
  $11 = $6 + $10 | 0;
  $8 = HEAP32[$11 >> 2];
  HEAP32[$3 + 504 >> 2] = 0;
  $17 = $3 + 504 | 0;
  $5 = sqlite3WhereExprUsage($17, HEAP32[$8 + 12 >> 2]);
  $19 = $5;
  $20 = i64toi32_i32$HIGH_BITS;
  $4 = HEAPU8[$8 | 0];
  label$2: {
   if (($4 | 0) == 49) {
    if (sqlite3ExprCheckIN($13, $8)) {
     break label$1;
    }
    $3 = HEAP32[$8 + 20 >> 2];
    $7 = Math_imul($2, 48) + $6 | 0;
    label$4: {
     if (HEAPU8[$8 + 5 | 0] & 16) {
      $14 = exprSelectUsage($17, $3);
      $5 = i64toi32_i32$HIGH_BITS;
      $18 = $5;
      break label$4;
     }
     $5 = sqlite3WhereExprListUsage($17, $3);
     $14 = $5;
     $18 = i64toi32_i32$HIGH_BITS;
    }
    $5 = $7;
    HEAP32[$5 + 32 >> 2] = $14;
    HEAP32[$5 + 36 >> 2] = $18;
    $7 = $14;
    $9 = $19;
    $14 = $7 | $9;
    $5 = $20;
    $5 = $18 | $5;
    $7 = $5;
    break label$2;
   }
   $5 = sqlite3WhereExprUsage($17, HEAP32[$8 + 16 >> 2]);
   $14 = $5;
   $7 = i64toi32_i32$HIGH_BITS;
   $18 = $7;
   $5 = $6 + $10 | 0;
   HEAP32[$5 + 32 >> 2] = $14;
   HEAP32[$5 + 36 >> 2] = $7;
   if (HEAP32[$8 + 20 >> 2] ? 1 : !HEAP32[$8 + 12 >> 2] | HEAP32[$8 + 4 >> 2] & 266240) {
    $7 = sqlite3WhereExprUsageNN($17, $8);
    $14 = $7;
    $5 = i64toi32_i32$HIGH_BITS;
    $7 = $5;
    break label$2;
   }
   $9 = $19;
   $14 = $9 | $14;
   $5 = $18;
   $7 = $20;
   $7 = $5 | $7;
  }
  $18 = $7;
  if (HEAP32[$17 >> 2]) {
   $3 = Math_imul($2, 48) + $6 | 0;
   HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 4096;
  }
  $10 = HEAP32[$8 + 4 >> 2];
  label$9: {
   if (!($10 & 3)) {
    break label$9;
   }
   $7 = sqlite3WhereGetMask($17, HEAP32[$8 + 36 >> 2]);
   $16 = $7;
   $3 = i64toi32_i32$HIGH_BITS;
   if ($10 & 1) {
    $7 = $3;
    $7 = $7 | $18;
    $18 = $7;
    $5 = $14;
    $9 = $16;
    $14 = $5 | $9;
    $23 = ($7 & 1) << 31 | $14 >>> 1;
    $5 = $7 >>> 1 | 0;
    $22 = $5;
    $5 = $3;
    $7 = $9;
    $9 = $23;
    if (($22 | 0) == ($5 | 0) & $7 >>> 0 > $9 >>> 0 | $5 >>> 0 > $22 >>> 0) {
     $9 = $16;
     $5 = !$9;
     $23 = $9 - 1 | 0;
     $7 = $3;
     $5 = $7 - $5 | 0;
     $22 = $5;
     break label$9;
    }
    sqlite3ErrorMsg($13, 2983, 0);
    break label$1;
   }
   $5 = $18;
   $9 = $5 >>> 1 | 0;
   $7 = $14;
   $5 = ($5 & 1) << 31 | $7 >>> 1;
   $7 = $3;
   if (($9 | 0) == ($7 | 0) & $5 >>> 0 < $16 >>> 0 | $9 >>> 0 < $7 >>> 0) {
    break label$9;
   }
   if (!(!(HEAPU8[$0 + 44 | 0] & 64) | HEAP32[$0 >> 2] <= 0)) {
    sqlite3ErrorMsg($13, 2983, 0);
    break label$1;
   }
   $10 = $10 & -3;
   HEAP32[$8 + 4 >> 2] = $10;
  }
  $3 = Math_imul($2, 48) + $6 | 0;
  HEAP32[$3 + 40 >> 2] = $14;
  $5 = $18;
  HEAP32[$3 + 44 >> 2] = $5;
  HEAP32[$3 + 16 >> 2] = -1;
  HEAP32[$3 + 20 >> 2] = -1;
  HEAP16[$3 + 12 >> 1] = 0;
  label$13: {
   label$14: {
    if (allowedOp($4)) {
     $10 = sqlite3ExprSkipCollate(HEAP32[$8 + 12 >> 2]);
     $16 = sqlite3ExprSkipCollate(HEAP32[$8 + 16 >> 2]);
     $5 = HEAP32[$3 + 32 >> 2];
     $7 = $19;
     $7 = $5 & $7;
     $9 = HEAP32[$3 + 36 >> 2];
     $5 = $20;
     $5 = $9 & $5;
     $21 = !($7 | $5);
     $7 = HEAP32[$3 + 28 >> 2];
     if (($7 | 0) > 0) {
      $10 = HEAP32[(HEAP32[$10 + 20 >> 2] + ($7 << 4) | 0) - 8 >> 2];
     }
     $7 = $3;
     $21 = $21 ? 16383 : 2048;
     $5 = $20;
     if (exprMightBeIndexed($0, $19, $5, $12 + 8 | 0, $10, $4)) {
      HEAP32[$7 + 20 >> 2] = HEAP32[$12 + 8 >> 2];
      HEAP32[$3 + 24 >> 2] = HEAP32[$12 + 12 >> 2];
      HEAP16[$3 + 12 >> 1] = operatorMask($4) & $21;
     }
     if (($4 | 0) == 45) {
      $6 = Math_imul($2, 48) + $6 | 0;
      HEAP16[$6 + 10 >> 1] = HEAPU16[$6 + 10 >> 1] | 2048;
     }
     label$19: {
      if (!$16) {
       break label$19;
      }
      $5 = HEAP32[$3 + 32 >> 2];
      if (!exprMightBeIndexed($0, $5, HEAP32[$3 + 36 >> 2], $12 + 8 | 0, $16, $4) | HEAPU8[$16 + 4 | 0] & 32) {
       break label$19;
      }
      $6 = $8;
      $3 = $11;
      $10 = 0;
      label$20: {
       if (HEAP32[$7 + 20 >> 2] < 0) {
        break label$20;
       }
       $6 = sqlite3ExprDup($15, $8, 0);
       if (HEAPU8[$15 + 87 | 0]) {
        sqlite3ExprDelete($15, $6);
        break label$1;
       }
       $3 = whereClauseInsert($1, $6, 3);
       if (!$3) {
        break label$1;
       }
       $11 = HEAP32[$1 + 24 >> 2];
       markTermAsChild($1, $3, $2);
       $3 = Math_imul($3, 48);
       if (($4 | 0) == 45) {
        $4 = $3 + $11 | 0;
        HEAP16[$4 + 10 >> 1] = HEAPU16[$4 + 10 >> 1] | 2048;
       }
       $3 = $3 + $11 | 0;
       $4 = HEAP32[$1 + 24 >> 2];
       $11 = $4 + Math_imul($2, 48) | 0;
       HEAP16[$11 + 10 >> 1] = HEAPU16[$11 + 10 >> 1] | 8;
       $10 = 0;
       if (!termIsEquivalence($13, $6)) {
        break label$20;
       }
       $4 = Math_imul($2, 48) + $4 | 0;
       HEAP16[$4 + 12 >> 1] = HEAPU16[$4 + 12 >> 1] | 2048;
       $10 = 2048;
      }
      exprCommute($13, $6);
      HEAP32[$3 + 20 >> 2] = HEAP32[$12 + 8 >> 2];
      $4 = HEAP32[$12 + 12 >> 2];
      HEAP32[$3 + 40 >> 2] = $14;
      HEAP32[$3 + 44 >> 2] = $18;
      $7 = $23;
      $9 = $19;
      $7 = $7 | $9;
      HEAP32[$3 + 32 >> 2] = $7;
      $5 = $22;
      $5 = $5 | $20;
      HEAP32[$3 + 36 >> 2] = $5;
      HEAP32[$3 + 24 >> 2] = $4;
      HEAP16[$3 + 12 >> 1] = operatorMask(HEAPU8[$6 | 0]) + $10 & $21;
      break label$14;
     }
     if (($4 | 0) != 50) {
      break label$14;
     }
     $4 = HEAP32[$8 + 4 >> 2];
     if ($4 & 1) {
      break label$14;
     }
     if (sqlite3ExprCanBeNull($10)) {
      break label$14;
     }
     HEAP32[$8 + 8 >> 2] = 12859;
     HEAP8[$8 | 0] = 170;
     HEAP32[$8 + 4 >> 2] = $4 | 536870912;
     HEAP32[$3 + 40 >> 2] = 0;
     HEAP32[$3 + 44 >> 2] = 0;
     HEAP16[$3 + 12 >> 1] = 0;
     break label$14;
    }
    label$23: {
     label$24: {
      label$25: {
       label$26: {
        label$27: {
         $3 = HEAPU8[$8 | 0];
         switch ($3 - 48 | 0) {
         case 1:
         case 2:
          break label$13;

         case 3:
          break label$24;

         case 0:
          break label$26;

         default:
          break label$27;
         }
        }
        if (($3 | 0) == 43) {
         break label$25;
        }
        if (($3 | 0) != 172) {
         break label$13;
        }
        if (HEAPU8[$1 + 8 | 0] != 44) {
         break label$14;
        }
        if (!isLikeOrGlob($13, $8, $12 + 28 | 0, $12 + 24 | 0, $12 + 20 | 0)) {
         break label$14;
        }
        $16 = HEAP32[HEAP32[$8 + 20 >> 2] + 24 >> 2];
        $10 = HEAP32[$12 + 28 >> 2];
        $11 = sqlite3ExprDup($15, $10, 0);
        $21 = HEAP32[$12 + 20 >> 2];
        if (HEAPU8[HEAP32[$13 >> 2] + 87 | 0] | !$21) {
         break label$23;
        }
        $3 = Math_imul($2, 48) + $6 | 0;
        HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 1024;
        $3 = 0;
        while (1) {
         $6 = HEAP32[$10 + 8 >> 2] + $3 | 0;
         $4 = HEAPU8[$6 | 0];
         if (!$4) {
          break label$23;
         }
         HEAP8[$6 | 0] = (HEAPU8[$4 + 30288 | 0] ^ -1 | 223) & $4;
         HEAP8[HEAP32[$11 + 8 >> 2] + $3 | 0] = HEAPU8[$4 + 29904 | 0];
         $3 = $3 + 1 | 0;
         continue;
        }
       }
       if (HEAPU8[$1 + 8 | 0] != 44) {
        break label$14;
       }
       $10 = HEAP32[$8 + 20 >> 2];
       $16 = Math_imul($2, 48);
       $3 = 0;
       while (1) {
        if (($3 | 0) == 2) {
         break label$14;
        }
        $4 = sqlite3PExpr($13, HEAPU8[$3 + 48982 | 0], sqlite3ExprDup($15, HEAP32[$8 + 12 >> 2], 0), sqlite3ExprDup($15, HEAP32[(($3 << 4) + $10 | 0) + 8 >> 2], 0));
        transferJoinMarkings($4, $8);
        $4 = whereClauseInsert($1, $4, 3);
        exprAnalyze($0, $1, $4);
        $6 = HEAP32[$1 + 24 >> 2];
        markTermAsChild($1, $4, $2);
        $3 = $3 + 1 | 0;
        $11 = $6 + $16 | 0;
        continue;
       }
      }
      exprAnalyzeOrTerm($0, $1, $2);
      $11 = HEAP32[$1 + 24 >> 2] + Math_imul($2, 48) | 0;
      break label$14;
     }
     $3 = HEAP32[$8 + 12 >> 2];
     if (HEAPU8[$3 | 0] != 167 | ($10 & 1 | HEAP16[$3 + 32 >> 1] < 0)) {
      break label$14;
     }
     $6 = whereClauseInsert($1, sqlite3PExpr($13, 54, sqlite3ExprDup($15, $3, 0), sqlite3ExprAlloc($15, 121, 0, 0)), 131);
     if (!$6) {
      break label$14;
     }
     $4 = HEAP32[$1 + 24 >> 2] + Math_imul($6, 48) | 0;
     HEAP32[$4 + 32 >> 2] = 0;
     HEAP32[$4 + 36 >> 2] = 0;
     HEAP32[$4 + 20 >> 2] = HEAP32[$3 + 28 >> 2];
     $3 = HEAP16[$3 + 32 >> 1];
     HEAP16[$4 + 12 >> 1] = 4;
     HEAP32[$4 + 24 >> 2] = $3;
     markTermAsChild($1, $6, $2);
     $11 = HEAP32[$1 + 24 >> 2] + Math_imul($2, 48) | 0;
     HEAP16[$11 + 10 >> 1] = HEAPU16[$11 + 10 >> 1] | 8;
     $9 = HEAP32[$11 + 44 >> 2];
     $5 = HEAP32[$11 + 40 >> 2];
     HEAP32[$4 + 40 >> 2] = $5;
     HEAP32[$4 + 44 >> 2] = $9;
     break label$14;
    }
    if (!HEAPU8[$15 + 87 | 0]) {
     $3 = HEAP32[$11 + 8 >> 2];
     $4 = ($3 + sqlite3Strlen30($3) | 0) - 1 | 0;
     $3 = HEAPU8[$4 | 0];
     if ($21) {
      if (($3 | 0) == 64) {
       HEAP32[$12 + 24 >> 2] = 0;
      }
      $3 = HEAPU8[$3 + 29904 | 0];
     }
     HEAP8[$4 | 0] = $3 + 1;
    }
    $3 = $21 ? 19761 : 32384;
    $4 = sqlite3PExpr($13, 57, sqlite3ExprAddCollateString($13, sqlite3ExprDup($15, $16, 0), $3), $10);
    transferJoinMarkings($4, $8);
    $4 = whereClauseInsert($1, $4, 259);
    exprAnalyze($0, $1, $4);
    $3 = sqlite3PExpr($13, 56, sqlite3ExprAddCollateString($13, sqlite3ExprDup($15, $16, 0), $3), $11);
    transferJoinMarkings($3, $8);
    $3 = whereClauseInsert($1, $3, 259);
    exprAnalyze($0, $1, $3);
    $11 = HEAP32[$1 + 24 >> 2] + Math_imul($2, 48) | 0;
    if (!HEAP32[$12 + 24 >> 2]) {
     break label$14;
    }
    markTermAsChild($1, $4, $2);
    markTermAsChild($1, $3, $2);
   }
   $3 = HEAPU8[$8 | 0];
  }
  label$33: {
   label$34: {
    label$35: {
     label$36: {
      label$37: {
       $4 = $3 & 255;
       switch ($4 - 49 | 0) {
       case 1:
       case 2:
       case 3:
        break label$34;

       case 0:
        break label$35;

       case 4:
        break label$36;

       default:
        break label$37;
       }
      }
      if (($4 | 0) != 45) {
       break label$34;
      }
     }
     label$38: {
      $6 = HEAP32[$8 + 12 >> 2];
      $4 = sqlite3ExprVectorSize($6);
      if (($4 | 0) < 2) {
       break label$38;
      }
      $10 = HEAP32[$8 + 16 >> 2];
      if ((sqlite3ExprVectorSize($10) | 0) != ($4 | 0) | (HEAPU8[$10 + 5 | 0] & 16 ? HEAPU8[$6 + 5 | 0] & 16 : 0) | HEAPU8[$1 + 8 | 0] != 44) {
       break label$38;
      }
      $3 = 0;
      while (1) {
       if (($3 | 0) != ($4 | 0)) {
        $6 = sqlite3ExprForVectorField($13, HEAP32[$8 + 12 >> 2], $3, $4);
        $17 = sqlite3ExprForVectorField($13, HEAP32[$8 + 16 >> 2], $3, $4);
        $6 = sqlite3PExpr($13, HEAPU8[$8 | 0], $6, $17);
        transferJoinMarkings($6, $8);
        exprAnalyze($0, $1, whereClauseInsert($1, $6, 32769));
        $3 = $3 + 1 | 0;
        continue;
       }
       break;
      }
      $3 = HEAP32[$1 + 24 >> 2] + Math_imul($2, 48) | 0;
      HEAP16[$3 + 12 >> 1] = 8192;
      HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 6;
      break label$33;
     }
     if (($3 & 255) != 49) {
      break label$34;
     }
    }
    if (HEAP32[$11 + 28 >> 2]) {
     break label$34;
    }
    $3 = HEAP32[$8 + 12 >> 2];
    if (!(HEAPU8[$8 + 5 | 0] & 16) | HEAPU8[$3 | 0] != 177) {
     break label$34;
    }
    $4 = HEAP32[$8 + 20 >> 2];
    if (HEAP32[$4 + 52 >> 2] | HEAP32[$4 + 68 >> 2] | HEAPU8[$1 + 8 | 0] != 44) {
     break label$34;
    }
    $4 = 0;
    while (1) {
     if ((sqlite3ExprVectorSize($3) | 0) <= ($4 | 0)) {
      break label$33;
     }
     $3 = whereClauseInsert($1, $8, 32770);
     $4 = $4 + 1 | 0;
     HEAP32[(HEAP32[$1 + 24 >> 2] + Math_imul($3, 48) | 0) + 28 >> 2] = $4;
     exprAnalyze($0, $1, $3);
     markTermAsChild($1, $3, $2);
     $3 = HEAP32[$8 + 12 >> 2];
     continue;
    }
   }
   if (HEAPU8[$1 + 8 | 0] != 44) {
    break label$33;
   }
   HEAP32[$12 + 8 >> 2] = 0;
   HEAP32[$12 + 4 >> 2] = 0;
   $4 = isAuxiliaryVtabOperator($15, $8, $12 + 19 | 0, $12 + 4 | 0, $12 + 8 | 0);
   $16 = HEAPU8[$12 + 19 | 0];
   $6 = HEAP32[$12 + 4 >> 2];
   $3 = HEAP32[$12 + 8 >> 2];
   while (1) {
    $0 = $3;
    $3 = $6;
    if (($4 | 0) <= 0) {
     break label$33;
    }
    $4 = $4 - 1 | 0;
    $6 = $0;
    $9 = sqlite3WhereExprUsage($17, $6);
    $19 = $9;
    $5 = i64toi32_i32$HIGH_BITS;
    $20 = $5;
    $5 = sqlite3WhereExprUsage($17, $3);
    $7 = $5;
    $9 = i64toi32_i32$HIGH_BITS;
    $5 = $9;
    $9 = $20;
    $5 = $9 & $5;
    $9 = $7 & $19;
    if ($5 | $9) {
     continue;
    }
    $6 = sqlite3PExpr($13, 46, 0, sqlite3ExprDup($15, $0, 0));
    if (!(!(HEAP8[$8 + 4 | 0] & 1) | !$6)) {
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] | 1;
     HEAP32[$6 + 36 >> 2] = HEAP32[$8 + 36 >> 2];
    }
    $11 = whereClauseInsert($1, $6, 3);
    $6 = HEAP32[$1 + 24 >> 2] + Math_imul($11, 48) | 0;
    HEAP32[$6 + 32 >> 2] = $19;
    $9 = $20;
    HEAP32[$6 + 36 >> 2] = $9;
    HEAP32[$6 + 20 >> 2] = HEAP32[$3 + 28 >> 2];
    $10 = HEAP16[$3 + 32 >> 1];
    HEAP8[$6 + 15 | 0] = $16;
    HEAP16[$6 + 12 >> 1] = 64;
    HEAP32[$6 + 24 >> 2] = $10;
    markTermAsChild($1, $11, $2);
    $11 = HEAP32[$1 + 24 >> 2] + Math_imul($2, 48) | 0;
    HEAP16[$11 + 10 >> 1] = HEAPU16[$11 + 10 >> 1] | 8;
    $5 = HEAP32[$11 + 44 >> 2];
    $7 = $11;
    $9 = HEAP32[$7 + 40 >> 2];
    HEAP32[$6 + 40 >> 2] = $9;
    HEAP32[$6 + 44 >> 2] = $5;
    $6 = $0;
    continue;
   }
  }
  $3 = HEAP32[$1 + 24 >> 2] + Math_imul($2, 48) | 0;
  $5 = HEAP32[$3 + 32 >> 2];
  $9 = HEAP32[$3 + 36 >> 2];
  HEAP32[$3 + 32 >> 2] = $5 | $23;
  $5 = $22;
  $5 = $9 | $5;
  HEAP32[$3 + 36 >> 2] = $5;
 }
 __stack_pointer = $12 + 32 | 0;
}

function __addtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 $19 = __stack_pointer - 112 | 0;
 __stack_pointer = $19;
 $14 = $7;
 $20 = $14;
 $11 = $8;
 $12 = $11 & 2147483647;
 $21 = $12;
 $12 = $2;
 $17 = !($12 | $1);
 $11 = $3;
 $15 = $11;
 $12 = $4;
 $14 = $12 & 2147483647;
 $16 = $14;
 $10 = 2147418112;
 $10 = $14 - $10 | 0;
 $12 = $15;
 $9 = $12;
 label$1: {
  label$2: {
   $14 = $16;
   if (!($14 | $9 ? $10 >>> 0 < 2147549184 : $17)) {
    $13 = $5;
    $14 = $6;
    $14 = ($13 | $14) != 0;
    $13 = $21;
    $9 = 2147418112;
    $9 = $13 - $9 | 0;
    $12 = $20;
    $11 = $12;
    $12 = ($9 | 0) == -2147418112 & ($11 | 0) != 0 | $9 >>> 0 > 2147549184;
    $13 = $9;
    $10 = $11;
    if (!$10 & ($13 | 0) == -2147418112 ? $14 : $12) {
     break label$2;
    }
   }
   $10 = $16;
   $13 = $10 >>> 0 < 2147418112;
   $12 = $10;
   $9 = $15;
   if (!(!$9 & ($12 | 0) == 2147418112 ? $17 : $13)) {
    $13 = $3;
    $7 = $13;
    $9 = $4;
    $12 = $9 | 32768;
    $8 = $12;
    $5 = $1;
    $12 = $2;
    $6 = $12;
    break label$1;
   }
   $12 = $6;
   $11 = !($12 | $5);
   $12 = $21;
   $13 = $12 >>> 0 < 2147418112;
   $9 = $12;
   $10 = $20;
   if (!(!$10 & ($9 | 0) == 2147418112 ? $11 : $13)) {
    $13 = $7;
    $7 = $13;
    $10 = $8;
    $9 = $10 | 32768;
    $8 = $9;
    break label$1;
   }
   $9 = $16;
   $13 = $9 ^ 2147418112;
   $11 = $13;
   $10 = $15;
   $12 = $10;
   $9 = $1;
   $13 = $2;
   $10 = $11;
   $10 = $13 | $10;
   if (!($12 | $9 | $10)) {
    $12 = $5;
    $13 = $1;
    $11 = $12 ^ $13;
    $9 = $6;
    $10 = $2;
    $9 = $9 ^ $10;
    $5 = $9;
    $13 = $8;
    $9 = $4;
    $13 = $13 ^ $9;
    $12 = $7;
    $10 = $3;
    $9 = $12 ^ $10;
    $12 = $9;
    $10 = $13 ^ -2147483648;
    $9 = $10;
    $10 = $5;
    $9 = $9 | $10;
    $13 = $11;
    $17 = !($9 | ($12 | $13));
    $14 = $17;
    $12 = $14 ? 0 : $3;
    $7 = $12;
    $13 = $4;
    $10 = $14 ? 2147450880 : $13;
    $8 = $10;
    $13 = $14;
    $9 = $13 ? 0 : $1;
    $5 = $9;
    $12 = $2;
    $14 = $13 ? 0 : $12;
    $6 = $14;
    break label$1;
   }
   $14 = $21;
   $9 = $14 ^ 2147418112;
   $14 = $5;
   $13 = $20;
   $10 = $13;
   $13 = $9;
   $9 = $6;
   $13 = $13 | $9;
   if (!($14 | $10 | $13)) {
    break label$1;
   }
   $14 = $16;
   $13 = $2;
   $14 = $14 | $13;
   $9 = $1;
   $10 = $15;
   if (!($14 | ($9 | $10))) {
    $14 = $6;
    $9 = $21;
    $9 = $14 | $9;
    $13 = $5;
    $10 = $20;
    $14 = $13 | $10;
    if ($9 | $14) {
     break label$1;
    }
    $13 = $5;
    $10 = $1;
    $5 = $13 & $10;
    $14 = $2;
    $9 = $6;
    $9 = $14 & $9;
    $6 = $9;
    $14 = $3;
    $13 = $7;
    $7 = $14 & $13;
    $9 = $4;
    $10 = $8;
    $10 = $9 & $10;
    $8 = $10;
    break label$1;
   }
   $14 = $21;
   $10 = $6;
   $14 = $14 | $10;
   $13 = $20;
   $9 = $5;
   if ($14 | ($13 | $9)) {
    break label$2;
   }
   $5 = $1;
   $14 = $2;
   $6 = $14;
   $7 = $3;
   $14 = $4;
   $8 = $14;
   break label$1;
  }
  $14 = $2;
  $9 = $6;
  $13 = $5;
  $10 = $1;
  $11 = ($14 | 0) == ($9 | 0) & $13 >>> 0 > $10 >>> 0 | $14 >>> 0 < $9 >>> 0;
  $14 = $21;
  $10 = $16;
  $13 = $15;
  $9 = $20;
  $12 = ($14 | 0) == ($10 | 0) & $13 >>> 0 < $9 >>> 0 | $10 >>> 0 < $14 >>> 0;
  $13 = $10;
  $9 = $15;
  $10 = $14;
  $14 = $20;
  $18 = ($9 | 0) == ($14 | 0) & ($10 | 0) == ($13 | 0) ? $11 : $12;
  $12 = $18;
  $10 = $12 ? $5 : $1;
  $15 = $10;
  $9 = $6;
  $13 = $2;
  $14 = $12 ? $9 : $13;
  $16 = $14;
  $9 = $12 ? $7 : $3;
  $20 = $9;
  $14 = $8;
  $10 = $4;
  $12 = $12 ? $14 : $10;
  $21 = $12;
  $22 = $9;
  $9 = $12 & 65535;
  $23 = $9;
  $10 = $18;
  $14 = $10 ? $3 : $7;
  $24 = $14;
  $9 = $4;
  $13 = $8;
  $12 = $10 ? $9 : $13;
  $25 = $12;
  $26 = $12 >>> 16 & 32767;
  $14 = $21;
  $17 = $14 >>> 16 & 32767;
  if (!$17) {
   $10 = $23;
   $17 = !($10 | $22);
   $13 = $17;
   $9 = $13 ? $15 : $22;
   $10 = $16;
   $12 = $23;
   $14 = $13 ? $10 : $12;
   $10 = Math_clz32($14);
   $11 = 0;
   $9 = ($10 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $10;
   $10 = $17 << 6;
   $12 = $9 + $10 | 0;
   $11 = $16;
   $9 = $23;
   __ashlti3($19 + 96 | 0, $15, $11, $22, $9, $12 - 15 | 0);
   $17 = 16 - $12 | 0;
   $13 = $19;
   $9 = HEAP32[$13 + 104 >> 2];
   $22 = $9;
   $11 = HEAP32[$13 + 108 >> 2];
   $23 = $11;
   $9 = HEAP32[$13 + 100 >> 2];
   $16 = $9;
   $11 = HEAP32[$13 + 96 >> 2];
   $15 = $11;
  }
  $14 = $18;
  $10 = $14 ? $1 : $5;
  $5 = $10;
  $9 = $2;
  $11 = $6;
  $13 = $14 ? $9 : $11;
  $6 = $13;
  $14 = $24;
  $7 = $14;
  $13 = $25;
  $10 = $13 & 65535;
  $8 = $10;
  if (!$26) {
   $10 = $8;
   $18 = !($7 | $10);
   $11 = $18;
   $9 = $11 ? $5 : $7;
   $10 = $6;
   $14 = $8;
   $13 = $11 ? $10 : $14;
   $10 = Math_clz32($13);
   $12 = 0;
   $9 = ($10 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $10;
   $10 = $18 << 6;
   $14 = $9 + $10 | 0;
   $12 = $6;
   $9 = $8;
   __ashlti3($19 + 80 | 0, $5, $12, $7, $9, $14 - 15 | 0);
   $26 = 16 - $14 | 0;
   $11 = $19;
   $9 = HEAP32[$11 + 88 >> 2];
   $7 = $9;
   $12 = HEAP32[$11 + 92 >> 2];
   $8 = $12;
   $9 = HEAP32[$11 + 84 >> 2];
   $6 = $9;
   $12 = HEAP32[$11 + 80 >> 2];
   $5 = $12;
  }
  $11 = $7;
  $2 = $11 << 3;
  $9 = $8;
  $12 = $9 << 3 | $11 >>> 29;
  $1 = $12;
  $12 = $6;
  $10 = $12 >>> 29 | 0;
  $11 = 0;
  $9 = $11;
  $11 = $1;
  $9 = $11 | $9;
  $12 = $2;
  $11 = $12 | $10;
  $3 = $11;
  $12 = $9 | 524288;
  $4 = $12;
  $9 = $22;
  $12 = $23;
  $11 = $12 << 3 | $9 >>> 29;
  $1 = $11;
  $11 = $16;
  $10 = $11 >>> 29 | 0;
  $11 = $9 << 3;
  $7 = $11 | $10;
  $9 = 0;
  $12 = $9;
  $9 = $1;
  $12 = $12 | $9;
  $8 = $12;
  $9 = $5;
  $1 = $9 << 3;
  $12 = $6;
  $11 = $12 << 3 | $9 >>> 29;
  $2 = $11;
  $12 = $20;
  $10 = $24;
  $5 = $12 ^ $10;
  $11 = $21;
  $9 = $25;
  $9 = $11 ^ $9;
  $6 = $9;
  label$10: {
   if (($17 | 0) == ($26 | 0)) {
    break label$10;
   }
   $18 = $17 - $26 | 0;
   if ($18 >>> 0 > 127) {
    $3 = 0;
    $4 = 0;
    $1 = 1;
    $2 = 0;
    break label$10;
   }
   $9 = $2;
   $12 = $4;
   __ashlti3($19 - -64 | 0, $1, $9, $3, $12, 128 - $18 | 0);
   $12 = $9;
   $9 = $4;
   __lshrti3($19 + 48 | 0, $1, $12, $3, $9, $18);
   $11 = $19;
   $9 = HEAP32[$11 + 48 >> 2];
   $4 = $9;
   $12 = HEAP32[$11 + 52 >> 2];
   $3 = $12;
   $12 = HEAP32[$11 + 64 >> 2];
   $2 = $12;
   $9 = HEAP32[$11 + 68 >> 2];
   $1 = $9;
   $9 = HEAP32[$11 + 72 >> 2];
   $10 = $9;
   $12 = HEAP32[$11 + 76 >> 2];
   $9 = $12;
   $12 = $1;
   $9 = $12 | $9;
   $11 = $2;
   $12 = $11 | $10;
   $11 = ($9 | $12) != 0;
   $10 = $4;
   $1 = $11 | $10;
   $12 = $3;
   $9 = $12;
   $2 = $9;
   $12 = $19;
   $9 = HEAP32[$12 + 56 >> 2];
   $3 = $9;
   $10 = HEAP32[$12 + 60 >> 2];
   $4 = $10;
  }
  $12 = $7;
  $24 = $12;
  $10 = $8;
  $9 = $10 | 524288;
  $25 = $9;
  $10 = $15;
  $22 = $10 << 3;
  $9 = $16;
  $12 = $9 << 3 | $10 >>> 29;
  $23 = $12;
  $12 = $6;
  label$12: {
   if (($12 | 0) < 0) {
    $5 = 0;
    $6 = 0;
    $7 = 0;
    $8 = 0;
    $11 = $1;
    $10 = $22;
    $10 = $11 ^ $10;
    $12 = $23;
    $9 = $2;
    $12 = $12 ^ $9;
    $14 = $12;
    $11 = $25;
    $12 = $4;
    $11 = $11 ^ $12;
    $13 = $11;
    $12 = $10;
    $9 = $3;
    $10 = $24;
    $10 = $9 ^ $10;
    $11 = $14;
    $9 = $13;
    $9 = $11 | $9;
    if (!($12 | $10 | $9)) {
     break label$1;
    }
    $11 = $22;
    $10 = $1;
    $13 = $11 - $10 | 0;
    $15 = $13;
    $9 = $23;
    $12 = $2;
    $14 = $12 + ($10 >>> 0 > $11 >>> 0) | 0;
    $14 = $9 - $14 | 0;
    $16 = $14;
    $9 = $24;
    $10 = $3;
    $12 = $9 - $10 | 0;
    $14 = $25;
    $11 = $4;
    $13 = $11 + ($10 >>> 0 > $9 >>> 0) | 0;
    $13 = $14 - $13 | 0;
    $3 = $13;
    $13 = $2;
    $9 = $23;
    $14 = $1;
    $10 = $22;
    $9 = ($13 | 0) == ($9 | 0) & $14 >>> 0 > $10 >>> 0 | $13 >>> 0 > $9 >>> 0;
    $10 = $12;
    $11 = $10 - $9 | 0;
    $7 = $11;
    $14 = $3;
    $12 = $10 >>> 0 < $9 >>> 0;
    $12 = $14 - $12 | 0;
    $8 = $12;
    if ($12 >>> 0 > 524287) {
     break label$12;
    }
    $14 = $8;
    $18 = !($7 | $14);
    $13 = $18;
    $10 = $13 ? $15 : $7;
    $14 = $16;
    $12 = $8;
    $9 = $13 ? $14 : $12;
    $14 = Math_clz32($9);
    $10 = ($14 | 0) == 32 ? Math_clz32($10) + 32 | 0 : $14;
    $11 = 0;
    $14 = $18 << 6;
    $12 = $14 + $10 | 0;
    $18 = $12 - 12 | 0;
    $11 = $16;
    $10 = $8;
    __ashlti3($19 + 32 | 0, $15, $11, $7, $10, $18);
    $17 = $17 - $18 | 0;
    $13 = $19;
    $10 = HEAP32[$13 + 40 >> 2];
    $7 = $10;
    $11 = HEAP32[$13 + 44 >> 2];
    $8 = $11;
    $11 = HEAP32[$13 + 32 >> 2];
    $15 = $11;
    $10 = HEAP32[$13 + 36 >> 2];
    $16 = $10;
    break label$12;
   }
   $11 = $23;
   $10 = $2;
   $12 = $11 + $10 | 0;
   $14 = $22;
   $13 = $1;
   $9 = $14 + $13 | 0;
   $15 = $9;
   $12 = $9 >>> 0 < $14 >>> 0 ? $12 + 1 | 0 : $12;
   $16 = $12;
   $13 = $10;
   $14 = $1;
   $1 = ($12 | 0) == ($13 | 0) & $14 >>> 0 > $9 >>> 0 | $13 >>> 0 > $12 >>> 0;
   $12 = $25;
   $10 = $4;
   $9 = $12 + $10 | 0;
   $14 = $3;
   $13 = $24;
   $11 = $14 + $13 | 0;
   $9 = $11 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
   $13 = $11;
   $11 = $9;
   $10 = $1;
   $12 = $13 + $10 | 0;
   $11 = $12 >>> 0 < $13 >>> 0 ? $11 + 1 | 0 : $11;
   $7 = $12;
   $8 = $11;
   $10 = $11 & 1048576;
   if (!$10) {
    break label$12;
   }
   $11 = $15;
   $3 = $11 & 1;
   $9 = 0;
   $2 = $9;
   $10 = $7;
   $11 = $10 << 31;
   $1 = $11;
   $11 = $16;
   $10 = $11 >>> 1 | 0;
   $9 = $15;
   $13 = ($11 & 1) << 31 | $9 >>> 1;
   $9 = $10;
   $10 = $1;
   $9 = $9 | $10;
   $11 = 0;
   $13 = $11 | $13;
   $10 = $3;
   $15 = $13 | $10;
   $11 = $9;
   $9 = $2;
   $11 = $11 | $9;
   $16 = $11;
   $17 = $17 + 1 | 0;
   $11 = $8;
   $10 = $11 >>> 1 | 0;
   $9 = $7;
   $7 = ($11 & 1) << 31 | $9 >>> 1;
   $8 = $10;
  }
  $1 = 0;
  $10 = $21;
  $9 = $10 & -2147483648;
  $2 = $9;
  if (($17 | 0) >= 32767) {
   $10 = $1;
   $7 = $10;
   $9 = $2;
   $11 = $9 | 2147418112;
   $8 = $11;
   $5 = 0;
   $6 = 0;
   break label$1;
  }
  $18 = 0;
  label$15: {
   if (($17 | 0) > 0) {
    $18 = $17;
    break label$15;
   }
   $11 = $16;
   $10 = $8;
   __ashlti3($19 + 16 | 0, $15, $11, $7, $10, $17 + 127 | 0);
   $10 = $11;
   $11 = $8;
   __lshrti3($19, $15, $10, $7, $11, 1 - $17 | 0);
   $9 = $19;
   $11 = HEAP32[$9 >> 2];
   $6 = $11;
   $10 = HEAP32[$9 + 4 >> 2];
   $5 = $10;
   $10 = HEAP32[$9 + 16 >> 2];
   $4 = $10;
   $11 = HEAP32[$9 + 20 >> 2];
   $3 = $11;
   $11 = HEAP32[$9 + 24 >> 2];
   $13 = $11;
   $10 = HEAP32[$9 + 28 >> 2];
   $11 = $10;
   $10 = $3;
   $11 = $11 | $10;
   $9 = $4;
   $10 = $13 | $9;
   $13 = $6;
   $9 = ($11 | $10) != 0;
   $15 = $13 | $9;
   $10 = $5;
   $16 = $10;
   $10 = $19;
   $11 = HEAP32[$10 + 8 >> 2];
   $7 = $11;
   $13 = HEAP32[$10 + 12 >> 2];
   $8 = $13;
  }
  $10 = $7;
  $11 = $10 << 29;
  $3 = $11;
  $11 = $16;
  $10 = $11 >>> 3 | 0;
  $13 = $15;
  $9 = ($11 & 7) << 29 | $13 >>> 3;
  $11 = 0;
  $5 = $11 | $9;
  $13 = $10;
  $10 = $3;
  $13 = $13 | $10;
  $6 = $13;
  $13 = $8;
  $11 = $13 >>> 3 | 0;
  $10 = $7;
  $13 = ($13 & 7) << 29 | $10 >>> 3;
  $3 = $13;
  $10 = $11 & 65535;
  $11 = $18;
  $13 = $11 << 16;
  $11 = $13;
  $11 = $11 | $10;
  $9 = 0;
  $10 = $3;
  $13 = $9 | $10;
  $7 = $13 | $1;
  $10 = $2;
  $10 = $11 | $10;
  $8 = $10;
  $17 = $15 & 7;
  label$17: {
   label$18: {
    label$19: {
     switch (__fe_getround() | 0) {
     case 0:
      $10 = $6;
      $11 = $5;
      $9 = $17 >>> 0 > 4;
      $14 = $11 + $9 | 0;
      $12 = $14 >>> 0 < $9 >>> 0 ? $10 + 1 | 0 : $10;
      $15 = $14;
      $11 = $10;
      $16 = $12;
      $9 = $5;
      $10 = $14;
      $11 = ($11 | 0) == ($12 | 0) & $9 >>> 0 > $10 >>> 0 | $11 >>> 0 > $12 >>> 0;
      $10 = $8;
      $9 = $7;
      $13 = $11 + $9 | 0;
      $7 = $13;
      $14 = $11 >>> 0 > $13 >>> 0 ? $10 + 1 | 0 : $10;
      $8 = $14;
      if (($17 | 0) != 4) {
       $5 = $15;
       $14 = $16;
       $6 = $14;
       break label$18;
      }
      $11 = $15;
      $10 = $11;
      $1 = $10 & 1;
      $14 = $1;
      $12 = $10 + $14 | 0;
      $9 = 0;
      $10 = $16;
      $13 = $9 + $10 | 0;
      $5 = $12;
      $14 = $9;
      $13 = $11 >>> 0 > $12 >>> 0 ? $13 + 1 | 0 : $13;
      $6 = $13;
      $11 = $1;
      $9 = $12;
      $14 = ($14 | 0) == ($13 | 0) & $11 >>> 0 > $9 >>> 0 | $14 >>> 0 > $13 >>> 0;
      $9 = $8;
      $11 = $7;
      $10 = $11 + $14 | 0;
      $7 = $10;
      $12 = $10 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
      $8 = $12;
      break label$17;

     case 1:
      $12 = $2;
      $11 = ($17 | 0) != 0 & ($1 | $12) != 0;
      $14 = $5;
      $13 = $11 + $14 | 0;
      $15 = $13;
      $9 = $6;
      $10 = $9;
      $14 = $10;
      $10 = $11 >>> 0 > $13 >>> 0 ? $10 + 1 | 0 : $10;
      $16 = $10;
      $11 = $5;
      $9 = $13;
      $14 = ($14 | 0) == ($10 | 0) & $11 >>> 0 > $9 >>> 0 | $14 >>> 0 > $10 >>> 0;
      $9 = $8;
      $11 = $7;
      $12 = $11 + $14 | 0;
      $13 = $12 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
      $7 = $12;
      $8 = $13;
      $5 = $15;
      $13 = $16;
      $6 = $13;
      break label$18;

     case 2:
      break label$19;

     default:
      break label$18;
     }
    }
    $13 = $2;
    $14 = !($13 | $1) & ($17 | 0) != 0;
    $9 = $5;
    $10 = $14 + $9 | 0;
    $13 = $6;
    $12 = $13;
    $15 = $10;
    $12 = $10 >>> 0 < $14 >>> 0 ? $12 + 1 | 0 : $12;
    $16 = $12;
    $9 = $13;
    $14 = $5;
    $9 = ($12 | 0) == ($9 | 0) & $14 >>> 0 > $10 >>> 0 | $9 >>> 0 > $12 >>> 0;
    $13 = $8;
    $10 = $13;
    $14 = $7;
    $11 = $14 + $9 | 0;
    $10 = $11 >>> 0 < $9 >>> 0 ? $10 + 1 | 0 : $10;
    $7 = $11;
    $8 = $10;
    $5 = $15;
    $10 = $16;
    $6 = $10;
   }
   if (!$17) {
    break label$1;
   }
  }
  __fe_raise_inexact();
 }
 $14 = $0;
 HEAP32[$14 >> 2] = $5;
 $10 = $6;
 HEAP32[$14 + 4 >> 2] = $10;
 HEAP32[$14 + 8 >> 2] = $7;
 $10 = $8;
 HEAP32[$14 + 12 >> 2] = $10;
 __stack_pointer = $19 + 112 | 0;
}

function fts3InitVtab($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0;
 $8 = __stack_pointer - 128 | 0;
 __stack_pointer = $8;
 $24 = HEAPU8[HEAP32[$4 >> 2] + 3 | 0];
 HEAP32[$8 + 108 >> 2] = 0;
 HEAP32[$8 + 104 >> 2] = 0;
 HEAP32[$8 + 100 >> 2] = 0;
 $27 = strlen(HEAP32[$4 + 4 >> 2]);
 $11 = strlen(HEAP32[$4 + 8 >> 2]);
 $9 = ($3 << 2) - 8 | 0;
 $7 = sqlite3_malloc64($9, 0);
 HEAP32[$8 + 112 >> 2] = $7;
 label$1: {
  label$2: {
   if (!$7) {
    break label$2;
   }
   $28 = memset($7, 0, $9);
   $21 = sqlite3_malloc64($9, 0);
   if (!$21) {
    break label$2;
   }
   $29 = $27 + 1 | 0;
   $25 = $11 + 1 | 0;
   $26 = memset($21, 0, $9);
   $22 = ($24 | 0) != 52;
   $7 = 0;
   $14 = 3;
   while (1) {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         if (!(($3 | 0) <= ($14 | 0) | $7)) {
          $12 = HEAP32[($14 << 2) + $4 >> 2];
          label$10: {
           if (HEAP32[$8 + 108 >> 2]) {
            break label$10;
           }
           if (strlen($12) >>> 0 < 9) {
            break label$10;
           }
           if (sqlite3_strnicmp($12, 12197, 8)) {
            break label$10;
           }
           if (sqlite3Fts3IsIdChar(HEAP8[$12 + 8 | 0])) {
            break label$10;
           }
           $7 = sqlite3Fts3InitTokenizer($2, $12 + 9 | 0, $8 + 108 | 0, $6);
           break label$4;
          }
          label$11: {
           if ($22) {
            break label$11;
           }
           if (!fts3IsSpecialColumn($12, $8 + 124 | 0, $8 + 120 | 0)) {
            break label$11;
           }
           $13 = HEAP32[$8 + 120 >> 2];
           if (!$13) {
            $7 = 7;
            break label$4;
           }
           $7 = 0;
           $9 = HEAP32[$8 + 124 >> 2];
           label$13: {
            while (1) {
             if (($7 | 0) == 8) {
              break label$13;
             }
             label$15: {
              $11 = $7 << 3;
              if (HEAP32[$11 + 54820 >> 2] == ($9 | 0)) {
               if (!sqlite3_strnicmp($12, HEAP32[$11 + 54816 >> 2], $9)) {
                break label$15;
               }
              }
              $7 = $7 + 1 | 0;
              continue;
             }
             break;
            }
            label$17: {
             switch ($7 | 0) {
             case 0:
              label$25: {
               if ((strlen($13) | 0) != 4) {
                break label$25;
               }
               if (sqlite3_strnicmp($13, 22880, 4)) {
                break label$25;
               }
               $30 = 1;
               $7 = 0;
               break label$6;
              }
              HEAP32[$8 + 16 >> 2] = $13;
              sqlite3Fts3ErrMsg($6, 7367, $8 + 16 | 0);
              $7 = 1;
              $30 = 1;
              break label$5;

             case 1:
              sqlite3_free($23);
              HEAP32[$8 + 120 >> 2] = 0;
              $7 = 0;
              $23 = $13;
              $13 = 0;
              break label$5;

             case 2:
              sqlite3_free($16);
              HEAP32[$8 + 120 >> 2] = 0;
              $7 = 0;
              $16 = $13;
              $13 = 0;
              break label$5;

             case 3:
              sqlite3_free($17);
              HEAP32[$8 + 120 >> 2] = 0;
              $7 = 0;
              $17 = $13;
              $13 = 0;
              break label$5;

             case 4:
              label$26: {
               label$27: {
                switch (strlen($13) - 3 | 0) {
                case 0:
                 if (sqlite3_strnicmp($13, 16960, 3)) {
                  break label$26;
                 }
                 break label$8;

                case 1:
                 break label$27;

                default:
                 break label$26;
                }
               }
               if (!sqlite3_strnicmp($13, 16955, 4)) {
                break label$8;
               }
              }
              HEAP32[$8 + 32 >> 2] = $13;
              sqlite3Fts3ErrMsg($6, 7344, $8 + 32 | 0);
              $7 = 1;
              break label$7;

             case 5:
              sqlite3_free($18);
              HEAP32[$8 + 120 >> 2] = 0;
              $7 = 0;
              $18 = $13;
              $13 = 0;
              break label$5;

             case 6:
              sqlite3_free($19);
              HEAP32[$8 + 120 >> 2] = 0;
              $7 = 0;
              $19 = $13;
              $13 = 0;
              break label$5;

             case 7:
              break label$17;

             default:
              break label$13;
             }
            }
            HEAP32[($20 << 2) + $26 >> 2] = $13;
            HEAP32[$8 + 120 >> 2] = 0;
            $20 = $20 + 1 | 0;
            $7 = 0;
            $13 = 0;
            break label$5;
           }
           HEAP32[$8 >> 2] = $12;
           sqlite3Fts3ErrMsg($6, 7317, $8);
           $7 = 1;
           break label$6;
          }
          $7 = strlen($12);
          HEAP32[($10 << 2) + $28 >> 2] = $12;
          $10 = $10 + 1 | 0;
          $15 = ($7 + $15 | 0) + 1 | 0;
          $7 = 0;
          break label$4;
         }
         HEAP32[$8 + 120 >> 2] = $15;
         HEAP32[$8 + 124 >> 2] = $7;
         HEAP32[$8 + 116 >> 2] = $10;
         label$29: {
          label$30: {
           label$31: {
            if (!$18 | $7) {
             break label$31;
            }
            sqlite3_free($16);
            sqlite3_free($17);
            $17 = 0;
            $16 = 0;
            if ($10) {
             break label$30;
            }
            sqlite3_free($28);
            HEAP32[$8 + 112 >> 2] = 0;
            $7 = fts3ContentColumns($1, HEAP32[$4 + 4 >> 2], $18, $8 + 112 | 0, $8 + 116 | 0, $8 + 120 | 0, $6);
            HEAP32[$8 + 124 >> 2] = $7;
            if (!$19 | $7) {
             break label$31;
            }
            $12 = HEAP32[$8 + 116 >> 2];
            $11 = ($12 | 0) > 0 ? $12 : 0;
            $9 = HEAP32[$8 + 112 >> 2];
            $7 = 0;
            while (1) {
             if (($7 | 0) == ($11 | 0)) {
              break label$30;
             }
             if (sqlite3_stricmp($19, HEAP32[($7 << 2) + $9 >> 2])) {
              $7 = $7 + 1 | 0;
              continue;
             } else {
              $11 = ($7 | 0) < ($12 | 0) ? $12 : $7;
              while (1) {
               if (($7 | 0) != ($11 | 0)) {
                $3 = ($7 << 2) + $9 | 0;
                $7 = $7 + 1 | 0;
                HEAP32[$3 >> 2] = HEAP32[($7 << 2) + $9 >> 2];
                continue;
               }
               break;
              }
              $12 = $12 - 1 | 0;
              break label$29;
             }
            }
           }
           $11 = 0;
           if ($7) {
            break label$1;
           }
          }
          $12 = HEAP32[$8 + 116 >> 2];
         }
         if (!$12) {
          HEAP32[HEAP32[$8 + 112 >> 2] >> 2] = 2590;
          HEAP32[$8 + 116 >> 2] = 1;
          HEAP32[$8 + 120 >> 2] = 8;
          $12 = 1;
         }
         if (!HEAP32[$8 + 108 >> 2]) {
          $7 = sqlite3Fts3InitTokenizer($2, 13357, $8 + 108 | 0, $6);
          HEAP32[$8 + 124 >> 2] = $7;
          $11 = 0;
          if ($7) {
           break label$1;
          }
         }
         $7 = fts3PrefixParameter($23, $8 + 104 | 0, $8 + 100 | 0);
         HEAP32[$8 + 124 >> 2] = $7;
         $11 = 0;
         label$41: {
          switch ($7 | 0) {
          case 1:
           HEAP32[$8 + 48 >> 2] = $23;
           sqlite3Fts3ErrMsg($6, 7282, $8 + 48 | 0);
           break label$1;

          case 0:
           break label$41;

          default:
           break label$1;
          }
         }
         $14 = HEAP32[$8 + 104 >> 2];
         $3 = Math_imul($14, 24);
         $15 = $12 << 2;
         $9 = (HEAP32[$8 + 120 >> 2] + ($3 + ($15 + (($25 + $27 | 0) + $12 | 0) | 0) | 0) | 0) + 289 | 0;
         $10 = sqlite3_malloc64($9, 0);
         if (!$10) {
          HEAP32[$8 + 124 >> 2] = 7;
          break label$1;
         }
         $7 = 0;
         $10 = memset($10, 0, $9);
         HEAP32[$10 + 268 >> 2] = 0;
         HEAP32[$10 + 24 >> 2] = $12;
         HEAP32[$10 + 12 >> 2] = $1;
         $11 = $10 + 288 | 0;
         HEAP32[$10 + 28 >> 2] = $11;
         $9 = HEAP32[$8 + 108 >> 2];
         HEAP32[$10 + 264 >> 2] = 1048576;
         HEAP32[$10 + 36 >> 2] = $9;
         $9 = ($24 | 0) == 52;
         HEAP8[$10 + 238 | 0] = $9 & !$30;
         HEAP8[$10 + 237 | 0] = $9;
         HEAP8[$10 + 239 | 0] = $31;
         HEAP8[$10 + 236 | 0] = $9;
         HEAP32[$10 + 48 >> 2] = 255;
         $9 = $11 + $15 | 0;
         HEAP32[$10 + 260 >> 2] = $9;
         HEAP32[$10 + 44 >> 2] = $19;
         HEAP32[$10 + 40 >> 2] = $18;
         __memcpy($9, HEAP32[$8 + 100 >> 2], $3);
         HEAP32[$10 + 256 >> 2] = $14;
         $11 = ($14 | 0) > 0 ? $14 : 0;
         while (1) {
          $9 = HEAP32[$10 + 260 >> 2];
          if (($7 | 0) != ($11 | 0)) {
           sqlite3Fts3HashInit((Math_imul($7, 24) + $9 | 0) + 4 | 0);
           $7 = $7 + 1 | 0;
           continue;
          }
          break;
         }
         $7 = Math_imul($14, 24) + $9 | 0;
         HEAP32[$10 + 32 >> 2] = $7;
         $7 = $7 + $12 | 0;
         HEAP32[$10 + 20 >> 2] = $7;
         $7 = __memcpy($7, HEAP32[$4 + 8 >> 2], $25) + $25 | 0;
         HEAP32[$10 + 16 >> 2] = $7;
         $3 = ($12 | 0) > 0 ? $12 : 0;
         $7 = __memcpy($7, HEAP32[$4 + 4 >> 2], $29) + $29 | 0;
         $15 = HEAP32[$8 + 112 >> 2];
         $9 = 0;
         while (1) {
          if (($3 | 0) == ($9 | 0)) {
           $22 = 0;
           $12 = ($20 | 0) > 0 ? $20 : 0;
           $4 = 0;
           while (1) {
            if (($3 | 0) == ($4 | 0)) {
             label$50: {
              $7 = 0;
              while (1) {
               if (($7 | 0) == ($12 | 0)) {
                break label$50;
               }
               $9 = HEAP32[($7 << 2) + $26 >> 2];
               if ($9) {
                HEAP32[$8 + 80 >> 2] = $9;
                sqlite3Fts3ErrMsg($6, 7394, $8 + 80 | 0);
                $22 = 1;
               }
               $7 = $7 + 1 | 0;
               continue;
              }
             }
            } else {
             $7 = 0;
             $15 = $4 << 2;
             $14 = strlen(HEAP32[$15 + HEAP32[$10 + 28 >> 2] >> 2]);
             while (1) {
              if (($7 | 0) != ($12 | 0)) {
               $11 = ($7 << 2) + $26 | 0;
               $9 = HEAP32[$11 >> 2];
               label$56: {
                if (!$9) {
                 break label$56;
                }
                if ((strlen($9) | 0) != ($14 | 0)) {
                 break label$56;
                }
                if (sqlite3_strnicmp(HEAP32[HEAP32[$10 + 28 >> 2] + $15 >> 2], $9, $14)) {
                 break label$56;
                }
                HEAP8[HEAP32[$10 + 32 >> 2] + $4 | 0] = 1;
                sqlite3_free($9);
                HEAP32[$11 >> 2] = 0;
               }
               $7 = $7 + 1 | 0;
               continue;
              }
              break;
             }
             $4 = $4 + 1 | 0;
             continue;
            }
            break;
           }
           HEAP32[$8 + 124 >> 2] = $22;
           if (!(!$16 ^ ($17 | 0) != 0 | $22)) {
            HEAP32[$8 + 124 >> 2] = 1;
            HEAP32[$8 + 64 >> 2] = $16 ? 3941 : 3943;
            sqlite3Fts3ErrMsg($6, 8437, $8 - -64 | 0);
           }
           HEAP32[$10 + 224 >> 2] = fts3ReadExprList($10, $17, $8 + 124 | 0);
           HEAP32[$10 + 228 >> 2] = fts3WriteExprList($10, $16, $8 + 124 | 0);
           $18 = 0;
           if (!HEAP32[$8 + 124 >> 2]) {
            label$59: {
             if ($0) {
              HEAP32[$8 + 124 >> 2] = fts3CreateTables($10);
              break label$59;
             }
             if (($24 | 0) == 52) {
              break label$59;
             }
             HEAP8[$10 + 237 | 0] = 2;
            }
            fts3DatabasePageSize($8 + 124 | 0, $10);
            HEAP32[$10 + 232 >> 2] = HEAP32[$10 + 244 >> 2] - 35;
            fts3DeclareVtab($8 + 124 | 0, $10);
           }
           $19 = 0;
           $11 = $10;
           break label$1;
          }
          HEAP32[$8 + 96 >> 2] = 0;
          $12 = $9 << 2;
          $14 = sqlite3Fts3NextToken(HEAP32[$15 + $12 >> 2], $8 + 96 | 0);
          $11 = HEAP32[$8 + 96 >> 2];
          if (($11 | 0) > 0) {
           __memcpy($7, $14, $11);
          }
          $11 = $7 + $11 | 0;
          HEAP8[$11 | 0] = 0;
          sqlite3Fts3Dequote($7);
          HEAP32[HEAP32[$10 + 28 >> 2] + $12 >> 2] = $7;
          $9 = $9 + 1 | 0;
          $7 = $11 + 1 | 0;
          continue;
         }
        }
        $7 = 0;
       }
       $31 = (HEAPU8[$13 | 0] & 223) == 68;
      }
     }
     $9 = $13;
     sqlite3_free($9);
    }
    $14 = $14 + 1 | 0;
    continue;
   }
  }
  HEAP32[$8 + 124 >> 2] = 7;
  $21 = 0;
  $11 = 0;
 }
 sqlite3_free($23);
 sqlite3_free(HEAP32[$8 + 100 >> 2]);
 sqlite3_free($16);
 sqlite3_free($17);
 sqlite3_free($18);
 sqlite3_free($19);
 $7 = 0;
 $9 = ($20 | 0) > 0 ? $20 : 0;
 while (1) {
  if (($7 | 0) != ($9 | 0)) {
   sqlite3_free(HEAP32[($7 << 2) + $21 >> 2]);
   $7 = $7 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3_free(HEAP32[$8 + 112 >> 2]);
 sqlite3_free($21);
 $7 = HEAP32[$8 + 124 >> 2];
 label$64: {
  if ($7) {
   if ($11) {
    fts3DisconnectMethod($11);
    break label$64;
   }
   $9 = HEAP32[$8 + 108 >> 2];
   if (!$9) {
    break label$64;
   }
   FUNCTION_TABLE[HEAP32[HEAP32[$9 >> 2] + 8 >> 2]]($9) | 0;
   break label$64;
  }
  HEAP32[$5 >> 2] = $11;
 }
 __stack_pointer = $8 + 128 | 0;
 return $7;
}

function selectExpander($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
 $9 = __stack_pointer - 112 | 0;
 __stack_pointer = $9;
 $4 = HEAP32[$0 >> 2];
 $8 = HEAP32[$4 >> 2];
 $5 = HEAP32[$1 + 4 >> 2];
 HEAP32[$1 + 4 >> 2] = $5 | 64;
 $15 = 2;
 label$1: {
  if (HEAPU8[$8 + 87 | 0]) {
   break label$1;
  }
  $15 = 1;
  if ($5 & 64) {
   break label$1;
  }
  if (HEAPU16[$0 + 20 >> 1]) {
   $2 = HEAP32[$4 + 100 >> 2] + 1 | 0;
   HEAP32[$4 + 100 >> 2] = $2;
   HEAP32[$1 + 16 >> 2] = $2;
  }
  $2 = HEAP32[$1 + 64 >> 2];
  $18 = HEAP32[$1 + 28 >> 2];
  $19 = HEAP32[$1 + 32 >> 2];
  if (!(!HEAP32[$4 + 264 >> 2] | !($5 & 2097152))) {
   if (!$2) {
    $2 = sqlite3DbMallocZero($8, 36, 0);
    HEAP32[$1 + 64 >> 2] = $2;
    $15 = 2;
    if (!$2) {
     break label$1;
    }
   }
   HEAP32[$2 + 4 >> 2] = 1;
  }
  sqlite3WithPush($4, $2, 0);
  sqlite3SrcListAssignCursors($4, $19);
  $27 = $19 + 8 | 0;
  $2 = $27;
  label$5: {
   while (1) {
    if (HEAP32[$19 >> 2] > ($7 | 0)) {
     label$8: {
      if (HEAP32[$2 + 16 >> 2]) {
       break label$8;
      }
      label$9: {
       if (!HEAP32[$2 + 8 >> 2]) {
        $15 = 2;
        if (sqlite3WalkSelect($0, HEAP32[$2 + 20 >> 2])) {
         break label$1;
        }
        if (!sqlite3ExpandSubquery($4, $2)) {
         break label$9;
        }
        break label$1;
       }
       $3 = resolveFromTermToCte($4, $0, $2);
       if ($3) {
        if (($3 | 0) <= 1) {
         break label$9;
        }
        break label$5;
       }
       $3 = sqlite3LocateTableItem($4, 0, $2);
       HEAP32[$2 + 16 >> 2] = $3;
       $15 = 2;
       if (!$3) {
        break label$1;
       }
       $12 = HEAP32[$3 + 24 >> 2];
       if ($12 >>> 0 >= 65535) {
        HEAP32[$9 >> 2] = HEAP32[$3 >> 2];
        sqlite3ErrorMsg($4, 22699, $9);
        HEAP32[$2 + 16 >> 2] = 0;
        break label$1;
       }
       HEAP32[$3 + 24 >> 2] = $12 + 1;
       if (HEAPU8[$3 + 43 | 0] != 1) {
        if (cannotBeFunction($4, $2)) {
         break label$1;
        }
        if (!HEAPU8[$3 + 43 | 0]) {
         break label$9;
        }
       }
       $12 = HEAPU8[$0 + 20 | 0];
       if (sqlite3ViewGetColumnNames($4, $3)) {
        break label$1;
       }
       label$14: {
        label$15: {
         switch (HEAPU8[$3 + 43 | 0] - 1 | 0) {
         case 1:
          if (!(HEAPU8[$8 + 35 | 0] & 128 | HEAP32[$3 + 60 >> 2] == HEAP32[HEAP32[$8 + 16 >> 2] + 28 >> 2])) {
           HEAP32[$9 + 16 >> 2] = HEAP32[$3 >> 2];
           sqlite3ErrorMsg($4, 14891, $9 + 16 | 0);
          }
          HEAP32[$2 + 20 >> 2] = sqlite3SelectDup($8, HEAP32[$3 + 44 >> 2], 0);
          break label$14;

         case 0:
          break label$15;

         default:
          break label$14;
         }
        }
        if (!(HEAPU8[$2 + 37 | 0] & 128)) {
         break label$14;
        }
        $6 = HEAP32[$3 + 52 >> 2];
        if (!$6 | HEAPU8[$6 + 17 | 0] <= (HEAP32[$8 + 32 >> 2] >>> 7 & 1) >>> 0) {
         break label$14;
        }
        HEAP32[$9 + 32 >> 2] = HEAP32[$3 >> 2];
        sqlite3ErrorMsg($4, 28717, $9 + 32 | 0);
       }
       $6 = HEAPU16[$3 + 34 >> 1];
       HEAP16[$3 + 34 >> 1] = 65535;
       HEAP16[$0 + 20 >> 1] = 1;
       sqlite3WalkSelect($0, HEAP32[$2 + 20 >> 2]);
       HEAP16[$0 + 20 >> 1] = $12;
       HEAP16[$3 + 34 >> 1] = $6;
      }
      if (!(HEAPU8[$2 + 37 | 0] & 2)) {
       break label$8;
      }
      if (sqlite3IndexedByLookup($4, $2)) {
       break label$5;
      }
     }
     $2 = $2 - -64 | 0;
     $7 = $7 + 1 | 0;
     continue;
    }
    break;
   }
   $15 = 2;
   if (HEAP32[$4 + 36 >> 2]) {
    break label$1;
   }
   if (sqlite3ProcessJoin($4, $1)) {
    break label$1;
   }
   $0 = HEAP32[$18 >> 2];
   $12 = ($0 | 0) > 0 ? $0 : 0;
   $2 = 0;
   label$18: {
    label$19: {
     while (1) {
      if (($2 | 0) != ($12 | 0)) {
       $7 = HEAP32[(($2 << 4) + $18 | 0) + 8 >> 2];
       $3 = HEAPU8[$7 | 0];
       label$22: {
        if (($3 | 0) != 141) {
         if (($3 | 0) != 180) {
          break label$22;
         }
         break label$19;
        }
        if (HEAPU8[HEAP32[$7 + 16 >> 2]] == 180) {
         break label$19;
        }
       }
       $2 = $2 + 1 | 0;
       $24 = HEAP32[$7 + 4 >> 2] | $24;
       continue;
      }
      break;
     }
     $3 = HEAP32[$1 + 28 >> 2];
     break label$18;
    }
    $20 = $5 & 2048;
    $29 = $18 + 8 | 0;
    $30 = HEAP32[HEAP32[$4 >> 2] + 32 >> 2] & 68;
    $3 = 0;
    while (1) {
     label$25: {
      if (($0 | 0) > ($25 | 0)) {
       $2 = ($25 << 4) + $29 | 0;
       $16 = HEAP32[$2 >> 2];
       $31 = HEAP32[$16 + 4 >> 2];
       $10 = 0;
       $14 = 0;
       $7 = HEAPU8[$16 | 0];
       if (($7 | 0) != 180) {
        if (!(($7 | 0) == 141 & HEAPU8[HEAP32[$16 + 16 >> 2]] == 180)) {
         $3 = sqlite3ExprListAppend($4, $3, $16);
         if ($3) {
          $7 = (HEAP32[$3 >> 2] << 4) + $3 | 0;
          HEAP32[$7 - 4 >> 2] = HEAP32[$2 + 4 >> 2];
          $0 = $7;
          $7 = $7 + 1 | 0;
          $0 = (HEAPU8[$0 + 1 | 0] | HEAPU8[$0 + 2 | 0] << 8) & 65532 | (HEAPU8[$2 + 9 | 0] | HEAPU8[$2 + 10 | 0] << 8) & 3;
          HEAP8[$7 | 0] = $0;
          HEAP8[$7 + 1 | 0] = $0 >>> 8;
          HEAP32[$2 + 4 >> 2] = 0;
         }
         HEAP32[$2 >> 2] = 0;
         break label$25;
        }
        $14 = HEAP32[HEAP32[$16 + 12 >> 2] + 8 >> 2];
       }
       $11 = $27;
       $6 = 0;
       while (1) {
        label$32: {
         label$33: {
          label$34: {
           label$35: {
            $0 = HEAP32[$19 >> 2];
            if (($6 | 0) >= ($0 | 0)) {
             break label$35;
            }
            $7 = HEAP32[$11 + 16 >> 2];
            $17 = HEAP32[$11 + 12 >> 2];
            if (!$17) {
             $17 = HEAP32[$7 >> 2];
            }
            if (HEAPU8[$8 + 87 | 0]) {
             break label$35;
            }
            label$37: {
             if (HEAPU8[$11 + 38 | 0] & 32) {
              $21 = HEAP32[HEAP32[$11 + 20 >> 2] + 28 >> 2];
              $5 = 0;
              break label$37;
             }
             label$39: {
              if (!$14) {
               break label$39;
              }
              if (!sqlite3StrICmp($14, $17)) {
               break label$39;
              }
              $0 = $6 + 1 | 0;
              break label$32;
             }
             $21 = 0;
             $2 = sqlite3SchemaToIndex($8, HEAP32[$7 + 60 >> 2]);
             $5 = 24304;
             if (($2 | 0) < 0) {
              break label$37;
             }
             $5 = HEAP32[HEAP32[$8 + 16 >> 2] + ($2 << 4) >> 2];
            }
            $26 = $5;
            $2 = 0;
            $28 = $6 + 1 | 0;
            if (!(HEAPU8[$11 + 102 | 0] & 4) | !$20 | ($28 | 0) >= ($0 | 0)) {
             break label$34;
            }
            $22 = HEAP32[$11 + 108 >> 2];
            $0 = 0;
            while (1) {
             if (HEAP32[$22 >> 2] <= ($0 | 0)) {
              break label$33;
             }
             $5 = HEAP32[(($0 << 3) + $22 | 0) + 8 >> 2];
             $3 = sqlite3ExprListAppend($4, $3, sqlite3Expr($8, 59, $5));
             if ($3) {
              $12 = HEAP32[$3 >> 2];
              HEAP32[$9 + 80 >> 2] = $5;
              $5 = ($12 << 4) + $3 | 0;
              HEAP32[$5 - 4 >> 2] = sqlite3MPrintf($8, 6022, $9 + 80 | 0);
              $13 = $5;
              $5 = $5 + 1 | 0;
              $13 = (HEAPU8[$13 + 1 | 0] | HEAPU8[$13 + 2 | 0] << 8) & 65404 | 130;
              HEAP8[$5 | 0] = $13;
              HEAP8[$5 + 1 | 0] = $13 >>> 8;
             }
             $0 = $0 + 1 | 0;
             continue;
            }
           }
           if ($10) {
            break label$25;
           }
           if ($14) {
            HEAP32[$9 + 96 >> 2] = $14;
            sqlite3ErrorMsg($4, 7892, $9 + 96 | 0);
            break label$25;
           }
           sqlite3ErrorMsg($4, 15700, 0);
           break label$25;
          }
          $22 = 0;
         }
         $12 = ($14 | 0) != 0 & ($21 | 0) != 0;
         $32 = $6 ^ -1;
         $33 = !$20 & (!$14 & ($6 | 0) != 0);
         while (1) {
          label$44: {
           if (HEAP16[$7 + 34 >> 1] <= ($2 | 0)) {
            break label$44;
           }
           $6 = Math_imul($2, 12);
           $0 = $6 + HEAP32[$7 + 4 >> 2] | 0;
           $5 = HEAP32[$0 >> 2];
           label$45: {
            if ($12) {
             if (!sqlite3MatchEName((($2 << 4) + $21 | 0) + 8 | 0, 0, $14, 0)) {
              break label$45;
             }
            }
            $0 = HEAPU16[$0 + 10 >> 1];
            if (!($0 & 2 ? HEAPU8[$1 + 6 | 0] & 2 : 1) | !($20 ? 1 : !($0 & 1024) | $14)) {
             break label$45;
            }
            if (!(!$33 | !(HEAPU8[$11 + 38 | 0] & 4))) {
             $10 = 1;
             if ((sqlite3IdListIndex(HEAP32[$11 + 44 >> 2], $5) | 0) >= 0) {
              break label$45;
             }
            }
            $0 = sqlite3Expr($8, 59, $5);
            $10 = HEAP32[$19 >> 2];
            label$48: {
             label$49: {
              if (($10 | 0) >= 2) {
               if (!(HEAPU8[$11 + 36 | 0] & 64) | $20) {
                break label$49;
               }
               if (!inAnyUsingClause($5, $11, $10 + $32 | 0)) {
                break label$49;
               }
              }
              if (HEAPU8[$4 + 208 | 0] < 2) {
               break label$48;
              }
             }
             $10 = sqlite3Expr($8, 59, $17);
             $0 = sqlite3PExpr($4, 141, $10, $0);
             label$51: {
              if (HEAPU8[$4 + 208 | 0] < 2) {
               break label$51;
              }
              $23 = HEAP32[$16 + 12 >> 2];
              if (!$23) {
               break label$51;
              }
              sqlite3RenameTokenRemap($4, $10, $23);
             }
             if (!$26) {
              break label$48;
             }
             $0 = sqlite3PExpr($4, 141, sqlite3Expr($8, 59, $26), $0);
            }
            $3 = sqlite3ExprListAppend($4, $3, $0);
            if (!$3) {
             $10 = 1;
             $3 = 0;
             break label$44;
            }
            $0 = HEAP32[$3 >> 2] - 1 | 0;
            label$53: {
             if (!(!$20 | HEAPU8[$4 + 208 | 0] > 1)) {
              $0 = ($0 << 4) + $3 | 0;
              label$55: {
               if ($21) {
                $10 = sqlite3DbStrDup($8, HEAP32[(($2 << 4) + $21 | 0) + 12 >> 2]);
                break label$55;
               }
               HEAP32[$9 + 72 >> 2] = $5;
               HEAP32[$9 + 68 >> 2] = $17;
               HEAP32[$9 + 64 >> 2] = $26;
               $10 = sqlite3MPrintf($8, 5865, $9 - -64 | 0);
              }
              HEAP32[$0 + 12 >> 2] = $10;
              $13 = $0;
              $0 = $0 + 17 | 0;
              $23 = (HEAPU8[$13 + 17 | 0] | HEAPU8[$13 + 18 | 0] << 8) & -4;
              $10 = $23 | 2;
              HEAP8[$0 | 0] = $10;
              HEAP8[$0 + 1 | 0] = $10 >>> 8;
              label$57: {
               if (HEAPU8[$11 + 38 | 0] & 4) {
                if ((sqlite3IdListIndex(HEAP32[$11 + 44 >> 2], $5) | 0) >= 0) {
                 break label$57;
                }
               }
               if ($22) {
                if ((sqlite3IdListIndex($22, $5) | 0) >= 0) {
                 break label$57;
                }
               }
               $10 = 1;
               if (!(HEAPU8[(HEAP32[$7 + 4 >> 2] + $6 | 0) + 11 | 0] & 4)) {
                break label$45;
               }
              }
              $0 = $23 | 258;
              HEAP8[$13 + 17 | 0] = $0;
              HEAP8[$13 + 18 | 0] = $0 >>> 8;
              break label$53;
             }
             if (!$34 & ($30 | 0) == 4) {
              HEAP32[$9 + 52 >> 2] = $5;
              HEAP32[$9 + 48 >> 2] = $17;
              $0 = ($0 << 4) + $3 | 0;
              HEAP32[$0 + 12 >> 2] = sqlite3MPrintf($8, 6016, $9 + 48 | 0);
              $6 = $0;
              $0 = $0 + 17 | 0;
              $6 = (HEAPU8[$6 + 17 | 0] | HEAPU8[$6 + 18 | 0] << 8) & 65532;
              HEAP8[$0 | 0] = $6;
              HEAP8[$0 + 1 | 0] = $6 >>> 8;
              break label$53;
             }
             $0 = ($0 << 4) + $3 | 0;
             HEAP32[$0 + 12 >> 2] = sqlite3DbStrDup($8, $5);
             $6 = $0;
             $0 = $0 + 17 | 0;
             $6 = (HEAPU8[$6 + 17 | 0] | HEAPU8[$6 + 18 | 0] << 8) & 65532;
             HEAP8[$0 | 0] = $6;
             HEAP8[$0 + 1 | 0] = $6 >>> 8;
            }
            $10 = 1;
           }
           $2 = $2 + 1 | 0;
           continue;
          }
          break;
         }
         $0 = $28;
        }
        $6 = $0;
        $11 = $11 - -64 | 0;
        continue;
       }
      }
      sqlite3ExprListDelete($8, $18);
      HEAP32[$1 + 28 >> 2] = $3;
      break label$18;
     }
     $24 = $24 | $31;
     $25 = $25 + 1 | 0;
     $0 = HEAP32[$18 >> 2];
     continue;
    }
   }
   label$61: {
    if (!$3) {
     break label$61;
    }
    if (HEAP32[$3 >> 2] > HEAP32[$8 + 128 >> 2]) {
     sqlite3ErrorMsg($4, 3072, 0);
     break label$1;
    }
    if (!($24 & 4194312)) {
     break label$61;
    }
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 262144;
   }
   $15 = 0;
   break label$1;
  }
  $15 = 2;
 }
 __stack_pointer = $9 + 112 | 0;
 return $15 | 0;
}

function sqlite3WhereBegin($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 $16 = __stack_pointer - 32 | 0;
 __stack_pointer = $16;
 $12 = HEAP32[$0 + 8 >> 2];
 $13 = HEAP32[$0 >> 2];
 HEAP32[$16 + 28 >> 2] = 0;
 HEAP32[$16 + 20 >> 2] = 0;
 HEAP32[$16 + 24 >> 2] = 0;
 $11 = $3 ? HEAP32[$3 >> 2] > 63 ? 0 : $3 : $11;
 $3 = HEAP32[$1 >> 2];
 label$2: {
  label$3: {
   if (($3 | 0) >= 65) {
    HEAP32[$16 >> 2] = 64;
    sqlite3ErrorMsg($0, 10719, $16);
    break label$3;
   }
   $10 = $6 & 32 ? 1 : $3;
   $17 = Math_imul($10, 96);
   $9 = $17 + 775 & -32;
   $3 = sqlite3DbMallocRawNN($13, $9 + 72 | 0, 0);
   if (HEAPU8[$13 + 87 | 0]) {
    sqlite3DbFree($13, $3);
    break label$3;
   }
   HEAP32[$3 + 16 >> 2] = $2;
   HEAP32[$3 + 8 >> 2] = $11;
   HEAP32[$3 + 4 >> 2] = $1;
   HEAP32[$3 >> 2] = $0;
   HEAP32[$3 + 12 >> 2] = $4;
   HEAP8[$3 + 48 | 0] = $10;
   HEAP32[$3 + 24 >> 2] = -1;
   HEAP32[$3 + 28 >> 2] = -1;
   $8 = sqlite3VdbeMakeLabel($0);
   HEAP16[$3 + 46 >> 1] = $7;
   HEAP16[$3 + 44 >> 1] = $6;
   HEAP32[$3 + 36 >> 2] = $8;
   HEAP32[$3 + 32 >> 2] = $8;
   $8 = HEAP32[$0 + 136 >> 2];
   HEAP32[$3 + 20 >> 2] = $5;
   HEAP32[$3 + 40 >> 2] = $8;
   $8 = 0;
   $18 = memset($3 + 49 | 0, 0, 39);
   $14 = $3 + 768 | 0;
   memset($14, 0, $17 + 72 | 0);
   HEAP32[$3 + 508 >> 2] = 0;
   HEAP32[$3 + 512 >> 2] = -99;
   $9 = $3 + $9 | 0;
   HEAP32[$16 + 16 >> 2] = $9;
   $17 = $3 + 88 | 0;
   HEAP32[$16 + 12 >> 2] = $17;
   HEAP32[$16 + 8 >> 2] = $3;
   whereLoopInit($9);
   sqlite3WhereClauseInit($17, $3);
   sqlite3WhereSplit($17, $2, 44);
   label$6: {
    if ($10) {
     $9 = $3 + 504 | 0;
     while (1) {
      $2 = ($8 << 6) + $1 | 0;
      createMask($9, HEAP32[$2 + 48 >> 2]);
      sqlite3WhereTabFuncArgs($0, $2 + 8 | 0, $17);
      $8 = $8 + 1 | 0;
      if (($8 | 0) < HEAP32[$1 >> 2]) {
       continue;
      }
      break;
     }
     break label$6;
    }
    if ($11) {
     HEAP8[$18 | 0] = HEAP32[$11 >> 2];
    }
    if (!(!($6 & 256) | HEAPU8[$13 + 80 | 0] & 16)) {
     HEAP8[$3 + 51 | 0] = 1;
    }
    sqlite3VdbeExplain($0, 0, 18193, 0);
   }
   sqlite3WhereExprAnalyze($1, $17);
   sqlite3WhereAddLimit($17, $5);
   label$11: {
    if (HEAP32[$0 + 36 >> 2]) {
     break label$11;
    }
    $8 = 0;
    while (1) {
     if (($8 | 0) < HEAP32[$3 + 108 >> 2]) {
      $2 = HEAP32[$3 + 112 >> 2] + Math_imul($8, 48) | 0;
      label$14: {
       if (HEAPU8[$2 + 10 | 0] & 2 | (HEAP32[$2 + 40 >> 2] | HEAP32[$2 + 44 >> 2])) {
        break label$14;
       }
       if ($10) {
        if (!exprIsDeterministic(HEAP32[$2 >> 2])) {
         break label$14;
        }
       }
       sqlite3ExprIfFalse($0, HEAP32[$2 >> 2], HEAP32[$3 + 36 >> 2], 16);
       $5 = $2;
       $2 = $2 + 10 | 0;
       HEAP16[$2 >> 1] = HEAPU16[$5 + 10 >> 1] | 4;
      }
      $8 = $8 + 1 | 0;
      continue;
     }
     break;
    }
    label$16: {
     if (!($6 & 256)) {
      break label$16;
     }
     if (HEAPU8[$13 + 80 | 0] & 16) {
      HEAP16[$3 + 44 >> 1] = HEAPU16[$3 + 44 >> 1] & 65279;
      $6 = $6 & 65279;
      break label$16;
     }
     if (isDistinctRedundant($0, $1, $17, $4)) {
      HEAP8[$3 + 51 | 0] = 1;
      break label$16;
     }
     if ($11) {
      break label$16;
     }
     HEAP32[$3 + 8 >> 2] = $4;
     HEAP16[$3 + 44 >> 1] = HEAPU16[$3 + 44 >> 1] | 128;
    }
    label$19: {
     label$20: {
      label$21: {
       if (($10 | 0) == 1) {
        if (whereShortCut($16 + 8 | 0)) {
         break label$21;
        }
       }
       if (whereLoopAddAll($16 + 8 | 0)) {
        break label$11;
       }
       wherePathSolver($3, 0);
       if (HEAPU8[$13 + 87 | 0]) {
        break label$11;
       }
       if (!HEAP32[$3 + 8 >> 2]) {
        break label$20;
       }
       wherePathSolver($3, (HEAPU16[$3 + 54 >> 1] << 16) + 65536 >> 16);
       if (HEAPU8[$13 + 87 | 0]) {
        break label$11;
       }
      }
      if (HEAP32[$3 + 8 >> 2]) {
       break label$19;
      }
     }
     if (!(HEAPU8[$13 + 33 | 0] & 16)) {
      break label$19;
     }
     HEAP32[$3 + 80 >> 2] = -1;
     HEAP32[$3 + 84 >> 2] = -1;
    }
    if (HEAP32[$0 + 36 >> 2]) {
     break label$11;
    }
    $19 = -1;
    $20 = -1;
    $8 = HEAPU8[$3 + 48 | 0];
    label$23: {
     label$24: {
      if (!(!$4 | $6 & 1024 | $8 >>> 0 < 2)) {
       if (HEAP8[$13 + 81 | 0] & 1) {
        break label$24;
       }
       $19 = whereOmitNoopJoin($3);
       $20 = i64toi32_i32$HIGH_BITS;
       $8 = HEAPU8[$3 + 48 | 0];
       $10 = $8;
      }
      if (($8 & 255) >>> 0 < 2) {
       break label$23;
      }
     }
     if (HEAPU8[$13 + 82 | 0] & 8) {
      break label$23;
     }
     whereCheckIfBloomFilterIsUseful($3);
    }
    $8 = HEAP32[$3 >> 2];
    HEAP32[$8 + 136 >> 2] = HEAP32[$8 + 136 >> 2] + HEAP16[$3 + 54 >> 1];
    $15 = 0;
    label$26: {
     if (!($6 & 4)) {
      break label$26;
     }
     $9 = HEAP32[$3 + 848 >> 2];
     $8 = HEAP32[$9 + 40 >> 2];
     label$27: {
      if ($8 & 4096) {
       $2 = HEAP32[$1 + 24 >> 2];
       $11 = 1;
       break label$27;
      }
      $15 = 0;
      if (!($6 & 8)) {
       break label$26;
      }
      $2 = HEAP32[$1 + 24 >> 2];
      $15 = 0;
      if (HEAPU8[$2 + 43 | 0] == 1) {
       break label$26;
      }
      $11 = 2;
      if ($6 & 16) {
       break label$27;
      }
      $15 = 0;
      if ($8 & 8192) {
       break label$26;
      }
     }
     HEAP8[$3 + 50 | 0] = $11;
     $15 = 0;
     if (HEAPU8[$2 + 28 | 0] & 128) {
      break label$26;
     }
     $15 = 0;
     if (!($8 & 64)) {
      break label$26;
     }
     HEAP32[$9 + 40 >> 2] = $8 & -65;
     $15 = $6 & 8;
    }
    $22 = ($10 | 0) > 0 ? $10 : 0;
    $21 = $6 & 32;
    $23 = !$7 | !$21;
    $5 = 0;
    while (1) {
     if (($5 | 0) != ($22 | 0)) {
      $18 = (HEAPU8[$14 + 60 | 0] << 6) + $1 | 0;
      $8 = $18 + 24 | 0;
      $10 = HEAP32[$8 >> 2];
      $4 = sqlite3SchemaToIndex($13, HEAP32[$10 + 60 >> 2]);
      $11 = HEAP32[$14 + 80 >> 2];
      label$31: {
       if (HEAPU8[$10 + 29 | 0] & 64) {
        break label$31;
       }
       $2 = HEAPU8[$10 + 43 | 0];
       if (($2 | 0) == 2) {
        break label$31;
       }
       $9 = HEAP32[$11 + 40 >> 2];
       if ($9 & 1024) {
        sqlite3VdbeAddOp4($12, 173, HEAP32[$18 + 48 >> 2], 0, 0, sqlite3GetVTable($13, $10), -11);
        break label$31;
       }
       if (($2 | 0) == 1) {
        break label$31;
       }
       if (!(HEAPU8[$18 + 44 | 0] & 80 ? 0 : $9 & 64 | $21)) {
        if (HEAPU8[$3 + 50 | 0]) {
         HEAP32[$3 + 24 >> 2] = HEAP32[$18 + 48 >> 2];
         $2 = 113;
        } else {
         $2 = 112;
        }
        sqlite3OpenTable($0, HEAP32[$18 + 48 >> 2], $4, $10, $2);
        if (!(HEAPU8[$3 + 50 | 0] | HEAP16[$10 + 34 >> 1] > 63 | (HEAPU8[$10 + 28 | 0] & 224 | HEAP32[$11 + 40 >> 2] & 4210688))) {
         $8 = HEAP32[$18 + 56 >> 2];
         $9 = HEAP32[$18 + 60 >> 2];
         $2 = 0;
         while (1) {
          if ($9 | $8) {
           $2 = $2 + 1 | 0;
           $8 = ($9 & 1) << 31 | $8 >>> 1;
           $9 = $9 >>> 1 | 0;
           continue;
          }
          break;
         }
         sqlite3VdbeChangeP4($12, -1, $2, -3);
        }
        sqlite3VdbeChangeP5($12, $15);
        break label$31;
       }
       sqlite3TableLock($0, $4, HEAP32[$10 + 20 >> 2], 0, HEAP32[$10 >> 2]);
      }
      label$40: {
       if (!(HEAPU8[$11 + 41 | 0] & 2)) {
        break label$40;
       }
       label$41: {
        label$42: {
         $9 = HEAP32[$11 + 32 >> 2];
         if (!(!(!(HEAPU8[$10 + 28 | 0] & 128) | !$21) & ((HEAPU8[$9 + 55 | 0] | HEAPU8[$9 + 56 | 0] << 8) & 3) == 2)) {
          if (HEAPU8[$3 + 50 | 0]) {
           $8 = HEAP32[$18 + 24 >> 2] + 8 | 0;
           $2 = $7;
           while (1) {
            $8 = HEAP32[$8 >> 2];
            if (!$8 | ($8 | 0) == ($9 | 0)) {
             break label$42;
            }
            $8 = $8 + 20 | 0;
            $2 = $2 + 1 | 0;
            continue;
           }
          }
          $2 = $7;
          $8 = 101;
          if (!$23) {
           break label$41;
          }
          $2 = HEAP32[$0 + 40 >> 2];
          HEAP32[$0 + 40 >> 2] = $2 + 1;
          $8 = 112;
          break label$41;
         }
         HEAP32[$14 + 8 >> 2] = HEAP32[$14 + 4 >> 2];
         break label$40;
        }
        HEAP32[$3 + 28 >> 2] = $2;
        $8 = 113;
       }
       HEAP32[$14 + 8 >> 2] = $2;
       sqlite3VdbeAddOp3($12, $8, $2, HEAP32[$9 + 44 >> 2], $4);
       sqlite3VdbeSetP4KeyInfo($0, $9);
       $8 = HEAP32[$11 + 40 >> 2];
       if (HEAP8[$3 + 44 | 0] & 1 | (!($8 & 15) | $8 & 32770 | ($8 & 524288 | $8 & 1048576)) | HEAPU8[$3 + 51 | 0] == 2) {
        break label$40;
       }
       sqlite3VdbeChangeP5($12, 2);
      }
      if (($4 | 0) >= 0) {
       sqlite3CodeVerifySchema($0, $4);
      }
      label$48: {
       if (!(HEAPU8[$18 + 44 | 0] & 16)) {
        break label$48;
       }
       $8 = sqlite3WhereMalloc($3, 20, 0);
       HEAP32[$14 + 56 >> 2] = $8;
       if (!$8) {
        break label$48;
       }
       $2 = HEAP32[$0 + 40 >> 2];
       HEAP32[$0 + 40 >> 2] = $2 + 1;
       HEAP32[$8 >> 2] = $2;
       $2 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $2;
       HEAP32[$8 + 4 >> 2] = $2;
       sqlite3VdbeAddOp2($12, 77, 65536, $2);
       $2 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $2;
       HEAP32[$8 + 8 >> 2] = $2;
       sqlite3VdbeAddOp2($12, 75, 0, $2);
       label$49: {
        if (!(HEAPU8[$10 + 28 | 0] & 128)) {
         sqlite3VdbeAddOp2($12, 118, HEAP32[$8 >> 2], 1);
         $8 = sqlite3KeyInfoAlloc(HEAP32[$0 >> 2], 1, 0);
         if (!$8) {
          break label$49;
         }
         HEAP32[$8 + 20 >> 2] = 0;
         HEAP8[HEAP32[$8 + 16 >> 2]] = 0;
         sqlite3VdbeAppendP4($12, $8, -8);
         break label$49;
        }
        $2 = HEAP32[$8 >> 2];
        $8 = sqlite3PrimaryKeyIndex($10);
        sqlite3VdbeAddOp2($12, 118, $2, HEAPU16[$8 + 50 >> 1]);
        sqlite3VdbeSetP4KeyInfo($0, $8);
       }
       HEAP32[$11 + 40 >> 2] = HEAP32[$11 + 40 >> 2] & -65;
       HEAP8[$3 + 51 | 0] = 3;
       HEAP8[$3 + 49 | 0] = 0;
      }
      $14 = $14 + 96 | 0;
      $5 = $5 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP32[$3 + 56 >> 2] = sqlite3VdbeCurrentAddr($12);
    if (HEAPU8[$13 + 87 | 0]) {
     break label$11;
    }
    $8 = 0;
    while (1) {
     if (($8 | 0) != ($22 | 0)) {
      if (HEAP32[$0 + 36 >> 2]) {
       break label$11;
      }
      $2 = Math_imul($8, 96) + $3 | 0;
      $11 = HEAP32[HEAP32[$2 + 848 >> 2] + 40 >> 2];
      $10 = $2 + 828 | 0;
      $9 = (HEAPU8[$10 | 0] << 6) + $1 | 0;
      $14 = HEAPU8[$9 + 45 | 0] | HEAPU8[$9 + 46 | 0] << 8;
      label$53: {
       if (!($14 & 16)) {
        break label$53;
       }
       if ($14 & 8) {
        sqlite3VdbeAddOp2($12, 9, HEAP32[$9 + 36 >> 2], HEAP32[$9 + 32 >> 2]);
        break label$53;
       }
       $14 = sqlite3VdbeAddOp0($12, 14);
       sqlite3VdbeAddOp2($12, 9, HEAP32[$9 + 36 >> 2], HEAP32[$9 + 32 >> 2]);
       sqlite3VdbeJumpHere($12, $14);
      }
      $9 = $2 + 768 | 0;
      if ($11 & 4210688) {
       label$56: {
        if ($11 & 16384) {
         constructAutomaticIndex($0, $17, ((HEAPU8[$2 + 828 | 0] << 6) + $1 | 0) + 8 | 0, $19, $20, $9);
         break label$56;
        }
        sqlite3ConstructBloomFilter($3, $8, $9, $19, $20);
       }
       if (HEAPU8[$13 + 87 | 0]) {
        break label$11;
       }
      }
      sqlite3WhereExplainOneScan($0, $1, $9, $6);
      HEAP32[$2 + 800 >> 2] = sqlite3VdbeCurrentAddr($12);
      $19 = sqlite3WhereCodeOneLoopStart($0, $12, $3, $8, $9, $19, $20);
      $20 = i64toi32_i32$HIGH_BITS;
      HEAP32[$3 + 32 >> 2] = HEAP32[$2 + 792 >> 2];
      $8 = $8 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP32[$3 + 60 >> 2] = sqlite3VdbeCurrentAddr($12);
    break label$2;
   }
   whereUndoExprMods($3);
   HEAP32[$0 + 136 >> 2] = HEAP32[$3 + 40 >> 2];
   whereInfoFree($13, $3);
  }
  $3 = 0;
 }
 __stack_pointer = $16 + 32 | 0;
 return $3;
}

function porter_stemmer($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 label$1: {
  label$2: {
   if ($1 - 21 >>> 0 <= 4294967277) {
    break label$2;
   }
   $7 = 22;
   while (1) {
    label$4: {
     if (($1 | 0) != ($4 | 0)) {
      $6 = HEAPU8[$0 + $4 | 0];
      if (($6 - 65 & 255) >>> 0 <= 25) {
       $6 = $6 + 32 | 0;
       break label$4;
      }
      if (($6 - 97 & 255) >>> 0 < 26) {
       break label$4;
      }
      break label$2;
     }
     HEAP8[$5 + 43 | 0] = 0;
     HEAP8[$5 + 39 | 0] = 0;
     HEAP8[$5 + 40 | 0] = 0;
     HEAP8[$5 + 41 | 0] = 0;
     HEAP8[$5 + 42 | 0] = 0;
     $0 = $5 + $7 | 0;
     $4 = $0 + 17 | 0;
     HEAP32[$5 + 12 >> 2] = $4;
     label$7: {
      if (HEAPU8[$0 + 17 | 0] != 115) {
       break label$7;
      }
      if (stem($5 + 12 | 0, 3936, 4159, 0)) {
       break label$7;
      }
      if (stem($5 + 12 | 0, 11621, 11640, 0)) {
       break label$7;
      }
      if (stem($5 + 12 | 0, 4159, 4159, 0)) {
       break label$7;
      }
      HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
     }
     $4 = HEAP32[$5 + 12 >> 2];
     label$8: {
      if (stem($5 + 12 | 0, 14015, 14016, 104)) {
       break label$8;
      }
      label$9: {
       if (!stem($5 + 12 | 0, 11595, 29623, 105)) {
        if (!stem($5 + 12 | 0, 14076, 29623, 105)) {
         break label$8;
        }
        if (HEAP32[$5 + 12 >> 2] != ($4 | 0)) {
         break label$9;
        }
        break label$8;
       }
       if (HEAP32[$5 + 12 >> 2] == ($4 | 0)) {
        break label$8;
       }
      }
      if (stem($5 + 12 | 0, 17629, 12569, 0)) {
       break label$8;
      }
      if (stem($5 + 12 | 0, 17551, 13813, 0)) {
       break label$8;
      }
      if (stem($5 + 12 | 0, 11554, 12211, 0)) {
       break label$8;
      }
      label$11: {
       $4 = HEAP32[$5 + 12 >> 2];
       if (!doubleConsonant($4)) {
        break label$11;
       }
       $6 = HEAPU8[$4 | 0] - 108 | 0;
       if (1 << $6 & 16513 ? $6 >>> 0 <= 14 : 0) {
        break label$11;
       }
       HEAP32[$5 + 12 >> 2] = $4 + 1;
       break label$8;
      }
      if (!m_eq_1($4)) {
       break label$8;
      }
      if (!star_oh($4)) {
       break label$8;
      }
      $4 = $4 - 1 | 0;
      HEAP32[$5 + 12 >> 2] = $4;
      HEAP8[$4 | 0] = 101;
     }
     $4 = HEAP32[$5 + 12 >> 2];
     label$12: {
      if (HEAPU8[$4 | 0] != 121) {
       break label$12;
      }
      if (!hasVowel($4 + 1 | 0)) {
       break label$12;
      }
      HEAP8[$4 | 0] = 105;
     }
     label$13: {
      label$14: {
       switch (HEAP8[$4 + 1 | 0] - 97 | 0) {
       case 0:
        if (stem($5 + 12 | 0, 17601, 12569, 104)) {
         break label$13;
        }
        stem($5 + 12 | 0, 2864, 10274, 104);
        break label$13;

       case 2:
        if (stem($5 + 12 | 0, 13198, 14119, 104)) {
         break label$13;
        }
        stem($5 + 12 | 0, 17632, 14128, 104);
        break label$13;

       case 4:
        stem($5 + 12 | 0, 11544, 12211, 104);
        break label$13;

       case 6:
        stem($5 + 12 | 0, 11056, 11876, 104);
        break label$13;

       case 11:
        if (stem($5 + 12 | 0, 17550, 13813, 104)) {
         break label$13;
        }
        if (stem($5 + 12 | 0, 17728, 11332, 104)) {
         break label$13;
        }
        if (stem($5 + 12 | 0, 13155, 2745, 104)) {
         break label$13;
        }
        if (stem($5 + 12 | 0, 13449, 14212, 104)) {
         break label$13;
        }
        stem($5 + 12 | 0, 9491, 3436, 104);
        break label$13;

       case 14:
        if (stem($5 + 12 | 0, 11549, 12211, 104)) {
         break label$13;
        }
        if (stem($5 + 12 | 0, 17603, 12569, 104)) {
         break label$13;
        }
        stem($5 + 12 | 0, 17590, 12569, 104);
        break label$13;

       case 18:
        if (stem($5 + 12 | 0, 17745, 11332, 104)) {
         break label$13;
        }
        if (stem($5 + 12 | 0, 11563, 12322, 104)) {
         break label$13;
        }
        if (stem($5 + 12 | 0, 12023, 11040, 104)) {
         break label$13;
        }
        stem($5 + 12 | 0, 9483, 3436, 104);
        break label$13;

       case 19:
        break label$14;

       default:
        break label$13;
       }
      }
      if (stem($5 + 12 | 0, 17739, 11332, 104)) {
       break label$13;
      }
      if (stem($5 + 12 | 0, 11557, 12322, 104)) {
       break label$13;
      }
      stem($5 + 12 | 0, 17554, 13813, 104);
     }
     label$22: {
      label$23: {
       label$24: {
        label$25: {
         label$26: {
          $4 = HEAP8[HEAP32[$5 + 12 >> 2]];
          switch ($4 - 105 | 0) {
          case 1:
          case 2:
           break label$22;

          case 3:
           break label$24;

          case 0:
           break label$25;

          default:
           break label$26;
          }
         }
         if (($4 | 0) == 115) {
          break label$23;
         }
         if (($4 | 0) != 101) {
          break label$22;
         }
         if (stem($5 + 12 | 0, 11631, 17317, 104)) {
          break label$22;
         }
         if (stem($5 + 12 | 0, 17595, 29623, 104)) {
          break label$22;
         }
         stem($5 + 12 | 0, 17733, 11332, 104);
         break label$22;
        }
        stem($5 + 12 | 0, 11625, 17317, 104);
        break label$22;
       }
       if (stem($5 + 12 | 0, 11637, 17317, 104)) {
        break label$22;
       }
       stem($5 + 12 | 0, 12027, 29623, 104);
       break label$22;
      }
      stem($5 + 12 | 0, 10783, 29623, 104);
     }
     label$27: {
      label$28: {
       label$29: {
        label$30: {
         label$31: {
          label$32: {
           label$33: {
            label$34: {
             label$35: {
              label$36: {
               label$37: {
                label$38: {
                 $4 = HEAP32[$5 + 12 >> 2];
                 switch (HEAP8[$4 + 1 | 0] - 97 | 0) {
                 case 21:
                 case 25:
                  break label$28;

                 case 20:
                  break label$29;

                 case 19:
                  break label$30;

                 case 18:
                  break label$31;

                 case 14:
                  break label$32;

                 case 13:
                  break label$33;

                 case 11:
                  break label$34;

                 case 8:
                  break label$35;

                 case 4:
                  break label$36;

                 case 2:
                  break label$37;

                 case 0:
                  break label$38;

                 default:
                  break label$27;
                 }
                }
                if (HEAPU8[$4 | 0] != 108) {
                 break label$27;
                }
                $4 = $4 + 2 | 0;
                if (!m_gt_1($4)) {
                 break label$27;
                }
                HEAP32[$5 + 12 >> 2] = $4;
                break label$27;
               }
               if (HEAPU8[$4 | 0] != 101 | HEAPU8[$4 + 2 | 0] != 110) {
                break label$27;
               }
               label$39: {
                switch (HEAPU8[$4 + 3 | 0] - 97 | 0) {
                case 0:
                case 4:
                 break label$39;

                default:
                 break label$27;
                }
               }
               $4 = $4 + 4 | 0;
               if (!m_gt_1($4)) {
                break label$27;
               }
               HEAP32[$5 + 12 >> 2] = $4;
               break label$27;
              }
              if (HEAPU8[$4 | 0] != 114) {
               break label$27;
              }
              $4 = $4 + 2 | 0;
              if (!m_gt_1($4)) {
               break label$27;
              }
              HEAP32[$5 + 12 >> 2] = $4;
              break label$27;
             }
             if (HEAPU8[$4 | 0] != 99) {
              break label$27;
             }
             $4 = $4 + 2 | 0;
             if (!m_gt_1($4)) {
              break label$27;
             }
             HEAP32[$5 + 12 >> 2] = $4;
             break label$27;
            }
            if (HEAPU8[$4 | 0] != 101 | HEAPU8[$4 + 2 | 0] != 98 | (HEAPU8[$4 + 3 | 0] | 8) != 105) {
             break label$27;
            }
            $4 = $4 + 4 | 0;
            if (!m_gt_1($4)) {
             break label$27;
            }
            HEAP32[$5 + 12 >> 2] = $4;
            break label$27;
           }
           if (HEAPU8[$4 | 0] != 116) {
            break label$27;
           }
           label$40: {
            switch (HEAPU8[$4 + 2 | 0] - 97 | 0) {
            case 0:
             $4 = $4 + 3 | 0;
             if (!m_gt_1($4)) {
              break label$27;
             }
             HEAP32[$5 + 12 >> 2] = $4;
             break label$27;

            case 4:
             break label$40;

            default:
             break label$27;
            }
           }
           if (stem($5 + 12 | 0, 13244, 29623, 106)) {
            break label$27;
           }
           if (stem($5 + 12 | 0, 10971, 29623, 106)) {
            break label$27;
           }
           stem($5 + 12 | 0, 13157, 29623, 106);
           break label$27;
          }
          if (HEAPU8[$4 | 0] == 117) {
           $4 = $4 + 2 | 0;
           if (!m_gt_1($4)) {
            break label$27;
           }
           HEAP32[$5 + 12 >> 2] = $4;
           break label$27;
          }
          if ((HEAPU8[$4 + 3 | 0] - 115 & 255) >>> 0 > 1) {
           break label$27;
          }
          stem($5 + 12 | 0, 11591, 29623, 106);
          break label$27;
         }
         if (HEAPU8[$4 | 0] != 109 | HEAPU8[$4 + 2 | 0] != 105) {
          break label$27;
         }
         $4 = $4 + 3 | 0;
         if (!m_gt_1($4)) {
          break label$27;
         }
         HEAP32[$5 + 12 >> 2] = $4;
         break label$27;
        }
        if (stem($5 + 12 | 0, 17609, 29623, 106)) {
         break label$27;
        }
        stem($5 + 12 | 0, 11571, 29623, 106);
        break label$27;
       }
       if (HEAPU8[$4 | 0] != 115 | HEAPU8[$4 + 2 | 0] != 111) {
        break label$27;
       }
       $4 = $4 + 3 | 0;
       if (!m_gt_1($4)) {
        break label$27;
       }
       HEAP32[$5 + 12 >> 2] = $4;
       break label$27;
      }
      if (HEAPU8[$4 | 0] != 101 | HEAPU8[$4 + 2 | 0] != 105) {
       break label$27;
      }
      $4 = $4 + 3 | 0;
      if (!m_gt_1($4)) {
       break label$27;
      }
      HEAP32[$5 + 12 >> 2] = $4;
     }
     $4 = HEAP32[$5 + 12 >> 2];
     label$43: {
      if (HEAPU8[$4 | 0] != 101) {
       break label$43;
      }
      $6 = $4 + 1 | 0;
      if (!m_gt_1($6)) {
       if (!m_eq_1($6)) {
        break label$43;
       }
       if (star_oh($6)) {
        break label$43;
       }
      }
      HEAP32[$5 + 12 >> 2] = $6;
      $4 = $6;
     }
     if (!(!m_gt_1($4) | HEAPU8[$4 | 0] != 108 | HEAPU8[$4 + 1 | 0] != 108)) {
      $4 = $4 + 1 | 0;
      HEAP32[$5 + 12 >> 2] = $4;
     }
     $6 = strlen($4);
     HEAP32[$3 >> 2] = $6;
     $7 = 0;
     while (1) {
      HEAP8[$2 + $6 | 0] = $7;
      $7 = HEAPU8[$4 | 0];
      if (!$7) {
       break label$1;
      }
      $6 = $6 - 1 | 0;
      $4 = $4 + 1 | 0;
      continue;
     }
    }
    HEAP8[($5 + 16 | 0) + $7 | 0] = $6;
    $7 = $7 - 1 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  copy_stemmer($0, $1, $2, $3);
 }
 __stack_pointer = $5 + 48 | 0;
}

function parseModifier($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = Math_fround(0), $18 = 0, $19 = 0;
 $11 = __stack_pointer + -64 | 0;
 __stack_pointer = $11;
 label$1: {
  label$2: {
   label$3: {
    $4 = HEAPU8[HEAPU8[$1 | 0] + 29904 | 0];
    $6 = $4 - 43 | 0;
    if (!($6 >>> 0 > 14 | !(1 << $6 & 32741))) {
     $6 = 1;
     while (1) {
      $0 = $1 + $6 | 0;
      $4 = HEAPU8[$0 | 0];
      if (!(!$4 | ($4 | 0) == 58 | HEAP8[$4 + 30288 | 0] & 1)) {
       $6 = $6 + 1 | 0;
       continue;
      }
      break;
     }
     $12 = 1;
     if ((sqlite3AtoF($1, $11 + 56 | 0, $6, 1) | 0) <= 0) {
      break label$1;
     }
     if (HEAPU8[$0 | 0] != 58) {
      while (1) {
       $6 = $0;
       $0 = $6 + 1 | 0;
       if (HEAP8[HEAPU8[$6 | 0] + 30288 | 0] & 1) {
        continue;
       }
       break;
      }
      $4 = sqlite3Strlen30($6);
      if ($4 - 11 >>> 0 < 4294967288) {
       break label$1;
      }
      $0 = $4 - 1 | 0;
      $1 = HEAPU8[$6 + $0 | 0];
      computeJD($2);
      $1 = ($1 & 223) == 83 ? $0 : $4;
      $5 = HEAPF64[$11 + 56 >> 3];
      $19 = $5 < 0 ? -.5 : .5;
      $4 = 0;
      while (1) {
       if (($4 | 0) == 6) {
        break label$3;
       }
       label$10: {
        $0 = $4 << 4;
        if (HEAPU8[$0 + 50768 | 0] != ($1 | 0)) {
         break label$10;
        }
        if (sqlite3_strnicmp($0 + 50769 | 0, $6, $1)) {
         break label$10;
        }
        $17 = HEAPF32[$0 + 50776 >> 2];
        if (!(+Math_fround(-$17) < $5) | !(+$17 > $5)) {
         break label$10;
        }
        label$11: {
         label$12: {
          label$13: {
           switch ($4 - 4 | 0) {
           case 0:
            computeYMD_HMS($2);
            HEAP8[$2 + 40 | 0] = 0;
            if (Math_abs($5) < 2147483648) {
             $6 = ~~$5;
            } else {
             $6 = -2147483648;
            }
            $0 = $6 + HEAP32[$2 + 12 >> 2] | 0;
            $1 = ($0 + (($0 | 0) > 0 ? -1 : -12) | 0) / 12 | 0;
            HEAP32[$2 + 8 >> 2] = $1 + HEAP32[$2 + 8 >> 2];
            HEAP32[$2 + 12 >> 2] = Math_imul($1, -12) + $0;
            $5 = $5 - +($6 | 0);
            break label$12;

           case 1:
            break label$13;

           default:
            break label$11;
           }
          }
          computeYMD_HMS($2);
          HEAP8[$2 + 40 | 0] = 0;
          if (Math_abs($5) < 2147483648) {
           $6 = ~~$5;
          } else {
           $6 = -2147483648;
          }
          HEAP32[$2 + 8 >> 2] = $6 + HEAP32[$2 + 8 >> 2];
          $5 = $5 - +($6 | 0);
         }
         HEAPF64[$11 + 56 >> 3] = $5;
        }
        computeJD($2);
        $5 = $5 * 1e3 * +HEAPF32[($4 << 4) + 50780 >> 2] + $19;
        label$19: {
         if (Math_abs($5) < 0x8000000000000000) {
          $10 = Math_abs($5) >= 1 ? ~~($5 > 0 ? Math_min(Math_floor($5 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($5 - +(~~$5 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
          $13 = ~~$5 >>> 0;
          break label$19;
         }
         $10 = -2147483648;
         $13 = 0;
        }
        $14 = $10;
        $4 = $13;
        $10 = HEAP32[$2 >> 2];
        $9 = $10;
        $8 = $4 + $10 | 0;
        $3 = HEAP32[$2 + 4 >> 2];
        $10 = $3;
        $3 = $14;
        $7 = $10 + $3 | 0;
        $4 = $2;
        HEAP32[$4 >> 2] = $8;
        $7 = $8 >>> 0 < $9 >>> 0 ? $7 + 1 | 0 : $7;
        HEAP32[$4 + 4 >> 2] = $7;
        $12 = 0;
        break label$3;
       }
       $4 = $4 + 1 | 0;
       continue;
      }
     }
     $6 = HEAPU8[$1 | 0];
     memset($11 + 8 | 0, 0, 48);
     if (parseHhMmSs(($6 - 58 >>> 0 < 4294967286) + $1 | 0, $11 + 8 | 0)) {
      break label$1;
     }
     computeJD($11 + 8 | 0);
     $6 = HEAPU8[$1 | 0];
     $3 = $11;
     $7 = HEAP32[$3 + 8 >> 2];
     $13 = $7;
     $4 = HEAP32[$3 + 12 >> 2];
     $14 = $4;
     computeJD($2);
     clearYMD_HMS_TZ($2);
     $4 = HEAP32[$2 >> 2];
     $0 = $4;
     $7 = HEAP32[$2 + 4 >> 2];
     $1 = $7;
     $3 = $13;
     $10 = $3 - 432e5 | 0;
     $7 = $14;
     $8 = $3 >>> 0 < 432e5;
     $8 = $7 - $8 | 0;
     $3 = __wasm_i64_srem($10, $8, 864e5, 0);
     $9 = $3;
     $4 = 0 - $3 | 0;
     $8 = i64toi32_i32$HIGH_BITS;
     $3 = $8;
     $10 = $3 + (($9 | 0) != 0) | 0;
     $10 = 0 - $10 | 0;
     $3 = ($6 | 0) == 45;
     $9 = $3 ? $4 : $9;
     $14 = $9;
     $7 = $8;
     $8 = $3 ? $10 : $7;
     $9 = $8;
     $8 = $1;
     $4 = $9 + $8 | 0;
     $10 = $14;
     $3 = $0;
     $7 = $10 + $3 | 0;
     HEAP32[$2 >> 2] = $7;
     $4 = $7 >>> 0 < $10 >>> 0 ? $4 + 1 | 0 : $4;
     HEAP32[$2 + 4 >> 2] = $4;
     $12 = 0;
     break label$1;
    }
    $12 = 1;
    label$21: {
     switch ($4 - 115 | 0) {
     default:
      label$25: {
       switch ($4 - 106 | 0) {
       default:
        if (($4 | 0) != 97) {
         break label$1;
        }
        $6 = sqlite3_stricmp($1, 9497);
        if ($6 | ($3 | 0) > 1) {
         break label$1;
        }
        if (HEAPU8[$2 + 40 | 0] | !HEAPU8[$2 + 41 | 0]) {
         break label$2;
        }
        $5 = HEAPF64[$2 + 32 >> 3];
        if (!($5 >= -21086676e4) | !($5 <= 253402300799)) {
         break label$1;
        }
        clearYMD_HMS_TZ($2);
        HEAP16[$2 + 40 >> 1] = 1;
        $5 = $5 * 1e3 + 21086676e7 + .5;
        label$28: {
         if (Math_abs($5) < 0x8000000000000000) {
          $4 = Math_abs($5) >= 1 ? ~~($5 > 0 ? Math_min(Math_floor($5 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($5 - +(~~$5 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
          $13 = ~~$5 >>> 0;
          break label$28;
         }
         $4 = -2147483648;
         $13 = 0;
        }
        $3 = $2;
        HEAP32[$3 >> 2] = $13;
        HEAP32[$3 + 4 >> 2] = $4;
        $12 = 0;
        break label$1;

       case 0:
        $6 = sqlite3_stricmp($1, 1365);
        if ($6 | ($3 | 0) > 1 | !HEAPU8[$2 + 40 | 0]) {
         break label$1;
        }
        if (HEAPU8[$2 + 41 | 0]) {
         break label$2;
        }
        break label$1;

       case 1:
        break label$1;

       case 2:
        break label$25;
       }
      }
      if (sqlite3_stricmp($1, 13203)) {
       break label$1;
      }
      if (!sqlite3NotPureFunc($0)) {
       break label$1;
      }
      $12 = toLocaltime($2, $0);
      break label$1;

     case 2:
      if (!(sqlite3_stricmp($1, 11812) | !HEAPU8[$2 + 41 | 0])) {
       if (($3 | 0) > 1) {
        break label$1;
       }
       $5 = HEAPF64[$2 + 32 >> 3] * 1e3 + 21086676e7;
       if (!($5 >= 0) | !($5 < 4642690608e5)) {
        break label$1;
       }
       clearYMD_HMS_TZ($2);
       HEAP16[$2 + 40 >> 1] = 1;
       $5 = $5 + .5;
       label$31: {
        if (Math_abs($5) < 0x8000000000000000) {
         $4 = Math_abs($5) >= 1 ? ~~($5 > 0 ? Math_min(Math_floor($5 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($5 - +(~~$5 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
         $13 = ~~$5 >>> 0;
         break label$31;
        }
        $4 = -2147483648;
        $13 = 0;
       }
       $3 = $2;
       HEAP32[$3 >> 2] = $13;
       HEAP32[$3 + 4 >> 2] = $4;
       $12 = 0;
       break label$1;
      }
      if (sqlite3_stricmp($1, 16951)) {
       break label$1;
      }
      if (!sqlite3NotPureFunc($0)) {
       break label$1;
      }
      $12 = 0;
      if (HEAPU8[$2 + 45 | 0]) {
       break label$1;
      }
      computeJD($2);
      $1 = $11 + 16 | 0;
      $3 = HEAP32[$2 + 4 >> 2];
      $16 = $3;
      $4 = HEAP32[$2 >> 2];
      $15 = $4;
      $13 = $4;
      $14 = $3;
      $6 = 0;
      while (1) {
       memset($1, 0, 40);
       HEAP8[$11 + 48 | 0] = 1;
       $8 = $18;
       $4 = $8;
       $8 = $4 >> 31;
       $7 = $8;
       $4 = $13;
       $10 = $18;
       $9 = $4 - $10 | 0;
       $13 = $9;
       $3 = $14;
       $8 = $3;
       $3 = $7;
       $7 = $3 + ($4 >>> 0 < $10 >>> 0) | 0;
       $7 = $8 - $7 | 0;
       $14 = $7;
       $4 = $11;
       HEAP32[$4 + 8 >> 2] = $9;
       HEAP32[$4 + 12 >> 2] = $7;
       $12 = toLocaltime($4 + 8 | 0, $0);
       if ($12) {
        break label$1;
       }
       computeJD($11 + 8 | 0);
       $8 = $11;
       $7 = HEAP32[$8 + 8 >> 2];
       $8 = $7;
       $10 = $15;
       $3 = $7 - $10 | 0;
       $18 = $3;
       $4 = HEAP32[$11 + 12 >> 2];
       $7 = $16;
       $9 = $7 + ($10 >>> 0 > $8 >>> 0) | 0;
       if ($3) {
        $4 = $6 >>> 0 < 3;
        $6 = $6 + 1 | 0;
        if ($4) {
         continue;
        }
       }
       break;
      }
      ;
      $12 = 0;
      memset($2 + 8 | 0, 0, 40);
      HEAP8[$2 + 45 | 0] = 1;
      HEAP8[$2 + 40 | 0] = 1;
      HEAP32[$2 >> 2] = $13;
      $9 = $14;
      HEAP32[$2 + 4 >> 2] = $9;
      break label$1;

     case 4:
      if (sqlite3_strnicmp($1, 28948, 8)) {
       break label$1;
      }
      $6 = $1 + 8 | 0;
      if ((sqlite3AtoF($6, $11 + 56 | 0, sqlite3Strlen30($6), 1) | 0) <= 0) {
       break label$1;
      }
      $5 = HEAPF64[$11 + 56 >> 3];
      $4 = $5 < 7;
      $0 = !$4;
      if (Math_abs($5) < 2147483648) {
       $6 = ~~$5;
      } else {
       $6 = -2147483648;
      }
      if ($0 | ($6 | 0) < 0 | +($6 | 0) != $5) {
       break label$1;
      }
      computeYMD_HMS($2);
      $12 = 0;
      HEAP8[$2 + 40 | 0] = 0;
      HEAP8[$2 + 44 | 0] = 0;
      computeJD($2);
      $9 = HEAP32[$2 >> 2];
      $15 = $9;
      $8 = HEAP32[$2 + 4 >> 2];
      $16 = $8;
      $3 = $8;
      $4 = $15;
      $7 = $4 + 1296e5 | 0;
      $3 = $7 >>> 0 < 1296e5 ? $3 + 1 | 0 : $3;
      $4 = __wasm_i64_sdiv($7, $3, 864e5, 0);
      $3 = i64toi32_i32$HIGH_BITS;
      $4 = __wasm_i64_srem($4, $3, 7, 0);
      $3 = i64toi32_i32$HIGH_BITS;
      $7 = $4 >>> 0 < 7;
      $7 = $3 - $7 | 0;
      $0 = $7;
      $7 = $3;
      $9 = $4 - 7 | 0;
      $3 = $4;
      $4 = $6 >>> 0 < $4 >>> 0 & ($7 | 0) >= 0 | ($7 | 0) > 0;
      $8 = $4 ? $9 : $3;
      $3 = $0;
      $10 = $4 ? $3 : $7;
      $4 = $6;
      $3 = $8;
      $7 = $4 - $3 | 0;
      $8 = $10;
      $9 = $8 + ($3 >>> 0 > $4 >>> 0) | 0;
      $9 = 0 - $9 | 0;
      $4 = __wasm_i64_mul($7, $9, 864e5, 0);
      $3 = $15;
      $8 = $4 + $3 | 0;
      $4 = $16;
      $9 = i64toi32_i32$HIGH_BITS;
      $7 = $4 + $9 | 0;
      HEAP32[$2 >> 2] = $8;
      $7 = $3 >>> 0 > $8 >>> 0 ? $7 + 1 | 0 : $7;
      HEAP32[$2 + 4 >> 2] = $7;
      break label$3;

     case 1:
     case 3:
      break label$1;

     case 0:
      break label$21;
     }
    }
    if (sqlite3_strnicmp($1, 29043, 9) | !(HEAPU8[$2 + 43 | 0] ? 1 : HEAPU8[$2 + 40 | 0] | HEAPU8[$2 + 42 | 0])) {
     break label$1;
    }
    computeYMD($2);
    HEAP8[$2 + 43 | 0] = 1;
    HEAP8[$2 + 44 | 0] = 0;
    HEAP32[$2 + 32 >> 2] = 0;
    HEAP32[$2 + 36 >> 2] = 0;
    HEAP32[$2 + 20 >> 2] = 0;
    HEAP32[$2 + 24 >> 2] = 0;
    $12 = 0;
    HEAP16[$2 + 40 >> 1] = 0;
    $6 = $1 + 9 | 0;
    if (!sqlite3_stricmp($6, 11647)) {
     HEAP32[$2 + 16 >> 2] = 1;
     break label$1;
    }
    if (!sqlite3_stricmp($6, 9324)) {
     HEAP32[$2 + 12 >> 2] = 1;
     HEAP32[$2 + 16 >> 2] = 1;
     break label$1;
    }
    $12 = (sqlite3_stricmp($6, 1371) | 0) != 0;
    break label$1;
   }
   clearYMD_HMS_TZ($2);
   break label$1;
  }
  $12 = 0;
  HEAP8[$2 + 41 | 0] = 0;
 }
 __stack_pointer = $11 - -64 | 0;
 return $12;
}

function wherePathSolver($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 $12 = HEAPU8[$0 + 48 | 0];
 $14 = $12 >>> 0 < 2 ? 1 : ($12 | 0) == 2 ? 5 : 10;
 $27 = HEAP32[$0 >> 2];
 $32 = HEAP32[$27 >> 2];
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2];
  if (!$2) {
   break label$1;
  }
  $15 = HEAP32[$2 >> 2];
 }
 $3 = Math_imul(($12 << 2) + 32 | 0, $14) + $15 << 1;
 $5 = $3 >> 31;
 $20 = sqlite3DbMallocRawNN($32, $3, $5);
 if ($20) {
  $8 = $15 << 1;
  $2 = $14 << 5;
  $6 = $20 + $2 | 0;
  $3 = $6;
  HEAP32[$3 >> 2] = 0;
  HEAP32[$3 + 4 >> 2] = 0;
  HEAP32[$3 + 24 >> 2] = 0;
  HEAP32[$3 + 28 >> 2] = 0;
  HEAP32[$3 + 16 >> 2] = 0;
  HEAP32[$3 + 20 >> 2] = 0;
  HEAP32[$3 + 8 >> 2] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  $21 = $2 + $3 | 0;
  $2 = $14 << 1;
  $7 = $12 << 2;
  $4 = $20;
  while (1) {
   if (($2 | 0) > 0) {
    HEAP32[$4 + 24 >> 2] = $21;
    $4 = $4 + 32 | 0;
    $2 = $2 - 1 | 0;
    $21 = $7 + $21 | 0;
    continue;
   }
   break;
  }
  label$5: {
   if (!$15) {
    $21 = 0;
    break label$5;
   }
   memset($21, 0, $8);
  }
  $4 = ($14 << 5) + $20 | 0;
  $2 = HEAP32[$27 + 136 >> 2];
  HEAP16[$4 + 16 >> 1] = $2 >>> 0 < 48 ? $2 : 48;
  if ($15) {
   HEAP8[$4 + 22 | 0] = $12 ? -1 : $15;
  }
  $35 = $0 - -64 | 0;
  $2 = 1;
  $16 = $20;
  while (1) {
   label$9: {
    $24 = $6;
    if (($12 | 0) == ($25 | 0)) {
     break label$9;
    }
    $17 = 0;
    $36 = ($2 | 0) > 0 ? $2 : 0;
    $33 = $25 << 2;
    $7 = $24;
    $28 = 0;
    while (1) {
     if (($28 | 0) != ($36 | 0)) {
      $2 = $35;
      while (1) {
       $6 = HEAP32[$2 >> 2];
       if ($6) {
        $8 = HEAP8[$7 + 22 | 0];
        $3 = $11;
        HEAP32[$3 + 8 >> 2] = 0;
        HEAP32[$3 + 12 >> 2] = 0;
        $5 = HEAP32[$6 >> 2];
        $2 = $5;
        $3 = HEAP32[$6 + 4 >> 2];
        $4 = $3;
        $3 = HEAP32[$7 >> 2];
        $18 = $3;
        $5 = HEAP32[$7 + 4 >> 2];
        $26 = $5;
        $3 = $5 ^ -1;
        $5 = $3;
        $9 = $18;
        $10 = $9 ^ -1;
        $3 = $4;
        $9 = $5;
        $9 = $3 & $9;
        $5 = $2;
        $3 = $10 & $5;
        label$14: {
         if ($3 | $9) {
          break label$14;
         }
         $3 = HEAP32[$6 + 8 >> 2];
         $10 = $3;
         $3 = $26;
         $9 = HEAP32[$6 + 12 >> 2];
         $29 = $9;
         $3 = $3 & $9;
         $5 = $18;
         $9 = $5 & $10;
         if ($3 | $9) {
          break label$14;
         }
         $2 = HEAP16[$7 + 16 >> 1];
         if (($2 | 0) < 3 ? HEAPU8[$6 + 41 | 0] & 64 : 0) {
          break label$14;
         }
         $19 = sqlite3LogEstAdd(sqlite3LogEstAdd(HEAP16[$6 + 18 >> 1], HEAPU16[$6 + 20 >> 1] + $2 << 16 >> 16), HEAP16[$7 + 20 >> 1]);
         $2 = HEAPU16[$6 + 22 >> 1] + $2 | 0;
         label$15: {
          if (($8 | 0) < 0) {
           $8 = wherePathSatisfiesOrderBy($0, HEAP32[$0 + 8 >> 2], $7, HEAPU16[$0 + 44 >> 1], $25 & 65535, $6, $11 + 8 | 0);
           break label$15;
          }
          $3 = HEAP32[$7 + 12 >> 2];
          $9 = HEAP32[$7 + 8 >> 2];
          HEAP32[$11 + 8 >> 2] = $9;
          HEAP32[$11 + 12 >> 2] = $3;
         }
         $2 = $2 << 16;
         label$17: {
          if (!(($8 | 0) < 0 | ($8 | 0) >= ($15 | 0))) {
           $13 = ($8 << 1) + $21 | 0;
           $4 = HEAPU16[$13 >> 1];
           if (!$4) {
            $4 = whereSortingCost($0, $1, $15, $8);
            HEAP16[$13 >> 1] = $4;
           }
           $22 = sqlite3LogEstAdd($19, $4 << 16 >> 16) + 5 | 0;
           break label$17;
          }
          $22 = $19;
          $19 = $19 - 2 | 0;
         }
         $5 = $18;
         $18 = $5 | $10;
         $3 = $26;
         $9 = $29;
         $9 = $3 | $9;
         $26 = $9;
         $30 = $2 >> 16;
         $4 = 0;
         $13 = ($17 | 0) > 0 ? $17 : 0;
         $2 = $16;
         label$20: {
          label$21: {
           while (1) {
            if (($4 | 0) != ($13 | 0)) {
             $5 = HEAP32[$2 + 4 >> 2];
             $29 = $5;
             $3 = $18;
             $9 = HEAP32[$2 >> 2];
             $10 = $9;
             $5 = $26;
             $9 = $29;
             if (($3 | 0) == ($10 | 0) & ($5 | 0) == ($9 | 0) & (HEAPU8[$2 + 22 | 0] ^ $8) << 24 >> 24 >= 0) {
              break label$21;
             }
             $2 = $2 + 32 | 0;
             $4 = $4 + 1 | 0;
             continue;
            }
            break;
           }
           $2 = $17;
           $4 = ($14 | 0) > ($2 | 0);
           label$25: {
            if ($4) {
             break label$25;
            }
            if ($22 << 16 >> 16 > $23 << 16 >> 16) {
             break label$14;
            }
            $2 = $34;
            if (($22 & 65535) != ($23 & 65535)) {
             break label$25;
            }
            if ($19 << 16 >> 16 >= $31 << 16 >> 16) {
             break label$14;
            }
           }
           $2 = ($2 << 5) + $16 | 0;
           $17 = $4 + $17 | 0;
           break label$20;
          }
          $4 = HEAP16[$2 + 18 >> 1];
          if (($4 | 0) < $22 << 16 >> 16) {
           break label$14;
          }
          if (($4 & 65535) != ($22 & 65535)) {
           break label$20;
          }
          $4 = HEAP16[$2 + 16 >> 1];
          if (($30 | 0) > ($4 | 0)) {
           break label$14;
          }
          if (($4 | 0) != ($30 | 0)) {
           break label$20;
          }
          if (HEAP16[$2 + 20 >> 1] <= $19 << 16 >> 16) {
           break label$14;
          }
         }
         $3 = HEAP32[$6 + 8 >> 2];
         $10 = $3;
         $5 = HEAP32[$6 + 12 >> 2];
         $9 = $5;
         $3 = HEAP32[$7 + 4 >> 2];
         $5 = HEAP32[$7 >> 2];
         HEAP32[$2 >> 2] = $5 | $10;
         $5 = $3;
         $3 = $9;
         $5 = $5 | $3;
         HEAP32[$2 + 4 >> 2] = $5;
         $3 = $11;
         $5 = HEAP32[$3 + 8 >> 2];
         $18 = $5;
         $10 = HEAP32[$3 + 12 >> 2];
         HEAP8[$2 + 22 | 0] = $8;
         HEAP16[$2 + 20 >> 1] = $19;
         HEAP16[$2 + 18 >> 1] = $22;
         HEAP16[$2 + 16 >> 1] = $30;
         HEAP32[$2 + 8 >> 2] = $18;
         HEAP32[$2 + 12 >> 2] = $10;
         __memcpy(HEAP32[$2 + 24 >> 2], HEAP32[$7 + 24 >> 2], $33);
         HEAP32[HEAP32[$2 + 24 >> 2] + $33 >> 2] = $6;
         if (($14 | 0) > ($17 | 0)) {
          break label$14;
         }
         $31 = HEAP16[$16 + 16 >> 1];
         $23 = HEAP16[$16 + 18 >> 1];
         $4 = 1;
         $34 = 0;
         $2 = $16;
         while (1) {
          if (($4 | 0) == ($14 | 0)) {
           break label$14;
          }
          $8 = HEAP16[$2 + 50 >> 1];
          label$27: {
           label$28: {
            if (($8 | 0) > $23 << 16 >> 16) {
             $13 = HEAPU16[$2 + 52 >> 1];
             break label$28;
            }
            if (($8 & 65535) != ($23 & 65535)) {
             break label$27;
            }
            $13 = HEAP16[$2 + 52 >> 1];
            if (($13 | 0) <= $31 << 16 >> 16) {
             break label$27;
            }
           }
           $31 = $13;
           $23 = $8;
           $34 = $4;
          }
          $2 = $2 + 32 | 0;
          $4 = $4 + 1 | 0;
          continue;
         }
        }
        $2 = $6 + 56 | 0;
        continue;
       }
       break;
      }
      $7 = $7 + 32 | 0;
      $28 = $28 + 1 | 0;
      continue;
     }
     break;
    }
    $25 = $25 + 1 | 0;
    $2 = $17;
    $6 = $16;
    $16 = $24;
    continue;
   }
   break;
  }
  label$30: {
   if ($2) {
    $7 = ($2 | 0) > 1 ? $2 : 1;
    $4 = $24;
    $2 = 1;
    while (1) if (($2 | 0) == ($7 | 0)) {
     $8 = $0 + 768 | 0;
     $2 = 0;
     while (1) {
      if (($2 | 0) != ($12 | 0)) {
       $6 = Math_imul($2, 96) + $8 | 0;
       $7 = HEAP32[HEAP32[$4 + 24 >> 2] + ($2 << 2) >> 2];
       HEAP32[$6 + 80 >> 2] = $7;
       $7 = HEAPU8[$7 + 16 | 0];
       HEAP8[$6 + 60 | 0] = $7;
       HEAP32[$6 + 4 >> 2] = HEAP32[(HEAP32[$0 + 4 >> 2] + ($7 << 6) | 0) + 48 >> 2];
       $2 = $2 + 1 | 0;
       continue;
      }
      break;
     }
     label$36: {
      if (HEAPU8[$0 + 51 | 0] | (!$1 | (HEAPU16[$0 + 44 >> 1] & 384) != 256)) {
       break label$36;
      }
      $2 = $12 - 1 | 0;
      if ((wherePathSatisfiesOrderBy($0, HEAP32[$0 + 12 >> 2], $4, 128, $2 & 65535, HEAP32[HEAP32[$4 + 24 >> 2] + ($2 << 2) >> 2], $11 + 8 | 0) | 0) != HEAP32[HEAP32[$0 + 12 >> 2] >> 2]) {
       break label$36;
      }
      HEAP8[$0 + 51 | 0] = 2;
     }
     $8 = HEAPU8[$0 + 52 | 0];
     HEAP8[$0 + 52 | 0] = $8 & 251;
     $2 = HEAP32[$0 + 8 >> 2];
     label$37: {
      if (!$2) {
       break label$37;
      }
      $7 = HEAP8[$4 + 22 | 0];
      HEAP8[$0 + 49 | 0] = $7;
      $6 = HEAPU16[$0 + 44 >> 1];
      label$38: {
       if ($6 & 128) {
        if (HEAP32[$2 >> 2] != ($7 | 0)) {
         break label$38;
        }
        HEAP8[$0 + 51 | 0] = 2;
        break label$38;
       }
       $5 = HEAP32[$4 + 12 >> 2];
       $3 = $4;
       $10 = HEAP32[$3 + 8 >> 2];
       HEAP32[$0 + 80 >> 2] = $10;
       HEAP32[$0 + 84 >> 2] = $5;
       if (($7 | 0) <= 0) {
        HEAP8[$0 + 49 | 0] = 0;
        if (!$12) {
         break label$38;
        }
        $8 = $12 - 1 | 0;
        $13 = HEAP32[HEAP32[$4 + 24 >> 2] + ($8 << 2) >> 2];
        $7 = HEAP32[$13 + 40 >> 2];
        if ($7 & 4096 | ($7 & 260) == 260) {
         break label$38;
        }
        HEAP32[$11 + 8 >> 2] = 0;
        HEAP32[$11 + 12 >> 2] = 0;
        $1 = wherePathSatisfiesOrderBy($0, $2, $4, 2048, $8 & 65535, $13, $11 + 8 | 0);
        $2 = HEAP32[$0 + 8 >> 2];
        if (($1 | 0) == HEAP32[$2 >> 2]) {
         HEAP8[$0 + 52 | 0] = HEAPU8[$0 + 52 | 0] | 4;
         $3 = $11;
         $5 = HEAP32[$3 + 8 >> 2];
         $10 = HEAP32[$3 + 12 >> 2];
         HEAP32[$0 + 80 >> 2] = $5;
         HEAP32[$0 + 84 >> 2] = $10;
        }
        $6 = HEAPU16[$0 + 44 >> 1];
        break label$38;
       }
       if (!($6 & 3) | (!$12 | ($7 | 0) != 1)) {
        break label$38;
       }
       HEAP8[$0 + 52 | 0] = $8 | 4;
      }
      if (!($6 & 512) | (!$12 | HEAP32[$2 >> 2] != HEAP8[$0 + 49 | 0])) {
       break label$37;
      }
      $5 = $11;
      HEAP32[$5 + 8 >> 2] = 0;
      HEAP32[$5 + 12 >> 2] = 0;
      $6 = $12 - 1 | 0;
      if ((wherePathSatisfiesOrderBy($0, $2, $4, 0, $6 & 65535, HEAP32[HEAP32[$4 + 24 >> 2] + ($6 << 2) >> 2], $5 + 8 | 0) | 0) != HEAP32[HEAP32[$0 + 8 >> 2] >> 2]) {
       break label$37;
      }
      HEAP8[$0 + 52 | 0] = HEAPU8[$0 + 52 | 0] | 8;
      $3 = $11;
      $10 = HEAP32[$3 + 8 >> 2];
      $5 = HEAP32[$3 + 12 >> 2];
      HEAP32[$0 + 80 >> 2] = $10;
      HEAP32[$0 + 84 >> 2] = $5;
     }
     HEAP16[$0 + 54 >> 1] = HEAPU16[$4 + 16 >> 1];
     break label$30;
    } else {
     $6 = ($2 << 5) + $24 | 0;
     $4 = HEAP16[$4 + 18 >> 1] > HEAP16[$6 + 18 >> 1] ? $6 : $4;
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   sqlite3ErrorMsg($27, 9703, 0);
  }
  sqlite3DbFreeNN($32, $20);
 }
 __stack_pointer = $11 + 16 | 0;
}

function allocateBtreePage($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 HEAP32[$11 + 12 >> 2] = 0;
 $15 = btreePagecount($0);
 $13 = HEAP32[$0 + 12 >> 2];
 $16 = sqlite3Get4byte(HEAP32[$13 + 56 >> 2] + 36 | 0);
 label$1: {
  if ($15 >>> 0 <= $16 >>> 0) {
   $5 = sqlite3CorruptError(73125);
   break label$1;
  }
  label$3: {
   label$4: {
    if ($16) {
     label$6: {
      label$7: {
       switch ($4 - 1 | 0) {
       case 0:
        if ($3 >>> 0 > $15 >>> 0) {
         break label$6;
        }
        $5 = ptrmapGet($0, $3, $11 + 11 | 0, 0);
        if ($5) {
         break label$1;
        }
        $7 = HEAPU8[$11 + 11 | 0] == 2;
        break label$6;

       case 1:
        break label$7;

       default:
        break label$6;
       }
      }
      $7 = 1;
     }
     $5 = sqlite3PagerWrite(HEAP32[$13 + 72 >> 2]);
     if ($5) {
      break label$1;
     }
     sqlite3Put4byte(HEAP32[$13 + 56 >> 2] + 36 | 0, $16 - 1 | 0);
     while (1) {
      label$10: {
       label$11: {
        $12 = $10;
        label$12: {
         if ($10) {
          $8 = sqlite3Get4byte(HEAP32[$12 + 56 >> 2]);
          break label$12;
         }
         $8 = sqlite3Get4byte(HEAP32[$13 + 56 >> 2] + 32 | 0);
        }
        if ($15 >>> 0 >= $8 >>> 0) {
         $6 = $17 + 1 | 0;
         if ($17 >>> 0 <= $16 >>> 0) {
          break label$11;
         }
         $17 = $6;
        }
        $5 = sqlite3CorruptError(73181);
        break label$10;
       }
       $17 = $6;
       $5 = btreeGetUnusedPage($0, $8, $11 + 12 | 0, 0);
      }
      if ($5) {
       $10 = 0;
       HEAP32[$11 + 12 >> 2] = 0;
       break label$3;
      }
      label$16: {
       label$17: {
        label$18: {
         label$19: {
          label$20: {
           $10 = HEAP32[$11 + 12 >> 2];
           $14 = HEAP32[$10 + 56 >> 2];
           $19 = $14 + 4 | 0;
           $6 = sqlite3Get4byte($19);
           $18 = $7 & 255;
           label$21: {
            if (!($6 | $18)) {
             $5 = sqlite3PagerWrite(HEAP32[$10 + 72 >> 2]);
             if ($5) {
              break label$3;
             }
             HEAP32[$2 >> 2] = $8;
             $5 = HEAP32[$13 + 56 >> 2];
             $6 = HEAP32[$10 + 56 >> 2];
             $6 = HEAPU8[$6 | 0] | HEAPU8[$6 + 1 | 0] << 8 | (HEAPU8[$6 + 2 | 0] << 16 | HEAPU8[$6 + 3 | 0] << 24);
             HEAP8[$5 + 32 | 0] = $6;
             HEAP8[$5 + 33 | 0] = $6 >>> 8;
             HEAP8[$5 + 34 | 0] = $6 >>> 16;
             HEAP8[$5 + 35 | 0] = $6 >>> 24;
             HEAP32[$1 >> 2] = $10;
             break label$21;
            }
            if ((HEAP32[$0 + 40 >> 2] >>> 2 | 0) - 2 >>> 0 < $6 >>> 0) {
             $5 = sqlite3CorruptError(73210);
             break label$3;
            }
            if (!$18 | (($4 | 0) == 2 & $3 >>> 0 > $8 >>> 0 ? 0 : ($3 | 0) != ($8 | 0))) {
             break label$20;
            }
            HEAP32[$2 >> 2] = $8;
            HEAP32[$1 >> 2] = $10;
            $5 = sqlite3PagerWrite(HEAP32[$10 + 72 >> 2]);
            if ($5) {
             break label$3;
            }
            if (!$6) {
             if (!$12) {
              $5 = HEAP32[$13 + 56 >> 2];
              $6 = HEAP32[$10 + 56 >> 2];
              $6 = HEAPU8[$6 | 0] | HEAPU8[$6 + 1 | 0] << 8 | (HEAPU8[$6 + 2 | 0] << 16 | HEAPU8[$6 + 3 | 0] << 24);
              HEAP8[$5 + 32 | 0] = $6;
              HEAP8[$5 + 33 | 0] = $6 >>> 8;
              HEAP8[$5 + 34 | 0] = $6 >>> 16;
              HEAP8[$5 + 35 | 0] = $6 >>> 24;
              break label$21;
             }
             $5 = sqlite3PagerWrite(HEAP32[$12 + 72 >> 2]);
             if ($5) {
              break label$3;
             }
             $5 = HEAP32[$12 + 56 >> 2];
             $6 = HEAP32[$10 + 56 >> 2];
             $6 = HEAPU8[$6 | 0] | HEAPU8[$6 + 1 | 0] << 8 | (HEAPU8[$6 + 2 | 0] << 16 | HEAPU8[$6 + 3 | 0] << 24);
             HEAP8[$5 | 0] = $6;
             HEAP8[$5 + 1 | 0] = $6 >>> 8;
             HEAP8[$5 + 2 | 0] = $6 >>> 16;
             HEAP8[$5 + 3 | 0] = $6 >>> 24;
             break label$21;
            }
            $8 = sqlite3Get4byte(HEAP32[$10 + 56 >> 2] + 8 | 0);
            if ($15 >>> 0 < $8 >>> 0) {
             $5 = sqlite3CorruptError(73244);
             break label$3;
            }
            $5 = btreeGetUnusedPage($0, $8, $11 + 4 | 0, 0);
            if ($5) {
             break label$3;
            }
            $7 = HEAP32[$11 + 4 >> 2];
            $5 = sqlite3PagerWrite(HEAP32[$7 + 72 >> 2]);
            if ($5) {
             releasePage($7);
             break label$3;
            }
            $5 = HEAP32[$7 + 56 >> 2];
            $9 = HEAP32[$10 + 56 >> 2];
            $9 = HEAPU8[$9 | 0] | HEAPU8[$9 + 1 | 0] << 8 | (HEAPU8[$9 + 2 | 0] << 16 | HEAPU8[$9 + 3 | 0] << 24);
            HEAP8[$5 | 0] = $9;
            HEAP8[$5 + 1 | 0] = $9 >>> 8;
            HEAP8[$5 + 2 | 0] = $9 >>> 16;
            HEAP8[$5 + 3 | 0] = $9 >>> 24;
            $5 = $6 - 1 | 0;
            sqlite3Put4byte(HEAP32[$7 + 56 >> 2] + 4 | 0, $5);
            __memcpy(HEAP32[$7 + 56 >> 2] + 8 | 0, HEAP32[$10 + 56 >> 2] + 12 | 0, $5 << 2);
            releasePage($7);
            if (!$12) {
             sqlite3Put4byte(HEAP32[$13 + 56 >> 2] + 32 | 0, $8);
             break label$21;
            }
            $5 = sqlite3PagerWrite(HEAP32[$12 + 72 >> 2]);
            if ($5) {
             break label$3;
            }
            sqlite3Put4byte(HEAP32[$12 + 56 >> 2], $8);
           }
           $10 = 0;
           HEAP32[$11 + 12 >> 2] = 0;
           break label$19;
          }
          if (!$6) {
           break label$17;
          }
          label$29: {
           if (!$3) {
            $8 = 0;
            break label$29;
           }
           $8 = 0;
           $5 = 0;
           if (($4 | 0) == 2) {
            while (1) {
             if (($5 | 0) == ($6 | 0)) {
              break label$29;
             }
             if (sqlite3Get4byte((($5 << 2) + $14 | 0) + 8 | 0) >>> 0 <= $3 >>> 0) {
              $8 = $5;
              break label$29;
             } else {
              $5 = $5 + 1 | 0;
              continue;
             }
            }
           }
           $5 = 1;
           $7 = sqlite3AbsInt32(sqlite3Get4byte($14 + 8 | 0) - $3 | 0);
           while (1) {
            if (($5 | 0) == ($6 | 0)) {
             break label$29;
            }
            $9 = sqlite3AbsInt32(sqlite3Get4byte((($5 << 2) + $14 | 0) + 8 | 0) - $3 | 0);
            $20 = $9;
            $9 = ($7 | 0) > ($9 | 0);
            $7 = $9 ? $20 : $7;
            $8 = $9 ? $5 : $8;
            $5 = $5 + 1 | 0;
            continue;
           }
          }
          $9 = ($8 << 2) + $14 | 0;
          $7 = $9 + 8 | 0;
          $5 = sqlite3Get4byte($7);
          if (!($15 >>> 0 >= $5 >>> 0 & $5 >>> 0 > 1)) {
           $5 = sqlite3CorruptError(73309);
           break label$3;
          }
          if (!(($4 | 0) == 2 & $3 >>> 0 > $5 >>> 0 | (!$18 | ($3 | 0) == ($5 | 0)))) {
           $5 = 0;
           $7 = 1;
           break label$16;
          }
          HEAP32[$2 >> 2] = $5;
          $5 = sqlite3PagerWrite(HEAP32[$10 + 72 >> 2]);
          if ($5) {
           break label$3;
          }
          $5 = $6 - 1 | 0;
          if ($8 >>> 0 < $5 >>> 0) {
           $8 = $9;
           $6 = ($6 << 2) + $14 | 0;
           $6 = HEAPU8[$6 + 4 | 0] | HEAPU8[$6 + 5 | 0] << 8 | (HEAPU8[$6 + 6 | 0] << 16 | HEAPU8[$6 + 7 | 0] << 24);
           HEAP8[$8 + 8 | 0] = $6;
           HEAP8[$8 + 9 | 0] = $6 >>> 8;
           HEAP8[$8 + 10 | 0] = $6 >>> 16;
           HEAP8[$8 + 11 | 0] = $6 >>> 24;
          }
          sqlite3Put4byte($19, $5);
          $7 = 0;
          $5 = HEAP32[$2 >> 2];
          $5 = btreeGetUnusedPage($0, $5, $1, !btreeGetHasContent($0, $5));
          if ($5) {
           break label$16;
          }
          $5 = sqlite3PagerWrite(HEAP32[HEAP32[$1 >> 2] + 72 >> 2]);
          if ($5) {
           break label$18;
          }
         }
         $7 = 0;
         break label$17;
        }
        releasePage(HEAP32[$1 >> 2]);
        HEAP32[$1 >> 2] = 0;
        break label$16;
       }
       $5 = 0;
      }
      releasePage($12);
      $6 = $7 & 255;
      $7 = 1;
      if ($6) {
       continue;
      }
      break;
     }
     break label$4;
    }
    $7 = HEAPU8[$0 + 19 | 0];
    $5 = sqlite3PagerWrite(HEAP32[$13 + 72 >> 2]);
    if ($5) {
     break label$1;
    }
    $6 = HEAP32[$0 + 48 >> 2];
    $5 = $6 + 1 | 0;
    HEAP32[$0 + 48 >> 2] = $5;
    if ((HEAPU32[16232] / HEAPU32[$0 + 36 >> 2] | 0) == ($6 | 0)) {
     $5 = $6 + 2 | 0;
     HEAP32[$0 + 48 >> 2] = $5;
    }
    $7 = !$7;
    label$40: {
     if (!HEAPU8[$0 + 17 | 0]) {
      break label$40;
     }
     if ((ptrmapPageno($0, $5) | 0) != ($5 | 0)) {
      break label$40;
     }
     HEAP32[$11 >> 2] = 0;
     $5 = btreeGetUnusedPage($0, $5, $11, $7);
     if ($5) {
      break label$1;
     }
     $6 = HEAP32[$11 >> 2];
     $5 = sqlite3PagerWrite(HEAP32[$6 + 72 >> 2]);
     releasePage($6);
     if ($5) {
      break label$1;
     }
     $6 = HEAP32[$0 + 48 >> 2];
     $5 = $6 + 1 | 0;
     HEAP32[$0 + 48 >> 2] = $5;
     if ((HEAPU32[16232] / HEAPU32[$0 + 36 >> 2] | 0) != ($6 | 0)) {
      break label$40;
     }
     $5 = $6 + 2 | 0;
     HEAP32[$0 + 48 >> 2] = $5;
    }
    sqlite3Put4byte(HEAP32[HEAP32[$0 + 12 >> 2] + 56 >> 2] + 28 | 0, $5);
    $5 = HEAP32[$0 + 48 >> 2];
    HEAP32[$2 >> 2] = $5;
    $5 = btreeGetUnusedPage($0, $5, $1, $7);
    if ($5) {
     break label$1;
    }
    $5 = sqlite3PagerWrite(HEAP32[HEAP32[$1 >> 2] + 72 >> 2]);
    if (!$5) {
     $5 = 0;
     break label$3;
    }
    releasePage(HEAP32[$1 >> 2]);
    HEAP32[$1 >> 2] = 0;
   }
   $12 = 0;
  }
  releasePage($10);
  releasePage($12);
 }
 __stack_pointer = $11 + 16 | 0;
 return $5;
}

function pow($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 $3 = 1;
 wasm2js_scratch_store_f64(+$1);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $10 = wasm2js_scratch_load_i32(0) | 0;
 $7 = $2;
 label$1: {
  label$2: {
   $12 = $2;
   $5 = $2 & 2147483647;
   $8 = $10;
   label$3: {
    if (!($5 | $8)) {
     break label$3;
    }
    wasm2js_scratch_store_f64(+$0);
    $6 = wasm2js_scratch_load_i32(1) | 0;
    $2 = wasm2js_scratch_load_i32(0) | 0;
    $4 = $6;
    $11 = $4;
    if (!$2 & ($4 | 0) == 1072693248) {
     break label$3;
    }
    $14 = $4 & 2147483647;
    if (!(!($14 >>> 0 > 2146435072 | ($14 | 0) == 2146435072 & ($2 | 0) != 0 | $5 >>> 0 > 2146435072) & (!$8 | ($5 | 0) != 2146435072))) {
     return $0 + $1;
    }
    label$5: {
     label$6: {
      label$7: {
       $6 = 0;
       label$8: {
        if (($11 | 0) > 0 | ($11 | 0) >= 0) {
         break label$8;
        }
        $6 = 2;
        if ($5 >>> 0 > 1128267775) {
         break label$8;
        }
        $6 = 0;
        if ($5 >>> 0 < 1072693248) {
         break label$8;
        }
        $15 = $5 >>> 20 | 0;
        if ($5 >>> 0 < 1094713344) {
         break label$7;
        }
        $15 = 1075 - $15 | 0;
        $19 = $8 >>> $15 | 0;
        $6 = 0;
        if ($19 << $15 != ($8 | 0)) {
         break label$8;
        }
        $6 = 2 - ($19 & 1) | 0;
       }
       if (!$8) {
        break label$6;
       }
       break label$5;
      }
      $6 = 0;
      if ($8) {
       break label$5;
      }
      $8 = 1043 - $15 | 0;
      $15 = $5 >>> $8 | 0;
      $6 = 0;
      if ($15 << $8 != ($5 | 0)) {
       break label$6;
      }
      $6 = 2 - ($15 & 1) | 0;
     }
     if (($5 | 0) == 2146435072) {
      if (!($14 - 1072693248 | $2)) {
       break label$3;
      }
      if ($14 >>> 0 >= 1072693248) {
       return ($7 | 0) > 0 | ($7 | 0) >= 0 ? $1 : 0;
      }
      return ($7 | 0) > 0 | ($7 | 0) >= 0 ? 0 : -$1;
     }
     if (($5 | 0) == 1072693248) {
      $2 = $7;
      if (($2 | 0) > 0 | ($2 | 0) >= 0) {
       return $0;
      }
      return 1 / $0;
     }
     if (($12 | 0) == 1073741824) {
      return $0 * $0;
     }
     if (($12 | 0) != 1071644672 | ($11 | 0) < 0) {
      break label$5;
     }
     return sqrt($0);
    }
    $3 = fabs($0);
    label$14: {
     if ($2) {
      break label$14;
     }
     label$15: {
      if (($4 | 0) < 0) {
       if (($4 | 0) == -2147483648 | ($4 | 0) == -1074790400) {
        break label$15;
       }
       if (($4 | 0) != -1048576) {
        break label$14;
       }
       break label$15;
      }
      if (!$4 | ($4 | 0) == 2146435072) {
       break label$15;
      }
      if (($4 | 0) != 1072693248) {
       break label$14;
      }
     }
     $3 = ($7 | 0) < 0 ? 1 / $3 : $3;
     $2 = $11;
     if (($2 | 0) > 0 | ($2 | 0) >= 0) {
      break label$3;
     }
     if (!($14 - 1072693248 | $6)) {
      $1 = $3 - $3;
      return $1 / $1;
     }
     return ($6 | 0) == 1 ? -$3 : $3;
    }
    $16 = 1;
    $2 = $11;
    label$18: {
     if (($2 | 0) > 0 | ($2 | 0) >= 0) {
      break label$18;
     }
     label$19: {
      switch ($6 | 0) {
      case 0:
       $1 = $0 - $0;
       return $1 / $1;

      case 1:
       break label$19;

      default:
       break label$18;
      }
     }
     $16 = -1;
    }
    label$21: {
     if ($5 >>> 0 >= 1105199105) {
      if ($5 >>> 0 >= 1139802113) {
       if ($14 >>> 0 <= 1072693247) {
        return ($7 | 0) < 0 ? infinity : 0;
       }
       return ($12 | 0) > 0 ? infinity : 0;
      }
      if ($14 >>> 0 <= 1072693246) {
       return ($7 | 0) < 0 ? $16 * 1e300 * 1e300 : $16 * 1e-300 * 1e-300;
      }
      if ($14 >>> 0 >= 1072693249) {
       return ($12 | 0) > 0 ? $16 * 1e300 * 1e300 : $16 * 1e-300 * 1e-300;
      }
      $0 = $3 + -1;
      $3 = $0 * 1.9259629911266175e-8 + $0 * $0 * (.5 - $0 * ($0 * -.25 + .3333333333333333)) * -1.4426950408889634;
      $9 = $0 * 1.4426950216293335;
      wasm2js_scratch_store_f64(+($3 + $9));
      $2 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $0 = +wasm2js_scratch_load_f64();
      $3 = $3 - ($0 - $9);
      $11 = 0;
      break label$21;
     }
     $0 = $3 * 9007199254740992;
     $5 = $14 >>> 0 < 1048576;
     $3 = $5 ? $0 : $3;
     wasm2js_scratch_store_f64(+$0);
     $6 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     $12 = $5 ? $6 : $14;
     $8 = $12 & 1048575;
     $4 = $8 | 1072693248;
     $12 = ($12 >> 20) + ($5 ? -1076 : -1023) | 0;
     $5 = 0;
     label$27: {
      if ($8 >>> 0 < 235663) {
       break label$27;
      }
      if ($8 >>> 0 < 767610) {
       $5 = 1;
       break label$27;
      }
      $4 = $8 | 1071644672;
      $12 = $12 + 1 | 0;
     }
     $2 = 0;
     $11 = $2;
     $8 = $5 << 3;
     $23 = HEAPF64[$8 + 56432 >> 3];
     wasm2js_scratch_store_f64(+$3);
     wasm2js_scratch_load_i32(1) | 0;
     $11 = 0;
     $6 = wasm2js_scratch_load_i32(0) | 0;
     $2 = $6;
     wasm2js_scratch_store_i32(0, $11 | $2);
     $6 = $11;
     $2 = $4 | $6;
     wasm2js_scratch_store_i32(1, $2 | 0);
     $9 = +wasm2js_scratch_load_f64();
     $13 = HEAPF64[$8 + 56416 >> 3];
     $17 = $9 - $13;
     $20 = 1 / ($13 + $9);
     $3 = $17 * $20;
     wasm2js_scratch_store_f64(+$3);
     $2 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     wasm2js_scratch_store_i32(0, 0);
     wasm2js_scratch_store_i32(1, $2 | 0);
     $0 = +wasm2js_scratch_load_f64();
     $18 = $0;
     wasm2js_scratch_store_i32(0, 0);
     $2 = (($5 << 18) + ($4 >>> 1 | 0) | 0) + 537395200 | 0;
     wasm2js_scratch_store_i32(1, $2 | 0);
     $21 = $0 * $0;
     $22 = +wasm2js_scratch_load_f64();
     $9 = $20 * ($17 - $0 * $22 - $0 * ($9 - ($22 - $13)));
     $13 = $9 * ($3 + $0);
     $0 = $3 * $3;
     $13 = $13 + $0 * $0 * ($0 * ($0 * ($0 * ($0 * ($0 * .20697501780033842 + .23066074577556175) + .272728123808534) + .33333332981837743) + .4285714285785502) + .5999999999999946);
     wasm2js_scratch_store_f64(+($21 + 3 + $13));
     $6 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     wasm2js_scratch_store_i32(0, 0);
     $2 = $6;
     wasm2js_scratch_store_i32(1, $2 | 0);
     $0 = +wasm2js_scratch_load_f64();
     $17 = $18 * $0;
     $3 = $9 * $0 + $3 * ($13 - ($0 + -3 - $21));
     wasm2js_scratch_store_f64(+($17 + $3));
     $2 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     wasm2js_scratch_store_i32(0, 0);
     wasm2js_scratch_store_i32(1, $2 | 0);
     $0 = +wasm2js_scratch_load_f64();
     $3 = $23 + ($0 * -7.028461650952758e-9 + ($3 - ($0 - $17)) * .9617966939259756);
     $18 = $3;
     $9 = HEAPF64[$8 + 56448 >> 3];
     $13 = $0 * .9617967009544373;
     $0 = $9 + ($3 + $13);
     $3 = +($12 | 0);
     wasm2js_scratch_store_f64(+($0 + $3));
     $2 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     wasm2js_scratch_store_i32(0, 0);
     wasm2js_scratch_store_i32(1, $2 | 0);
     $0 = +wasm2js_scratch_load_f64();
     $3 = $18 - ($0 - $3 - $9 - $13);
     $11 = 0;
    }
    wasm2js_scratch_store_i32(0, 0);
    $2 = $7;
    wasm2js_scratch_store_i32(1, $2 | 0);
    $9 = +wasm2js_scratch_load_f64();
    $3 = ($1 - $9) * $0 + $3 * $1;
    $1 = $0 * $9;
    $0 = $3 + $1;
    wasm2js_scratch_store_f64(+$0);
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $10 = wasm2js_scratch_load_i32(0) | 0;
    $5 = $10;
    label$29: {
     $7 = $2;
     $4 = $2;
     if (($4 | 0) >= 1083179008) {
      if ($4 - 1083179008 | $5) {
       break label$2;
      }
      if (!($3 + 8008566259537294e-32 > $0 - $1)) {
       break label$29;
      }
      break label$2;
     }
     if (($4 & 2147482624) >>> 0 < 1083231232) {
      break label$29;
     }
     if ($4 + 1064252416 | $5) {
      break label$1;
     }
     if (!($0 - $1 >= $3)) {
      break label$29;
     }
     break label$1;
    }
    $5 = 0;
    $8 = $4 & 2147483647;
    if ($8 >>> 0 >= 1071644673) {
     $4 = (1048576 >>> ($8 >>> 20 | 0) - 1022 | 0) + $4 | 0;
     $8 = $4 >>> 20 & 2047;
     $5 = ($4 & 1048575 | 1048576) >>> 1043 - $8 | 0;
     $5 = ($7 | 0) < 0 ? 0 - $5 | 0 : $5;
     wasm2js_scratch_store_i32(0, 0);
     $11 = -1048576 >> $8 - 1023 & $4;
     $2 = $11;
     wasm2js_scratch_store_i32(1, $2 | 0);
     $1 = $1 - +wasm2js_scratch_load_f64();
     wasm2js_scratch_store_f64(+($3 + $1));
     $2 = wasm2js_scratch_load_i32(1) | 0;
     $10 = wasm2js_scratch_load_i32(0) | 0;
     $7 = $2;
    }
    wasm2js_scratch_store_i32(0, 0);
    wasm2js_scratch_store_i32(1, $7 | 0);
    $0 = +wasm2js_scratch_load_f64();
    $9 = $0 * .6931471824645996;
    $3 = ($3 - ($0 - $1)) * .6931471805599453 + $0 * -1.904654299957768e-9;
    $1 = $9 + $3;
    $0 = $1 * $1;
    $0 = $1 - $0 * ($0 * ($0 * ($0 * ($0 * 4.1381367970572385e-8 + -16533902205465252e-22) + 6613756321437934e-20) + -.0027777777777015593) + .16666666666666602);
    $18 = $1 * $0 / ($0 + -2);
    $0 = $3 - ($1 - $9);
    $1 = $1 - ($18 - ($1 * $0 + $0)) + 1;
    wasm2js_scratch_store_f64(+$1);
    $11 = wasm2js_scratch_load_i32(1) | 0;
    $10 = wasm2js_scratch_load_i32(0) | 0;
    $7 = $11;
    $4 = $7 + ($5 << 20) | 0;
    label$31: {
     if (($4 | 0) <= 1048575) {
      $1 = scalbn($1, $5);
      break label$31;
     }
     $2 = 0;
     $6 = 0;
     wasm2js_scratch_store_i32(0, $6 | $10);
     $11 = $2;
     $2 = $4 | $11;
     wasm2js_scratch_store_i32(1, $2 | 0);
     $1 = +wasm2js_scratch_load_f64();
    }
    $3 = $16 * $1;
   }
   return $3;
  }
  return $16 * 1e300 * 1e300;
 }
 return $16 * 1e-300 * 1e-300;
}

function __rem_pio2_large($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $8 = __stack_pointer - 560 | 0;
 __stack_pointer = $8;
 $6 = ($2 - 3 | 0) / 24 | 0;
 $18 = ($6 | 0) > 0 ? $6 : 0;
 $13 = Math_imul($18, -24) + $2 | 0;
 $12 = HEAP32[($4 << 2) + 58752 >> 2];
 $11 = $3 - 1 | 0;
 if (($12 + $11 | 0) >= 0) {
  $7 = $3 + $12 | 0;
  $2 = $18 - $11 | 0;
  $6 = 0;
  while (1) {
   $5 = ($2 | 0) < 0 ? 0 : +HEAP32[($2 << 2) + 58768 >> 2];
   HEAPF64[($8 + 320 | 0) + ($6 << 3) >> 3] = $5;
   $2 = $2 + 1 | 0;
   $6 = $6 + 1 | 0;
   if (($6 | 0) != ($7 | 0)) {
    continue;
   }
   break;
  }
 }
 $16 = $13 - 24 | 0;
 $7 = 0;
 $19 = ($12 | 0) > 0 ? $12 : 0;
 $10 = ($3 | 0) <= 0;
 while (1) {
  label$6: {
   if ($10) {
    $5 = 0;
    break label$6;
   }
   $6 = $7 + $11 | 0;
   $2 = 0;
   $5 = 0;
   while (1) {
    $5 = HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($6 - $2 << 3) >> 3] + $5;
    $2 = $2 + 1 | 0;
    if (($3 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
  }
  HEAPF64[($7 << 3) + $8 >> 3] = $5;
  $2 = ($7 | 0) == ($19 | 0);
  $7 = $7 + 1 | 0;
  if (!$2) {
   continue;
  }
  break;
 }
 $24 = 47 - $13 | 0;
 $22 = 48 - $13 | 0;
 $25 = $13 - 25 | 0;
 $7 = $12;
 label$9: {
  while (1) {
   $5 = HEAPF64[($7 << 3) + $8 >> 3];
   $2 = 0;
   $6 = $7;
   $17 = ($7 | 0) <= 0;
   if (!$17) {
    while (1) {
     $10 = $2 << 2;
     $10 = $10 + ($8 + 480 | 0) | 0;
     $9 = $5 * 5.960464477539063e-8;
     label$14: {
      if (Math_abs($9) < 2147483648) {
       $11 = ~~$9;
       break label$14;
      }
      $11 = -2147483648;
     }
     $9 = +($11 | 0);
     $5 = $9 * -16777216 + $5;
     label$13: {
      if (Math_abs($5) < 2147483648) {
       $11 = ~~$5;
       break label$13;
      }
      $11 = -2147483648;
     }
     HEAP32[$10 >> 2] = $11;
     $6 = $6 - 1 | 0;
     $5 = HEAPF64[($6 << 3) + $8 >> 3] + $9;
     $2 = $2 + 1 | 0;
     if (($7 | 0) != ($2 | 0)) {
      continue;
     }
     break;
    }
   }
   $5 = scalbn($5, $16);
   $5 = $5 + floor($5 * .125) * -8;
   label$17: {
    if (Math_abs($5) < 2147483648) {
     $15 = ~~$5;
     break label$17;
    }
    $15 = -2147483648;
   }
   $5 = $5 - +($15 | 0);
   label$19: {
    label$20: {
     label$21: {
      $23 = ($16 | 0) <= 0;
      label$22: {
       if (!$23) {
        $6 = ($7 << 2) + $8 | 0;
        $2 = $6 + 476 | 0;
        $11 = $2;
        $2 = HEAP32[$6 + 476 >> 2];
        $6 = $2;
        $2 = $2 >> $22;
        $6 = $6 - ($2 << $22) | 0;
        HEAP32[$11 >> 2] = $6;
        $15 = $2 + $15 | 0;
        $14 = $6 >> $24;
        break label$22;
       }
       if ($16) {
        break label$21;
       }
       $14 = HEAP32[(($7 << 2) + $8 | 0) + 476 >> 2] >> 23;
      }
      if (($14 | 0) <= 0) {
       break label$19;
      }
      break label$20;
     }
     $14 = 2;
     if ($5 >= .5) {
      break label$20;
     }
     $14 = 0;
     break label$19;
    }
    $2 = 0;
    $11 = 0;
    if (!$17) {
     while (1) {
      $17 = ($8 + 480 | 0) + ($2 << 2) | 0;
      $6 = HEAP32[$17 >> 2];
      $10 = 16777215;
      label$26: {
       label$27: {
        if ($11) {
         break label$27;
        }
        $10 = 16777216;
        if ($6) {
         break label$27;
        }
        $11 = 0;
        break label$26;
       }
       HEAP32[$17 >> 2] = $10 - $6;
       $11 = 1;
      }
      $2 = $2 + 1 | 0;
      if (($7 | 0) != ($2 | 0)) {
       continue;
      }
      break;
     }
    }
    label$28: {
     if ($23) {
      break label$28;
     }
     $2 = 8388607;
     label$29: {
      switch ($25 | 0) {
      case 1:
       $2 = 4194303;
       break;

      case 0:
       break label$29;

      default:
       break label$28;
      }
     }
     $10 = ($7 << 2) + $8 | 0;
     $6 = $10 + 476 | 0;
     HEAP32[$6 >> 2] = HEAP32[$10 + 476 >> 2] & $2;
    }
    $15 = $15 + 1 | 0;
    if (($14 | 0) != 2) {
     break label$19;
    }
    $5 = 1 - $5;
    $14 = 2;
    if (!$11) {
     break label$19;
    }
    $5 = $5 - scalbn(1, $16);
   }
   if ($5 == 0) {
    $2 = 1;
    $10 = 0;
    $6 = $7;
    label$32: {
     if (($7 | 0) <= ($12 | 0)) {
      break label$32;
     }
     while (1) {
      $6 = $6 - 1 | 0;
      $10 = HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2] | $10;
      if (($6 | 0) > ($12 | 0)) {
       continue;
      }
      break;
     }
     if (!$10) {
      break label$32;
     }
     $13 = $16;
     while (1) {
      $13 = $13 - 24 | 0;
      $7 = $7 - 1 | 0;
      if (!HEAP32[($8 + 480 | 0) + ($7 << 2) >> 2]) {
       continue;
      }
      break;
     }
     break label$9;
    }
    while (1) {
     $6 = $2;
     $2 = $2 + 1 | 0;
     if (!HEAP32[($8 + 480 | 0) + ($12 - $6 << 2) >> 2]) {
      continue;
     }
     break;
    }
    $10 = $7 + $6 | 0;
    while (1) {
     $6 = $3 + $7 | 0;
     $7 = $7 + 1 | 0;
     HEAPF64[($8 + 320 | 0) + ($6 << 3) >> 3] = HEAP32[($18 + $7 << 2) + 58768 >> 2];
     $2 = 0;
     $5 = 0;
     if (($3 | 0) > 0) {
      while (1) {
       $5 = HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($6 - $2 << 3) >> 3] + $5;
       $2 = $2 + 1 | 0;
       if (($3 | 0) != ($2 | 0)) {
        continue;
       }
       break;
      }
     }
     HEAPF64[($7 << 3) + $8 >> 3] = $5;
     if (($7 | 0) < ($10 | 0)) {
      continue;
     }
     break;
    }
    $7 = $10;
    continue;
   }
   break;
  }
  $5 = scalbn($5, 24 - $13 | 0);
  label$39: {
   if ($5 >= 16777216) {
    $3 = $7 << 2;
    $3 = $3 + ($8 + 480 | 0) | 0;
    $9 = $5 * 5.960464477539063e-8;
    label$42: {
     if (Math_abs($9) < 2147483648) {
      $2 = ~~$9;
      break label$42;
     }
     $2 = -2147483648;
    }
    $5 = +($2 | 0) * -16777216 + $5;
    label$41: {
     if (Math_abs($5) < 2147483648) {
      $6 = ~~$5;
      break label$41;
     }
     $6 = -2147483648;
    }
    HEAP32[$3 >> 2] = $6;
    $7 = $7 + 1 | 0;
    break label$39;
   }
   if (Math_abs($5) < 2147483648) {
    $2 = ~~$5;
   } else {
    $2 = -2147483648;
   }
   $13 = $16;
  }
  HEAP32[($8 + 480 | 0) + ($7 << 2) >> 2] = $2;
 }
 $5 = scalbn(1, $13);
 if (($7 | 0) >= 0) {
  $3 = $7;
  while (1) {
   $2 = $3;
   HEAPF64[($2 << 3) + $8 >> 3] = $5 * +HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2];
   $3 = $2 - 1 | 0;
   $5 = $5 * 5.960464477539063e-8;
   if ($2) {
    continue;
   }
   break;
  }
  $12 = 0;
  $6 = $7;
  while (1) {
   $0 = $12 >>> 0 > $19 >>> 0 ? $19 : $12;
   $2 = 0;
   $5 = 0;
   while (1) {
    $5 = HEAPF64[($2 << 3) + 61536 >> 3] * HEAPF64[($2 + $6 << 3) + $8 >> 3] + $5;
    $3 = ($0 | 0) != ($2 | 0);
    $2 = $2 + 1 | 0;
    if ($3) {
     continue;
    }
    break;
   }
   HEAPF64[($8 + 160 | 0) + ($7 - $6 << 3) >> 3] = $5;
   $6 = $6 - 1 | 0;
   $2 = ($7 | 0) != ($12 | 0);
   $12 = $12 + 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 label$51: {
  label$52: {
   label$53: {
    switch ($4 | 0) {
    case 3:
     label$56: {
      if (($7 | 0) <= 0) {
       break label$56;
      }
      $0 = ($8 + 160 | 0) + ($7 << 3) | 0;
      $5 = HEAPF64[$0 >> 3];
      $2 = $7;
      while (1) {
       $3 = $2 - 1 | 0;
       $6 = ($8 + 160 | 0) + ($3 << 3) | 0;
       $9 = HEAPF64[$6 >> 3];
       $20 = $9;
       $9 = $9 + $5;
       HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($20 - $9);
       HEAPF64[$6 >> 3] = $9;
       $6 = $2 >>> 0 > 1;
       $5 = $9;
       $2 = $3;
       if ($6) {
        continue;
       }
       break;
      }
      if (($7 | 0) < 2) {
       break label$56;
      }
      $5 = HEAPF64[$0 >> 3];
      $2 = $7;
      while (1) {
       $3 = $2 - 1 | 0;
       $6 = ($8 + 160 | 0) + ($3 << 3) | 0;
       $9 = HEAPF64[$6 >> 3];
       $20 = $9;
       $9 = $9 + $5;
       HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($20 - $9);
       HEAPF64[$6 >> 3] = $9;
       $6 = $2 >>> 0 > 2;
       $5 = $9;
       $2 = $3;
       if ($6) {
        continue;
       }
       break;
      }
      while (1) {
       $21 = $21 + HEAPF64[($8 + 160 | 0) + ($7 << 3) >> 3];
       $2 = ($7 | 0) > 2;
       $7 = $7 - 1 | 0;
       if ($2) {
        continue;
       }
       break;
      }
     }
     $5 = HEAPF64[$8 + 160 >> 3];
     if ($14) {
      break label$52;
     }
     HEAPF64[$1 >> 3] = $5;
     $5 = HEAPF64[$8 + 168 >> 3];
     HEAPF64[$1 + 16 >> 3] = $21;
     HEAPF64[$1 + 8 >> 3] = $5;
     break label$51;

    case 0:
     $5 = 0;
     if (($7 | 0) >= 0) {
      while (1) {
       $2 = $7;
       $7 = $2 - 1 | 0;
       $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
       if ($2) {
        continue;
       }
       break;
      }
     }
     HEAPF64[$1 >> 3] = $14 ? -$5 : $5;
     break label$51;

    case 1:
    case 2:
     break label$53;

    default:
     break label$51;
    }
   }
   $5 = 0;
   if (($7 | 0) >= 0) {
    $3 = $7;
    while (1) {
     $2 = $3;
     $3 = $2 - 1 | 0;
     $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
     if ($2) {
      continue;
     }
     break;
    }
   }
   HEAPF64[$1 >> 3] = $14 ? -$5 : $5;
   $5 = HEAPF64[$8 + 160 >> 3] - $5;
   $2 = 1;
   if (($7 | 0) > 0) {
    while (1) {
     $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
     $3 = ($2 | 0) != ($7 | 0);
     $2 = $2 + 1 | 0;
     if ($3) {
      continue;
     }
     break;
    }
   }
   HEAPF64[$1 + 8 >> 3] = $14 ? -$5 : $5;
   break label$51;
  }
  HEAPF64[$1 >> 3] = -$5;
  $5 = HEAPF64[$8 + 168 >> 3];
  HEAPF64[$1 + 16 >> 3] = -$21;
  HEAPF64[$1 + 8 >> 3] = -$5;
 }
 __stack_pointer = $8 + 560 | 0;
 return $15 & 7;
}

function whereLoopAddBtreeIndex($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0;
 $14 = __stack_pointer - 96 | 0;
 __stack_pointer = $14;
 $5 = 7;
 $19 = HEAP32[HEAP32[$0 >> 2] >> 2];
 $13 = HEAP32[$19 >> 2];
 label$1: {
  if (HEAPU8[$13 + 87 | 0]) {
   break label$1;
  }
  $4 = HEAP32[$0 + 8 >> 2];
  $24 = HEAPU16[$4 + 28 >> 1];
  $15 = HEAPU16[$4 + 22 >> 1];
  $8 = HEAP32[$4 >> 2];
  $25 = $8;
  $7 = HEAP32[$4 + 4 >> 2];
  $26 = $7;
  $27 = HEAPU16[$4 + 46 >> 1];
  $28 = HEAPU16[$4 + 26 >> 1];
  $16 = HEAPU16[$4 + 44 >> 1];
  $10 = HEAPU16[$4 + 24 >> 1];
  $17 = HEAP32[$4 + 40 >> 2];
  $6 = $17 & 32 ? 24 : 447;
  $6 = whereScanInit($14, HEAP32[$0 + 4 >> 2], HEAP32[$1 + 40 >> 2], $10, (HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) & 4 ? $6 & 387 : $6, $2);
  HEAP16[$4 + 18 >> 1] = 0;
  $29 = $16 + 1 | 0;
  $30 = HEAP16[HEAP32[$2 + 8 >> 2] >> 1];
  $20 = estLog($30);
  $31 = $20 & 65535;
  $5 = 0;
  while (1) {
   label$3: {
    if (!$6 | $5) {
     break label$3;
    }
    $9 = HEAPU16[$6 + 12 >> 1];
    label$4: {
     if (!(HEAPU8[$6 + 10 | 0] & 128 ? 0 : ($9 | 0) != 256)) {
      $5 = 0;
      if (indexColumnNotNull($2, $10)) {
       break label$4;
      }
     }
     $5 = 0;
     $7 = HEAP32[$4 + 8 >> 2];
     $21 = $7;
     $8 = HEAP32[$4 + 12 >> 2];
     $22 = $8;
     $8 = HEAP32[$6 + 32 >> 2];
     $11 = $8;
     $7 = HEAP32[$6 + 36 >> 2];
     $8 = $7;
     $7 = $22;
     $8 = $8 & $7;
     $7 = $11 & $21;
     if ($8 | $7) {
      break label$4;
     }
     $8 = $6 + 11 | 0;
     if (HEAP8[$8 | 0] & 1 & ($9 | 0) == 16) {
      break label$4;
     }
     if (HEAPU8[$1 + 36 | 0] & 88) {
      $7 = HEAP32[$6 >> 2];
      if (!(HEAPU8[$7 + 4 | 0] & 3) | HEAP32[$7 + 36 >> 2] != HEAP32[$1 + 40 >> 2]) {
       break label$4;
      }
     }
     label$8: {
      if (HEAPU8[$2 + 54 | 0]) {
       $5 = 2;
       if ((HEAPU16[$2 + 50 >> 1] - 1 | 0) == ($10 | 0)) {
        break label$8;
       }
      }
      $5 = 1;
     }
     HEAP8[$0 + 16 | 0] = $5 | HEAPU8[$0 + 16 | 0];
     HEAP16[$4 + 44 >> 1] = $16;
     HEAP16[$4 + 28 >> 1] = $24;
     HEAP16[$4 + 26 >> 1] = $28;
     HEAP16[$4 + 24 >> 1] = $10;
     HEAP32[$4 + 40 >> 2] = $17;
     $5 = 0;
     if (whereLoopResize($13, $4, $29)) {
      break label$3;
     }
     $7 = HEAPU16[$4 + 44 >> 1];
     $12 = $7 + 1 | 0;
     HEAP16[$4 + 44 >> 1] = $12;
     HEAP32[HEAP32[$4 + 52 >> 2] + ($7 << 2) >> 2] = $6;
     $7 = HEAP32[$6 + 32 >> 2];
     $21 = $7 | $25;
     $8 = HEAP32[$6 + 36 >> 2];
     $7 = $26;
     $7 = $8 | $7;
     $22 = $7;
     $7 = HEAP32[$4 + 8 >> 2];
     $8 = $7;
     $11 = HEAP32[$4 + 12 >> 2];
     $7 = $11 ^ -1;
     $11 = $21;
     $8 = $11 & ($8 ^ -1);
     HEAP32[$4 >> 2] = $8;
     $8 = $7;
     $7 = $22;
     $8 = $8 & $7;
     HEAP32[$4 + 4 >> 2] = $8;
     label$10: {
      if ($9 & 1) {
       $11 = HEAP32[$6 >> 2];
       label$12: {
        if (HEAPU8[$11 + 5 | 0] & 16) {
         $5 = $12 & 65535;
         $12 = (($5 | 0) > 1 ? $5 : 1) - 1 | 0;
         $5 = 0;
         $7 = 46;
         while (1) {
          if (($5 | 0) == ($12 | 0)) {
           break label$12;
          }
          $8 = HEAP32[HEAP32[$4 + 52 >> 2] + ($5 << 2) >> 2];
          if ($8) {
           $7 = HEAP32[$8 >> 2] == ($11 | 0) ? 0 : $7;
          }
          $5 = $5 + 1 | 0;
          continue;
         }
        }
        $7 = 0;
        $5 = HEAP32[$11 + 20 >> 2];
        if (!$5) {
         break label$12;
        }
        $5 = HEAP32[$5 >> 2];
        if (!$5) {
         break label$12;
        }
        $8 = $5 >> 31;
        $7 = sqlite3LogEst($5, $8) & 65535;
       }
       label$16: {
        if (!(HEAPU8[$2 + 55 | 0] & 128) | ($20 | 0) < 10) {
         break label$16;
        }
        if (!(((HEAPU16[HEAP32[$2 + 8 >> 2] + ($10 << 1) >> 1] - ($7 + $31 | 0) | 0) + estLog($7 << 16 >> 16) | 0) + 10 & 32768)) {
         break label$16;
        }
        $5 = 0;
        if (HEAPU8[$13 + 82 | 0] & 2 | ($3 | 0) > 1) {
         break label$4;
        }
        HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 40 >> 2] | 1048576;
       }
       $5 = HEAP32[$4 + 40 >> 2] | 4;
       HEAP32[$4 + 40 >> 2] = $5;
       break label$10;
      }
      if ($9 & 130) {
       $8 = HEAP16[HEAP32[$2 + 4 >> 2] + ($10 << 1) >> 1];
       $12 = HEAP32[$4 + 40 >> 2];
       $5 = $12 | 1;
       HEAP32[$4 + 40 >> 2] = $5;
       $7 = 4097;
       label$18: {
        label$19: {
         if (($8 | 0) == -1) {
          break label$19;
         }
         if (($8 | 0) < 0 | $3) {
          break label$18;
         }
         $8 = HEAPU16[$2 + 50 >> 1];
         if (($8 - 1 | 0) != ($10 | 0)) {
          break label$18;
         }
         if (HEAPU8[$2 + 55 | 0] & 8 | !(!HEAPU8[$2 + 54 | 0] | ($8 | 0) != 1) & ($9 | 0) == 2) {
          break label$19;
         }
         $7 = 65537;
        }
        $5 = $7 | $12;
        HEAP32[$4 + 40 >> 2] = $5;
       }
       $7 = 0;
       if (HEAPU8[$14 + 25 | 0] < 2) {
        break label$10;
       }
       $5 = $5 | 2097152;
       HEAP32[$4 + 40 >> 2] = $5;
       break label$10;
      }
      if ($9 & 256) {
       $5 = HEAP32[$4 + 40 >> 2] | 8;
       HEAP32[$4 + 40 >> 2] = $5;
       $7 = 0;
       break label$10;
      }
      $7 = HEAP32[$4 + 40 >> 2];
      if ($9 & 36) {
       HEAP32[$4 + 40 >> 2] = $7 | 34;
       HEAP16[$4 + 26 >> 1] = whereRangeVectorLen($19, HEAP32[$1 + 40 >> 2], $2, $10, $6);
       if (!(HEAP8[$6 + 11 | 0] & 1)) {
        $5 = HEAP32[$4 + 40 >> 2];
        $7 = 0;
        $23 = $6;
        $18 = 0;
        break label$10;
       }
       if (whereLoopResize($13, $4, HEAPU16[$4 + 44 >> 1] + 1 | 0)) {
        break label$3;
       }
       $5 = HEAPU16[$4 + 44 >> 1];
       HEAP16[$4 + 44 >> 1] = $5 + 1;
       $18 = $6 + 48 | 0;
       HEAP32[HEAP32[$4 + 52 >> 2] + ($5 << 2) >> 2] = $18;
       HEAP16[$4 + 28 >> 1] = 1;
       $5 = HEAP32[$4 + 40 >> 2] | 16;
       HEAP32[$4 + 40 >> 2] = $5;
       $7 = 0;
       $23 = $6;
       break label$10;
      }
      HEAP32[$4 + 40 >> 2] = $7 | 18;
      HEAP16[$4 + 28 >> 1] = whereRangeVectorLen($19, HEAP32[$1 + 40 >> 2], $2, $10, $6);
      $7 = 0;
      $5 = HEAP32[$4 + 40 >> 2];
      $23 = $5 & 32 ? HEAP32[(HEAP32[$4 + 52 >> 2] + (HEAPU16[$4 + 44 >> 1] << 2) | 0) - 8 >> 2] : 0;
      $18 = $6;
     }
     label$26: {
      if ($5 & 2) {
       whereRangeScanEst($23, $18, $4);
       $5 = HEAP32[$4 + 40 >> 2];
       $6 = HEAPU16[$4 + 22 >> 1];
       break label$26;
      }
      $8 = HEAPU16[$4 + 24 >> 1] + 1 | 0;
      HEAP16[$4 + 24 >> 1] = $8;
      $6 = HEAP16[$6 + 8 >> 1];
      if (!(HEAP16[HEAP32[$2 + 4 >> 2] + ($10 << 1) >> 1] < 0 | ($6 | 0) > 0)) {
       $6 = HEAPU16[$4 + 22 >> 1] + ($6 - $7 | 0) | 0;
       break label$26;
      }
      $6 = HEAP32[$2 + 8 >> 2] + (($8 & 65535) << 1) | 0;
      $6 = HEAPU16[$4 + 22 >> 1] + (HEAPU16[$6 >> 1] - HEAPU16[$6 - 2 >> 1] | 0) | 0;
      $6 = $9 & 256 ? $6 + 10 | 0 : $6;
     }
     $9 = sqlite3LogEstAdd($20, ($6 + ((Math_imul(HEAP16[$2 + 48 >> 1], 15) | 0) / HEAP16[HEAP32[$1 + 16 >> 2] + 40 >> 1] | 0) << 16) + 65536 >> 16);
     if (!($5 & 320)) {
      $9 = sqlite3LogEstAdd($9, ($6 << 16) - -1048576 >> 16);
     }
     $8 = $3 + $7 | 0;
     HEAP16[$4 + 22 >> 1] = $8 + $6;
     HEAP16[$4 + 20 >> 1] = $9 + $8;
     whereLoopOutputAdjust(HEAP32[$0 + 4 >> 2], $4, $30);
     $5 = whereLoopInsert($0, $4);
     $9 = HEAP32[$4 + 40 >> 2];
     HEAP16[$4 + 22 >> 1] = $9 & 2 ? $15 : $6;
     label$30: {
      if ($9 & 16) {
       break label$30;
      }
      $6 = HEAPU16[$4 + 24 >> 1];
      if ($6 >>> 0 >= HEAPU16[$2 + 52 >> 1] | ((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) & 3) == 2 & HEAPU16[$2 + 50 >> 1] <= $6 >>> 0) {
       break label$30;
      }
      whereLoopAddBtreeIndex($0, $1, $2, $8 << 16 >> 16);
     }
     HEAP16[$4 + 22 >> 1] = $15;
    }
    $6 = whereScanNext($14);
    continue;
   }
   break;
  }
  HEAP16[$4 + 46 >> 1] = $27;
  HEAP16[$4 + 28 >> 1] = $24;
  HEAP16[$4 + 26 >> 1] = $28;
  HEAP16[$4 + 24 >> 1] = $10;
  HEAP32[$4 >> 2] = $25;
  $8 = $26;
  HEAP32[$4 + 4 >> 2] = $8;
  HEAP32[$4 + 40 >> 2] = $17;
  HEAP16[$4 + 44 >> 1] = $16;
  HEAP16[$4 + 22 >> 1] = $15;
  if (($10 | 0) != ($27 | 0)) {
   break label$1;
  }
  $6 = $10 + 1 | 0;
  if (($10 | 0) != ($16 | 0) | $6 >>> 0 >= HEAPU16[$2 + 50 >> 1] | ((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) & 192) != 128 | (HEAPU8[$13 + 81 | 0] & 64 | HEAP16[HEAP32[$2 + 8 >> 2] + ($6 << 1) >> 1] < 42)) {
   break label$1;
  }
  $5 = whereLoopResize($13, $4, $29);
  if ($5) {
   break label$1;
  }
  HEAP16[$4 + 24 >> 1] = HEAPU16[$4 + 24 >> 1] + 1;
  HEAP16[$4 + 46 >> 1] = HEAPU16[$4 + 46 >> 1] + 1;
  $9 = HEAPU16[$4 + 44 >> 1];
  HEAP16[$4 + 44 >> 1] = $9 + 1;
  $5 = 0;
  HEAP32[HEAP32[$4 + 52 >> 2] + ($9 << 2) >> 2] = 0;
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 40 >> 2] | 32768;
  $9 = HEAP32[$2 + 8 >> 2];
  $6 = HEAPU16[$9 + ($10 << 1) >> 1] - HEAPU16[($6 << 1) + $9 >> 1] | 0;
  HEAP16[$4 + 22 >> 1] = HEAPU16[$4 + 22 >> 1] - $6;
  whereLoopAddBtreeIndex($0, $1, $2, ($3 + $6 << 16) + 327680 >> 16);
  HEAP16[$4 + 46 >> 1] = $10;
  HEAP16[$4 + 24 >> 1] = $10;
  HEAP16[$4 + 22 >> 1] = $15;
  HEAP32[$4 + 40 >> 2] = $17;
 }
 __stack_pointer = $14 + 96 | 0;
 return $5;
}

function sqlite3DeleteFrom($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 60 >> 2] = 0;
 HEAP32[$4 + 56 >> 2] = 0;
 HEAP32[$4 + 48 >> 2] = 0;
 HEAP32[$4 + 52 >> 2] = 0;
 $17 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $5 = sqlite3SrcListLookup($0, $1);
  if (!$5) {
   break label$1;
  }
  $23 = sqlite3TriggersExist($0, $5, 128, 0, 0);
  $14 = HEAPU8[$5 + 43 | 0];
  $12 = 1;
  if (!$23) {
   $12 = (sqlite3FkRequired($0, $5, 0, 0) | 0) != 0;
  }
  if (sqlite3ViewGetColumnNames($0, $5)) {
   break label$1;
  }
  if (sqlite3IsReadOnly($0, $5, ($23 | 0) != 0)) {
   break label$1;
  }
  $8 = HEAP32[$5 >> 2];
  $10 = HEAP32[$17 + 16 >> 2];
  $9 = sqlite3SchemaToIndex($17, HEAP32[$5 + 60 >> 2]);
  $10 = sqlite3AuthCheck($0, 9, $8, 0, HEAP32[$10 + ($9 << 4) >> 2]);
  if (($10 | 0) == 1) {
   break label$1;
  }
  $13 = HEAP32[$0 + 40 >> 2];
  $15 = $13 + 1 | 0;
  HEAP32[$0 + 40 >> 2] = $15;
  HEAP32[$1 + 48 >> 2] = $13;
  $8 = $15;
  $11 = $5 + 8 | 0;
  $6 = $11;
  while (1) {
   $6 = HEAP32[$6 >> 2];
   if ($6) {
    $8 = $8 + 1 | 0;
    HEAP32[$0 + 40 >> 2] = $8;
    $7 = $7 + 1 | 0;
    $6 = $6 + 20 | 0;
    continue;
   }
   break;
  }
  if (($14 & 255) == 2) {
   sqlite3AuthContextPush($0, $4 + 48 | 0, HEAP32[$5 >> 2]);
  }
  $6 = 0;
  $3 = sqlite3GetVdbe($0);
  if (!$3) {
   break label$1;
  }
  if (!HEAPU8[$0 + 18 | 0]) {
   sqlite3VdbeCountChanges($3);
  }
  sqlite3BeginWriteOperation($0, $12, $9);
  if (($14 & 255) == 2) {
   sqlite3MaterializeView($0, $5, $2, $13);
   HEAP32[$4 + 60 >> 2] = $13;
   HEAP32[$4 + 56 >> 2] = $13;
  }
  HEAP32[$4 + 40 >> 2] = 0;
  HEAP32[$4 + 44 >> 2] = 0;
  HEAP32[$4 + 32 >> 2] = 0;
  HEAP32[$4 + 36 >> 2] = 0;
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 28 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $0;
  if (sqlite3ResolveExprNames($4 + 16 | 0, $2)) {
   break label$1;
  }
  if (!(HEAPU8[$0 + 18 | 0] | !(HEAP8[$17 + 36 | 0] & 1) | (HEAP32[$0 + 120 >> 2] | HEAPU8[$0 + 149 | 0]))) {
   $16 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $16;
   sqlite3VdbeAddOp2($3, 71, 0, $16);
  }
  label$9: {
   if (!($2 | $10 | $12 | HEAPU8[$5 + 43 | 0] == 1)) {
    sqlite3TableLock($0, $9, HEAP32[$5 + 20 >> 2], 1, HEAP32[$5 >> 2]);
    if (!(HEAPU8[$5 + 28 | 0] & 128)) {
     sqlite3VdbeAddOp4($3, 145, HEAP32[$5 + 20 >> 2], $9, $16 ? $16 : -1, HEAP32[$5 >> 2], -1);
    }
    $7 = $16 ? $16 : -1;
    while (1) {
     $6 = HEAP32[$11 >> 2];
     if ($6) {
      sqlite3VdbeAddOp2($3, 145, HEAP32[$6 + 44 >> 2], $9);
      if (!(!(HEAPU8[$5 + 28 | 0] & 128) | ((HEAPU8[$6 + 55 | 0] | HEAPU8[$6 + 56 | 0] << 8) & 3) != 2)) {
       sqlite3VdbeChangeP3($3, -1, $7);
      }
      $11 = $6 + 20 | 0;
      continue;
     } else {
      $8 = 0;
      break label$9;
     }
    }
   }
   $8 = HEAPU8[$4 + 40 | 0] & 64 ? 20 : $12 ? 20 : 28;
   label$16: {
    if (!(HEAPU8[$5 + 28 | 0] & 128)) {
     $10 = 1;
     $22 = HEAP32[$0 + 44 >> 2] + 1 | 0;
     HEAP32[$0 + 44 >> 2] = $22;
     $12 = 0;
     sqlite3VdbeAddOp2($3, 75, 0, $22);
     $11 = 0;
     break label$16;
    }
    $6 = HEAP32[$0 + 44 >> 2];
    $12 = sqlite3PrimaryKeyIndex($5);
    $10 = HEAP16[$12 + 50 >> 1];
    HEAP32[$0 + 44 >> 2] = $6 + $10;
    $18 = HEAP32[$0 + 40 >> 2];
    HEAP32[$0 + 40 >> 2] = $18 + 1;
    $19 = sqlite3VdbeAddOp2($3, 118, $18, $10);
    sqlite3VdbeSetP4KeyInfo($0, $12);
    $11 = $6 + 1 | 0;
   }
   $6 = 0;
   $15 = sqlite3WhereBegin($0, $1, $2, 0, 0, 0, $8, $15);
   if (!$15) {
    break label$1;
   }
   $20 = sqlite3WhereOkOnePass($15, $4 + 8 | 0);
   if (($20 | 0) != 1) {
    sqlite3MultiWrite($0);
   }
   if (sqlite3WhereUsesDeferredSeek($15)) {
    sqlite3VdbeAddOp1($3, 143, $13);
   }
   if ($16) {
    sqlite3VdbeAddOp2($3, 86, $16, 1);
   }
   label$21: {
    label$22: {
     label$23: {
      label$24: {
       label$25: {
        label$26: {
         label$27: {
          label$28: {
           label$29: {
            label$30: {
             label$31: {
              label$32: {
               label$33: {
                if ($12) {
                 $8 = 0;
                 $9 = ($10 | 0) > 0 ? $10 : 0;
                 while (1) {
                  if (($9 | 0) != ($8 | 0)) {
                   sqlite3ExprCodeGetColumnOfTable($3, $5, $13, HEAP16[HEAP32[$12 + 4 >> 2] + ($8 << 1) >> 1], $8 + $11 | 0);
                   $8 = $8 + 1 | 0;
                   continue;
                  }
                  break;
                 }
                 if (!$20) {
                  break label$32;
                 }
                 $9 = $11;
                 break label$33;
                }
                $21 = 1;
                $9 = HEAP32[$0 + 44 >> 2] + 1 | 0;
                HEAP32[$0 + 44 >> 2] = $9;
                sqlite3ExprCodeGetColumnOfTable($3, $5, $13, -1, $9);
                if (!$20) {
                 break label$30;
                }
               }
               $8 = sqlite3DbMallocRawNN($17, $7 + 2 | 0, 0);
               if (!$8) {
                sqlite3WhereEnd($15);
                break label$1;
               }
               $7 = $7 + 1 | 0;
               $6 = memset($8, 1, $7);
               HEAP8[$6 + $7 | 0] = 0;
               $7 = HEAP32[$4 + 8 >> 2];
               if (($7 | 0) >= 0) {
                HEAP8[($7 - $13 | 0) + $6 | 0] = 0;
               }
               $7 = HEAP32[$4 + 12 >> 2];
               if (($7 | 0) >= 0) {
                HEAP8[($7 - $13 | 0) + $6 | 0] = 0;
               }
               if ($19) {
                sqlite3VdbeChangeToNoop($3, $19);
               }
               $6 = sqlite3VdbeMakeLabel($0);
               if (($14 & 255) != 2) {
                break label$31;
               }
               $21 = $10;
               break label$27;
              }
              $9 = HEAP32[$0 + 44 >> 2] + 1 | 0;
              HEAP32[$0 + 44 >> 2] = $9;
              sqlite3VdbeAddOp4($3, 97, $11, $10, $9, sqlite3IndexAffinityStr(HEAP32[$0 >> 2], $12), $10);
              sqlite3VdbeAddOp4Int($3, 138, $18, $9, $11, $10);
              break label$29;
             }
             $7 = 0;
             if (($20 | 0) != 2) {
              $11 = 0;
              $21 = $10;
              $19 = 0;
              break label$28;
             }
             $11 = 0;
             $7 = 1;
             $19 = sqlite3VdbeAddOp0($3, 14);
             $21 = $10;
             break label$28;
            }
            sqlite3VdbeAddOp2($3, 156, $22, $9);
           }
           sqlite3WhereEnd($15);
           $11 = 1;
           $7 = 0;
           $8 = 0;
           $19 = 0;
           $10 = 0;
           if (($14 & 255) == 2) {
            break label$26;
           }
          }
          sqlite3OpenTableAndIndices($0, $5, 113, 8, $13, $8, $4 + 60 | 0, $4 + 56 | 0);
          if ($7) {
           sqlite3VdbeJumpHereOrPopInst($3, $19);
          }
          $7 = $8;
          $10 = $6;
          if ($11) {
           break label$26;
          }
         }
         $14 = 0;
         if (HEAPU8[$5 + 43 | 0] == 1) {
          $11 = 0;
          break label$24;
         }
         $7 = HEAP32[$4 + 60 >> 2];
         if (HEAPU8[($7 - $13 | 0) + $8 | 0]) {
          sqlite3VdbeAddOp4Int($3, 27, $7, $6, $9, $21);
         }
         $11 = 0;
         break label$25;
        }
        label$45: {
         if ($12) {
          $14 = sqlite3VdbeAddOp1($3, 35, $18);
          $11 = 1;
          if (HEAPU8[$5 + 43 | 0] == 1) {
           sqlite3VdbeAddOp3($3, 94, $18, 0, $9);
           break label$45;
          }
          sqlite3VdbeAddOp2($3, 134, $18, $9);
          break label$45;
         }
         $11 = 1;
         $14 = sqlite3VdbeAddOp3($3, 45, $22, 0, $9);
        }
        $8 = $7;
        $6 = $10;
       }
       if (HEAPU8[$5 + 43 | 0] != 1) {
        break label$23;
       }
      }
      $7 = sqlite3GetVTable($17, $5);
      sqlite3VtabMakeWritable($0, $5);
      sqlite3MayAbort($0);
      label$48: {
       if (($20 | 0) != 1) {
        break label$48;
       }
       sqlite3VdbeAddOp1($3, 122, $13);
       if (HEAP32[$0 + 116 >> 2]) {
        break label$48;
       }
       HEAP8[$0 + 20 | 0] = 0;
      }
      sqlite3VdbeAddOp4($3, 7, 0, 1, $9, $7, -11);
      sqlite3VdbeChangeP5($3, 2);
      if ($11) {
       break label$22;
      }
      break label$21;
     }
     sqlite3GenerateRowDelete($0, $5, $23, HEAP32[$4 + 60 >> 2], HEAP32[$4 + 56 >> 2], $9, $21, !HEAPU8[$0 + 18 | 0], 11, $20 & 255, HEAP32[$4 + 12 >> 2]);
     if (!$11) {
      break label$21;
     }
    }
    label$49: {
     if ($12) {
      sqlite3VdbeAddOp2($3, 38, $18, $14 + 1 | 0);
      break label$49;
     }
     sqlite3VdbeGoto($3, $14);
    }
    sqlite3VdbeJumpHere($3, $14);
    break label$9;
   }
   sqlite3VdbeResolveLabel($3, $6);
   sqlite3WhereEnd($15);
  }
  if (!(HEAPU8[$0 + 18 | 0] | HEAP32[$0 + 120 >> 2])) {
   sqlite3AutoincrementEnd($0);
  }
  if ($16) {
   sqlite3CodeChangeCount($3, $16, 14922);
  }
  $6 = $8;
 }
 sqlite3AuthContextPop($4 + 48 | 0);
 sqlite3SrcListDelete($17, $1);
 sqlite3ExprDelete($17, $2);
 sqlite3DbFree($17, $6);
 __stack_pointer = $4 - -64 | 0;
}

function sqlite3WindowCodeStep($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 $7 = HEAP32[$1 + 68 >> 2];
 $13 = HEAP32[$7 + 12 >> 2];
 $6 = sqlite3GetVdbe($0);
 $1 = HEAP32[$1 + 32 >> 2];
 $8 = HEAP32[$1 + 48 >> 2];
 $15 = HEAP16[HEAP32[$1 + 24 >> 2] + 34 >> 1];
 $18 = sqlite3VdbeMakeLabel($0);
 memset($5 + 28 | 0, 0, 36);
 HEAP32[$5 + 24 >> 2] = $3;
 HEAP32[$5 + 16 >> 2] = $6;
 HEAP32[$5 + 12 >> 2] = $7;
 HEAP32[$5 + 8 >> 2] = $0;
 HEAP32[$5 + 20 >> 2] = $4;
 $14 = HEAP32[$7 + 48 >> 2];
 HEAP32[$5 + 48 >> 2] = $14;
 HEAP32[$5 + 56 >> 2] = $14 + 3;
 $1 = 2;
 HEAP32[$5 + 40 >> 2] = $14 + 2;
 label$1: {
  label$2: {
   label$3: {
    switch (HEAPU8[$7 + 17 | 0] - 86 | 0) {
    case 0:
     if (HEAPU8[$7 + 16 | 0] == 89) {
      break label$1;
     }
     $1 = 1;
     if (windowExprGtZero($0, HEAP32[$7 + 24 >> 2])) {
      break label$2;
     }
     break label$1;

    case 4:
     break label$3;

    default:
     break label$2;
    }
   }
   if (windowCacheFrame($7)) {
    break label$1;
   }
   $1 = 1;
   if (HEAPU8[$7 + 18 | 0] != 88) {
    break label$2;
   }
   if (HEAPU8[$7 + 16 | 0] == 89) {
    break label$1;
   }
   $1 = 3;
   if (!windowExprGtZero($0, HEAP32[$7 + 28 >> 2])) {
    break label$1;
   }
  }
  HEAP32[$5 + 32 >> 2] = $1;
 }
 $1 = HEAP32[$0 + 44 >> 2];
 $16 = $15 + $1 | 0;
 $17 = $16 + 2 | 0;
 HEAP32[$0 + 44 >> 2] = $17;
 HEAP32[$5 + 36 >> 2] = $17;
 $4 = $17;
 label$5: {
  switch (HEAPU8[$7 + 17 | 0] - 86 | 0) {
  case 0:
  case 2:
   $4 = $16 + 3 | 0;
   HEAP32[$0 + 44 >> 2] = $4;
   $10 = $4;
   break;

  default:
   break label$5;
  }
 }
 label$7: {
  switch (HEAPU8[$7 + 18 | 0] - 86 | 0) {
  case 0:
  case 2:
   $4 = $4 + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $4;
   $9 = $4;
   break;

  default:
   break label$7;
  }
 }
 $3 = $1 + 1 | 0;
 $1 = 0;
 if (HEAPU8[$7 + 16 | 0] != 76) {
  $12 = $13 ? HEAP32[$13 >> 2] : 0;
  $19 = HEAP32[$7 + 76 >> 2] + $3 | 0;
  $11 = HEAP32[$7 + 8 >> 2];
  if ($11) {
   $19 = HEAP32[$11 >> 2] + $19 | 0;
  }
  $11 = $4 + $12 | 0;
  HEAP32[$5 + 44 >> 2] = $11 + 1;
  $11 = $12 + $11 | 0;
  HEAP32[$5 + 52 >> 2] = $11 + 1;
  $11 = $12 + $11 | 0;
  HEAP32[$5 + 60 >> 2] = $11 + 1;
  HEAP32[$0 + 44 >> 2] = $12 + $11;
  $12 = $4 + 1 | 0;
 }
 $14 = $14 + 1 | 0;
 $16 = $16 + 1 | 0;
 $4 = ($15 | 0) > 0 ? $15 : 0;
 while (1) {
  if (($1 | 0) != ($4 | 0)) {
   sqlite3VdbeAddOp3($6, 94, $8, $1, $1 + $3 | 0);
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3VdbeAddOp3($6, 97, $3, $15, $16);
 $1 = 0;
 $4 = 0;
 $8 = HEAP32[$7 + 8 >> 2];
 if ($8) {
  $15 = HEAP32[$8 >> 2];
  $4 = HEAP32[$7 + 76 >> 2];
  $8 = sqlite3KeyInfoFromExprList($0, $8, 0, 0);
  $1 = HEAP32[$0 + 44 >> 2] + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $1;
  $11 = $3 + $4 | 0;
  $3 = sqlite3VdbeAddOp3($6, 90, $11, HEAP32[$7 + 68 >> 2], $15);
  sqlite3VdbeAppendP4($6, $8, -8);
  $4 = $3 + 2 | 0;
  sqlite3VdbeAddOp3($6, 13, $4, $3 + 4 | 0, $4);
  $4 = sqlite3VdbeAddOp1($6, 9, $1);
  sqlite3VdbeAddOp3($6, 80, $11, HEAP32[$7 + 68 >> 2], $15 - 1 | 0);
 }
 sqlite3VdbeAddOp2($6, 127, $14, $17);
 sqlite3VdbeAddOp3($6, 128, $14, $16, $17);
 $8 = sqlite3VdbeAddOp3($6, 52, HEAP32[$7 + 84 >> 2], 0, $17);
 HEAP32[$5 + 28 >> 2] = windowInitAccum($0, $7);
 if ($10) {
  sqlite3ExprCode($0, HEAP32[$7 + 24 >> 2], $10);
  windowCheckValue($0, $10, HEAPU8[$7 + 16 | 0] == 89 ? 3 : 0);
 }
 if ($9) {
  sqlite3ExprCode($0, HEAP32[$7 + 28 >> 2], $9);
  windowCheckValue($0, $9, HEAPU8[$7 + 16 | 0] == 89 ? 4 : 1);
 }
 label$18: {
  if (HEAPU8[$7 + 16 | 0] != 89) {
   $3 = HEAPU8[$7 + 17 | 0];
   if (!$10 | ($3 | 0) != HEAPU8[$7 + 18 | 0]) {
    break label$18;
   }
   $3 = sqlite3VdbeAddOp3($6, ($3 | 0) == 86 ? 57 : 55, $10, 0, $9);
   windowAggFinal($5 + 8 | 0, 0);
   sqlite3VdbeAddOp2($6, 35, HEAP32[$5 + 48 >> 2], 1);
   windowReturnOneRow($5 + 8 | 0);
   sqlite3VdbeAddOp1($6, 146, HEAP32[$5 + 48 >> 2]);
   sqlite3VdbeAddOp2($6, 8, 0, $18);
   sqlite3VdbeJumpHere($6, $3);
  }
  $3 = HEAPU8[$7 + 17 | 0];
 }
 label$20: {
  label$21: {
   if (($3 & 255) == 86) {
    if (!$9 | HEAPU8[$7 + 16 | 0] == 89) {
     break label$21;
    }
    sqlite3VdbeAddOp3($6, 107, $10, $9, $10);
    $3 = HEAPU8[$7 + 17 | 0];
   }
   if (($3 & 255) == 90) {
    break label$20;
   }
  }
  sqlite3VdbeAddOp2($6, 35, HEAP32[$5 + 40 >> 2], 1);
 }
 sqlite3VdbeAddOp2($6, 35, HEAP32[$5 + 48 >> 2], 1);
 sqlite3VdbeAddOp2($6, 35, HEAP32[$5 + 56 >> 2], 1);
 if (!(!$12 | !$13)) {
  sqlite3VdbeAddOp3($6, 80, $19, $12, HEAP32[$13 >> 2] - 1 | 0);
  sqlite3VdbeAddOp3($6, 80, $12, HEAP32[$5 + 44 >> 2], HEAP32[$13 >> 2] - 1 | 0);
  sqlite3VdbeAddOp3($6, 80, $12, HEAP32[$5 + 52 >> 2], HEAP32[$13 >> 2] - 1 | 0);
  sqlite3VdbeAddOp3($6, 80, $12, HEAP32[$5 + 60 >> 2], HEAP32[$13 >> 2] - 1 | 0);
 }
 sqlite3VdbeAddOp2($6, 8, 0, $18);
 sqlite3VdbeJumpHere($6, $8);
 if ($12) {
  windowIfNewPeer($0, $13, $19, $12, $18);
 }
 $3 = HEAPU8[$7 + 17 | 0];
 label$25: {
  if (($3 | 0) == 86) {
   windowCodeOp($5 + 8 | 0, 3, 0, 0);
   if (HEAPU8[$7 + 18 | 0] == 90) {
    break label$25;
   }
   if (HEAPU8[$7 + 16 | 0] == 89) {
    $3 = sqlite3VdbeMakeLabel($0);
    $8 = sqlite3VdbeCurrentAddr($6);
    windowCodeRangeTest($5 + 8 | 0, 57, HEAP32[$5 + 48 >> 2], $9, HEAP32[$5 + 56 >> 2], $3);
    windowCodeOp($5 + 8 | 0, 2, $10, 0);
    windowCodeOp($5 + 8 | 0, 1, 0, 0);
    sqlite3VdbeAddOp2($6, 8, 0, $8);
    sqlite3VdbeResolveLabel($6, $3);
    break label$25;
   }
   windowCodeOp($5 + 8 | 0, 1, $9, 0);
   windowCodeOp($5 + 8 | 0, 2, $10, 0);
   break label$25;
  }
  if (HEAPU8[$7 + 18 | 0] == 88) {
   label$29: {
    if (($3 | 0) == 88) {
     $3 = HEAPU8[$7 + 16 | 0];
     windowCodeOp($5 + 8 | 0, 3, $9, 0);
     if (($3 | 0) != 89) {
      break label$29;
     }
     windowCodeOp($5 + 8 | 0, 2, $10, 0);
     windowCodeOp($5 + 8 | 0, 1, 0, 0);
     break label$25;
    }
    windowCodeOp($5 + 8 | 0, 3, $9, 0);
   }
   windowCodeOp($5 + 8 | 0, 1, 0, 0);
   windowCodeOp($5 + 8 | 0, 2, $10, 0);
   break label$25;
  }
  windowCodeOp($5 + 8 | 0, 3, 0, 0);
  if (HEAPU8[$7 + 18 | 0] == 90) {
   break label$25;
  }
  if (HEAPU8[$7 + 16 | 0] == 89) {
   $8 = sqlite3VdbeCurrentAddr($6);
   $3 = 0;
   if ($9) {
    $3 = sqlite3VdbeMakeLabel($0);
    windowCodeRangeTest($5 + 8 | 0, 57, HEAP32[$5 + 48 >> 2], $9, HEAP32[$5 + 56 >> 2], $3);
   }
   windowCodeOp($5 + 8 | 0, 1, 0, 0);
   windowCodeOp($5 + 8 | 0, 2, $10, 0);
   if (!$9) {
    break label$25;
   }
   sqlite3VdbeAddOp2($6, 8, 0, $8);
   sqlite3VdbeResolveLabel($6, $3);
   break label$25;
  }
  $3 = 0;
  if ($9) {
   $3 = sqlite3VdbeAddOp3($6, 49, $9, 0, 1);
  }
  windowCodeOp($5 + 8 | 0, 1, 0, 0);
  windowCodeOp($5 + 8 | 0, 2, $10, 0);
  if (!$9) {
   break label$25;
  }
  sqlite3VdbeJumpHere($6, $3);
 }
 sqlite3VdbeResolveLabel($6, $18);
 sqlite3WhereEnd($2);
 $3 = 0;
 if (HEAP32[$7 + 8 >> 2]) {
  $3 = sqlite3VdbeAddOp2($6, 71, 0, $1);
  sqlite3VdbeJumpHere($6, $4);
 }
 HEAP32[$5 + 36 >> 2] = 0;
 $4 = sqlite3VdbeAddOp1($6, 35, $14);
 $8 = HEAPU8[$7 + 17 | 0];
 label$35: {
  if (HEAPU8[$7 + 18 | 0] == 88) {
   label$37: {
    if (($8 & 255) == 88) {
     $8 = HEAPU8[$7 + 16 | 0];
     windowCodeOp($5 + 8 | 0, 3, $9, 0);
     if (($8 | 0) != 89) {
      break label$37;
     }
     windowCodeOp($5 + 8 | 0, 2, $10, 0);
     break label$37;
    }
    windowCodeOp($5 + 8 | 0, 3, $9, 0);
   }
   windowCodeOp($5 + 8 | 0, 1, 0, 0);
   break label$35;
  }
  windowCodeOp($5 + 8 | 0, 3, 0, 0);
  if (($8 & 255) == 86) {
   label$40: {
    if (HEAPU8[$7 + 16 | 0] == 89) {
     $8 = sqlite3VdbeCurrentAddr($6);
     $0 = windowCodeOp($5 + 8 | 0, 2, $10, 1);
     $9 = windowCodeOp($5 + 8 | 0, 1, 0, 1);
     break label$40;
    }
    $8 = sqlite3VdbeCurrentAddr($6);
    if (HEAPU8[$7 + 18 | 0] == 90) {
     $9 = windowCodeOp($5 + 8 | 0, 1, $10, 1);
     $0 = windowCodeOp($5 + 8 | 0, 2, 0, 1);
     break label$40;
    }
    $9 = windowCodeOp($5 + 8 | 0, 1, $9, 1);
    $0 = windowCodeOp($5 + 8 | 0, 2, $10, 1);
   }
   sqlite3VdbeAddOp2($6, 8, 0, $8);
   sqlite3VdbeJumpHere($6, $0);
   $8 = sqlite3VdbeCurrentAddr($6);
   $0 = windowCodeOp($5 + 8 | 0, 1, 0, 1);
   sqlite3VdbeAddOp2($6, 8, 0, $8);
   sqlite3VdbeJumpHere($6, $9);
   sqlite3VdbeJumpHere($6, $0);
   break label$35;
  }
  $8 = sqlite3VdbeCurrentAddr($6);
  $0 = windowCodeOp($5 + 8 | 0, 1, 0, 1);
  windowCodeOp($5 + 8 | 0, 2, $10, 0);
  sqlite3VdbeAddOp2($6, 8, 0, $8);
  sqlite3VdbeJumpHere($6, $0);
 }
 sqlite3VdbeJumpHere($6, $4);
 sqlite3VdbeAddOp1($6, 146, HEAP32[$5 + 48 >> 2]);
 if (HEAP32[$7 + 8 >> 2]) {
  $4 = HEAP32[$7 + 88 >> 2];
  if ($4) {
   sqlite3VdbeAddOp2($6, 71, 1, $4);
   sqlite3VdbeAddOp2($6, 71, 0, HEAP32[$7 + 92 >> 2]);
  }
  sqlite3VdbeChangeP1($6, $3, sqlite3VdbeCurrentAddr($6));
  sqlite3VdbeAddOp1($6, 67, $1);
 }
 __stack_pointer = $5 - -64 | 0;
}

function sqlite3AtoF($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $6 = __stack_pointer - 128 | 0;
 __stack_pointer = $6;
 $5 = $1;
 HEAP32[$5 >> 2] = 0;
 HEAP32[$5 + 4 >> 2] = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  label$2: {
   if (($3 | 0) == 1) {
    $12 = 1;
    $16 = 1;
    $7 = $0;
    break label$2;
   }
   $7 = 3 - $3 | 0;
   $12 = $2 & -2;
   while (1) {
    label$5: {
     if (($7 | 0) >= ($12 | 0)) {
      $16 = 1;
     } else {
      if (!HEAPU8[$0 + $7 | 0]) {
       break label$5;
      }
      $16 = -100;
     }
     $2 = $7 ^ 1;
     $7 = ($3 & 1) + $0 | 0;
     $12 = 2;
     break label$2;
    }
    $7 = $7 + 2 | 0;
    continue;
   }
  }
  $0 = $0 + $2 | 0;
  while (1) {
   if ($0 >>> 0 <= $7 >>> 0) {
    break label$1;
   }
   $2 = HEAPU8[$7 | 0];
   if (HEAP8[$2 + 30288 | 0] & 1) {
    $7 = $7 + $12 | 0;
    continue;
   }
   break;
  }
  $7 = (($2 | 0) == 45 ? $12 : ($2 | 0) == 43 ? $12 : 0) + $7 | 0;
  $3 = 0;
  label$10: {
   label$11: {
    label$12: while (1) {
     $20 = 1;
     if ($0 >>> 0 <= $7 >>> 0) {
      break label$11;
     }
     $13 = HEAPU8[$7 | 0];
     if ($13 - 58 >>> 0 >= 4294967286) {
      $3 = $3 + 1 | 0;
      $7 = $7 + $12 | 0;
      $5 = __wasm_i64_mul($10, $8, 10, 0);
      $4 = $5;
      $11 = i64toi32_i32$HIGH_BITS;
      $8 = $11;
      $5 = $13 << 24;
      $14 = $5 >> 31;
      $13 = $5 >> 24;
      $11 = $14;
      $14 = $8;
      $9 = $11 + $14 | 0;
      $5 = $4;
      $4 = $13 + $5 | 0;
      $11 = $4 - 48 | 0;
      $10 = $11;
      $9 = $4 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
      $4 = $4 >>> 0 < 48;
      $4 = $9 - $4 | 0;
      $8 = $4;
      if ($10 >>> 0 < 3435973835 & ($4 | 0) <= 214748364 | ($4 | 0) < 214748364) {
       continue;
      }
      while (1) {
       if (HEAPU8[$7 | 0] - 58 >>> 0 < 4294967286 | $0 >>> 0 <= $7 >>> 0) {
        continue label$12;
       }
       $15 = $15 + 1 | 0;
       $7 = $7 + $12 | 0;
       continue;
      }
     }
     break;
    }
    label$15: {
     if (($13 | 0) != 46) {
      break label$15;
     }
     $16 = $16 + 1 | 0;
     while (1) {
      $7 = $7 + $12 | 0;
      if ($7 >>> 0 >= $0 >>> 0) {
       break label$15;
      }
      $13 = HEAPU8[$7 | 0];
      if ($13 - 58 >>> 0 < 4294967286) {
       break label$15;
      }
      if ($10 >>> 0 > 3435973834 & ($8 | 0) >= 214748364 | ($8 | 0) > 214748364) {
       continue;
      }
      $3 = $3 + 1 | 0;
      $15 = $15 - 1 | 0;
      $9 = __wasm_i64_mul($10, $8, 10, 0);
      $5 = $9;
      $9 = $13 << 24;
      $14 = $9 >> 31;
      $4 = $14;
      $14 = i64toi32_i32$HIGH_BITS;
      $11 = $4 + $14 | 0;
      $4 = $9 >> 24;
      $9 = $5;
      $5 = $4 + $9 | 0;
      $11 = $5 >>> 0 < $4 >>> 0 ? $11 + 1 | 0 : $11;
      $10 = $5 - 48 | 0;
      $5 = $5 >>> 0 < 48;
      $5 = $11 - $5 | 0;
      $8 = $5;
      continue;
     }
    }
    if ($0 >>> 0 <= $7 >>> 0) {
     break label$11;
    }
    label$17: {
     if ((HEAPU8[$7 | 0] | 32) != 101) {
      $19 = 1;
      break label$17;
     }
     $16 = $16 + 1 | 0;
     $7 = $7 + $12 | 0;
     if ($7 >>> 0 >= $0 >>> 0) {
      break label$10;
     }
     label$20: {
      label$21: {
       switch (HEAPU8[$7 | 0] - 43 | 0) {
       case 2:
        $7 = $7 + $12 | 0;
        $20 = -1;
        break label$20;

       case 0:
        break label$21;

       default:
        break label$20;
       }
      }
      $7 = $7 + $12 | 0;
     }
     while (1) {
      if ($0 >>> 0 <= $7 >>> 0) {
       break label$17;
      }
      $13 = HEAPU8[$7 | 0];
      if ($13 - 58 >>> 0 < 4294967286) {
       break label$17;
      }
      $17 = ($17 | 0) < 1e4 ? (Math_imul($17, 10) + ($13 << 24 >> 24) | 0) - 48 | 0 : 1e4;
      $7 = $7 + $12 | 0;
      $19 = 1;
      continue;
     }
    }
    while (1) {
     if (!(HEAP8[HEAPU8[$7 | 0] + 30288 | 0] & 1) | $0 >>> 0 <= $7 >>> 0) {
      break label$10;
     }
     $7 = $7 + $12 | 0;
     continue;
    }
   }
   $19 = 1;
  }
  $21 = $1;
  $5 = $8;
  label$25: {
   if ($5 | $10) {
    $17 = Math_imul($17, $20) + $15 | 0;
    $12 = $17 >> 31;
    $12 = ($12 ^ $17) - $12 | 0;
    $13 = ($17 | 0) < 0;
    label$27: {
     while (1) {
      if (($12 | 0) > 0) {
       label$30: {
        if (!$13) {
         $5 = $8;
         if ($10 >>> 0 > 3435973835 & ($5 | 0) >= 214748364 | ($5 | 0) > 214748364) {
          break label$27;
         }
         $5 = __wasm_i64_mul($10, $8, 10, 0);
         $15 = $5;
         $11 = i64toi32_i32$HIGH_BITS;
         $1 = $11;
         break label$30;
        }
        $5 = __wasm_i64_sdiv($10, $8, 10, 0);
        $15 = $5;
        $11 = i64toi32_i32$HIGH_BITS;
        $1 = $11;
        $5 = __wasm_i64_mul($5, $11, 10, 0);
        $11 = i64toi32_i32$HIGH_BITS;
        $14 = $5;
        $4 = $10;
        $5 = $11;
        if (($14 | 0) != ($4 | 0) | ($8 | 0) != ($5 | 0)) {
         break label$27;
        }
       }
       $12 = $12 - 1 | 0;
       $10 = $15;
       $4 = $1;
       $8 = $4;
       continue;
      }
      break;
     }
     $5 = $10;
     $9 = 0 - $5 | 0;
     $11 = ($2 | 0) == 45;
     $5 = $11 ? $9 : $5;
     $4 = $11 ? 0 - ($8 + (($10 | 0) != 0) | 0) | 0 : $8;
     $18 = +($5 >>> 0) + +($4 | 0) * 4294967296;
     break label$25;
    }
    $5 = $8;
    $9 = $5 + (($10 | 0) != 0) | 0;
    $9 = 0 - $9 | 0;
    $14 = 0 - $10 | 0;
    $5 = ($2 | 0) == 45;
    $10 = $5 ? $14 : $10;
    $4 = $5 ? $9 : $8;
    $8 = $4;
    if ($12 >>> 0 >= 308) {
     if ($12 >>> 0 <= 341) {
      sqlite3Pow10($6 + 48 | 0, $12 - 308 | 0);
      $4 = $8;
      __floatditf($6 + 32 | 0, $10, $4);
      $4 = HEAP32[$6 + 40 >> 2];
      $10 = $4;
      $8 = HEAP32[$6 + 44 >> 2];
      $15 = HEAP32[$6 + 56 >> 2];
      $4 = HEAP32[$6 + 60 >> 2];
      $1 = $4;
      $4 = HEAP32[$6 + 32 >> 2];
      $11 = $4;
      $2 = HEAP32[$6 + 36 >> 2];
      $14 = HEAP32[$6 + 48 >> 2];
      $4 = HEAP32[$6 + 52 >> 2];
      $5 = $4;
      if (($17 | 0) < 0) {
       $4 = $2;
       $9 = $1;
       __divtf3($6, $11, $4, $10, $8, $14, $5, $15, $9);
       $9 = HEAP32[$6 >> 2];
       $2 = $9;
       $9 = HEAP32[$6 + 12 >> 2];
       $1 = $9;
       $5 = HEAP32[$6 + 4 >> 2];
       $9 = $5;
       $5 = HEAP32[$6 + 8 >> 2];
       $4 = $5;
       $5 = $1;
       $18 = __trunctfdf2($2, $9, $4, $5) / 1e308;
       break label$25;
      }
      $9 = $1;
      $4 = $8;
      __multf3($6 + 16 | 0, $14, $5, $15, $9, $11, $2, $10, $4);
      $4 = HEAP32[$6 + 16 >> 2];
      $1 = $4;
      $4 = HEAP32[$6 + 28 >> 2];
      $2 = $4;
      $4 = HEAP32[$6 + 20 >> 2];
      $18 = __trunctfdf2($1, $4, HEAP32[$6 + 24 >> 2], $2) * 1e308;
      break label$25;
     }
     $4 = $10;
     $18 = (+($4 >>> 0) + +($8 | 0) * 4294967296) * 0;
     if (($17 | 0) < 0) {
      break label$25;
     }
     $18 = +Math_fround(Math_fround(+($10 >>> 0) + +($8 | 0) * 4294967296) * Math_fround(infinity));
     break label$25;
    }
    sqlite3Pow10($6 + 112 | 0, $12);
    __floatditf($6 + 96 | 0, $10, $8);
    $10 = HEAP32[$6 + 104 >> 2];
    $4 = HEAP32[$6 + 108 >> 2];
    $8 = $4;
    $4 = HEAP32[$6 + 120 >> 2];
    $15 = $4;
    $1 = HEAP32[$6 + 124 >> 2];
    $11 = HEAP32[$6 + 96 >> 2];
    $4 = HEAP32[$6 + 100 >> 2];
    $2 = $4;
    $4 = HEAP32[$6 + 112 >> 2];
    $14 = $4;
    $5 = HEAP32[$6 + 116 >> 2];
    label$35: {
     if (($17 | 0) < 0) {
      $4 = $8;
      $9 = $5;
      $5 = $1;
      __divtf3($6 - -64 | 0, $11, $2, $10, $4, $14, $9, $15, $5);
      $5 = HEAP32[$6 + 64 >> 2];
      $15 = $5;
      $9 = HEAP32[$6 + 68 >> 2];
      $1 = $9;
      $5 = HEAP32[$6 + 76 >> 2];
      $9 = HEAP32[$6 + 72 >> 2];
      $4 = $9;
      break label$35;
     }
     $9 = $1;
     $4 = $2;
     __multf3($6 + 80 | 0, $14, $5, $15, $9, $11, $4, $10, $8);
     $15 = HEAP32[$6 + 80 >> 2];
     $4 = HEAP32[$6 + 84 >> 2];
     $1 = $4;
     $5 = HEAP32[$6 + 92 >> 2];
     $4 = HEAP32[$6 + 88 >> 2];
    }
    $10 = $4;
    $8 = $5;
    $4 = $8;
    $18 = __trunctfdf2($15, $1, $10, $4);
    break label$25;
   }
   $18 = ($2 | 0) == 45 ? -0 : 0;
  }
  HEAPF64[$21 >> 3] = $18;
  if (!(!$19 | ($0 | 0) != ($7 | 0) | (($3 | 0) <= 0 | ($16 | 0) <= 0))) {
   $13 = $16;
   break label$1;
  }
  if (!(!$19 & ($16 | 0) != 3 | ($16 | 0) < 2)) {
   $13 = -1;
   if (($3 | 0) > 0) {
    break label$1;
   }
  }
  $13 = 0;
 }
 __stack_pointer = $6 + 128 | 0;
 return $13;
}

function flattenSubquery($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 $12 = __stack_pointer - 32 | 0;
 __stack_pointer = $12;
 $11 = HEAP32[$0 >> 2];
 $6 = HEAP32[$11 + 80 >> 2];
 label$1: {
  if (HEAP32[$1 + 68 >> 2] | $6 & 1) {
   break label$1;
  }
  $10 = HEAP32[$1 + 32 >> 2];
  $5 = $10 + ($2 << 6) | 0;
  $14 = $5 + 28 | 0;
  $9 = HEAP32[$14 >> 2];
  if (HEAP32[$9 + 68 >> 2]) {
   break label$1;
  }
  $14 = $5;
  $17 = HEAP32[$0 + 248 >> 2];
  $21 = HEAP32[$5 + 48 >> 2];
  $5 = HEAP32[$9 + 32 >> 2];
  $7 = HEAP32[$9 + 60 >> 2];
  label$2: {
   if ($7) {
    if (HEAP32[$1 + 60 >> 2] | HEAP32[$7 + 16 >> 2]) {
     break label$1;
    }
    $13 = HEAP32[$1 + 4 >> 2];
    if (!($13 & 256)) {
     break label$2;
    }
    break label$1;
   }
   $13 = HEAP32[$1 + 4 >> 2];
  }
  $8 = HEAP32[$5 >> 2];
  if (!$8) {
   break label$1;
  }
  $16 = HEAP32[$9 + 4 >> 2];
  if ($16 & 1 | (HEAP32[$10 >> 2] > 1 | $3 ? $7 : 0)) {
   break label$1;
  }
  $15 = HEAP32[$1 + 48 >> 2];
  if ((HEAP32[$9 + 48 >> 2] ? $15 : 0) | (HEAP32[$9 + 48 >> 2] ? $3 : 0)) {
   break label$1;
  }
  label$7: {
   if ($7) {
    if (HEAP32[$1 + 36 >> 2] | $13 & 1) {
     break label$1;
    }
    if (!($16 & 8192)) {
     break label$7;
    }
    break label$1;
   }
   if ($16 & 8192) {
    break label$1;
   }
  }
  $20 = ($2 << 6) + $10 | 0;
  $7 = HEAPU8[$20 + 44 | 0];
  $16 = $7 & 96;
  if ($16) {
   if (($8 | 0) > 1 | $3 | HEAPU8[HEAP32[$5 + 24 >> 2] + 43 | 0] == 1) {
    break label$1;
   }
   $22 = 1;
   if ($13 & 1 | $7 & 16) {
    break label$1;
   }
  }
  if (HEAPU8[$5 + 44 | 0] & 64 ? ($2 | 0) > 0 : 0) {
   break label$1;
  }
  $4 = ($2 << 6) + $10 | 0;
  $18 = HEAPU8[$4 + 45 | 0] | HEAPU8[$4 + 46 | 0] << 8;
  if (!(!($18 & 256) | HEAPU8[HEAP32[$4 + 68 >> 2] + 18 | 0])) {
   $4 = 0;
   break label$1;
  }
  if (!(!(HEAPU8[(($8 << 6) + $5 | 0) - 20 | 0] & 32) | ($8 | 0) < 2)) {
   $4 = 0;
   if ($7 & 4 | $18 & 1024 | (HEAP32[(($2 << 6) + $10 | 0) + 52 >> 2] | $18 & 2048)) {
    break label$1;
   }
  }
  $8 = 0;
  label$13: {
   if (!HEAP32[$9 + 52 >> 2]) {
    break label$13;
   }
   $4 = 0;
   if (HEAP32[$9 + 48 >> 2] | (($16 | 0) != 0 | $13) & 1 | $3) {
    break label$1;
   }
   $3 = $9;
   while (1) {
    if ($3) {
     if (HEAPU8[$3 + 4 | 0] & 9) {
      break label$1;
     }
     $5 = HEAP32[$3 + 52 >> 2];
     if (HEAPU8[$3 | 0] != 135 ? $5 : 0) {
      break label$1;
     }
     $7 = HEAP32[$3 + 32 >> 2];
     if (HEAP32[$3 + 68 >> 2] | HEAP32[$7 >> 2] <= 0) {
      break label$1;
     }
     $3 = $5;
     if (!(HEAPU8[$7 + 44 | 0] & 64) | ($2 | 0) <= 0) {
      continue;
     }
     break label$1;
    }
    break;
   }
   label$17: {
    if (!$15) {
     break label$17;
    }
    $3 = 0;
    $4 = HEAP32[$15 >> 2];
    $7 = ($4 | 0) > 0 ? $4 : 0;
    while (1) {
     if (($3 | 0) == ($7 | 0)) {
      break label$17;
     }
     $5 = $3 << 4;
     $4 = 0;
     $3 = $3 + 1 | 0;
     if (HEAPU16[($5 + $15 | 0) + 20 >> 1]) {
      continue;
     }
     break;
    }
    break label$1;
   }
   $4 = 0;
   if ($13 & 8192) {
    break label$1;
   }
   if (HEAP32[$10 >> 2] < 2) {
    break label$13;
   }
   if ($6 & 8388608 | HEAP32[$0 + 100 >> 2] > 500) {
    break label$1;
   }
   $5 = HEAP32[$0 + 40 >> 2];
   $3 = $5 >> 31;
   $4 = $5;
   $5 = $3 << 2 | $5 >>> 30;
   $3 = $4 << 2;
   $3 = $3 + 4 | 0;
   $8 = sqlite3DbMallocZero($11, $3, $3 >>> 0 < 4 ? $5 + 1 | 0 : $5);
   if (!$8) {
    $8 = 0;
    break label$13;
   }
   HEAP32[$8 >> 2] = HEAP32[$0 + 40 >> 2];
  }
  $4 = $9 + 52 | 0;
  $3 = ($2 << 6) + $10 | 0;
  $6 = $3 + 16 | 0;
  HEAP32[$0 + 248 >> 2] = HEAP32[$6 >> 2];
  sqlite3AuthCheck($0, 21, 0, 0, 0);
  HEAP32[$0 + 248 >> 2] = $17;
  $19 = HEAP32[$14 + 28 >> 2];
  $9 = $3 + 12 | 0;
  sqlite3DbFree($11, HEAP32[$9 >> 2]);
  sqlite3DbFree($11, HEAP32[$3 + 16 >> 2]);
  $6 = $3 + 20 | 0;
  sqlite3DbFree($11, HEAP32[$6 >> 2]);
  HEAP32[$3 + 20 >> 2] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  HEAP32[$3 + 16 >> 2] = 0;
  HEAP32[$14 + 28 >> 2] = 0;
  while (1) {
   $9 = HEAP32[$4 >> 2];
   if ($9) {
    $6 = HEAP32[$1 + 52 >> 2];
    $5 = HEAP32[$3 + 24 >> 2];
    $7 = HEAP32[$1 + 60 >> 2];
    $17 = HEAP32[$1 + 48 >> 2];
    HEAP32[$3 + 24 >> 2] = 0;
    HEAP32[$1 + 60 >> 2] = 0;
    HEAP32[$1 + 48 >> 2] = 0;
    HEAP32[$1 + 52 >> 2] = 0;
    $4 = sqlite3SelectDup($11, $1, 0);
    HEAP32[$1 + 48 >> 2] = $17;
    HEAP32[$1 + 60 >> 2] = $7;
    HEAP8[$1 | 0] = 135;
    HEAP32[$3 + 24 >> 2] = $5;
    label$22: {
     if (!$4) {
      $4 = $6;
      break label$22;
     }
     $5 = HEAP32[$0 + 100 >> 2] + 1 | 0;
     HEAP32[$0 + 100 >> 2] = $5;
     HEAP32[$4 + 16 >> 2] = $5;
     if (!(HEAPU8[$11 + 87 | 0] | !$8)) {
      renumberCursors($0, $4, $2, $8);
     }
     HEAP32[$4 + 52 >> 2] = $6;
     if ($6) {
      HEAP32[$6 + 56 >> 2] = $4;
     }
     HEAP32[$4 + 56 >> 2] = $1;
    }
    HEAP32[$1 + 52 >> 2] = $4;
    $4 = $9 + 52 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFree($11, $8);
  label$26: {
   if (HEAPU8[$11 + 87 | 0]) {
    HEAP32[$14 + 28 >> 2] = $19;
    break label$26;
   }
   $4 = HEAP32[$3 + 24 >> 2];
   if ($4) {
    $6 = HEAP32[$4 + 24 >> 2];
    label$29: {
     if (($6 | 0) == 1) {
      $6 = HEAP32[$0 + 116 >> 2];
      sqlite3ParserAddCleanup($6 ? $6 : $0, 48, $4);
      break label$29;
     }
     HEAP32[$4 + 24 >> 2] = $6 - 1;
    }
    HEAP32[$3 + 24 >> 2] = 0;
   }
   $23 = $2 + 1 | 0;
   $18 = $2 << 6;
   $3 = -1;
   $8 = $19;
   $7 = $1;
   while (1) {
    label$32: {
     if (!$7) {
      break label$32;
     }
     $5 = $10 + $18 | 0;
     $13 = HEAP32[$8 + 32 >> 2];
     $6 = HEAP32[$13 >> 2];
     $15 = 0;
     $15 = ($1 | 0) == ($7 | 0) ? HEAPU8[$20 + 44 | 0] : $15;
     $4 = HEAPU8[$5 + 44 | 0];
     $10 = HEAP32[$7 + 32 >> 2];
     if (($6 | 0) >= 2) {
      $10 = sqlite3SrcListEnlarge($0, $10, $6 - 1 | 0, $23);
      if (!$10) {
       break label$32;
      }
      HEAP32[$7 + 32 >> 2] = $10;
     }
     $17 = $4 & 64;
     $4 = 0;
     $9 = ($6 | 0) > 0 ? $6 : 0;
     while (1) {
      if (($4 | 0) != ($9 | 0)) {
       $3 = ($2 + $4 << 6) + $10 | 0;
       $6 = $3;
       $5 = $3 + 8 | 0;
       if (HEAPU8[$3 + 46 | 0] & 4) {
        sqlite3IdListDelete($11, HEAP32[$3 + 52 >> 2]);
       }
       $3 = ($4 << 6) + $13 | 0;
       $14 = $3 + 8 | 0;
       __memcpy($5, $14, 64);
       HEAP8[$6 + 44 | 0] = HEAPU8[$6 + 44 | 0] | $17;
       $3 = HEAP32[$3 + 48 >> 2];
       memset($14, 0, 64);
       $4 = $4 + 1 | 0;
       continue;
      }
      break;
     }
     $5 = $10 + $18 | 0;
     $4 = $5 + 44 | 0;
     HEAP8[$4 | 0] = HEAPU8[$5 + 44 | 0] & 64 | $15 | $17;
     $6 = HEAP32[$8 + 48 >> 2];
     if (!(!$6 | HEAPU8[$7 + 6 | 0] & 64)) {
      $5 = HEAP32[$6 >> 2];
      $4 = 0;
      while (1) {
       if (($4 | 0) < ($5 | 0)) {
        HEAP16[(($4 << 4) + $6 | 0) + 20 >> 1] = 0;
        $4 = $4 + 1 | 0;
        continue;
       }
       break;
      }
      HEAP32[$7 + 48 >> 2] = $6;
      HEAP32[$8 + 48 >> 2] = 0;
     }
     $4 = HEAP32[$8 + 36 >> 2];
     HEAP32[$8 + 36 >> 2] = 0;
     if ($16) {
      sqlite3SetJoinExpr($4, $3, 1);
     }
     if ($4) {
      $6 = HEAP32[$7 + 36 >> 2];
      if ($6) {
       $4 = sqlite3PExpr($0, 44, $4, $6);
      }
      HEAP32[$7 + 36 >> 2] = $4;
     }
     if (!HEAPU8[$11 + 87 | 0]) {
      HEAP32[$12 + 12 >> 2] = $22;
      HEAP32[$12 + 8 >> 2] = $3;
      HEAP32[$12 + 4 >> 2] = $21;
      HEAP32[$12 >> 2] = $0;
      HEAP32[$12 + 16 >> 2] = HEAP32[$8 + 28 >> 2];
      substSelect($12, $7, 0);
     }
     HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] | HEAP32[$8 + 4 >> 2] & 256;
     $4 = HEAP32[$8 + 60 >> 2];
     if ($4) {
      HEAP32[$7 + 60 >> 2] = $4;
      HEAP32[$8 + 60 >> 2] = 0;
     }
     $4 = 0;
     while (1) {
      if (($4 | 0) != ($9 | 0)) {
       recomputeColumnsUsed($7, (($2 + $4 << 6) + $10 | 0) + 8 | 0);
       $4 = $4 + 1 | 0;
       continue;
      }
      break;
     }
     $8 = HEAP32[$8 + 52 >> 2];
     $7 = HEAP32[$7 + 52 >> 2];
     continue;
    }
    break;
   }
   sqlite3AggInfoPersistWalkerInit($12, $0);
   sqlite3WalkSelect($12, $19);
   sqlite3SelectDelete($11, $19);
  }
  $4 = 1;
 }
 __stack_pointer = $12 + 32 | 0;
 return $4;
}

function multiSelect($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $5 = __stack_pointer - 96 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$1 + 52 >> 2];
 $10 = HEAP32[$0 >> 2];
 HEAP32[$5 + 88 >> 2] = HEAP32[$2 + 24 >> 2];
 $6 = HEAP32[$2 + 20 >> 2];
 $4 = HEAP32[$2 + 16 >> 2];
 HEAP32[$5 + 80 >> 2] = $4;
 HEAP32[$5 + 84 >> 2] = $6;
 $4 = HEAP32[$2 + 12 >> 2];
 $6 = HEAP32[$2 + 8 >> 2];
 HEAP32[$5 + 72 >> 2] = $6;
 HEAP32[$5 + 76 >> 2] = $4;
 $6 = HEAP32[$2 + 4 >> 2];
 $4 = HEAP32[$2 >> 2];
 HEAP32[$5 + 64 >> 2] = $4;
 HEAP32[$5 + 68 >> 2] = $6;
 $7 = sqlite3GetVdbe($0);
 if (HEAPU8[$5 + 64 | 0] == 12) {
  sqlite3VdbeAddOp2($7, 118, HEAP32[$5 + 68 >> 2], HEAP32[HEAP32[$1 + 28 >> 2] >> 2]);
  HEAP8[$5 + 64 | 0] = 14;
 }
 label$2: {
  label$3: {
   $4 = HEAP32[$1 + 4 >> 2];
   if ($4 & 1024) {
    $9 = multiSelectValues($0, $1, $5 - -64 | 0);
    if (($9 | 0) >= 0) {
     break label$3;
    }
    $4 = HEAP32[$1 + 4 >> 2];
   }
   label$5: {
    label$6: {
     if (!($4 & 8192)) {
      break label$6;
     }
     if (!hasAnchor($1)) {
      break label$6;
     }
     generateWithRecursiveQuery($0, $1, $5 - -64 | 0);
     $9 = 0;
     break label$5;
    }
    if (HEAP32[$1 + 48 >> 2]) {
     $9 = multiSelectOrderBy($0, $1, $2);
     break label$2;
    }
    if (!HEAP32[$3 + 52 >> 2]) {
     sqlite3VdbeExplain($0, 1, 17915, 0);
     sqlite3VdbeExplain($0, 1, 17896, 0);
    }
    label$9: {
     label$10: {
      switch (HEAPU8[$1 | 0] - 134 | 0) {
      case 1:
       HEAP32[$5 + 32 >> 2] = 0;
       HEAP32[$3 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
       HEAP32[$3 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
       HEAP32[$3 + 60 >> 2] = HEAP32[$1 + 60 >> 2];
       $9 = sqlite3Select($0, $3, $5 - -64 | 0);
       HEAP32[$3 + 60 >> 2] = 0;
       if ($9) {
        break label$3;
       }
       HEAP32[$1 + 52 >> 2] = 0;
       $6 = HEAP32[$3 + 8 >> 2];
       HEAP32[$1 + 8 >> 2] = $6;
       HEAP32[$1 + 12 >> 2] = HEAP32[$3 + 12 >> 2];
       $4 = 0;
       label$13: {
        if (!$6) {
         break label$13;
        }
        $4 = sqlite3VdbeAddOp1($7, 16, $6);
        $6 = HEAP32[$1 + 12 >> 2];
        if (!$6) {
         break label$13;
        }
        sqlite3VdbeAddOp3($7, 160, HEAP32[$1 + 8 >> 2], $6 + 1 | 0, $6);
       }
       sqlite3VdbeExplain($0, 1, 19651, 0);
       $9 = sqlite3Select($0, $1, $5 - -64 | 0);
       $12 = HEAP32[$1 + 52 >> 2];
       HEAP32[$1 + 52 >> 2] = $3;
       $6 = sqlite3LogEstAdd(HEAP16[$1 + 2 >> 1], HEAP16[$3 + 2 >> 1]);
       HEAP16[$1 + 2 >> 1] = $6;
       $3 = HEAP32[$1 + 60 >> 2];
       label$14: {
        if (!$3) {
         break label$14;
        }
        if (!sqlite3ExprIsInteger(HEAP32[$3 + 12 >> 2], $5 + 32 | 0)) {
         break label$14;
        }
        $3 = HEAP32[$5 + 32 >> 2];
        if (($3 | 0) <= 0) {
         break label$14;
        }
        $3 = sqlite3LogEst($3, 0);
        if (($6 | 0) <= ($3 | 0)) {
         break label$14;
        }
        HEAP16[$1 + 2 >> 1] = $3;
       }
       if (!$4) {
        break label$9;
       }
       sqlite3VdbeJumpHere($7, $4);
       break label$9;

      case 0:
      case 2:
       label$15: {
        if (HEAPU8[$5 + 64 | 0] == 1) {
         $4 = HEAP32[$5 + 68 >> 2];
         break label$15;
        }
        $4 = HEAP32[$0 + 40 >> 2];
        HEAP32[$0 + 40 >> 2] = $4 + 1;
        HEAP32[$1 + 20 >> 2] = sqlite3VdbeAddOp2($7, 118, $4, 0);
        $6 = findRightmost($1);
        HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] | 32;
       }
       sqlite3SelectDestInit($5 + 32 | 0, 1, $4);
       $9 = sqlite3Select($0, $3, $5 + 32 | 0);
       if (!$9) {
        HEAP32[$1 + 52 >> 2] = 0;
        $6 = HEAP32[$1 + 60 >> 2];
        HEAP32[$1 + 60 >> 2] = 0;
        $8 = HEAPU8[$1 | 0];
        HEAP8[$5 + 32 | 0] = ($8 | 0) == 136 ? 2 : 1;
        HEAP32[$5 + 16 >> 2] = sqlite3SelectOpName($8);
        sqlite3VdbeExplain($0, 1, 19821, $5 + 16 | 0);
        $9 = sqlite3Select($0, $1, $5 + 32 | 0);
        HEAP32[$1 + 48 >> 2] = 0;
        $12 = HEAP32[$1 + 52 >> 2];
        HEAP32[$1 + 52 >> 2] = $3;
        if (HEAPU8[$1 | 0] == 134) {
         HEAP16[$1 + 2 >> 1] = sqlite3LogEstAdd(HEAP16[$1 + 2 >> 1], HEAP16[$3 + 2 >> 1]);
        }
        sqlite3ExprDelete($10, HEAP32[$1 + 60 >> 2]);
        HEAP32[$1 + 8 >> 2] = 0;
        HEAP32[$1 + 12 >> 2] = 0;
        HEAP32[$1 + 60 >> 2] = $6;
        if (HEAPU8[$10 + 87 | 0] | HEAPU8[$5 + 64 | 0] == 1) {
         break label$9;
        }
        $3 = sqlite3VdbeMakeLabel($0);
        $6 = sqlite3VdbeMakeLabel($0);
        computeLimitRegisters($0, $1, $3);
        sqlite3VdbeAddOp2($7, 35, $4, $3);
        $8 = sqlite3VdbeCurrentAddr($7);
        selectInnerLoop($0, $1, $4, 0, 0, $5 - -64 | 0, $6, $3);
        sqlite3VdbeResolveLabel($7, $6);
        sqlite3VdbeAddOp2($7, 38, $4, $8);
        sqlite3VdbeResolveLabel($7, $3);
        sqlite3VdbeAddOp2($7, 122, $4, 0);
        break label$9;
       }
       break label$3;

      default:
       break label$10;
      }
     }
     $4 = HEAP32[$0 + 40 >> 2];
     HEAP32[$0 + 40 >> 2] = $4 + 2;
     HEAP32[$1 + 20 >> 2] = sqlite3VdbeAddOp2($7, 118, $4, 0);
     $6 = findRightmost($1);
     HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] | 32;
     sqlite3SelectDestInit($5 + 32 | 0, 1, $4);
     $9 = sqlite3Select($0, $3, $5 + 32 | 0);
     if ($9) {
      break label$3;
     }
     $6 = $4 + 1 | 0;
     $8 = sqlite3VdbeAddOp2($7, 118, $6, 0);
     HEAP32[$1 + 52 >> 2] = 0;
     HEAP32[$1 + 24 >> 2] = $8;
     $8 = HEAP32[$1 + 60 >> 2];
     HEAP32[$1 + 60 >> 2] = 0;
     HEAP32[$5 + 36 >> 2] = $6;
     HEAP32[$5 >> 2] = sqlite3SelectOpName(HEAPU8[$1 | 0]);
     sqlite3VdbeExplain($0, 1, 19821, $5);
     $9 = sqlite3Select($0, $1, $5 + 32 | 0);
     $12 = HEAP32[$1 + 52 >> 2];
     HEAP32[$1 + 52 >> 2] = $3;
     $3 = HEAP16[$3 + 2 >> 1];
     if (($3 | 0) < HEAP16[$1 + 2 >> 1]) {
      HEAP16[$1 + 2 >> 1] = $3;
     }
     sqlite3ExprDelete($10, HEAP32[$1 + 60 >> 2]);
     HEAP32[$1 + 60 >> 2] = $8;
     if ($9) {
      break label$9;
     }
     $3 = sqlite3VdbeMakeLabel($0);
     $8 = sqlite3VdbeMakeLabel($0);
     computeLimitRegisters($0, $1, $3);
     sqlite3VdbeAddOp2($7, 35, $4, $3);
     $11 = sqlite3GetTempReg($0);
     $13 = sqlite3VdbeAddOp2($7, 134, $4, $11);
     sqlite3VdbeAddOp4Int($7, 27, $6, $8, $11, 0);
     sqlite3ReleaseTempReg($0, $11);
     selectInnerLoop($0, $1, $4, 0, 0, $5 - -64 | 0, $8, $3);
     sqlite3VdbeResolveLabel($7, $8);
     sqlite3VdbeAddOp2($7, 38, $4, $13);
     sqlite3VdbeResolveLabel($7, $3);
     sqlite3VdbeAddOp2($7, 122, $6, 0);
     sqlite3VdbeAddOp2($7, 122, $4, 0);
    }
    if (HEAP32[$1 + 56 >> 2]) {
     break label$5;
    }
    sqlite3VdbeExplainPop($0);
   }
   if (HEAP32[$0 + 36 >> 2] | !(HEAPU8[$1 + 4 | 0] & 32)) {
    break label$3;
   }
   $11 = HEAP32[HEAP32[$1 + 28 >> 2] >> 2];
   $8 = sqlite3KeyInfoAlloc($10, $11, 1);
   if (!$8) {
    $9 = 7;
    break label$3;
   }
   $4 = 0;
   $13 = ($11 | 0) > 0 ? $11 : 0;
   $3 = $8 + 20 | 0;
   while (1) {
    if (($4 | 0) == ($13 | 0)) {
     while (1) {
      $4 = 0;
      if ($1) {
       while (1) {
        label$26: {
         if (($4 | 0) == 2) {
          break label$26;
         }
         $10 = ($4 << 2) + $1 | 0;
         $6 = $10 + 20 | 0;
         $3 = HEAP32[$6 >> 2];
         if (($3 | 0) < 0) {
          break label$26;
         }
         sqlite3VdbeChangeP2($7, $3, $11);
         sqlite3VdbeChangeP4($7, $3, sqlite3KeyInfoRef($8), -8);
         HEAP32[$10 + 20 >> 2] = -1;
         $4 = $4 + 1 | 0;
         continue;
        }
        break;
       }
       $1 = HEAP32[$1 + 52 >> 2];
       continue;
      }
      break;
     }
     sqlite3KeyInfoUnref($8);
     break label$3;
    }
    $6 = multiSelectCollSeq($0, $1, $4);
    HEAP32[$3 >> 2] = $6;
    if (!$6) {
     HEAP32[$3 >> 2] = HEAP32[$10 + 8 >> 2];
    }
    $3 = $3 + 4 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  HEAP32[$2 + 12 >> 2] = HEAP32[$5 + 76 >> 2];
  HEAP32[$2 + 16 >> 2] = HEAP32[$5 + 80 >> 2];
  if (!$12) {
   break label$2;
  }
  sqlite3ParserAddCleanup($0, 49, $12);
 }
 __stack_pointer = $5 + 96 | 0;
 return $9;
}

function sqlite3ParseUri($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $11 = __stack_pointer + -64 | 0;
 __stack_pointer = $11;
 $7 = sqlite3Strlen30($1);
 label$1: {
  label$2: {
   $17 = $5;
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        $8 = HEAP32[$2 >> 2];
        if (!(HEAPU8[64278] | $8 & 64) | ($7 | 0) < 5) {
         break label$7;
        }
        if (memcmp($1, 22453, 5)) {
         break label$7;
        }
        $10 = $7 + 8 | 0;
        while (1) {
         if (($6 | 0) != ($7 | 0)) {
          $5 = $9;
          $9 = HEAPU8[$1 + $6 | 0] == 38;
          $10 = $9 + $10 | 0;
          $5 = $9 >>> 0 > $10 >>> 0 ? $5 + 1 | 0 : $5;
          $9 = $5;
          $6 = $6 + 1 | 0;
          continue;
         }
         break;
        }
        $5 = $9;
        $6 = sqlite3_malloc64($10, $5);
        if (!$6) {
         break label$2;
        }
        $14 = $8 | 64;
        $8 = 0;
        HEAP8[$6 | 0] = 0;
        HEAP8[$6 + 1 | 0] = 0;
        HEAP8[$6 + 2 | 0] = 0;
        HEAP8[$6 + 3 | 0] = 0;
        $10 = $6 + 4 | 0;
        $7 = 5;
        if (HEAPU8[$1 + 5 | 0] != 47 | HEAPU8[$1 + 6 | 0] != 47) {
         break label$6;
        }
        $6 = 7;
        while (1) {
         $7 = HEAPU8[$1 + $6 | 0];
         if (!(!$7 | ($7 | 0) == 47)) {
          $6 = $6 + 1 | 0;
          continue;
         }
         break;
        }
        if (($6 | 0) == 7) {
         $7 = $6;
         break label$6;
        }
        $7 = 16;
        if (($6 | 0) == 16) {
         if (!memcmp(2048, $1 + 7 | 0, 9)) {
          break label$6;
         }
        }
        HEAP32[$11 + 4 >> 2] = $1 + 7;
        HEAP32[$11 >> 2] = $6 - 7;
        $6 = 1;
        $7 = sqlite3_mprintf(5705, $11);
        break label$4;
       }
       $6 = sqlite3_malloc64($7 + 8 | 0, 0);
       if (!$6) {
        break label$2;
       }
       HEAP8[$6 | 0] = 0;
       HEAP8[$6 + 1 | 0] = 0;
       HEAP8[$6 + 2 | 0] = 0;
       HEAP8[$6 + 3 | 0] = 0;
       $10 = $6 + 4 | 0;
       if ($7) {
        __memcpy($10, $1, $7);
       }
       $1 = $7 + $10 | 0;
       HEAP8[$1 | 0] = 0;
       HEAP8[$1 + 1 | 0] = 0;
       HEAP8[$1 + 2 | 0] = 0;
       HEAP8[$1 + 3 | 0] = 0;
       $14 = $8 & -65;
       break label$5;
      }
      while (1) {
       $16 = $10 + $12 | 0;
       $18 = $16 - 1 | 0;
       label$16: {
        label$17: {
         label$18: {
          label$19: {
           label$20: {
            label$21: while (1) {
             $6 = HEAPU8[$1 + $7 | 0];
             label$22: while (1) {
              $9 = $6 & 255;
              if (!$9 | ($9 | 0) == 35) {
               break label$16;
              }
              $5 = $7 + 1 | 0;
              label$23: {
               if (($9 | 0) != 37) {
                break label$23;
               }
               $13 = HEAPU8[$1 + $5 | 0];
               if (!(HEAPU8[$13 + 30288 | 0] & 8)) {
                break label$23;
               }
               $15 = HEAPU8[($1 + $7 | 0) + 2 | 0];
               if (!(HEAPU8[$15 + 30288 | 0] & 8)) {
                break label$23;
               }
               $7 = $7 + 3 | 0;
               $6 = (sqlite3HexToInt($13 << 24 >> 24) << 4) + sqlite3HexToInt($15 << 24 >> 24) | 0;
               if ($6) {
                break label$17;
               }
               while (1) {
                $6 = HEAPU8[$1 + $7 | 0];
                if (!$6 | ($6 | 0) == 35 | !$8 & ($6 | 0) == 63) {
                 continue label$22;
                }
                label$25: {
                 if (($8 | 0) == 1) {
                  if (($6 | 0) == 38 | ($6 | 0) == 61) {
                   continue label$22;
                  }
                  break label$25;
                 }
                 if (($8 | 0) != 2) {
                  break label$25;
                 }
                 if (($6 | 0) == 38) {
                  continue label$22;
                 }
                }
                $7 = $7 + 1 | 0;
                continue;
               }
              }
              break;
             }
             if (($8 | 0) != 1) {
              break label$20;
             }
             if (!(($9 | 0) == 61 | ($9 | 0) == 38)) {
              $8 = 1;
              break label$18;
             }
             if (!HEAPU8[$18 | 0]) {
              $7 = $5;
              while (1) {
               $8 = 1;
               $9 = $1 + $7 | 0;
               $6 = HEAPU8[$9 | 0];
               if (!$6 | ($6 | 0) == 35 | HEAPU8[$9 - 1 | 0] == 38) {
                continue label$21;
               }
               $7 = $7 + 1 | 0;
               continue;
              }
             }
             break;
            }
            $8 = 2;
            if (($9 | 0) != 38) {
             break label$19;
            }
            $6 = 0;
            HEAP8[$16 | 0] = 0;
            $8 = 1;
            $12 = $12 + 1 | 0;
            break label$18;
           }
           if (!(!$8 & ($9 | 0) == 63) & (($8 | 0) != 2 | ($9 | 0) != 38)) {
            break label$18;
           }
           $8 = 1;
          }
          $6 = 0;
         }
         $7 = $5;
        }
        HEAP8[$10 + $12 | 0] = $6;
        $12 = $12 + 1 | 0;
        continue;
       }
       break;
      }
      if (($8 | 0) == 1) {
       HEAP8[$16 | 0] = 0;
       $12 = $12 + 1 | 0;
      }
      $1 = $10 + $12 | 0;
      HEAP8[$1 | 0] = 0;
      HEAP8[$1 + 1 | 0] = 0;
      HEAP8[$1 + 2 | 0] = 0;
      HEAP8[$1 + 3 | 0] = 0;
      $7 = sqlite3Strlen30($10);
      $8 = $10;
      while (1) {
       $6 = ($7 + $8 | 0) + 1 | 0;
       if (!HEAPU8[$6 | 0]) {
        break label$5;
       }
       $1 = sqlite3Strlen30($6);
       $8 = ($6 + $1 | 0) + 1 | 0;
       $7 = sqlite3Strlen30($8);
       label$32: {
        label$33: {
         switch ($1 - 3 | 0) {
         case 0:
          if (memcmp(5014, $6, 3)) {
           continue;
          }
          $0 = $8;
          continue;

         case 2:
          $13 = 13883;
          if (memcmp(13883, $6, 5)) {
           continue;
          }
          $15 = 393216;
          $12 = -393217;
          $9 = 49600;
          break label$32;

         case 1:
          break label$33;

         default:
          continue;
         }
        }
        if ((HEAPU8[$6 | 0] | HEAPU8[$6 + 1 | 0] << 8 | (HEAPU8[$6 + 2 | 0] << 16 | HEAPU8[$6 + 3 | 0] << 24)) != 1701080941) {
         continue;
        }
        $15 = $14 & 135;
        $13 = 4155;
        $12 = -136;
        $9 = 49632;
       }
       $6 = 0;
       label$36: {
        label$37: {
         while (1) {
          $5 = ($6 << 3) + $9 | 0;
          $1 = HEAP32[$5 >> 2];
          if (!$1) {
           break label$37;
          }
          label$39: {
           if ((sqlite3Strlen30($1) | 0) == ($7 | 0)) {
            if (!memcmp($8, $1, $7)) {
             break label$39;
            }
           }
           $6 = $6 + 1 | 0;
           continue;
          }
          break;
         }
         $6 = HEAP32[$5 + 4 >> 2];
         if ($6) {
          break label$36;
         }
        }
        HEAP32[$11 + 36 >> 2] = $8;
        HEAP32[$11 + 32 >> 2] = $13;
        $6 = 1;
        $7 = sqlite3_mprintf(7953, $11 + 32 | 0);
        break label$4;
       }
       if (($6 & -129) > ($15 | 0)) {
        HEAP32[$11 + 52 >> 2] = $8;
        HEAP32[$11 + 48 >> 2] = $13;
        $6 = 3;
        $7 = sqlite3_mprintf(8078, $11 + 48 | 0);
        break label$4;
       } else {
        $14 = $12 & $14 | $6;
        continue;
       }
      }
     }
     $7 = sqlite3_vfs_find($0);
     HEAP32[$3 >> 2] = $7;
     $6 = 0;
     if ($7) {
      break label$3;
     }
     HEAP32[$11 + 16 >> 2] = $0;
     $6 = 1;
     $7 = sqlite3_mprintf(7159, $11 + 16 | 0);
    }
    HEAP32[$17 >> 2] = $7;
    sqlite3_free_filename($10);
    $10 = 0;
   }
   HEAP32[$2 >> 2] = $14;
   HEAP32[$4 >> 2] = $10;
   break label$1;
  }
  $6 = 7;
 }
 __stack_pointer = $11 - -64 | 0;
 return $6;
}

function fts3IncrmergeLoad($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $8 = __stack_pointer - 80 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 72 >> 2] = 0;
 $9 = fts3SqlStmt($0, 32, $8 + 72 | 0, 0);
 label$1: {
  if ($9) {
   break label$1;
  }
  HEAP32[$8 + 64 >> 2] = 0;
  HEAP32[$8 + 68 >> 2] = 0;
  HEAP32[$8 + 60 >> 2] = 0;
  $12 = $2;
  $7 = $1;
  $11 = $7 + 1 | 0;
  $13 = $11 ? $12 : $12 + 1 | 0;
  $16 = HEAP32[$8 + 72 >> 2];
  sqlite3_bind_int64($16, 1, $11, $13);
  sqlite3_bind_int($16, 2, $3);
  label$2: {
   if ((sqlite3_step($16) | 0) == 100) {
    $13 = sqlite3_column_int64($16, 1);
    $19 = $13;
    $7 = i64toi32_i32$HIGH_BITS;
    $20 = $7;
    $7 = sqlite3_column_int64($16, 2);
    $21 = $7;
    $13 = i64toi32_i32$HIGH_BITS;
    $22 = $13;
    $9 = $6 + 40 | 0;
    fts3ReadEndBlockField($16, 3, $8 - -64 | 0, $9);
    $12 = $6;
    $13 = HEAP32[$12 + 40 >> 2];
    $17 = $13;
    $7 = HEAP32[$12 + 44 >> 2];
    $18 = $7;
    if (($7 | 0) < 0) {
     $13 = $17;
     $10 = 0 - $13 | 0;
     $17 = $10;
     $7 = $18;
     $11 = $7 + (($13 | 0) != 0) | 0;
     $11 = 0 - $11 | 0;
     $18 = $11;
     $14 = $6;
     HEAP32[$14 + 40 >> 2] = $10;
     HEAP32[$14 + 44 >> 2] = $11;
    }
    $11 = $18;
    HEAP8[$6 + 48 | 0] = !($11 | $17);
    $15 = sqlite3_column_bytes($16, 4);
    $23 = sqlite3_column_blob($16, 4);
    if (!$23) {
     sqlite3_reset($16);
     $9 = $15 ? 7 : 267;
     break label$1;
    }
    $14 = HEAP32[$8 + 68 >> 2];
    $10 = $14;
    $11 = HEAP32[$8 + 64 >> 2];
    $7 = $11;
    $9 = fts3IsAppendable($0, $11, $14, $8 + 60 | 0);
    HEAP32[$8 + 76 >> 2] = $9;
    $11 = HEAP32[$8 + 60 >> 2];
    if (!(!$11 | $9)) {
     HEAP32[$8 + 56 >> 2] = 0;
     HEAP32[$8 + 52 >> 2] = 0;
     $14 = $22;
     $9 = sqlite3Fts3ReadBlock($0, $21, $14, $8 + 56 | 0, $8 + 52 | 0);
     HEAP32[$8 + 76 >> 2] = $9;
     if (!$9) {
      $9 = nodeReaderInit($8, HEAP32[$8 + 56 >> 2], HEAP32[$8 + 52 >> 2]);
      while (1) {
       if (!(!HEAP32[$8 >> 2] | $9)) {
        $9 = nodeReaderNext($8);
        continue;
       }
       break;
      }
      HEAP32[$8 + 76 >> 2] = $9;
      if ((fts3TermCmp($4, $5, HEAP32[$8 + 24 >> 2], HEAP32[$8 + 28 >> 2]) | 0) <= 0) {
       HEAP32[$8 + 60 >> 2] = 0;
       $11 = 0;
      }
      nodeReaderRelease($8);
     }
     sqlite3_free(HEAP32[$8 + 56 >> 2]);
    }
    if ($9) {
     $4 = $9;
     break label$2;
    }
    $4 = $9;
    if (!$11) {
     break label$2;
    }
    $5 = HEAP8[$23 | 0];
    if (($5 - 16 & 255) >>> 0 <= 240) {
     sqlite3_reset($16);
     $9 = 267;
     break label$1;
    }
    $12 = $5;
    $17 = $12 & 255;
    $18 = 0;
    $12 = $6;
    HEAP32[$12 + 32 >> 2] = $7;
    $11 = $10;
    HEAP32[$12 + 36 >> 2] = $11;
    HEAP32[$12 + 24 >> 2] = $19;
    $11 = $20;
    HEAP32[$12 + 28 >> 2] = $11;
    HEAP32[$12 + 16 >> 2] = $3;
    HEAP32[$12 + 8 >> 2] = $1;
    $11 = $2;
    HEAP32[$12 + 12 >> 2] = $11;
    $14 = $7;
    $13 = $19;
    $7 = $14 - $13 | 0;
    $11 = $10;
    $12 = $20;
    $10 = $12 + ($13 >>> 0 > $14 >>> 0) | 0;
    $9 = ($7 + 1 | 0) / 16 | 0;
    HEAP32[$6 >> 2] = $9;
    $1 = ($5 | 0) > 15 ? $5 : 15;
    $21 = $9;
    $10 = $9 >> 31;
    $22 = $10;
    while (1) {
     $14 = $18;
     $11 = $1;
     $13 = $17;
     if (!(!$14 & ($11 | 0) == ($13 | 0))) {
      $11 = $18;
      $7 = $11;
      $12 = $17 + 1 | 0;
      $7 = $12 ? $7 : $7 + 1 | 0;
      $17 = $12;
      $18 = $7;
      $13 = $22;
      $13 = __wasm_i64_mul($12, $7, $21, $13);
      $14 = $13;
      $7 = i64toi32_i32$HIGH_BITS;
      $13 = $7;
      $7 = $20;
      $12 = $7 + $13 | 0;
      $11 = $19;
      $10 = $14 + $11 | 0;
      $12 = $10 >>> 0 < $14 >>> 0 ? $12 + 1 | 0 : $12;
      $11 = ($17 << 5) + $6 | 0;
      HEAP32[$11 + 56 >> 2] = $10;
      HEAP32[$11 + 60 >> 2] = $12;
      continue;
     }
     break;
    }
    $11 = Math_imul($5, $9);
    $12 = $11 >> 31;
    $14 = $11;
    $11 = $12;
    $12 = $20;
    $10 = $12 + $11 | 0;
    $7 = $19;
    $13 = $7 + $14 | 0;
    $4 = ($5 << 5) + $6 | 0;
    $7 = $4;
    HEAP32[$7 + 56 >> 2] = $13;
    $10 = $13 >>> 0 < $14 >>> 0 ? $10 + 1 | 0 : $10;
    HEAP32[$7 + 60 >> 2] = $10;
    $3 = $7 + 76 | 0;
    $9 = HEAP32[$0 + 232 >> 2];
    blobGrowBuffer($3, (($9 | 0) < ($15 | 0) ? $15 : $9) + 20 | 0, $8 + 76 | 0);
    $9 = HEAP32[$8 + 76 >> 2];
    if (!$9) {
     __memcpy(HEAP32[$7 + 76 >> 2], $23, $15);
     HEAP32[$4 + 80 >> 2] = $15;
     $4 = HEAP32[$7 + 76 >> 2] + $15 | 0;
     $7 = $4;
     HEAP8[$7 | 0] = 0;
     HEAP8[$7 + 1 | 0] = 0;
     HEAP8[$7 + 2 | 0] = 0;
     HEAP8[$7 + 3 | 0] = 0;
     HEAP8[$7 + 4 | 0] = 0;
     HEAP8[$7 + 5 | 0] = 0;
     HEAP8[$7 + 6 | 0] = 0;
     HEAP8[$7 + 7 | 0] = 0;
     HEAP8[$7 + 16 | 0] = 0;
     HEAP8[$7 + 17 | 0] = 0;
     HEAP8[$7 + 18 | 0] = 0;
     HEAP8[$7 + 19 | 0] = 0;
     HEAP8[$7 + 8 | 0] = 0;
     HEAP8[$7 + 9 | 0] = 0;
     HEAP8[$7 + 10 | 0] = 0;
     HEAP8[$7 + 11 | 0] = 0;
     HEAP8[$7 + 12 | 0] = 0;
     HEAP8[$7 + 13 | 0] = 0;
     HEAP8[$7 + 14 | 0] = 0;
     HEAP8[$7 + 15 | 0] = 0;
    }
    $4 = $9;
    while (1) {
     if (($5 | 0) < 0 | $4) {
      break label$2;
     }
     label$17: {
      label$18: {
       $3 = ($5 << 5) + $6 | 0;
       $4 = HEAP32[$3 + 76 >> 2];
       if (!$4) {
        break label$18;
       }
       $9 = nodeReaderInit($8, $4, HEAP32[$3 + 80 >> 2]);
       while (1) {
        if (!(!HEAP32[$8 >> 2] | $9)) {
         $9 = nodeReaderNext($8);
         continue;
        }
        break;
       }
       HEAP32[$8 + 76 >> 2] = $9;
       $11 = $3 - -64 | 0;
       $15 = HEAP32[$8 + 28 >> 2];
       blobGrowBuffer($11, $15, $8 + 76 | 0);
       $9 = HEAP32[$8 + 76 >> 2];
       $4 = $9;
       if ($9) {
        break label$17;
       }
       if (($15 | 0) > 0) {
        __memcpy(HEAP32[$11 >> 2], HEAP32[$8 + 24 >> 2], $15);
       }
       HEAP32[$3 + 68 >> 2] = $15;
       if (($5 | 0) <= 0) {
        $9 = 0;
        break label$18;
       }
       HEAP32[$8 + 56 >> 2] = 0;
       HEAP32[$8 + 52 >> 2] = 0;
       $10 = HEAP32[$8 + 16 >> 2];
       $17 = $10;
       $7 = HEAP32[$8 + 20 >> 2];
       $3 = ($5 - 1 << 5) + $6 | 0;
       $10 = $3;
       HEAP32[$10 + 56 >> 2] = $17;
       HEAP32[$10 + 60 >> 2] = $7;
       HEAP32[$8 + 76 >> 2] = sqlite3Fts3ReadBlock($0, $17, $7, $8 + 56 | 0, $8 + 52 | 0);
       $15 = $10 + 76 | 0;
       $4 = HEAP32[$8 + 52 >> 2];
       $9 = HEAP32[$0 + 232 >> 2];
       blobGrowBuffer($15, (($4 | 0) > ($9 | 0) ? $4 : $9) + 20 | 0, $8 + 76 | 0);
       $9 = HEAP32[$8 + 76 >> 2];
       if (!$9) {
        __memcpy(HEAP32[$10 + 76 >> 2], HEAP32[$8 + 56 >> 2], $4);
        HEAP32[$3 + 80 >> 2] = $4;
        $4 = HEAP32[$10 + 76 >> 2] + $4 | 0;
        $10 = $4;
        HEAP8[$10 | 0] = 0;
        HEAP8[$10 + 1 | 0] = 0;
        HEAP8[$10 + 2 | 0] = 0;
        HEAP8[$10 + 3 | 0] = 0;
        HEAP8[$10 + 4 | 0] = 0;
        HEAP8[$10 + 5 | 0] = 0;
        HEAP8[$10 + 6 | 0] = 0;
        HEAP8[$10 + 7 | 0] = 0;
        HEAP8[$10 + 16 | 0] = 0;
        HEAP8[$10 + 17 | 0] = 0;
        HEAP8[$10 + 18 | 0] = 0;
        HEAP8[$10 + 19 | 0] = 0;
        HEAP8[$10 + 8 | 0] = 0;
        HEAP8[$10 + 9 | 0] = 0;
        HEAP8[$10 + 10 | 0] = 0;
        HEAP8[$10 + 11 | 0] = 0;
        HEAP8[$10 + 12 | 0] = 0;
        HEAP8[$10 + 13 | 0] = 0;
        HEAP8[$10 + 14 | 0] = 0;
        HEAP8[$10 + 15 | 0] = 0;
       }
       sqlite3_free(HEAP32[$8 + 56 >> 2]);
       $4 = $9;
       break label$17;
      }
      $4 = 0;
     }
     $5 = $5 - 1 | 0;
     nodeReaderRelease($8);
     continue;
    }
   }
   $9 = sqlite3_reset($16);
   break label$1;
  }
  $9 = (wasm2js_i32$0 = $9, wasm2js_i32$1 = sqlite3_reset($16), wasm2js_i32$2 = $4, 
  wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
 }
 __stack_pointer = $8 + 80 | 0;
 return $9;
}

function xferOptimization($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 label$1: {
  label$2: {
   if (HEAP32[$0 + 264 >> 2] | HEAP32[$2 + 64 >> 2] | HEAPU8[$1 + 43 | 0] == 1) {
    break label$2;
   }
   label$3: {
    if (($3 | 0) != 11) {
     break label$3;
    }
    if (HEAP16[$1 + 32 >> 1] >= 0) {
     $3 = HEAPU8[$1 + 42 | 0];
     if (($3 | 0) != 11) {
      break label$3;
     }
    }
    $3 = 2;
   }
   $5 = HEAP32[$2 + 32 >> 2];
   if (HEAP32[$5 >> 2] != 1 | HEAP32[$5 + 28 >> 2] | (HEAP32[$2 + 36 >> 2] | HEAP32[$2 + 48 >> 2])) {
    break label$2;
   }
   if (HEAP32[$2 + 40 >> 2] | HEAP32[$2 + 60 >> 2] | (HEAP32[$2 + 52 >> 2] | HEAP8[$2 + 4 | 0] & 1)) {
    break label$2;
   }
   $2 = HEAP32[$2 + 28 >> 2];
   if (HEAP32[$2 >> 2] != 1 | HEAPU8[HEAP32[$2 + 8 >> 2]] != 180) {
    break label$2;
   }
   $11 = HEAP32[$0 >> 2];
   $2 = sqlite3LocateTableItem($0, 0, $5 + 8 | 0);
   if (!$2 | HEAP32[$2 + 20 >> 2] == HEAP32[$1 + 20 >> 2] & HEAP32[$2 + 60 >> 2] == HEAP32[$1 + 60 >> 2]) {
    break label$2;
   }
   $5 = HEAP32[$1 + 28 >> 2];
   $7 = HEAP32[$2 + 28 >> 2];
   if (HEAPU8[$2 + 43 | 0] | ($5 ^ $7) & 128) {
    break label$2;
   }
   $8 = HEAPU16[$1 + 34 >> 1];
   if (HEAPU16[$1 + 32 >> 1] != HEAPU16[$2 + 32 >> 1] | ($7 & 65536 ? 0 : $5 & 65536) | ($8 | 0) != HEAPU16[$2 + 34 >> 1]) {
    break label$2;
   }
   $7 = 0;
   while (1) {
    if ($8 << 16 >> 16 > ($7 | 0)) {
     $6 = Math_imul($7, 12);
     $5 = $6 + HEAP32[$1 + 4 >> 2] | 0;
     $14 = HEAPU16[$5 + 10 >> 1] & 96;
     $8 = HEAP32[$2 + 4 >> 2] + $6 | 0;
     if (($14 | 0) != (HEAPU16[$8 + 10 >> 1] & 96)) {
      break label$1;
     }
     if ($14) {
      if (sqlite3ExprCompare(0, sqlite3ColumnExpr($2, $8), sqlite3ColumnExpr($1, $5), -1)) {
       break label$2;
      }
     }
     if (HEAPU8[$5 + 5 | 0] != HEAPU8[$8 + 5 | 0]) {
      break label$1;
     }
     if (sqlite3_stricmp(sqlite3ColumnColl($5), sqlite3ColumnColl($8))) {
      break label$1;
     }
     if (HEAPU8[$5 + 4 | 0] & 15) {
      if (!(HEAPU8[$8 + 4 | 0] & 15)) {
       break label$2;
      }
     }
     label$10: {
      if (!$7 | HEAPU8[$5 + 10 | 0] & 96) {
       break label$10;
      }
      $5 = sqlite3ColumnExpr($1, $5);
      $8 = sqlite3ColumnExpr($2, $8);
      if ((($5 | 0) != 0 | 0) == (!$8 | 0)) {
       break label$2;
      }
      if (!$5) {
       break label$10;
      }
      if (strcmp(HEAP32[$5 + 8 >> 2], HEAP32[$8 + 8 >> 2])) {
       break label$2;
      }
     }
     $7 = $7 + 1 | 0;
     $8 = HEAPU16[$1 + 34 >> 1];
     continue;
    }
    break;
   }
   $14 = $2 + 8 | 0;
   $8 = 0;
   $13 = $1 + 8 | 0;
   $6 = $13;
   while (1) {
    $7 = HEAP32[$6 >> 2];
    if ($7) {
     $8 = HEAPU8[$7 + 54 | 0] ? 1 : $8;
     $5 = $14;
     while (1) {
      $5 = HEAP32[$5 >> 2];
      if (!$5) {
       break label$2;
      }
      if (!xferCompatibleIndex($7, $5)) {
       $5 = $5 + 20 | 0;
       continue;
      }
      break;
     }
     if (!(HEAP32[$5 + 44 >> 2] != HEAP32[$7 + 44 >> 2] | HEAP32[$2 + 60 >> 2] != HEAP32[$1 + 60 >> 2])) {
      if (!sqlite3FaultSim(411)) {
       break label$2;
      }
     }
     $6 = $7 + 20 | 0;
     continue;
    }
    break;
   }
   $5 = HEAP32[$1 + 16 >> 2];
   if ($5) {
    if (sqlite3ExprListCompare(HEAP32[$2 + 16 >> 2], $5, -1)) {
     break label$2;
    }
   }
   $6 = HEAP32[$11 + 36 >> 2];
   label$17: {
    if (HEAP32[$11 + 32 >> 2] & 16384) {
     if (HEAP32[$1 + 48 >> 2]) {
      break label$2;
     }
     if (!($6 & 1)) {
      break label$17;
     }
     break label$2;
    }
    if ($6 & 1) {
     break label$2;
    }
   }
   $16 = sqlite3SchemaToIndex($11, HEAP32[$2 + 60 >> 2]);
   $5 = sqlite3GetVdbe($0);
   sqlite3CodeVerifySchema($0, $16);
   $9 = HEAP32[$0 + 40 >> 2];
   HEAP32[$0 + 40 >> 2] = $9 + 2;
   $6 = autoIncBegin($0, $4, $1);
   $15 = sqlite3GetTempReg($0);
   sqlite3VdbeAddOp2($5, 75, 0, $15);
   $12 = sqlite3GetTempReg($0);
   $10 = $9 + 1 | 0;
   sqlite3OpenTable($0, $10, $4, $1, 113);
   if (!(HEAPU8[$11 + 24 | 0] & 4 | !($8 | (HEAP32[$1 + 8 >> 2] ? HEAP16[$1 + 32 >> 1] < 0 : 0)) & $3 - 3 >>> 0 > 4294967293)) {
    $7 = sqlite3VdbeAddOp2($5, 35, $10, 0);
    $17 = sqlite3VdbeAddOp0($5, 8);
    sqlite3VdbeJumpHere($5, $7);
   }
   label$22: {
    if (!(HEAPU8[$2 + 28 | 0] & 128)) {
     sqlite3OpenTable($0, $9, $16, $2, 112);
     $18 = sqlite3VdbeAddOp2($5, 35, $9, 0);
     label$24: {
      if (HEAP16[$1 + 32 >> 1] >= 0) {
       $7 = sqlite3VdbeAddOp2($5, 135, $9, $12);
       if (!(HEAPU8[$11 + 24 | 0] & 4)) {
        $8 = sqlite3VdbeAddOp3($5, 30, $10, 0, $12);
        sqlite3RowidConstraint($0, $3, $1);
        sqlite3VdbeJumpHere($5, $8);
       }
       autoIncStep($0, $6, $12);
       break label$24;
      }
      if (!(HEAP32[$1 + 8 >> 2] | HEAPU8[$11 + 24 | 0] & 8)) {
       $7 = sqlite3VdbeAddOp2($5, 127, $10, $12);
       break label$24;
      }
      $7 = sqlite3VdbeAddOp2($5, 135, $9, $12);
     }
     $6 = 169;
     if (HEAPU8[$11 + 24 | 0] & 4) {
      sqlite3VdbeAddOp1($5, 137, $10);
      $6 = 152;
     }
     sqlite3VdbeAddOp3($5, 129, $10, $9, $12);
     sqlite3VdbeAddOp3($5, 128, $10, $15, $12);
     if (!(HEAPU8[$11 + 24 | 0] & 4)) {
      sqlite3VdbeChangeP4($5, -1, $1, -5);
     }
     sqlite3VdbeChangeP5($5, $6);
     sqlite3VdbeAddOp2($5, 38, $9, $7);
     sqlite3VdbeAddOp2($5, 122, $9, 0);
     sqlite3VdbeAddOp2($5, 122, $10, 0);
     break label$22;
    }
    sqlite3TableLock($0, $4, HEAP32[$1 + 20 >> 2], 1, HEAP32[$1 >> 2]);
    sqlite3TableLock($0, $16, HEAP32[$2 + 20 >> 2], 0, HEAP32[$2 >> 2]);
   }
   while (1) {
    $6 = $14;
    label$31: {
     label$32: {
      $3 = HEAP32[$13 >> 2];
      if ($3) {
       while (1) {
        label$35: {
         $6 = HEAP32[$6 >> 2];
         if (!$6) {
          break label$35;
         }
         if (xferCompatibleIndex($3, $6)) {
          break label$35;
         }
         $6 = $6 + 20 | 0;
         continue;
        }
        break;
       }
       sqlite3VdbeAddOp3($5, 112, $9, HEAP32[$6 + 44 >> 2], $16);
       sqlite3VdbeSetP4KeyInfo($0, $6);
       sqlite3VdbeAddOp3($5, 113, $10, HEAP32[$3 + 44 >> 2], $4);
       sqlite3VdbeSetP4KeyInfo($0, $3);
       sqlite3VdbeChangeP5($5, 1);
       $13 = sqlite3VdbeAddOp2($5, 35, $9, 0);
       label$36: {
        label$37: {
         if (HEAPU8[$11 + 24 | 0] & 4) {
          $7 = HEAPU16[$6 + 52 >> 1];
          $1 = 0;
          while (1) {
           $8 = ($1 | 0) == ($7 | 0);
           if ($8) {
            break label$32;
           }
           if (sqlite3_stricmp(32384, HEAP32[HEAP32[$6 + 32 >> 2] + ($1 << 2) >> 2])) {
            break label$37;
           }
           $1 = $1 + 1 | 0;
           continue;
          }
         }
         $6 = 8;
         if (!(HEAPU8[$2 + 28 | 0] & 128)) {
          break label$36;
         }
         $6 = ((HEAPU8[$3 + 55 | 0] | HEAPU8[$3 + 56 | 0] << 8) & 3) == 2 ? 9 : 8;
         break label$36;
        }
        $6 = 8;
        if ($8) {
         break label$32;
        }
       }
       sqlite3VdbeAddOp3($5, 134, $9, $15, 1);
       break label$31;
      }
      if ($18) {
       sqlite3VdbeJumpHere($5, $18);
      }
      sqlite3ReleaseTempReg($0, $12);
      sqlite3ReleaseTempReg($0, $15);
      if (!$17) {
       return 1;
      }
      sqlite3AutoincrementEnd($0);
      sqlite3VdbeAddOp2($5, 70, 0, 0);
      sqlite3VdbeJumpHere($5, $17);
      sqlite3VdbeAddOp2($5, 122, $10, 0);
      break label$2;
     }
     sqlite3VdbeAddOp1($5, 137, $10);
     sqlite3VdbeAddOp2($5, 129, $10, $9);
     $6 = 152;
    }
    sqlite3VdbeAddOp2($5, 138, $10, $15);
    sqlite3VdbeChangeP5($5, $6);
    sqlite3VdbeAddOp2($5, 38, $9, $13 + 1 | 0);
    sqlite3VdbeJumpHere($5, $13);
    sqlite3VdbeAddOp2($5, 122, $9, 0);
    sqlite3VdbeAddOp2($5, 122, $10, 0);
    $13 = $3 + 20 | 0;
    continue;
   }
  }
  return 0;
 }
 return 0;
}

function sqlite3WhereEnd($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $15 = HEAP32[$0 + 4 >> 2];
 $7 = HEAP32[$0 >> 2];
 $12 = HEAP32[$7 >> 2];
 $5 = HEAP32[$7 + 8 >> 2];
 $13 = sqlite3VdbeCurrentAddr($5);
 $1 = HEAPU8[$0 + 48 | 0];
 while (1) {
  if (($1 | 0) > 0) {
   $9 = $1 - 1 | 0;
   $2 = Math_imul($9, 96) + $0 | 0;
   $10 = $2;
   $3 = HEAP32[$2 + 824 >> 2];
   if ($3) {
    $4 = $2 + 792 | 0;
    sqlite3VdbeResolveLabel($5, HEAP32[$4 >> 2]);
    HEAP32[$2 + 792 >> 2] = 0;
    HEAP32[$3 + 16 >> 2] = sqlite3VdbeCurrentAddr($5);
    sqlite3VdbeAddOp3($5, 67, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2], 1);
    $14 = $14 + 1 | 0;
   }
   $6 = HEAP32[$2 + 848 >> 2];
   $11 = $2;
   $8 = $2 + 829 | 0;
   label$4: {
    if (HEAPU8[$8 | 0] != 184) {
     $3 = 0;
     label$6: {
      if (!(HEAPU8[$6 + 41 | 0] & 2) | (HEAPU8[$0 + 51 | 0] != 2 | HEAPU8[$0 + 48 | 0] != ($1 | 0))) {
       break label$6;
      }
      $1 = HEAP32[$6 + 32 >> 2];
      if (!(HEAPU8[$1 + 55 | 0] & 128)) {
       break label$6;
      }
      $4 = HEAPU16[$6 + 30 >> 1];
      if (!$4 | HEAP16[HEAP32[$1 + 8 >> 2] + ($4 << 1) >> 1] < 36) {
       break label$6;
      }
      $3 = HEAP32[$7 + 44 >> 2] + 1 | 0;
      $1 = 0;
      while (1) {
       if (($1 | 0) != ($4 | 0)) {
        sqlite3VdbeAddOp3($5, 94, HEAP32[$2 + 776 >> 2], $1, $1 + $3 | 0);
        $1 = $1 + 1 | 0;
        continue;
       }
       break;
      }
      HEAP32[$7 + 44 >> 2] = (HEAP32[$7 + 44 >> 2] + $4 | 0) + 1;
      $3 = sqlite3VdbeAddOp4Int($5, HEAPU8[$11 + 829 | 0] == 37 ? 20 : 23, HEAP32[$2 + 776 >> 2], 0, $3, $4);
      sqlite3VdbeAddOp2($5, 8, 1, HEAP32[$2 + 836 >> 2]);
     }
     $1 = HEAP32[$2 + 792 >> 2];
     if ($1) {
      sqlite3VdbeResolveLabel($5, $1);
     }
     $1 = $2 + 836 | 0;
     sqlite3VdbeAddOp3($5, HEAPU8[$11 + 829 | 0], HEAP32[$2 + 832 >> 2], HEAP32[$1 >> 2], HEAPU8[$2 + 830 | 0]);
     sqlite3VdbeChangeP5($5, HEAPU8[$2 + 831 | 0]);
     $4 = $2 + 804 | 0;
     if (HEAP32[$4 >> 2]) {
      sqlite3VdbeResolveLabel($5, HEAP32[$2 + 808 >> 2]);
      sqlite3VdbeAddOp2($5, 60, HEAP32[$2 + 804 >> 2], HEAP32[$2 + 836 >> 2] - 1 | 0);
     }
     if (!$3) {
      break label$4;
     }
     sqlite3VdbeJumpHere($5, $3);
     break label$4;
    }
    $1 = HEAP32[$2 + 792 >> 2];
    if (!$1) {
     break label$4;
    }
    sqlite3VdbeResolveLabel($5, $1);
   }
   $8 = $2;
   label$11: {
    if (!(HEAPU8[$6 + 41 | 0] & 8)) {
     break label$11;
    }
    $1 = $2 + 840 | 0;
    if (HEAP32[$1 >> 2] <= 0) {
     break label$11;
    }
    sqlite3VdbeResolveLabel($5, HEAP32[$2 + 784 >> 2]);
    $3 = HEAP32[$2 + 840 >> 2];
    $1 = (HEAP32[$2 + 844 >> 2] + Math_imul($3, 20) | 0) - 20 | 0;
    while (1) {
     if (($3 | 0) <= 0) {
      break label$11;
     }
     sqlite3VdbeJumpHere($5, HEAP32[$1 + 4 >> 2] + 1 | 0);
     if (HEAPU8[$1 + 16 | 0] != 184) {
      label$14: {
       if (!HEAP32[$1 + 12 >> 2]) {
        break label$14;
       }
       $4 = HEAP32[$6 + 40 >> 2] & 263168;
       if (HEAP32[$8 + 768 >> 2]) {
        sqlite3VdbeAddOp2($5, 24, HEAP32[$1 >> 2], sqlite3VdbeCurrentAddr($5) + (($4 | 0) == 262144 ? 3 : 2) | 0);
       }
       if (($4 | 0) != 262144) {
        break label$14;
       }
       sqlite3VdbeAddOp4Int($5, 25, HEAP32[$2 + 776 >> 2], sqlite3VdbeCurrentAddr($5) + 2 | 0, HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
       sqlite3VdbeJumpHere($5, HEAP32[$1 + 4 >> 2] + 1 | 0);
      }
      sqlite3VdbeAddOp2($5, HEAPU8[$1 + 16 | 0], HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
     }
     sqlite3VdbeJumpHere($5, HEAP32[$1 + 4 >> 2] - 1 | 0);
     $1 = $1 - 20 | 0;
     $3 = $3 - 1 | 0;
     continue;
    }
   }
   sqlite3VdbeResolveLabel($5, HEAP32[$2 + 780 >> 2]);
   $1 = HEAP32[$10 + 824 >> 2];
   if ($1) {
    sqlite3VdbeAddOp3($5, 67, HEAP32[$1 + 8 >> 2], 0, 1);
   }
   $1 = $2 + 788 | 0;
   $3 = HEAP32[$1 >> 2];
   if ($3) {
    sqlite3VdbeGoto($5, $3);
    sqlite3VdbeJumpHere($5, HEAP32[$2 + 788 >> 2]);
    sqlite3VdbeJumpHere($5, HEAP32[$2 + 788 >> 2] - 2 | 0);
   }
   $1 = HEAP32[$2 + 816 >> 2];
   if ($1) {
    sqlite3VdbeAddOp2($5, 60, HEAP32[$2 + 812 >> 2] >>> 1 | 0, $1);
   }
   $1 = $9;
   $3 = HEAP32[$8 + 768 >> 2];
   if (!$3) {
    continue;
   }
   $1 = HEAP32[$6 + 40 >> 2];
   $3 = sqlite3VdbeAddOp1($5, 49, $3);
   if (!($1 & 64)) {
    sqlite3VdbeAddOp1($5, 136, HEAP32[$2 + 772 >> 2]);
   }
   $4 = $1 & 8192;
   label$20: {
    label$21: {
     label$22: {
      if (!($1 & 512)) {
       if (!$4) {
        break label$20;
       }
       if (HEAP32[$2 + 840 >> 2]) {
        break label$22;
       }
       break label$20;
      }
      if (!$4) {
       break label$21;
      }
     }
     $1 = HEAP32[$2 + 840 >> 2];
     sqlite3VdbeAddOp3($5, 101, HEAP32[$2 + 776 >> 2], HEAP32[$1 + 44 >> 2], sqlite3SchemaToIndex($12, HEAP32[$1 + 24 >> 2]));
     sqlite3VdbeSetP4KeyInfo($7, $1);
    }
    sqlite3VdbeAddOp1($5, 136, HEAP32[$2 + 776 >> 2]);
   }
   label$24: {
    if (HEAPU8[$11 + 829 | 0] == 67) {
     sqlite3VdbeAddOp2($5, 9, HEAP32[$2 + 832 >> 2], HEAP32[$2 + 796 >> 2]);
     break label$24;
    }
    sqlite3VdbeGoto($5, HEAP32[$2 + 796 >> 2]);
   }
   sqlite3VdbeJumpHere($5, $3);
   $1 = $9;
   continue;
  }
  break;
 }
 if (HEAP32[$0 + 68 >> 2]) {
  whereUndoExprMods($0);
 }
 $1 = $0 + 768 | 0;
 $2 = 0;
 while (1) {
  if ($2 >>> 0 < HEAPU8[$0 + 48 | 0]) {
   label$29: {
    if (HEAP32[$1 + 56 >> 2]) {
     sqlite3WhereRightJoinLoop($0, $2, $1);
     break label$29;
    }
    $3 = (HEAPU8[$1 + 60 | 0] << 6) + $15 | 0;
    if (HEAPU8[$3 + 45 | 0] & 32) {
     translateColumnToCopy($7, HEAP32[$1 + 32 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$3 + 40 >> 2], 0);
     break label$29;
    }
    $9 = HEAP32[$3 + 24 >> 2];
    $10 = HEAPU8[$12 + 87 | 0];
    $3 = HEAP32[$1 + 80 >> 2];
    $4 = HEAP32[$3 + 40 >> 2];
    label$32: {
     if ($4 & 576) {
      $4 = $3 + 32 | 0;
      break label$32;
     }
     if (!($4 & 8192)) {
      break label$29;
     }
     $4 = $1 + 72 | 0;
    }
    $3 = $4;
    $8 = HEAP32[$3 >> 2];
    if ($10 | !$8) {
     break label$29;
    }
    $4 = $13;
    label$34: {
     if (!HEAPU8[$0 + 50 | 0]) {
      break label$34;
     }
     $4 = $13;
     if (HEAPU8[HEAP32[$8 + 12 >> 2] + 28 | 0] & 128) {
      break label$34;
     }
     $4 = HEAP32[$0 + 60 >> 2];
    }
    $6 = HEAP32[$1 + 32 >> 2] + 1 | 0;
    $3 = sqlite3VdbeGetOp($5, $6);
    $6 = $3 + Math_imul($4 - $6 | 0, 20) | 0;
    $11 = HEAP32[$1 + 4 >> 2];
    while (1) {
     label$36: {
      if (HEAP32[$3 + 4 >> 2] != ($11 | 0)) {
       break label$36;
      }
      $4 = HEAPU8[$3 | 0];
      if (($4 | 0) != 18) {
       if (($4 | 0) != 135) {
        if (($4 | 0) != 94) {
         break label$36;
        }
        $4 = HEAP32[$3 + 8 >> 2];
        $10 = $8;
        label$39: {
         if (HEAPU8[$9 + 28 | 0] & 128) {
          $4 = HEAPU16[HEAP32[sqlite3PrimaryKeyIndex($9) + 4 >> 2] + ($4 << 1) >> 1];
          break label$39;
         }
         $4 = sqlite3StorageColumnToTable($9, $4 << 16 >> 16);
        }
        $4 = sqlite3TableColumnToIndex($10, $4 << 16 >> 16);
        if (($4 | 0) < 0) {
         break label$36;
        }
        HEAP32[$3 + 8 >> 2] = $4 & 65535;
        HEAP32[$3 + 4 >> 2] = HEAP32[$1 + 8 >> 2];
        break label$36;
       }
       $4 = HEAP32[$1 + 8 >> 2];
       HEAP8[$3 | 0] = 142;
       HEAP32[$3 + 4 >> 2] = $4;
       break label$36;
      }
      HEAP32[$3 + 4 >> 2] = HEAP32[$1 + 8 >> 2];
     }
     $3 = $3 + 20 | 0;
     if ($6 >>> 0 > $3 >>> 0) {
      continue;
     }
     break;
    }
   }
   $1 = $1 + 96 | 0;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3VdbeResolveLabel($5, HEAP32[$0 + 36 >> 2]);
 HEAP32[$7 + 136 >> 2] = HEAP32[$0 + 40 >> 2];
 whereInfoFree($12, $0);
 HEAP8[$7 + 26 | 0] = HEAPU8[$7 + 26 | 0] - $14;
}

function constructAutomaticIndex($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0;
 $21 = __stack_pointer - 16 | 0;
 __stack_pointer = $21;
 $16 = HEAP32[$0 + 8 >> 2];
 $30 = sqlite3VdbeAddOp0($16, 14);
 $11 = HEAP32[$1 + 24 >> 2];
 $27 = $11 + Math_imul(HEAP32[$1 + 12 >> 2], 48) | 0;
 $19 = HEAP32[$5 + 80 >> 2];
 $20 = HEAP32[$2 + 16 >> 2];
 label$1: {
  while (1) {
   if ($11 >>> 0 < $27 >>> 0) {
    label$4: {
     if (HEAPU8[$11 + 10 | 0] & 2) {
      break label$4;
     }
     $10 = HEAP32[$11 >> 2];
     if (!sqlite3ExprIsTableConstraint($10, $2)) {
      break label$4;
     }
     $24 = sqlite3ExprAnd($0, $24, sqlite3ExprDup(HEAP32[$0 >> 2], $10, 0));
    }
    $6 = $4;
    label$5: {
     if (!termCanDriveIndex($11, $2, $3, $6)) {
      break label$5;
     }
     $10 = HEAP32[$11 + 24 >> 2];
     $12 = $10 & 31;
     if (($10 & 63) >>> 0 >= 32) {
      $7 = 1 << $12;
      $6 = 0;
     } else {
      $7 = (1 << $12) - 1 & 1 >>> 32 - $12;
      $6 = 1 << $12;
     }
     $12 = ($10 | 0) > 63;
     $9 = $12 ? 0 : $6;
     $15 = $9;
     $13 = $7;
     $6 = $12 ? -2147483648 : $13;
     $18 = $6;
     if (!($17 & 255)) {
      $17 = HEAP32[$20 >> 2];
      HEAP32[$21 + 4 >> 2] = HEAP32[HEAP32[$20 + 4 >> 2] + Math_imul($10, 12) >> 2];
      HEAP32[$21 >> 2] = $17;
      sqlite3_log(284, 24425, $21);
     }
     $17 = 1;
     $6 = $18;
     $9 = $22;
     $9 = $6 & $9;
     $7 = $23;
     $12 = $15;
     $6 = $7 & $12;
     if ($9 | $6) {
      break label$5;
     }
     $10 = $8 + 1 | 0;
     if (whereLoopResize(HEAP32[$0 >> 2], $19, $10)) {
      break label$1;
     }
     HEAP32[HEAP32[$19 + 52 >> 2] + ($8 << 2) >> 2] = $11;
     $7 = $15;
     $12 = $23;
     $23 = $7 | $12;
     $6 = $18;
     $9 = $22;
     $9 = $6 | $9;
     $22 = $9;
     $8 = $10;
    }
    $11 = $11 + 48 | 0;
    continue;
   }
   break;
  }
  HEAP32[$19 + 40 >> 2] = 16961;
  HEAP16[$19 + 24 >> 1] = $8;
  HEAP16[$19 + 44 >> 1] = $8;
  $10 = HEAP16[$20 + 34 >> 1];
  $11 = ($10 | 0) < 63 ? $10 : 63;
  $29 = ($11 | 0) > 0 ? $11 : 0;
  $6 = $2;
  $9 = HEAP32[$6 + 48 >> 2];
  $25 = $9;
  $7 = HEAP32[$6 + 52 >> 2];
  $28 = $7;
  $7 = $22;
  $9 = $7 ^ -1;
  $6 = $23;
  $7 = $6 ^ -1;
  $6 = $9 | -2147483648;
  $15 = $6;
  $9 = $25;
  $12 = $7;
  $23 = $9 & $12;
  $6 = $28;
  $7 = $15;
  $7 = $6 & $7;
  $22 = $7;
  $15 = 0;
  $18 = 0;
  while (1) {
   $7 = $18;
   $6 = $15;
   $12 = $29;
   if (!(!$7 & ($6 | 0) == ($12 | 0))) {
    $6 = $22;
    $12 = $23;
    $9 = $15;
    $13 = $9 & 31;
    if (($9 & 63) >>> 0 >= 32) {
     $7 = $6 >>> $13 | 0;
    } else {
     $7 = ((1 << $13) - 1 & $6) << 32 - $13 | $12 >>> $13;
    }
    $8 = ($7 & 1) + $8 | 0;
    $7 = $18;
    $6 = $15;
    $13 = $6 + 1 | 0;
    $14 = $13 ? $7 : $7 + 1 | 0;
    $15 = $13;
    $18 = $14;
    continue;
   }
   break;
  }
  $11 = 0;
  $14 = $28;
  $26 = (($14 | 0) < 0 ? $10 - 62 | 0 : 1) + $8 | 0;
  $10 = sqlite3AllocateIndexObject(HEAP32[$0 >> 2], $26 << 16 >> 16, 0, $21 + 12 | 0);
  if (!$10) {
   break label$1;
  }
  HEAP32[$19 + 32 >> 2] = $10;
  HEAP32[$10 + 12 >> 2] = $20;
  HEAP32[$10 >> 2] = 1495;
  $8 = HEAP32[$1 + 24 >> 2];
  $15 = 0;
  $18 = 0;
  while (1) {
   if ($8 >>> 0 >= $27 >>> 0) {
    label$11: {
     $8 = 0;
     $15 = 0;
     $18 = 0;
     while (1) {
      $7 = $18;
      $6 = $29;
      $9 = $15;
      if (!$7 & ($6 | 0) == ($9 | 0)) {
       break label$11;
      }
      $9 = $22;
      $6 = $23;
      $14 = $15;
      $12 = $14 & 31;
      if (($14 & 63) >>> 0 >= 32) {
       $9 = $9 >>> $12 | 0;
      } else {
       $9 = ((1 << $12) - 1 & $9) << 32 - $12 | $6 >>> $12;
      }
      $6 = 0;
      if ($6 | $9 & 1) {
       HEAP16[HEAP32[$10 + 4 >> 2] + ($11 << 1) >> 1] = $8;
       HEAP32[HEAP32[$10 + 32 >> 2] + ($11 << 2) >> 2] = 32384;
       $11 = $11 + 1 | 0;
      }
      $8 = $8 + 1 | 0;
      $6 = $18;
      $7 = $15;
      $12 = $7 + 1 | 0;
      $13 = $12 ? $6 : $6 + 1 | 0;
      $15 = $12;
      $18 = $13;
      continue;
     }
    }
   } else {
    $13 = $4;
    label$15: {
     if (!termCanDriveIndex($8, $2, $3, $13)) {
      break label$15;
     }
     $17 = HEAP32[$8 + 24 >> 2];
     $14 = $17;
     $9 = $14 & 31;
     if (($14 & 63) >>> 0 >= 32) {
      $7 = 1 << $9;
      $6 = 0;
     } else {
      $7 = (1 << $9) - 1 & 1 >>> 32 - $9;
      $6 = 1 << $9;
     }
     $9 = ($17 | 0) > 63;
     $14 = $9 ? 0 : $6;
     $25 = $14;
     $6 = $7;
     $13 = $9 ? -2147483648 : $6;
     $28 = $13;
     $14 = $18;
     $14 = $13 & $14;
     $7 = $15;
     $9 = $25;
     $13 = $7 & $9;
     if ($13 | $14) {
      break label$15;
     }
     $7 = HEAP32[$8 >> 2];
     HEAP16[HEAP32[$10 + 4 >> 2] + ($11 << 1) >> 1] = $17;
     $17 = sqlite3ExprCompareCollSeq($0, $7);
     if ($17) {
      $17 = HEAP32[$17 >> 2];
     } else {
      $17 = 32384;
     }
     $7 = $15;
     $9 = $25;
     $15 = $7 | $9;
     $13 = $18;
     $14 = $28;
     $14 = $13 | $14;
     $18 = $14;
     HEAP32[HEAP32[$10 + 32 >> 2] + ($11 << 2) >> 2] = $17;
     $11 = $11 + 1 | 0;
    }
    $8 = $8 + 48 | 0;
    continue;
   }
   break;
  }
  $13 = $2;
  $14 = HEAP32[$13 + 48 >> 2];
  label$18: {
   $7 = HEAP32[$2 + 52 >> 2];
   if (($7 | 0) > 0 | ($7 | 0) >= 0) {
    break label$18;
   }
   $8 = 63;
   while (1) {
    if (HEAP16[$20 + 34 >> 1] <= ($8 | 0)) {
     break label$18;
    }
    HEAP16[HEAP32[$10 + 4 >> 2] + ($11 << 1) >> 1] = $8;
    HEAP32[HEAP32[$10 + 32 >> 2] + ($11 << 2) >> 2] = 32384;
    $8 = $8 + 1 | 0;
    $11 = $11 + 1 | 0;
    continue;
   }
  }
  HEAP16[HEAP32[$10 + 4 >> 2] + ($11 << 1) >> 1] = 65535;
  HEAP32[HEAP32[$10 + 32 >> 2] + ($11 << 2) >> 2] = 32384;
  $8 = HEAP32[$0 + 40 >> 2];
  HEAP32[$0 + 40 >> 2] = $8 + 1;
  HEAP32[$5 + 8 >> 2] = $8;
  sqlite3VdbeAddOp2($16, 116, $8, $26);
  sqlite3VdbeSetP4KeyInfo($0, $10);
  if (!(HEAPU8[HEAP32[$0 >> 2] + 82 | 0] & 8)) {
   $8 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $8;
   HEAP32[$5 + 52 >> 2] = $8;
   sqlite3VdbeAddOp2($16, 77, 1e4, $8);
  }
  $7 = HEAP32[HEAP32[$1 >> 2] + 4 >> 2];
  $1 = HEAPU8[$5 + 60 | 0];
  $8 = $7 + ($1 << 6) | 0;
  $3 = $8;
  $27 = $8 + 45 | 0;
  label$21: {
   if (HEAPU8[$27 | 0] & 32) {
    $2 = HEAP32[$8 + 36 >> 2];
    $26 = sqlite3VdbeAddOp2($16, 71, 0, 0);
    sqlite3VdbeAddOp3($16, 10, $2, 0, HEAP32[$8 + 32 >> 2]);
    $2 = sqlite3VdbeAddOp1($16, 11, $2);
    break label$21;
   }
   $26 = 0;
   $2 = sqlite3VdbeAddOp1($16, 35, HEAP32[$5 + 4 >> 2]);
  }
  $17 = 0;
  if ($24) {
   $17 = sqlite3VdbeMakeLabel($0);
   sqlite3ExprIfFalse($0, $24, $17, 16);
   HEAP32[$19 + 40 >> 2] = HEAP32[$19 + 40 >> 2] | 131072;
  }
  $8 = sqlite3GetTempReg($0);
  $10 = sqlite3GenerateIndexKey($0, $10, HEAP32[$5 + 4 >> 2], $8, 0, 0, 0, 0);
  $20 = HEAP32[$5 + 52 >> 2];
  if ($20) {
   sqlite3VdbeAddOp4Int($16, 180, $20, 0, $10, HEAPU16[$19 + 24 >> 1]);
  }
  sqlite3VdbeAddOp2($16, 138, HEAP32[$5 + 8 >> 2], $8);
  sqlite3VdbeChangeP5($16, 16);
  if ($24) {
   sqlite3VdbeResolveLabel($16, $17);
  }
  label$26: {
   if (HEAPU8[$3 + 45 | 0] & 32) {
    sqlite3VdbeChangeP2($16, $26, $11 + $10 | 0);
    translateColumnToCopy($0, $2, HEAP32[$5 + 4 >> 2], HEAP32[(($1 << 6) + $7 | 0) + 40 >> 2], HEAP32[$5 + 8 >> 2]);
    sqlite3VdbeGoto($16, $2);
    $1 = (HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8) & 65503;
    HEAP8[$3 + 45 | 0] = $1;
    HEAP8[$3 + 46 | 0] = $1 >>> 8;
    break label$26;
   }
   sqlite3VdbeAddOp2($16, 38, HEAP32[$5 + 4 >> 2], $2 + 1 | 0);
   sqlite3VdbeChangeP5($16, 3);
  }
  sqlite3VdbeJumpHere($16, $2);
  sqlite3ReleaseTempReg($0, $8);
  sqlite3VdbeJumpHere($16, $30);
 }
 sqlite3ExprDelete(HEAP32[$0 >> 2], $24);
 __stack_pointer = $21 + 16 | 0;
}

function jsonParseValue($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $5 = HEAP32[$0 + 12 >> 2];
 while (1) {
  $3 = $1;
  $1 = $1 + 1 | 0;
  $6 = $3 + $5 | 0;
  $2 = HEAPU8[$6 | 0];
  if (HEAPU8[$2 + 50864 | 0]) {
   continue;
  }
  break;
 }
 label$2: {
  label$3: {
   if (($2 | 0) == 34) {
    $1 = $3;
    while (1) {
     $7 = -1;
     $4 = $1;
     $1 = $1 + 1 | 0;
     $2 = HEAPU8[$5 + $1 | 0];
     if ($2 >>> 0 < 32) {
      break label$3;
     }
     if (($2 | 0) != 92) {
      if (($2 | 0) != 34) {
       continue;
      }
      $7 = $4 + 2 | 0;
      jsonParseAddNode($0, 5, $7 - $3 | 0, $6);
      if (HEAPU8[$0 + 20 | 0]) {
       break label$3;
      }
      HEAP8[(HEAP32[$0 + 8 >> 2] + Math_imul(HEAP32[$0 >> 2], 12) | 0) - 11 | 0] = $8;
      return $7;
     }
     $8 = 2;
     label$7: {
      label$8: {
       $1 = $4 + 2 | 0;
       $4 = $5 + $1 | 0;
       $2 = HEAPU8[$4 | 0];
       switch ($2 - 110 | 0) {
       case 1:
       case 2:
       case 3:
       case 5:
        break label$3;

       case 0:
       case 4:
       case 6:
        continue;

       case 7:
        break label$7;

       default:
        break label$8;
       }
      }
      label$9: {
       switch ($2 - 98 | 0) {
       case 1:
       case 2:
       case 3:
        break label$3;

       case 0:
       case 4:
        continue;

       default:
        break label$9;
       }
      }
      if (($2 | 0) == 34 | ($2 | 0) == 47 | ($2 | 0) == 92) {
       continue;
      }
      break label$3;
     }
     if (jsonIs4Hex($4 + 1 | 0)) {
      continue;
     }
     break;
    }
    break label$3;
   }
   label$10: {
    label$11: {
     label$12: {
      label$13: {
       label$14: {
        if (($2 | 0) != 91) {
         if (($2 | 0) == 102) {
          break label$12;
         }
         if (($2 | 0) == 110) {
          break label$14;
         }
         if (($2 | 0) == 116) {
          break label$13;
         }
         if (($2 | 0) != 123) {
          break label$11;
         }
         $6 = jsonParseAddNode($0, 7, 0, 0);
         if (($6 | 0) < 0) {
          break label$10;
         }
         while (1) {
          $2 = $3;
          $3 = $2 + 1 | 0;
          if (HEAPU8[HEAPU8[$5 + $3 | 0] + 50864 | 0]) {
           continue;
          }
          $1 = HEAPU16[$0 + 22 >> 1] + 1 | 0;
          HEAP16[$0 + 22 >> 1] = $1;
          $7 = -1;
          if (($1 & 65535) >>> 0 > 2e3) {
           break label$3;
          }
          $1 = jsonParseValue($0, $3);
          if (($1 | 0) < 0) {
           HEAP16[$0 + 22 >> 1] = HEAPU16[$0 + 22 >> 1] - 1;
           if (($1 | 0) != -2) {
            break label$3;
           }
           return HEAP32[$0 >> 2] == ($6 + 1 | 0) ? $2 + 2 | 0 : -1;
          }
          if (HEAPU8[$0 + 20 | 0]) {
           break label$3;
          }
          $2 = HEAP32[$0 + 8 >> 2] + Math_imul(HEAP32[$0 >> 2] - 1 | 0, 12) | 0;
          if (HEAPU8[$2 | 0] != 5) {
           break label$3;
          }
          HEAP8[$2 + 1 | 0] = HEAPU8[$2 + 1 | 0] | 64;
          while (1) {
           $2 = $1 + $5 | 0;
           $4 = $1 + 1 | 0;
           $1 = $4;
           $2 = HEAPU8[$2 | 0];
           if (HEAPU8[$2 + 50864 | 0]) {
            continue;
           }
           break;
          }
          if (($2 | 0) != 58) {
           break label$3;
          }
          $1 = jsonParseValue($0, $4);
          HEAP16[$0 + 22 >> 1] = HEAPU16[$0 + 22 >> 1] - 1;
          if (($1 | 0) < 0) {
           break label$3;
          }
          while (1) {
           $3 = $1;
           $1 = $1 + 1 | 0;
           $2 = HEAPU8[$3 + $5 | 0];
           if (HEAPU8[$2 + 50864 | 0]) {
            continue;
           }
           break;
          }
          if (($2 | 0) == 44) {
           continue;
          }
          break;
         }
         if (($2 | 0) != 125) {
          break label$3;
         }
         HEAP32[(HEAP32[$0 + 8 >> 2] + Math_imul($6, 12) | 0) + 4 >> 2] = HEAP32[$0 >> 2] + ($6 ^ -1);
         break label$2;
        }
        $4 = jsonParseAddNode($0, 6, 0, 0);
        if (($4 | 0) < 0) {
         break label$10;
        }
        HEAP32[(HEAP32[$0 + 8 >> 2] + Math_imul($4, 12) | 0) + 8 >> 2] = 0;
        while (1) {
         $2 = $3;
         $3 = $2 + 1 | 0;
         if (HEAPU8[HEAPU8[$5 + $3 | 0] + 50864 | 0]) {
          continue;
         }
         $1 = HEAPU16[$0 + 22 >> 1] + 1 | 0;
         HEAP16[$0 + 22 >> 1] = $1;
         $7 = -1;
         if (($1 & 65535) >>> 0 > 2e3) {
          break label$3;
         }
         $1 = jsonParseValue($0, $3);
         HEAP16[$0 + 22 >> 1] = HEAPU16[$0 + 22 >> 1] - 1;
         if (($1 | 0) < 0) {
          if (($1 | 0) != -3) {
           break label$3;
          }
          return HEAP32[$0 >> 2] == ($4 + 1 | 0) ? $2 + 2 | 0 : -1;
         }
         while (1) {
          $3 = $1;
          $1 = $1 + 1 | 0;
          $2 = HEAPU8[$3 + $5 | 0];
          if (HEAPU8[$2 + 50864 | 0]) {
           continue;
          }
          break;
         }
         if (($2 | 0) == 44) {
          continue;
         }
         break;
        }
        if (($2 | 0) != 93) {
         break label$3;
        }
        HEAP32[(HEAP32[$0 + 8 >> 2] + Math_imul($4, 12) | 0) + 4 >> 2] = HEAP32[$0 >> 2] + ($4 ^ -1);
        break label$2;
       }
       if (strncmp($6, 11103, 4)) {
        break label$11;
       }
       $1 = $3 + 4 | 0;
       if (HEAPU8[HEAPU8[$5 + $1 | 0] + 30288 | 0] & 6) {
        break label$11;
       }
       jsonParseAddNode($0, 0, 0, 0);
       break label$2;
      }
      if (strncmp($6, 12326, 4)) {
       break label$11;
      }
      $1 = $3 + 4 | 0;
      if (HEAPU8[HEAPU8[$5 + $1 | 0] + 30288 | 0] & 6) {
       break label$11;
      }
      jsonParseAddNode($0, 1, 0, 0);
      break label$2;
     }
     if (strncmp($6, 12859, 5)) {
      break label$11;
     }
     $1 = $3 + 5 | 0;
     if (HEAPU8[HEAPU8[$5 + $1 | 0] + 30288 | 0] & 6) {
      break label$11;
     }
     jsonParseAddNode($0, 2, 0, 0);
     break label$2;
    }
    if (!(($2 | 0) != 45 & ($2 - 48 & 255) >>> 0 > 9)) {
     label$24: {
      if ($2 >>> 0 > 48) {
       break label$24;
      }
      $1 = ((($2 | 0) == 45) + $3 | 0) + $5 | 0;
      if (HEAPU8[$1 | 0] != 48) {
       break label$24;
      }
      $7 = -1;
      if ((HEAPU8[$1 + 1 | 0] - 48 & 255) >>> 0 < 10) {
       break label$3;
      }
     }
     $1 = $3;
     $9 = 1;
     while (1) {
      $4 = $1;
      $1 = $1 + 1 | 0;
      $2 = HEAPU8[$5 + $1 | 0];
      if (($2 - 48 & 255) >>> 0 < 10) {
       continue;
      }
      if (($2 & 255) == 46) {
       $7 = -1;
       if (HEAPU8[$4 + $5 | 0] == 45) {
        break label$3;
       }
       $2 = $8;
       $8 = 1;
       if (!$2) {
        continue;
       }
       break label$3;
      }
      $10 = $4 + $5 | 0;
      $11 = HEAP8[$10 | 0];
      if (($2 & 223) == 69) {
       $7 = -1;
       if (($9 ^ -1 | ($11 | 0) < 48) & 1) {
        break label$3;
       }
       label$28: {
        label$29: {
         $4 = $4 + 2 | 0;
         $2 = HEAPU8[$5 + $4 | 0];
         switch ($2 - 43 | 0) {
         case 0:
         case 2:
          break label$29;

         default:
          break label$28;
         }
        }
        $2 = HEAPU8[$10 + 3 | 0];
        $1 = $4;
       }
       $8 = 1;
       $9 = 0;
       if (($2 - 58 & 255) >>> 0 >= 246) {
        continue;
       }
       break label$3;
      }
      break;
     }
     $7 = -1;
     if (($11 | 0) < 48) {
      break label$3;
     }
     jsonParseAddNode($0, $8 ? 4 : 3, $1 - $3 | 0, $6);
     break label$2;
    }
    if ($2) {
     if (($2 | 0) == 125) {
      return -2;
     }
     if (($2 | 0) != 93) {
      break label$10;
     }
     return -3;
    }
    return 0;
   }
   $7 = -1;
  }
  return $7;
 }
 return $1;
}

function sqlite3VdbeRecordCompareWithSkip($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$2 + 4 >> 2];
 label$1: {
  label$2: {
   label$3: {
    label$5: {
     if ($3) {
      $9 = HEAP8[$1 + 1 | 0];
      $3 = $9 & 255;
      HEAP32[$6 + 16 >> 2] = $3;
      $12 = 1;
      $10 = 2;
      $7 = $7 + 40 | 0;
      if (($9 | 0) < 0) {
       $10 = sqlite3GetVarint32($1 + 1 | 0, $6 + 16 | 0) + 1 | 0;
       $3 = HEAP32[$6 + 16 >> 2];
      }
      $3 = sqlite3VdbeSerialTypeLen($3);
      $13 = HEAPU8[$1 | 0];
      $3 = $3 + $13 | 0;
      break label$5;
     }
     $3 = HEAP8[$1 | 0];
     $13 = $3 & 255;
     HEAP32[$6 + 60 >> 2] = $13;
     $10 = 1;
     if (($3 | 0) < 0) {
      $10 = sqlite3GetVarint32($1, $6 + 60 | 0);
      $13 = HEAP32[$6 + 60 >> 2];
     }
     $3 = $13;
    }
    $9 = $3;
    label$4: {
     if ($9 >>> 0 <= $0 >>> 0) {
      $14 = $2 + 23 | 0;
      while (1) {
       label$11: {
        label$12: {
         label$13: {
          label$14: {
           label$15: {
            label$16: {
             label$17: {
              $3 = HEAPU16[$7 + 16 >> 1];
              label$18: {
               if ($3 & 36) {
                $4 = 1;
                $3 = HEAPU8[$1 + $10 | 0];
                if ($3 >>> 0 > 9) {
                 break label$18;
                }
                if (($3 | 0) == 7) {
                 break label$13;
                }
                if (!$3) {
                 break label$15;
                }
                $11 = vdbeRecordDecodeInt($3, $1 + $9 | 0);
                $15 = HEAP32[$7 >> 2];
                $5 = i64toi32_i32$HIGH_BITS;
                $8 = HEAP32[$7 + 4 >> 2];
                if ($11 >>> 0 < $15 >>> 0 & ($5 | 0) <= ($8 | 0) | ($5 | 0) < ($8 | 0)) {
                 break label$15;
                }
                if (($5 | 0) <= ($8 | 0) & $11 >>> 0 <= $15 >>> 0 | ($5 | 0) < ($8 | 0)) {
                 break label$11;
                }
                $5 = $3;
                break label$2;
               }
               if ($3 & 8) {
                $5 = 1;
                $3 = HEAPU8[$1 + $10 | 0];
                if ($3 >>> 0 > 9) {
                 break label$3;
                }
                $4 = -1;
                if (!$3) {
                 $5 = 0;
                 break label$2;
                }
                sqlite3VdbeSerialGet($1 + $9 | 0, $3, $6 + 16 | 0);
                if (($3 | 0) == 7) {
                 $16 = HEAPF64[$6 + 16 >> 3];
                 $17 = HEAPF64[$7 >> 3];
                 if ($16 < $17) {
                  break label$2;
                 }
                 $3 = 7;
                 $4 = 1;
                 if ($16 > $17) {
                  break label$2;
                 }
                 break label$11;
                }
                $5 = $3;
                $4 = sqlite3IntFloatCompare(HEAP32[$6 + 16 >> 2], HEAP32[$6 + 20 >> 2], HEAPF64[$7 >> 3]);
                break label$12;
               }
               if ($3 & 2) {
                $5 = $1 + $10 | 0;
                $4 = HEAP8[$5 | 0];
                $3 = $4 & 255;
                HEAP32[$6 + 12 >> 2] = $3;
                if (($4 | 0) < 0) {
                 sqlite3GetVarint32($5, $6 + 12 | 0);
                 $3 = HEAP32[$6 + 12 >> 2];
                }
                if ($3 >>> 0 < 12) {
                 $4 = -1;
                 $5 = $3;
                 break label$2;
                }
                $5 = 1;
                if (!($3 & 1)) {
                 break label$3;
                }
                $8 = $3 - 12 >>> 1 | 0;
                HEAP32[$6 + 28 >> 2] = $8;
                label$26: {
                 if ($9 + $8 >>> 0 <= $0 >>> 0) {
                  $4 = HEAP32[$2 >> 2];
                  if (HEAPU16[$4 + 8 >> 1] > $12 >>> 0) {
                   break label$26;
                  }
                 }
                 HEAP8[$14 | 0] = sqlite3CorruptError(85321);
                 break label$4;
                }
                $11 = HEAP32[(($12 << 2) + $4 | 0) + 20 >> 2];
                if ($11) {
                 HEAP8[$6 + 34 | 0] = HEAPU8[$4 + 4 | 0];
                 $4 = HEAP32[$4 + 12 >> 2];
                 HEAP16[$6 + 32 >> 1] = 2;
                 HEAP32[$6 + 36 >> 2] = $4;
                 HEAP32[$6 + 24 >> 2] = $1 + $9;
                 $5 = $3;
                 $4 = vdbeCompareMemString($6 + 16 | 0, $7, $11, $14);
                 break label$12;
                }
                $11 = HEAP32[$7 + 12 >> 2];
                $4 = memcmp($1 + $9 | 0, HEAP32[$7 + 8 >> 2], ($8 | 0) < ($11 | 0) ? $8 : $11);
                if ($4) {
                 break label$2;
                }
                $5 = $3;
                $4 = $8 - $11 | 0;
                break label$12;
               }
               $8 = $1 + $10 | 0;
               $5 = HEAPU8[$8 | 0];
               $4 = $5 << 24 >> 24;
               if (!($3 & 16)) {
                break label$16;
               }
               HEAP32[$6 + 12 >> 2] = $5;
               if (($4 | 0) < 0) {
                sqlite3GetVarint32($8, $6 + 12 | 0);
                $5 = HEAP32[$6 + 12 >> 2];
               }
               $4 = -1;
               if ($5 & 1 | $5 >>> 0 < 12) {
                break label$2;
               }
               $3 = $5 - 12 >>> 1 | 0;
               if ($9 + $3 >>> 0 > $0 >>> 0) {
                break label$14;
               }
               if (HEAPU8[$7 + 17 | 0] & 4) {
                if (!isAllZero($1 + $9 | 0, $3)) {
                 $5 = 1;
                 break label$3;
                }
                $4 = $3 - HEAP32[$7 >> 2] | 0;
                break label$12;
               }
               $8 = HEAP32[$7 + 12 >> 2];
               $4 = memcmp($1 + $9 | 0, HEAP32[$7 + 8 >> 2], ($3 | 0) < ($8 | 0) ? $3 : $8);
               if (!$4) {
                break label$17;
               }
              }
              $5 = 1;
              break label$2;
             }
             $4 = $3 - $8 | 0;
             break label$12;
            }
            $4 = ($4 | 0) != 0;
            break label$12;
           }
           $5 = $3;
           $4 = -1;
           break label$2;
          }
          HEAP8[$14 | 0] = sqlite3CorruptError(85351);
          break label$4;
         }
         $5 = 7;
         sqlite3VdbeSerialGet($1 + $9 | 0, 7, $6 + 16 | 0);
         $4 = 0 - sqlite3IntFloatCompare(HEAP32[$7 >> 2], HEAP32[$7 + 4 >> 2], HEAPF64[$6 + 16 >> 3]) | 0;
        }
        $3 = $5;
        if ($4) {
         break label$2;
        }
       }
       $12 = $12 + 1 | 0;
       label$32: {
        if (($12 | 0) == HEAPU16[$2 + 20 >> 1]) {
         break label$32;
        }
        $4 = sqlite3VdbeSerialTypeLen($3);
        $10 = sqlite3VarintLen($3, 0) + $10 | 0;
        if ($13 >>> 0 <= $10 >>> 0) {
         break label$32;
        }
        $7 = $7 + 40 | 0;
        $9 = $4 + $9 | 0;
        if ($9 >>> 0 <= $0 >>> 0) {
         continue;
        }
       }
       break;
      }
      HEAP8[$2 + 26 | 0] = 1;
      $4 = HEAP8[$2 + 22 | 0];
      break label$1;
     }
     HEAP8[$2 + 23 | 0] = sqlite3CorruptError(85244);
    }
    $4 = 0;
    break label$1;
   }
   $4 = 1;
  }
  $3 = HEAPU8[HEAP32[HEAP32[$2 >> 2] + 16 >> 2] + $12 | 0];
  if (!$3) {
   break label$1;
  }
  label$33: {
   if (!($3 & 2)) {
    break label$33;
   }
   if (!$5) {
    if (!($3 & 1)) {
     break label$33;
    }
    break label$1;
   }
   if ((HEAPU8[$7 + 16 | 0] ^ !($3 & 1)) & 1) {
    break label$1;
   }
  }
  $4 = 0 - $4 | 0;
 }
 __stack_pointer = $6 - -64 | 0;
 return $4;
}

function dlfree($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  label$2: {
   if (!$0) {
    break label$2;
   }
   $3 = $0 - 8 | 0;
   $1 = HEAP32[$0 - 4 >> 2];
   $0 = $1 & -8;
   $5 = $3 + $0 | 0;
   label$3: {
    if ($1 & 1) {
     break label$3;
    }
    if (!($1 & 3)) {
     break label$2;
    }
    $1 = HEAP32[$3 >> 2];
    $3 = $3 - $1 | 0;
    $4 = HEAP32[17794];
    if ($3 >>> 0 < $4 >>> 0) {
     break label$2;
    }
    $0 = $0 + $1 | 0;
    if (HEAP32[17795] != ($3 | 0)) {
     if ($1 >>> 0 <= 255) {
      $6 = $1 >>> 3 | 0;
      $2 = ($6 << 3) + 71200 | 0;
      $4 = HEAP32[$3 + 8 >> 2];
      $1 = HEAP32[$3 + 12 >> 2];
      if (($4 | 0) == ($1 | 0)) {
       HEAP32[17790] = HEAP32[17790] & __wasm_rotl_i32(-2, $6);
       break label$3;
      }
      HEAP32[$4 + 12 >> 2] = $1;
      HEAP32[$1 + 8 >> 2] = $4;
      break label$3;
     }
     $7 = HEAP32[$3 + 24 >> 2];
     $2 = HEAP32[$3 + 12 >> 2];
     label$7: {
      if (($2 | 0) != ($3 | 0)) {
       $1 = HEAP32[$3 + 8 >> 2];
       HEAP32[$1 + 12 >> 2] = $2;
       HEAP32[$2 + 8 >> 2] = $1;
       break label$7;
      }
      label$9: {
       $1 = $3 + 20 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        break label$9;
       }
       $1 = $3 + 16 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        break label$9;
       }
       $2 = 0;
       break label$7;
      }
      while (1) {
       $6 = $1;
       $2 = $4;
       $1 = $2 + 20 | 0;
       $4 = HEAP32[$1 >> 2];
       if ($4) {
        continue;
       }
       $1 = $2 + 16 | 0;
       $4 = HEAP32[$2 + 16 >> 2];
       if ($4) {
        continue;
       }
       break;
      }
      HEAP32[$6 >> 2] = 0;
     }
     if (!$7) {
      break label$3;
     }
     $4 = HEAP32[$3 + 28 >> 2];
     $1 = ($4 << 2) + 71464 | 0;
     label$11: {
      if (HEAP32[$1 >> 2] == ($3 | 0)) {
       HEAP32[$1 >> 2] = $2;
       if ($2) {
        break label$11;
       }
       HEAP32[17791] = HEAP32[17791] & __wasm_rotl_i32(-2, $4);
       break label$3;
      }
      HEAP32[(HEAP32[$7 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $7 >> 2] = $2;
      if (!$2) {
       break label$3;
      }
     }
     HEAP32[$2 + 24 >> 2] = $7;
     $1 = HEAP32[$3 + 16 >> 2];
     if ($1) {
      HEAP32[$2 + 16 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $2;
     }
     $1 = HEAP32[$3 + 20 >> 2];
     if (!$1) {
      break label$3;
     }
     HEAP32[$2 + 20 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $2;
     break label$3;
    }
    $1 = HEAP32[$5 + 4 >> 2];
    if (($1 & 3) != 3) {
     break label$3;
    }
    HEAP32[17792] = $0;
    HEAP32[$5 + 4 >> 2] = $1 & -2;
    break label$1;
   }
   if ($3 >>> 0 >= $5 >>> 0) {
    break label$2;
   }
   $1 = HEAP32[$5 + 4 >> 2];
   if (!($1 & 1)) {
    break label$2;
   }
   label$14: {
    if (!($1 & 2)) {
     if (HEAP32[17796] == ($5 | 0)) {
      HEAP32[17796] = $3;
      $0 = HEAP32[17793] + $0 | 0;
      HEAP32[17793] = $0;
      HEAP32[$3 + 4 >> 2] = $0 | 1;
      if (HEAP32[17795] != ($3 | 0)) {
       break label$2;
      }
      HEAP32[17792] = 0;
      HEAP32[17795] = 0;
      return;
     }
     if (HEAP32[17795] == ($5 | 0)) {
      HEAP32[17795] = $3;
      $0 = HEAP32[17792] + $0 | 0;
      HEAP32[17792] = $0;
      break label$1;
     }
     $0 = ($1 & -8) + $0 | 0;
     label$18: {
      if ($1 >>> 0 <= 255) {
       $6 = $1 >>> 3 | 0;
       $2 = ($6 << 3) + 71200 | 0;
       $4 = HEAP32[$5 + 8 >> 2];
       $1 = HEAP32[$5 + 12 >> 2];
       if (($4 | 0) == ($1 | 0)) {
        HEAP32[17790] = HEAP32[17790] & __wasm_rotl_i32(-2, $6);
        break label$18;
       }
       HEAP32[$4 + 12 >> 2] = $1;
       HEAP32[$1 + 8 >> 2] = $4;
       break label$18;
      }
      $7 = HEAP32[$5 + 24 >> 2];
      $2 = HEAP32[$5 + 12 >> 2];
      label$21: {
       if (($5 | 0) != ($2 | 0)) {
        $1 = HEAP32[$5 + 8 >> 2];
        HEAP32[$1 + 12 >> 2] = $2;
        HEAP32[$2 + 8 >> 2] = $1;
        break label$21;
       }
       label$23: {
        $1 = $5 + 20 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         break label$23;
        }
        $1 = $5 + 16 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         break label$23;
        }
        $2 = 0;
        break label$21;
       }
       while (1) {
        $6 = $1;
        $2 = $4;
        $1 = $2 + 20 | 0;
        $4 = HEAP32[$1 >> 2];
        if ($4) {
         continue;
        }
        $1 = $2 + 16 | 0;
        $4 = HEAP32[$2 + 16 >> 2];
        if ($4) {
         continue;
        }
        break;
       }
       HEAP32[$6 >> 2] = 0;
      }
      if (!$7) {
       break label$18;
      }
      $4 = HEAP32[$5 + 28 >> 2];
      $1 = ($4 << 2) + 71464 | 0;
      label$25: {
       if (HEAP32[$1 >> 2] == ($5 | 0)) {
        HEAP32[$1 >> 2] = $2;
        if ($2) {
         break label$25;
        }
        HEAP32[17791] = HEAP32[17791] & __wasm_rotl_i32(-2, $4);
        break label$18;
       }
       HEAP32[(HEAP32[$7 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $7 >> 2] = $2;
       if (!$2) {
        break label$18;
       }
      }
      HEAP32[$2 + 24 >> 2] = $7;
      $1 = HEAP32[$5 + 16 >> 2];
      if ($1) {
       HEAP32[$2 + 16 >> 2] = $1;
       HEAP32[$1 + 24 >> 2] = $2;
      }
      $1 = HEAP32[$5 + 20 >> 2];
      if (!$1) {
       break label$18;
      }
      HEAP32[$2 + 20 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $2;
     }
     HEAP32[$3 + 4 >> 2] = $0 | 1;
     HEAP32[$0 + $3 >> 2] = $0;
     if (HEAP32[17795] != ($3 | 0)) {
      break label$14;
     }
     HEAP32[17792] = $0;
     return;
    }
    HEAP32[$5 + 4 >> 2] = $1 & -2;
    HEAP32[$3 + 4 >> 2] = $0 | 1;
    HEAP32[$0 + $3 >> 2] = $0;
   }
   if ($0 >>> 0 <= 255) {
    $1 = ($0 & -8) + 71200 | 0;
    $0 = 1 << ($0 >>> 3);
    $4 = HEAP32[17790];
    label$29: {
     if (!($0 & $4)) {
      HEAP32[17790] = $0 | $4;
      $0 = $1;
      break label$29;
     }
     $0 = HEAP32[$1 + 8 >> 2];
    }
    HEAP32[$1 + 8 >> 2] = $3;
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$3 + 12 >> 2] = $1;
    HEAP32[$3 + 8 >> 2] = $0;
    return;
   }
   $1 = 31;
   if ($0 >>> 0 <= 16777215) {
    $1 = $0 >>> 8 | 0;
    $2 = $1;
    $1 = $1 + 1048320 >>> 16 & 8;
    $4 = $2 << $1;
    $2 = $4;
    $4 = $4 + 520192 >>> 16 & 4;
    $2 = $2 << $4;
    $6 = $2;
    $2 = $2 + 245760 >>> 16 & 2;
    $1 = ($6 << $2 >>> 15 | 0) - ($1 | $4 | $2) | 0;
    $1 = ($1 << 1 | $0 >>> $1 + 21 & 1) + 28 | 0;
   }
   HEAP32[$3 + 28 >> 2] = $1;
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 20 >> 2] = 0;
   $4 = ($1 << 2) + 71464 | 0;
   label$32: {
    label$33: {
     $2 = HEAP32[17791];
     $5 = 1 << $1;
     label$34: {
      if (!($2 & $5)) {
       HEAP32[17791] = $2 | $5;
       HEAP32[$4 >> 2] = $3;
       break label$34;
      }
      $1 = $0 << (($1 | 0) == 31 ? 0 : 25 - ($1 >>> 1 | 0) | 0);
      $2 = HEAP32[$4 >> 2];
      while (1) {
       $4 = $2;
       if ((HEAP32[$2 + 4 >> 2] & -8) == ($0 | 0)) {
        break label$33;
       }
       $2 = $1 >>> 29 | 0;
       $1 = $1 << 1;
       $6 = ($2 & 4) + $4 | 0;
       $5 = $6 + 16 | 0;
       $2 = HEAP32[$5 >> 2];
       if ($2) {
        continue;
       }
       break;
      }
      HEAP32[$6 + 16 >> 2] = $3;
     }
     HEAP32[$3 + 24 >> 2] = $4;
     HEAP32[$3 + 12 >> 2] = $3;
     HEAP32[$3 + 8 >> 2] = $3;
     break label$32;
    }
    $0 = HEAP32[$4 + 8 >> 2];
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$4 + 8 >> 2] = $3;
    HEAP32[$3 + 24 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = $4;
    HEAP32[$3 + 8 >> 2] = $0;
   }
   $3 = HEAP32[17798] - 1 | 0;
   HEAP32[17798] = $3 ? $3 : -1;
  }
  return;
 }
 HEAP32[$3 + 4 >> 2] = $0 | 1;
 HEAP32[$0 + $3 >> 2] = $0;
}

function sqlite3EndTable($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $7 = __stack_pointer - 160 | 0;
 __stack_pointer = $7;
 label$1: {
  if (!($2 | $4)) {
   break label$1;
  }
  $5 = HEAP32[$0 + 236 >> 2];
  if (!$5) {
   break label$1;
  }
  $10 = HEAP32[$0 >> 2];
  label$2: {
   label$3: {
    label$4: {
     if (!$4) {
      if (sqlite3ShadowTableName($10, HEAP32[$5 >> 2])) {
       HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] | 4096;
      }
      $12 = $10 + 177 | 0;
      if (!HEAPU8[$12 | 0]) {
       break label$2;
      }
      $6 = HEAP32[$10 + 172 >> 2];
      if (!HEAPU8[$5 + 43 | 0]) {
       break label$3;
      }
      if ($6) {
       break label$4;
      }
      HEAP32[$5 + 20 >> 2] = 0;
      break label$2;
     }
     $12 = $10 + 177 | 0;
     if (!HEAPU8[$12 | 0]) {
      break label$2;
     }
    }
    sqlite3ErrorMsg($0, 29623, 0);
    break label$1;
   }
   HEAP32[$5 + 20 >> 2] = $6;
   if (($6 | 0) != 1) {
    break label$2;
   }
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] | 1;
  }
  label$7: {
   if (!($3 & 65536)) {
    break label$7;
   }
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] | 65536;
   $6 = 0;
   while (1) {
    if (HEAP16[$5 + 34 >> 1] <= ($6 | 0)) {
     break label$7;
    }
    $8 = HEAP32[$5 + 4 >> 2];
    $11 = $8 + Math_imul($6, 12) | 0;
    $9 = HEAPU8[$11 + 4 | 0];
    if ($9 >>> 0 <= 15) {
     $6 = Math_imul($6, 12) + $8 | 0;
     $11 = HEAP32[$6 >> 2];
     $5 = HEAP32[$5 >> 2];
     if (HEAPU8[$6 + 10 | 0] & 4) {
      HEAP32[$7 + 120 >> 2] = sqlite3ColumnType($6, 29623);
      HEAP32[$7 + 116 >> 2] = $11;
      HEAP32[$7 + 112 >> 2] = $5;
      sqlite3ErrorMsg($0, 28820, $7 + 112 | 0);
      break label$1;
     }
     HEAP32[$7 + 100 >> 2] = $11;
     HEAP32[$7 + 96 >> 2] = $5;
     sqlite3ErrorMsg($0, 5874, $7 + 96 | 0);
     break label$1;
    }
    $8 = $9 & 240;
    if (($8 | 0) == 16) {
     HEAP8[$11 + 5 | 0] = 65;
    }
    if (!(!(HEAP8[$11 + 10 | 0] & 1) | ($9 & 15 | HEAP16[$5 + 32 >> 1] == ($6 | 0)))) {
     HEAP8[$11 + 4 | 0] = $8 | 2;
     HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] | 2048;
    }
    $6 = $6 + 1 | 0;
    continue;
   }
  }
  if ($3 & 128) {
   $6 = HEAP32[$5 + 28 >> 2];
   if ($6 & 8) {
    sqlite3ErrorMsg($0, 5401, 0);
    break label$1;
   }
   if (!($6 & 4)) {
    HEAP32[$7 + 80 >> 2] = HEAP32[$5 >> 2];
    sqlite3ErrorMsg($0, 6553, $7 + 80 | 0);
    break label$1;
   }
   HEAP32[$5 + 28 >> 2] = $6 | 640;
   convertToWithoutRowidTable($0, $5);
  }
  $13 = sqlite3SchemaToIndex($10, HEAP32[$5 + 60 >> 2]);
  $6 = HEAP32[$5 + 16 >> 2];
  label$16: {
   if (!$6) {
    break label$16;
   }
   sqlite3ResolveSelfReference($0, $5, 4, 0, $6);
   if (!HEAP32[$0 + 36 >> 2]) {
    break label$16;
   }
   sqlite3ExprListDelete($10, HEAP32[$5 + 16 >> 2]);
   HEAP32[$5 + 16 >> 2] = 0;
  }
  label$17: {
   if (!(HEAPU8[$5 + 28 | 0] & 96)) {
    break label$17;
   }
   $8 = 0;
   $6 = 0;
   while (1) {
    if (($6 | 0) < HEAP16[$5 + 34 >> 1]) {
     $9 = Math_imul($6, 12);
     $11 = $9 + HEAP32[$5 + 4 >> 2] | 0;
     label$20: {
      if (HEAPU8[$11 + 10 | 0] & 96) {
       if (!sqlite3ResolveSelfReference($0, $5, 8, sqlite3ColumnExpr($5, $11), 0)) {
        break label$20;
       }
       sqlite3ColumnSetExpr($0, $5, HEAP32[$5 + 4 >> 2] + $9 | 0, sqlite3ExprAlloc($10, 121, 0, 0));
       break label$20;
      }
      $8 = $8 + 1 | 0;
     }
     $6 = $6 + 1 | 0;
     continue;
    }
    break;
   }
   if ($8) {
    break label$17;
   }
   sqlite3ErrorMsg($0, 10516, 0);
   break label$1;
  }
  estimateTableWidth($5);
  $6 = $5 + 8 | 0;
  while (1) {
   $6 = HEAP32[$6 >> 2];
   if ($6) {
    estimateIndexWidth($6);
    $6 = $6 + 20 | 0;
    continue;
   }
   break;
  }
  label$24: {
   if (!HEAPU8[$12 | 0]) {
    $6 = sqlite3GetVdbe($0);
    if (!$6) {
     break label$1;
    }
    sqlite3VdbeAddOp1($6, 122, 0);
    $11 = HEAPU8[$5 + 43 | 0];
    label$26: {
     if ($4) {
      if (HEAPU8[$0 + 208 | 0]) {
       HEAP32[$0 + 12 >> 2] = 1;
       HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
       break label$1;
      }
      $9 = HEAP32[$0 + 44 >> 2];
      $12 = $9 + 3 | 0;
      HEAP32[$0 + 44 >> 2] = $12;
      sqlite3MayAbort($0);
      sqlite3VdbeAddOp3($6, 113, 1, HEAP32[$0 + 92 >> 2], $13);
      sqlite3VdbeChangeP5($6, 16);
      HEAP32[$0 + 40 >> 2] = 2;
      $3 = $9 + 1 | 0;
      $14 = sqlite3VdbeCurrentAddr($6);
      sqlite3VdbeAddOp3($6, 10, $3, 0, $14 + 1 | 0);
      if (HEAP32[$0 + 36 >> 2]) {
       break label$1;
      }
      $8 = sqlite3ResultSetOfSelect($0, $4, 65);
      if (!$8) {
       break label$1;
      }
      $15 = HEAPU16[$8 + 34 >> 1];
      HEAP16[$5 + 34 >> 1] = $15;
      HEAP16[$5 + 36 >> 1] = $15;
      HEAP32[$5 + 4 >> 2] = HEAP32[$8 + 4 >> 2];
      HEAP32[$8 + 4 >> 2] = 0;
      HEAP16[$8 + 34 >> 1] = 0;
      sqlite3DeleteTable($10, $8);
      sqlite3SelectDestInit($7 + 128 | 0, 13, $3);
      sqlite3Select($0, $4, $7 + 128 | 0);
      if (HEAP32[$0 + 36 >> 2]) {
       break label$1;
      }
      sqlite3VdbeEndCoroutine($6, $3);
      sqlite3VdbeJumpHere($6, $14);
      $8 = sqlite3VdbeAddOp1($6, 11, HEAP32[$7 + 132 >> 2]);
      $9 = $9 + 2 | 0;
      sqlite3VdbeAddOp3($6, 97, HEAP32[$7 + 140 >> 2], HEAP32[$7 + 144 >> 2], $9);
      sqlite3TableAffinity($6, $5, 0);
      sqlite3VdbeAddOp2($6, 127, 1, $12);
      sqlite3VdbeAddOp3($6, 128, 1, $9, $12);
      sqlite3VdbeGoto($6, $8);
      sqlite3VdbeJumpHere($6, $8);
      sqlite3VdbeAddOp1($6, 122, 1);
      $9 = createTableStmt($10, $5);
      break label$26;
     }
     $8 = $11 ? 18211 : 19797;
     $14 = $3 ? $0 + 196 | 0 : $2;
     $3 = HEAP32[$14 >> 2];
     $12 = HEAP32[$0 + 188 >> 2];
     $9 = $3 - $12 | 0;
     $9 = HEAPU8[$3 | 0] != 59 ? HEAP32[$14 + 4 >> 2] + $9 | 0 : $9;
     HEAP32[$7 + 72 >> 2] = $12;
     HEAP32[$7 + 68 >> 2] = $9;
     HEAP32[$7 + 64 >> 2] = $8;
     $9 = sqlite3MPrintf($10, 5670, $7 - -64 | 0);
    }
    $3 = HEAP32[HEAP32[$10 + 16 >> 2] + ($13 << 4) >> 2];
    $8 = HEAP32[$5 >> 2];
    $12 = HEAP32[$0 + 92 >> 2];
    HEAP32[$7 + 56 >> 2] = HEAP32[$0 + 88 >> 2];
    HEAP32[$7 + 52 >> 2] = $9;
    HEAP32[$7 + 48 >> 2] = $12;
    HEAP32[$7 + 44 >> 2] = $8;
    HEAP32[$7 + 40 >> 2] = $8;
    HEAP32[$7 + 36 >> 2] = $11 ? 1826 : 13666;
    HEAP32[$7 + 32 >> 2] = $3;
    sqlite3NestedParse($0, 16151, $7 + 32 | 0);
    sqlite3DbFree($10, $9);
    sqlite3ChangeCookie($0, $13);
    label$30: {
     if (HEAPU8[$0 + 208 | 0] | !(HEAPU8[$5 + 28 | 0] & 8)) {
      break label$30;
     }
     $11 = HEAP32[$10 + 16 >> 2] + ($13 << 4) | 0;
     if (HEAP32[HEAP32[$11 + 12 >> 2] + 72 >> 2]) {
      break label$30;
     }
     HEAP32[$7 + 16 >> 2] = HEAP32[$11 >> 2];
     sqlite3NestedParse($0, 24573, $7 + 16 | 0);
    }
    HEAP32[$7 >> 2] = HEAP32[$5 >> 2];
    sqlite3VdbeAddParseSchemaOp($6, $13, sqlite3MPrintf($10, 27421, $7), 0);
    if (!HEAPU8[$10 + 177 | 0]) {
     break label$24;
    }
   }
   if (sqlite3HashInsert(HEAP32[$5 + 60 >> 2] + 8 | 0, HEAP32[$5 >> 2], $5)) {
    sqlite3OomFault($10);
    break label$1;
   }
   HEAP32[$0 + 236 >> 2] = 0;
   HEAP32[$10 + 24 >> 2] = HEAP32[$10 + 24 >> 2] | 1;
   if (strcmp(HEAP32[$5 >> 2], 14088)) {
    break label$24;
   }
   HEAP32[HEAP32[$5 + 60 >> 2] + 72 >> 2] = $5;
  }
  if (HEAPU8[$5 + 43 | 0] | $4) {
   break label$1;
  }
  HEAP32[$5 + 44 >> 2] = (HEAP32[(HEAP32[$1 >> 2] ? $1 : $2) >> 2] - HEAP32[$0 + 188 >> 2] | 0) + 13;
 }
 __stack_pointer = $7 + 160 | 0;
}

function strftimeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $3 = __stack_pointer - 288 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $9 = sqlite3_value_text(HEAP32[$2 >> 2]);
  if (!$9) {
   break label$1;
  }
  if (isDate($0, $1 - 1 | 0, $2 + 4 | 0, $3 + 240 | 0)) {
   break label$1;
  }
  $2 = 0;
  sqlite3StrAccumInit($3 + 216 | 0, 0, 0, 0, HEAP32[sqlite3_context_db_handle($0) + 120 >> 2]);
  computeJD($3 + 240 | 0);
  computeYMD_HMS($3 + 240 | 0);
  $4 = HEAP32[$3 + 244 >> 2];
  $12 = $4;
  $6 = HEAP32[$3 + 240 >> 2];
  $11 = $6;
  $13 = +($6 >>> 0) + +($4 | 0) * 4294967296;
  $6 = __wasm_i64_sdiv($6, $4, 1e3, 0);
  $14 = $6;
  $4 = i64toi32_i32$HIGH_BITS;
  $15 = $4;
  $4 = $12;
  $5 = $11 + 1296e5 | 0;
  $7 = $5 >>> 0 < 1296e5 ? $4 + 1 | 0 : $4;
  $1 = __wasm_i64_sdiv($5, $7, 864e5, 0);
  $7 = i64toi32_i32$HIGH_BITS;
  $1 = __wasm_i64_srem($1, $7, 7, 0) + 48 | 0;
  $5 = $4;
  $4 = $11;
  $6 = $4 + 432e5 | 0;
  $5 = $6 >>> 0 < 432e5 ? $5 + 1 | 0 : $5;
  $11 = $6;
  $12 = $5;
  $4 = __wasm_i64_sdiv($6, $5, 864e5, 0);
  $5 = i64toi32_i32$HIGH_BITS;
  $4 = __wasm_i64_srem($4, $5, 7, 0);
  $16 = $4;
  $5 = i64toi32_i32$HIGH_BITS;
  $4 = $5;
  $10 = HEAPF64[$3 + 272 >> 3];
  label$2: {
   if (Math_abs($10) < 2147483648) {
    $17 = ~~$10;
    break label$2;
   }
   $17 = -2147483648;
  }
  $10 = Math_min($10, 59.999);
  $13 = $13 / 864e5;
  $7 = $14;
  $14 = $7 - 413362496 | 0;
  $5 = $15;
  $6 = ($7 >>> 0 < 413362496) + 49 | 0;
  $6 = $5 - $6 | 0;
  $15 = $6;
  $18 = $16;
  $19 = HEAP32[$3 + 256 >> 2];
  $20 = HEAP32[$3 + 260 >> 2];
  $21 = HEAP32[$3 + 252 >> 2];
  $22 = HEAP32[$3 + 264 >> 2];
  $23 = HEAP32[$3 + 248 >> 2];
  $24 = $1 << 24 >> 24;
  $1 = 0;
  while (1) {
   $8 = HEAPU8[$1 + $9 | 0];
   label$5: {
    if (($8 | 0) != 37) {
     if ($8) {
      break label$5;
     }
     if ($1 >>> 0 > $2 >>> 0) {
      sqlite3_str_append($3 + 216 | 0, $2 + $9 | 0, $1 - $2 | 0);
     }
     sqlite3ResultStrAccum($0, $3 + 216 | 0);
     break label$1;
    }
    if ($1 >>> 0 > $2 >>> 0) {
     sqlite3_str_append($3 + 216 | 0, $2 + $9 | 0, $1 - $2 | 0);
    }
    $2 = $1 + 2 | 0;
    label$9: {
     label$10: {
      label$11: {
       label$12: {
        label$13: {
         label$14: {
          label$15: {
           label$16: {
            label$17: {
             label$18: {
              label$19: {
               label$20: {
                label$21: {
                 label$22: {
                  label$23: {
                   $1 = $1 + 1 | 0;
                   $8 = HEAP8[$9 + $1 | 0];
                   switch ($8 - 100 | 0) {
                   case 0:
                    break label$10;

                   case 1:
                   case 3:
                   case 4:
                   case 5:
                   case 7:
                   case 8:
                    break label$11;

                   case 9:
                    break label$18;

                   case 6:
                    break label$20;

                   case 2:
                    break label$22;

                   default:
                    break label$23;
                   }
                  }
                  label$24: {
                   switch ($8 - 72 | 0) {
                   case 1:
                   case 3:
                   case 4:
                    break label$11;

                   case 5:
                    break label$17;

                   case 2:
                    break label$19;

                   case 0:
                    break label$21;

                   default:
                    break label$24;
                   }
                  }
                  label$25: {
                   switch ($8 - 83 | 0) {
                   case 1:
                   case 2:
                   case 3:
                   case 5:
                    break label$11;

                   case 6:
                    break label$13;

                   case 0:
                    break label$15;

                   case 4:
                    break label$20;

                   default:
                    break label$25;
                   }
                  }
                  switch ($8 - 115 | 0) {
                  case 1:
                  case 2:
                  case 3:
                   break label$11;

                  case 4:
                   break label$14;

                  case 0:
                   break label$16;

                  default:
                   break label$12;
                  }
                 }
                 HEAPF64[$3 + 16 >> 3] = $10;
                 sqlite3_str_appendf($3 + 216 | 0, 12112, $3 + 16 | 0);
                 break label$5;
                }
                HEAP32[$3 + 32 >> 2] = $20;
                sqlite3_str_appendf($3 + 216 | 0, 15876, $3 + 32 | 0);
                break label$5;
               }
               __memcpy($3 + 168 | 0, $3 + 240 | 0, 48);
               HEAP32[$3 + 180 >> 2] = 1;
               HEAP32[$3 + 184 >> 2] = 1;
               HEAP8[$3 + 208 | 0] = 0;
               computeJD($3 + 168 | 0);
               $7 = HEAP32[$3 + 172 >> 2];
               $16 = $7;
               $5 = $11;
               $6 = HEAP32[$3 + 168 >> 2];
               $25 = $6;
               $4 = $5 - $6 | 0;
               $7 = $12;
               $6 = $16;
               $5 = __wasm_i64_sdiv($4, $7 - ($6 + ($5 >>> 0 < $25 >>> 0) | 0) | 0, 864e5, 0);
               if (($8 | 0) == 87) {
                HEAP32[$3 + 48 >> 2] = (($5 - $18 | 0) + 7 | 0) / 7;
                sqlite3_str_appendf($3 + 216 | 0, 15876, $3 + 48 | 0);
                break label$5;
               }
               HEAP32[$3 + 64 >> 2] = $5 + 1;
               sqlite3_str_appendf($3 + 216 | 0, 15871, $3 - -64 | 0);
               break label$5;
              }
              HEAPF64[$3 + 80 >> 3] = $13;
              sqlite3_str_appendf($3 + 216 | 0, 12010, $3 + 80 | 0);
              break label$5;
             }
             HEAP32[$3 + 96 >> 2] = $21;
             sqlite3_str_appendf($3 + 216 | 0, 15876, $3 + 96 | 0);
             break label$5;
            }
            HEAP32[$3 + 112 >> 2] = $22;
            sqlite3_str_appendf($3 + 216 | 0, 15876, $3 + 112 | 0);
            break label$5;
           }
           HEAP32[$3 + 128 >> 2] = $14;
           HEAP32[$3 + 132 >> 2] = $15;
           sqlite3_str_appendf($3 + 216 | 0, 14325, $3 + 128 | 0);
           break label$5;
          }
          HEAP32[$3 + 144 >> 2] = $17;
          sqlite3_str_appendf($3 + 216 | 0, 15876, $3 + 144 | 0);
          break label$5;
         }
         sqlite3_str_appendchar($3 + 216 | 0, 1, $24);
         break label$5;
        }
        HEAP32[$3 + 160 >> 2] = $23;
        sqlite3_str_appendf($3 + 216 | 0, 15866, $3 + 160 | 0);
        break label$5;
       }
       if (($8 | 0) == 37) {
        break label$9;
       }
      }
      sqlite3_str_reset($3 + 216 | 0);
      break label$1;
     }
     HEAP32[$3 >> 2] = $19;
     sqlite3_str_appendf($3 + 216 | 0, 15876, $3);
     break label$5;
    }
    sqlite3_str_appendchar($3 + 216 | 0, 1, 37);
   }
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $3 + 288 | 0;
}

function dispose_chunk($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = $0 + $1 | 0;
 $2 = HEAP32[$0 + 4 >> 2];
 label$1: {
  label$2: {
   if ($2 & 1) {
    break label$2;
   }
   if (!($2 & 3)) {
    break label$1;
   }
   $2 = HEAP32[$0 >> 2];
   $1 = $2 + $1 | 0;
   label$3: {
    $0 = $0 - $2 | 0;
    if (($0 | 0) != HEAP32[17795]) {
     if ($2 >>> 0 <= 255) {
      $6 = $2 >>> 3 | 0;
      $3 = ($6 << 3) + 71200 | 0;
      $4 = HEAP32[$0 + 8 >> 2];
      $2 = HEAP32[$0 + 12 >> 2];
      if (($4 | 0) != ($2 | 0)) {
       break label$3;
      }
      HEAP32[17790] = HEAP32[17790] & __wasm_rotl_i32(-2, $6);
      break label$2;
     }
     $7 = HEAP32[$0 + 24 >> 2];
     $3 = HEAP32[$0 + 12 >> 2];
     label$6: {
      if (($3 | 0) != ($0 | 0)) {
       $2 = HEAP32[$0 + 8 >> 2];
       HEAP32[$2 + 12 >> 2] = $3;
       HEAP32[$3 + 8 >> 2] = $2;
       break label$6;
      }
      label$8: {
       $2 = $0 + 20 | 0;
       $4 = HEAP32[$2 >> 2];
       if ($4) {
        break label$8;
       }
       $2 = $0 + 16 | 0;
       $4 = HEAP32[$2 >> 2];
       if ($4) {
        break label$8;
       }
       $3 = 0;
       break label$6;
      }
      while (1) {
       $6 = $2;
       $3 = $4;
       $2 = $3 + 20 | 0;
       $4 = HEAP32[$2 >> 2];
       if ($4) {
        continue;
       }
       $2 = $3 + 16 | 0;
       $4 = HEAP32[$3 + 16 >> 2];
       if ($4) {
        continue;
       }
       break;
      }
      HEAP32[$6 >> 2] = 0;
     }
     if (!$7) {
      break label$2;
     }
     $4 = HEAP32[$0 + 28 >> 2];
     $2 = ($4 << 2) + 71464 | 0;
     label$10: {
      if (HEAP32[$2 >> 2] == ($0 | 0)) {
       HEAP32[$2 >> 2] = $3;
       if ($3) {
        break label$10;
       }
       HEAP32[17791] = HEAP32[17791] & __wasm_rotl_i32(-2, $4);
       break label$2;
      }
      HEAP32[(HEAP32[$7 + 16 >> 2] == ($0 | 0) ? 16 : 20) + $7 >> 2] = $3;
      if (!$3) {
       break label$2;
      }
     }
     HEAP32[$3 + 24 >> 2] = $7;
     $2 = HEAP32[$0 + 16 >> 2];
     if ($2) {
      HEAP32[$3 + 16 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $3;
     }
     $2 = HEAP32[$0 + 20 >> 2];
     if (!$2) {
      break label$2;
     }
     HEAP32[$3 + 20 >> 2] = $2;
     HEAP32[$2 + 24 >> 2] = $3;
     break label$2;
    }
    $2 = HEAP32[$5 + 4 >> 2];
    if (($2 & 3) != 3) {
     break label$2;
    }
    HEAP32[17792] = $1;
    HEAP32[$5 + 4 >> 2] = $2 & -2;
    HEAP32[$0 + 4 >> 2] = $1 | 1;
    HEAP32[$5 >> 2] = $1;
    return;
   }
   HEAP32[$4 + 12 >> 2] = $2;
   HEAP32[$2 + 8 >> 2] = $4;
  }
  $2 = HEAP32[$5 + 4 >> 2];
  label$13: {
   if (!($2 & 2)) {
    if (HEAP32[17796] == ($5 | 0)) {
     HEAP32[17796] = $0;
     $1 = HEAP32[17793] + $1 | 0;
     HEAP32[17793] = $1;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     if (HEAP32[17795] != ($0 | 0)) {
      break label$1;
     }
     HEAP32[17792] = 0;
     HEAP32[17795] = 0;
     return;
    }
    if (HEAP32[17795] == ($5 | 0)) {
     HEAP32[17795] = $0;
     $1 = HEAP32[17792] + $1 | 0;
     HEAP32[17792] = $1;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + $1 >> 2] = $1;
     return;
    }
    $1 = ($2 & -8) + $1 | 0;
    label$17: {
     if ($2 >>> 0 <= 255) {
      $6 = $2 >>> 3 | 0;
      $3 = ($6 << 3) + 71200 | 0;
      $4 = HEAP32[$5 + 8 >> 2];
      $2 = HEAP32[$5 + 12 >> 2];
      if (($4 | 0) == ($2 | 0)) {
       HEAP32[17790] = HEAP32[17790] & __wasm_rotl_i32(-2, $6);
       break label$17;
      }
      HEAP32[$4 + 12 >> 2] = $2;
      HEAP32[$2 + 8 >> 2] = $4;
      break label$17;
     }
     $7 = HEAP32[$5 + 24 >> 2];
     $3 = HEAP32[$5 + 12 >> 2];
     label$20: {
      if (($5 | 0) != ($3 | 0)) {
       $2 = HEAP32[$5 + 8 >> 2];
       HEAP32[$2 + 12 >> 2] = $3;
       HEAP32[$3 + 8 >> 2] = $2;
       break label$20;
      }
      label$22: {
       $4 = $5 + 20 | 0;
       $2 = HEAP32[$4 >> 2];
       if ($2) {
        break label$22;
       }
       $4 = $5 + 16 | 0;
       $2 = HEAP32[$4 >> 2];
       if ($2) {
        break label$22;
       }
       $3 = 0;
       break label$20;
      }
      while (1) {
       $6 = $4;
       $3 = $2;
       $4 = $2 + 20 | 0;
       $2 = HEAP32[$4 >> 2];
       if ($2) {
        continue;
       }
       $4 = $3 + 16 | 0;
       $2 = HEAP32[$3 + 16 >> 2];
       if ($2) {
        continue;
       }
       break;
      }
      HEAP32[$6 >> 2] = 0;
     }
     if (!$7) {
      break label$17;
     }
     $4 = HEAP32[$5 + 28 >> 2];
     $2 = ($4 << 2) + 71464 | 0;
     label$24: {
      if (HEAP32[$2 >> 2] == ($5 | 0)) {
       HEAP32[$2 >> 2] = $3;
       if ($3) {
        break label$24;
       }
       HEAP32[17791] = HEAP32[17791] & __wasm_rotl_i32(-2, $4);
       break label$17;
      }
      HEAP32[(HEAP32[$7 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $7 >> 2] = $3;
      if (!$3) {
       break label$17;
      }
     }
     HEAP32[$3 + 24 >> 2] = $7;
     $2 = HEAP32[$5 + 16 >> 2];
     if ($2) {
      HEAP32[$3 + 16 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $3;
     }
     $2 = HEAP32[$5 + 20 >> 2];
     if (!$2) {
      break label$17;
     }
     HEAP32[$3 + 20 >> 2] = $2;
     HEAP32[$2 + 24 >> 2] = $3;
    }
    HEAP32[$0 + 4 >> 2] = $1 | 1;
    HEAP32[$0 + $1 >> 2] = $1;
    if (HEAP32[17795] != ($0 | 0)) {
     break label$13;
    }
    HEAP32[17792] = $1;
    return;
   }
   HEAP32[$5 + 4 >> 2] = $2 & -2;
   HEAP32[$0 + 4 >> 2] = $1 | 1;
   HEAP32[$0 + $1 >> 2] = $1;
  }
  if ($1 >>> 0 <= 255) {
   $2 = ($1 & -8) + 71200 | 0;
   $1 = 1 << ($1 >>> 3);
   $4 = HEAP32[17790];
   label$28: {
    if (!($1 & $4)) {
     HEAP32[17790] = $1 | $4;
     $1 = $2;
     break label$28;
    }
    $1 = HEAP32[$2 + 8 >> 2];
   }
   HEAP32[$2 + 8 >> 2] = $0;
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[$0 + 12 >> 2] = $2;
   HEAP32[$0 + 8 >> 2] = $1;
   return;
  }
  $2 = 31;
  if ($1 >>> 0 <= 16777215) {
   $2 = $1 >>> 8 | 0;
   $3 = $2;
   $2 = $2 + 1048320 >>> 16 & 8;
   $4 = $3 << $2;
   $3 = $4;
   $4 = $4 + 520192 >>> 16 & 4;
   $3 = $3 << $4;
   $6 = $3;
   $3 = $3 + 245760 >>> 16 & 2;
   $2 = ($6 << $3 >>> 15 | 0) - ($2 | $4 | $3) | 0;
   $2 = ($2 << 1 | $1 >>> $2 + 21 & 1) + 28 | 0;
  }
  HEAP32[$0 + 28 >> 2] = $2;
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  $4 = ($2 << 2) + 71464 | 0;
  label$31: {
   $3 = HEAP32[17791];
   $5 = 1 << $2;
   label$32: {
    if (!($3 & $5)) {
     HEAP32[17791] = $3 | $5;
     HEAP32[$4 >> 2] = $0;
     break label$32;
    }
    $2 = $1 << (($2 | 0) == 31 ? 0 : 25 - ($2 >>> 1 | 0) | 0);
    $3 = HEAP32[$4 >> 2];
    while (1) {
     $4 = $3;
     if ((HEAP32[$3 + 4 >> 2] & -8) == ($1 | 0)) {
      break label$31;
     }
     $3 = $2 >>> 29 | 0;
     $2 = $2 << 1;
     $6 = ($3 & 4) + $4 | 0;
     $5 = $6 + 16 | 0;
     $3 = HEAP32[$5 >> 2];
     if ($3) {
      continue;
     }
     break;
    }
    HEAP32[$6 + 16 >> 2] = $0;
   }
   HEAP32[$0 + 24 >> 2] = $4;
   HEAP32[$0 + 12 >> 2] = $0;
   HEAP32[$0 + 8 >> 2] = $0;
   return;
  }
  $1 = HEAP32[$4 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$4 + 8 >> 2] = $0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = $4;
  HEAP32[$0 + 8 >> 2] = $1;
 }
}

function sqlite3Fts3EvalPhrasePoslist($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $13 = HEAP32[$0 >> 2];
 $16 = HEAP32[$1 + 20 >> 2];
 HEAP32[$3 >> 2] = 0;
 $6 = HEAP32[$16 + 68 >> 2];
 label$1: {
  if (($6 | 0) != ($2 | 0) & HEAP32[$13 + 24 >> 2] > ($6 | 0)) {
   break label$1;
  }
  $8 = HEAP32[$1 + 28 >> 2];
  $11 = $8;
  $9 = HEAP32[$1 + 24 >> 2];
  $12 = $9;
  HEAP32[$4 + 16 >> 2] = $9;
  HEAP32[$4 + 20 >> 2] = $8;
  $6 = HEAP32[$16 + 28 >> 2];
  HEAP32[$4 + 28 >> 2] = $6;
  label$3: {
   $8 = HEAP32[$0 + 32 >> 2];
   $5 = $9;
   $5 = ($8 | 0) == ($5 | 0);
   $9 = HEAP32[$0 + 36 >> 2];
   $8 = $11;
   if (HEAPU8[$1 + 32 | 0] ? 0 : $5 & ($9 | 0) == ($8 | 0)) {
    break label$3;
   }
   HEAP32[$4 + 24 >> 2] = 0;
   $13 = HEAPU8[$13 + 239 | 0];
   $6 = 0;
   $10 = $1;
   while (1) {
    $1 = HEAP32[$1 + 8 >> 2];
    if ($1) {
     $6 = HEAPU8[$1 + 32 | 0] ? 1 : $6;
     $5 = HEAP32[$1 >> 2];
     $10 = ($5 | 0) == 1 ? $1 : $10;
     $7 = ($5 | 0) == 4 ? 1 : $7;
     continue;
    }
    break;
   }
   if (!$7) {
    $7 = 0;
    break label$1;
   }
   if (HEAP32[$16 + 40 >> 2]) {
    $14 = HEAPU8[$10 + 32 | 0];
    fts3EvalRestart($0, $10, $4 + 24 | 0);
    $1 = $14;
    label$9: {
     while (1) {
      $7 = HEAP32[$4 + 24 >> 2];
      if ($7) {
       break label$1;
      }
      $5 = HEAPU8[$10 + 32 | 0];
      if ($5) {
       break label$9;
      }
      fts3EvalNextRow($0, $10, $4 + 24 | 0);
      if ($1) {
       continue;
      }
      $8 = $12;
      $5 = $10;
      $5 = HEAP32[$5 + 24 >> 2];
      $9 = HEAP32[$10 + 28 >> 2];
      if (($8 | 0) != ($5 | 0) | ($11 | 0) != ($9 | 0)) {
       continue;
      }
      break;
     }
     $7 = HEAP32[$4 + 24 >> 2];
     if ($7) {
      break label$1;
     }
     $5 = HEAPU8[$10 + 32 | 0];
    }
    $7 = 267;
    if (($5 & 255) != ($14 | 0)) {
     break label$1;
    }
   }
   label$11: {
    if (!($6 & 255)) {
     break label$11;
    }
    while (1) {
     if (HEAPU8[$10 + 32 | 0]) {
      break label$11;
     }
     fts3EvalNextRow($0, $10, $4 + 24 | 0);
     $7 = HEAP32[$4 + 24 >> 2];
     if (!$7) {
      continue;
     }
     break;
    }
    break label$1;
   }
   $14 = 1;
   while (1) {
    label$14: {
     label$15: {
      label$16: {
       if ($10) {
        $1 = $10;
        if (HEAP32[$1 >> 2] == 1) {
         $1 = HEAP32[$10 + 16 >> 2];
        }
        $1 = HEAP32[$1 + 20 >> 2];
        $7 = HEAP32[$1 + 48 >> 2];
        HEAP32[$4 + 28 >> 2] = $7;
        $9 = HEAP32[$1 + 60 >> 2];
        $5 = HEAP32[$1 + 56 >> 2];
        HEAP32[$4 + 16 >> 2] = $5;
        HEAP32[$4 + 20 >> 2] = $9;
        $6 = HEAP32[$1 + 4 >> 2];
        if (HEAPU8[$0 + 52 | 0] != ($13 | 0)) {
         break label$16;
        }
        $6 = $6 ? HEAP32[$1 >> 2] + $6 >>> 0 <= $7 >>> 0 : 1;
        HEAP8[$4 + 15 | 0] = $6;
        while (1) {
         label$22: {
          if ($7) {
           $9 = HEAP32[$4 + 16 >> 2];
           $12 = $9;
           $5 = HEAP32[$4 + 20 >> 2];
           $11 = $5;
           $5 = HEAP32[$0 + 32 >> 2];
           $17 = $5;
           $9 = HEAP32[$0 + 36 >> 2];
           $15 = $9;
           $6 = HEAPU8[$4 + 15 | 0];
           $8 = $12;
           $9 = $11;
           $5 = $15;
           $11 = ($17 | 0) != ($8 | 0) | ($9 | 0) != ($5 | 0) ? -1 : 0;
           $8 = $9;
           $9 = $5;
           $5 = $17;
           $5 = $5 >>> 0 < $12 >>> 0 & ($8 | 0) >= ($9 | 0) | ($8 | 0) > ($9 | 0) ? 1 : $11;
           if ($6 | (($13 ? 0 - $5 | 0 : $5) | 0) >= 0) {
            break label$14;
           }
           break label$22;
          }
          $6 = HEAPU8[$4 + 15 | 0];
          if ($6) {
           break label$15;
          }
         }
         sqlite3Fts3DoclistNext($13, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], $4 + 28 | 0, $4 + 16 | 0, $4 + 15 | 0);
         $7 = HEAP32[$4 + 28 >> 2];
         continue;
        }
       }
       $6 = $14 ? HEAP32[$16 + 48 >> 2] : 0;
       HEAP32[$4 + 28 >> 2] = $6;
       break label$3;
      }
      $5 = 1;
      label$26: {
       if (!$6) {
        break label$26;
       }
       $5 = 0;
       if (!$7) {
        break label$26;
       }
       $5 = HEAPU32[$1 >> 2] >= $7 >>> 0;
      }
      $6 = $5;
      HEAP8[$4 + 15 | 0] = $6;
      while (1) {
       label$28: {
        if ($7) {
         $6 = HEAPU8[$4 + 15 | 0];
         $8 = HEAP32[$4 + 20 >> 2];
         $11 = $8;
         $5 = $0;
         $8 = HEAP32[$5 + 32 >> 2];
         $17 = $8;
         $9 = $8;
         $12 = HEAP32[$4 + 16 >> 2];
         $5 = $12;
         $15 = HEAP32[$0 + 36 >> 2];
         $8 = $15;
         $12 = $9 >>> 0 > $5 >>> 0 & ($11 | 0) <= ($8 | 0) | ($11 | 0) < ($8 | 0);
         $9 = $5;
         $8 = $17;
         $5 = $11;
         if ((($13 ? $12 : $9 >>> 0 > $8 >>> 0 & ($5 | 0) >= ($15 | 0) | ($5 | 0) > ($15 | 0)) | 0) != 1) {
          break label$14;
         }
         if (!($6 & 255)) {
          break label$28;
         }
         break label$14;
        }
        $6 = HEAPU8[$4 + 15 | 0];
        if ($6) {
         break label$15;
        }
       }
       sqlite3Fts3DoclistPrev($13, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], $4 + 28 | 0, $4 + 16 | 0, $4 + 8 | 0, $4 + 15 | 0);
       $7 = HEAP32[$4 + 28 >> 2];
       continue;
      }
     }
     $7 = 0;
    }
    HEAP32[$1 + 48 >> 2] = $7;
    $9 = HEAP32[$4 + 16 >> 2];
    $12 = $9;
    $5 = HEAP32[$4 + 20 >> 2];
    $11 = $5;
    HEAP32[$1 + 56 >> 2] = $12;
    HEAP32[$1 + 60 >> 2] = $5;
    label$30: {
     if (!($6 & 255)) {
      $8 = $0;
      $5 = HEAP32[$8 + 32 >> 2];
      $9 = HEAP32[$8 + 36 >> 2];
      $1 = $9;
      $8 = $12;
      $8 = ($5 | 0) == ($8 | 0);
      $9 = $11;
      $5 = $1;
      if ($8 & ($9 | 0) == ($5 | 0)) {
       break label$30;
      }
     }
     $14 = 0;
    }
    $10 = HEAP32[$10 + 12 >> 2];
    continue;
   }
  }
  $7 = 0;
  if (!$6) {
   break label$1;
  }
  label$32: {
   if (HEAPU8[$6 | 0] == 1) {
    $1 = $6 + 1 | 0;
    HEAP32[$4 + 28 >> 2] = $1;
    $7 = HEAP8[$6 + 1 | 0];
    label$34: {
     if (($7 | 0) < 0) {
      $7 = sqlite3Fts3GetVarint32($1, $4 + 24 | 0);
      break label$34;
     }
     HEAP32[$4 + 24 >> 2] = $7 & 255;
     $7 = 1;
    }
    $6 = $7 + $1 | 0;
    HEAP32[$4 + 28 >> 2] = $6;
    break label$32;
   }
   HEAP32[$4 + 24 >> 2] = 0;
  }
  while (1) {
   $1 = HEAP32[$4 + 24 >> 2];
   if (($2 | 0) > ($1 | 0)) {
    $7 = 0;
    fts3ColumnlistCopy(0, $4 + 28 | 0);
    $1 = HEAP32[$4 + 28 >> 2];
    if (!HEAPU8[$1 | 0]) {
     break label$1;
    }
    $7 = $1 + 1 | 0;
    $1 = HEAP8[$1 + 1 | 0];
    label$38: {
     if (($1 | 0) < 0) {
      $1 = sqlite3Fts3GetVarint32($7, $4 + 24 | 0);
      break label$38;
     }
     HEAP32[$4 + 24 >> 2] = $1 & 255;
     $1 = 1;
    }
    $6 = $7 + $1 | 0;
    HEAP32[$4 + 28 >> 2] = $6;
    continue;
   }
   break;
  }
  $7 = 0;
  HEAP32[$3 >> 2] = ($1 | 0) == ($2 | 0) ? HEAPU8[$6 | 0] ? $6 : 0 : 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return $7;
}

function sqlite3VdbeMemTranslate($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  if (!(($1 | 0) == 1 | HEAPU8[$0 + 18 | 0] == 1)) {
   $3 = 7;
   if (sqlite3VdbeMemMakeWriteable($0)) {
    break label$1;
   }
   $2 = HEAP32[$0 + 8 >> 2];
   $8 = $2 + (HEAP32[$0 + 12 >> 2] & -2) | 0;
   while (1) {
    if ($2 >>> 0 < $8 >>> 0) {
     $3 = HEAPU8[$2 + 1 | 0];
     HEAP8[$2 + 1 | 0] = HEAPU8[$2 | 0];
     HEAP8[$2 | 0] = $3;
     $2 = $2 + 2 | 0;
     continue;
    }
    break;
   }
   HEAP8[$0 + 18 | 0] = $1;
   return 0;
  }
  $2 = HEAP32[$0 + 12 >> 2];
  label$5: {
   if (($1 | 0) == 1) {
    $2 = $2 & -2;
    HEAP32[$0 + 12 >> 2] = $2;
    $5 = $2 >> 31;
    $3 = $5 << 1 | $2 >>> 31;
    $5 = $2 << 1;
    $9 = $5 | 1;
    $5 = $3;
    break label$5;
   }
   $3 = $2 >> 31;
   $5 = $3 << 1 | $2 >>> 31;
   $3 = $2 << 1;
   $3 = $3 + 2 | 0;
   $5 = $3 >>> 0 < 2 ? $5 + 1 | 0 : $5;
   $9 = $3;
  }
  $3 = HEAP32[$0 + 8 >> 2];
  $9 = sqlite3DbMallocRaw(HEAP32[$0 + 20 >> 2], $9, $5);
  if (!$9) {
   return 7;
  }
  $8 = $2 + $3 | 0;
  $2 = $9;
  label$8: {
   label$9: {
    label$10: {
     label$11: {
      label$12: {
       switch (HEAPU8[$0 + 18 | 0] - 1 | 0) {
       case 0:
        if (($1 | 0) != 2) {
         break label$10;
        }
        $5 = $9;
        label$15: while (1) {
         if ($3 >>> 0 >= $8 >>> 0) {
          break label$9;
         }
         $2 = $3 + 1 | 0;
         label$16: {
          $6 = HEAPU8[$3 | 0];
          if ($6 >>> 0 < 192) {
           $3 = $2;
           break label$16;
          }
          $4 = HEAPU8[$6 + 32128 | 0];
          while (1) {
           label$19: {
            if (($2 | 0) == ($8 | 0)) {
             $2 = $8;
            } else {
             $3 = HEAPU8[$2 | 0];
             if (($3 & 192) == 128) {
              break label$19;
             }
            }
            $3 = $2;
            $6 = 65533;
            if (($4 & -2) == 65534 | $4 >>> 0 < 128 | ($4 & -2048) == 55296) {
             break label$16;
            }
            if ($4 >>> 0 <= 65535) {
             $6 = $4;
             break label$16;
            }
            HEAP8[$5 + 2 | 0] = $4;
            HEAP8[$5 + 3 | 0] = $4 >>> 8 & 3 | 220;
            $2 = $4 - 65536 | 0;
            HEAP8[$5 + 1 | 0] = $2 >>> 18 & 3 | 216;
            HEAP8[$5 | 0] = $2 >>> 10 & 192 | $4 >>> 10 & 63;
            $5 = $5 + 4 | 0;
            continue label$15;
           }
           $4 = $3 & 63 | $4 << 6;
           $2 = $2 + 1 | 0;
           continue;
          }
         }
         HEAP8[$5 | 0] = $6;
         HEAP8[$5 + 1 | 0] = $6 >>> 8;
         $5 = $5 + 2 | 0;
         continue;
        }
        ;

       default:
        while (1) {
         if ($3 >>> 0 >= $8 >>> 0) {
          break label$11;
         }
         $7 = HEAPU8[$3 + 1 | 0];
         $6 = HEAPU8[$3 | 0];
         $4 = $7 | $6 << 8;
         $5 = $3 + 2 | 0;
         if (!(($6 & 248) != 216 | $8 >>> 0 <= $5 >>> 0)) {
          $5 = HEAPU8[$3 + 2 | 0];
          $6 = HEAPU8[$3 + 3 | 0];
          HEAP8[$2 + 3 | 0] = $6 & 63 | 128;
          $4 = ($4 << 10 & 983040) + 65536 | 0;
          HEAP8[$2 | 0] = $4 >>> 18 | 240;
          $7 = $7 << 10;
          HEAP8[$2 + 1 | 0] = ($7 & 61440 | $4) >>> 12 & 63 | 128;
          HEAP8[$2 + 2 | 0] = ($5 << 8 & 768 | $6 | $7) >>> 6 & 63 | 128;
          $2 = $2 + 4 | 0;
          $3 = $3 + 4 | 0;
          continue;
         }
         if ($4 >>> 0 <= 127) {
          HEAP8[$2 | 0] = $7;
          $2 = $2 + 1 | 0;
          $3 = $5;
          continue;
         } else {
          if ($4 >>> 0 <= 2047) {
           HEAP8[$2 + 1 | 0] = $7 & 63 | 128;
           HEAP8[$2 | 0] = $4 >>> 6 | 192;
           $2 = $2 + 2 | 0;
          } else {
           HEAP8[$2 + 2 | 0] = $7 & 63 | 128;
           HEAP8[$2 | 0] = $6 >>> 4 | 224;
           HEAP8[$2 + 1 | 0] = $4 >>> 6 & 63 | 128;
           $2 = $2 + 3 | 0;
          }
          $3 = $5;
          continue;
         }
        }
        ;

       case 1:
        break label$12;
       }
      }
      while (1) {
       if ($3 >>> 0 >= $8 >>> 0) {
        break label$11;
       }
       $7 = HEAPU8[$3 | 0];
       $6 = HEAPU8[$3 + 1 | 0];
       $4 = $7 | $6 << 8;
       $5 = $3 + 2 | 0;
       if (!(($6 & 248) != 216 | $8 >>> 0 <= $5 >>> 0)) {
        $5 = HEAPU8[$3 + 3 | 0];
        $6 = HEAPU8[$3 + 2 | 0];
        HEAP8[$2 + 3 | 0] = $6 & 63 | 128;
        $4 = ($4 << 10 & 983040) + 65536 | 0;
        HEAP8[$2 | 0] = $4 >>> 18 | 240;
        $7 = $7 << 10;
        HEAP8[$2 + 1 | 0] = ($7 & 61440 | $4) >>> 12 & 63 | 128;
        HEAP8[$2 + 2 | 0] = ($5 << 8 & 768 | $6 | $7) >>> 6 & 63 | 128;
        $2 = $2 + 4 | 0;
        $3 = $3 + 4 | 0;
        continue;
       }
       if ($4 >>> 0 <= 127) {
        HEAP8[$2 | 0] = $7;
        $2 = $2 + 1 | 0;
        $3 = $5;
        continue;
       } else {
        if ($4 >>> 0 <= 2047) {
         HEAP8[$2 + 1 | 0] = $7 & 63 | 128;
         HEAP8[$2 | 0] = $4 >>> 6 | 192;
         $2 = $2 + 2 | 0;
        } else {
         HEAP8[$2 + 2 | 0] = $7 & 63 | 128;
         HEAP8[$2 | 0] = $6 >>> 4 | 224;
         HEAP8[$2 + 1 | 0] = $4 >>> 6 & 63 | 128;
         $2 = $2 + 3 | 0;
        }
        $3 = $5;
        continue;
       }
      }
     }
     HEAP32[$0 + 12 >> 2] = $2 - $9;
     break label$8;
    }
    $5 = $9;
    while (1) {
     if ($3 >>> 0 >= $8 >>> 0) {
      break label$9;
     }
     $2 = $3 + 1 | 0;
     $4 = HEAPU8[$3 | 0];
     label$34: {
      label$35: {
       if ($4 >>> 0 < 192) {
        $3 = $2;
        break label$35;
       }
       $4 = HEAPU8[$4 + 32128 | 0];
       while (1) {
        label$38: {
         label$39: {
          if (($2 | 0) == ($8 | 0)) {
           $2 = $8;
          } else {
           $3 = HEAPU8[$2 | 0];
           if (($3 & 192) == 128) {
            break label$39;
           }
          }
          $3 = $2;
          if (($4 & -2) == 65534 | $4 >>> 0 < 128 | ($4 & -2048) == 55296) {
           break label$38;
          }
          if ($4 >>> 0 <= 65535) {
           break label$35;
          }
          HEAP8[$5 + 2 | 0] = $4 >>> 8 & 3 | 220;
          $2 = $4 - 65536 | 0;
          HEAP8[$5 + 1 | 0] = $2 >>> 10 & 192 | $4 >>> 10 & 63;
          HEAP8[$5 | 0] = $2 >>> 18 & 3 | 216;
          $2 = $5 + 3 | 0;
          $6 = 4;
          break label$34;
         }
         $4 = $3 & 63 | $4 << 6;
         $2 = $2 + 1 | 0;
         continue;
        }
        break;
       }
       $4 = 65533;
      }
      HEAP8[$5 | 0] = $4 >>> 8;
      $2 = $5 + 1 | 0;
      $6 = 2;
     }
     HEAP8[$2 | 0] = $4;
     $5 = $5 + $6 | 0;
     continue;
    }
   }
   HEAP32[$0 + 12 >> 2] = $5 - $9;
   HEAP8[$5 | 0] = 0;
   $2 = $5 + 1 | 0;
  }
  HEAP8[$2 | 0] = 0;
  $2 = HEAPU16[$0 + 16 >> 1];
  sqlite3VdbeMemRelease($0);
  HEAP8[$0 + 18 | 0] = $1;
  HEAP32[$0 + 32 >> 2] = $9;
  HEAP32[$0 + 8 >> 2] = $9;
  HEAP16[$0 + 16 >> 1] = $2 & 2109 | 514;
  HEAP32[$0 + 24 >> 2] = sqlite3DbMallocSize(HEAP32[$0 + 20 >> 2], $9);
  $3 = 0;
 }
 return $3;
}

function multiSelectOrderBy($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 $10 = __stack_pointer - 80 | 0;
 __stack_pointer = $10;
 $4 = HEAP32[$0 + 8 >> 2];
 $17 = HEAP32[$0 >> 2];
 $15 = sqlite3VdbeMakeLabel($0);
 $20 = sqlite3VdbeMakeLabel($0);
 $7 = HEAP32[$1 + 48 >> 2];
 $12 = HEAP32[$7 >> 2];
 label$1: {
  label$2: {
   $13 = HEAPU8[$1 | 0];
   if (($13 | 0) == 135) {
    break label$2;
   }
   $6 = 1;
   label$3: while (1) {
    if (HEAPU8[$17 + 87 | 0] | HEAP32[HEAP32[$1 + 28 >> 2] >> 2] < ($6 | 0)) {
     break label$2;
    }
    $3 = 0;
    $16 = ($12 | 0) > 0 ? $12 : 0;
    $5 = $7 + 8 | 0;
    while (1) {
     label$5: {
      if (($3 | 0) != ($16 | 0)) {
       if (HEAPU16[$5 + 12 >> 1] != ($6 | 0)) {
        break label$5;
       }
       $16 = $3;
      }
      label$7: {
       if (($12 | 0) != ($16 | 0)) {
        break label$7;
       }
       $3 = sqlite3Expr($17, 155, 0);
       $5 = 7;
       if (!$3) {
        break label$1;
       }
       HEAP32[$3 + 8 >> 2] = $6;
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] | 2048;
       $7 = sqlite3ExprListAppend($0, $7, $3);
       HEAP32[$1 + 48 >> 2] = $7;
       if (!$7) {
        $7 = 0;
        break label$7;
       }
       HEAP16[(($12 << 4) + $7 | 0) + 20 >> 1] = $6;
       $12 = $12 + 1 | 0;
      }
      $6 = $6 + 1 | 0;
      continue label$3;
     }
     $5 = $5 + 16 | 0;
     $3 = $3 + 1 | 0;
     continue;
    }
   }
  }
  $6 = 0;
  $16 = sqlite3DbMallocRawNN($17, ($12 << 2) + 4 | 0, 0);
  if ($16) {
   HEAP32[$16 >> 2] = $12;
   $5 = $7 + 8 | 0;
   $8 = (($12 | 0) > 0 ? $12 : 0) + 1 | 0;
   $3 = 1;
   while (1) {
    if (($3 | 0) != ($8 | 0)) {
     HEAP32[($3 << 2) + $16 >> 2] = HEAPU16[$5 + 12 >> 1] - 1;
     $5 = $5 + 16 | 0;
     $3 = $3 + 1 | 0;
     continue;
    }
    break;
   }
   $25 = multiSelectOrderByKeyInfo($0, $1);
  }
  label$12: {
   if (($13 | 0) != 135) {
    $3 = HEAP32[HEAP32[$1 + 28 >> 2] >> 2];
    $18 = HEAP32[$0 + 44 >> 2] + 1 | 0;
    HEAP32[$0 + 44 >> 2] = $3 + $18;
    sqlite3VdbeAddOp2($4, 71, 0, $18);
    label$14: {
     $6 = sqlite3KeyInfoAlloc($17, $3, 1);
     if (!$6) {
      break label$14;
     }
     $5 = ($3 | 0) > 0 ? $3 : 0;
     $3 = 0;
     while (1) {
      if (($3 | 0) == ($5 | 0)) {
       break label$14;
      }
      HEAP32[(($3 << 2) + $6 | 0) + 20 >> 2] = multiSelectCollSeq($0, $1, $3);
      HEAP8[HEAP32[$6 + 16 >> 2] + $3 | 0] = 0;
      $3 = $3 + 1 | 0;
      continue;
     }
    }
    $3 = 0;
    $5 = $1;
    $22 = $13 & 254;
    if (($22 | 0) != 134) {
     break label$12;
    }
   }
   $3 = 1;
   $22 = 134;
   label$16: {
    if (HEAPU8[$17 + 82 | 0] & 32) {
     break label$16;
    }
    $5 = $1;
    while (1) {
     $8 = HEAP32[$5 + 52 >> 2];
     if (!(!$8 | HEAPU8[$5 | 0] != ($13 | 0))) {
      $3 = $3 + 1 | 0;
      $5 = $8;
      continue;
     }
     break;
    }
    if ($3 >>> 0 < 4) {
     $3 = 1;
     break label$16;
    }
    $8 = 2;
    $5 = $1;
    while (1) if ($3 >>> 0 <= $8 >>> 0) {
     $3 = 1;
     break label$12;
    } else {
     $8 = $8 + 2 | 0;
     $5 = HEAP32[$5 + 52 >> 2];
     continue;
    }
   }
   $5 = $1;
  }
  $8 = HEAP32[$5 + 52 >> 2];
  HEAP32[$5 + 52 >> 2] = 0;
  HEAP32[$8 + 56 >> 2] = 0;
  HEAP32[$8 + 48 >> 2] = sqlite3ExprListDup(HEAP32[$0 >> 2], $7, 0);
  sqlite3ResolveOrderGroupBy($0, $1, HEAP32[$1 + 48 >> 2], 19018);
  sqlite3ResolveOrderGroupBy($0, $8, HEAP32[$8 + 48 >> 2], 19018);
  computeLimitRegisters($0, $1, $15);
  $7 = HEAP32[$1 + 8 >> 2];
  if (!(!$7 | ($13 | 0) != 135)) {
   $14 = HEAP32[$0 + 44 >> 2];
   $19 = $14 + 2 | 0;
   HEAP32[$0 + 44 >> 2] = $19;
   $11 = HEAP32[$1 + 12 >> 2];
   $9 = $14 + 1 | 0;
   sqlite3VdbeAddOp2($4, 80, $11 ? $11 + 1 | 0 : $7, $9);
   sqlite3VdbeAddOp2($4, 80, $9, $19);
  }
  sqlite3ExprDelete($17, HEAP32[$1 + 60 >> 2]);
  HEAP32[$1 + 60 >> 2] = 0;
  $11 = HEAP32[$0 + 44 >> 2];
  $21 = $11 + 4 | 0;
  HEAP32[$0 + 44 >> 2] = $21;
  $7 = $11 + 1 | 0;
  sqlite3SelectDestInit($10 + 48 | 0, 13, $7);
  $14 = $11 + 2 | 0;
  sqlite3SelectDestInit($10 + 16 | 0, 13, $14);
  HEAP32[$10 >> 2] = sqlite3SelectOpName(HEAPU8[$1 | 0]);
  sqlite3VdbeExplain($0, 1, 24562, $10);
  $23 = sqlite3VdbeAddOp3($4, 10, $7, 0, sqlite3VdbeCurrentAddr($4) + 1 | 0);
  HEAP32[$8 + 8 >> 2] = $9;
  sqlite3VdbeExplain($0, 1, 18345, 0);
  sqlite3Select($0, $8, $10 + 48 | 0);
  sqlite3VdbeEndCoroutine($4, $7);
  sqlite3VdbeJumpHere($4, $23);
  $23 = sqlite3VdbeAddOp3($4, 10, $14, 0, sqlite3VdbeCurrentAddr($4) + 1 | 0);
  $9 = HEAP32[$1 + 12 >> 2];
  $26 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = $19;
  sqlite3VdbeExplain($0, 1, 18326, 0);
  sqlite3Select($0, $1, $10 + 16 | 0);
  HEAP32[$1 + 8 >> 2] = $26;
  HEAP32[$1 + 12 >> 2] = $9;
  sqlite3VdbeEndCoroutine($4, $14);
  $9 = $11 + 3 | 0;
  $19 = generateOutputSubroutine($0, $1, $10 + 48 | 0, $2, $9, $18, $6, $15);
  if ($3) {
   $24 = generateOutputSubroutine($0, $1, $10 + 16 | 0, $2, $21, $18, $6, $15);
  }
  sqlite3KeyInfoUnref($6);
  $18 = $15;
  $6 = $15;
  if (($22 | 0) != 136) {
   $6 = sqlite3VdbeAddOp2($4, 9, $21, $24);
   $18 = sqlite3VdbeAddOp2($4, 11, $14, $15);
   sqlite3VdbeGoto($4, $6);
   HEAP16[$1 + 2 >> 1] = sqlite3LogEstAdd(HEAP16[$1 + 2 >> 1], HEAP16[$8 + 2 >> 1]);
  }
  label$26: {
   if (($13 | 0) == 137) {
    $11 = $6;
    $2 = HEAP16[$8 + 2 >> 1];
    if (($2 | 0) >= HEAP16[$1 + 2 >> 1]) {
     break label$26;
    }
    HEAP16[$1 + 2 >> 1] = $2;
    break label$26;
   }
   $11 = sqlite3VdbeAddOp2($4, 9, $9, $19);
   sqlite3VdbeAddOp2($4, 11, $7, $15);
   sqlite3VdbeGoto($4, $11);
  }
  $1 = sqlite3VdbeAddOp2($4, 9, $9, $19);
  sqlite3VdbeAddOp2($4, 11, $7, $6);
  sqlite3VdbeGoto($4, $20);
  label$28: {
   label$29: {
    if (($13 | 0) == 135) {
     $9 = $1;
     break label$29;
    }
    if (($13 | 0) == 137) {
     $9 = $1;
     $1 = $1 + 1 | 0;
     break label$28;
    }
    $9 = sqlite3VdbeAddOp2($4, 11, $7, $6);
    sqlite3VdbeGoto($4, $20);
   }
  }
  $13 = $1;
  $6 = sqlite3VdbeCurrentAddr($4);
  if ($3) {
   sqlite3VdbeAddOp2($4, 9, $21, $24);
  }
  sqlite3VdbeAddOp2($4, 11, $14, $11);
  sqlite3VdbeGoto($4, $20);
  sqlite3VdbeJumpHere($4, $23);
  sqlite3VdbeAddOp2($4, 11, $7, $18);
  sqlite3VdbeAddOp2($4, 11, $14, $11);
  sqlite3VdbeResolveLabel($4, $20);
  sqlite3VdbeAddOp4($4, 89, 0, 0, 0, $16, -14);
  sqlite3VdbeAddOp4($4, 90, HEAP32[$10 + 60 >> 2], HEAP32[$10 + 28 >> 2], $12, $25, -8);
  sqlite3VdbeChangeP5($4, 1);
  sqlite3VdbeAddOp3($4, 13, $13, $9, $6);
  sqlite3VdbeResolveLabel($4, $15);
  $3 = HEAP32[$5 + 52 >> 2];
  if ($3) {
   sqlite3ParserAddCleanup($0, 49, $3);
  }
  HEAP32[$5 + 52 >> 2] = $8;
  HEAP32[$8 + 56 >> 2] = $5;
  sqlite3ExprListDelete($17, HEAP32[$8 + 48 >> 2]);
  HEAP32[$8 + 48 >> 2] = 0;
  sqlite3VdbeExplainPop($0);
  $5 = HEAP32[$0 + 36 >> 2] != 0;
 }
 __stack_pointer = $10 + 80 | 0;
 $3 = $5;
 return $3;
}

function sqlite3WalFrames($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $15 = __stack_pointer - 48 | 0;
 __stack_pointer = $15;
 $9 = walIndexHdr($0);
 if (memcmp($0 + 52 | 0, $9, 48)) {
  $20 = HEAP32[$9 + 16 >> 2] + 1 | 0;
 } else {
  $20 = 0;
 }
 $7 = walRestartLog($0);
 label$3: {
  if ($7) {
   break label$3;
  }
  $14 = HEAP32[$0 + 68 >> 2];
  label$4: {
   if ($14) {
    break label$4;
   }
   sqlite3Put4byte($15 + 16 | 0, 931071618);
   sqlite3Put4byte($15 + 16 | 4, 3007e3);
   sqlite3Put4byte($15 + 16 | 8, $1);
   $9 = HEAP32[$0 + 112 >> 2];
   sqlite3Put4byte($15 + 16 | 12, $9);
   if (!$9) {
    sqlite3_randomness(8, $0 + 84 | 0);
   }
   $8 = HEAP32[$0 + 88 >> 2];
   $6 = HEAP32[$0 + 84 >> 2];
   $11 = $6;
   $6 = $15;
   HEAP32[$6 + 32 >> 2] = $11;
   HEAP32[$6 + 36 >> 2] = $8;
   walChecksumBytes(1, $6 + 16 | 0, 24, 0, $6 + 8 | 0);
   $9 = HEAP32[$6 + 8 >> 2];
   sqlite3Put4byte($6 + 40 | 0, $9);
   $7 = HEAP32[$6 + 12 >> 2];
   sqlite3Put4byte($6 + 44 | 0, $7);
   HEAP32[$0 + 80 >> 2] = $7;
   HEAP32[$0 + 76 >> 2] = $9;
   HEAP8[$0 + 65 | 0] = 0;
   HEAP32[$0 + 36 >> 2] = $1;
   HEAP8[$0 + 47 | 0] = 1;
   $7 = sqlite3OsWrite(HEAP32[$0 + 8 >> 2], $6 + 16 | 0, 32, 0, 0);
   if ($7) {
    break label$3;
   }
   if (!HEAPU8[$0 + 48 | 0]) {
    break label$4;
   }
   $7 = sqlite3OsSync(HEAP32[$0 + 8 >> 2], $5 >>> 2 & 3);
   if ($7) {
    break label$3;
   }
  }
  HEAP32[$15 + 16 >> 2] = $0;
  $22 = HEAP32[$0 + 8 >> 2];
  HEAP32[$15 + 32 >> 2] = $5;
  $6 = $15;
  HEAP32[$6 + 24 >> 2] = 0;
  HEAP32[$6 + 28 >> 2] = 0;
  HEAP32[$6 + 20 >> 2] = $22;
  HEAP32[$6 + 36 >> 2] = $1;
  $6 = $1 + 24 | 0;
  $8 = $6 >> 31;
  $21 = $6;
  $19 = $8;
  $6 = __wasm_i64_mul($6, $8, $14, 0);
  $11 = $6;
  $8 = i64toi32_i32$HIGH_BITS;
  $10 = $11 + 32 | 0;
  $12 = $10 >>> 0 < 32 ? $8 + 1 | 0 : $8;
  $17 = $10;
  $18 = $12;
  $9 = $2;
  while (1) {
   if ($9) {
    $6 = $15 + 16 | 0;
    label$8: {
     label$9: {
      label$10: {
       label$11: {
        if (!$20) {
         break label$11;
        }
        if (!(HEAP32[$9 + 16 >> 2] | !$4)) {
         $14 = $14 + 1 | 0;
         $7 = 0;
         break label$10;
        }
        HEAP32[$15 + 8 >> 2] = 0;
        sqlite3WalFindFrame($0, HEAP32[$9 + 24 >> 2], $15 + 8 | 0);
        $7 = HEAP32[$15 + 8 >> 2];
        if ($20 >>> 0 > $7 >>> 0) {
         break label$11;
        }
        $11 = $19;
        $11 = __wasm_i64_mul($7 - 1 | 0, 0, $21, $11);
        $8 = $11;
        $12 = i64toi32_i32$HIGH_BITS;
        $10 = $12;
        $6 = $8 + 56 | 0;
        $10 = $6 >>> 0 < 56 ? $10 + 1 | 0 : $10;
        $16 = $6;
        $6 = HEAP32[$0 + 104 >> 2];
        if (!($7 >>> 0 >= $6 >>> 0 ? $6 : 0)) {
         HEAP32[$0 + 104 >> 2] = $7;
        }
        $7 = sqlite3OsWrite(HEAP32[$0 + 8 >> 2], HEAP32[$9 + 4 >> 2], $1, $16, $10);
        if ($7) {
         break label$3;
        }
        HEAP16[$9 + 28 >> 1] = HEAPU16[$9 + 28 >> 1] & 65471;
        break label$8;
       }
       $14 = $14 + 1 | 0;
       $7 = 0;
       if (!$4) {
        break label$9;
       }
       $7 = HEAP32[$9 + 16 >> 2];
      }
      $7 = $7 ? 0 : $3;
     }
     $10 = $18;
     $7 = walWriteOneFrame($6, $9, $7, $17, $10);
     if ($7) {
      break label$3;
     }
     HEAP16[$9 + 28 >> 1] = HEAPU16[$9 + 28 >> 1] | 64;
     $8 = $19;
     $6 = $8 + $18 | 0;
     $13 = $21;
     $12 = $17;
     $11 = $13 + $12 | 0;
     $6 = $13 >>> 0 > $11 >>> 0 ? $6 + 1 | 0 : $6;
     $17 = $11;
     $18 = $6;
     $23 = $9;
    }
    $9 = HEAP32[$9 + 16 >> 2];
    continue;
   }
   break;
  }
  label$14: {
   if (!$4) {
    $7 = 0;
    $9 = 0;
    break label$14;
   }
   if (HEAP32[$0 + 104 >> 2]) {
    $7 = walRewriteChecksums($0, $14);
    if ($7) {
     break label$3;
    }
   }
   $20 = $5 & 3;
   label$17: {
    if (!$20) {
     $9 = 0;
     $7 = 0;
     break label$17;
    }
    label$19: {
     if (!HEAPU8[$0 + 49 | 0]) {
      $9 = 0;
      break label$19;
     }
     $6 = $18;
     $16 = sqlite3SectorSize(HEAP32[$0 + 8 >> 2]);
     $13 = $16;
     $10 = $17;
     $8 = $13 + $10 | 0;
     $11 = $8 >>> 0 < $13 >>> 0 ? $6 + 1 | 0 : $6;
     $6 = $8;
     $12 = $6 - 1 | 0;
     $8 = !$6;
     $8 = $11 - $8 | 0;
     $5 = $8;
     $6 = __wasm_i64_srem($12, $8, $13, 0);
     $8 = i64toi32_i32$HIGH_BITS;
     $16 = $8;
     $11 = $12;
     $13 = $6;
     $10 = $11 - $6 | 0;
     $24 = $10;
     $8 = $5;
     $6 = $16;
     $12 = $6 + ($11 >>> 0 < $13 >>> 0) | 0;
     $12 = $8 - $12 | 0;
     $5 = $12;
     $11 = $15;
     HEAP32[$11 + 24 >> 2] = $10;
     HEAP32[$11 + 28 >> 2] = $12;
     $9 = 0;
     $16 = $17;
     $12 = $18;
     $10 = $12;
     while (1) {
      $8 = $16;
      $13 = $24;
      $11 = $5;
      $12 = $10;
      if ($8 >>> 0 < $13 >>> 0 & ($11 | 0) >= ($12 | 0) | ($11 | 0) > ($12 | 0)) {
       $8 = $10;
       $7 = walWriteOneFrame($15 + 16 | 0, $23, $3, $16, $8);
       if ($7) {
        break label$3;
       }
       $9 = $9 + 1 | 0;
       $12 = $19;
       $10 = $10 + $12 | 0;
       $11 = $21;
       $13 = $16;
       $6 = $11 + $13 | 0;
       $10 = $6 >>> 0 < $11 >>> 0 ? $10 + 1 | 0 : $10;
       $16 = $6;
       continue;
      }
      break;
     }
     $8 = $17;
     $11 = $24;
     $13 = $5;
     $10 = $18;
     $7 = 0;
     if (($8 | 0) != ($11 | 0) | ($13 | 0) != ($10 | 0)) {
      break label$17;
     }
    }
    $7 = sqlite3OsSync($22, $20);
   }
   if (!HEAPU8[$0 + 47 | 0]) {
    break label$14;
   }
   $10 = HEAP32[$0 + 20 >> 2];
   $18 = $10;
   $8 = HEAP32[$0 + 16 >> 2];
   $17 = $8;
   if (($10 | 0) < 0) {
    break label$14;
   }
   $10 = $19;
   $10 = __wasm_i64_mul($9 + $14 | 0, 0, $21, $10);
   $13 = $10;
   $11 = i64toi32_i32$HIGH_BITS;
   $6 = $11;
   $12 = $13 + 32 | 0;
   $6 = $12 >>> 0 < 32 ? $6 + 1 | 0 : $6;
   $19 = $6;
   $6 = $18;
   $13 = $19;
   $8 = $12;
   $11 = $17;
   $10 = ($6 | 0) <= ($13 | 0) & $8 >>> 0 > $11 >>> 0 | ($6 | 0) < ($13 | 0);
   $13 = $10 ? $8 : $11;
   $11 = $19;
   $8 = $10 ? $11 : $6;
   walLimitSize($0, $13, $8);
   HEAP8[$0 + 47 | 0] = 0;
  }
  $14 = HEAP32[$0 + 68 >> 2];
  while (1) {
   if (!(!$2 | $7)) {
    $7 = 0;
    if (HEAPU8[$2 + 28 | 0] & 64) {
     $14 = $14 + 1 | 0;
     $7 = walIndexAppend($0, $14, HEAP32[$2 + 24 >> 2]);
    }
    $2 = HEAP32[$2 + 16 >> 2];
    continue;
   }
   break;
  }
  while (1) {
   if (!(($9 | 0) <= 0 | $7)) {
    $9 = $9 - 1 | 0;
    $14 = $14 + 1 | 0;
    $7 = walIndexAppend($0, $14, HEAP32[$23 + 24 >> 2]);
    continue;
   }
   break;
  }
  if ($7) {
   break label$3;
  }
  HEAP32[$0 + 68 >> 2] = $14;
  HEAP16[$0 + 66 >> 1] = $1 & 65280 | $1 >>> 16;
  $7 = 0;
  if (!$4) {
   break label$3;
  }
  HEAP32[$0 + 72 >> 2] = $3;
  $9 = $0 + 60 | 0;
  HEAP32[$9 >> 2] = HEAP32[$0 + 60 >> 2] + 1;
  walIndexWriteHdr($0);
  HEAP32[$0 + 12 >> 2] = $14;
 }
 __stack_pointer = $15 + 48 | 0;
 return $7;
}

function patternCompare($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 12 >> 2] = $0;
 $10 = HEAPU8[$2 + 3 | 0];
 $11 = HEAPU8[$2 | 0];
 $9 = HEAPU8[$2 + 1 | 0];
 label$1: {
  label$2: {
   label$3: {
    label$4: while (1) {
     label$5: {
      label$6: {
       label$7: {
        $1 = HEAP32[$4 + 12 >> 2];
        $0 = HEAP8[$1 | 0];
        label$8: {
         if (($0 | 0) >= 0) {
          HEAP32[$4 + 12 >> 2] = $1 + 1;
          $0 = $0 & 255;
          break label$8;
         }
         $0 = sqlite3Utf8Read($4 + 12 | 0);
        }
        if ($0) {
         if (($0 | 0) == ($11 | 0)) {
          while (1) {
           $1 = HEAP32[$4 + 12 >> 2];
           $0 = HEAP8[$1 | 0];
           label$13: {
            if (($0 | 0) >= 0) {
             HEAP32[$4 + 12 >> 2] = $1 + 1;
             $0 = $0 & 255;
             break label$13;
            }
            $0 = sqlite3Utf8Read($4 + 12 | 0);
           }
           if (!(($0 | 0) == ($9 | 0) & ($9 | 0) != 0 ? 0 : ($11 | 0) != ($0 | 0))) {
            if (($0 | 0) != ($9 | 0)) {
             continue;
            }
            if (sqlite3Utf8Read($4 + 8 | 0)) {
             continue;
            }
            break label$2;
           }
           break;
          }
          if (!$0) {
           $6 = 0;
           break label$1;
          }
          if (($0 | 0) == ($3 | 0)) {
           if (HEAPU8[$2 + 2 | 0]) {
            $7 = HEAP32[$4 + 12 >> 2] - 1 | 0;
            $5 = HEAP32[$4 + 8 >> 2];
            while (1) {
             if (!HEAPU8[$5 | 0]) {
              $6 = 2;
              break label$3;
             }
             $6 = patternCompare($7, $5, $2, $3);
             if (($6 | 0) != 1) {
              break label$3;
             }
             $1 = HEAPU8[$5 | 0];
             $0 = $5 + 1 | 0;
             $5 = $0;
             if ($1 >>> 0 < 192) {
              continue;
             }
             while (1) {
              $1 = HEAPU8[$0 | 0];
              $5 = $0;
              $0 = $0 + 1 | 0;
              if (($1 & 192) == 128) {
               continue;
              }
              break;
             }
             continue;
            }
           }
           $0 = sqlite3Utf8Read($4 + 12 | 0);
           if (!$0) {
            break label$2;
           }
          }
          if ($0 >>> 0 < 129) {
           break label$5;
          }
          $7 = HEAP32[$4 + 12 >> 2];
          while (1) {
           $5 = HEAP32[$4 + 8 >> 2];
           $1 = HEAP8[$5 | 0];
           label$23: {
            if (($1 | 0) >= 0) {
             HEAP32[$4 + 8 >> 2] = $5 + 1;
             $1 = $1 & 255;
             break label$23;
            }
            $1 = sqlite3Utf8Read($4 + 8 | 0);
           }
           if (!$1) {
            break label$2;
           }
           if (($0 | 0) != ($1 | 0)) {
            continue;
           }
           $6 = patternCompare($7, HEAP32[$4 + 8 >> 2], $2, $3);
           if (($6 | 0) == 1) {
            continue;
           }
           break;
          }
          break label$1;
         }
         if (($0 | 0) == ($3 | 0)) {
          label$26: {
           if (!HEAPU8[$2 + 2 | 0]) {
            $0 = sqlite3Utf8Read($4 + 12 | 0);
            if ($0) {
             break label$26;
            }
            $6 = 1;
            break label$1;
           }
           $6 = 1;
           $8 = sqlite3Utf8Read($4 + 8 | 0);
           if (!$8) {
            break label$1;
           }
           $0 = 0;
           $12 = 0;
           $7 = 0;
           $5 = sqlite3Utf8Read($4 + 12 | 0);
           if (($5 | 0) == 94) {
            $12 = 1;
            $5 = sqlite3Utf8Read($4 + 12 | 0);
           }
           if (($5 | 0) != 93) {
            break label$7;
           }
           $7 = ($8 | 0) == 93;
           $1 = 0;
           break label$6;
          }
          $14 = HEAP32[$4 + 12 >> 2];
         }
         $5 = HEAP32[$4 + 8 >> 2];
         $1 = HEAP8[$5 | 0];
         label$29: {
          if (($1 | 0) >= 0) {
           HEAP32[$4 + 8 >> 2] = $5 + 1;
           $1 = $1 & 255;
           break label$29;
          }
          $1 = sqlite3Utf8Read($4 + 8 | 0);
         }
         if (($1 | 0) == ($0 | 0) | !(!$10 | (HEAPU8[($0 & 255) + 29904 | 0] != HEAPU8[($1 & 255) + 29904 | 0] | $0 >>> 0 > 127)) & $1 >>> 0 < 128) {
          continue;
         }
         $6 = 1;
         if (HEAP32[$4 + 12 >> 2] == ($14 | 0) | ($0 | 0) != ($9 | 0)) {
          break label$1;
         }
         if ($1) {
          continue;
         }
         break label$1;
        }
        $6 = HEAPU8[HEAP32[$4 + 8 >> 2]] != 0;
        break label$1;
       }
       $1 = 1;
      }
      while (1) {
       label$33: {
        label$34: {
         label$35: {
          label$36: {
           if (!$1) {
            $0 = 0;
            break label$36;
           }
           $1 = $0;
           $0 = $5;
           label$38: {
            if (($0 | 0) != 45) {
             if (($0 | 0) == 93) {
              break label$34;
             }
             if (!$0) {
              break label$1;
             }
             break label$38;
            }
            $13 = HEAPU8[HEAP32[$4 + 12 >> 2]];
            if (($13 | 0) == 93 | !$13) {
             break label$38;
            }
            if ($1) {
             break label$35;
            }
           }
           $7 = ($0 | 0) == ($8 | 0) ? 1 : $7;
          }
          $5 = sqlite3Utf8Read($4 + 12 | 0);
          $1 = 1;
          continue;
         }
         $7 = (wasm2js_i32$0 = $7, wasm2js_i32$1 = sqlite3Utf8Read($4 + 12 | 0) >>> 0 < $8 >>> 0 ? $7 : 1, 
         wasm2js_i32$2 = $1 >>> 0 > $8 >>> 0, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
         break label$33;
        }
        if (($7 | 0) != ($12 | 0)) {
         continue label$4;
        }
        break label$1;
       }
       $1 = 0;
       continue;
      }
     }
     break;
    }
    label$40: {
     if ($10) {
      HEAP8[$4 + 7 | 0] = 0;
      HEAP8[$4 + 5 | 0] = (HEAPU8[$0 + 30288 | 0] ^ -1 | 223) & $0;
      $0 = HEAPU8[$0 + 29904 | 0];
      break label$40;
     }
     HEAP8[$4 + 5 | 0] = $0;
     $0 = 0;
    }
    HEAP8[$4 + 6 | 0] = $0;
    $1 = HEAP32[$4 + 12 >> 2];
    $0 = HEAP32[$4 + 8 >> 2];
    while (1) {
     $0 = strcspn($0, $4 + 5 | 0) + $0 | 0;
     if (!HEAPU8[$0 | 0]) {
      HEAP32[$4 + 8 >> 2] = $0;
      break label$2;
     }
     $0 = $0 + 1 | 0;
     $6 = patternCompare($1, $0, $2, $3);
     if (($6 | 0) == 1) {
      continue;
     }
     break;
    }
    HEAP32[$4 + 8 >> 2] = $0;
    break label$1;
   }
   HEAP32[$4 + 8 >> 2] = $5;
   break label$1;
  }
  $6 = 2;
 }
 __stack_pointer = $4 + 16 | 0;
 return $6;
}

function selectInnerLoop($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $18 = __stack_pointer - 16 | 0;
 __stack_pointer = $18;
 $16 = $4 ? HEAPU8[$4 + 1 | 0] : $16;
 $13 = HEAP32[$5 + 4 >> 2];
 $14 = HEAPU8[$5 | 0];
 $8 = HEAP32[$0 + 8 >> 2];
 $12 = $3 ? HEAP32[$3 >> 2] ? $3 : 0 : $12;
 if (!($16 | $12)) {
  codeOffset($8, HEAP32[$1 + 12 >> 2], $6);
 }
 $10 = HEAP32[HEAP32[$1 + 28 >> 2] >> 2];
 $9 = HEAP32[$5 + 12 >> 2];
 label$4: {
  label$5: {
   if (!$9) {
    if ($12) {
     $19 = HEAP32[HEAP32[$12 >> 2] >> 2] + ((HEAPU8[$12 + 32 | 0] ^ -1) & 1) | 0;
     $3 = $19 + HEAP32[$0 + 44 >> 2] | 0;
    } else {
     $3 = HEAP32[$0 + 44 >> 2];
    }
    $9 = $3 + 1 | 0;
    HEAP32[$5 + 12 >> 2] = $9;
    $11 = $0 + 44 | 0;
    break label$5;
   }
   $3 = HEAP32[$0 + 44 >> 2];
   if (($3 | 0) >= ($9 + $10 | 0)) {
    break label$4;
   }
   $11 = $0 + 44 | 0;
  }
  HEAP32[$11 >> 2] = $3 + $10;
 }
 HEAP32[$5 + 16 >> 2] = $10;
 $3 = 0;
 label$9: {
  label$10: {
   if (($2 | 0) >= 0) {
    $11 = ($10 | 0) > 0 ? $10 : 0;
    while (1) {
     if (($3 | 0) == ($11 | 0)) {
      break label$10;
     }
     sqlite3VdbeAddOp3($8, 94, $2, $3, $3 + $9 | 0);
     $3 = $3 + 1 | 0;
     continue;
    }
   }
   $20 = 1;
   label$13: {
    if ($14 - 9 >>> 0 < 2) {
     break label$13;
    }
    if (($14 | 0) == 3) {
     break label$10;
    }
    if (($14 | 0) == 13) {
     break label$13;
    }
    $20 = 0;
   }
   label$14: {
    if (!(!$12 | $16 | (($14 | 0) == 12 | ($14 | 0) == 14))) {
     $3 = HEAP32[$12 + 4 >> 2];
     while (1) {
      $2 = HEAP32[$12 >> 2];
      if (HEAP32[$2 >> 2] > ($3 | 0)) {
       $2 = HEAPU16[(($3 << 4) + $2 | 0) + 20 >> 1];
       if ($2) {
        $3 = $3 + 1 | 0;
        HEAP16[(HEAP32[$1 + 28 >> 2] + ($2 << 4) | 0) + 4 >> 1] = $3 - HEAP32[$12 + 4 >> 2];
       } else {
        $3 = $3 + 1 | 0;
       }
       continue;
      }
      break;
     }
     $17 = HEAP32[$1 + 28 >> 2];
     $3 = HEAP32[$17 >> 2];
     $15 = ($3 | 0) > 0 ? $3 : 0;
     $2 = $9;
     $3 = 0;
     while (1) {
      if (($3 | 0) != ($15 | 0)) {
       $11 = HEAPU16[(($3 << 4) + $17 | 0) + 20 >> 1];
       $2 = $11 ? 0 : $2;
       $3 = $3 + 1 | 0;
       $10 = $10 - (($11 | 0) != 0) | 0;
       continue;
      }
      break;
     }
     $20 = $20 | 12;
     break label$14;
    }
    $2 = $9;
   }
   HEAP8[$18 + 12 | 0] = $20;
   HEAP32[$18 + 8 >> 2] = $9;
   if (!(!HEAP32[$1 + 8 >> 2] | !($20 & 8) | ($19 | 0) <= 0)) {
    HEAP32[$12 + 36 >> 2] = $18 + 8;
    $2 = 0;
    break label$9;
   }
   innerLoopLoadRow($0, $1, $18 + 8 | 0);
   break label$9;
  }
  $2 = $9;
 }
 label$23: {
  if (!$16) {
   break label$23;
  }
  $3 = HEAPU8[$4 + 1 | 0];
  fixDistinctOpenEph($0, $3, codeDistinct($0, $3, HEAP32[$4 + 4 >> 2], $6, HEAP32[$1 + 28 >> 2], $9), HEAP32[$4 + 8 >> 2]);
  if ($12) {
   break label$23;
  }
  codeOffset($8, HEAP32[$1 + 12 >> 2], $6);
 }
 label$24: {
  label$25: {
   label$26: {
    label$27: {
     label$28: {
      switch ($14 - 1 | 0) {
      case 0:
       $3 = sqlite3GetTempReg($0);
       sqlite3VdbeAddOp3($8, 97, $9, $10, $3);
       sqlite3VdbeAddOp4Int($8, 138, $13, $3, $9, $10);
       sqlite3ReleaseTempReg($0, $3);
       break label$27;

      case 1:
       sqlite3VdbeAddOp3($8, 140, $13, $9, $10);
       break label$27;

      case 4:
      case 7:
      case 11:
      case 13:
       $11 = $19 + 1 | 0;
       $3 = sqlite3GetTempRange($0, $11);
       $5 = $19 + $3 | 0;
       sqlite3VdbeAddOp3($8, 97, $9, $10, $5);
       if (($14 | 0) == 5) {
        $15 = $13 + 1 | 0;
        sqlite3VdbeAddOp4Int($8, 28, $15, sqlite3VdbeCurrentAddr($8) + 4 | 0, $3, 0);
        sqlite3VdbeAddOp4Int($8, 138, $15, $3, $9, $10);
       }
       label$38: {
        if ($12) {
         pushOntoSorter($0, $12, $1, $5, $2, 1, $19);
         break label$38;
        }
        $9 = sqlite3GetTempReg($0);
        sqlite3VdbeAddOp2($8, 127, $13, $9);
        sqlite3VdbeAddOp3($8, 128, $13, $3, $9);
        sqlite3VdbeChangeP5($8, 8);
        sqlite3ReleaseTempReg($0, $9);
       }
       sqlite3ReleaseTempRange($0, $3, $11);
       break label$27;

      case 14:
       if ($12) {
        break label$25;
       }
       $3 = HEAP32[$5 + 8 >> 2];
       $2 = sqlite3GetTempReg($0);
       sqlite3VdbeAddOp2($8, 50, $9, $7);
       $11 = $3 >>> 31 | 0;
       sqlite3VdbeAddOp3($8, 97, $11 + $9 | 0, $10 - $11 | 0, $2);
       if (($3 | 0) < 0) {
        sqlite3VdbeAddOp3($8, 128, $13, $2, $9);
        break label$26;
       }
       sqlite3VdbeAddOp4Int($8, 138, $13, $2, $9, $3);
       break label$26;

      case 10:
       if ($12) {
        break label$25;
       }
       $3 = sqlite3GetTempReg($0);
       sqlite3VdbeAddOp4($8, 97, $9, $10, $3, HEAP32[$5 + 20 >> 2], $10);
       sqlite3VdbeAddOp4Int($8, 138, $13, $3, $9, $10);
       sqlite3ReleaseTempReg($0, $3);
       break label$26;

      case 2:
       sqlite3VdbeAddOp2($8, 71, 1, $13);
       break label$27;

      case 9:
       if ($12) {
        break label$25;
       }
       break label$26;

      case 8:
      case 12:
       if ($12) {
        break label$25;
       }
       if (($14 | 0) == 13) {
        sqlite3VdbeAddOp1($8, 11, HEAP32[$5 + 4 >> 2]);
        break label$26;
       }
       sqlite3VdbeAddOp2($8, 84, $9, $10);
       break label$26;

      case 5:
      case 6:
       break label$28;

      default:
       break label$27;
      }
     }
     $5 = HEAP32[$5 + 24 >> 2];
     $11 = HEAP32[$5 >> 2];
     $15 = sqlite3GetTempReg($0);
     $17 = $11 + 2 | 0;
     $2 = sqlite3GetTempRange($0, $17);
     $16 = $11 + $2 | 0;
     $3 = $16 + 1 | 0;
     $4 = 0;
     $14 = ($14 | 0) != 6;
     if (!$14) {
      $4 = sqlite3VdbeAddOp4Int($8, 28, $13 + 1 | 0, 0, $9, $10);
     }
     sqlite3VdbeAddOp3($8, 97, $9, $10, $3);
     if (!$14) {
      sqlite3VdbeAddOp2($8, 138, $13 + 1 | 0, $3);
      sqlite3VdbeChangeP5($8, 16);
     }
     $3 = 0;
     $11 = ($11 | 0) > 0 ? $11 : 0;
     $9 = $9 - 1 | 0;
     while (1) {
      if (($3 | 0) != ($11 | 0)) {
       sqlite3VdbeAddOp2($8, 81, HEAPU16[(($3 << 4) + $5 | 0) + 20 >> 1] + $9 | 0, $2 + $3 | 0);
       $3 = $3 + 1 | 0;
       continue;
      }
      break;
     }
     sqlite3VdbeAddOp2($8, 126, $13, $16);
     sqlite3VdbeAddOp3($8, 97, $2, $17, $15);
     sqlite3VdbeAddOp4Int($8, 138, $13, $15, $2, $17);
     if ($4) {
      sqlite3VdbeJumpHere($8, $4);
     }
     sqlite3ReleaseTempReg($0, $15);
     sqlite3ReleaseTempRange($0, $2, $17);
    }
    if ($12) {
     break label$24;
    }
   }
   $3 = HEAP32[$1 + 8 >> 2];
   if (!$3) {
    break label$24;
   }
   sqlite3VdbeAddOp2($8, 60, $3, $7);
   break label$24;
  }
  pushOntoSorter($0, $12, $1, $9, $2, $10, $19);
 }
 __stack_pointer = $18 + 16 | 0;
}

function whereLoopAddBtree($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 $9 = __stack_pointer - 80 | 0;
 __stack_pointer = $9;
 HEAP16[$9 + 2 >> 1] = 65535;
 $15 = HEAP32[$0 >> 2];
 $6 = HEAP32[$15 + 4 >> 2] + 8 | 0;
 $3 = HEAP32[$0 + 8 >> 2];
 $17 = HEAPU8[$3 + 16 | 0];
 $11 = $6 + ($17 << 6) | 0;
 $12 = HEAP32[$11 + 16 >> 2];
 $19 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if (HEAPU8[$11 + 37 | 0] & 2) {
   $7 = HEAP32[$11 + 60 >> 2];
   break label$1;
  }
  if (HEAPU8[$12 + 28 | 0] & 128) {
   $7 = HEAP32[$12 + 8 >> 2];
   break label$1;
  }
  memset($9 + 8 | 0, 0, 72);
  HEAP8[$9 + 62 | 0] = 5;
  HEAP16[$9 + 58 >> 1] = 1;
  HEAP16[$9 + 60 >> 1] = 1;
  HEAP32[$9 + 16 >> 2] = $9 + 4;
  HEAP32[$9 + 12 >> 2] = $9 + 2;
  HEAP32[$9 + 20 >> 2] = $12;
  $7 = HEAPU16[$12 + 40 >> 1];
  HEAP8[$9 + 63 | 0] = 3;
  HEAP8[$9 + 64 | 0] = 0;
  HEAP16[$9 + 56 >> 1] = $7;
  $7 = HEAPU16[$12 + 38 >> 1];
  HEAP16[$9 + 6 >> 1] = 0;
  HEAP16[$9 + 4 >> 1] = $7;
  $7 = $9 + 8 | 0;
  if (HEAP8[$11 + 37 | 0] & 1) {
   break label$1;
  }
  HEAP32[$9 + 28 >> 2] = HEAP32[HEAP32[$11 + 16 >> 2] + 8 >> 2];
 }
 label$4: {
  if (!(HEAPU8[HEAP32[HEAP32[$15 >> 2] >> 2] + 33 | 0] & 128) | (HEAP32[$0 + 12 >> 2] | HEAPU16[$15 + 44 >> 1] & 4128)) {
   break label$4;
  }
  $8 = HEAPU8[$11 + 37 | 0] | HEAPU8[$11 + 38 | 0] << 8;
  if ($8 & 3 | HEAPU8[$12 + 28 | 0] & 128 | ($8 & 8 | $8 & 64)) {
   break label$4;
  }
  if (HEAPU8[$11 + 36 | 0] & 16) {
   break label$4;
  }
  $8 = HEAP32[$19 + 24 >> 2];
  $18 = $8 + Math_imul(HEAP32[$19 + 12 >> 2], 48) | 0;
  $4 = HEAPU16[$12 + 38 >> 1];
  $14 = estLog($4 << 16 >> 16);
  $4 = $4 + $14 | 0;
  $20 = $4 - 10 | 0;
  $22 = $4 + 28 | 0;
  $4 = 0;
  while (1) {
   if ($8 >>> 0 >= $18 >>> 0 | $4) {
    break label$4;
   }
   $4 = 0;
   $5 = HEAP32[$3 + 8 >> 2];
   $23 = $5;
   $10 = HEAP32[$3 + 12 >> 2];
   $16 = $10;
   $5 = HEAP32[$8 + 36 >> 2];
   $21 = $5;
   $10 = HEAP32[$8 + 32 >> 2];
   $13 = $10;
   $5 = $16;
   $10 = $21;
   $10 = $5 & $10;
   $5 = $13 & $23;
   label$6: {
    if ($5 | $10) {
     break label$6;
    }
    if (!termCanDriveIndex($8, $11, 0, 0)) {
     break label$6;
    }
    HEAP16[$3 + 24 >> 1] = 1;
    HEAP32[$3 + 44 >> 2] = 1;
    HEAP32[$3 + 32 >> 2] = 0;
    HEAP32[HEAP32[$3 + 52 >> 2] >> 2] = $8;
    label$7: {
     if (HEAPU8[$12 + 43 | 0] != 2) {
      $4 = $22;
      if (!(HEAPU8[$12 + 29 | 0] & 64)) {
       break label$7;
      }
     }
     $4 = $20;
    }
    HEAP16[$3 + 22 >> 1] = 43;
    $4 = $4 << 16 >> 16;
    HEAP16[$3 + 18 >> 1] = ($4 | 0) > 0 ? $4 : 0;
    HEAP32[$3 + 40 >> 2] = 16384;
    HEAP16[$3 + 20 >> 1] = sqlite3LogEstAdd($14, 43);
    $10 = HEAP32[$8 + 36 >> 2];
    $5 = HEAP32[$8 + 32 >> 2];
    HEAP32[$3 >> 2] = $5 | $1;
    $5 = $2;
    $5 = $5 | $10;
    HEAP32[$3 + 4 >> 2] = $5;
    $4 = whereLoopInsert($0, $3);
   }
   $8 = $8 + 48 | 0;
   continue;
  }
 }
 $6 = ($17 << 6) + $6 | 0;
 $16 = $6;
 $16 = $6;
 $18 = 1;
 while (1) {
  label$10: {
   label$11: {
    if (!(!$7 | $4)) {
     label$13: {
      $4 = HEAP32[$7 + 36 >> 2];
      if (!$4) {
       break label$13;
      }
      if (whereUsablePartialIndex(HEAP32[$16 + 40 >> 2], HEAPU8[$11 + 36 | 0], $19, $4)) {
       break label$13;
      }
      $4 = 0;
      break label$10;
     }
     $4 = 0;
     if (HEAP8[$7 + 56 | 0] & 1) {
      break label$10;
     }
     $14 = HEAPU16[HEAP32[$7 + 8 >> 2] >> 1];
     HEAP16[$3 + 28 >> 1] = 0;
     HEAP32[$3 + 24 >> 2] = 0;
     HEAP32[$3 + 44 >> 2] = 0;
     HEAP16[$3 + 18 >> 1] = 0;
     HEAP8[$3 + 17 | 0] = 0;
     HEAP32[$3 + 32 >> 2] = $7;
     HEAP16[$3 + 22 >> 1] = $14;
     HEAP32[$3 >> 2] = $1;
     $5 = $2;
     HEAP32[$3 + 4 >> 2] = $5;
     $4 = indexMightHelpWithOrderBy($0, $7, HEAP32[$16 + 40 >> 2]);
     label$14: {
      $6 = HEAPU8[$7 + 55 | 0] | HEAPU8[$7 + 56 | 0] << 8;
      if (($6 & 3) == 3) {
       HEAP32[$3 + 40 >> 2] = 256;
       HEAP16[$3 + 20 >> 1] = $14 + 16;
       HEAP8[$3 + 17 | 0] = $4 ? $18 : 0;
       whereLoopOutputAdjust($19, $3, $14 << 16 >> 16);
       break label$14;
      }
      label$16: {
       if ($6 & 32) {
        $10 = 0;
        $13 = 0;
        $6 = 576;
        break label$16;
       }
       $5 = HEAP32[$7 + 64 >> 2];
       $6 = $5;
       $13 = HEAP32[$7 + 68 >> 2];
       $21 = $13;
       $10 = $16;
       $13 = HEAP32[$10 + 48 >> 2];
       $8 = $13;
       $5 = HEAP32[$10 + 52 >> 2];
       $13 = $5;
       $5 = $21;
       $13 = $5 & $13;
       $10 = $6;
       $10 = $8 & $10;
       $6 = $13 | $10 ? 512 : 576;
      }
      HEAP32[$3 + 40 >> 2] = $6;
      $6 = $18;
      label$18: {
       if ($4) {
        break label$18;
       }
       $6 = 0;
       if (HEAPU8[$11 + 37 | 0] & 2 | (HEAP32[$7 + 36 >> 2] | HEAPU8[$12 + 28 | 0] & 128)) {
        break label$18;
       }
       $5 = $10;
       if (HEAPU8[$7 + 55 | 0] & 4 | ($5 | $13) | (HEAPU8[$15 + 44 | 0] & 4 | HEAP16[$7 + 48 >> 1] >= HEAP16[$12 + 40 >> 1])) {
        break label$11;
       }
       if (!HEAPU8[64279] | HEAPU8[HEAP32[HEAP32[$15 >> 2] >> 2] + 80 | 0] & 32) {
        break label$11;
       }
      }
      HEAP8[$3 + 17 | 0] = $6;
      HEAP16[$3 + 20 >> 1] = (((Math_imul(HEAP16[$7 + 48 >> 1], 15) | 0) / HEAP16[$12 + 40 >> 1] | 0) + $14 | 0) + 1;
      $5 = $13;
      if ($5 | $10) {
       $8 = $14 + 16 | 0;
       $20 = HEAP32[$16 + 40 >> 2];
       $4 = 0;
       while (1) {
        label$21: {
         if (HEAP32[$15 + 100 >> 2] <= ($4 | 0)) {
          break label$21;
         }
         $6 = HEAP32[$15 + 112 >> 2] + Math_imul($4, 48) | 0;
         if (!sqlite3ExprCoveredByIndex(HEAP32[$6 >> 2], $20, $7)) {
          break label$21;
         }
         $4 = $4 + 1 | 0;
         $17 = HEAP16[$6 + 8 >> 1];
         if (($17 | 0) > 0) {
          $17 = HEAPU8[$6 + 12 | 0] & 130 ? -20 : -1;
         }
         $8 = $8 + $17 | 0;
         continue;
        }
        break;
       }
       HEAP16[$3 + 20 >> 1] = sqlite3LogEstAdd(HEAP16[$3 + 20 >> 1], $8 << 16 >> 16);
      }
      whereLoopOutputAdjust($19, $3, $14 << 16 >> 16);
      if (!(HEAPU8[$11 + 36 | 0] & 16) | !HEAP32[$7 + 40 >> 2]) {
       break label$14;
      }
      HEAP16[$3 + 22 >> 1] = $14;
      break label$11;
     }
     $4 = whereLoopInsert($0, $3);
     HEAP16[$3 + 22 >> 1] = $14;
     if (!$4) {
      break label$11;
     }
    }
    __stack_pointer = $9 + 80 | 0;
    return $4;
   }
   HEAP8[$0 + 16 | 0] = 0;
   $4 = whereLoopAddBtreeIndex($0, $11, $7, 0);
   if (HEAPU8[$0 + 16 | 0] != 1) {
    break label$10;
   }
   HEAP32[$12 + 28 >> 2] = HEAP32[$12 + 28 >> 2] | 256;
  }
  $6 = 0;
  $18 = $18 + 1 | 0;
  $6 = HEAPU8[$11 + 37 | 0] & 2 ? $6 : HEAP32[$7 + 20 >> 2];
  $7 = $6;
  continue;
 }
}

function fts3PoslistPhraseMerge($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 44 >> 2] = HEAP32[$0 >> 2];
 $13 = HEAP32[$4 >> 2];
 HEAP32[$6 + 40 >> 2] = $13;
 $7 = HEAP32[$5 >> 2];
 HEAP32[$6 + 36 >> 2] = $7;
 HEAP32[$6 + 32 >> 2] = 0;
 HEAP32[$6 + 28 >> 2] = 0;
 if (HEAPU8[$13 | 0] == 1) {
  $9 = $13 + 1 | 0;
  $13 = HEAP8[$13 + 1 | 0];
  label$2: {
   if (($13 | 0) < 0) {
    $13 = sqlite3Fts3GetVarint32($9, $6 + 32 | 0);
    break label$2;
   }
   HEAP32[$6 + 32 >> 2] = $13 & 255;
   $13 = 1;
  }
  HEAP32[$6 + 40 >> 2] = $9 + $13;
 }
 if (HEAPU8[$7 | 0] == 1) {
  $13 = 1;
  $9 = $7 + 1 | 0;
  $7 = HEAP8[$7 + 1 | 0];
  label$5: {
   if (($7 | 0) < 0) {
    $13 = sqlite3Fts3GetVarint32($9, $6 + 28 | 0);
    break label$5;
   }
   HEAP32[$6 + 28 >> 2] = $7 & 255;
  }
  HEAP32[$6 + 36 >> 2] = $13 + $9;
 }
 $20 = $1;
 $8 = $1 >> 31;
 $21 = $8;
 $13 = ($2 | 0) != 0;
 while (1) {
  label$8: {
   $1 = HEAP32[$6 + 32 >> 2];
   $7 = HEAP32[$6 + 28 >> 2];
   if (($1 | 0) == ($7 | 0)) {
    $7 = HEAP32[$6 + 44 >> 2];
    HEAP32[$6 + 16 >> 2] = 0;
    HEAP32[$6 + 20 >> 2] = 0;
    HEAP32[$6 + 8 >> 2] = 0;
    HEAP32[$6 + 12 >> 2] = 0;
    HEAP32[$6 >> 2] = 0;
    HEAP32[$6 + 4 >> 2] = 0;
    if ($1) {
     HEAP8[$7 | 0] = 1;
     $9 = $7 + 1 | 0;
     $8 = $1 >> 31;
     HEAP32[$6 + 44 >> 2] = $9 + sqlite3Fts3PutVarint($9, $1, $8);
    }
    fts3GetDeltaVarint($6 + 40 | 0, $6 + 8 | 0);
    $1 = HEAP32[$6 + 12 >> 2];
    $15 = $1;
    $8 = HEAP32[$6 + 8 >> 2];
    $16 = $8;
    $10 = $8 - 2 | 0;
    $17 = $10;
    $11 = $8 >>> 0 < 2;
    $11 = $1 - $11 | 0;
    $18 = $11;
    HEAP32[$6 + 8 >> 2] = $10;
    HEAP32[$6 + 12 >> 2] = $11;
    fts3GetDeltaVarint($6 + 36 | 0, $6);
    $9 = HEAP32[$6 + 4 >> 2];
    $22 = $9;
    $11 = HEAP32[$6 >> 2];
    $1 = $11;
    $10 = $11 >>> 0 < 2;
    $10 = $9 - $10 | 0;
    $14 = $10;
    $8 = $1 - 2 | 0;
    $19 = $8;
    HEAP32[$6 >> 2] = $8;
    HEAP32[$6 + 4 >> 2] = $10;
    $9 = $16;
    $10 = $15;
    $8 = $9 >>> 0 < 2 & ($10 | 0) <= 0 | ($10 | 0) < 0;
    $12 = $1;
    $9 = $22;
    if ($8 | ($12 >>> 0 < 2 & ($9 | 0) <= 0 | ($9 | 0) < 0)) {
     break label$8;
    }
    while (1) {
     $9 = $21;
     $12 = $18;
     $8 = $9 + $12 | 0;
     $1 = $17;
     $10 = $20;
     $11 = $1 + $10 | 0;
     $16 = $11;
     $8 = $10 >>> 0 > $11 >>> 0 ? $8 + 1 | 0 : $8;
     $15 = $8;
     label$12: {
      while (1) {
       $12 = $19;
       $10 = $16;
       $8 = $14;
       $1 = $15;
       $9 = ($12 | 0) != ($10 | 0) | ($8 | 0) != ($1 | 0);
       $8 = $18;
       $1 = $17;
       $10 = $12;
       $11 = ($14 | 0) <= ($8 | 0) & $1 >>> 0 >= $10 >>> 0 | ($8 | 0) > ($14 | 0) | $3;
       $8 = $16;
       $1 = $10;
       $12 = $15;
       $10 = $14;
       if (!($11 | ($8 >>> 0 < $1 >>> 0 & ($12 | 0) <= ($10 | 0) | ($10 | 0) > ($12 | 0)) ? $9 : 0)) {
        $9 = $2;
        $12 = $9 ? $17 : $19;
        $1 = $18;
        $8 = $9 ? $1 : $14;
        $9 = $12;
        $10 = $9 + 2 | 0;
        $11 = $10 >>> 0 < 2 ? $8 + 1 | 0 : $8;
        fts3PutDeltaVarint($6 + 44 | 0, $6 + 16 | 0, $10, $11);
        $11 = HEAP32[$6 + 16 >> 2];
        $8 = $11;
        $9 = HEAP32[$6 + 20 >> 2];
        $10 = $8 >>> 0 < 2;
        $10 = $9 - $10 | 0;
        $12 = $8 - 2 | 0;
        HEAP32[$6 + 16 >> 2] = $12;
        HEAP32[$6 + 20 >> 2] = $10;
        $7 = 0;
       }
       $1 = $16;
       $9 = $19;
       $8 = $15;
       $10 = $14;
       $12 = ($1 >>> 0 < $9 >>> 0 & ($8 | 0) <= ($10 | 0) | ($8 | 0) < ($10 | 0) | $13) == 1;
       $8 = $17;
       $1 = $9;
       $9 = $10;
       $10 = $18;
       if (!($12 & ($8 >>> 0 < $1 >>> 0 & ($9 | 0) >= ($10 | 0) | ($9 | 0) > ($10 | 0)))) {
        if (HEAPU8[HEAP32[$6 + 36 >> 2]] < 2) {
         break label$12;
        }
        fts3GetDeltaVarint($6 + 36 | 0, $6);
        $1 = HEAP32[$6 >> 2];
        $8 = $1;
        $11 = $8 - 2 | 0;
        $19 = $11;
        $9 = HEAP32[$6 + 4 >> 2];
        $12 = $8 >>> 0 < 2;
        $12 = $9 - $12 | 0;
        $14 = $12;
        HEAP32[$6 >> 2] = $11;
        HEAP32[$6 + 4 >> 2] = $12;
        continue;
       }
       break;
      }
      if (HEAPU8[HEAP32[$6 + 40 >> 2]] < 2) {
       break label$12;
      }
      fts3GetDeltaVarint($6 + 40 | 0, $6 + 8 | 0);
      $12 = HEAP32[$6 + 8 >> 2];
      $9 = $12;
      $1 = $9 - 2 | 0;
      $17 = $1;
      $8 = HEAP32[$6 + 12 >> 2];
      $11 = $9 >>> 0 < 2;
      $11 = $8 - $11 | 0;
      $18 = $11;
      HEAP32[$6 + 8 >> 2] = $1;
      HEAP32[$6 + 12 >> 2] = $11;
      continue;
     }
     break;
    }
    if ($7) {
     HEAP32[$6 + 44 >> 2] = $7;
    }
    fts3ColumnlistCopy(0, $6 + 40 | 0);
    fts3ColumnlistCopy(0, $6 + 36 | 0);
    $7 = HEAP32[$6 + 40 >> 2];
    if (!HEAPU8[$7 | 0]) {
     break label$8;
    }
    $1 = HEAP32[$6 + 36 >> 2];
    if (!HEAPU8[$1 | 0]) {
     break label$8;
    }
    $9 = $7 + 1 | 0;
    $7 = HEAP8[$7 + 1 | 0];
    label$17: {
     if (($7 | 0) < 0) {
      $7 = sqlite3Fts3GetVarint32($9, $6 + 32 | 0);
      break label$17;
     }
     HEAP32[$6 + 32 >> 2] = $7 & 255;
     $7 = 1;
    }
    HEAP32[$6 + 40 >> 2] = $9 + $7;
    $7 = $1 + 1 | 0;
    $1 = HEAP8[$1 + 1 | 0];
    label$19: {
     if (($1 | 0) < 0) {
      $1 = sqlite3Fts3GetVarint32($7, $6 + 28 | 0);
      break label$19;
     }
     HEAP32[$6 + 28 >> 2] = $1 & 255;
     $1 = 1;
    }
    HEAP32[$6 + 36 >> 2] = $7 + $1;
    continue;
   }
   if (($1 | 0) < ($7 | 0)) {
    fts3ColumnlistCopy(0, $6 + 40 | 0);
    $7 = HEAP32[$6 + 40 >> 2];
    if (!HEAPU8[$7 | 0]) {
     break label$8;
    }
    $1 = $7 + 1 | 0;
    $7 = HEAP8[$7 + 1 | 0];
    label$22: {
     if (($7 | 0) < 0) {
      $7 = sqlite3Fts3GetVarint32($1, $6 + 32 | 0);
      break label$22;
     }
     HEAP32[$6 + 32 >> 2] = $7 & 255;
     $7 = 1;
    }
    HEAP32[$6 + 40 >> 2] = $1 + $7;
    continue;
   }
   fts3ColumnlistCopy(0, $6 + 36 | 0);
   $7 = HEAP32[$6 + 36 >> 2];
   if (!HEAPU8[$7 | 0]) {
    break label$8;
   }
   $1 = $7 + 1 | 0;
   $7 = HEAP8[$7 + 1 | 0];
   label$24: {
    if (($7 | 0) < 0) {
     $7 = sqlite3Fts3GetVarint32($1, $6 + 28 | 0);
     break label$24;
    }
    HEAP32[$6 + 28 >> 2] = $7 & 255;
    $7 = 1;
   }
   HEAP32[$6 + 36 >> 2] = $1 + $7;
   continue;
  }
  break;
 }
 $13 = 0;
 fts3PoslistCopy(0, $6 + 36 | 0);
 fts3PoslistCopy(0, $6 + 40 | 0);
 HEAP32[$4 >> 2] = HEAP32[$6 + 40 >> 2];
 HEAP32[$5 >> 2] = HEAP32[$6 + 36 >> 2];
 __stack_pointer = $6 + 48 | 0;
 $7 = HEAP32[$6 + 44 >> 2];
 if (($7 | 0) != HEAP32[$0 >> 2]) {
  HEAP8[$7 | 0] = 0;
  HEAP32[$0 >> 2] = $7 + 1;
  $13 = 1;
 }
 return $13;
}

function sqlite3BtreeOpen($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $9 = __stack_pointer - 112 | 0;
 __stack_pointer = $9;
 label$1: {
  label$2: {
   label$3: {
    if ($1) {
     $6 = HEAPU8[$1 | 0];
     if (!strcmp($1, 22444)) {
      $8 = !$6;
      break label$2;
     }
     if ($6) {
      break label$3;
     }
    }
    $8 = 1;
    if (sqlite3TempInMemory($2)) {
     break label$2;
    }
   }
   $10 = 0;
   if (!($5 & 128)) {
    break label$1;
   }
  }
  $4 = $4 | 2;
  $10 = 1;
 }
 $7 = 7;
 $6 = sqlite3MallocZero(48, 0);
 label$6: {
  if (!$6) {
   break label$6;
  }
  HEAP32[$6 >> 2] = $2;
  HEAP8[$6 + 8 | 0] = 0;
  HEAP32[$6 + 36 >> 2] = 1;
  HEAP32[$6 + 32 >> 2] = $6;
  label$7: {
   label$8: {
    label$9: {
     label$10: {
      label$11: {
       label$12: {
        $11 = $5 & -769 | 512;
        $11 = ($5 & 256) >>> 8 | 0 ? $10 ? $11 : $8 ? $11 : $5 : $5;
        if (!(!($11 & 64) & $10 | $8 | !($11 & 131072))) {
         $5 = HEAP32[$0 + 8 >> 2] + 1 | 0;
         $12 = sqlite3Strlen30($1) + 1 | 0;
         $13 = ($5 | 0) > ($12 | 0) ? $5 : $12;
         $8 = $13 >> 31;
         $8 = sqlite3Malloc($13, $8);
         HEAP8[$6 + 9 | 0] = 1;
         if (!$8) {
          break label$7;
         }
         label$14: {
          if ($10) {
           __memcpy($8, $1, $12);
           break label$14;
          }
          $7 = sqlite3OsFullPathname($0, $1, $5, $8);
          if (($7 | 512) == 512) {
           break label$14;
          }
          sqlite3_free($8);
          break label$7;
         }
         $5 = 70976;
         label$16: {
          while (1) {
           $5 = HEAP32[$5 >> 2];
           if (!$5) {
            break label$16;
           }
           label$18: {
            label$19: {
             $7 = HEAP32[$5 >> 2];
             if (strcmp($8, sqlite3PagerFilename($7, 0))) {
              break label$19;
             }
             if ((sqlite3PagerVfs($7) | 0) != ($0 | 0)) {
              break label$19;
             }
             $7 = HEAP32[$2 + 20 >> 2];
             while (1) {
              if (($7 | 0) <= 0) {
               break label$18;
              }
              $7 = $7 - 1 | 0;
              $12 = HEAP32[(HEAP32[$2 + 16 >> 2] + ($7 << 4) | 0) + 4 >> 2];
              if (!$12 | HEAP32[$12 + 4 >> 2] != ($5 | 0)) {
               continue;
              }
              break;
             }
             sqlite3_free($8);
             sqlite3_free($6);
             $7 = 19;
             break label$6;
            }
            $5 = $5 + 72 | 0;
            continue;
           }
           break;
          }
          HEAP32[$6 + 4 >> 2] = $5;
          HEAP32[$5 + 68 >> 2] = HEAP32[$5 + 68 >> 2] + 1;
         }
         sqlite3_free($8);
         if ($5) {
          break label$12;
         }
        }
        $5 = sqlite3MallocZero(92, 0);
        if (!$5) {
         $7 = 7;
         break label$9;
        }
        $7 = sqlite3PagerOpen($0, $5, $1, $4, $11);
        if ($7) {
         break label$10;
        }
        $8 = HEAP32[$2 + 48 >> 2];
        $13 = HEAP32[$2 + 52 >> 2];
        sqlite3PagerSetMmapLimit(HEAP32[$5 >> 2], $8, $13);
        $7 = sqlite3PagerReadFileheader(HEAP32[$5 >> 2], $9);
        if ($7) {
         break label$10;
        }
        HEAP32[$5 + 4 >> 2] = $2;
        HEAP8[$5 + 16 | 0] = $4;
        sqlite3PagerSetBusyHandler(HEAP32[$5 >> 2], $5);
        HEAP32[$6 + 4 >> 2] = $5;
        HEAP32[$5 + 8 >> 2] = 0;
        HEAP32[$5 + 12 >> 2] = 0;
        $8 = HEAP32[$5 >> 2];
        if (sqlite3PagerIsreadonly($8)) {
         HEAP16[$5 + 24 >> 1] = HEAPU16[$5 + 24 >> 1] | 1;
        }
        $4 = HEAPU8[$9 + 17 | 0] << 16 | HEAPU8[$9 + 16 | 0] << 8;
        HEAP32[$5 + 36 >> 2] = $4;
        $7 = $5 + 36 | 0;
        label$23: {
         if (!($4 - 1 & $4 ? 0 : $4 - 65537 >>> 0 >= 4294902271)) {
          $4 = 0;
          HEAP32[$7 >> 2] = 0;
          if (!$1 | $10) {
           break label$23;
          }
          HEAP8[$5 + 17 | 0] = 0;
          HEAP8[$5 + 18 | 0] = 0;
          break label$23;
         }
         $4 = HEAPU8[$9 + 20 | 0];
         HEAP16[$5 + 24 >> 1] = HEAPU16[$5 + 24 >> 1] | 2;
         HEAP8[$5 + 17 | 0] = (sqlite3Get4byte($9 + 52 | 0) | 0) != 0;
         HEAP8[$5 + 18 | 0] = (sqlite3Get4byte($9 - -64 | 0) | 0) != 0;
        }
        $7 = sqlite3PagerSetPagesize($8, $7, $4);
        if ($7) {
         break label$10;
        }
        HEAP32[$5 + 68 >> 2] = 1;
        HEAP32[$5 + 40 >> 2] = HEAP32[$5 + 36 >> 2] - $4;
        if (!HEAPU8[$6 + 9 | 0]) {
         break label$8;
        }
        HEAP32[$5 + 72 >> 2] = HEAP32[17744];
        HEAP32[17744] = $5;
        break label$11;
       }
       if (!HEAPU8[$6 + 9 | 0]) {
        break label$8;
       }
      }
      $1 = 0;
      $4 = HEAP32[$2 + 20 >> 2];
      $7 = ($4 | 0) > 0 ? $4 : 0;
      while (1) {
       if (($1 | 0) == ($7 | 0)) {
        break label$8;
       }
       $4 = HEAP32[(HEAP32[$2 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
       if (!$4 | !HEAPU8[$4 + 9 | 0]) {
        $1 = $1 + 1 | 0;
        continue;
       } else {
        while (1) {
         $1 = $4;
         $4 = HEAP32[$1 + 28 >> 2];
         if ($4) {
          continue;
         }
         break;
        }
        $4 = HEAP32[$6 + 4 >> 2];
        label$28: {
         if ($4 >>> 0 < HEAPU32[$1 + 4 >> 2]) {
          HEAP32[$6 + 24 >> 2] = $1;
          $4 = $1 + 28 | 0;
          $2 = 0;
          $1 = $6;
          break label$28;
         }
         while (1) {
          $2 = $1;
          $1 = HEAP32[$1 + 24 >> 2];
          if (!$1) {
           HEAP32[$6 + 24 >> 2] = 0;
           $4 = $2 + 24 | 0;
           $1 = $6;
           break label$28;
          }
          if (HEAPU32[$1 + 4 >> 2] < $4 >>> 0) {
           continue;
          }
          break;
         }
         HEAP32[$6 + 28 >> 2] = $2;
         HEAP32[$6 + 24 >> 2] = $1;
         $4 = $2 + 24 | 0;
         $2 = $6;
        }
        HEAP32[$1 + 28 >> 2] = $2;
        HEAP32[$4 >> 2] = $6;
        break label$8;
       }
      }
     }
     $1 = HEAP32[$5 >> 2];
     if (!$1) {
      break label$9;
     }
     sqlite3PagerClose($1, 0);
    }
    sqlite3_free($5);
    sqlite3_free($6);
    HEAP32[$3 >> 2] = 0;
    break label$6;
   }
   HEAP32[$3 >> 2] = $6;
   $7 = 0;
   if (!sqlite3BtreeSchema($6, 0, 0)) {
    sqlite3BtreeSetCacheSize($6, -2e3);
   }
   $6 = sqlite3PagerFile(HEAP32[$5 >> 2]);
   if (!HEAP32[$6 >> 2]) {
    break label$6;
   }
   sqlite3OsFileControlHint($6, 30, $5 + 4 | 0);
   break label$6;
  }
  sqlite3_free($6);
 }
 __stack_pointer = $9 + 112 | 0;
 return $7;
}

function checkTreePage($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 136 >> 2] = $3;
 HEAP32[$5 + 140 >> 2] = $4;
 HEAP32[$5 + 132 >> 2] = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $26 = HEAP32[$0 + 36 >> 2];
  $27 = HEAP32[$0 + 32 >> 2];
  $28 = HEAP32[$0 + 28 >> 2];
  $9 = HEAP32[$0 >> 2];
  $17 = HEAP32[$9 + 40 >> 2];
  if (checkRef($0, $1)) {
   break label$1;
  }
  HEAP32[$0 + 32 >> 2] = $1;
  HEAP32[$0 + 28 >> 2] = 29494;
  $6 = btreeGetPage($9, $1, $5 + 132 | 0, 0);
  label$2: {
   if ($6) {
    HEAP32[$5 + 96 >> 2] = $6;
    checkAppendMsg($0, 16011, $5 + 96 | 0);
    $11 = -1;
    break label$2;
   }
   $7 = HEAP32[$5 + 132 >> 2];
   $29 = HEAPU8[$7 | 0];
   HEAP8[$7 | 0] = 0;
   $6 = btreeInitPage($7);
   if ($6) {
    HEAP32[$5 + 80 >> 2] = $6;
    checkAppendMsg($0, 16613, $5 + 80 | 0);
    $11 = -1;
    break label$2;
   }
   $6 = btreeComputeFreeSpace($7);
   if ($6) {
    HEAP32[$5 + 64 >> 2] = $6;
    checkAppendMsg($0, 9758, $5 - -64 | 0);
    $11 = -1;
    break label$2;
   }
   $20 = HEAPU8[$7 + 9 | 0];
   $12 = HEAP32[$7 + 56 >> 2];
   HEAP32[$0 + 28 >> 2] = 29548;
   $11 = -1;
   $13 = $12 + $20 | 0;
   $16 = (HEAPU8[$13 + 5 | 0] << 8 | HEAPU8[$13 + 6 | 0]) - 1 & 65535;
   $6 = HEAPU8[$7 + 8 | 0];
   $24 = ($20 - ($6 << 2) | 0) + 12 | 0;
   $14 = (HEAPU8[$13 + 4 | 0] | HEAPU8[$13 + 3 | 0] << 8) - 1 | 0;
   $15 = $24 + ($14 << 1) | 0;
   label$6: {
    if (!$6) {
     $6 = sqlite3Get4byte($13 + 8 | 0);
     if (HEAPU8[$9 + 17 | 0]) {
      HEAP32[$0 + 28 >> 2] = 29520;
      checkPtrmap($0, $6, 5, $1);
     }
     $11 = checkTreePage($0, $6, $5 + 136 | 0, $3, $4);
     $18 = 0;
     break label$6;
    }
    $10 = HEAP32[$0 + 64 >> 2];
    HEAP32[$10 >> 2] = 0;
    $18 = 1;
   }
   $30 = $16 + 1 | 0;
   $15 = $12 + $15 | 0;
   $31 = $17 - 5 | 0;
   $21 = $17 - 4 | 0;
   $22 = 1;
   $6 = $14;
   while (1) {
    if (!(!HEAP32[$0 + 16 >> 2] | ($6 | 0) < 0)) {
     HEAP32[$0 + 36 >> 2] = $6;
     $8 = HEAPU8[$15 + 1 | 0] | HEAPU8[$15 | 0] << 8;
     label$11: {
      if (!($16 >>> 0 < $8 >>> 0 & $8 >>> 0 <= $21 >>> 0)) {
       HEAP32[$5 + 40 >> 2] = $21;
       HEAP32[$5 + 36 >> 2] = $30;
       HEAP32[$5 + 32 >> 2] = $8;
       checkAppendMsg($0, 16049, $5 + 32 | 0);
       $22 = 0;
       break label$11;
      }
      $23 = $8 + $12 | 0;
      FUNCTION_TABLE[HEAP32[$7 + 80 >> 2]]($7, $23, $5 + 104 | 0);
      if (HEAPU16[$5 + 122 >> 1] + $8 >>> 0 > $17 >>> 0) {
       $22 = 0;
       checkAppendMsg($0, 13969, 0);
       break label$11;
      }
      if (HEAPU8[$7 + 1 | 0]) {
       $25 = HEAP32[$5 + 136 >> 2];
       $19 = HEAP32[$5 + 140 >> 2];
       $3 = HEAP32[$5 + 104 >> 2];
       $4 = HEAP32[$5 + 108 >> 2];
       label$15: {
        label$16: {
         if ($18) {
          if ($25 >>> 0 < $3 >>> 0 & ($4 | 0) >= ($19 | 0) | ($4 | 0) > ($19 | 0)) {
           break label$16;
          }
          break label$15;
         }
         if ($3 >>> 0 < $25 >>> 0 & ($4 | 0) <= ($19 | 0) | ($4 | 0) < ($19 | 0)) {
          break label$15;
         }
        }
        HEAP32[$5 + 48 >> 2] = $3;
        HEAP32[$5 + 52 >> 2] = $4;
        checkAppendMsg($0, 9173, $5 + 48 | 0);
        $3 = HEAP32[$5 + 104 >> 2];
        $4 = HEAP32[$5 + 108 >> 2];
       }
       HEAP32[$5 + 136 >> 2] = $3;
       HEAP32[$5 + 140 >> 2] = $4;
       $18 = 0;
      }
      $3 = HEAP32[$5 + 116 >> 2];
      $4 = HEAPU16[$5 + 120 >> 1];
      if ($3 >>> 0 > $4 >>> 0) {
       $4 = (($3 + $31 | 0) - $4 >>> 0) / ($21 >>> 0) | 0;
       $3 = sqlite3Get4byte((HEAPU16[$5 + 122 >> 1] + $23 | 0) - 4 | 0);
       if (HEAPU8[$9 + 17 | 0]) {
        checkPtrmap($0, $3, 3, $1);
       }
       checkList($0, 0, $3, $4);
      }
      if (!HEAPU8[$7 + 8 | 0]) {
       $8 = sqlite3Get4byte($23);
       if (HEAPU8[$9 + 17 | 0]) {
        checkPtrmap($0, $8, 5, $1);
       }
       $18 = 0;
       $4 = HEAP32[$5 + 136 >> 2];
       $8 = checkTreePage($0, $8, $5 + 136 | 0, $4, HEAP32[$5 + 140 >> 2]);
       if (($11 | 0) == ($8 | 0)) {
        break label$11;
       }
       checkAppendMsg($0, 4456, 0);
       $11 = $8;
       break label$11;
      }
      btreeHeapInsert($10, (HEAPU16[$5 + 122 >> 1] + $8 | 0) - 1 | $8 << 16);
     }
     $15 = $15 - 2 | 0;
     $6 = $6 - 1 | 0;
     continue;
    }
    break;
   }
   $4 = HEAP32[$5 + 140 >> 2];
   HEAP32[$2 >> 2] = HEAP32[$5 + 136 >> 2];
   HEAP32[$2 + 4 >> 2] = $4;
   HEAP32[$0 + 28 >> 2] = 0;
   if ($22) {
    if (HEAP32[$0 + 16 >> 2] <= 0) {
     break label$2;
    }
    label$23: {
     if (HEAPU8[$7 + 8 | 0]) {
      break label$23;
     }
     $10 = HEAP32[$0 + 64 >> 2];
     HEAP32[$10 >> 2] = 0;
     while (1) {
      if (($14 | 0) < 0) {
       break label$23;
      }
      $6 = (($14 << 1) + $24 | 0) + $12 | 0;
      $6 = HEAPU8[$6 | 0] << 8 | HEAPU8[$6 + 1 | 0];
      btreeHeapInsert($10, ($6 + (FUNCTION_TABLE[HEAP32[$7 + 76 >> 2]]($7, $6 + $12 | 0) | 0) | 0) - 1 | $6 << 16);
      $14 = $14 - 1 | 0;
      continue;
     }
    }
    $6 = $20 + 1 | 0;
    while (1) {
     $6 = $6 + $12 | 0;
     $6 = HEAPU8[$6 | 0] << 8 | HEAPU8[$6 + 1 | 0];
     if ($6) {
      $2 = $6 + $12 | 0;
      btreeHeapInsert($10, ((HEAPU8[$2 + 2 | 0] << 8 | HEAPU8[$2 + 3 | 0]) + $6 | 0) - 1 | $6 << 16);
      continue;
     } else {
      $2 = 0;
      while (1) {
       $6 = $16 & 65535;
       label$29: {
        if (btreeHeapPull($10, $5 + 104 | 0)) {
         $16 = HEAP32[$5 + 104 >> 2];
         $9 = $16 >>> 16 | 0;
         if ($9 >>> 0 > $6 >>> 0) {
          break label$29;
         }
         HEAP32[$5 + 20 >> 2] = $1;
         HEAP32[$5 + 16 >> 2] = $9;
         checkAppendMsg($0, 1913, $5 + 16 | 0);
        }
        if (HEAP32[$10 >> 2]) {
         break label$2;
        }
        $6 = (($6 ^ -1) + $17 | 0) + $2 | 0;
        $2 = HEAPU8[$13 + 7 | 0];
        if (($6 | 0) == ($2 | 0)) {
         break label$2;
        }
        HEAP32[$5 + 8 >> 2] = $1;
        HEAP32[$5 + 4 >> 2] = $2;
        HEAP32[$5 >> 2] = $6;
        checkAppendMsg($0, 1861, $5);
        break label$2;
       }
       $2 = (($6 ^ -1) + $2 | 0) + $9 | 0;
       continue;
      }
     }
    }
   }
   HEAP8[$7 | 0] = $29;
  }
  releasePage(HEAP32[$5 + 132 >> 2]);
  HEAP32[$0 + 36 >> 2] = $26;
  HEAP32[$0 + 32 >> 2] = $27;
  HEAP32[$0 + 28 >> 2] = $28;
  $6 = $11 + 1 | 0;
 }
 __stack_pointer = $5 + 144 | 0;
 return $6;
}

function sqlite3_blob_open($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $9 = __stack_pointer - 336 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 332 >> 2] = 0;
 HEAP32[$7 >> 2] = 0;
 $17 = ($6 | 0) != 0;
 $12 = sqlite3DbMallocZero($0, 32, 0);
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: while (1) {
      label$6: {
       sqlite3ParseObjectInit($9 + 56 | 0, $0);
       if (!$12) {
        break label$6;
       }
       sqlite3DbFree($0, HEAP32[$9 + 332 >> 2]);
       HEAP32[$9 + 332 >> 2] = 0;
       sqlite3BtreeEnterAll($0);
       label$7: {
        $11 = sqlite3LocateTable($9 + 56 | 0, 0, $2, $1);
        if ($11) {
         $13 = 7862;
         $8 = HEAPU8[$11 + 43 | 0];
         label$9: {
          if (($8 | 0) == 1) {
           break label$9;
          }
          $13 = 8042;
          if (HEAPU8[$11 + 28 | 0] & 128) {
           break label$9;
          }
          if (($8 | 0) != 2) {
           break label$7;
          }
          $13 = 7116;
         }
         HEAP32[$9 + 16 >> 2] = $2;
         $8 = $13;
         sqlite3ErrorMsg($9 + 56 | 0, $8, $9 + 16 | 0);
        }
        $16 = 1;
        if (!HEAP32[$9 + 60 >> 2]) {
         break label$3;
        }
        sqlite3DbFree($0, 0);
        HEAP32[$9 + 332 >> 2] = HEAP32[$9 + 60 >> 2];
        HEAP32[$9 + 60 >> 2] = 0;
        break label$3;
       }
       HEAP32[$12 + 28 >> 2] = $11;
       HEAP32[$12 + 24 >> 2] = HEAP32[HEAP32[$0 + 16 >> 2] + (sqlite3SchemaToIndex($0, HEAP32[$11 + 60 >> 2]) << 4) >> 2];
       $8 = 0;
       $10 = HEAP16[$11 + 34 >> 1];
       $13 = ($10 | 0) > 0 ? $10 : 0;
       while (1) {
        label$11: {
         if (($8 | 0) != ($13 | 0)) {
          if (sqlite3StrICmp(HEAP32[HEAP32[$11 + 4 >> 2] + Math_imul($8, 12) >> 2], $3)) {
           break label$11;
          }
          $13 = $8;
         }
         label$13: {
          label$14: {
           if (($10 | 0) == ($13 | 0)) {
            sqlite3DbFree($0, 0);
            HEAP32[$9 + 32 >> 2] = $3;
            HEAP32[$9 + 332 >> 2] = sqlite3MPrintf($0, 28881, $9 + 32 | 0);
            break label$14;
           }
           if (!$6) {
            break label$13;
           }
           $10 = 0;
           label$16: {
            if (!(HEAPU8[$0 + 33 | 0] & 64)) {
             break label$16;
            }
            $8 = $11 + 48 | 0;
            while (1) {
             $15 = HEAP32[$8 >> 2];
             if (!$15) {
              break label$16;
             }
             $8 = 0;
             $14 = HEAP32[$15 + 20 >> 2];
             $14 = ($14 | 0) > 0 ? $14 : 0;
             while (1) {
              if (($8 | 0) != ($14 | 0)) {
               $10 = HEAP32[(($8 << 3) + $15 | 0) + 36 >> 2] == ($13 | 0) ? 1325 : $10;
               $8 = $8 + 1 | 0;
               continue;
              }
              break;
             }
             $8 = $15 + 4 | 0;
             continue;
            }
           }
           $8 = $11 + 8 | 0;
           while (1) {
            $14 = HEAP32[$8 >> 2];
            if ($14) {
             $19 = HEAPU16[$14 + 50 >> 1];
             $8 = 0;
             while (1) {
              if (($8 | 0) != ($19 | 0)) {
               $15 = HEAP16[HEAP32[$14 + 4 >> 2] + ($8 << 1) >> 1];
               $10 = ($15 | 0) == -2 ? 14744 : ($13 | 0) == ($15 | 0) ? 14744 : $10;
               $8 = $8 + 1 | 0;
               continue;
              }
              break;
             }
             $8 = $14 + 20 | 0;
             continue;
            }
            break;
           }
           if (!$10) {
            break label$13;
           }
           sqlite3DbFree($0, 0);
           HEAP32[$9 + 48 >> 2] = $10;
           HEAP32[$9 + 332 >> 2] = sqlite3MPrintf($0, 11899, $9 + 48 | 0);
          }
          $16 = 1;
          break label$4;
         }
         $10 = sqlite3VdbeCreate($9 + 56 | 0);
         HEAP32[$12 + 16 >> 2] = $10;
         label$24: {
          label$25: {
           if ($10) {
            $8 = HEAP32[$11 + 60 >> 2];
            $15 = sqlite3SchemaToIndex($0, $8);
            sqlite3VdbeAddOp4Int($10, 2, $15, $17, HEAP32[$8 >> 2], HEAP32[$8 + 4 >> 2]);
            sqlite3VdbeChangeP5($10, 1);
            $8 = sqlite3VdbeAddOpList($10, 6, 30256);
            sqlite3VdbeUsesBtree($10, $15);
            if (HEAPU8[$0 + 87 | 0]) {
             break label$25;
            }
            HEAP32[$8 + 4 >> 2] = $15;
            $14 = HEAP32[$11 + 20 >> 2];
            HEAP32[$8 + 12 >> 2] = $17;
            HEAP32[$8 + 8 >> 2] = $14;
            sqlite3VdbeChangeP4($10, 2, HEAP32[$11 >> 2], 0);
            if (HEAPU8[$0 + 87 | 0]) {
             break label$25;
            }
            if ($6) {
             HEAP8[$8 + 20 | 0] = 113;
            }
            $14 = HEAP32[$11 + 20 >> 2];
            HEAP32[$8 + 32 >> 2] = $15;
            HEAP32[$8 + 28 >> 2] = $14;
            HEAP8[$8 + 21 | 0] = 253;
            HEAP32[$8 + 36 >> 2] = HEAP16[$11 + 34 >> 1] + 1;
            HEAP32[$8 + 68 >> 2] = HEAP16[$11 + 34 >> 1];
            HEAP16[$9 + 260 >> 1] = 0;
            HEAP32[$9 + 96 >> 2] = 1;
            HEAP32[$9 + 100 >> 2] = 1;
            sqlite3VdbeMakeReady($10, $9 + 56 | 0);
           }
           $8 = HEAPU8[$0 + 87 | 0];
           HEAP32[$12 + 20 >> 2] = $0;
           HEAP16[$12 + 8 >> 1] = $13;
           if ($8) {
            break label$24;
           }
           $16 = blobSeekToRow($12, $4, $5, $9 + 332 | 0);
           if (($16 | 0) != 17 | $18 >>> 0 > 48) {
            break label$24;
           }
           $18 = $18 + 1 | 0;
           sqlite3ParseObjectReset($9 + 56 | 0);
           $16 = 17;
           continue label$5;
          }
          HEAP32[$12 + 20 >> 2] = $0;
          HEAP16[$12 + 8 >> 1] = $13;
         }
         if ($16) {
          break label$4;
         }
         break label$6;
        }
        $8 = $8 + 1 | 0;
        continue;
       }
      }
      break;
     }
     $16 = 0;
     if (HEAPU8[$0 + 87 | 0]) {
      break label$4;
     }
     HEAP32[$7 >> 2] = $12;
     break label$1;
    }
    if (!$12) {
     break label$2;
    }
   }
   $8 = HEAP32[$12 + 16 >> 2];
   if (!$8) {
    break label$2;
   }
   sqlite3VdbeFinalize($8);
  }
  sqlite3DbFree($0, $12);
 }
 $8 = HEAP32[$9 + 332 >> 2];
 HEAP32[$9 >> 2] = $8;
 sqlite3ErrorWithMsg($0, $16, $8 ? 8342 : 0, $9);
 sqlite3DbFree($0, $8);
 sqlite3ParseObjectReset($9 + 56 | 0);
 $8 = sqlite3ApiExit($0, $16);
 __stack_pointer = $9 + 336 | 0;
 return $8;
}

function sqlite3FindInIndex($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $14 = __stack_pointer - 32 | 0;
 __stack_pointer = $14;
 $13 = sqlite3GetVdbe($0);
 $12 = HEAP32[$0 + 40 >> 2];
 HEAP32[$0 + 40 >> 2] = $12 + 1;
 label$1: {
  if (!$3) {
   $3 = 0;
   break label$1;
  }
  if (!(HEAPU8[$1 + 5 | 0] & 16)) {
   break label$1;
  }
  $11 = HEAP32[HEAP32[$1 + 20 >> 2] + 28 >> 2];
  $7 = HEAP32[$11 >> 2];
  $8 = ($7 | 0) > 0 ? $7 : 0;
  while (1) {
   label$4: {
    if (($6 | 0) != ($8 | 0)) {
     if (!sqlite3ExprCanBeNull(HEAP32[(($6 << 4) + $11 | 0) + 8 >> 2])) {
      break label$4;
     }
     $8 = $6;
    }
    $3 = ($8 | 0) == ($7 | 0) ? 0 : $3;
    break label$1;
   }
   $6 = $6 + 1 | 0;
   continue;
  }
 }
 $21 = $2 & 4;
 label$6: {
  label$7: {
   if (HEAP32[$0 + 36 >> 2]) {
    break label$7;
   }
   $6 = isCandidateForInOpt($1);
   if (!$6) {
    break label$7;
   }
   $16 = HEAP32[$6 + 28 >> 2];
   $11 = HEAP32[$16 >> 2];
   $9 = HEAP32[HEAP32[$6 + 32 >> 2] + 24 >> 2];
   $17 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$9 + 60 >> 2]);
   sqlite3CodeVerifySchema($0, $17);
   $6 = 0;
   sqlite3TableLock($0, $17, HEAP32[$9 + 20 >> 2], 0, HEAP32[$9 >> 2]);
   if (!(($11 | 0) != 1 | HEAP16[HEAP32[$16 + 8 >> 2] + 32 >> 1] >= 0)) {
    $6 = sqlite3VdbeAddOp0($13, 14);
    sqlite3OpenTable($0, $12, $17, $9, 112);
    HEAP32[$14 >> 2] = HEAP32[$9 >> 2];
    sqlite3VdbeExplain($0, 0, 18928, $14);
    sqlite3VdbeJumpHere($13, $6);
    $7 = 1;
    break label$6;
   }
   $8 = 1;
   while (1) {
    if (!(!$8 | ($6 | 0) >= ($11 | 0))) {
     $8 = sqlite3VectorFieldSubexpr(HEAP32[$1 + 12 >> 2], $6);
     $7 = sqlite3TableColumnAffinity($9, HEAP16[HEAP32[(($6 << 4) + $16 | 0) + 8 >> 2] + 32 >> 1]);
     $8 = ($7 | 0) > 66 | sqlite3CompareAffinity($8, $7) - 65 >>> 0 < 2;
     $6 = $6 + 1 | 0;
     continue;
    }
    break;
   }
   if (!$8) {
    break label$7;
   }
   $22 = ($11 | 0) > 0 ? $11 : 0;
   $6 = $9 + 8 | 0;
   $7 = $11 & 31;
   if (($11 & 63) >>> 0 >= 32) {
    $10 = -1 << $7;
    $9 = 0;
   } else {
    $10 = (1 << $7) - 1 & -1 >>> 32 - $7 | -1 << $7;
    $9 = -1 << $7;
   }
   $23 = $9 ^ -1;
   $24 = $10 ^ -1;
   $7 = 0;
   while (1) {
    $8 = HEAP32[$6 >> 2];
    if (!(!$8 | $7)) {
     $7 = 0;
     $6 = HEAPU16[$8 + 52 >> 1];
     label$13: {
      if (($11 | 0) > ($6 | 0) | (HEAP32[$8 + 36 >> 2] | $6 >>> 0 > 62)) {
       break label$13;
      }
      label$14: {
       if (!$21) {
        break label$14;
       }
       if (HEAPU16[$8 + 50 >> 1] > ($11 | 0)) {
        break label$13;
       }
       if (($6 | 0) <= ($11 | 0)) {
        break label$14;
       }
       if (!HEAPU8[$8 + 54 | 0]) {
        break label$13;
       }
      }
      $15 = 0;
      $18 = 0;
      $19 = 0;
      while (1) {
       label$16: {
        if (($15 | 0) == ($22 | 0)) {
         break label$16;
        }
        $6 = 0;
        $10 = sqlite3VectorFieldSubexpr(HEAP32[$1 + 12 >> 2], $15);
        $9 = HEAP32[(($15 << 4) + $16 | 0) + 8 >> 2];
        $10 = sqlite3BinaryCompareCollSeq($0, $10, $9);
        while (1) {
         $7 = ($6 | 0) == ($11 | 0);
         if ($7) {
          break label$16;
         }
         label$18: {
          if (HEAPU16[HEAP32[$8 + 4 >> 2] + ($6 << 1) >> 1] == HEAPU16[$9 + 32 >> 1]) {
           if (!$10) {
            break label$18;
           }
           if (!sqlite3StrICmp(HEAP32[$10 >> 2], HEAP32[HEAP32[$8 + 32 >> 2] + ($6 << 2) >> 2])) {
            break label$18;
           }
          }
          $6 = $6 + 1 | 0;
          continue;
         }
         break;
        }
        if ($7) {
         break label$16;
        }
        $7 = $6 & 31;
        if (($6 & 63) >>> 0 >= 32) {
         $9 = 1 << $7;
         $20 = 0;
        } else {
         $9 = (1 << $7) - 1 & 1 >>> 32 - $7;
         $20 = 1 << $7;
        }
        $7 = $9;
        $10 = $19;
        $10 = $9 & $10;
        $9 = $18 & $20;
        if ($9 | $10) {
         break label$16;
        }
        if ($4) {
         HEAP32[($15 << 2) + $4 >> 2] = $6;
        }
        $18 = $18 | $20;
        $9 = $19;
        $10 = $7;
        $10 = $9 | $10;
        $19 = $10;
        $15 = $15 + 1 | 0;
        continue;
       }
       break;
      }
      $7 = 0;
      $9 = $18;
      $10 = $19;
      if (($23 | 0) != ($9 | 0) | ($10 | 0) != ($24 | 0)) {
       break label$13;
      }
      $6 = sqlite3VdbeAddOp0($13, 14);
      HEAP32[$14 + 16 >> 2] = HEAP32[$8 >> 2];
      sqlite3VdbeExplain($0, 0, 18897, $14 + 16 | 0);
      sqlite3VdbeAddOp3($13, 112, $12, HEAP32[$8 + 44 >> 2], $17);
      sqlite3VdbeSetP4KeyInfo($0, $8);
      $7 = HEAPU8[HEAP32[$8 + 28 >> 2]];
      label$21: {
       if (!$3) {
        break label$21;
       }
       $9 = HEAP32[$0 + 44 >> 2] + 1 | 0;
       HEAP32[$0 + 44 >> 2] = $9;
       HEAP32[$3 >> 2] = $9;
       if (($11 | 0) != 1) {
        break label$21;
       }
       sqlite3SetHasNullFlag($13, $12, $9);
      }
      $7 = $7 + 3 | 0;
      sqlite3VdbeJumpHere($13, $6);
     }
     $6 = $8 + 20 | 0;
     continue;
    }
    break;
   }
   if ($7) {
    break label$6;
   }
  }
  label$22: {
   if (!($2 & 1) | HEAPU8[$1 + 5 | 0] & 16) {
    break label$22;
   }
   if (wasm2js_i32$0 = sqlite3InRhsIsConstant($1), wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAP32[HEAP32[$1 + 20 >> 2] >> 2] > 2, 
   wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
    break label$22;
   }
   $12 = -1;
   HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 40 >> 2] - 1;
   $7 = 5;
   break label$6;
  }
  $8 = HEAP32[$0 + 136 >> 2];
  label$24: {
   if ($21) {
    $6 = 0;
    HEAP32[$0 + 136 >> 2] = 0;
    break label$24;
   }
   if (!$3) {
    $6 = 0;
    break label$24;
   }
   $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $6;
   HEAP32[$3 >> 2] = $6;
  }
  sqlite3CodeRhsOfIN($0, $1, $12);
  if ($6) {
   sqlite3SetHasNullFlag($13, $12, $6);
  }
  HEAP32[$0 + 136 >> 2] = $8;
  $7 = 2;
 }
 label$28: {
  if (!$4 | ($7 | 0) == 3 | ($7 | 0) == 4) {
   break label$28;
  }
  $6 = 0;
  $8 = sqlite3ExprVectorSize(HEAP32[$1 + 12 >> 2]);
  $8 = ($8 | 0) > 0 ? $8 : 0;
  while (1) {
   if (($6 | 0) == ($8 | 0)) {
    break label$28;
   }
   HEAP32[($6 << 2) + $4 >> 2] = $6;
   $6 = $6 + 1 | 0;
   continue;
  }
 }
 HEAP32[$5 >> 2] = $12;
 __stack_pointer = $14 + 32 | 0;
 return $7;
}

function sqlite3Fts3SegReaderStep($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $13 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if (!$13) {
   break label$1;
  }
  $17 = HEAPU8[$0 + 239 | 0] ? 98 : 99;
  $8 = HEAP32[$1 >> 2];
  $18 = ($13 | 0) > 1 ? $13 : 1;
  $14 = HEAP32[$1 + 12 >> 2];
  $2 = HEAP32[$14 + 12 >> 2];
  $19 = $2 & 2;
  $20 = $2 & 1;
  $22 = $2 & 4;
  $23 = $2 & 16;
  $21 = $2 & 32;
  $24 = !($2 & 8);
  label$3: while (1) {
   $2 = 0;
   while (1) {
    $3 = HEAP32[$1 + 8 >> 2];
    if (($3 | 0) > ($2 | 0)) {
     $3 = HEAP32[($2 << 2) + $8 >> 2];
     label$6: {
      if (HEAPU8[$3 + 4 | 0]) {
       fts3SegReaderSetEof($3);
       break label$6;
      }
      $6 = fts3SegReaderNext($0, $3);
      if ($6) {
       break label$1;
      }
     }
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   fts3SegReaderSort($8, $13, $3, 100);
   $6 = 0;
   HEAP32[$1 + 8 >> 2] = 0;
   $2 = HEAP32[$8 >> 2];
   if (!HEAP32[$2 + 40 >> 2]) {
    break label$1;
   }
   $3 = HEAP32[$2 + 60 >> 2];
   HEAP32[$1 + 44 >> 2] = $3;
   $5 = HEAP32[$2 + 64 >> 2];
   HEAP32[$1 + 40 >> 2] = $5;
   $2 = HEAP32[$14 >> 2];
   if (!(!$2 | $23)) {
    $4 = HEAP32[$14 + 4 >> 2];
    if (($4 | 0) > ($3 | 0) | ($3 | 0) > ($4 | 0) & $24) {
     break label$1;
    }
    if (memcmp($5, $2, $4)) {
     break label$1;
    }
   }
   $4 = 1;
   while (1) {
    label$10: {
     if (($4 | 0) == ($18 | 0)) {
      $4 = $18;
      break label$10;
     }
     $2 = HEAP32[($4 << 2) + $8 >> 2];
     if (!HEAP32[$2 + 40 >> 2] | HEAP32[$2 + 60 >> 2] != ($3 | 0)) {
      break label$10;
     }
     if (memcmp($5, HEAP32[$2 + 64 >> 2], $3)) {
      break label$10;
     }
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   label$12: {
    if (($4 | 0) != 1 | $19 | $21) {
     break label$12;
    }
    $3 = HEAP32[$8 >> 2];
    $2 = HEAP32[$3 + 56 >> 2];
    label$13: {
     label$14: {
      label$15: {
       label$16: {
        if (HEAPU8[$0 + 239 | 0]) {
         if ($2) {
          break label$12;
         }
         HEAP32[$1 + 52 >> 2] = HEAP32[$3 + 76 >> 2];
         break label$16;
        }
        $4 = HEAP32[$3 + 76 >> 2];
        HEAP32[$1 + 52 >> 2] = $4;
        if ($2) {
         break label$15;
        }
       }
       HEAP32[$1 + 48 >> 2] = HEAP32[$3 + 72 >> 2];
       break label$14;
      }
      $6 = fts3MsrBufferData($1, HEAP32[$3 + 72 >> 2], $4);
      HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 16 >> 2];
      if ($6) {
       break label$13;
      }
     }
     $6 = 100;
    }
    HEAP32[$1 + 8 >> 2] = 1;
    break label$1;
   }
   $2 = 0;
   while (1) {
    if (($2 | 0) != ($4 | 0)) {
     fts3SegReaderFirstDocid($0, HEAP32[($2 << 2) + $8 >> 2]);
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   fts3SegReaderSort($8, $4, $4, $17);
   $9 = 0;
   $10 = 0;
   $5 = 0;
   while (1) {
    label$21: {
     if (HEAP32[HEAP32[$8 >> 2] + 80 >> 2]) {
      HEAP32[$7 + 12 >> 2] = 0;
      HEAP32[$7 + 8 >> 2] = 0;
      $2 = HEAP32[$8 >> 2];
      $11 = HEAP32[$2 + 88 >> 2];
      $12 = HEAP32[$2 + 92 >> 2];
      fts3SegReaderNextDocid($0, $2, $7 + 12 | 0, $7 + 8 | 0);
      $2 = 1;
      while (1) {
       if (($2 | 0) == ($4 | 0)) {
        $2 = $4;
        break label$21;
       }
       $3 = HEAP32[($2 << 2) + $8 >> 2];
       if (!HEAP32[$3 + 80 >> 2] | (($11 | 0) != HEAP32[$3 + 88 >> 2] | ($12 | 0) != HEAP32[$3 + 92 >> 2])) {
        break label$21;
       }
       fts3SegReaderNextDocid($0, $3, 0, 0);
       $2 = $2 + 1 | 0;
       continue;
      }
     }
     if (($5 | 0) > 0) {
      $6 = fts3GrowSegReaderBuffer($1, $5 + 20 | 0);
      if ($6) {
       break label$1;
      }
      $2 = HEAP32[$1 + 16 >> 2] + $5 | 0;
      HEAP8[$2 | 0] = 0;
      HEAP8[$2 + 1 | 0] = 0;
      HEAP8[$2 + 2 | 0] = 0;
      HEAP8[$2 + 3 | 0] = 0;
      HEAP8[$2 + 4 | 0] = 0;
      HEAP8[$2 + 5 | 0] = 0;
      HEAP8[$2 + 6 | 0] = 0;
      HEAP8[$2 + 7 | 0] = 0;
      HEAP8[$2 + 16 | 0] = 0;
      HEAP8[$2 + 17 | 0] = 0;
      HEAP8[$2 + 18 | 0] = 0;
      HEAP8[$2 + 19 | 0] = 0;
      HEAP8[$2 + 8 | 0] = 0;
      HEAP8[$2 + 9 | 0] = 0;
      HEAP8[$2 + 10 | 0] = 0;
      HEAP8[$2 + 11 | 0] = 0;
      HEAP8[$2 + 12 | 0] = 0;
      HEAP8[$2 + 13 | 0] = 0;
      HEAP8[$2 + 14 | 0] = 0;
      HEAP8[$2 + 15 | 0] = 0;
      HEAP32[$1 + 52 >> 2] = $5;
      HEAP32[$1 + 8 >> 2] = $4;
      HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 16 >> 2];
      $6 = 100;
      break label$1;
     }
     HEAP32[$1 + 8 >> 2] = $4;
     continue label$3;
    }
    if ($22) {
     fts3ColumnFilter(HEAP32[$14 + 8 >> 2], 0, $7 + 12 | 0, $7 + 8 | 0);
    }
    label$27: {
     $3 = HEAP32[$7 + 8 >> 2];
     label$28: {
      if (($3 | 0) <= 0 ? $19 : 0) {
       break label$28;
      }
      label$29: {
       if (!(!HEAPU8[$0 + 239 | 0] | ($5 | 0) <= 0)) {
        if (($10 | 0) <= ($12 | 0) & $9 >>> 0 <= $11 >>> 0 | ($10 | 0) < ($12 | 0)) {
         break label$27;
        }
        $15 = $9 - $11 | 0;
        $16 = $10 - (($9 >>> 0 < $11 >>> 0) + $12 | 0) | 0;
        break label$29;
       }
       if ((($10 | 0) >= ($12 | 0) & $9 >>> 0 >= $11 >>> 0 | ($10 | 0) > ($12 | 0)) & ($5 | 0) > 0) {
        break label$27;
       }
       $15 = $11 - $9 | 0;
       $16 = $12 - (($9 >>> 0 > $11 >>> 0) + $10 | 0) | 0;
      }
      $6 = fts3GrowSegReaderBuffer($1, (sqlite3Fts3VarintLen($15, $16) + (($20 ? $3 + 1 | 0 : 0) + $5 | 0) | 0) + 20 | 0);
      if ($6) {
       break label$1;
      }
      $6 = HEAP32[$1 + 16 >> 2] + $5 | 0;
      if ($21) {
       $3 = sqlite3Fts3FirstFilter($15, $16, HEAP32[$7 + 12 >> 2], $3, $6);
       $9 = $3 ? $11 : $9;
       $10 = $3 ? $12 : $10;
       $5 = $3 + $5 | 0;
       break label$28;
      }
      $5 = sqlite3Fts3PutVarint($6, $15, $16) + $5 | 0;
      if ($20) {
       __memcpy(HEAP32[$1 + 16 >> 2] + $5 | 0, HEAP32[$7 + 12 >> 2], $3);
       $3 = $3 + $5 | 0;
       HEAP8[$3 + HEAP32[$1 + 16 >> 2] | 0] = 0;
       $5 = $3 + 1 | 0;
      }
      $9 = $11;
      $10 = $12;
     }
     fts3SegReaderSort($8, $4, $2, $17);
     continue;
    }
    break;
   }
   break;
  }
  $6 = 267;
 }
 __stack_pointer = $7 + 16 | 0;
 return $6;
}

function renameColumnFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $1 = __stack_pointer - 336 | 0;
 __stack_pointer = $1;
 $8 = sqlite3_context_db_handle($0);
 $11 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $3 = sqlite3_value_text(HEAP32[$2 + 12 >> 2]);
 $6 = sqlite3_value_text(HEAP32[$2 + 16 >> 2]);
 $9 = sqlite3_value_int(HEAP32[$2 + 20 >> 2]);
 $12 = sqlite3_value_text(HEAP32[$2 + 24 >> 2]);
 $13 = sqlite3_value_int(HEAP32[$2 + 28 >> 2]);
 $5 = sqlite3_value_int(HEAP32[$2 + 32 >> 2]);
 label$1: {
  if (!$11 | !$6 | (!$12 | ($9 | 0) < 0)) {
   break label$1;
  }
  $14 = HEAP32[$8 + 360 >> 2];
  sqlite3BtreeEnterAll($8);
  $7 = sqlite3FindTable($8, $6, $3);
  if (!$7 | HEAP16[$7 + 34 >> 1] <= ($9 | 0)) {
   break label$1;
  }
  $10 = HEAP32[HEAP32[$7 + 4 >> 2] + Math_imul($9, 12) >> 2];
  HEAP32[$1 + 328 >> 2] = 0;
  $4 = $1 + 320 | 0;
  HEAP32[$4 >> 2] = 0;
  HEAP32[$4 + 4 >> 2] = 0;
  HEAP32[$1 + 312 >> 2] = 0;
  HEAP32[$1 + 316 >> 2] = 0;
  HEAP32[$1 + 320 >> 2] = HEAP16[$7 + 32 >> 1] == ($9 | 0) ? -1 : $9;
  HEAP32[$8 + 360 >> 2] = 0;
  $5 = renameParseSql($1 + 40 | 0, $3, $8, $11, $5);
  HEAP32[$1 + 28 >> 2] = 0;
  HEAP32[$1 + 20 >> 2] = 0;
  HEAP32[$1 + 24 >> 2] = 0;
  HEAP32[$1 + 16 >> 2] = 88;
  HEAP32[$1 + 12 >> 2] = 89;
  HEAP32[$1 + 324 >> 2] = $7;
  HEAP32[$1 + 32 >> 2] = $1 + 312;
  HEAP32[$1 + 8 >> 2] = $1 + 40;
  label$2: {
   if ($5) {
    break label$2;
   }
   label$3: {
    label$4: {
     $4 = HEAP32[$1 + 276 >> 2];
     if ($4) {
      label$6: {
       switch (HEAPU8[$4 + 43 | 0]) {
       case 2:
        $3 = HEAP32[$4 + 44 >> 2];
        HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] & -2097153;
        HEAP32[$1 + 52 >> 2] = 0;
        sqlite3SelectPrep($1 + 40 | 0, $3, 0);
        $5 = HEAPU8[$8 + 87 | 0] ? 7 : HEAP32[$1 + 52 >> 2];
        if ($5) {
         break label$2;
        }
        sqlite3WalkSelect($1 + 8 | 0, $3);
        break label$3;

       case 0:
        break label$6;

       default:
        break label$3;
       }
      }
      $5 = sqlite3_stricmp($6, HEAP32[$4 >> 2]);
      HEAP32[$1 + 324 >> 2] = $4;
      if ($5) {
       break label$4;
      }
      if (HEAP16[$4 + 34 >> 1] > ($9 | 0)) {
       renameTokenFind($1 + 40 | 0, $1 + 312 | 0, HEAP32[HEAP32[$4 + 4 >> 2] + Math_imul($9, 12) >> 2]);
      }
      if (HEAP32[$1 + 320 >> 2] < 0) {
       renameTokenFind($1 + 40 | 0, $1 + 312 | 0, HEAP32[$1 + 276 >> 2] + 32 | 0);
      }
      sqlite3WalkExprList($1 + 8 | 0, HEAP32[HEAP32[$1 + 276 >> 2] + 16 >> 2]);
      $3 = HEAP32[$1 + 276 >> 2] + 8 | 0;
      while (1) {
       $3 = HEAP32[$3 >> 2];
       if ($3) {
        sqlite3WalkExprList($1 + 8 | 0, HEAP32[$3 + 40 >> 2]);
        $3 = $3 + 20 | 0;
        continue;
       }
       break;
      }
      $3 = $1 + 280 | 0;
      while (1) {
       $3 = HEAP32[$3 >> 2];
       if ($3) {
        sqlite3WalkExprList($1 + 8 | 0, HEAP32[$3 + 40 >> 2]);
        $3 = $3 + 20 | 0;
        continue;
       } else {
        $3 = 0;
        while (1) {
         $4 = HEAP32[$1 + 276 >> 2];
         if (HEAP16[$4 + 34 >> 1] <= ($3 | 0)) {
          break label$4;
         }
         sqlite3WalkExpr($1 + 8 | 0, sqlite3ColumnExpr($4, HEAP32[$4 + 4 >> 2] + Math_imul($3, 12) | 0));
         $3 = $3 + 1 | 0;
         continue;
        }
       }
      }
     }
     $6 = HEAP32[$1 + 280 >> 2];
     if ($6) {
      sqlite3WalkExprList($1 + 8 | 0, HEAP32[$6 + 40 >> 2]);
      sqlite3WalkExpr($1 + 8 | 0, HEAP32[HEAP32[$1 + 280 >> 2] + 36 >> 2]);
      break label$3;
     }
     $5 = renameResolveTrigger($1 + 40 | 0);
     if ($5) {
      break label$2;
     }
     $6 = HEAP32[$1 + 284 >> 2] + 28 | 0;
     while (1) {
      $6 = HEAP32[$6 >> 2];
      if ($6) {
       $5 = HEAP32[$6 + 12 >> 2];
       label$19: {
        if (!$5) {
         break label$19;
        }
        if ((sqlite3LocateTable($1 + 40 | 0, 0, $5, $3) | 0) != ($7 | 0)) {
         break label$19;
        }
        $5 = HEAP32[$6 + 32 >> 2];
        if ($5) {
         renameColumnElistNames($1 + 40 | 0, $1 + 312 | 0, HEAP32[$5 + 8 >> 2], $10);
        }
        renameColumnIdlistNames($1 + 40 | 0, $1 + 312 | 0, HEAP32[$6 + 28 >> 2], $10);
        renameColumnElistNames($1 + 40 | 0, $1 + 312 | 0, HEAP32[$6 + 24 >> 2], $10);
       }
       $6 = $6 + 40 | 0;
       continue;
      }
      break;
     }
     if (HEAP32[$1 + 160 >> 2] == ($7 | 0)) {
      renameColumnIdlistNames($1 + 40 | 0, $1 + 312 | 0, HEAP32[HEAP32[$1 + 284 >> 2] + 16 >> 2], $10);
     }
     renameWalkTrigger($1 + 8 | 0, HEAP32[$1 + 284 >> 2]);
     break label$3;
    }
    $3 = $4 + 48 | 0;
    while (1) {
     $7 = HEAP32[$3 >> 2];
     if (!$7) {
      break label$3;
     }
     $3 = 0;
     while (1) {
      if (($3 | 0) < HEAP32[$7 + 20 >> 2]) {
       label$25: {
        if ($5) {
         break label$25;
        }
        $4 = (($3 << 3) + $7 | 0) + 36 | 0;
        if (HEAP32[$4 >> 2] != ($9 | 0)) {
         break label$25;
        }
        renameTokenFind($1 + 40 | 0, $1 + 312 | 0, $4);
       }
       label$26: {
        if (sqlite3_stricmp(HEAP32[$7 + 8 >> 2], $6)) {
         break label$26;
        }
        $4 = HEAP32[(($3 << 3) + $7 | 0) + 40 >> 2];
        if (sqlite3_stricmp($4, $10)) {
         break label$26;
        }
        renameTokenFind($1 + 40 | 0, $1 + 312 | 0, $4);
       }
       $3 = $3 + 1 | 0;
       continue;
      }
      break;
     }
     $3 = $7 + 4 | 0;
     continue;
    }
   }
   $5 = renameEditSql($0, $1 + 312 | 0, $11, $12, $13);
  }
  label$27: {
   label$28: {
    label$29: {
     switch ($5 | 0) {
     case 0:
      break label$27;

     case 1:
      break label$29;

     default:
      break label$28;
     }
    }
    if (!sqlite3WritableSchema($8)) {
     break label$28;
    }
    sqlite3_result_value($0, HEAP32[$2 >> 2]);
    break label$27;
   }
   if (HEAP32[$1 + 44 >> 2]) {
    renameColumnParseError($0, 29623, HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2], $1 + 40 | 0);
    break label$27;
   }
   sqlite3_result_error_code($0, $5);
  }
  renameParseCleanup($1 + 40 | 0);
  renameTokenFree($8, HEAP32[$1 + 312 >> 2]);
  HEAP32[$8 + 360 >> 2] = $14;
 }
 __stack_pointer = $1 + 336 | 0;
}

function fts3EvalNextRow($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 label$1: {
  label$2: {
   if (HEAP32[$2 >> 2]) {
    break label$2;
   }
   $8 = HEAPU8[$0 + 52 | 0];
   HEAP8[$1 + 33 | 0] = 1;
   label$3: {
    switch (HEAP32[$1 >> 2] - 1 | 0) {
    case 0:
    case 2:
     $4 = HEAP32[$1 + 16 >> 2];
     $5 = HEAP32[$1 + 12 >> 2];
     if (HEAPU8[$5 + 34 | 0]) {
      fts3EvalNextRow($0, $4, $2);
      $6 = HEAP32[$4 + 28 >> 2];
      $3 = HEAP32[$4 + 24 >> 2];
      HEAP32[$1 + 24 >> 2] = $3;
      HEAP32[$1 + 28 >> 2] = $6;
      HEAP8[$1 + 32 | 0] = HEAPU8[$4 + 32 | 0];
      return;
     }
     $12 = HEAPU8[$4 + 34 | 0];
     fts3EvalNextRow($0, $5, $2);
     if ($12) {
      $3 = HEAP32[$5 + 28 >> 2];
      $6 = HEAP32[$5 + 24 >> 2];
      HEAP32[$1 + 24 >> 2] = $6;
      HEAP32[$1 + 28 >> 2] = $3;
      HEAP8[$1 + 32 | 0] = HEAPU8[$5 + 32 | 0];
      return;
     }
     fts3EvalNextRow($0, $4, $2);
     $14 = $8 & 255;
     label$8: {
      while (1) {
       if (HEAPU8[$5 + 32 | 0]) {
        $6 = HEAP32[$5 + 28 >> 2];
        $3 = HEAP32[$5 + 24 >> 2];
        HEAP32[$1 + 24 >> 2] = $3;
        HEAP32[$1 + 28 >> 2] = $6;
        $8 = 1;
        break label$8;
       }
       label$11: {
        $12 = HEAPU8[$4 + 32 | 0];
        if ($12 | HEAP32[$2 >> 2]) {
         break label$11;
        }
        $6 = HEAP32[$5 + 24 >> 2];
        $10 = $6;
        $3 = HEAP32[$5 + 28 >> 2];
        $9 = $3;
        $3 = HEAP32[$4 + 24 >> 2];
        $11 = $3;
        $7 = $6;
        $6 = HEAP32[$4 + 28 >> 2];
        $3 = $6;
        $6 = $9;
        $7 = ($11 | 0) != ($7 | 0) | ($3 | 0) != ($6 | 0) ? -1 : 0;
        $6 = $3;
        $3 = $11;
        $8 = $10 >>> 0 > $3 >>> 0 & ($9 | 0) >= ($6 | 0) | ($6 | 0) < ($9 | 0) ? 1 : $7;
        $8 = $14 ? 0 - $8 | 0 : $8;
        if (!$8) {
         break label$11;
        }
        fts3EvalNextRow($0, ($8 | 0) < 0 ? $5 : $4, $2);
        continue;
       }
       break;
      }
      $7 = HEAP32[$5 + 28 >> 2];
      HEAP32[$1 + 24 >> 2] = HEAP32[$5 + 24 >> 2];
      HEAP32[$1 + 28 >> 2] = $7;
      $8 = ($12 | 0) != 0;
     }
     HEAP8[$1 + 32 | 0] = $8;
     if (!$8 | HEAP32[$1 >> 2] != 1) {
      break label$2;
     }
     label$12: {
      $1 = HEAP32[$4 + 20 >> 2];
      if (!HEAP32[$1 >> 2]) {
       break label$12;
      }
      while (1) {
       if (HEAP32[$2 >> 2] | HEAPU8[$4 + 32 | 0]) {
        break label$12;
       }
       memset(HEAP32[$1 + 28 >> 2], 0, HEAP32[$1 + 32 >> 2]);
       fts3EvalNextRow($0, $4, $2);
       continue;
      }
     }
     label$14: {
      $1 = HEAP32[$5 + 20 >> 2];
      if (!$1 | !HEAP32[$1 >> 2]) {
       break label$14;
      }
      while (1) {
       if (HEAP32[$2 >> 2] | HEAPU8[$5 + 32 | 0]) {
        break label$14;
       }
       memset(HEAP32[$1 + 28 >> 2], 0, HEAP32[$1 + 32 >> 2]);
       fts3EvalNextRow($0, $5, $2);
       continue;
      }
     }
     HEAP8[$5 + 32 | 0] = 1;
     HEAP8[$4 + 32 | 0] = 1;
     return;

    case 3:
     $14 = $8 & 255 ? -1 : 1;
     $4 = HEAP32[$1 + 12 >> 2];
     $5 = HEAP32[$1 + 16 >> 2];
     $3 = $4;
     label$16: {
      if (HEAPU8[$5 + 32 | 0]) {
       break label$16;
      }
      $7 = HEAP32[$4 + 24 >> 2];
      $10 = $7;
      $11 = HEAP32[$5 + 24 >> 2];
      $7 = HEAP32[$5 + 28 >> 2];
      $13 = $7;
      $3 = $10;
      $6 = $11;
      $9 = HEAP32[$4 + 28 >> 2];
      $8 = ($3 | 0) != ($6 | 0) | ($13 | 0) != ($9 | 0) ? -1 : 0;
      $3 = $9;
      $6 = $10;
      $7 = $13;
      $7 = Math_imul($11 >>> 0 < $6 >>> 0 & ($7 | 0) <= ($3 | 0) | ($3 | 0) > ($7 | 0) ? 1 : $8, $14);
      $6 = HEAPU8[$4 + 32 | 0];
      if (!$6) {
       $3 = $4;
       if (($7 | 0) < 0) {
        break label$16;
       }
      }
      $3 = $5;
      if ($6) {
       break label$16;
      }
      $3 = $5;
      if (($7 | 0) > 0) {
       break label$16;
      }
      fts3EvalNextRow($0, $4, $2);
      $3 = $5;
     }
     $8 = $3;
     fts3EvalNextRow($0, $8, $2);
     $12 = HEAPU8[$4 + 32 | 0] ? HEAPU8[$5 + 32 | 0] != 0 : $12;
     HEAP8[$1 + 32 | 0] = $12;
     $6 = HEAP32[$4 + 24 >> 2];
     $10 = $6;
     $3 = HEAP32[$4 + 28 >> 2];
     $9 = $3;
     label$19: {
      if (!HEAPU8[$5 + 32 | 0]) {
       $7 = $10;
       $3 = HEAP32[$5 + 24 >> 2];
       $11 = $3;
       $3 = $9;
       $6 = HEAP32[$5 + 28 >> 2];
       $13 = $6;
       $0 = ($7 | 0) != ($11 | 0) | ($3 | 0) != ($6 | 0) ? -1 : 0;
       $3 = $11;
       if (HEAPU8[$4 + 32 | 0] | (Math_imul(($6 | 0) <= ($9 | 0) & $7 >>> 0 > $3 >>> 0 | ($6 | 0) < ($9 | 0) ? 1 : $0, $14) | 0) >= 0) {
        break label$19;
       }
      }
      HEAP32[$1 + 24 >> 2] = $10;
      HEAP32[$1 + 28 >> 2] = $9;
      return;
     }
     HEAP32[$1 + 24 >> 2] = $11;
     $7 = $13;
     HEAP32[$1 + 28 >> 2] = $7;
     return;

    case 1:
     break label$3;

    default:
     break label$1;
    }
   }
   $5 = HEAP32[$1 + 12 >> 2];
   $4 = HEAP32[$1 + 16 >> 2];
   if (!HEAPU8[$4 + 33 | 0]) {
    fts3EvalNextRow($0, $4, $2);
   }
   fts3EvalNextRow($0, $5, $2);
   $12 = HEAPU8[$5 + 32 | 0];
   if (!$12) {
    $8 = $8 & 255;
    while (1) {
     label$24: {
      if (HEAP32[$2 >> 2] | HEAPU8[$4 + 32 | 0]) {
       break label$24;
      }
      $7 = HEAP32[$5 + 24 >> 2];
      $10 = $7;
      $11 = HEAP32[$4 + 24 >> 2];
      $7 = HEAP32[$4 + 28 >> 2];
      $13 = $7;
      $3 = $10;
      $6 = $11;
      $9 = HEAP32[$5 + 28 >> 2];
      $10 = $3 >>> 0 < $6 >>> 0 & ($13 | 0) >= ($9 | 0) | ($9 | 0) < ($13 | 0);
      $6 = $3;
      $3 = $9;
      $7 = $13;
      if ((($8 ? $10 : $11 >>> 0 < $6 >>> 0 & ($3 | 0) >= ($7 | 0) | ($3 | 0) > ($7 | 0)) | 0) != 1) {
       break label$24;
      }
      fts3EvalNextRow($0, $4, $2);
      continue;
     }
     break;
    }
    $12 = HEAPU8[$5 + 32 | 0];
   }
   $6 = HEAP32[$5 + 24 >> 2];
   $10 = $6;
   $3 = HEAP32[$5 + 28 >> 2];
   HEAP8[$1 + 32 | 0] = $12;
   HEAP32[$1 + 24 >> 2] = $10;
   HEAP32[$1 + 28 >> 2] = $3;
  }
  return;
 }
 $4 = HEAP32[$1 + 20 >> 2];
 fts3EvalInvalidatePoslist($4);
 HEAP32[$2 >> 2] = fts3EvalPhraseNext($0, $4, $1 + 32 | 0);
 $6 = HEAP32[$4 + 20 >> 2];
 $3 = HEAP32[$4 + 16 >> 2];
 HEAP32[$1 + 24 >> 2] = $3;
 HEAP32[$1 + 28 >> 2] = $6;
}

function sqlite3BtreeInsert($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 56 >> 2] = $3;
 HEAP32[$5 + 52 >> 2] = 0;
 $6 = HEAP32[$0 + 8 >> 2];
 $9 = HEAP32[$6 + 4 >> 2];
 label$1: {
  label$2: {
   if (!(HEAPU8[$0 + 1 | 0] & 32)) {
    break label$2;
   }
   $4 = saveAllCursors($9, HEAP32[$0 + 64 >> 2], $0);
   if ($4) {
    break label$1;
   }
   if (!$3 | HEAP8[$0 + 68 | 0] >= 0) {
    break label$2;
   }
   $4 = sqlite3CorruptError(75895);
   break label$1;
  }
  if (HEAPU8[$0 | 0] >= 3) {
   $4 = moveToRoot($0);
   if ($4 & -17) {
    break label$1;
   }
  }
  label$4: {
   $4 = HEAP32[$0 + 112 >> 2];
   if (!$4) {
    if (HEAPU8[$6 + 11 | 0]) {
     invalidateIncrblobCursors($6, HEAP32[$0 + 64 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], 0);
    }
    label$7: {
     if (!(HEAPU8[$0 + 1 | 0] & 2)) {
      break label$7;
     }
     $6 = HEAP32[$0 + 32 >> 2];
     if (($6 | 0) != HEAP32[$1 + 8 >> 2] | HEAP32[$0 + 36 >> 2] != HEAP32[$1 + 12 >> 2]) {
      break label$7;
     }
     if (!HEAPU16[$0 + 50 >> 1] | HEAP32[$0 + 44 >> 2] != (HEAP32[$1 + 32 >> 2] + HEAP32[$1 + 28 >> 2] | 0)) {
      break label$4;
     }
     $4 = btreeOverwriteCell($0, $1);
     break label$1;
    }
    if ($3) {
     break label$4;
    }
    $4 = sqlite3BtreeTableMoveto($0, HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], $2 >>> 3 & 1, $5 + 56 | 0);
    if ($4) {
     break label$1;
    }
    break label$4;
   }
   if (!($2 & 2 | $3)) {
    $3 = HEAPU16[$1 + 24 >> 1];
    label$9: {
     if ($3) {
      HEAP32[$5 + 8 >> 2] = $4;
      $4 = HEAP32[$1 + 20 >> 2];
      HEAP8[$5 + 34 | 0] = 0;
      HEAP8[$5 + 30 | 0] = 0;
      HEAP16[$5 + 28 >> 1] = $3;
      HEAP32[$5 + 12 >> 2] = $4;
      $4 = sqlite3BtreeIndexMoveto($0, $5 + 8 | 0, $5 + 56 | 0);
      break label$9;
     }
     $4 = btreeMoveto($0, HEAP32[$1 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2], $2 >>> 3 & 1, $5 + 56 | 0);
    }
    HEAP32[$5 + 60 >> 2] = $4;
    if ($4) {
     break label$1;
    }
    $3 = HEAP32[$5 + 56 >> 2];
   }
   if ($3) {
    break label$4;
   }
   getCellInfo($0);
   $6 = HEAP32[$0 + 32 >> 2];
   $3 = HEAP32[$0 + 36 >> 2];
   if (($6 | 0) != HEAP32[$1 + 8 >> 2] | ($3 | 0) != HEAP32[$1 + 12 >> 2]) {
    break label$4;
   }
   $4 = HEAP32[$1 >> 2];
   HEAP32[$5 + 40 >> 2] = 0;
   HEAP32[$5 + 36 >> 2] = $6;
   HEAP32[$5 + 24 >> 2] = $4;
   $4 = btreeOverwriteCell($0, $5 + 8 | 0);
   break label$1;
  }
  $3 = HEAP32[$0 + 116 >> 2];
  if (HEAP32[$3 + 20 >> 2] < 0) {
   label$12: {
    if (HEAPU8[$0 | 0] >= 2) {
     $4 = sqlite3CorruptError(76018);
     break label$12;
    }
    $4 = btreeComputeFreeSpace($3);
   }
   if ($4) {
    break label$1;
   }
  }
  $6 = HEAP32[$9 + 84 >> 2];
  label$14: {
   label$15: {
    if ($2 & 128) {
     HEAP32[$5 + 60 >> 2] = 0;
     $4 = HEAP32[$9 + 88 >> 2];
     $7 = ($4 | 0) > 4 ? $4 : 4;
     HEAP32[$5 + 52 >> 2] = $7;
     if (!HEAPU8[$9 + 17 | 0] | HEAPU16[$3 + 14 >> 1] >= $7 >>> 0) {
      break label$14;
     }
     FUNCTION_TABLE[HEAP32[$3 + 80 >> 2]]($3, $6, $5 + 8 | 0);
     $4 = 0;
     if (HEAP32[$5 + 20 >> 2] == HEAPU16[$5 + 24 >> 1]) {
      break label$15;
     }
     ptrmapPut($9, sqlite3Get4byte(($6 + $7 | 0) - 4 | 0), 3, HEAP32[$3 + 4 >> 2], $5 + 60 | 0);
     $4 = HEAP32[$5 + 60 >> 2];
     break label$15;
    }
    $4 = fillInCell($3, $6, $1, $5 + 52 | 0);
    HEAP32[$5 + 60 >> 2] = $4;
   }
   if ($4) {
    break label$1;
   }
  }
  $7 = HEAPU16[$0 + 70 >> 1];
  $4 = HEAP32[$5 + 56 >> 2];
  label$17: {
   if (!$4) {
    if (HEAPU16[$3 + 24 >> 1] <= $7 >>> 0) {
     $4 = sqlite3CorruptError(76054);
     break label$1;
    }
    $4 = sqlite3PagerWrite(HEAP32[$3 + 72 >> 2]);
    if ($4) {
     break label$1;
    }
    $4 = HEAP32[$3 + 64 >> 2] + ($7 << 1) | 0;
    $4 = HEAP32[$3 + 56 >> 2] + (HEAPU16[$3 + 26 >> 1] & (HEAPU8[$4 | 0] << 8 | HEAPU8[$4 + 1 | 0])) | 0;
    if (!HEAPU8[$3 + 8 | 0]) {
     $10 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8 | (HEAPU8[$4 + 2 | 0] << 16 | HEAPU8[$4 + 3 | 0] << 24);
     HEAP8[$6 | 0] = $10;
     HEAP8[$6 + 1 | 0] = $10 >>> 8;
     HEAP8[$6 + 2 | 0] = $10 >>> 16;
     HEAP8[$6 + 3 | 0] = $10 >>> 24;
    }
    FUNCTION_TABLE[HEAP32[$3 + 80 >> 2]]($3, $4, $5 + 8 | 0);
    if (HEAP32[$5 + 20 >> 2] != HEAPU16[$5 + 24 >> 1]) {
     $8 = clearCellOverflow($3, $4, $5 + 8 | 0);
    }
    HEAP32[$5 + 60 >> 2] = $8;
    HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 251;
    $8 = HEAPU16[$5 + 26 >> 1];
    if (!(($8 | 0) != HEAP32[$5 + 52 >> 2] | HEAP32[$5 + 20 >> 2] != HEAPU16[$5 + 24 >> 1] | (HEAPU16[$3 + 16 >> 1] <= $8 >>> 0 ? HEAPU8[$9 + 17 | 0] : 0))) {
     if ((HEAP32[$3 + 56 >> 2] + HEAPU8[$3 + 9 | 0] | 0) + 10 >>> 0 > $4 >>> 0) {
      $4 = sqlite3CorruptError(76081);
      break label$1;
     }
     if (HEAPU32[$3 + 60 >> 2] < $4 + $8 >>> 0) {
      $4 = sqlite3CorruptError(76084);
      break label$1;
     }
     __memcpy($4, $6, $8);
     $4 = 0;
     break label$1;
    }
    dropCell($3, $7, $8, $5 + 60 | 0);
    $4 = HEAP32[$5 + 60 >> 2];
    if (!$4) {
     break label$17;
    }
    break label$1;
   }
   if (!HEAPU16[$3 + 24 >> 1] | ($4 | 0) >= 0) {
    break label$17;
   }
   $4 = $7 + 1 | 0;
   HEAP16[$0 + 70 >> 1] = $4;
   HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 253;
   $7 = $4 & 65535;
  }
  insertCell($3, $7, $6, HEAP32[$5 + 52 >> 2], 0, 0, $5 + 60 | 0);
  HEAP16[$0 + 50 >> 1] = 0;
  if (!HEAPU8[$3 + 12 | 0]) {
   $4 = HEAP32[$5 + 60 >> 2];
   break label$1;
  }
  HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 253;
  $4 = balance($0);
  HEAP8[HEAP32[$0 + 116 >> 2] + 12 | 0] = 0;
  HEAP8[$0 | 0] = 1;
  if (!($2 & 2) | $4) {
   break label$1;
  }
  btreeReleaseAllCursorPages($0);
  $4 = 0;
  label$27: {
   if (!HEAP32[$0 + 112 >> 2]) {
    break label$27;
   }
   $6 = HEAP32[$1 + 8 >> 2];
   $3 = sqlite3Malloc($6, HEAP32[$1 + 12 >> 2]);
   HEAP32[$0 + 16 >> 2] = $3;
   if (!$3) {
    $4 = 7;
    HEAP32[$5 + 60 >> 2] = 7;
    break label$27;
   }
   __memcpy($3, HEAP32[$1 >> 2], HEAP32[$1 + 8 >> 2]);
  }
  HEAP8[$0 | 0] = 3;
  $6 = HEAP32[$1 + 12 >> 2];
  HEAP32[$0 + 56 >> 2] = HEAP32[$1 + 8 >> 2];
  HEAP32[$0 + 60 >> 2] = $6;
 }
 __stack_pointer = $5 - -64 | 0;
 return $4;
}

function sqlite3Fts3Incrmerge($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 $15 = sqlite3_malloc(640);
 label$1: {
  if (!$15) {
   $4 = 7;
   break label$1;
  }
  $20 = ($2 | 0) > 2 ? $2 : 2;
  $12 = $15 + 584 | 0;
  $21 = $15 + 568 | 0;
  $4 = fts3IncrmergeHintLoad($0, $3 + 24 | 0);
  label$3: {
   while (1) {
    if (($1 | 0) <= 0 | $4) {
     break label$3;
    }
    $9 = HEAP32[$0 + 256 >> 2];
    HEAP32[$3 + 20 >> 2] = 0;
    HEAP32[$3 + 16 >> 2] = 0;
    fts3SqlStmt($0, 28, $3 + 20 | 0, 0);
    $4 = HEAP32[$3 + 20 >> 2];
    sqlite3_bind_int($4, 1, $20);
    $13 = $9 << 10;
    $9 = -1;
    $16 = $13;
    $5 = $13;
    $6 = $5 >> 31;
    $17 = $6;
    if ((sqlite3_step($4) | 0) == 100) {
     $6 = sqlite3_column_int64($4, 0);
     $11 = $6;
     $5 = i64toi32_i32$HIGH_BITS;
     $7 = $5;
     $9 = sqlite3_column_int($4, 1);
    }
    HEAP32[$3 + 40 >> 2] = $9;
    $4 = sqlite3_reset($4);
    HEAP32[$3 + 44 >> 2] = $4;
    $13 = 0;
    label$6: {
     if ($4) {
      break label$6;
     }
     $8 = HEAP32[$3 + 28 >> 2];
     if (!$8) {
      break label$6;
     }
     HEAP32[$3 + 8 >> 2] = 0;
     HEAP32[$3 + 12 >> 2] = 0;
     HEAP32[$3 + 4 >> 2] = 0;
     $4 = fts3IncrmergeHintPop($3 + 24 | 0, $3 + 8 | 0, $3 + 4 | 0);
     HEAP32[$3 + 44 >> 2] = $4;
     label$7: {
      label$8: {
       if (($9 | 0) < 0) {
        $5 = HEAP32[$3 + 8 >> 2];
        $14 = $5;
        $6 = HEAP32[$3 + 12 >> 2];
        $18 = $6;
        break label$8;
       }
       $5 = $17;
       $5 = __wasm_i64_srem($11, $7, $16, $5);
       $6 = i64toi32_i32$HIGH_BITS;
       $22 = $6;
       $10 = $5;
       $6 = HEAP32[$3 + 8 >> 2];
       $14 = $6;
       $5 = HEAP32[$3 + 12 >> 2];
       $18 = $5;
       $6 = $17;
       $6 = __wasm_i64_srem($14, $5, $16, $6);
       $10 = $10 >>> 0 < $6 >>> 0;
       $5 = i64toi32_i32$HIGH_BITS;
       $6 = $5;
       $5 = $22;
       if ($10 & ($6 | 0) >= ($5 | 0) | ($5 | 0) < ($6 | 0)) {
        break label$7;
       }
      }
      $9 = ($2 | 0) < ($9 | 0) ? $9 : $2;
      $13 = HEAP32[$3 + 4 >> 2];
      $9 = ($9 | 0) < ($13 | 0) ? $9 : $13;
      HEAP32[$3 + 40 >> 2] = $9;
      $19 = 1;
      $13 = 1;
      $11 = $14;
      $10 = $18;
      $7 = $10;
      break label$6;
     }
     HEAP32[$3 + 28 >> 2] = $8;
    }
    if (($9 | 0) <= 0) {
     break label$3;
    }
    $6 = 0;
    $5 = ($16 | 0) >= ($7 | 0) & $6 >>> 0 >= $11 >>> 0 | ($7 | 0) < ($16 | 0);
    if (!($5 & (($7 | 0) > 0 | ($7 | 0) >= 0))) {
     $4 = 267;
     HEAP32[$3 + 44 >> 2] = 267;
     break label$3;
    }
    $8 = memset($15, 0, 640);
    HEAP32[$8 + 580 >> 2] = 1;
    label$11: {
     label$12: {
      if ($4) {
       break label$12;
      }
      $4 = fts3IncrmergeOutputIdx($0, $11, $7, $3 + 16 | 0);
      HEAP32[$3 + 44 >> 2] = $4;
      $10 = HEAP32[$3 + 16 >> 2];
      label$13: {
       if (!$13 | ($10 | 0) != 1 ? $10 : 0) {
        break label$13;
       }
       HEAP32[$3 + 8 >> 2] = 0;
       $5 = $11 + 1 | 0;
       $6 = $5 ? $7 : $7 + 1 | 0;
       $4 = fts3SegmentIsMaxLevel($0, $5, $6, $3 + 8 | 0);
       HEAP32[$3 + 44 >> 2] = $4;
       if (!HEAP32[$3 + 8 >> 2]) {
        break label$13;
       }
       HEAP32[$8 + 580 >> 2] = HEAP32[$8 + 580 >> 2] | 2;
      }
      if ($4) {
       break label$12;
      }
      $4 = fts3IncrmergeCsr($0, $11, $7, $9, $12);
      HEAP32[$3 + 44 >> 2] = $4;
      if (HEAP32[$8 + 588 >> 2] != ($9 | 0) | $4) {
       break label$12;
      }
      $4 = sqlite3Fts3SegReaderStart($0, $12, $21);
      HEAP32[$3 + 44 >> 2] = $4;
      if ($4) {
       break label$12;
      }
      $4 = sqlite3Fts3SegReaderStep($0, $12);
      if ($4 ? ($4 | 0) != 100 : 0) {
       break label$11;
      }
      label$14: {
       if (!(!$13 | ($10 | 0) <= 0)) {
        $9 = fts3IncrmergeLoad($0, $11, $7, $10 - 1 | 0, HEAP32[$8 + 624 >> 2], HEAP32[$8 + 628 >> 2], $8);
        break label$14;
       }
       $9 = fts3IncrmergeWriter($0, $11, $7, $10, $12, $8);
      }
      HEAP32[$3 + 44 >> 2] = $9;
      label$16: {
       label$17: {
        if (!HEAP32[$8 >> 2] | $9) {
         break label$17;
        }
        label$18: {
         if ($4) {
          while (1) {
           $4 = fts3IncrmergeAppend($0, $8, $12);
           if (!$4) {
            $4 = sqlite3Fts3SegReaderStep($0, $12);
           }
           $9 = HEAP32[$8 + 4 >> 2];
           if (($4 | 0) == 100 & ($9 | 0) >= ($1 | 0)) {
            break label$18;
           }
           if (($4 | 0) == 100) {
            continue;
           }
           break;
          }
          HEAP32[$3 + 44 >> 2] = $4;
          if ($4) {
           break label$17;
          }
         }
         $9 = HEAP32[$8 + 4 >> 2];
        }
        HEAP32[$3 + 44 >> 2] = fts3IncrmergeChomp($0, $11, $7, $12, $3 + 40 | 0);
        $1 = ($9 ^ -1) + $1 | 0;
        $4 = HEAP32[$3 + 40 >> 2];
        $5 = 1;
        if (!$4) {
         break label$16;
        }
        fts3IncrmergeHintPush($3 + 24 | 0, $11, $7, $4, $3 + 44 | 0);
        $19 = 1;
       }
       $14 = HEAP32[$8 + 44 >> 2];
       $6 = HEAP32[$8 + 40 >> 2];
       $5 = $6;
       $10 = 0 - $5 | 0;
       HEAP32[$8 + 40 >> 2] = $10;
       $6 = $14;
       $5 = $6 + (($5 | 0) != 0) | 0;
       $5 = 0 - $5 | 0;
       HEAP32[$8 + 44 >> 2] = $5;
       $5 = 0;
      }
      fts3IncrmergeRelease($0, $8, $3 + 44 | 0);
      $4 = $5;
      if (HEAPU8[$8 + 48 | 0] | !$4) {
       break label$12;
      }
      $6 = $11 + 1 | 0;
      $10 = $6 ? $7 : $7 + 1 | 0;
      $5 = $10;
      $10 = HEAP32[$8 + 40 >> 2];
      $14 = $10;
      $10 = HEAP32[$8 + 44 >> 2];
      fts3PromoteSegments($0, $6, $5, $14, $10);
     }
     sqlite3Fts3SegReaderFinish($12);
     $4 = HEAP32[$3 + 44 >> 2];
     continue;
    }
    break;
   }
   sqlite3Fts3SegReaderFinish($12);
  }
  if (!(!$19 | $4)) {
   $4 = fts3IncrmergeHintStore($0, $3 + 24 | 0);
  }
  sqlite3_free($15);
  sqlite3_free(HEAP32[$3 + 24 >> 2]);
 }
 __stack_pointer = $3 + 48 | 0;
 return $4;
}

function attachFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 $4 = sqlite3_context_db_handle($0);
 HEAP32[$5 + 60 >> 2] = 0;
 HEAP32[$5 + 56 >> 2] = 0;
 HEAP32[$5 + 48 >> 2] = 0;
 $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $8 = $3 ? $3 : 29623;
 $2 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      if (HEAPU8[$4 + 178 | 0] & 4) {
       $2 = sqlite3_vfs_find(17561);
       HEAP32[$5 + 44 >> 2] = $2;
       if (!$2) {
        break label$1;
       }
       $1 = HEAP32[$4 + 16 >> 2];
       $9 = HEAPU8[$4 + 176 | 0] << 4;
       $3 = $1 + $9 | 0;
       $6 = $3 + 4 | 0;
       $7 = HEAP32[$3 + 4 >> 2];
       if ($7) {
        sqlite3BtreeClose($7);
       }
       $7 = 0;
       HEAP32[$6 >> 2] = 0;
       HEAP32[($1 + $9 | 0) + 12 >> 2] = 0;
       $2 = sqlite3BtreeOpen($2, 49596, $4, $6, 0, 256);
       break label$5;
      }
      label$8: {
       $1 = HEAP32[$4 + 20 >> 2];
       $3 = HEAP32[$4 + 148 >> 2];
       label$9: {
        if (($1 | 0) < ($3 + 2 | 0)) {
         $6 = $2 ? $2 : 29623;
         $2 = 0;
         $7 = ($1 | 0) > 0 ? $1 : 0;
         while (1) {
          if (($2 | 0) == ($7 | 0)) {
           break label$8;
          }
          $3 = sqlite3DbIsNamed($4, $2, $6);
          $2 = $2 + 1 | 0;
          if (!$3) {
           continue;
          }
          break;
         }
         HEAP32[$5 + 16 >> 2] = $6;
         $3 = sqlite3MPrintf($4, 12798, $5 + 16 | 0);
         break label$9;
        }
        HEAP32[$5 + 32 >> 2] = $3;
        $3 = sqlite3MPrintf($4, 16348, $5 + 32 | 0);
       }
       HEAP32[$5 + 48 >> 2] = $3;
       $2 = 0;
       break label$4;
      }
      $2 = HEAP32[$4 + 16 >> 2];
      label$12: {
       if (($2 | 0) == ($4 + 456 | 0)) {
        $2 = sqlite3DbMallocRawNN($4, 48, 0);
        if (!$2) {
         break label$1;
        }
        $3 = HEAP32[$4 + 16 >> 2];
        $7 = HEAP32[$3 >> 2];
        $1 = HEAP32[$3 + 4 >> 2];
        HEAP32[$2 >> 2] = $7;
        HEAP32[$2 + 4 >> 2] = $1;
        $7 = HEAP32[$3 + 28 >> 2];
        $1 = HEAP32[$3 + 24 >> 2];
        HEAP32[$2 + 24 >> 2] = $1;
        HEAP32[$2 + 28 >> 2] = $7;
        $1 = HEAP32[$3 + 20 >> 2];
        $7 = HEAP32[$3 + 16 >> 2];
        HEAP32[$2 + 16 >> 2] = $7;
        HEAP32[$2 + 20 >> 2] = $1;
        $7 = HEAP32[$3 + 12 >> 2];
        $1 = HEAP32[$3 + 8 >> 2];
        HEAP32[$2 + 8 >> 2] = $1;
        HEAP32[$2 + 12 >> 2] = $7;
        break label$12;
       }
       $2 = sqlite3DbRealloc($4, $2, ($1 << 4) + 16 | 0, 0);
       if (!$2) {
        break label$1;
       }
      }
      HEAP32[$4 + 16 >> 2] = $2;
      $3 = (HEAP32[$4 + 20 >> 2] << 4) + $2 | 0;
      HEAP32[$3 >> 2] = 0;
      HEAP32[$3 + 4 >> 2] = 0;
      HEAP32[$3 + 8 >> 2] = 0;
      HEAP32[$3 + 12 >> 2] = 0;
      HEAP32[$5 + 52 >> 2] = HEAP32[$4 + 60 >> 2];
      $2 = sqlite3ParseUri(HEAP32[HEAP32[$4 >> 2] + 16 >> 2], $8, $5 + 52 | 0, $5 + 44 | 0, $5 + 60 | 0, $5 + 56 | 0);
      if ($2) {
       if (($2 | 0) == 7) {
        sqlite3OomFault($4);
       }
       $2 = HEAP32[$5 + 56 >> 2];
       sqlite3_result_error($0, $2, -1);
       sqlite3_free($2);
       break label$1;
      }
      $2 = HEAP32[$5 + 52 >> 2] | 256;
      HEAP32[$5 + 52 >> 2] = $2;
      $7 = HEAP32[$5 + 60 >> 2];
      $2 = sqlite3BtreeOpen(HEAP32[$5 + 44 >> 2], $7, $4, $3 + 4 | 0, 0, $2);
      HEAP32[$4 + 20 >> 2] = HEAP32[$4 + 20 >> 2] + 1;
      HEAP32[$3 >> 2] = sqlite3DbStrDup($4, $6);
     }
     $6 = 0;
     HEAP8[$4 + 95 | 0] = 0;
     label$16: {
      if ($2) {
       if (($2 | 0) == 19) {
        HEAP32[$5 + 48 >> 2] = sqlite3MPrintf($4, 15720, 0);
        $2 = 1;
       }
       HEAP8[$3 + 8 | 0] = 3;
       break label$16;
      }
      $1 = sqlite3SchemaGet($4, HEAP32[$3 + 4 >> 2]);
      HEAP32[$3 + 12 >> 2] = $1;
      $2 = 7;
      label$19: {
       if (!$1) {
        break label$19;
       }
       $6 = 1;
       $2 = 0;
       if (!HEAPU8[$1 + 76 | 0] | HEAPU8[$1 + 77 | 0] == HEAPU8[$4 + 84 | 0]) {
        break label$19;
       }
       $6 = 0;
       HEAP32[$5 + 48 >> 2] = sqlite3MPrintf($4, 12919, 0);
       $2 = 1;
      }
      sqlite3BtreeEnter(HEAP32[$3 + 4 >> 2]);
      sqlite3PagerLockingMode(sqlite3BtreePager(HEAP32[$3 + 4 >> 2]), HEAPU8[$4 + 89 | 0]);
      sqlite3BtreeSecureDelete(HEAP32[$3 + 4 >> 2], sqlite3BtreeSecureDelete(HEAP32[HEAP32[$4 + 16 >> 2] + 4 >> 2], -1));
      sqlite3BtreeSetPagerFlags(HEAP32[$3 + 4 >> 2], HEAP32[$4 + 32 >> 2] & 56 | 3);
      HEAP8[$3 + 8 | 0] = 3;
      if (!$6) {
       break label$16;
      }
      $2 = HEAP32[$3 >> 2] ? 0 : 7;
     }
     sqlite3_free_filename($7);
     if (!$2) {
      sqlite3BtreeEnterAll($4);
      HEAP8[$4 + 176 | 0] = 0;
      HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] & -17;
      if (HEAPU8[$4 + 178 | 0] & 4) {
       break label$1;
      }
      $2 = sqlite3Init($4, $5 + 48 | 0);
      if (!$2) {
       break label$1;
      }
     }
     if (!(HEAPU8[$4 + 178 | 0] & 4)) {
      $3 = HEAP32[$4 + 20 >> 2] - 1 | 0;
      $6 = HEAP32[(HEAP32[$4 + 16 >> 2] + ($3 << 4) | 0) + 4 >> 2];
      if ($6) {
       sqlite3BtreeClose($6);
       $6 = HEAP32[$4 + 16 >> 2] + ($3 << 4) | 0;
       HEAP32[$6 + 12 >> 2] = 0;
       HEAP32[$6 + 4 >> 2] = 0;
      }
      sqlite3ResetAllSchemasOfConnection($4);
      HEAP32[$4 + 20 >> 2] = $3;
      if (!(($2 | 0) != 3082 & ($2 | 0) != 7)) {
       sqlite3OomFault($4);
       sqlite3DbFree($4, HEAP32[$5 + 48 >> 2]);
       $3 = sqlite3MPrintf($4, 1141, 0);
       HEAP32[$5 + 48 >> 2] = $3;
       break label$4;
      }
      $3 = HEAP32[$5 + 48 >> 2];
      if ($3) {
       break label$3;
      }
      HEAP32[$5 >> 2] = $8;
      $3 = sqlite3MPrintf($4, 7652, $5);
      HEAP32[$5 + 48 >> 2] = $3;
      break label$4;
     }
     $3 = HEAP32[$5 + 48 >> 2];
    }
    if (!$3) {
     break label$2;
    }
   }
   sqlite3_result_error($0, $3, -1);
   sqlite3DbFree($4, HEAP32[$5 + 48 >> 2]);
  }
  if (!$2) {
   break label$1;
  }
  sqlite3_result_error_code($0, $2);
 }
 __stack_pointer = $5 - -64 | 0;
}

function exprAnalyzeOrTerm($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $17 = HEAP32[$1 + 24 >> 2];
 $3 = $17 + Math_imul($2, 48) | 0;
 $21 = HEAP32[$3 >> 2];
 $18 = HEAP32[$1 >> 2];
 $20 = HEAP32[$18 >> 2];
 $13 = HEAP32[$20 >> 2];
 $6 = sqlite3DbMallocZero($13, 424, 0);
 HEAP32[$3 + 24 >> 2] = $6;
 label$1: {
  if (!$6) {
   break label$1;
  }
  HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 16;
  memset($6 + 32 | 0, 0, 384);
  sqlite3WhereClauseInit($6, $18);
  sqlite3WhereSplit($6, $21, 43);
  sqlite3WhereExprAnalyze($0, $6);
  if (HEAPU8[$13 + 87 | 0]) {
   break label$1;
  }
  $19 = $18 + 504 | 0;
  $5 = HEAP32[$6 + 24 >> 2];
  $9 = HEAP32[$6 + 12 >> 2];
  $14 = -1;
  $10 = -1;
  $15 = -1;
  $16 = -1;
  while (1) {
   if (!(!($14 | $10) | ($9 | 0) <= 0)) {
    $3 = HEAPU16[$5 + 12 >> 1];
    label$4: {
     if (!($3 & 511)) {
      $3 = sqlite3DbMallocRawNN($13, 416, 0);
      if (!$3) {
       $15 = 0;
       $16 = 0;
       break label$4;
      }
      HEAP32[$5 + 24 >> 2] = $3;
      HEAP32[$5 + 20 >> 2] = -1;
      HEAP16[$5 + 12 >> 1] = 1024;
      HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 10 >> 1] | 32;
      memset($3 + 32 | 0, 0, 384);
      sqlite3WhereClauseInit($3, HEAP32[$1 >> 2]);
      sqlite3WhereSplit($3, HEAP32[$5 >> 2], 44);
      sqlite3WhereExprAnalyze($0, $3);
      HEAP32[$3 + 4 >> 2] = $1;
      $15 = 0;
      $16 = 0;
      $11 = 0;
      $12 = 0;
      label$7: {
       if (HEAPU8[$13 + 87 | 0]) {
        break label$7;
       }
       $7 = 0;
       $8 = HEAP32[$3 + 12 >> 2];
       $8 = ($8 | 0) > 0 ? $8 : 0;
       $3 = HEAP32[$3 + 24 >> 2];
       while (1) {
        if (($7 | 0) == ($8 | 0)) {
         break label$7;
        }
        if (!(!allowedOp(HEAPU8[HEAP32[$3 >> 2]]) & HEAPU16[$3 + 12 >> 1] != 64)) {
         $4 = $11;
         $11 = sqlite3WhereGetMask($19, HEAP32[$3 + 20 >> 2]) | $4;
         $12 = i64toi32_i32$HIGH_BITS | $12;
        }
        $3 = $3 + 48 | 0;
        $7 = $7 + 1 | 0;
        continue;
       }
      }
      $4 = $14;
      $14 = $4 & $11;
      $10 = $12 & $10;
      break label$4;
     }
     $7 = HEAPU16[$5 + 10 >> 1];
     if ($7 & 8) {
      break label$4;
     }
     $11 = sqlite3WhereGetMask($19, HEAP32[$5 + 20 >> 2]);
     $12 = i64toi32_i32$HIGH_BITS;
     if ($7 & 2) {
      $4 = $11;
      $11 = sqlite3WhereGetMask($19, HEAP32[(HEAP32[$6 + 24 >> 2] + Math_imul(HEAP32[$5 + 16 >> 2], 48) | 0) + 20 >> 2]) | $4;
      $12 = i64toi32_i32$HIGH_BITS | $12;
     }
     $4 = $15;
     $8 = $3 & 2;
     $4 = $8 ? $4 & $11 : 0;
     $15 = $4;
     $16 = $8 ? $12 & $16 : 0;
     $14 = $11 & $14;
     $4 = $10;
     $4 = $4 & $12;
     $10 = $4;
    }
    $9 = $9 - 1 | 0;
    $5 = $5 + 48 | 0;
    continue;
   }
   break;
  }
  HEAP32[$6 + 416 >> 2] = $14;
  $4 = $10;
  HEAP32[$6 + 420 >> 2] = $4;
  $10 = -1;
  $3 = Math_imul($2, 48) + $17 | 0;
  HEAP32[$3 + 20 >> 2] = -1;
  HEAP16[$3 + 12 >> 1] = 512;
  label$12: {
   if (!($14 | $4)) {
    break label$12;
   }
   HEAP8[$1 + 9 | 0] = 1;
   if (HEAP32[$6 + 12 >> 2] != 2) {
    break label$12;
   }
   $7 = HEAP32[$6 + 24 >> 2];
   $8 = 0;
   label$13: while (1) {
    $9 = whereNthSubterm($7, $8);
    if (!$9) {
     break label$12;
    }
    $8 = $8 + 1 | 0;
    $3 = 0;
    while (1) {
     $5 = whereNthSubterm($7 + 48 | 0, $3);
     if (!$5) {
      continue label$13;
     }
     whereCombineDisjuncts($0, $1, $9, $5);
     $3 = $3 + 1 | 0;
     $7 = HEAP32[$6 + 24 >> 2];
     continue;
    }
   }
  }
  $4 = $16;
  if (!($4 | $15)) {
   break label$1;
  }
  $9 = 0;
  while (1) {
   if (!($22 >>> 0 > 1 | $9)) {
    $7 = HEAP32[$6 + 12 >> 2];
    $3 = HEAP32[$6 + 24 >> 2];
    while (1) {
     if (($7 | 0) <= 0) {
      break label$1;
     }
     $7 = $7 - 1 | 0;
     HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] & 65471;
     label$18: {
      $5 = HEAP32[$3 + 20 >> 2];
      if (($10 | 0) != ($5 | 0)) {
       $4 = sqlite3WhereGetMask($19, $5);
       $11 = $4;
       $4 = $16;
       $8 = i64toi32_i32$HIGH_BITS;
       $4 = $4 & $8;
       $8 = $15 & $11;
       if ($4 | $8) {
        break label$18;
       }
      }
      $3 = $3 + 48 | 0;
      continue;
     }
     break;
    }
    $8 = HEAP32[$3 + 24 >> 2];
    $4 = HEAP32[HEAP32[$3 >> 2] + 12 >> 2];
    $9 = 1;
    while (1) {
     if (!(!$9 | ($7 | 0) < 0)) {
      label$22: {
       label$23: {
        if (HEAP32[$3 + 20 >> 2] != ($5 | 0)) {
         HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] & 65471;
         break label$23;
        }
        $9 = 0;
        if (HEAP32[$3 + 24 >> 2] != ($8 | 0)) {
         break label$22;
        }
        if (($8 | 0) == -2) {
         if (sqlite3ExprCompare($20, HEAP32[HEAP32[$3 >> 2] + 12 >> 2], $4, -1)) {
          break label$22;
         }
        }
        $10 = sqlite3ExprAffinity(HEAP32[HEAP32[$3 >> 2] + 16 >> 2]);
        $17 = sqlite3ExprAffinity(HEAP32[HEAP32[$3 >> 2] + 12 >> 2]);
        if (($17 | 0) != ($10 | 0) ? $10 : 0) {
         break label$22;
        }
        HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 64;
       }
       $9 = 1;
      }
      $3 = $3 + 48 | 0;
      $7 = $7 - 1 | 0;
      continue;
     }
     break;
    }
    $22 = $22 + 1 | 0;
    $10 = $5;
    continue;
   }
   break;
  }
  if (!$9) {
   break label$1;
  }
  $3 = HEAP32[$6 + 24 >> 2];
  $7 = HEAP32[$6 + 12 >> 2];
  $5 = 0;
  $6 = 0;
  while (1) {
   if (($7 | 0) > 0) {
    if (HEAPU8[$3 + 10 | 0] & 64) {
     $6 = sqlite3ExprDup($13, HEAP32[HEAP32[$3 >> 2] + 16 >> 2], 0);
     $5 = sqlite3ExprListAppend(HEAP32[$18 >> 2], $5, $6);
     $6 = HEAP32[HEAP32[$3 >> 2] + 12 >> 2];
    }
    $7 = $7 - 1 | 0;
    $3 = $3 + 48 | 0;
    continue;
   }
   break;
  }
  $3 = sqlite3PExpr($20, 49, sqlite3ExprDup($13, $6, 0), 0);
  if ($3) {
   transferJoinMarkings($3, $21);
   HEAP32[$3 + 20 >> 2] = $5;
   $3 = whereClauseInsert($1, $3, 3);
   exprAnalyze($0, $1, $3);
   markTermAsChild($1, $3, $2);
   return;
  }
  sqlite3ExprListDelete($13, $5);
 }
}

function sqlite3PagerOpen($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 HEAP32[$9 + 12 >> 2] = 4096;
 $16 = sqlite3JournalSize($0);
 HEAP32[$1 >> 2] = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $12 = $3 & 2;
      if ($12) {
       if (!$2) {
        $14 = 1;
        $15 = 1;
        break label$4;
       }
       if (!HEAPU8[$2 | 0]) {
        $15 = 1;
        $11 = $2;
        break label$4;
       }
       $7 = sqlite3DbStrDup(0, $2);
       if (!$7) {
        break label$5;
       }
       $14 = 1;
       $15 = 1;
       $8 = sqlite3Strlen30($7);
       break label$3;
      }
      $10 = 1;
      label$9: {
       if (!$2) {
        $14 = 1;
        break label$9;
       }
       if (!HEAPU8[$2 | 0]) {
        $11 = $2;
        break label$9;
       }
       $5 = HEAP32[$0 + 8 >> 2] + 1 | 0;
       $11 = $5 << 1;
       $7 = sqlite3DbMallocRaw(0, $11, $11 >> 31);
       if (!$7) {
        break label$5;
       }
       HEAP8[$7 | 0] = 0;
       $10 = $4 << 7 >> 31 & 1550;
       $6 = sqlite3OsFullPathname($0, $2, $5, $7);
       $8 = sqlite3Strlen30($7);
       $13 = (sqlite3Strlen30($2) + $2 | 0) + 1 | 0;
       $5 = $13;
       while (1) {
        if (HEAPU8[$5 | 0]) {
         $5 = (strlen($5) + $5 | 0) + 1 | 0;
         $5 = ($5 + strlen($5) | 0) + 1 | 0;
         continue;
        }
        break;
       }
       label$14: {
        label$15: {
         $6 = ($6 | 0) == 512 ? $10 : $6;
         if ($6) {
          break label$15;
         }
         $10 = ($5 - $13 | 0) + 1 | 0;
         if (HEAP32[$0 + 8 >> 2] >= ($8 + 8 | 0)) {
          break label$14;
         }
         $6 = sqlite3CantopenError(58663);
         if ($6) {
          break label$15;
         }
         break label$14;
        }
        sqlite3DbFree(0, $7);
        break label$1;
       }
       $11 = $2;
       break label$2;
      }
      break label$2;
     }
     $6 = 7;
     break label$1;
    }
    $8 = 0;
   }
   $10 = 1;
  }
  $6 = 7;
  $2 = $16 + 7 & -8;
  $5 = sqlite3MallocZero((((Math_imul($8, 3) + ($2 << 1) | 0) + $10 | 0) + (HEAP32[$0 + 4 >> 2] + 7 & -8) | 0) + 314 | 0, 0);
  if (!$5) {
   sqlite3DbFree(0, $7);
   break label$1;
  }
  $6 = $5 + 288 | 0;
  HEAP32[$5 + 64 >> 2] = $6;
  HEAP32[$5 + 228 >> 2] = $5 + 240;
  $6 = (HEAP32[$0 + 4 >> 2] + 7 & -8) + $6 | 0;
  HEAP32[$5 + 72 >> 2] = $6;
  $6 = $2 + $6 | 0;
  HEAP32[$5 + 68 >> 2] = $6;
  $2 = $2 + $6 | 0;
  HEAP8[$2 | 0] = $5;
  HEAP8[$2 + 1 | 0] = $5 >>> 8;
  HEAP8[$2 + 2 | 0] = $5 >>> 16;
  HEAP8[$2 + 3 | 0] = $5 >>> 24;
  $6 = $2 + 8 | 0;
  HEAP32[$5 + 184 >> 2] = $6;
  label$17: {
   label$18: {
    if (($8 | 0) > 0) {
     $2 = 1;
     $6 = (__memcpy($6, $7, $8) + $8 | 0) + 1 | 0;
     if ($13) {
      __memcpy($6, $13, $10);
      $2 = $10;
     }
     $2 = $2 + $6 | 0;
     HEAP32[$5 + 188 >> 2] = $2;
     $2 = __memcpy($2, $7, $8) + $8 | 0;
     HEAP8[$2 | 0] = 45;
     HEAP8[$2 + 1 | 0] = 106;
     HEAP8[$2 + 2 | 0] = 111;
     HEAP8[$2 + 3 | 0] = 117;
     HEAP8[$2 + 4 | 0] = 114;
     HEAP8[$2 + 5 | 0] = 110;
     HEAP8[$2 + 6 | 0] = 97;
     HEAP8[$2 + 7 | 0] = 108;
     $2 = $2 + 9 | 0;
     HEAP32[$5 + 236 >> 2] = $2;
     $2 = __memcpy($2, $7, $8) + $8 | 0;
     HEAP8[$2 | 0] = 45;
     HEAP8[$2 + 1 | 0] = 119;
     HEAP8[$2 + 2 | 0] = 97;
     HEAP8[$2 + 3 | 0] = 108;
     break label$18;
    }
    HEAP32[$5 + 236 >> 2] = 0;
    HEAP32[$5 + 188 >> 2] = 0;
    if (!$8) {
     break label$17;
    }
   }
   sqlite3DbFree(0, $7);
  }
  HEAP32[$5 + 152 >> 2] = $4;
  HEAP32[$5 >> 2] = $0;
  $8 = 0;
  label$21: {
   label$22: {
    label$23: {
     label$24: {
      if (!(!HEAPU8[$11 | 0] | $14)) {
       HEAP32[$9 + 8 >> 2] = 0;
       $6 = sqlite3OsOpen($0, HEAP32[$5 + 184 >> 2], HEAP32[$5 + 64 >> 2], $4, $9 + 8 | 0);
       $0 = HEAP32[$9 + 8 >> 2];
       $2 = $0 >>> 7 & 1;
       HEAP8[$5 + 16 | 0] = $2;
       if ($6) {
        break label$22;
       }
       $6 = sqlite3OsDeviceCharacteristics(HEAP32[$5 + 64 >> 2]);
       $7 = $0 & 1;
       label$26: {
        if ($7) {
         break label$26;
        }
        setSectorSize($5);
        $0 = HEAP32[$5 + 156 >> 2];
        if ($0 >>> 0 <= HEAPU32[$9 + 12 >> 2]) {
         break label$26;
        }
        if ($0 >>> 0 >= 8193) {
         HEAP32[$9 + 12 >> 2] = 8192;
         break label$26;
        }
        HEAP32[$9 + 12 >> 2] = $0;
       }
       HEAP8[$5 + 13 | 0] = sqlite3_uri_boolean(HEAP32[$5 + 184 >> 2], 11381, 0);
       label$28: {
        if ($6 & 8192) {
         break label$28;
        }
        if (sqlite3_uri_boolean(HEAP32[$5 + 184 >> 2], 13453, 0)) {
         break label$28;
        }
        $8 = 1;
        $0 = 0;
        break label$23;
       }
       $4 = 1;
       break label$24;
      }
      $2 = 0;
     }
     HEAP8[$5 + 13 | 0] = 1;
     HEAP8[$5 + 17 | 0] = 1;
     HEAP8[$5 + 18 | 0] = 4;
     $7 = $4 & 1;
     $0 = 1;
    }
    $6 = sqlite3PagerSetPagesize($5, $9 + 12 | 0, -1);
    if ($6) {
     break label$22;
    }
    $6 = sqlite3PcacheOpen(HEAP32[$9 + 12 >> 2], !($12 >>> 1 | 0), $12 ? 0 : 14, $5, HEAP32[$5 + 228 >> 2]);
    if (!$6) {
     break label$21;
    }
   }
   sqlite3OsClose(HEAP32[$5 + 64 >> 2]);
   sqlite3PageFree(HEAP32[$5 + 224 >> 2]);
   sqlite3_free($5);
   break label$1;
  }
  HEAP32[$5 + 160 >> 2] = 1073741823;
  HEAP8[$5 + 12 | 0] = $0;
  HEAP8[$5 + 19 | 0] = $0;
  HEAP8[$5 + 4 | 0] = $0;
  HEAP8[$5 + 15 | 0] = $15;
  HEAP8[$5 + 14 | 0] = $7;
  HEAP8[$5 + 7 | 0] = $0;
  $7 = $3 & 1;
  HEAP8[$5 + 6 | 0] = !$7;
  if ($8) {
   HEAP32[$5 + 8 >> 2] = 167903233;
  }
  HEAP32[$5 + 176 >> 2] = -1;
  HEAP32[$5 + 180 >> 2] = -1;
  HEAP16[$5 + 148 >> 1] = 88;
  setSectorSize($5);
  $0 = 2;
  label$30: {
   if (!$7) {
    $0 = 4;
    if (!($2 | $12)) {
     break label$30;
    }
   }
   HEAP8[$5 + 5 | 0] = $0;
  }
  HEAP32[$5 + 216 >> 2] = 15;
  setGetterMethod($5);
  HEAP32[$1 >> 2] = $5;
  $6 = 0;
 }
 __stack_pointer = $9 + 16 | 0;
 return $6;
}

function sqlite3_backup_step($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 sqlite3BtreeEnter(HEAP32[$0 + 24 >> 2]);
 $2 = HEAP32[$0 + 28 >> 2];
 if (!isFatalError($2)) {
  $2 = HEAP32[$0 + 24 >> 2];
  $15 = sqlite3BtreePager($2);
  $11 = sqlite3BtreePager(HEAP32[$0 + 4 >> 2]);
  label$4: {
   if (!(!HEAP32[$0 >> 2] | HEAPU8[HEAP32[$2 + 4 >> 2] + 20 | 0] != 2)) {
    $16 = 1;
    $2 = 5;
    break label$4;
   }
   if (sqlite3BtreeTxnState($2)) {
    $16 = 1;
    $2 = 0;
    break label$4;
   }
   $2 = sqlite3BtreeBeginTrans($2, 0, 0);
  }
  $3 = HEAP32[$0 + 12 >> 2];
  label$2: {
   label$3: {
    if (!($3 | $2)) {
     $2 = 7;
     if ((setDestPgsz($0) | 0) == 7) {
      break label$2;
     }
     $3 = HEAP32[$0 + 12 >> 2];
     break label$3;
    }
    if ($2) {
     break label$2;
    }
   }
   $2 = 0;
   if ($3) {
    break label$2;
   }
   $2 = sqlite3BtreeBeginTrans(HEAP32[$0 + 4 >> 2], 2, $0 + 8 | 0);
   if ($2) {
    break label$2;
   }
   HEAP32[$0 + 12 >> 2] = 1;
   $2 = 0;
  }
  $5 = HEAP32[$0 + 24 >> 2];
  $9 = sqlite3BtreeGetPageSize($5);
  $3 = HEAP32[$0 + 4 >> 2];
  $12 = sqlite3BtreeGetPageSize($3);
  $6 = sqlite3PagerGetJournalMode(sqlite3BtreePager($3));
  $3 = $2 ? $2 : ($6 | 0) == 5 ? (($9 | 0) != ($12 | 0)) << 3 : $2;
  $4 = sqlite3BtreeLastPage($5);
  $5 = 0;
  while (1) {
   label$9: {
    if (($1 | 0) <= ($5 | 0) & ($1 | 0) >= 0) {
     break label$9;
    }
    $2 = HEAP32[$0 + 16 >> 2];
    if ($4 >>> 0 < $2 >>> 0 | $3) {
     break label$9;
    }
    $3 = 0;
    if (((HEAPU32[16232] / HEAPU32[HEAP32[HEAP32[$0 + 24 >> 2] + 4 >> 2] + 36 >> 2] | 0) + 1 | 0) != ($2 | 0)) {
     $3 = sqlite3PagerGet($15, $2, $7 + 12 | 0, 2);
     if (!$3) {
      $3 = backupOnePage($0, $2, sqlite3PagerGetData(HEAP32[$7 + 12 >> 2]), 0);
      sqlite3PagerUnref(HEAP32[$7 + 12 >> 2]);
     }
     $2 = HEAP32[$0 + 16 >> 2];
    }
    HEAP32[$0 + 16 >> 2] = $2 + 1;
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  label$12: {
   label$13: {
    if (($3 | 0) == 101) {
     break label$13;
    }
    if ($3) {
     break label$12;
    }
    HEAP32[$0 + 36 >> 2] = $4;
    $2 = HEAP32[$0 + 16 >> 2];
    HEAP32[$0 + 32 >> 2] = ($4 - $2 | 0) + 1;
    if ($2 >>> 0 > $4 >>> 0) {
     break label$13;
    }
    $3 = 0;
    if (HEAP32[$0 + 40 >> 2]) {
     break label$12;
    }
    attachBackupObject($0);
    break label$12;
   }
   label$14: {
    if ($4) {
     break label$14;
    }
    $4 = 1;
    $3 = sqlite3BtreeNewDb(HEAP32[$0 + 4 >> 2]);
    if (($3 | 0) == 101) {
     break label$14;
    }
    if ($3) {
     break label$12;
    }
   }
   $3 = sqlite3BtreeUpdateMeta(HEAP32[$0 + 4 >> 2], 1, HEAP32[$0 + 8 >> 2] + 1 | 0);
   if ($3) {
    break label$12;
   }
   $2 = HEAP32[$0 >> 2];
   if ($2) {
    sqlite3ResetAllSchemasOfConnection($2);
   }
   if (($6 | 0) == 5) {
    $3 = sqlite3BtreeSetVersion(HEAP32[$0 + 4 >> 2], 2);
    if ($3) {
     break label$12;
    }
   }
   label$17: {
    if (($9 | 0) < ($12 | 0)) {
     $2 = HEAP32[16232];
     $3 = HEAP32[HEAP32[HEAP32[$0 + 4 >> 2] + 4 >> 2] + 36 >> 2];
     $1 = sqlite3PagerFile($11);
     sqlite3PagerPagecount($11, $7 + 12 | 0);
     $5 = ($12 | 0) / ($9 | 0) | 0;
     $5 = (($4 + $5 | 0) - 1 | 0) / ($5 | 0) | 0;
     $2 = $5 - (((($2 >>> 0) / ($3 >>> 0) | 0) + 1 | 0) == ($5 | 0)) | 0;
     $10 = $4;
     $8 = $4 >> 31;
     $6 = $8;
     $5 = HEAP32[$7 + 12 >> 2];
     $3 = 0;
     while (1) {
      if (!($2 >>> 0 > $5 >>> 0 | $3)) {
       $3 = 0;
       label$21: {
        if (((HEAPU32[16232] / HEAPU32[HEAP32[HEAP32[$0 + 4 >> 2] + 4 >> 2] + 36 >> 2] | 0) + 1 | 0) == ($2 | 0)) {
         break label$21;
        }
        $3 = sqlite3PagerGet($11, $2, $7 + 8 | 0, 0);
        if ($3) {
         break label$21;
        }
        $3 = sqlite3PagerWrite(HEAP32[$7 + 8 >> 2]);
        sqlite3PagerUnref(HEAP32[$7 + 8 >> 2]);
       }
       $2 = $2 + 1 | 0;
       continue;
      }
      break;
     }
     $4 = $9;
     $8 = $4 >> 31;
     $13 = $8;
     $9 = $4;
     $4 = $13;
     $4 = __wasm_i64_mul($10, $6, $9, $4);
     $17 = $4;
     $8 = i64toi32_i32$HIGH_BITS;
     $14 = $8;
     if (!$3) {
      $3 = sqlite3PagerCommitPhaseOne($11, 0, 1);
     }
     $2 = HEAP32[16232];
     $4 = $12 + $2 | 0;
     $8 = $4 >> 31;
     $10 = $4;
     $5 = $17;
     $6 = $8;
     $4 = $14;
     $8 = $5 >>> 0 < $10 >>> 0 & ($6 | 0) >= ($4 | 0) | ($4 | 0) < ($6 | 0);
     $4 = $8 ? $5 : $10;
     $18 = $4;
     $5 = $8 ? $14 : $6;
     $12 = $5;
     $4 = $2 + $9 | 0;
     $5 = $4 >> 31;
     $10 = $4;
     $6 = $5;
     while (1) {
      $4 = $12;
      if (!(($4 | 0) <= ($6 | 0) & $10 >>> 0 >= $18 >>> 0 | ($4 | 0) < ($6 | 0) | $3)) {
       HEAP32[$7 + 8 >> 2] = 0;
       $5 = $13;
       $5 = __wasm_i64_sdiv($10, $6, $9, $5);
       $3 = sqlite3PagerGet($15, $5 + 1 | 0, $7 + 8 | 0, 0);
       if (!$3) {
        $3 = sqlite3OsWrite($1, sqlite3PagerGetData(HEAP32[$7 + 8 >> 2]), $9, $10, $6);
       }
       sqlite3PagerUnref(HEAP32[$7 + 8 >> 2]);
       $5 = $13;
       $6 = $5 + $6 | 0;
       $4 = $9;
       $8 = $10 + $4 | 0;
       $6 = $8 >>> 0 < $4 >>> 0 ? $6 + 1 | 0 : $6;
       $10 = $8;
       continue;
      }
      break;
     }
     if ($3) {
      break label$17;
     }
     $6 = $14;
     $3 = backupTruncateFile($1, $17, $6);
     if ($3) {
      break label$17;
     }
     $3 = sqlite3PagerSync($11, 0);
     break label$17;
    }
    sqlite3PagerTruncateImage($11, Math_imul(($9 | 0) / ($12 | 0) | 0, $4));
    $3 = sqlite3PagerCommitPhaseOne($11, 0, 0);
   }
   if ($3) {
    break label$12;
   }
   $2 = sqlite3BtreeCommitPhaseTwo(HEAP32[$0 + 4 >> 2], 0);
   $3 = $2 ? $2 : 101;
  }
  if (!$16) {
   sqlite3BtreeCommitPhaseOne(HEAP32[$0 + 24 >> 2], 0);
   sqlite3BtreeCommitPhaseTwo(HEAP32[$0 + 24 >> 2], 0);
  }
  $2 = ($3 | 0) == 3082 ? 7 : $3;
  HEAP32[$0 + 28 >> 2] = $2;
 }
 __stack_pointer = $7 + 16 | 0;
 return $2;
}

function jsonReturn($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      switch (HEAPU8[$0 | 0] - 1 | 0) {
      default:
       sqlite3_result_null($1);
       break label$1;

      case 0:
       sqlite3_result_int($1, 1);
       break label$1;

      case 1:
       sqlite3_result_int($1, 0);
       break label$1;

      case 2:
       $2 = HEAP32[$0 + 8 >> 2];
       $7 = HEAPU8[$2 | 0];
       $0 = (($7 | 0) == 45) + $2 | 0;
       while (1) {
        $5 = HEAPU8[$0 | 0];
        if (($5 - 48 & 255) >>> 0 <= 9) {
         $0 = $0 + 1 | 0;
         label$12: {
          $4 = $6;
          if ($4 >>> 0 < 3435973836 & ($3 | 0) <= 214748364 | ($3 | 0) < 214748364) {
           break label$12;
          }
          $4 = $3;
          if (($6 | 0) != -858993460 | ($4 | 0) != 214748364 | (HEAPU8[$0 | 0] - 48 & 255) >>> 0 < 10) {
           break label$4;
          }
          label$13: {
           switch ($5 - 56 | 0) {
           case 0:
            break label$13;

           case 1:
            break label$4;

           default:
            break label$12;
           }
          }
          if (($7 | 0) != 45) {
           break label$4;
          }
          sqlite3_result_int64($1, 0, -2147483648);
          break label$1;
         }
         $4 = __wasm_i64_mul($6, $3, 10, 0);
         $8 = 0;
         $3 = $5 - 48 | 0;
         $5 = $3;
         $8 = $4;
         $4 = $3 + $8 | 0;
         $3 = i64toi32_i32$HIGH_BITS;
         $6 = $4;
         $3 = $4 >>> 0 < $5 >>> 0 ? $3 + 1 | 0 : $3;
         continue;
        }
        break;
       }
       ;
       $4 = $3 + (($6 | 0) != 0) | 0;
       $4 = 0 - $4 | 0;
       $8 = ($7 | 0) == 45;
       $5 = $8 ? 0 - $6 | 0 : $6;
       $3 = $8 ? $4 : $3;
       sqlite3_result_int64($1, $5, $3);
       break label$1;

      case 5:
      case 6:
       break label$2;

      case 4:
       break label$3;

      case 3:
       break label$5;
      }
     }
     $2 = HEAP32[$0 + 8 >> 2];
    }
    sqlite3AtoF($2, $9 + 8 | 0, sqlite3Strlen30($2), 1);
    sqlite3_result_double($1, HEAPF64[$9 + 8 >> 3]);
    break label$1;
   }
   if (!(HEAPU8[$0 + 1 | 0] & 2)) {
    sqlite3_result_text($1, HEAP32[$0 + 8 >> 2] + 1 | 0, HEAP32[$0 + 4 >> 2] - 2 | 0, -1);
    break label$1;
   }
   $10 = HEAP32[$0 + 8 >> 2];
   $0 = HEAP32[$0 + 4 >> 2];
   $6 = sqlite3_malloc($0 + 1 | 0);
   if ($6) {
    $13 = $10 + 3 | 0;
    $14 = $0 - 6 | 0;
    $15 = $0 - 1 | 0;
    $0 = 1;
    while (1) {
     label$17: {
      label$18: {
       label$19: {
        label$20: {
         if ($0 >>> 0 >= $15 >>> 0) {
          break label$20;
         }
         $7 = 1;
         $11 = $0 + $10 | 0;
         $2 = HEAPU8[$11 | 0];
         if (($2 | 0) != 92) {
          $4 = $5;
          $3 = $0;
          break label$17;
         }
         $2 = 8;
         $4 = $5;
         label$22: {
          label$23: {
           label$24: {
            label$25: {
             label$26: {
              $3 = $0 + 1 | 0;
              $12 = $10 + $3 | 0;
              $8 = HEAPU8[$12 | 0];
              switch ($8 - 98 | 0) {
              case 0:
               break label$17;

              case 1:
              case 2:
              case 3:
               break label$22;

              case 4:
               break label$25;

              default:
               break label$26;
              }
             }
             label$27: {
              switch ($8 - 114 | 0) {
              case 1:
              case 2:
               break label$22;

              case 0:
               break label$24;

              case 3:
               break label$27;

              default:
               break label$23;
              }
             }
             $2 = jsonHexToInt4($12 + 1 | 0);
             if (!$2) {
              break label$20;
             }
             $3 = $0 + 5 | 0;
             if ($2 >>> 0 <= 127) {
              break label$18;
             }
             if ($2 >>> 0 <= 2047) {
              HEAP8[$5 + $6 | 0] = $2 >>> 6 | 192;
              $4 = $5 + 1 | 0;
              $2 = $2 & 63 | -128;
              $7 = 2;
              break label$17;
             }
             label$29: {
              if (($2 & 64512) != 55296 | $3 >>> 0 >= $14 >>> 0 | HEAPU8[$11 + 6 | 0] != 92 | HEAPU8[$11 + 7 | 0] != 117) {
               break label$29;
              }
              $7 = jsonHexToInt4($3 + $13 | 0);
              if (($7 & 64512) != 56320) {
               break label$29;
              }
              $4 = $5 + $6 | 0;
              $2 = ($7 & 1023 | $2 << 10 & 1047552) + 65536 | 0;
              HEAP8[$4 | 0] = $2 >>> 18 | 240;
              HEAP8[$4 + 2 | 0] = $2 >>> 6 & 63 | 128;
              HEAP8[$4 + 1 | 0] = $2 >>> 12 & 63 | 128;
              $4 = $5 + 3 | 0;
              $3 = $0 + 11 | 0;
              $2 = $7 & 63 | -128;
              $7 = 4;
              break label$17;
             }
             $0 = $5 + $6 | 0;
             HEAP8[$0 | 0] = $2 >>> 12 | 224;
             HEAP8[$0 + 1 | 0] = $2 >>> 6 & 63 | 128;
             $4 = $5 + 2 | 0;
             $2 = $2 & 63 | -128;
             $7 = 3;
             break label$17;
            }
            $2 = 12;
            break label$18;
           }
           $2 = 13;
           break label$18;
          }
          if (($8 | 0) == 110) {
           break label$19;
          }
         }
         $2 = ($8 | 0) == 116 ? 9 : $8;
         break label$18;
        }
        HEAP8[$5 + $6 | 0] = 0;
        sqlite3_result_text($1, $6, $5, 3);
        break label$1;
       }
       $2 = 10;
      }
      $4 = $5;
     }
     HEAP8[$4 + $6 | 0] = $2;
     $0 = $3 + 1 | 0;
     $5 = $5 + $7 | 0;
     continue;
    }
   }
   sqlite3_result_error_nomem($1);
   break label$1;
  }
  jsonReturnJson($0, $1, 0);
 }
 __stack_pointer = $9 + 16 | 0;
}

function fts3MatchinfoValues($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $11 = HEAP32[$0 >> 2];
 HEAP32[$4 + 24 >> 2] = 0;
 $16 = $2 + 16 | 0;
 while (1) {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          if ($5) {
           break label$9;
          }
          $12 = $3 + $13 | 0;
          $6 = HEAPU8[$12 | 0];
          if (!$6) {
           break label$9;
          }
          HEAP8[$2 + 24 | 0] = $6;
          label$10: {
           label$11: {
            label$12: {
             label$13: {
              label$14: {
               $6 = HEAP8[$12 | 0];
               switch ($6 - 108 | 0) {
               case 2:
                break label$11;

               case 4:
                break label$13;

               case 0:
                break label$3;

               case 7:
                break label$4;

               case 1:
               case 3:
               case 5:
               case 6:
                break label$7;

               default:
                break label$14;
               }
              }
              switch ($6 - 97 | 0) {
              case 0:
               break label$10;

              case 2:
               break label$12;

              case 1:
               break label$5;

              default:
               break label$8;
              }
             }
             $5 = 0;
             if (!$1) {
              break label$2;
             }
             HEAP32[HEAP32[$2 + 28 >> 2] >> 2] = HEAP32[$2 + 8 >> 2];
             break label$2;
            }
            $5 = 0;
            if (!$1) {
             break label$2;
            }
            HEAP32[HEAP32[$2 + 28 >> 2] >> 2] = HEAP32[$2 + 4 >> 2];
            break label$2;
           }
           if (!$1) {
            break label$6;
           }
           HEAP32[$4 + 16 >> 2] = 0;
           HEAP32[$4 + 20 >> 2] = 0;
           $5 = fts3MatchinfoSelectDoctotal($11, $4 + 24 | 0, $4 + 16 | 0, 0, 0);
           HEAP32[$4 + 28 >> 2] = $5;
           $7 = HEAP32[$4 + 16 >> 2];
           HEAP32[HEAP32[$2 + 28 >> 2] >> 2] = $7;
           break label$2;
          }
          if (!$1) {
           break label$6;
          }
          $5 = fts3MatchinfoSelectDoctotal($11, $4 + 24 | 0, $4 + 16 | 0, $4 + 12 | 0, $4 + 8 | 0);
          HEAP32[$4 + 28 >> 2] = $5;
          if ($5) {
           break label$2;
          }
          $7 = HEAP32[$4 + 20 >> 2];
          $17 = $7;
          $14 = HEAP32[$4 + 16 >> 2];
          $18 = __wasm_i64_sdiv($14, $7, 2, 0);
          $7 = i64toi32_i32$HIGH_BITS;
          $9 = $7;
          $5 = 0;
          $6 = 0;
          while (1) {
           if (HEAP32[$2 + 4 >> 2] <= ($6 | 0)) {
            break label$2;
           }
           $8 = sqlite3Fts3GetVarint(HEAP32[$4 + 12 >> 2], $4) + HEAP32[$4 + 12 >> 2] | 0;
           HEAP32[$4 + 12 >> 2] = $8;
           if (HEAPU32[$4 + 8 >> 2] < $8 >>> 0) {
            $5 = 267;
            HEAP32[$4 + 28 >> 2] = 267;
            break label$2;
           } else {
            $7 = HEAP32[$4 >> 2];
            $10 = $7;
            $19 = HEAP32[$2 + 28 >> 2] + ($6 << 2) | 0;
            $8 = $9;
            $7 = $18;
            $15 = $7 + $10 | 0;
            $8 = $10 >>> 0 > $15 >>> 0 ? $8 + 1 | 0 : $8;
            $7 = $17;
            $7 = __wasm_i64_sdiv($15, $8, $14, $7);
            HEAP32[$19 >> 2] = $7;
            $6 = $6 + 1 | 0;
            continue;
           }
          }
         }
         sqlite3_reset(HEAP32[$4 + 24 >> 2]);
         __stack_pointer = $4 + 32 | 0;
         return $5;
        }
        if (($6 | 0) == 121) {
         break label$5;
        }
       }
       $6 = HEAP32[$0 + 16 >> 2];
       $5 = fts3ExprLoadDoclists($0, 0, 0);
       HEAP32[$4 + 28 >> 2] = $5;
       if ($5) {
        break label$2;
       }
       if ($1) {
        if (HEAP32[$0 + 28 >> 2]) {
         $5 = fts3MatchinfoSelectDoctotal($11, $4 + 24 | 0, $16, 0, 0);
         HEAP32[$4 + 28 >> 2] = $5;
         if ($5) {
          break label$2;
         }
        }
        HEAP32[$4 + 28 >> 2] = fts3ExprIterate($6, 112, $2);
        sqlite3Fts3EvalTestDeferred($0, $4 + 28 | 0);
        $5 = HEAP32[$4 + 28 >> 2];
        if ($5) {
         break label$2;
        }
       }
       fts3ExprIterate($6, 113, $2);
      }
      $5 = 0;
      break label$2;
     }
     memset(HEAP32[$2 + 28 >> 2], 0, fts3MatchinfoSize($2, $6) << 2);
     $5 = fts3ExprLHitGather(HEAP32[$0 + 16 >> 2], $2);
     HEAP32[$4 + 28 >> 2] = $5;
     break label$2;
    }
    $5 = fts3ExprLoadDoclists($0, 0, 0);
    HEAP32[$4 + 28 >> 2] = $5;
    if ($5) {
     break label$2;
    }
    $5 = fts3MatchinfoLcs($0, $2);
    HEAP32[$4 + 28 >> 2] = $5;
    break label$2;
   }
   HEAP32[$4 >> 2] = 0;
   $8 = HEAP32[$0 + 32 >> 2];
   $7 = HEAP32[$0 + 36 >> 2];
   $5 = sqlite3Fts3SelectDocsize($11, $8, $7, $4);
   HEAP32[$4 + 28 >> 2] = $5;
   $9 = HEAP32[$4 >> 2];
   label$20: {
    if ($5) {
     break label$20;
    }
    $5 = 0;
    $8 = sqlite3_column_blob($9, 0);
    $10 = $8 + sqlite3_column_bytes($9, 0) | 0;
    $6 = 0;
    while (1) {
     if (HEAP32[$2 + 4 >> 2] <= ($6 | 0)) {
      break label$20;
     }
     $8 = sqlite3Fts3GetVarintBounded($8, $10, $4 + 16 | 0) + $8 | 0;
     if ($10 >>> 0 < $8 >>> 0) {
      HEAP32[$4 + 28 >> 2] = 267;
     } else {
      $7 = HEAP32[$4 + 16 >> 2];
      HEAP32[HEAP32[$2 + 28 >> 2] + ($6 << 2) >> 2] = $7;
      $6 = $6 + 1 | 0;
      continue;
     }
     break;
    }
    $5 = 267;
   }
   sqlite3_reset($9);
  }
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] + (fts3MatchinfoSize($2, HEAP8[$12 | 0]) << 2);
  $13 = $13 + 1 | 0;
  continue;
 }
}

function whereLoopAddVirtualOne($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $19 = __stack_pointer - 32 | 0;
 __stack_pointer = $19;
 $16 = HEAP32[$6 + 16 >> 2];
 $22 = HEAP32[$0 + 4 >> 2];
 $10 = HEAP32[$0 + 8 >> 2];
 $17 = HEAPU8[$10 + 16 | 0];
 $11 = HEAP32[$0 >> 2];
 $21 = HEAP32[$11 + 4 >> 2];
 $23 = HEAP32[$11 >> 2];
 $20 = HEAP32[$6 >> 2];
 HEAP32[$8 >> 2] = 0;
 HEAP32[$10 >> 2] = $1;
 $14 = $2;
 HEAP32[$10 + 4 >> 2] = $14;
 $24 = ($20 | 0) > 0 ? $20 : 0;
 $11 = HEAP32[$6 + 4 >> 2];
 while (1) {
  if (($13 | 0) != ($24 | 0)) {
   $12 = HEAP32[$22 + 24 >> 2];
   HEAP8[$11 + 5 | 0] = 0;
   $12 = Math_imul(HEAP32[$11 + 8 >> 2], 48) + $12 | 0;
   $14 = HEAP32[$12 + 32 >> 2];
   $1 = $14;
   $14 = $4;
   $15 = HEAP32[$12 + 36 >> 2];
   $2 = $15;
   $14 = $14 & $15;
   $18 = $3;
   $15 = $18 & $1;
   $18 = $1;
   label$3: {
    if (HEAPU16[$12 + 12 >> 1] & $5 | (($15 | 0) != ($18 | 0) | ($14 | 0) != ($2 | 0))) {
     break label$3;
    }
    if (!$9) {
     if (isLimitTerm($12)) {
      break label$3;
     }
    }
    HEAP8[$11 + 5 | 0] = 1;
   }
   $11 = $11 + 12 | 0;
   $13 = $13 + 1 | 0;
   continue;
  }
  break;
 }
 $11 = 0;
 $25 = memset($16, 0, $20 << 3);
 HEAP32[$6 + 56 >> 2] = 0;
 HEAP32[$6 + 48 >> 2] = 25;
 HEAP32[$6 + 52 >> 2] = 0;
 HEAP32[$6 + 40 >> 2] = -1568170194;
 HEAP32[$6 + 44 >> 2] = 1416446638;
 HEAP32[$6 + 32 >> 2] = 0;
 HEAP32[$6 + 20 >> 2] = 0;
 HEAP32[$6 + 24 >> 2] = 0;
 $13 = ($17 << 6) + $21 | 0;
 $15 = HEAP32[$13 + 56 >> 2];
 $1 = $15;
 $14 = HEAP32[$13 + 60 >> 2];
 HEAP32[$6 + 88 >> 2] = 0;
 HEAP32[$6 + 64 >> 2] = $1;
 HEAP32[$6 + 68 >> 2] = $14;
 $3 = $13;
 $13 = vtabBestIndex($23, HEAP32[$13 + 24 >> 2], $6);
 label$5: {
  if ($13) {
   if (($13 | 0) == 19) {
    break label$5;
   }
   $11 = $13;
   break label$5;
  }
  memset(HEAP32[$10 + 52 >> 2], 0, $20 << 2);
  HEAP32[$10 + 32 >> 2] = 0;
  HEAP32[$10 + 36 >> 2] = 0;
  HEAP32[$10 + 24 >> 2] = 0;
  HEAP32[$10 + 28 >> 2] = 0;
  $13 = HEAP32[$6 + 4 >> 2];
  $16 = -1;
  while (1) {
   if (($11 | 0) != ($24 | 0)) {
    label$9: {
     $21 = ($11 << 3) + $25 | 0;
     $12 = HEAP32[$21 >> 2];
     if (($12 | 0) <= 0) {
      break label$9;
     }
     label$10: {
      label$11: {
       if (($12 | 0) > ($20 | 0)) {
        break label$11;
       }
       $17 = HEAP32[$13 + 8 >> 2];
       if (($17 | 0) < 0 | HEAP32[$22 + 12 >> 2] <= ($17 | 0)) {
        break label$11;
       }
       $5 = $12 - 1 | 0;
       $4 = HEAP32[$10 + 52 >> 2] + ($5 << 2) | 0;
       if (HEAP32[$4 >> 2]) {
        break label$11;
       }
       if (HEAPU8[$13 + 5 | 0]) {
        break label$10;
       }
      }
      HEAP32[$19 + 16 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] >> 2];
      sqlite3ErrorMsg($23, 9826, $19 + 16 | 0);
      $11 = 1;
      break label$5;
     }
     $14 = HEAP32[$10 >> 2];
     $18 = $14;
     $15 = HEAP32[$10 + 4 >> 2];
     $1 = $15;
     $12 = HEAP32[$22 + 24 >> 2] + Math_imul($17, 48) | 0;
     $15 = HEAP32[$12 + 32 >> 2];
     $14 = HEAP32[$12 + 36 >> 2];
     $2 = $14;
     $14 = $18 | $15;
     HEAP32[$10 >> 2] = $14;
     $14 = $1;
     $15 = $2;
     $15 = $14 | $15;
     HEAP32[$10 + 4 >> 2] = $15;
     HEAP32[$4 >> 2] = $12;
     label$12: {
      if (!HEAPU8[$21 + 4 | 0]) {
       break label$12;
      }
      if (!($7 >>> $11 & 1 | $11 >>> 0 > 15)) {
       HEAP16[$10 + 30 >> 1] = HEAPU16[$10 + 30 >> 1] | 1 << $5;
      }
      if (HEAPU8[$12 + 15 | 0] != 74) {
       break label$12;
      }
      HEAP8[$10 + 28 | 0] = HEAPU8[$10 + 28 | 0] | 2;
     }
     $17 = ($5 | 0) > ($16 | 0);
     label$14: {
      if (HEAP32[$6 + 88 >> 2] & ($11 >>> 0 < 32 ? 1 << $11 : 0)) {
       HEAP32[$10 + 36 >> 2] = HEAP32[$10 + 36 >> 2] | 1 << $5;
       break label$14;
      }
      if (!(HEAP8[$12 + 12 | 0] & 1)) {
       break label$14;
      }
      HEAP32[$6 + 32 >> 2] = 0;
      HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] & -2;
      HEAP32[$8 >> 2] = 1;
     }
     $16 = $17 ? $5 : $16;
     if (!isLimitTerm($12) | !HEAP32[$8 >> 2]) {
      break label$9;
     }
     if (HEAP32[$6 + 28 >> 2]) {
      sqlite3_free(HEAP32[$6 + 24 >> 2]);
      HEAP32[$6 + 24 >> 2] = 0;
      HEAP32[$6 + 28 >> 2] = 0;
     }
     HEAP32[$9 >> 2] = 1;
     $11 = 0;
     break label$5;
    }
    $13 = $13 + 12 | 0;
    $11 = $11 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP16[$10 + 44 >> 1] = $16 + 1;
  $12 = (($16 | 0) >= 0 ? $16 : -1) + 1 | 0;
  $11 = 0;
  label$17: {
   while (1) {
    if (($11 | 0) == ($12 | 0)) {
     break label$17;
    }
    $13 = $11 << 2;
    $11 = $11 + 1 | 0;
    if (HEAP32[HEAP32[$10 + 52 >> 2] + $13 >> 2]) {
     continue;
    }
    break;
   }
   HEAP32[$19 >> 2] = HEAP32[HEAP32[$3 + 24 >> 2] >> 2];
   sqlite3ErrorMsg($23, 9826, $19);
   $11 = 1;
   break label$5;
  }
  HEAP32[$10 + 24 >> 2] = HEAP32[$6 + 20 >> 2];
  HEAP8[$10 + 28 | 0] = HEAPU8[$10 + 28 | 0] & 254 | HEAP8[$6 + 28 | 0] & 1;
  HEAP32[$6 + 28 >> 2] = 0;
  HEAP32[$10 + 32 >> 2] = HEAP32[$6 + 24 >> 2];
  $11 = 0;
  $11 = HEAP32[$6 + 32 >> 2] ? HEAP32[$6 + 8 >> 2] : $11;
  HEAP16[$10 + 18 >> 1] = 0;
  HEAP8[$10 + 29 | 0] = $11;
  HEAP16[$10 + 20 >> 1] = sqlite3LogEstFromDouble(HEAPF64[$6 + 40 >> 3]);
  $15 = HEAP32[$6 + 48 >> 2];
  $18 = HEAP32[$6 + 52 >> 2];
  HEAP16[$10 + 22 >> 1] = sqlite3LogEst($15, $18);
  HEAP32[$10 + 40 >> 2] = HEAP32[$10 + 40 >> 2] & -4097 | HEAP32[$6 + 56 >> 2] << 12 & 4096;
  $11 = whereLoopInsert($0, $10);
  if (!(HEAP8[$10 + 28 | 0] & 1)) {
   break label$5;
  }
  sqlite3_free(HEAP32[$10 + 32 >> 2]);
  HEAP8[$10 + 28 | 0] = HEAPU8[$10 + 28 | 0] & 254;
 }
 __stack_pointer = $19 + 32 | 0;
 return $11;
}

function vdbeCommit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 $2 = sqlite3VtabSync($0, $1);
 $1 = 0;
 label$1: {
  while (1) {
   if ($2) {
    break label$1;
   }
   if (HEAP32[$0 + 20 >> 2] > ($1 | 0)) {
    $2 = 0;
    $6 = $1 << 4;
    $4 = HEAP32[($6 + HEAP32[$0 + 16 >> 2] | 0) + 4 >> 2];
    if ((sqlite3BtreeTxnState($4) | 0) == 2) {
     sqlite3BtreeEnter($4);
     $2 = sqlite3BtreePager($4);
     label$5: {
      if (HEAPU8[(HEAP32[$0 + 16 >> 2] + $6 | 0) + 8 | 0] == 1) {
       break label$5;
      }
      if (52 >>> sqlite3PagerGetJournalMode($2) & 1) {
       break label$5;
      }
      $7 = !sqlite3PagerIsMemdb($2) + $7 | 0;
     }
     $5 = 1;
     $2 = sqlite3PagerExclusiveLock($2);
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  label$6: {
   if (!$5) {
    break label$6;
   }
   $1 = HEAP32[$0 + 232 >> 2];
   if (!$1) {
    break label$6;
   }
   $2 = 531;
   if (FUNCTION_TABLE[$1 | 0](HEAP32[$0 + 228 >> 2]) | 0) {
    break label$1;
   }
  }
  $2 = 0;
  label$7: {
   label$8: {
    $4 = sqlite3BtreeGetFilename(HEAP32[HEAP32[$0 + 16 >> 2] + 4 >> 2]);
    label$9: {
     if (!sqlite3Strlen30($4)) {
      $1 = 0;
      break label$9;
     }
     $1 = 0;
     if (($7 | 0) > 1) {
      break label$8;
     }
    }
    while (1) if (!$2 & HEAP32[$0 + 20 >> 2] > ($1 | 0)) {
     $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
     if ($2) {
      $2 = sqlite3BtreeCommitPhaseOne($2, 0);
     } else {
      $2 = 0;
     }
     $1 = $1 + 1 | 0;
     continue;
    } else {
     $1 = 0;
     while (1) {
      if ($2) {
       break label$1;
      }
      if (HEAP32[$0 + 20 >> 2] <= ($1 | 0)) {
       break label$7;
      }
      $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
      if ($2) {
       $2 = sqlite3BtreeCommitPhaseTwo($2, 0);
      } else {
       $2 = 0;
      }
      $1 = $1 + 1 | 0;
      continue;
     }
    }
   }
   $6 = HEAP32[$0 >> 2];
   HEAP32[$3 + 76 >> 2] = 0;
   $1 = sqlite3Strlen30($4);
   HEAP32[$3 + 56 >> 2] = 0;
   HEAP32[$3 + 52 >> 2] = $4;
   HEAP32[$3 + 48 >> 2] = 0;
   $7 = sqlite3MPrintf($0, 17341, $3 + 48 | 0);
   if (!$7) {
    $2 = 7;
    break label$1;
   }
   $4 = $7 + 4 | 0;
   $5 = $4 + $1 | 0;
   $1 = 0;
   label$20: {
    label$21: {
     label$22: {
      label$23: {
       while (1) {
        label$25: {
         if (!$1) {
          break label$25;
         }
         if ($1 >>> 0 > 100) {
          break label$23;
         }
         if (($1 | 0) != 1) {
          break label$25;
         }
         HEAP32[$3 + 32 >> 2] = $4;
         sqlite3_log(13, 7973, $3 + 32 | 0);
        }
        sqlite3_randomness(4, $3 + 68 | 0);
        $2 = HEAP32[$3 + 68 >> 2];
        HEAP32[$3 >> 2] = $2 >>> 8;
        HEAP32[$3 + 4 >> 2] = $2 & 255;
        sqlite3_snprintf(13, $5, 18180, $3);
        $2 = sqlite3OsAccess($6, $4, 0, $3 + 72 | 0);
        if (!$2) {
         $1 = $1 + 1 | 0;
         if (HEAP32[$3 + 72 >> 2]) {
          continue;
         }
        }
        break;
       }
       if ($2) {
        break label$21;
       }
       break label$22;
      }
      HEAP32[$3 + 16 >> 2] = $4;
      sqlite3_log(13, 7521, $3 + 16 | 0);
      sqlite3OsDelete($6, $4, 0);
     }
     $1 = 0;
     $2 = sqlite3OsOpenMalloc($6, $4, $3 + 76 | 0, 16406, 0);
     if ($2) {
      break label$21;
     }
     $8 = HEAP32[$3 + 76 >> 2];
     label$27: {
      label$28: {
       while (1) {
        if (HEAP32[$0 + 20 >> 2] > ($1 | 0)) {
         $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
         label$31: {
          if ((sqlite3BtreeTxnState($2) | 0) != 2) {
           break label$31;
          }
          $5 = sqlite3BtreeGetJournalname($2);
          if (!$5) {
           break label$31;
          }
          $2 = sqlite3OsWrite($8, $5, sqlite3Strlen30($5) + 1 | 0, $9, $10);
          $5 = sqlite3Strlen30($5);
          if ($2) {
           break label$28;
          }
          $2 = $5 + 1 | 0;
          $9 = $2 + $9 | 0;
          $10 = $2 >>> 0 > $9 >>> 0 ? $10 + 1 | 0 : $10;
         }
         $1 = $1 + 1 | 0;
         continue;
        }
        break;
       }
       if (sqlite3OsDeviceCharacteristics($8) & 1024) {
        break label$27;
       }
       $2 = sqlite3OsSync($8, 2);
       if (!$2) {
        break label$27;
       }
       sqlite3OsCloseFree($8);
       sqlite3OsDelete($6, $4, 0);
       break label$21;
      }
      sqlite3OsCloseFree($8);
      sqlite3OsDelete($6, $4, 0);
      break label$21;
     }
     $2 = 0;
     $1 = 0;
     label$32: {
      while (1) {
       if (!$2) {
        if (HEAP32[$0 + 20 >> 2] <= ($1 | 0)) {
         break label$32;
        }
        $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
        if ($2) {
         $2 = sqlite3BtreeCommitPhaseOne($2, $4);
        } else {
         $2 = 0;
        }
        $1 = $1 + 1 | 0;
        continue;
       }
       break;
      }
      sqlite3OsCloseFree($8);
      break label$21;
     }
     sqlite3OsCloseFree($8);
     $2 = sqlite3OsDelete($6, $4, 1);
     sqlite3DbFree($0, $7);
     if ($2) {
      break label$1;
     }
     sqlite3BeginBenignMalloc();
     $1 = 0;
     while (1) {
      if (HEAP32[$0 + 20 >> 2] <= ($1 | 0)) {
       break label$20;
      }
      $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
      if ($2) {
       sqlite3BtreeCommitPhaseTwo($2, 1);
      }
      $1 = $1 + 1 | 0;
      continue;
     }
    }
    sqlite3DbFree($0, $7);
    break label$1;
   }
   sqlite3EndBenignMalloc();
  }
  sqlite3VtabCommit($0);
  $2 = 0;
 }
 __stack_pointer = $3 + 80 | 0;
 return $2;
}

function jsonLookupStep($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $12 = HEAP32[$0 + 8 >> 2];
 label$1: {
  label$2: while (1) {
   $6 = Math_imul($1, 12);
   $9 = $12 + $6 | 0;
   $5 = HEAPU8[$2 | 0];
   if (!$5) {
    return $9;
   }
   if (HEAPU8[($6 + $12 | 0) + 1 | 0] & 8) {
    break label$1;
   }
   label$4: {
    label$5: {
     if (($5 | 0) == 91) {
      $5 = 0;
      $6 = 1;
      while (1) {
       $7 = HEAPU8[$2 + $6 | 0];
       if ($7 - 58 >>> 0 < 4294967286) {
        break label$5;
       }
       $6 = $6 + 1 | 0;
       $5 = (Math_imul($5, 10) + ($7 << 24 >> 24) | 0) - 48 | 0;
       continue;
      }
     }
     if (($5 | 0) != 46) {
      break label$4;
     }
     if (HEAPU8[$9 | 0] != 7) {
      break label$1;
     }
     $10 = $2 + 1 | 0;
     $7 = 0;
     label$8: {
      label$9: {
       $5 = HEAPU8[$2 + 1 | 0];
       label$10: {
        if (($5 | 0) == 34) {
         $11 = $2 + 2 | 0;
         $5 = 1;
         while (1) {
          $6 = HEAPU8[$5 + $10 | 0];
          if (!$6) {
           break label$10;
          }
          if (($6 | 0) == 34) {
           break label$9;
          }
          $5 = $5 + 1 | 0;
          continue;
         }
        }
        while (1) {
         $5 = $5 & 255;
         if (!(!$5 | ($5 | 0) == 46 | ($5 | 0) == 91)) {
          $7 = $7 + 1 | 0;
          $5 = HEAPU8[$10 + $7 | 0];
          continue;
         }
         break;
        }
        $11 = $10;
        $2 = $7;
        if ($7) {
         break label$8;
        }
       }
       HEAP32[$4 >> 2] = $10;
       break label$1;
      }
      $2 = $5 + 1 | 0;
      $7 = $5 - 1 | 0;
     }
     while (1) {
      $8 = HEAP32[$9 + 4 >> 2];
      $5 = 1;
      while (1) {
       if ($5 >>> 0 <= $8 >>> 0) {
        $6 = $5 + 1 | 0;
        if (jsonLabelCompare(Math_imul($5, 12) + $9 | 0, $11, $7)) {
         $2 = $2 + $10 | 0;
         $1 = $1 + $6 | 0;
         continue label$2;
        } else {
         $5 = jsonNodeSize(Math_imul($6, 12) + $9 | 0) + $6 | 0;
         continue;
        }
       }
       break;
      }
      if (HEAPU8[$9 + 1 | 0] & 32) {
       $1 = HEAP32[$9 + 8 >> 2] + $1 | 0;
       $9 = Math_imul($1, 12) + $12 | 0;
       continue;
      }
      break;
     }
     if (!$3) {
      break label$1;
     }
     $6 = jsonParseAddNode($0, 7, 2, 0);
     $7 = jsonParseAddNode($0, 5, $7, $11);
     $5 = jsonLookupAppend($0, $2 + $10 | 0, $3, $4);
     if (HEAPU8[$0 + 20 | 0] | !$5) {
      break label$1;
     }
     $8 = HEAP32[$0 + 8 >> 2] + Math_imul($1, 12) | 0;
     HEAP32[$8 + 8 >> 2] = $6 - $1;
     HEAP8[$8 + 1 | 0] = HEAPU8[$8 + 1 | 0] | 32;
     $6 = HEAP32[$0 + 8 >> 2] + Math_imul($7, 12) | 0;
     HEAP8[$6 + 1 | 0] = HEAPU8[$6 + 1 | 0] | 1;
     return $5;
    }
    label$21: {
     if (!(($7 | 0) == 93 & $6 >>> 0 >= 2)) {
      if (HEAPU8[$2 + 1 | 0] != 35) {
       break label$4;
      }
      $8 = $9;
      $10 = $1;
      if (HEAPU8[$9 | 0] != 6) {
       break label$1;
      }
      while (1) {
       $11 = HEAP32[$8 + 4 >> 2];
       while (1) {
        if ($6 >>> 0 <= $11 >>> 0) {
         $7 = Math_imul($6, 12) + $8 | 0;
         $6 = jsonNodeSize($7) + $6 | 0;
         $5 = ((HEAPU8[$7 + 1 | 0] ^ -1) >>> 2 & 1) + $5 | 0;
         continue;
        }
        break;
       }
       if (HEAPU8[$8 + 1 | 0] & 32) {
        $10 = HEAP32[$8 + 8 >> 2] + $10 | 0;
        $8 = Math_imul($10, 12) + $12 | 0;
        $6 = 1;
        continue;
       }
       break;
      }
      $6 = 2;
      $7 = HEAPU8[$2 + 2 | 0];
      label$27: {
       if (($7 | 0) == 45) {
        $7 = HEAPU8[$2 + 3 | 0];
        if ($7 - 58 >>> 0 < 4294967286) {
         break label$27;
        }
        $8 = 0;
        $6 = 3;
        while (1) {
         $8 = (Math_imul($8, 10) + ($7 << 24 >> 24) | 0) - 48 | 0;
         $6 = $6 + 1 | 0;
         $7 = HEAPU8[$6 + $2 | 0];
         if ($7 - 58 >>> 0 > 4294967285) {
          continue;
         }
         break;
        }
        if ($5 >>> 0 < $8 >>> 0) {
         break label$1;
        }
        $5 = $5 - $8 | 0;
       }
       if (($7 | 0) == 93) {
        break label$21;
       }
      }
      HEAP32[$4 >> 2] = $2;
      return 0;
     }
     if (HEAPU8[$9 | 0] != 6) {
      break label$1;
     }
    }
    $2 = ($2 + $6 | 0) + 1 | 0;
    while (1) {
     $11 = HEAP32[$9 + 4 >> 2];
     $6 = 1;
     label$31: {
      label$32: {
       label$33: {
        while (1) {
         if ($6 >>> 0 <= $11 >>> 0) {
          $8 = Math_imul($6, 12) + $9 | 0;
          $7 = HEAPU8[$8 + 1 | 0];
          if (!($7 & 4 ? 1 : $5)) {
           break label$33;
          }
          $6 = jsonNodeSize($8) + $6 | 0;
          $5 = (($7 >>> 2 & 1) + $5 | 0) - 1 | 0;
          continue;
         }
         break;
        }
        if (HEAPU8[$9 + 1 | 0] & 32) {
         break label$32;
        }
        if (!$3 | $5) {
         break label$1;
        }
        $6 = jsonParseAddNode($0, 6, 1, 0);
        $5 = jsonLookupAppend($0, $2, $3, $4);
        if (HEAPU8[$0 + 20 | 0] | !$5) {
         break label$1;
        }
        $7 = HEAP32[$0 + 8 >> 2] + Math_imul($1, 12) | 0;
        HEAP32[$7 + 8 >> 2] = $6 - $1;
        HEAP8[$7 + 1 | 0] = HEAPU8[$7 + 1 | 0] | 32;
        return $5;
       }
       $5 = 0;
       if (!(HEAPU8[$9 + 1 | 0] & 32)) {
        break label$31;
       }
      }
      $1 = HEAP32[$9 + 8 >> 2] + $1 | 0;
      $9 = Math_imul($1, 12) + $12 | 0;
      continue;
     }
     break;
    }
    $1 = $1 + $6 | 0;
    continue;
   }
   break;
  }
  HEAP32[$4 >> 2] = $2;
 }
 return 0;
}

function walIndexRecover($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 $7 = HEAPU8[$0 + 45 | 0];
 $16 = $7 + 1 | 0;
 $17 = 2 - $7 | 0;
 $1 = walLockExclusive($0, $16, $17);
 if (!$1) {
  $7 = 0;
  memset($0 + 52 | 0, 0, 48);
  $1 = sqlite3OsFileSize(HEAP32[$0 + 8 >> 2], $2 + 72 | 0);
  label$2: {
   if ($1) {
    break label$2;
   }
   $3 = HEAP32[$2 + 72 >> 2];
   $5 = $3;
   label$3: {
    label$4: {
     $3 = HEAP32[$2 + 76 >> 2];
     if ($5 >>> 0 < 33 & ($3 | 0) <= 0 | ($3 | 0) < 0) {
      break label$4;
     }
     $1 = sqlite3OsRead(HEAP32[$0 + 8 >> 2], $2 + 32 | 0, 32, 0, 0);
     if ($1) {
      break label$2;
     }
     $6 = sqlite3Get4byte($2 + 32 | 0);
     $1 = sqlite3Get4byte($2 + 32 | 8);
     if ($1 & $1 - 1 | ($6 & -2) != 931071618 | $1 - 65537 >>> 0 < 4294902271) {
      break label$4;
     }
     HEAP32[$0 + 36 >> 2] = $1;
     $6 = $6 & 1;
     HEAP8[$0 + 65 | 0] = $6;
     HEAP32[$0 + 112 >> 2] = sqlite3Get4byte($2 + 32 | 12);
     $3 = HEAP32[$2 + 52 >> 2];
     $5 = HEAP32[$2 + 48 >> 2];
     HEAP32[$0 + 84 >> 2] = $5;
     HEAP32[$0 + 88 >> 2] = $3;
     $5 = $6 ^ 1;
     $6 = $0 + 76 | 0;
     walChecksumBytes($5, $2 + 32 | 0, 24, 0, $6);
     if (HEAP32[$0 + 76 >> 2] != (sqlite3Get4byte($2 + 56 | 0) | 0)) {
      break label$4;
     }
     if (HEAP32[$0 + 80 >> 2] != (sqlite3Get4byte($2 + 60 | 0) | 0)) {
      break label$4;
     }
     label$5: {
      if ((sqlite3Get4byte($2 + 32 | 4) | 0) != 3007e3) {
       $6 = 0;
       $1 = sqlite3CantopenError(62953);
       break label$5;
      }
      $9 = sqlite3_malloc64($1 + 32792 | 0, 0);
      if (!$9) {
       $1 = 7;
       break label$2;
      }
      $23 = $1 & 65280 | $1 >>> 16;
      $18 = $9 + 24 | 0;
      $19 = $18 + $1 | 0;
      $3 = HEAP32[$2 + 72 >> 2];
      $13 = $3 - 32 | 0;
      $5 = HEAP32[$2 + 76 >> 2];
      $8 = $3 >>> 0 < 32;
      $8 = $5 - $8 | 0;
      $14 = $1 + 24 | 0;
      $3 = __wasm_i64_sdiv($13, $8, $14, 0);
      $20 = $3;
      $24 = walFramePage($3);
      $6 = 0;
      $1 = 0;
      while (1) {
       label$9: {
        if ($11 >>> 0 > $24 >>> 0) {
         break label$9;
        }
        $1 = walIndexPage($0, $11, $2 + 28 | 0);
        $15 = HEAP32[$2 + 28 >> 2];
        if (!$15) {
         break label$9;
        }
        $21 = $11 << 2;
        HEAP32[$21 + HEAP32[$0 + 32 >> 2] >> 2] = $19;
        $4 = $11 << 12;
        $10 = $4 | 4062;
        $25 = $10 >>> 0 < $20 >>> 0 ? $10 : $20;
        $4 = $11 ? $4 - 33 | 0 : 1;
        $10 = $4;
        $12 = 0;
        while (1) {
         label$11: {
          $8 = $12;
          $3 = $25;
          $5 = $10;
          $22 = !$8 & $3 >>> 0 < $5 >>> 0 | ($8 | 0) != 0;
          if ($22) {
           break label$11;
          }
          $1 = HEAP32[$0 + 8 >> 2];
          $8 = __wasm_i64_mul($4 - 1 | 0, 0, $14, 0);
          $3 = $8;
          $5 = i64toi32_i32$HIGH_BITS;
          $3 = $3 + 32 | 0;
          $13 = $3 >>> 0 < 32 ? $5 + 1 | 0 : $5;
          $1 = sqlite3OsRead($1, $9, $14, $3, $13);
          if ($1) {
           break label$11;
          }
          if (!walDecodeFrame($0, $2 + 24 | 0, $2 + 20 | 0, $18, $9)) {
           $1 = 0;
           break label$11;
          }
          $1 = walIndexAppend($0, $10, HEAP32[$2 + 24 >> 2]);
          if ($1) {
           break label$11;
          }
          $1 = HEAP32[$2 + 20 >> 2];
          if ($1) {
           HEAP32[$0 + 72 >> 2] = $1;
           HEAP32[$0 + 68 >> 2] = $10;
           HEAP16[$0 + 66 >> 1] = $23;
           $6 = HEAP32[$0 + 80 >> 2];
           $7 = HEAP32[$0 + 76 >> 2];
          }
          $3 = $12;
          $5 = $10;
          $8 = $5 + 1 | 0;
          $3 = $8 ? $3 : $3 + 1 | 0;
          $10 = $8;
          $12 = $3;
          $4 = $4 + 1 | 0;
          $1 = 0;
          continue;
         }
         break;
        }
        HEAP32[HEAP32[$0 + 32 >> 2] + $21 >> 2] = $15;
        $4 = $11 ? 0 : 136;
        __memcpy($15 + $4 | 0, $4 + $19 | 0, 32768 - $4 | 0);
        if (!$22) {
         break label$9;
        }
        $11 = $11 + 1 | 0;
        continue;
       }
       break;
      }
      sqlite3_free($9);
     }
     if ($1) {
      break label$2;
     }
     break label$3;
    }
    $6 = 0;
   }
   HEAP32[$0 + 80 >> 2] = $6;
   HEAP32[$0 + 76 >> 2] = $7;
   walIndexWriteHdr($0);
   $1 = 0;
   $4 = walCkptInfo($0);
   HEAP32[$4 >> 2] = 0;
   HEAP32[$4 + 32 >> 2] = HEAP32[$0 + 68 >> 2];
   HEAP32[$4 + 4 >> 2] = 0;
   $7 = 1;
   while (1) {
    if (($7 | 0) != 5) {
     $6 = $7 + 3 | 0;
     $1 = walLockExclusive($0, $6, 1);
     if (($1 | 0) != 5) {
      if ($1) {
       break label$2;
      }
      label$17: {
       label$18: {
        if (($7 | 0) != 1) {
         break label$18;
        }
        $9 = HEAP32[$0 + 68 >> 2];
        if (!$9) {
         break label$18;
        }
        HEAP32[$4 + 8 >> 2] = $9;
        break label$17;
       }
       HEAP32[(($7 << 2) + $4 | 0) + 4 >> 2] = -1;
      }
      walUnlockExclusive($0, $6, 1);
     }
     $7 = $7 + 1 | 0;
     continue;
    }
    break;
   }
   if (!HEAP32[$0 + 72 >> 2]) {
    break label$2;
   }
   $7 = HEAP32[$0 + 68 >> 2];
   HEAP32[$2 + 4 >> 2] = HEAP32[$0 + 108 >> 2];
   HEAP32[$2 >> 2] = $7;
   sqlite3_log(283, 6516, $2);
  }
  walUnlockExclusive($0, $16, $17);
 }
 __stack_pointer = $2 + 80 | 0;
 return $1;
}

function jsonAppendString($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $6 = HEAP32[$0 + 8 >> 2];
  $12 = $6;
  $4 = HEAP32[$0 + 12 >> 2];
  $9 = $4;
  $6 = HEAP32[$0 + 20 >> 2];
  $11 = $6;
  $14 = $2;
  $8 = $2;
  $4 = HEAP32[$0 + 16 >> 2];
  $10 = $4;
  $7 = $4;
  $3 = $8 + $4 | 0;
  $4 = $11;
  $5 = $3 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
  $6 = $3;
  $3 = $5;
  $4 = $6 + 2 | 0;
  $3 = $4 >>> 0 < 2 ? $3 + 1 | 0 : $3;
  $6 = $3;
  $3 = $9;
  $5 = $12;
  if (($6 | 0) == ($3 | 0) & $4 >>> 0 >= $5 >>> 0 | $3 >>> 0 < $6 >>> 0) {
   if (jsonGrow($0, $2 + 2 | 0)) {
    break label$1;
   }
   $3 = HEAP32[$0 + 20 >> 2];
   $11 = $3;
   $5 = HEAP32[$0 + 16 >> 2];
   $10 = $5;
  }
  $3 = $11;
  $4 = $3;
  $7 = $10;
  $8 = $7 + 1 | 0;
  $4 = $8 ? $4 : $4 + 1 | 0;
  HEAP32[$0 + 16 >> 2] = $8;
  HEAP32[$0 + 20 >> 2] = $4;
  HEAP8[$10 + HEAP32[$0 + 4 >> 2] | 0] = 34;
  $17 = $2 + 7 | 0;
  $8 = 0;
  $3 = $14;
  $5 = $3 + 7 | 0;
  $8 = $5 >>> 0 < 7 ? 1 : $8;
  $18 = $5;
  $19 = $8;
  $20 = $2 + 3 | 0;
  $5 = 0;
  $4 = $14;
  $7 = $4 + 3 | 0;
  $5 = $7 >>> 0 < 3 ? 1 : $5;
  $21 = $7;
  $22 = $5;
  $10 = 0;
  $11 = 0;
  while (1) {
   label$4: {
    label$5: {
     $6 = $14;
     $8 = $10;
     $5 = $11;
     if (($6 | 0) != ($8 | 0) | $5) {
      $2 = HEAPU8[$10 + $1 | 0];
      if (!(($2 | 0) != 92 & ($2 | 0) != 34)) {
       $13 = $2;
       break label$5;
      }
      if ($2 >>> 0 > 31) {
       $13 = $2;
       break label$4;
      }
      $13 = HEAPU8[$2 + 51120 | 0];
      if ($13) {
       break label$5;
      }
      $8 = HEAP32[$0 + 8 >> 2];
      $15 = $8;
      $5 = HEAP32[$0 + 12 >> 2];
      $16 = $5;
      $8 = HEAP32[$0 + 20 >> 2];
      $12 = $8;
      $5 = HEAP32[$0 + 16 >> 2];
      $9 = $5;
      $6 = $10;
      $4 = $18;
      $3 = $6 + $4 | 0;
      $8 = $11;
      $5 = $19;
      $7 = $8 + $5 | 0;
      $7 = $3 >>> 0 < $4 >>> 0 ? $7 + 1 | 0 : $7;
      $4 = $3;
      $8 = $9;
      $5 = $4 + $8 | 0;
      $6 = $7;
      $7 = $12;
      $3 = $6 + $7 | 0;
      $3 = $5 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
      $8 = $3;
      $3 = $16;
      $4 = $5;
      $7 = $15;
      if (($8 | 0) == ($3 | 0) & $4 >>> 0 > $7 >>> 0 | $3 >>> 0 < $8 >>> 0) {
       if (jsonGrow($0, $17 - $10 | 0)) {
        break label$1;
       }
       $3 = HEAP32[$0 + 20 >> 2];
       $12 = $3;
       $7 = HEAP32[$0 + 16 >> 2];
       $9 = $7;
      }
      $3 = $12;
      $4 = $9;
      $6 = $4 + 1 | 0;
      $5 = $6 ? $3 : $3 + 1 | 0;
      HEAP32[$0 + 16 >> 2] = $6;
      HEAP32[$0 + 20 >> 2] = $5;
      HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = 92;
      $5 = HEAP32[$0 + 16 >> 2];
      $9 = $5;
      $4 = HEAP32[$0 + 20 >> 2];
      $3 = $9;
      $7 = $3 + 1 | 0;
      $6 = $7 ? $4 : $4 + 1 | 0;
      HEAP32[$0 + 16 >> 2] = $7;
      HEAP32[$0 + 20 >> 2] = $6;
      HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = 117;
      $6 = HEAP32[$0 + 16 >> 2];
      $9 = $6;
      $3 = HEAP32[$0 + 20 >> 2];
      $4 = $9;
      $5 = $4 + 1 | 0;
      $7 = $5 ? $3 : $3 + 1 | 0;
      HEAP32[$0 + 16 >> 2] = $5;
      HEAP32[$0 + 20 >> 2] = $7;
      HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = 48;
      $7 = HEAP32[$0 + 16 >> 2];
      $9 = $7;
      $4 = HEAP32[$0 + 20 >> 2];
      $3 = $9;
      $6 = $3 + 1 | 0;
      $5 = $6 ? $4 : $4 + 1 | 0;
      HEAP32[$0 + 16 >> 2] = $6;
      HEAP32[$0 + 20 >> 2] = $5;
      HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = 48;
      $5 = HEAP32[$0 + 16 >> 2];
      $9 = $5;
      $3 = HEAP32[$0 + 20 >> 2];
      $4 = $9;
      $7 = $4 + 1 | 0;
      $6 = $7 ? $3 : $3 + 1 | 0;
      HEAP32[$0 + 16 >> 2] = $7;
      HEAP32[$0 + 20 >> 2] = $6;
      HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = $2 >>> 4 | 48;
      $13 = HEAPU8[($2 & 15) + 12092 | 0];
      break label$4;
     }
     $6 = HEAP32[$0 + 16 >> 2];
     $10 = $6;
     $4 = HEAP32[$0 + 20 >> 2];
     $3 = $10;
     $5 = $3 + 1 | 0;
     $7 = $5 ? $4 : $4 + 1 | 0;
     HEAP32[$0 + 16 >> 2] = $5;
     HEAP32[$0 + 20 >> 2] = $7;
     HEAP8[$10 + HEAP32[$0 + 4 >> 2] | 0] = 34;
     break label$1;
    }
    $7 = HEAP32[$0 + 8 >> 2];
    $15 = $7;
    $3 = HEAP32[$0 + 12 >> 2];
    $16 = $3;
    $3 = HEAP32[$0 + 16 >> 2];
    $9 = $3;
    $7 = HEAP32[$0 + 20 >> 2];
    $12 = $7;
    $4 = $21;
    $8 = $10;
    $6 = $4 - $8 | 0;
    $2 = $6;
    $7 = $22;
    $3 = $11;
    $5 = $3 + ($4 >>> 0 < $8 >>> 0) | 0;
    $5 = $7 - $5 | 0;
    $4 = $5;
    $5 = $12;
    $6 = $4 + $5 | 0;
    $8 = $2;
    $7 = $9;
    $3 = $8 + $7 | 0;
    $6 = $3 >>> 0 < $8 >>> 0 ? $6 + 1 | 0 : $6;
    $7 = $6;
    $6 = $16;
    $5 = $15;
    if (($6 | 0) == ($7 | 0) & $3 >>> 0 > $5 >>> 0 | $6 >>> 0 < $7 >>> 0) {
     if (jsonGrow($0, $20 - $10 | 0)) {
      break label$1;
     }
     $6 = HEAP32[$0 + 20 >> 2];
     $12 = $6;
     $5 = HEAP32[$0 + 16 >> 2];
     $9 = $5;
    }
    $6 = $12;
    $3 = $6;
    $8 = $9;
    $4 = $8 + 1 | 0;
    $3 = $4 ? $3 : $3 + 1 | 0;
    HEAP32[$0 + 16 >> 2] = $4;
    HEAP32[$0 + 20 >> 2] = $3;
    HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = 92;
   }
   $3 = HEAP32[$0 + 16 >> 2];
   $9 = $3;
   $8 = HEAP32[$0 + 20 >> 2];
   $4 = $8;
   $6 = $9;
   $5 = $6 + 1 | 0;
   $4 = $5 ? $4 : $4 + 1 | 0;
   HEAP32[$0 + 16 >> 2] = $5;
   HEAP32[$0 + 20 >> 2] = $4;
   HEAP8[$9 + HEAP32[$0 + 4 >> 2] | 0] = $13;
   $4 = $11;
   $8 = $10;
   $3 = $8 + 1 | 0;
   $5 = $3 ? $4 : $4 + 1 | 0;
   $10 = $3;
   $11 = $5;
   continue;
  }
 }
}

function pager_playback($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $4 = HEAP32[$0 >> 2];
 HEAP32[$5 + 16 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 1;
 $3 = HEAP32[$0 + 168 >> 2];
 HEAP32[$5 + 8 >> 2] = $3;
 label$1: {
  label$2: {
   $2 = sqlite3OsFileSize(HEAP32[$0 + 68 >> 2], $5 + 24 | 0);
   if ($2) {
    break label$2;
   }
   $8 = HEAP32[$0 + 224 >> 2];
   $2 = readSuperJournal(HEAP32[$0 + 68 >> 2], $8, HEAP32[HEAP32[$0 >> 2] + 8 >> 2] + 1 | 0);
   label$3: {
    if ($2) {
     break label$3;
    }
    if (!HEAPU8[$8 | 0]) {
     $2 = 0;
     break label$3;
    }
    $2 = sqlite3OsAccess($4, $8, 0, $5 + 12 | 0);
   }
   $8 = 0;
   label$5: {
    label$6: {
     if (!HEAP32[$5 + 12 >> 2] | $2) {
      break label$6;
     }
     HEAP32[$0 + 80 >> 2] = 0;
     HEAP32[$0 + 84 >> 2] = 0;
     $14 = $0 + 80 | 0;
     $9 = $1;
     label$7: while (1) {
      $6 = HEAP32[$5 + 24 >> 2];
      $3 = HEAP32[$5 + 28 >> 2];
      $2 = readJournalHdr($0, $1, $6, $3, $5 + 20 | 0, $5 + 16 | 0);
      if ($2) {
       if (($2 | 0) == 101) {
        break label$5;
       }
       break label$2;
      }
      $10 = HEAP32[$5 + 20 >> 2];
      if (($10 | 0) == -1) {
       $6 = HEAP32[$5 + 28 >> 2];
       $7 = $6;
       $3 = HEAP32[$5 + 24 >> 2];
       $4 = $3;
       $6 = HEAP32[$0 + 156 >> 2];
       $2 = $3 - $6 | 0;
       $11 = $2;
       $3 = $7;
       $2 = $4 >>> 0 < $6 >>> 0;
       $2 = $3 - $2 | 0;
       $7 = $2;
       $2 = HEAP32[$0 + 168 >> 2];
       $3 = $2;
       $4 = HEAP32[$0 + 172 >> 2];
       $2 = $4;
       $6 = $3 + 8 | 0;
       $2 = $6 >>> 0 < 8 ? $2 + 1 | 0 : $2;
       $3 = $2;
       $2 = $7;
       $3 = __wasm_i64_sdiv($11, $2, $6, $3);
       $10 = $3;
       HEAP32[$5 + 20 >> 2] = $3;
      }
      label$10: {
       if ($1 | $10) {
        $2 = HEAP32[$0 + 156 >> 2];
        $13 = $2;
        $3 = HEAP32[$0 + 80 >> 2];
        $12 = $3;
        $2 = HEAP32[$0 + 84 >> 2];
        $11 = $2;
        break label$10;
       }
       $2 = HEAP32[$0 + 156 >> 2];
       $13 = $2;
       $2 = HEAP32[$0 + 92 >> 2];
       $6 = $2;
       $4 = $13;
       $3 = HEAP32[$0 + 88 >> 2];
       $7 = $3;
       $2 = $4 + $3 | 0;
       $3 = $6;
       $12 = $2;
       $6 = $7 >>> 0 > $2 >>> 0 ? $3 + 1 | 0 : $3;
       $11 = $6;
       $6 = HEAP32[$0 + 80 >> 2];
       $3 = $6;
       $7 = $6;
       $4 = HEAP32[$0 + 84 >> 2];
       $6 = $4;
       $6 = $4;
       $4 = $11;
       if (($7 | 0) != ($2 | 0) | ($6 | 0) != ($4 | 0)) {
        $12 = $3;
        $2 = $6;
        $11 = $2;
        break label$10;
       }
       $2 = HEAP32[$5 + 24 >> 2];
       $7 = $2;
       $6 = $12;
       $3 = $2 - $6 | 0;
       $10 = $3;
       $4 = HEAP32[$5 + 28 >> 2];
       $2 = $11;
       $2 = $2 + ($6 >>> 0 > $7 >>> 0) | 0;
       $2 = $4 - $2 | 0;
       $6 = $2;
       $2 = HEAP32[$0 + 168 >> 2];
       $4 = $2;
       $7 = HEAP32[$0 + 172 >> 2];
       $3 = $7;
       $2 = $4 + 8 | 0;
       $3 = $2 >>> 0 < 8 ? $3 + 1 | 0 : $3;
       $4 = $3;
       $3 = $6;
       $4 = __wasm_i64_sdiv($10, $3, $2, $4);
       $10 = $4;
       HEAP32[$5 + 20 >> 2] = $4;
      }
      $6 = $13;
      $7 = $12;
      $3 = $11;
      label$13: {
       if (($6 | 0) != ($7 | 0) | $3) {
        break label$13;
       }
       $4 = HEAP32[$5 + 16 >> 2];
       $2 = pager_truncate($0, $4);
       if ($2) {
        break label$2;
       }
       HEAP32[$0 + 28 >> 2] = $4;
       if (HEAPU32[$0 + 160 >> 2] >= $4 >>> 0) {
        break label$13;
       }
       HEAP32[$0 + 160 >> 2] = $4;
      }
      $3 = $8 + $10 | 0;
      $4 = 0;
      while (1) {
       if (($4 | 0) == ($10 | 0)) {
        $8 = $3;
        continue label$7;
       }
       if ($9) {
        pager_reset($0);
       }
       label$17: {
        $2 = pager_playback_one_page($0, $14, 0, 1, 0);
        if ($2) {
         if (($2 | 0) == 101) {
          break label$17;
         }
         if (($2 | 0) == 522) {
          break label$5;
         }
         break label$6;
        }
        $4 = $4 + 1 | 0;
        $8 = $8 + 1 | 0;
        $9 = 0;
        continue;
       }
       break;
      }
      $3 = HEAP32[$5 + 28 >> 2];
      $7 = HEAP32[$5 + 24 >> 2];
      $2 = $7;
      $7 = $14;
      HEAP32[$7 >> 2] = $2;
      HEAP32[$7 + 4 >> 2] = $3;
      $9 = 0;
      continue;
     }
    }
    if ($2) {
     break label$2;
    }
   }
   $2 = sqlite3PagerSetPagesize($0, $5 + 8 | 0, -1);
   HEAP8[$0 + 19 | 0] = HEAPU8[$0 + 12 | 0];
   if ($2) {
    break label$1;
   }
   $9 = HEAP32[$0 + 224 >> 2];
   $4 = $9 + 4 | 0;
   $2 = readSuperJournal(HEAP32[$0 + 68 >> 2], $4, HEAP32[HEAP32[$0 >> 2] + 8 >> 2] + 1 | 0);
   if ($2) {
    break label$1;
   }
   if ((HEAPU8[$0 + 17 | 0] - 4 & 255) >>> 0 <= 252) {
    $2 = sqlite3PagerSync($0, 0);
    if ($2) {
     break label$1;
    }
   }
   $2 = pager_end_transaction($0, HEAPU8[$4 | 0] != 0, 0);
   if ($2) {
    break label$1;
   }
   if (!(!HEAPU8[$4 | 0] | !HEAP32[$5 + 12 >> 2])) {
    HEAP8[$9 | 0] = 0;
    HEAP8[$9 + 1 | 0] = 0;
    HEAP8[$9 + 2 | 0] = 0;
    HEAP8[$9 + 3 | 0] = 0;
    $2 = pager_delsuper($0, $4);
    break label$1;
   }
   $2 = 0;
   break label$1;
  }
  HEAP8[$0 + 19 | 0] = HEAPU8[$0 + 12 | 0];
 }
 if (!(!$1 | !$8)) {
  HEAP32[$5 + 4 >> 2] = HEAP32[$0 + 188 >> 2];
  HEAP32[$5 >> 2] = $8;
  sqlite3_log(539, 6297, $5);
 }
 setSectorSize($0);
 __stack_pointer = $5 + 32 | 0;
 return $2;
}

function codeEqualityTerm($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 $14 = HEAP32[$0 + 8 >> 2];
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        $8 = HEAP32[$1 >> 2];
        $10 = HEAPU8[$8 | 0];
        switch ($10 - 50 | 0) {
        case 1:
        case 2:
         break label$4;

        case 0:
         break label$5;

        case 3:
         break label$6;

        default:
         break label$7;
        }
       }
       if (($10 | 0) != 45) {
        break label$4;
       }
      }
      $5 = sqlite3ExprCodeTarget($0, HEAP32[$8 + 16 >> 2], $5);
      break label$3;
     }
     sqlite3VdbeAddOp2($14, 75, 0, $5);
     break label$3;
    }
    $9 = HEAP32[$2 + 80 >> 2];
    label$8: {
     if (HEAPU8[$9 + 41 | 0] & 4) {
      break label$8;
     }
     $10 = HEAP32[$9 + 32 >> 2];
     if (!$10 | !HEAPU8[HEAP32[$10 + 28 >> 2] + $3 | 0]) {
      break label$8;
     }
     $4 = !$4;
    }
    $10 = 0;
    $7 = ($3 | 0) > 0 ? $3 : 0;
    while (1) {
     label$10: {
      if (($7 | 0) == ($10 | 0)) {
       $6 = HEAPU16[$9 + 44 >> 1];
       $11 = ($3 | 0) > ($6 | 0) ? $3 : $6;
       $7 = 0;
       $6 = $3;
       while (1) {
        if (($6 | 0) == ($11 | 0)) {
         break label$10;
        }
        $7 = (HEAP32[HEAP32[HEAP32[$9 + 52 >> 2] + ($6 << 2) >> 2] >> 2] == ($8 | 0)) + $7 | 0;
        $6 = $6 + 1 | 0;
        continue;
       }
      }
      $6 = HEAP32[HEAP32[$9 + 52 >> 2] + ($10 << 2) >> 2];
      if (HEAP32[$6 >> 2] == ($8 | 0) ? $6 : 0) {
       break label$2;
      }
      $10 = $10 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP32[$12 + 12 >> 2] = 0;
    $6 = HEAP32[$8 + 4 >> 2];
    label$14: {
     if (!(HEAP32[HEAP32[HEAP32[$8 + 20 >> 2] + 28 >> 2] >> 2] != 1 ? $6 & 4096 : 0)) {
      $11 = sqlite3FindInIndex($0, $8, 4, 0, 0, $12 + 12 | 0);
      break label$14;
     }
     if (!($6 & 33554432 ? HEAP32[$8 + 28 >> 2] : 0)) {
      $6 = HEAP32[$0 >> 2];
      $13 = removeUnindexableInClauseTerms($0, $3, $9, $8);
      label$18: {
       if (HEAPU8[$6 + 87 | 0]) {
        $11 = 5;
        break label$18;
       }
       $15 = sqlite3DbMallocZero(HEAP32[$0 >> 2], $7 << 2, 0);
       $11 = sqlite3FindInIndex($0, $13, 4, 0, $15, $12 + 12 | 0);
       HEAP32[$8 + 28 >> 2] = HEAP32[$12 + 12 >> 2];
      }
      sqlite3ExprDelete($6, $13);
      break label$14;
     }
     $16 = HEAP32[$0 >> 2];
     $6 = sqlite3ExprVectorSize(HEAP32[$8 + 12 >> 2]);
     $15 = sqlite3DbMallocZero($16, (($6 | 0) < ($7 | 0) ? $7 : $6) << 2, 0);
     $11 = sqlite3FindInIndex($0, $8, 4, 0, $15, $12 + 12 | 0);
    }
    $4 = ($11 | 0) == 4 ? !$4 : $4;
    sqlite3VdbeAddOp2($14, $4 ? 31 : 35, HEAP32[$12 + 12 >> 2], 0);
    HEAP32[$9 + 40 >> 2] = HEAP32[$9 + 40 >> 2] | 2048;
    if (!HEAP32[$2 + 72 >> 2]) {
     HEAP32[$2 + 16 >> 2] = sqlite3VdbeMakeLabel($0);
    }
    label$21: {
     if (($3 | 0) <= 0) {
      break label$21;
     }
     $6 = HEAP32[$9 + 40 >> 2];
     if ($6 & 1048576) {
      break label$21;
     }
     HEAP32[$9 + 40 >> 2] = $6 | 262144;
    }
    $13 = HEAP32[$2 + 72 >> 2];
    $7 = $13 + $7 | 0;
    HEAP32[$2 + 72 >> 2] = $7;
    $7 = sqlite3WhereRealloc(HEAP32[HEAP32[$1 + 4 >> 2] >> 2], HEAP32[$2 + 76 >> 2], Math_imul($7, 20), 0);
    HEAP32[$2 + 76 >> 2] = $7;
    label$22: {
     if ($7) {
      $19 = $4 ? 37 : 38;
      $17 = $5 - $3 | 0;
      $7 = Math_imul($13, 20) + $7 | 0;
      $16 = ($11 | 0) != 1;
      $6 = $3;
      while (1) {
       if (($6 | 0) < HEAPU16[$9 + 44 >> 1]) {
        if (HEAP32[HEAP32[HEAP32[$9 + 52 >> 2] + ($6 << 2) >> 2] >> 2] == ($8 | 0)) {
         $11 = $6 + $17 | 0;
         label$27: {
          if (!$16) {
           $13 = HEAP32[$12 + 12 >> 2];
           $4 = sqlite3VdbeAddOp2($14, 135, $13, $11);
           break label$27;
          }
          label$29: {
           if (!$15) {
            $4 = 0;
            break label$29;
           }
           $4 = HEAP32[($18 << 2) + $15 >> 2];
           $18 = $18 + 1 | 0;
          }
          $13 = HEAP32[$12 + 12 >> 2];
          $4 = sqlite3VdbeAddOp3($14, 94, $13, $4, $11);
         }
         HEAP32[$7 + 4 >> 2] = $4;
         sqlite3VdbeAddOp1($14, 50, $11);
         label$31: {
          if (($3 | 0) == ($6 | 0)) {
           HEAP8[$7 + 16 | 0] = $19;
           HEAP32[$7 >> 2] = $13;
           if (($3 | 0) > 0) {
            HEAP32[$7 + 12 >> 2] = $3;
            HEAP32[$7 + 8 >> 2] = $17;
            break label$31;
           }
           HEAP32[$7 + 12 >> 2] = 0;
           break label$31;
          }
          HEAP8[$7 + 16 | 0] = 184;
         }
         $7 = $7 + 20 | 0;
        }
        $6 = $6 + 1 | 0;
        continue;
       }
       break;
      }
      if (HEAP32[$9 + 40 >> 2] & 1049600 | ($3 | 0) <= 0) {
       break label$22;
      }
      sqlite3VdbeAddOp3($14, 125, HEAP32[$2 + 8 >> 2], 0, $3);
      break label$22;
     }
     HEAP32[$2 + 72 >> 2] = 0;
    }
    sqlite3DbFree(HEAP32[$0 >> 2], $15);
    if (($3 | 0) > ($10 | 0)) {
     break label$1;
    }
   }
   if (!(HEAPU8[HEAP32[$2 + 80 >> 2] + 42 | 0] & 32)) {
    break label$2;
   }
   if (HEAPU8[$1 + 13 | 0] & 8) {
    break label$1;
   }
  }
  disableTerm($2, $1);
 }
 __stack_pointer = $12 + 16 | 0;
 return $5;
}

function fkActionTrigger($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 $7 = ($3 | 0) != 0;
 $8 = HEAPU8[($7 + $2 | 0) + 25 | 0];
 $4 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$4 + 34 | 0] & 8 ? ($8 | 0) == 7 : 0) {
   break label$1;
  }
  $15 = ($7 << 2) + $2 | 0;
  $5 = HEAP32[$15 + 28 >> 2];
  if ($5 | !$8) {
   break label$1;
  }
  HEAP32[$6 + 44 >> 2] = 0;
  HEAP32[$6 + 40 >> 2] = 0;
  label$3: {
   if (!sqlite3FkLocateIndex($0, $1, $2, $6 + 44 | 0, $6 + 40 | 0)) {
    $16 = (($3 | 0) != 0 | ($8 | 0) != 10) & ($8 | 0) != 7;
    $17 = $1 + 32 | 0;
    $18 = $2 + 36 | 0;
    $19 = HEAP32[12300];
    $20 = HEAP32[12301];
    $21 = HEAP32[12298];
    $22 = HEAP32[12299];
    $12 = HEAP32[$6 + 44 >> 2];
    $23 = $8 - 9 | 0;
    $5 = 0;
    while (1) {
     if (HEAP32[$2 + 20 >> 2] > ($5 | 0)) {
      HEAP32[$6 + 32 >> 2] = $21;
      HEAP32[$6 + 36 >> 2] = $22;
      HEAP32[$6 + 24 >> 2] = $19;
      HEAP32[$6 + 28 >> 2] = $20;
      $7 = HEAP32[$6 + 40 >> 2];
      $9 = HEAP32[($7 ? $7 + ($5 << 2) | 0 : $18) >> 2];
      $7 = $17;
      $13 = HEAP32[$1 + 4 >> 2];
      $7 = $12 ? HEAP32[$12 + 4 >> 2] + ($5 << 1) | 0 : $7;
      sqlite3TokenInit($6 + 8 | 0, HEAP32[$13 + Math_imul(HEAP16[$7 >> 1], 12) >> 2]);
      $7 = Math_imul($9, 12);
      sqlite3TokenInit($6 + 16 | 0, HEAP32[$7 + HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
      $10 = sqlite3ExprAnd($0, $10, sqlite3PExpr($0, 53, sqlite3PExpr($0, 141, sqlite3ExprAlloc($4, 59, $6 + 32 | 0, 0), sqlite3ExprAlloc($4, 59, $6 + 8 | 0, 0)), sqlite3ExprAlloc($4, 59, $6 + 16 | 0, 0)));
      if ($3) {
       $11 = sqlite3ExprAnd($0, $11, sqlite3PExpr($0, 45, sqlite3PExpr($0, 141, sqlite3ExprAlloc($4, 59, $6 + 32 | 0, 0), sqlite3ExprAlloc($4, 59, $6 + 8 | 0, 0)), sqlite3PExpr($0, 141, sqlite3ExprAlloc($4, 59, $6 + 24 | 0, 0), sqlite3ExprAlloc($4, 59, $6 + 8 | 0, 0))));
      }
      if ($16) {
       label$10: {
        label$11: {
         label$12: {
          switch ($23 | 0) {
          case 1:
           $7 = sqlite3PExpr($0, 141, sqlite3ExprAlloc($4, 59, $6 + 24 | 0, 0), sqlite3ExprAlloc($4, 59, $6 + 8 | 0, 0));
           break label$10;

          case 0:
           break label$12;

          default:
           break label$11;
          }
         }
         $9 = HEAP32[$2 >> 2];
         $7 = HEAP32[$9 + 4 >> 2] + $7 | 0;
         if (HEAPU8[$7 + 10 | 0] & 96) {
          break label$11;
         }
         $7 = sqlite3ColumnExpr($9, $7);
         if (!$7) {
          break label$11;
         }
         $7 = sqlite3ExprDup($4, $7, 0);
         break label$10;
        }
        $7 = sqlite3ExprAlloc($4, 121, 0, 0);
       }
       $14 = sqlite3ExprListAppend($0, $14, $7);
       sqlite3ExprListSetName($0, $14, $6 + 16 | 0, 0);
      }
      $5 = $5 + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3DbFree($4, HEAP32[$6 + 40 >> 2]);
    $7 = 0;
    $13 = HEAP32[HEAP32[$2 >> 2] >> 2];
    $2 = sqlite3Strlen30($13);
    label$14: {
     if (($8 | 0) != 7) {
      break label$14;
     }
     $5 = sqlite3SchemaToIndex($4, HEAP32[$1 + 60 >> 2]);
     HEAP32[$6 + 36 >> 2] = $2;
     HEAP32[$6 + 32 >> 2] = $13;
     $5 = HEAP32[HEAP32[$4 + 16 >> 2] + ($5 << 4) >> 2];
     HEAP32[$6 + 24 >> 2] = $5;
     HEAP32[$6 + 28 >> 2] = sqlite3Strlen30($5);
     $5 = sqlite3Expr($4, 71, 15341);
     if ($5) {
      HEAP8[$5 + 1 | 0] = 2;
     }
     $24 = sqlite3SelectNew($0, sqlite3ExprListAppend($0, 0, $5), sqlite3SrcListAppend($0, 0, $6 + 24 | 0, $6 + 32 | 0), $10, 0, 0, 0, 0, 0);
     $10 = 0;
    }
    $9 = $10;
    $10 = $24;
    HEAP16[$4 + 308 >> 1] = 0;
    HEAP32[$4 + 304 >> 2] = HEAP32[$4 + 304 >> 2] + 1;
    $5 = sqlite3DbMallocZero($4, $2 + 85 | 0, 0);
    label$17: {
     if (!$5) {
      break label$17;
     }
     $12 = $5 + 84 | 0;
     HEAP32[$5 + 48 >> 2] = $12;
     $7 = $5 + 36 | 0;
     HEAP32[$5 + 28 >> 2] = $7;
     __memcpy($12, $13, $2);
     HEAP32[$5 + 56 >> 2] = sqlite3ExprDup($4, $9, 1);
     HEAP32[$5 + 60 >> 2] = sqlite3ExprListDup($4, $14, 1);
     HEAP32[$5 + 44 >> 2] = sqlite3SelectDup($4, $10, 1);
     if (!$11) {
      $11 = 0;
      break label$17;
     }
     $11 = sqlite3PExpr($0, 19, $11, 0);
     HEAP32[$5 + 12 >> 2] = sqlite3ExprDup($4, $11, 1);
    }
    $2 = HEAP32[$4 + 304 >> 2] - 1 | 0;
    HEAP32[$4 + 304 >> 2] = $2;
    $0 = 0;
    $0 = $2 ? $0 : HEAPU16[$4 + 310 >> 1];
    HEAP16[$4 + 308 >> 1] = $0;
    sqlite3ExprDelete($4, $9);
    sqlite3ExprDelete($4, $11);
    sqlite3ExprListDelete($4, $14);
    sqlite3SelectDelete($4, $10);
    if (HEAPU8[$4 + 87 | 0] != 1) {
     break label$3;
    }
    fkTriggerDelete($4, $5);
   }
   $5 = 0;
   break label$1;
  }
  $0 = 138;
  label$20: {
   label$21: {
    label$22: {
     switch ($8 - 7 | 0) {
     case 0:
      break label$20;

     case 3:
      break label$22;

     default:
      break label$21;
     }
    }
    if ($3) {
     break label$21;
    }
    $0 = 128;
    break label$20;
   }
   $0 = 129;
  }
  HEAP32[$7 + 4 >> 2] = $5;
  HEAP8[$7 | 0] = $0;
  $0 = HEAP32[$1 + 60 >> 2];
  HEAP32[$5 + 24 >> 2] = $0;
  HEAP32[$5 + 20 >> 2] = $0;
  HEAP32[$15 + 28 >> 2] = $5;
  HEAP8[$5 + 8 | 0] = $3 ? -127 : -128;
 }
 __stack_pointer = $6 + 48 | 0;
 return $5;
}

function whereLoopAddOr($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 $5 = __stack_pointer - 608 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$0 >> 2];
 $16 = HEAP32[$0 + 4 >> 2];
 $14 = HEAP32[$16 + 24 >> 2];
 $8 = HEAP32[$16 + 12 >> 2];
 $10 = HEAP32[$0 + 8 >> 2];
 memset($5 + 112 | 0, 0, 56);
 label$1: {
  $6 = (HEAP32[$6 + 4 >> 2] + 8 | 0) + (HEAPU8[$10 + 16 | 0] << 6) | 0;
  if (HEAPU8[$6 + 36 | 0] & 16) {
   break label$1;
  }
  $19 = HEAP32[$6 + 40 >> 2];
  $20 = Math_imul($8, 48) + $14 | 0;
  $21 = $6;
  while (1) {
   if ($14 >>> 0 >= $20 >>> 0 | $12) {
    break label$1;
   }
   $12 = 0;
   label$3: {
    if (!(HEAPU8[$14 + 13 | 0] & 2)) {
     break label$3;
    }
    $9 = HEAP32[$10 + 8 >> 2];
    $11 = $9;
    $7 = HEAP32[$10 + 12 >> 2];
    $8 = $7;
    $6 = HEAP32[$14 + 24 >> 2];
    $7 = HEAP32[$6 + 416 >> 2];
    $18 = $7;
    $9 = HEAP32[$6 + 420 >> 2];
    $7 = $9;
    $9 = $8;
    $7 = $9 & $7;
    if (!($7 | $18 & $11)) {
     break label$3;
    }
    $13 = HEAP32[$6 + 24 >> 2];
    $6 = HEAP32[$6 + 12 >> 2];
    $9 = $0;
    $7 = HEAP32[$9 + 8 >> 2];
    $11 = HEAP32[$9 + 12 >> 2];
    HEAP32[$5 + 176 >> 2] = $7;
    HEAP32[$5 + 180 >> 2] = $11;
    $7 = HEAP32[$9 + 20 >> 2];
    $11 = HEAP32[$9 + 16 >> 2];
    HEAP32[$5 + 184 >> 2] = $11;
    HEAP32[$5 + 188 >> 2] = $7;
    $11 = HEAP32[$9 + 4 >> 2];
    $7 = HEAP32[$9 >> 2];
    HEAP32[$5 + 168 >> 2] = $7;
    HEAP32[$5 + 172 >> 2] = $11;
    $22 = Math_imul($6, 48) + $13 | 0;
    HEAP32[$5 + 180 >> 2] = $5 + 56;
    $6 = 1;
    while (1) {
     label$5: {
      label$6: {
       label$7: {
        if ($13 >>> 0 < $22 >>> 0) {
         if (HEAPU8[$13 + 13 | 0] & 4) {
          $8 = HEAP32[$13 + 24 >> 2];
         } else {
          if (HEAP32[$13 + 20 >> 2] != ($19 | 0)) {
           break label$5;
          }
          $8 = HEAP32[$16 >> 2];
          HEAP32[$5 + 216 >> 2] = $13;
          HEAP32[$5 + 212 >> 2] = 1;
          HEAP32[$5 + 204 >> 2] = 1;
          HEAP8[$5 + 200 | 0] = 44;
          HEAP32[$5 + 196 >> 2] = $16;
          HEAP32[$5 + 192 >> 2] = $8;
          $8 = $5 + 192 | 0;
         }
         HEAP16[$5 + 56 >> 1] = 0;
         HEAP32[$5 + 172 >> 2] = $8;
         label$11: {
          if (HEAPU8[HEAP32[$21 + 16 >> 2] + 43 | 0] == 1) {
           $11 = $2;
           $7 = $4;
           $12 = whereLoopAddVirtual($5 + 168 | 0, $1, $11, $3, $7);
           break label$11;
          }
          $7 = $2;
          $12 = whereLoopAddBtree($5 + 168 | 0, $1, $7);
         }
         if (!$12) {
          $7 = $2;
          $11 = $4;
          $12 = whereLoopAddOr($5 + 168 | 0, $1, $7, $3, $11);
         }
         $8 = HEAPU16[$5 + 56 >> 1];
         if (!$8) {
          HEAP16[$5 + 112 >> 1] = 0;
          $8 = 0;
          break label$7;
         }
         if ($6) {
          whereOrMove($5 + 112 | 0, $5 + 56 | 0);
          break label$6;
         }
         whereOrMove($5, $5 + 112 | 0);
         $17 = 0;
         HEAP16[$5 + 112 >> 1] = 0;
         $23 = HEAPU16[$5 >> 1];
         while (1) {
          if (($17 | 0) == ($23 | 0)) {
           break label$6;
          }
          $6 = ($17 << 4) + $5 | 0;
          $15 = $6;
          $15 = $6;
          $15 = $6;
          $6 = 0;
          while (1) {
           if ($6 >>> 0 < ($8 & 65535) >>> 0) {
            $8 = ($5 + 56 | 0) + ($6 << 4) | 0;
            $9 = $8;
            $11 = HEAP32[$9 + 8 >> 2];
            $18 = $11;
            $7 = HEAP32[$9 + 12 >> 2];
            $24 = $7;
            $9 = $15;
            $7 = HEAP32[$9 + 8 >> 2];
            $11 = HEAP32[$9 + 12 >> 2];
            $9 = $18;
            $9 = $7 | $9;
            $7 = $11;
            $11 = $24;
            $7 = $7 | $11;
            whereOrInsert($5 + 112 | 0, $9, $7, sqlite3LogEstAdd(HEAP16[$15 + 16 >> 1], HEAP16[$8 + 16 >> 1]), sqlite3LogEstAdd(HEAP16[$15 + 18 >> 1], HEAP16[$8 + 18 >> 1]));
            $6 = $6 + 1 | 0;
            $8 = HEAPU16[$5 + 56 >> 1];
            continue;
           }
           break;
          }
          $17 = $17 + 1 | 0;
          continue;
         }
        }
        $8 = HEAPU16[$5 + 112 >> 1];
       }
       HEAP16[$10 + 44 >> 1] = 1;
       HEAP32[HEAP32[$10 + 52 >> 2] >> 2] = $14;
       $6 = 0;
       HEAP16[$10 + 18 >> 1] = 0;
       HEAP32[$10 + 40 >> 2] = 8192;
       HEAP8[$10 + 17 | 0] = 0;
       HEAP32[$10 + 32 >> 2] = 0;
       HEAP32[$10 + 36 >> 2] = 0;
       HEAP32[$10 + 24 >> 2] = 0;
       HEAP32[$10 + 28 >> 2] = 0;
       $11 = $8 & 65535;
       while (1) {
        if ($6 >>> 0 >= $11 >>> 0 | $12) {
         break label$3;
        }
        $8 = ($5 + 112 | 0) + ($6 << 4) | 0;
        HEAP16[$10 + 20 >> 1] = HEAPU16[$8 + 16 >> 1] + 1;
        HEAP16[$10 + 22 >> 1] = HEAPU16[$8 + 18 >> 1];
        $9 = HEAP32[$8 + 12 >> 2];
        $7 = HEAP32[$8 + 8 >> 2];
        HEAP32[$10 >> 2] = $7;
        HEAP32[$10 + 4 >> 2] = $9;
        $6 = $6 + 1 | 0;
        $12 = whereLoopInsert($0, $10);
        continue;
       }
      }
      $6 = 0;
     }
     $13 = $13 + 48 | 0;
     continue;
    }
   }
   $14 = $14 + 48 | 0;
   continue;
  }
 }
 __stack_pointer = $5 + 608 | 0;
 return $12;
}

function __rem_pio2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 wasm2js_scratch_store_f64(+$0);
 $4 = wasm2js_scratch_load_i32(1) | 0;
 $11 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   $3 = $4;
   $8 = $4 & 2147483647;
   label$3: {
    if ($8 >>> 0 <= 1074752122) {
     if (($3 & 1048575) == 598523) {
      break label$3;
     }
     if ($8 >>> 0 <= 1073928572) {
      if (($4 | 0) > 0 | ($4 | 0) >= 0) {
       $0 = $0 + -1.5707963267341256;
       $2 = $0 + -6077100506506192e-26;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -6077100506506192e-26;
       $3 = 1;
       break label$1;
      }
      $0 = $0 + 1.5707963267341256;
      $2 = $0 + 6077100506506192e-26;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 6077100506506192e-26;
      $3 = -1;
      break label$1;
     }
     if (($4 | 0) > 0 | ($4 | 0) >= 0) {
      $0 = $0 + -3.1415926534682512;
      $2 = $0 + -1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.2154201013012384e-10;
      $3 = 2;
      break label$1;
     }
     $0 = $0 + 3.1415926534682512;
     $2 = $0 + 1.2154201013012384e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.2154201013012384e-10;
     $3 = -2;
     break label$1;
    }
    if ($8 >>> 0 <= 1075594811) {
     if ($8 >>> 0 <= 1075183036) {
      if (($8 | 0) == 1074977148) {
       break label$3;
      }
      if (($4 | 0) > 0 | ($4 | 0) >= 0) {
       $0 = $0 + -4.712388980202377;
       $2 = $0 + -1.8231301519518578e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.8231301519518578e-10;
       $3 = 3;
       break label$1;
      }
      $0 = $0 + 4.712388980202377;
      $2 = $0 + 1.8231301519518578e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.8231301519518578e-10;
      $3 = -3;
      break label$1;
     }
     if (($8 | 0) == 1075388923) {
      break label$3;
     }
     if (($4 | 0) > 0 | ($4 | 0) >= 0) {
      $0 = $0 + -6.2831853069365025;
      $2 = $0 + -2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + -2.430840202602477e-10;
      $3 = 4;
      break label$1;
     }
     $0 = $0 + 6.2831853069365025;
     $2 = $0 + 2.430840202602477e-10;
     HEAPF64[$1 >> 3] = $2;
     HEAPF64[$1 + 8 >> 3] = $0 - $2 + 2.430840202602477e-10;
     $3 = -4;
     break label$1;
    }
    if ($8 >>> 0 > 1094263290) {
     break label$2;
    }
   }
   $2 = $0 * .6366197723675814 + 6755399441055744 + -6755399441055744;
   $6 = $0 + $2 * -1.5707963267341256;
   $10 = $2 * 6077100506506192e-26;
   $12 = $6 - $10;
   $9 = $12 < -.7853981633974483;
   if (Math_abs($2) < 2147483648) {
    $3 = ~~$2;
   } else {
    $3 = -2147483648;
   }
   label$14: {
    if ($9) {
     $3 = $3 - 1 | 0;
     $2 = $2 + -1;
     $10 = $2 * 6077100506506192e-26;
     $6 = $0 + $2 * -1.5707963267341256;
     break label$14;
    }
    if (!($12 > .7853981633974483)) {
     break label$14;
    }
    $3 = $3 + 1 | 0;
    $2 = $2 + 1;
    $10 = $2 * 6077100506506192e-26;
    $6 = $0 + $2 * -1.5707963267341256;
   }
   $0 = $6 - $10;
   HEAPF64[$1 >> 3] = $0;
   wasm2js_scratch_store_f64(+$0);
   $5 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $9 = $8 >>> 20 | 0;
   label$16: {
    if (($9 - ($5 >>> 20 & 2047) | 0) < 17) {
     break label$16;
    }
    $0 = $2 * 6077100506303966e-26;
    $12 = $6 - $0;
    $10 = $2 * 20222662487959506e-37 - ($6 - $12 - $0);
    $0 = $12 - $10;
    HEAPF64[$1 >> 3] = $0;
    wasm2js_scratch_store_f64(+$0);
    $5 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    if (($9 - ($5 >>> 20 & 2047) | 0) < 50) {
     $6 = $12;
     break label$16;
    }
    $0 = $2 * 20222662487111665e-37;
    $6 = $12 - $0;
    $10 = $2 * 84784276603689e-45 - ($12 - $6 - $0);
    $0 = $6 - $10;
    HEAPF64[$1 >> 3] = $0;
   }
   HEAPF64[$1 + 8 >> 3] = $6 - $0 - $10;
   break label$1;
  }
  if ($8 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   HEAPF64[$1 >> 3] = $0;
   HEAPF64[$1 + 8 >> 3] = $0;
   $3 = 0;
   break label$1;
  }
  $5 = $4 & 1048575;
  wasm2js_scratch_store_i32(0, $11 | 0);
  $5 = $5 | 1096810496;
  wasm2js_scratch_store_i32(1, $5 | 0);
  $0 = +wasm2js_scratch_load_f64();
  $3 = 0;
  $9 = 1;
  while (1) {
   $3 = ($7 + 16 | 0) + ($3 << 3) | 0;
   if (Math_abs($0) < 2147483648) {
    $5 = ~~$0;
   } else {
    $5 = -2147483648;
   }
   $2 = +($5 | 0);
   HEAPF64[$3 >> 3] = $2;
   $0 = ($0 - $2) * 16777216;
   $3 = 1;
   $5 = $9 & 1;
   $9 = 0;
   if ($5) {
    continue;
   }
   break;
  }
  HEAPF64[$7 + 32 >> 3] = $0;
  $3 = 2;
  while (1) {
   $9 = $3;
   $3 = $3 - 1 | 0;
   if (HEAPF64[($7 + 16 | 0) + ($9 << 3) >> 3] == 0) {
    continue;
   }
   break;
  }
  $3 = __rem_pio2_large($7 + 16 | 0, $7, ($8 >>> 20 | 0) - 1046 | 0, $9 + 1 | 0, 1);
  $0 = HEAPF64[$7 >> 3];
  if (($4 | 0) < 0) {
   HEAPF64[$1 >> 3] = -$0;
   HEAPF64[$1 + 8 >> 3] = -HEAPF64[$7 + 8 >> 3];
   $3 = 0 - $3 | 0;
   break label$1;
  }
  HEAPF64[$1 >> 3] = $0;
  HEAPF64[$1 + 8 >> 3] = HEAPF64[$7 + 8 >> 3];
 }
 __stack_pointer = $7 + 48 | 0;
 return $3;
}

function resolveSelectStep($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $9 = 1;
 $2 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if ($2 & 4) {
   break label$1;
  }
  $5 = HEAP32[$0 >> 2];
  $7 = HEAP32[$0 + 24 >> 2];
  if (!($2 & 64)) {
   sqlite3SelectPrep($5, $1, $7);
   $9 = HEAP32[$5 + 36 >> 2] ? 2 : 1;
   break label$1;
  }
  $10 = HEAP32[$1 + 52 >> 2];
  $11 = HEAP32[$5 >> 2];
  $12 = $4 | 4;
  $2 = $1;
  while (1) {
   if ($2) {
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 4;
    $0 = $12;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    $0 = $12;
    HEAP32[$0 + 8 >> 2] = 0;
    HEAP32[$0 + 12 >> 2] = 0;
    HEAP32[$0 >> 2] = 0;
    HEAP32[$0 + 4 >> 2] = 0;
    HEAP32[$4 + 28 >> 2] = $2;
    HEAP32[$4 >> 2] = $5;
    $9 = 2;
    if (sqlite3ResolveExprNames($4, HEAP32[$2 + 60 >> 2])) {
     break label$1;
    }
    if (HEAP8[$2 + 6 | 0] & 1) {
     HEAP32[HEAP32[HEAP32[$2 + 32 >> 2] + 28 >> 2] + 48 >> 2] = HEAP32[$2 + 48 >> 2];
     HEAP32[$2 + 48 >> 2] = 0;
    }
    $0 = 0;
    while (1) {
     $3 = HEAP32[$2 + 32 >> 2];
     if (HEAP32[$3 >> 2] > ($0 | 0)) {
      $6 = ($0 << 6) + $3 | 0;
      $3 = HEAP32[$6 + 28 >> 2];
      label$8: {
       if (!$3 | HEAPU8[$3 + 4 | 0] & 4) {
        break label$8;
       }
       $15 = $7 ? HEAP32[$7 + 16 >> 2] : 0;
       $8 = HEAP32[$5 + 248 >> 2];
       $13 = HEAP32[$6 + 16 >> 2];
       if ($13) {
        HEAP32[$5 + 248 >> 2] = $13;
       }
       sqlite3ResolveSelectNames($5, $3, $7);
       HEAP32[$5 + 248 >> 2] = $8;
       if (HEAP32[$5 + 36 >> 2]) {
        break label$1;
       }
       if (!$7) {
        break label$8;
       }
       $3 = $6 + 45 | 0;
       $6 = (HEAPU8[$6 + 45 | 0] | HEAPU8[$6 + 46 | 0] << 8) & 65527 | (HEAP32[$7 + 16 >> 2] > ($15 | 0)) << 3;
       HEAP8[$3 | 0] = $6;
       HEAP8[$3 + 1 | 0] = $6 >>> 8;
      }
      $0 = $0 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP32[$4 + 12 >> 2] = $7;
    HEAP32[$4 + 4 >> 2] = $3;
    HEAP32[$4 + 24 >> 2] = 16385;
    if (sqlite3ResolveExprListNames($4, HEAP32[$2 + 28 >> 2])) {
     break label$1;
    }
    $8 = HEAP32[$2 + 40 >> 2];
    $0 = HEAP32[$4 + 24 >> 2];
    label$12: {
     if ($0 & 16 ? 1 : $8) {
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | $0 & 134221824 | 8;
      $3 = $0 & -16385;
      break label$12;
     }
     $3 = $0 & -16386;
    }
    $0 = HEAP32[$2 + 28 >> 2];
    HEAP32[$4 + 24 >> 2] = $3 | 128;
    HEAP32[$4 + 8 >> 2] = $0;
    $0 = HEAP32[$2 + 44 >> 2];
    if ($0) {
     if (!(HEAPU8[$2 + 4 | 0] & 8)) {
      sqlite3ErrorMsg($5, 1193, 0);
      break label$1;
     }
     if (sqlite3ResolveExprNames($4, $0)) {
      break label$1;
     }
    }
    $0 = 0;
    if (sqlite3ResolveExprNames($4, HEAP32[$2 + 36 >> 2])) {
     break label$1;
    }
    while (1) {
     $3 = HEAP32[$2 + 32 >> 2];
     if (HEAP32[$3 >> 2] > ($0 | 0)) {
      $3 = ($0 << 6) + $3 | 0;
      if (HEAPU8[$3 + 45 | 0] & 4) {
       if (sqlite3ResolveExprListNames($4, HEAP32[$3 - -64 >> 2])) {
        break label$1;
       }
      }
      $0 = $0 + 1 | 0;
      continue;
     }
     break;
    }
    label$19: {
     if (HEAPU8[$5 + 208 | 0] < 2) {
      break label$19;
     }
     $3 = $2 + 72 | 0;
     while (1) {
      $0 = HEAP32[$3 >> 2];
      if (!$0) {
       break label$19;
      }
      if (sqlite3ResolveExprListNames($4, HEAP32[$0 + 12 >> 2])) {
       break label$1;
      }
      $3 = $0 + 36 | 0;
      if (!sqlite3ResolveExprListNames($4, HEAP32[$0 + 8 >> 2])) {
       continue;
      }
      break;
     }
     break label$1;
    }
    HEAP32[$4 + 12 >> 2] = 0;
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] | 16385;
    if (HEAP8[$2 + 6 | 0] & 1) {
     $0 = HEAP32[HEAP32[$2 + 32 >> 2] + 28 >> 2];
     HEAP32[$2 + 48 >> 2] = HEAP32[$0 + 48 >> 2];
     HEAP32[$0 + 48 >> 2] = 0;
    }
    $0 = HEAP32[$2 + 48 >> 2];
    if (!(!$0 | !$14 & ($10 | 0) != 0)) {
     if (resolveOrderGroupBy($4, $2, $0, 19018)) {
      break label$1;
     }
    }
    if (HEAPU8[$11 + 87 | 0]) {
     break label$1;
    }
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] & -16385;
    label$23: {
     if (!$8) {
      break label$23;
     }
     if (resolveOrderGroupBy($4, $2, $8, 19360) | HEAPU8[$11 + 87 | 0]) {
      break label$1;
     }
     $0 = 0;
     $3 = HEAP32[$8 >> 2];
     $6 = ($3 | 0) > 0 ? $3 : 0;
     $3 = $8 + 8 | 0;
     while (1) {
      if (($0 | 0) == ($6 | 0)) {
       break label$23;
      }
      if (HEAPU8[HEAP32[$3 >> 2] + 4 | 0] & 16) {
       sqlite3ErrorMsg($5, 12672, 0);
       break label$1;
      } else {
       $3 = $3 + 16 | 0;
       $0 = $0 + 1 | 0;
       continue;
      }
     }
    }
    $0 = HEAP32[$2 + 56 >> 2];
    if (!(!$0 | HEAP32[HEAP32[$2 + 28 >> 2] >> 2] == HEAP32[HEAP32[$0 + 28 >> 2] >> 2])) {
     sqlite3SelectWrongNumTermsError($5, $0);
     break label$1;
    }
    $14 = $14 + 1 | 0;
    $2 = HEAP32[$2 + 52 >> 2];
    continue;
   }
   break;
  }
  if ($10) {
   $9 = 2;
   if (resolveCompoundOrderBy($5, $1)) {
    break label$1;
   }
  }
  $9 = 1;
 }
 __stack_pointer = $4 + 32 | 0;
 return $9 | 0;
}

function allocateIndexInfo($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $6 = HEAP32[$1 + 12 >> 2];
 $10 = ($6 | 0) > 0 ? $6 : 0;
 $6 = HEAP32[$1 + 24 >> 2];
 $14 = HEAP32[$4 + 16 >> 2];
 $15 = HEAP32[$0 + 8 >> 2];
 $12 = HEAP32[$0 >> 2];
 while (1) {
  if (($8 | 0) != ($10 | 0)) {
   $7 = HEAPU16[$6 + 10 >> 1];
   HEAP16[$6 + 10 >> 1] = $7 & 65471;
   $11 = HEAP32[$6 + 20 >> 2];
   label$3: {
    if (($11 | 0) != HEAP32[$4 + 40 >> 2]) {
     break label$3;
    }
    $9 = HEAP32[$6 + 32 >> 2];
    $19 = $9;
    $9 = $3;
    $16 = HEAP32[$6 + 36 >> 2];
    $9 = $9 & $16;
    $16 = $2 & $19;
    if (!(HEAPU16[$6 + 12 >> 1] & 63487) | $7 & 128 | ($9 | $16)) {
     break label$3;
    }
    if (HEAPU8[$4 + 36 | 0] & 88) {
     $9 = HEAP32[$6 >> 2];
     if (!(HEAPU8[$9 + 4 | 0] & 3) | HEAP32[$9 + 36 >> 2] != ($11 | 0)) {
      break label$3;
     }
    }
    HEAP16[$6 + 10 >> 1] = $7 | 64;
    $13 = $13 + 1 | 0;
   }
   $6 = $6 + 48 | 0;
   $8 = $8 + 1 | 0;
   continue;
  }
  break;
 }
 $6 = 0;
 label$5: {
  if (!$15) {
   break label$5;
  }
  $11 = HEAP32[$15 >> 2];
  $10 = ($11 | 0) > 0 ? $11 : 0;
  $6 = 0;
  label$7: {
   while (1) {
    if (($6 | 0) == ($10 | 0)) {
     break label$7;
    }
    label$9: {
     $7 = ($6 << 4) + $15 | 0;
     $8 = HEAP32[$7 + 8 >> 2];
     label$10: {
      if (sqlite3ExprIsConstant($8)) {
       break label$10;
      }
      if (HEAPU8[$7 + 16 | 0] & 2) {
       break label$9;
      }
      $7 = HEAPU8[$8 | 0];
      if (($7 | 0) != 113) {
       if (($7 | 0) != 167 | HEAP32[$8 + 28 >> 2] != HEAP32[$4 + 40 >> 2]) {
        break label$9;
       }
       break label$10;
      }
      $7 = HEAP32[$8 + 12 >> 2];
      if (HEAPU8[$7 | 0] != 167 | HEAP32[$7 + 28 >> 2] != HEAP32[$4 + 40 >> 2]) {
       break label$9;
      }
      HEAP16[$8 + 32 >> 1] = HEAPU16[$7 + 32 >> 1];
      $7 = HEAP16[$7 + 32 >> 1];
      if (($7 | 0) < 0) {
       break label$10;
      }
      $2 = HEAP32[$8 + 8 >> 2];
      $8 = sqlite3ColumnColl(HEAP32[$14 + 4 >> 2] + Math_imul($7 & 65535, 12) | 0);
      if (sqlite3_stricmp($2, $8 ? $8 : 32384)) {
       break label$9;
      }
     }
     $6 = $6 + 1 | 0;
     continue;
    }
    break;
   }
   $10 = $6;
  }
  $6 = 0;
  if (($10 | 0) != ($11 | 0)) {
   break label$5;
  }
  $17 = $11;
  $6 = HEAPU16[$0 + 44 >> 1];
  label$12: {
   if ($6 & 128) {
    $6 = $6 >>> 9 & 1 | 2;
    break label$12;
   }
   $6 = $6 >>> 6 & 1;
  }
 }
 $8 = $17 << 3;
 $9 = sqlite3DbMallocZero(HEAP32[$12 >> 2], ($8 + Math_imul($13, 24) | 0) + 96 | 0, 0);
 if (!$9) {
  sqlite3ErrorMsg($12, 1141, 0);
  return $9;
 }
 HEAP32[$9 + 72 >> 2] = $1;
 HEAP32[$9 + 84 >> 2] = 0;
 HEAP32[$9 + 80 >> 2] = $6;
 HEAP32[$9 + 76 >> 2] = $12;
 $0 = (($13 << 2) + $9 | 0) + 92 | 0;
 HEAP32[$9 + 4 >> 2] = $0;
 $12 = Math_imul($13, 12) + $0 | 0;
 HEAP32[$9 + 12 >> 2] = $12;
 HEAP32[$9 + 16 >> 2] = $8 + $12;
 $6 = HEAP32[$1 + 12 >> 2];
 $13 = ($6 | 0) > 0 ? $6 : 0;
 $6 = HEAP32[$1 + 24 >> 2];
 $14 = 0;
 $4 = 0;
 $8 = 0;
 while (1) {
  label$16: {
   label$17: {
    label$18: {
     label$19: {
      if (($8 | 0) != ($13 | 0)) {
       $11 = HEAPU16[$6 + 10 >> 1];
       if (!($11 & 64)) {
        break label$16;
       }
       $10 = HEAP32[$6 + 24 >> 2];
       $7 = Math_imul($4, 12) + $0 | 0;
       HEAP32[$7 + 8 >> 2] = $8;
       HEAP32[$7 >> 2] = $10;
       label$21: {
        $1 = HEAPU16[$6 + 12 >> 1];
        $10 = $1 & 16383;
        if (($10 | 0) != 64) {
         if (($10 | 0) != 1) {
          break label$21;
         }
         if ($11 << 16 >> 16 < 0) {
          break label$19;
         }
         $18 = (($4 | 0) < 32 ? 1 << $4 : 0) | $18;
         HEAP32[$9 + 84 >> 2] = $18;
         break label$19;
        }
        HEAP8[$7 + 4 | 0] = HEAPU8[$6 + 15 | 0];
        break label$17;
       }
       if (!($10 & 384)) {
        break label$18;
       }
       if (($10 | 0) == 256) {
        HEAP8[$7 + 4 | 0] = 71;
        break label$17;
       }
       HEAP8[$7 + 4 | 0] = 72;
       break label$17;
      }
      HEAP32[$9 >> 2] = $4;
      $7 = 0;
      $10 = ($17 | 0) > 0 ? $17 : 0;
      $6 = 0;
      while (1) {
       if (($6 | 0) != ($10 | 0)) {
        $8 = ($6 << 4) + $15 | 0;
        $4 = HEAP32[$8 + 8 >> 2];
        if (!sqlite3ExprIsConstant($4)) {
         $11 = ($7 << 3) + $12 | 0;
         HEAP32[$11 >> 2] = HEAP16[$4 + 32 >> 1];
         HEAP8[$11 + 4 | 0] = HEAP8[$8 + 16 | 0] & 1;
         $7 = $7 + 1 | 0;
        }
        $6 = $6 + 1 | 0;
        continue;
       }
       break;
      }
      HEAP32[$9 + 8 >> 2] = $7;
      HEAP16[$5 >> 1] = $14;
      return $9;
     }
     $1 = 2;
     $10 = 2;
    }
    HEAP8[$7 + 4 | 0] = $1;
    if (!($10 & 60)) {
     break label$17;
    }
    if (!sqlite3ExprIsVector(HEAP32[HEAP32[$6 >> 2] + 16 >> 2])) {
     break label$17;
    }
    $2 = $7;
    $14 = (($4 | 0) < 16 ? 1 << $4 : 0) | $14;
    $7 = $1 & 16383;
    if (($7 | 0) != 4) {
     if (($7 | 0) != 16) {
      break label$17;
     }
     HEAP8[$2 + 4 | 0] = 8;
     break label$17;
    }
    HEAP8[$2 + 4 | 0] = 32;
   }
   $4 = $4 + 1 | 0;
  }
  $6 = $6 + 48 | 0;
  $8 = $8 + 1 | 0;
  continue;
 }
}

function walCheckpoint($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $8 = __stack_pointer - 32 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 28 >> 2] = 0;
 HEAP32[$8 + 24 >> 2] = 0;
 HEAP32[$8 + 20 >> 2] = 0;
 $16 = walPagesize($0);
 $15 = walCkptInfo($0);
 $13 = HEAP32[$0 + 68 >> 2];
 label$1: {
  if ($13 >>> 0 <= HEAPU32[$15 >> 2]) {
   $7 = 0;
  } else {
   $20 = $15 + 4 | 0;
   $21 = HEAP32[$0 + 72 >> 2];
   $11 = 1;
   while (1) {
    if (($11 | 0) != 5) {
     $17 = ($11 << 2) + $20 | 0;
     $14 = HEAP32[$17 >> 2];
     label$6: {
      if ($14 >>> 0 >= $13 >>> 0) {
       break label$6;
      }
      $18 = $11 + 3 | 0;
      $7 = walBusyLock($0, $3, $4, $18, 1);
      if (($7 | 0) == 5) {
       $13 = $14;
       $3 = 0;
       break label$6;
      }
      if ($7) {
       break label$1;
      }
      HEAP32[$17 >> 2] = ($11 | 0) == 1 ? $13 : -1;
      walUnlockExclusive($0, $18, 1);
      $7 = 0;
     }
     $11 = $11 + 1 | 0;
     continue;
    }
    break;
   }
   $9 = 0;
   label$8: {
    if (HEAPU32[$15 >> 2] >= $13 >>> 0) {
     break label$8;
    }
    $7 = walIteratorInit($0, HEAP32[$15 >> 2], $8 + 28 | 0);
    $17 = HEAP32[$8 + 28 >> 2];
    $9 = 0;
    if (!$17) {
     break label$8;
    }
    $7 = walBusyLock($0, $3, $4, 3, 1);
    if (!$7) {
     $20 = HEAP32[$15 >> 2];
     HEAP32[$15 + 32 >> 2] = $13;
     $18 = $5 >>> 2 & 3;
     $11 = sqlite3OsSync(HEAP32[$0 + 8 >> 2], $18);
     label$10: {
      if ($11) {
       break label$10;
      }
      $5 = __wasm_i64_mul($16, 0, $21, 0);
      $19 = $5;
      $9 = i64toi32_i32$HIGH_BITS;
      $14 = $9;
      HEAP32[$8 + 8 >> 2] = $19;
      HEAP32[$8 + 12 >> 2] = $9;
      sqlite3OsFileControl(HEAP32[$0 + 4 >> 2], 39, 0);
      $11 = sqlite3OsFileSize(HEAP32[$0 + 4 >> 2], $8);
      if ($11) {
       break label$10;
      }
      $9 = HEAP32[$8 >> 2];
      $10 = $9;
      $5 = HEAP32[$8 + 4 >> 2];
      $12 = $5;
      $9 = $5;
      $5 = $14;
      $7 = $19;
      if (($9 | 0) <= ($5 | 0) & $7 >>> 0 > $10 >>> 0 | ($9 | 0) < ($5 | 0)) {
       $7 = HEAP32[$0 + 68 >> 2];
       $7 = __wasm_i64_mul($7, 0, $16, 0);
       $5 = i64toi32_i32$HIGH_BITS;
       $11 = $5;
       $9 = $7;
       $10 = $7 + $10 | 0;
       $5 = $12;
       $7 = $11;
       $12 = $5 + $7 | 0;
       $12 = $9 >>> 0 > $10 >>> 0 ? $12 + 1 | 0 : $12;
       $5 = $10;
       $10 = $12;
       $7 = $5 + 65536 | 0;
       $10 = $7 >>> 0 < 65536 ? $10 + 1 | 0 : $10;
       $12 = $19;
       $5 = $10;
       $10 = $14;
       if ($7 >>> 0 < $12 >>> 0 & ($5 | 0) <= ($10 | 0) | ($5 | 0) < ($10 | 0)) {
        $11 = sqlite3CorruptError(63767);
        break label$10;
       }
       sqlite3OsFileControlHint(HEAP32[$0 + 4 >> 2], 5, $8 + 8 | 0);
      }
      $11 = 0;
     }
     $19 = $16 + 24 | 0;
     while (1) {
      label$15: {
       $7 = $11;
       if ($7) {
        break label$15;
       }
       if (walIteratorNext($17, $8 + 24 | 0, $8 + 20 | 0)) {
        $7 = 0;
        break label$15;
       }
       if (HEAP32[$1 + 296 >> 2]) {
        $7 = HEAPU8[$1 + 87 | 0] ? 7 : 9;
        break label$15;
       }
       $11 = 0;
       $7 = HEAP32[$8 + 20 >> 2];
       if ($20 >>> 0 >= $7 >>> 0 | $7 >>> 0 > $13 >>> 0) {
        continue;
       }
       $14 = HEAP32[$8 + 24 >> 2];
       if ($21 >>> 0 < $14 >>> 0) {
        continue;
       }
       $5 = HEAP32[$0 + 8 >> 2];
       $10 = __wasm_i64_mul($7 - 1 | 0, 0, $19, 0);
       $9 = $10;
       $12 = i64toi32_i32$HIGH_BITS;
       $7 = $12;
       $10 = $9 + 56 | 0;
       $7 = $10 >>> 0 < 56 ? $7 + 1 | 0 : $7;
       $7 = sqlite3OsRead($5, $6, $16, $10, $7);
       if ($7) {
        break label$15;
       }
       $5 = HEAP32[$0 + 4 >> 2];
       $9 = __wasm_i64_mul($16, 0, $14 - 1 | 0, 0);
       $7 = i64toi32_i32$HIGH_BITS;
       $7 = sqlite3OsWrite($5, $6, $16, $9, $7);
       if (!$7) {
        continue;
       }
      }
      break;
     }
     sqlite3OsFileControl(HEAP32[$0 + 4 >> 2], 37, 0);
     label$18: {
      if ($7) {
       break label$18;
      }
      if (HEAP32[walIndexHdr($0) + 16 >> 2] == ($13 | 0)) {
       $1 = HEAP32[$0 + 4 >> 2];
       $7 = HEAP32[$0 + 72 >> 2];
       $7 = __wasm_i64_mul($16, 0, $7, 0);
       $9 = i64toi32_i32$HIGH_BITS;
       $7 = sqlite3OsTruncate($1, $7, $9);
       if ($7) {
        break label$18;
       }
       $7 = sqlite3OsSync(HEAP32[$0 + 4 >> 2], $18);
       if ($7) {
        break label$18;
       }
      }
      HEAP32[$15 >> 2] = $13;
      $7 = 0;
     }
     walUnlockExclusive($0, 3, 1);
    }
    $9 = $17;
   }
   $7 = ($7 | 0) == 5 ? 0 : $7;
  }
  if ($7 | !$2) {
   break label$1;
  }
  $7 = 5;
  if (HEAPU32[$15 >> 2] < HEAPU32[$0 + 68 >> 2]) {
   break label$1;
  }
  $7 = 0;
  if (($2 | 0) < 2) {
   break label$1;
  }
  sqlite3_randomness(4, $8 + 8 | 0);
  $7 = walBusyLock($0, $3, $4, 4, 4);
  if ($7) {
   break label$1;
  }
  $7 = 0;
  if (($2 | 0) == 3) {
   walRestartHdr($0, HEAP32[$8 + 8 >> 2]);
   $7 = sqlite3OsTruncate(HEAP32[$0 + 8 >> 2], 0, 0);
  }
  walUnlockExclusive($0, 4, 4);
 }
 walIteratorFree($9);
 __stack_pointer = $8 + 32 | 0;
 return $7;
}

function sqlite3RunVacuum($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $5 = __stack_pointer - 80 | 0;
 __stack_pointer = $5;
 label$1: {
  if (!HEAPU8[$1 + 85 | 0]) {
   sqlite3SetString($0, $1, 10112);
   $4 = 1;
   break label$1;
  }
  if (HEAP32[$1 + 184 >> 2] >= 2) {
   sqlite3SetString($0, $1, 4112);
   $4 = 1;
   break label$1;
  }
  $10 = HEAP32[$1 + 60 >> 2];
  label$4: {
   if (!$3) {
    $4 = 29623;
    break label$4;
   }
   if ((sqlite3_value_type($3) | 0) != 3) {
    sqlite3SetString($0, $1, 13263);
    $4 = 1;
    break label$1;
   }
   $4 = sqlite3_value_text($3);
   HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 60 >> 2] & -8 | 6;
  }
  $15 = HEAPU8[$1 + 94 | 0];
  HEAP8[$1 + 94 | 0] = 0;
  $12 = HEAP32[$1 + 24 >> 2];
  HEAP32[$1 + 24 >> 2] = $12 | 6;
  $9 = HEAP32[$1 + 32 >> 2];
  $13 = $9;
  $7 = HEAP32[$1 + 36 >> 2];
  $16 = $7;
  $9 = $7 & -2;
  $7 = $13 & -268456450;
  HEAP32[$1 + 32 >> 2] = $7 | 513;
  HEAP32[$1 + 36 >> 2] = $9;
  $6 = HEAP32[$1 + 16 >> 2] + ($2 << 4) | 0;
  $11 = HEAP32[$6 >> 2];
  $17 = HEAP32[$1 + 112 >> 2];
  $7 = HEAP32[$1 + 116 >> 2];
  $18 = $7;
  $7 = HEAP32[$1 + 104 >> 2];
  $19 = $7;
  $20 = HEAP32[$1 + 108 >> 2];
  $6 = HEAP32[$6 + 4 >> 2];
  $21 = sqlite3PagerIsMemdb(sqlite3BtreePager($6));
  $14 = HEAP32[$1 + 20 >> 2];
  HEAP32[$5 + 64 >> 2] = $4;
  $4 = execSqlF($1, $0, 17567, $5 - -64 | 0);
  HEAP32[$1 + 60 >> 2] = $10;
  $10 = 0;
  label$7: {
   if ($4) {
    break label$7;
   }
   $10 = HEAP32[$1 + 16 >> 2] + ($14 << 4) | 0;
   $8 = HEAP32[$10 + 4 >> 2];
   label$8: {
    if ($3) {
     $4 = sqlite3PagerFile(sqlite3BtreePager($8));
     HEAP32[$5 + 72 >> 2] = 0;
     HEAP32[$5 + 76 >> 2] = 0;
     if (HEAP32[$4 >> 2]) {
      if (sqlite3OsFileSize($4, $5 + 72 | 0)) {
       break label$8;
      }
      $9 = HEAP32[$5 + 72 >> 2];
      $7 = HEAP32[$5 + 76 >> 2];
      if (!!$9 & ($7 | 0) >= 0 | ($7 | 0) > 0) {
       break label$8;
      }
     }
     HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] | 8;
    }
    $7 = sqlite3BtreeGetRequestedReserve($6);
    sqlite3BtreeSetCacheSize($8, HEAP32[HEAP32[(HEAP32[$1 + 16 >> 2] + ($2 << 4) | 0) + 12 >> 2] + 80 >> 2]);
    sqlite3BtreeSetSpillSize($8, sqlite3BtreeSetSpillSize($6, 0));
    sqlite3BtreeSetPagerFlags($8, 33);
    $4 = execSql($1, $0, 19447);
    if ($4) {
     break label$7;
    }
    $4 = sqlite3BtreeBeginTrans($6, !$3 << 1, 0);
    if ($4) {
     break label$7;
    }
    $4 = sqlite3PagerGetJournalMode(sqlite3BtreePager($6));
    if (!(($4 | 0) != 5 | $3)) {
     HEAP32[$1 + 100 >> 2] = 0;
    }
    $4 = 7;
    if (sqlite3BtreeSetPageSize($8, sqlite3BtreeGetPageSize($6), $7, 0)) {
     break label$7;
    }
    if (!$21) {
     if (sqlite3BtreeSetPageSize($8, HEAP32[$1 + 100 >> 2], $7, 0)) {
      break label$7;
     }
    }
    if (HEAPU8[$1 + 87 | 0]) {
     break label$7;
    }
    $4 = HEAP8[$1 + 90 | 0];
    label$13: {
     if (($4 | 0) >= 0) {
      $4 = $4 & 255;
      break label$13;
     }
     $4 = sqlite3BtreeGetAutoVacuum($6);
    }
    sqlite3BtreeSetAutoVacuum($8, $4);
    HEAP8[$1 + 176 | 0] = $14;
    HEAP32[$5 + 48 >> 2] = $11;
    $4 = execSqlF($1, $0, 23623, $5 + 48 | 0);
    if ($4) {
     break label$7;
    }
    HEAP32[$5 + 32 >> 2] = $11;
    $4 = execSqlF($1, $0, 26933, $5 + 32 | 0);
    if ($4) {
     break label$7;
    }
    HEAP8[$1 + 176 | 0] = 0;
    HEAP32[$5 + 16 >> 2] = $11;
    $4 = execSqlF($1, $0, 23472, $5 + 16 | 0);
    HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] & -5;
    if ($4) {
     break label$7;
    }
    HEAP32[$5 >> 2] = $11;
    $4 = execSqlF($1, $0, 25849, $5);
    if ($4) {
     break label$7;
    }
    $0 = 0;
    while (1) {
     if ($0 >>> 0 <= 9) {
      $4 = HEAPU8[$0 + 33448 | 0];
      sqlite3BtreeGetMeta($6, $4, $5 + 72 | 0);
      $2 = $0 | 1;
      $0 = $0 + 2 | 0;
      $4 = sqlite3BtreeUpdateMeta($8, $4, HEAP32[$5 + 72 >> 2] + HEAPU8[$2 + 33448 | 0] | 0);
      if (!$4) {
       continue;
      }
      break label$7;
     }
     break;
    }
    if (!$3) {
     $4 = sqlite3BtreeCopyFile($6, $8);
     if ($4) {
      break label$7;
     }
    }
    $4 = sqlite3BtreeCommit($8);
    $0 = (($4 | 0) != 0) << 1;
    if (!($3 | $4)) {
     sqlite3BtreeSetAutoVacuum($6, sqlite3BtreeGetAutoVacuum($8));
     $0 = 0;
    }
    if ($0 | $3) {
     break label$7;
    }
    $4 = sqlite3BtreeGetRequestedReserve($8);
    $4 = sqlite3BtreeSetPageSize($6, sqlite3BtreeGetPageSize($8), $4, 1);
    break label$7;
   }
   sqlite3SetString($0, $1, 3464);
   $4 = 1;
  }
  HEAP32[$1 + 112 >> 2] = $17;
  $9 = $18;
  HEAP32[$1 + 116 >> 2] = $9;
  HEAP32[$1 + 104 >> 2] = $19;
  $9 = $20;
  HEAP32[$1 + 108 >> 2] = $9;
  HEAP32[$1 + 32 >> 2] = $13;
  $9 = $16;
  HEAP32[$1 + 36 >> 2] = $9;
  HEAP32[$1 + 24 >> 2] = $12;
  HEAP8[$1 + 94 | 0] = $15;
  HEAP8[$1 + 176 | 0] = 0;
  sqlite3BtreeSetPageSize($6, -1, 0, 1);
  HEAP8[$1 + 85 | 0] = 1;
  if ($10) {
   sqlite3BtreeClose(HEAP32[$10 + 4 >> 2]);
   HEAP32[$10 + 12 >> 2] = 0;
   HEAP32[$10 + 4 >> 2] = 0;
  }
  sqlite3ResetAllSchemasOfConnection($1);
 }
 __stack_pointer = $5 + 80 | 0;
 return $4;
}

function pager_playback_one_page($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 $14 = HEAP32[$0 + 224 >> 2];
 $12 = HEAP32[($3 ? 68 : 72) + $0 >> 2];
 $5 = $1;
 $6 = HEAP32[$5 >> 2];
 $9 = HEAP32[$5 + 4 >> 2];
 $7 = read32bits($12, $6, $9, $11 + 8 | 0);
 label$1: {
  if ($7) {
   break label$1;
  }
  $9 = HEAP32[$1 >> 2];
  $6 = HEAP32[$5 + 4 >> 2];
  $5 = $9;
  $13 = $5 + 4 | 0;
  $5 = $13 >>> 0 < 4 ? $6 + 1 | 0 : $6;
  $7 = sqlite3OsRead($12, $14, HEAP32[$0 + 168 >> 2], $13, $5);
  if ($7) {
   break label$1;
  }
  $6 = $1;
  $5 = HEAP32[$6 >> 2];
  $7 = $5;
  $5 = HEAP32[$6 + 4 >> 2];
  $10 = $5;
  $5 = HEAP32[$0 + 172 >> 2];
  $13 = $5;
  $5 = HEAP32[$0 + 168 >> 2];
  $6 = $5;
  $8 = $3 << 2;
  $9 = $6 + $8 | 0;
  $13 = $9 >>> 0 < $8 >>> 0 ? $13 + 1 | 0 : $13;
  $8 = $9;
  $6 = $13;
  $13 = $10;
  $9 = $6 + $13 | 0;
  $5 = $7;
  $5 = $8 + $5 | 0;
  $9 = $5 >>> 0 < $8 >>> 0 ? $9 + 1 | 0 : $9;
  $13 = $5;
  $5 = $9;
  $6 = $13 + 4 | 0;
  $5 = $6 >>> 0 < 4 ? $5 + 1 | 0 : $5;
  $9 = $6;
  $13 = $5;
  HEAP32[$1 >> 2] = $6;
  HEAP32[$1 + 4 >> 2] = $5;
  $7 = 101;
  $10 = HEAP32[$11 + 8 >> 2];
  if (!$10 | HEAP32[$0 + 164 >> 2] == ($10 | 0)) {
   break label$1;
  }
  $7 = 0;
  if (HEAPU32[$0 + 28 >> 2] < $10 >>> 0) {
   break label$1;
  }
  if (sqlite3BitvecTest($2, $10)) {
   break label$1;
  }
  label$2: {
   if (!$3) {
    break label$2;
   }
   $5 = $9 - 4 | 0;
   $6 = $9 >>> 0 < 4;
   $6 = $13 - $6 | 0;
   $7 = read32bits($12, $5, $6, $11 + 4 | 0);
   if ($7) {
    break label$1;
   }
   if ($4) {
    break label$2;
   }
   $7 = 101;
   if ((pager_cksum($0, $14) | 0) != HEAP32[$11 + 4 >> 2]) {
    break label$1;
   }
  }
  if ($2) {
   $7 = sqlite3BitvecSet($2, $10);
   if ($7) {
    break label$1;
   }
  }
  label$4: {
   if (($10 | 0) != 1) {
    break label$4;
   }
   $7 = HEAPU8[$14 + 20 | 0];
   if (($7 | 0) == HEAP16[$0 + 150 >> 1]) {
    break label$4;
   }
   HEAP16[$0 + 150 >> 1] = $7;
  }
  label$5: {
   label$6: {
    label$7: {
     if (!HEAP32[$0 + 232 >> 2]) {
      $12 = sqlite3PagerLookup($0, $10);
      HEAP32[$11 + 12 >> 2] = $12;
      if (!$3) {
       break label$7;
      }
      break label$6;
     }
     $12 = 0;
     HEAP32[$11 + 12 >> 2] = 0;
     if ($3) {
      break label$6;
     }
     $7 = 1;
     break label$5;
    }
    if (!$12) {
     $12 = 0;
     $7 = 1;
     break label$5;
    }
    $7 = (HEAPU16[$12 + 28 >> 1] ^ -1) >>> 3 & 1;
    break label$5;
   }
   $7 = 1;
   if (HEAPU8[$0 + 7 | 0]) {
    break label$5;
   }
   $5 = $1;
   $6 = HEAP32[$5 >> 2];
   $1 = $6;
   $9 = HEAP32[$5 + 4 >> 2];
   $2 = $9;
   $9 = HEAP32[$0 + 88 >> 2];
   $8 = $9;
   $6 = HEAP32[$0 + 92 >> 2];
   $9 = $6;
   $6 = $2;
   $5 = $1;
   $7 = ($6 | 0) <= ($9 | 0) & $5 >>> 0 <= $8 >>> 0 | ($6 | 0) < ($9 | 0);
  }
  label$10: {
   label$11: {
    $1 = HEAP32[$0 + 64 >> 2];
    if (!HEAP32[$1 >> 2]) {
     break label$11;
    }
    $2 = HEAPU8[$0 + 17 | 0];
    if (!$7 | ($2 ? $2 >>> 0 <= 3 : 0)) {
     break label$11;
    }
    $5 = HEAP32[$0 + 168 >> 2];
    $9 = $5;
    $6 = HEAP32[$0 + 172 >> 2];
    $5 = __wasm_i64_mul($5, $6, $10 - 1 | 0, 0);
    $6 = i64toi32_i32$HIGH_BITS;
    $7 = sqlite3OsWrite($1, $14, $9, $5, $6);
    if (HEAPU32[$0 + 36 >> 2] < $10 >>> 0) {
     HEAP32[$0 + 36 >> 2] = $10;
    }
    $1 = HEAP32[$0 + 96 >> 2];
    if (!$1) {
     break label$10;
    }
    sqlite3BackupUpdate($1, $10, $14);
    break label$10;
   }
   $7 = 0;
   if ($3 | $12) {
    break label$10;
   }
   HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] | 2;
   $7 = sqlite3PagerGet($0, $10, $11 + 12 | 0, 1);
   HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] & 253;
   if ($7) {
    break label$1;
   }
   sqlite3PcacheMakeDirty(HEAP32[$11 + 12 >> 2]);
   $12 = HEAP32[$11 + 12 >> 2];
   $7 = 0;
  }
  if (!$12) {
   break label$1;
  }
  $1 = __memcpy(HEAP32[$12 + 4 >> 2], $14, HEAP32[$0 + 168 >> 2]);
  FUNCTION_TABLE[HEAP32[$0 + 216 >> 2]](HEAP32[$11 + 12 >> 2]);
  if (($10 | 0) == 1) {
   $8 = $1;
   $6 = HEAPU8[$8 + 24 | 0] | HEAPU8[$8 + 25 | 0] << 8 | (HEAPU8[$8 + 26 | 0] << 16 | HEAPU8[$8 + 27 | 0] << 24);
   $5 = HEAPU8[$8 + 28 | 0] | HEAPU8[$8 + 29 | 0] << 8 | (HEAPU8[$8 + 30 | 0] << 16 | HEAPU8[$8 + 31 | 0] << 24);
   HEAP8[$0 + 112 | 0] = $6;
   HEAP8[$0 + 113 | 0] = $6 >>> 8;
   HEAP8[$0 + 114 | 0] = $6 >>> 16;
   HEAP8[$0 + 115 | 0] = $6 >>> 24;
   HEAP8[$0 + 116 | 0] = $5;
   HEAP8[$0 + 117 | 0] = $5 >>> 8;
   HEAP8[$0 + 118 | 0] = $5 >>> 16;
   HEAP8[$0 + 119 | 0] = $5 >>> 24;
   $6 = HEAPU8[$8 + 36 | 0] | HEAPU8[$8 + 37 | 0] << 8 | (HEAPU8[$8 + 38 | 0] << 16 | HEAPU8[$8 + 39 | 0] << 24);
   $5 = HEAPU8[$8 + 32 | 0] | HEAPU8[$8 + 33 | 0] << 8 | (HEAPU8[$8 + 34 | 0] << 16 | HEAPU8[$8 + 35 | 0] << 24);
   HEAP8[$0 + 120 | 0] = $5;
   HEAP8[$0 + 121 | 0] = $5 >>> 8;
   HEAP8[$0 + 122 | 0] = $5 >>> 16;
   HEAP8[$0 + 123 | 0] = $5 >>> 24;
   HEAP8[$0 + 124 | 0] = $6;
   HEAP8[$0 + 125 | 0] = $6 >>> 8;
   HEAP8[$0 + 126 | 0] = $6 >>> 16;
   HEAP8[$0 + 127 | 0] = $6 >>> 24;
  }
  sqlite3PcacheRelease(HEAP32[$11 + 12 >> 2]);
 }
 __stack_pointer = $11 + 16 | 0;
 return $7;
}

function analyzeOneTable($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0;
 $6 = HEAP32[$0 + 44 >> 2];
 $14 = $4 + 9 | 0;
 HEAP32[$0 + 44 >> 2] = ($6 | 0) > ($14 | 0) ? $6 : $14;
 $15 = HEAP32[$0 >> 2];
 $6 = sqlite3GetVdbe($0);
 label$1: {
  if (!$1 | !$6 | HEAPU8[$1 + 43 | 0]) {
   break label$1;
  }
  if (!sqlite3_strlike(28289, HEAP32[$1 >> 2], 92)) {
   break label$1;
  }
  $7 = HEAP32[$1 >> 2];
  $9 = HEAP32[$15 + 16 >> 2];
  $17 = sqlite3SchemaToIndex($15, HEAP32[$1 + 60 >> 2]);
  if (sqlite3AuthCheck($0, 28, $7, 0, HEAP32[$9 + ($17 << 4) >> 2])) {
   break label$1;
  }
  $20 = $4 + 8 | 0;
  $25 = $4 + 7 | 0;
  $26 = $4 + 5 | 0;
  $11 = $4 + 4 | 0;
  $27 = $4 + 3 | 0;
  $16 = $4 + 2 | 0;
  $21 = $4 + 1 | 0;
  sqlite3TableLock($0, $17, HEAP32[$1 + 20 >> 2], 0, HEAP32[$1 >> 2]);
  $7 = HEAP32[$0 + 40 >> 2];
  $10 = $5 + 2 | 0;
  HEAP32[$0 + 40 >> 2] = ($7 | 0) > ($10 | 0) ? $7 : $10;
  sqlite3OpenTable($0, $5, $17, $1, 112);
  $22 = $4 + 6 | 0;
  sqlite3VdbeLoadString($6, $22, HEAP32[$1 >> 2]);
  $7 = $1 + 8 | 0;
  $10 = $5 + 1 | 0;
  $23 = 1;
  while (1) {
   $8 = HEAP32[$7 >> 2];
   if ($8) {
    label$4: {
     if (($2 | 0) != ($8 | 0) ? $2 : 0) {
      break label$4;
     }
     $12 = HEAP32[$8 + 36 >> 2];
     label$5: {
      label$6: {
       $7 = HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8;
       label$7: {
        if (!(!(HEAPU8[$1 + 28 | 0] & 128) | ($7 & 3) != 2)) {
         $13 = HEAP32[$1 >> 2];
         $9 = HEAPU16[$8 + 50 >> 1];
         break label$7;
        }
        $13 = HEAP32[$8 >> 2];
        $9 = HEAPU16[$8 + 52 >> 1];
        if ($7 & 8) {
         break label$6;
        }
       }
       $7 = $9;
       break label$5;
      }
      $7 = HEAPU16[$8 + 50 >> 1];
     }
     $23 = $12 ? $23 : 0;
     sqlite3VdbeLoadString($6, $25, $13);
     $13 = HEAP32[$0 + 44 >> 2];
     $12 = $7 - 1 | 0;
     $18 = $14 + $12 | 0;
     HEAP32[$0 + 44 >> 2] = ($13 | 0) > ($18 | 0) ? $13 : $18;
     sqlite3VdbeAddOp3($6, 112, $10, HEAP32[$8 + 44 >> 2], $17);
     sqlite3VdbeSetP4KeyInfo($0, $8);
     sqlite3VdbeAddOp2($6, 71, $9, $16);
     sqlite3VdbeAddOp2($6, 71, HEAPU16[$8 + 50 >> 1], $27);
     $28 = sqlite3VdbeAddOp1($6, 35, $10);
     sqlite3VdbeAddOp3($6, 98, $10, $11, 1);
     sqlite3VdbeAddOp2($6, 71, HEAP32[$15 + 492 >> 2], $26);
     sqlite3VdbeAddFunctionCall($0, 0, $16, $21, 4, 49736, 0);
     sqlite3VdbeAddOp2($6, 71, 0, $16);
     $19 = sqlite3VdbeCurrentAddr($6);
     if ($7 >>> 0 >= 2) {
      $24 = sqlite3VdbeMakeLabel($0);
      $9 = sqlite3DbMallocRawNN($15, $12 << 2, 0);
      if (!$9) {
       break label$4;
      }
      sqlite3VdbeAddOp0($6, 8);
      $19 = sqlite3VdbeCurrentAddr($6);
      if (!(!HEAPU8[$8 + 54 | 0] | (($12 | 0) != 1 | HEAPU16[$8 + 50 >> 1] != 1))) {
       sqlite3VdbeAddOp2($6, 51, $14, $24);
      }
      $7 = 0;
      while (1) {
       if (($7 | 0) != ($12 | 0)) {
        $13 = $7 << 2;
        $18 = sqlite3LocateCollSeq($0, HEAP32[$13 + HEAP32[$8 + 32 >> 2] >> 2]);
        sqlite3VdbeAddOp2($6, 71, $7, $16);
        sqlite3VdbeAddOp3($6, 94, $10, $7, $11);
        HEAP32[$9 + $13 >> 2] = sqlite3VdbeAddOp4($6, 52, $11, 0, $7 + $14 | 0, $18, -2);
        sqlite3VdbeChangeP5($6, 128);
        $7 = $7 + 1 | 0;
        continue;
       }
       break;
      }
      sqlite3VdbeAddOp2($6, 71, $12, $16);
      sqlite3VdbeGoto($6, $24);
      sqlite3VdbeJumpHere($6, $19 - 1 | 0);
      $7 = 0;
      while (1) {
       if (($7 | 0) != ($12 | 0)) {
        sqlite3VdbeJumpHere($6, HEAP32[($7 << 2) + $9 >> 2]);
        sqlite3VdbeAddOp3($6, 94, $10, $7, $7 + $14 | 0);
        $7 = $7 + 1 | 0;
        continue;
       }
       break;
      }
      sqlite3VdbeResolveLabel($6, $24);
      sqlite3DbFree($15, $9);
     }
     sqlite3VdbeAddFunctionCall($0, 1, $21, $11, 2, 49776, 0);
     label$15: {
      if (HEAP32[$15 + 492 >> 2]) {
       $7 = sqlite3VdbeAddOp1($6, 50, $11);
       $12 = sqlite3VdbeAddOp1($6, 15, $11);
       $9 = sqlite3VdbeAddOp4Int($6, 23, $10, 0, $14, 1);
       sqlite3VdbeJumpHere($6, $7);
       sqlite3VdbeAddOp2($6, 38, $10, $19);
       sqlite3VdbeJumpHere($6, $12);
       sqlite3VdbeJumpHere($6, $9);
       break label$15;
      }
      sqlite3VdbeAddOp2($6, 38, $10, $19);
     }
     callStatGet($0, $21, $20);
     sqlite3VdbeAddOp4($6, 97, $22, 3, $11, 20306, 0);
     sqlite3VdbeAddOp2($6, 127, $3, $4);
     sqlite3VdbeAddOp3($6, 128, $3, $11, $4);
     sqlite3VdbeChangeP5($6, 8);
     sqlite3VdbeJumpHere($6, $28);
    }
    $7 = $8 + 20 | 0;
    continue;
   }
   break;
  }
  if (!($23 & 255) | $2) {
   break label$1;
  }
  sqlite3VdbeAddOp2($6, 98, $5, $20);
  $7 = sqlite3VdbeAddOp1($6, 16, $20);
  sqlite3VdbeAddOp2($6, 75, 0, $25);
  sqlite3VdbeAddOp4($6, 97, $22, 3, $11, 20306, 0);
  sqlite3VdbeAddOp2($6, 127, $3, $4);
  sqlite3VdbeAddOp3($6, 128, $3, $11, $4);
  sqlite3VdbeChangeP5($6, 8);
  sqlite3VdbeJumpHere($6, $7);
 }
}

function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$11: {
           $9 = $1;
           $7 = $9;
           if ($7) {
            $4 = $2;
            if (!$4) {
             break label$11;
            }
            $5 = $3;
            if (!$5) {
             break label$9;
            }
            $7 = Math_clz32($5) - Math_clz32($7) | 0;
            if ($7 >>> 0 <= 31) {
             break label$8;
            }
            break label$2;
           }
           $6 = $3;
           if (($6 | 0) == 1 | $6 >>> 0 > 1) {
            break label$2;
           }
           $7 = $0;
           $4 = $2;
           $7 = ($7 >>> 0) / ($4 >>> 0) | 0;
           __wasm_intrinsics_temp_i64 = $0 - Math_imul($7, $4) | 0;
           __wasm_intrinsics_temp_i64$hi = 0;
           i64toi32_i32$HIGH_BITS = 0;
           $6 = $7;
           return $6;
          }
          $6 = $3;
          $4 = $6;
          if (!$0) {
           break label$7;
          }
          if (!$4) {
           break label$6;
          }
          $5 = $4 - 1 | 0;
          if ($5 & $4) {
           break label$6;
          }
          $6 = $7 & $5;
          $1 = $6;
          $9 = $0;
          $5 = 0;
          __wasm_intrinsics_temp_i64 = $9 | $5;
          $6 = 0;
          $10 = $6;
          $6 = $1;
          $10 = $10 | $6;
          __wasm_intrinsics_temp_i64$hi = $10;
          $5 = $7 >>> __wasm_ctz_i32($4) | 0;
          i64toi32_i32$HIGH_BITS = 0;
          return $5;
         }
         $5 = $4 - 1 | 0;
         if (!($5 & $4)) {
          break label$5;
         }
         $7 = (Math_clz32($4) + 33 | 0) - Math_clz32($7) | 0;
         $4 = 0 - $7 | 0;
         break label$3;
        }
        $4 = 63 - $7 | 0;
        $7 = $7 + 1 | 0;
        break label$3;
       }
       __wasm_intrinsics_temp_i64 = 0;
       $5 = ($7 >>> 0) / ($4 >>> 0) | 0;
       $6 = $7 - Math_imul($5, $4) | 0;
       __wasm_intrinsics_temp_i64$hi = $6;
       i64toi32_i32$HIGH_BITS = 0;
       $6 = $5;
       return $6;
      }
      $7 = Math_clz32($4) - Math_clz32($7) | 0;
      if ($7 >>> 0 < 31) {
       break label$4;
      }
      break label$2;
     }
     __wasm_intrinsics_temp_i64 = $0 & $5;
     __wasm_intrinsics_temp_i64$hi = 0;
     if (($4 | 0) == 1) {
      break label$1;
     }
     $6 = $1;
     $5 = $0;
     $10 = 0;
     $9 = __wasm_ctz_i32($4);
     $8 = $9 & 31;
     if (($9 & 63) >>> 0 >= 32) {
      $5 = $6 >>> $8 | 0;
     } else {
      $10 = $6 >>> $8 | 0;
      $5 = ((1 << $8) - 1 & $6) << 32 - $8 | $5 >>> $8;
     }
     i64toi32_i32$HIGH_BITS = $10;
     return $5;
    }
    $4 = 63 - $7 | 0;
    $7 = $7 + 1 | 0;
   }
   $5 = $1;
   $6 = $0;
   $10 = 0;
   $9 = $7 & 63;
   $8 = $9 & 31;
   if (($9 & 63) >>> 0 >= 32) {
    $11 = $5 >>> $8 | 0;
   } else {
    $10 = $5 >>> $8 | 0;
    $11 = ((1 << $8) - 1 & $5) << 32 - $8 | $6 >>> $8;
   }
   $12 = $10;
   $10 = $1;
   $5 = $0;
   $9 = $4 & 63;
   $8 = $9 & 31;
   if (($9 & 63) >>> 0 >= 32) {
    $6 = $5 << $8;
    $0 = 0;
   } else {
    $6 = (1 << $8) - 1 & $5 >>> 32 - $8 | $10 << $8;
    $0 = $5 << $8;
   }
   $1 = $6;
   if ($7) {
    $6 = $3;
    $4 = $6 - 1 | 0;
    $10 = $2;
    $8 = $10 - 1 | 0;
    $4 = ($8 | 0) != -1 ? $4 + 1 | 0 : $4;
    $15 = $8;
    $16 = $4;
    while (1) {
     $6 = $11;
     $5 = $6 << 1;
     $4 = $12;
     $10 = $4 << 1 | $6 >>> 31;
     $6 = 0;
     $4 = $6;
     $6 = $10;
     $4 = $6 | $4;
     $12 = $4;
     $10 = $1;
     $9 = $10 >>> 31 | 0;
     $10 = $5;
     $11 = $9 | $10;
     $6 = $15;
     $9 = $11;
     $5 = $6 - $9 | 0;
     $4 = $16;
     $10 = $12;
     $8 = $10 + ($6 >>> 0 < $9 >>> 0) | 0;
     $8 = $4 - $8 | 0;
     $13 = $8 >> 31;
     $6 = $8 >> 31;
     $14 = $6;
     $4 = $3;
     $4 = $6 & $4;
     $5 = $4;
     $6 = $9;
     $9 = $2;
     $8 = $13;
     $9 = $9 & $8;
     $10 = $6 - $9 | 0;
     $11 = $10;
     $4 = $12;
     $8 = $5;
     $5 = $8 + ($6 >>> 0 < $9 >>> 0) | 0;
     $5 = $4 - $5 | 0;
     $12 = $5;
     $5 = $1;
     $4 = $0;
     $6 = $5 << 1 | $4 >>> 31;
     $9 = $17;
     $5 = $4 << 1;
     $0 = $9 | $5;
     $4 = $18;
     $4 = $4 | $6;
     $1 = $4;
     $6 = $13;
     $13 = $6 & 1;
     $5 = 0;
     $14 = $5;
     $17 = $13;
     $7 = $7 - 1 | 0;
     if ($7) {
      continue;
     }
     break;
    }
   }
   __wasm_intrinsics_temp_i64 = $11;
   $5 = $12;
   __wasm_intrinsics_temp_i64$hi = $5;
   $4 = $0;
   $0 = $4 << 1;
   $5 = $1;
   $6 = $5 << 1 | $4 >>> 31;
   $4 = $14;
   $4 = $6 | $4;
   i64toi32_i32$HIGH_BITS = $4;
   $9 = $13;
   $5 = $0;
   $5 = $9 | $5;
   return $5;
  }
  __wasm_intrinsics_temp_i64 = $0;
  $5 = $1;
  __wasm_intrinsics_temp_i64$hi = $5;
  $0 = 0;
  $1 = 0;
 }
 $5 = $1;
 i64toi32_i32$HIGH_BITS = $5;
 $4 = $0;
 return $4;
}

function renameTableFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $1 = __stack_pointer - 368 | 0;
 __stack_pointer = $1;
 $7 = sqlite3_context_db_handle($0);
 $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $9 = sqlite3_value_text(HEAP32[$2 + 12 >> 2]);
 $8 = sqlite3_value_text(HEAP32[$2 + 16 >> 2]);
 $10 = sqlite3_value_text(HEAP32[$2 + 20 >> 2]);
 $4 = sqlite3_value_int(HEAP32[$2 + 24 >> 2]);
 if (!(!$10 | (!$9 | !$8))) {
  $11 = HEAP32[$7 + 360 >> 2];
  HEAP32[$7 + 360 >> 2] = 0;
  sqlite3BtreeEnterAll($7);
  HEAP32[$1 + 88 >> 2] = 0;
  HEAP32[$1 + 80 >> 2] = 0;
  HEAP32[$1 + 84 >> 2] = 0;
  HEAP32[$1 + 72 >> 2] = 0;
  HEAP32[$1 + 76 >> 2] = 0;
  $5 = sqlite3FindTable($7, $8, $3);
  HEAP32[$1 + 60 >> 2] = 0;
  HEAP32[$1 + 52 >> 2] = 0;
  HEAP32[$1 + 56 >> 2] = 0;
  HEAP32[$1 + 84 >> 2] = $5;
  HEAP32[$1 + 48 >> 2] = 90;
  HEAP32[$1 + 44 >> 2] = 91;
  HEAP32[$1 + 64 >> 2] = $1 + 72;
  HEAP32[$1 + 40 >> 2] = $1 + 96;
  $3 = renameParseSql($1 + 96 | 0, $3, $7, $9, $4);
  label$2: {
   if ($3) {
    break label$2;
   }
   $4 = HEAP32[$7 + 32 >> 2];
   $6 = $4 & 67108864;
   label$3: {
    label$4: {
     $5 = HEAP32[$1 + 332 >> 2];
     if ($5) {
      $3 = HEAPU8[$5 + 43 | 0];
      if (($3 | 0) == 2) {
       if ($6) {
        break label$3;
       }
       $3 = HEAP32[$5 + 44 >> 2];
       HEAP32[$1 + 36 >> 2] = 0;
       HEAP32[$1 + 28 >> 2] = 0;
       HEAP32[$1 + 32 >> 2] = 0;
       HEAP32[$1 + 20 >> 2] = 0;
       HEAP32[$1 + 24 >> 2] = 0;
       HEAP32[$1 + 12 >> 2] = 0;
       HEAP32[$1 + 16 >> 2] = 0;
       HEAP32[$1 + 8 >> 2] = $1 + 96;
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] & -2097153;
       sqlite3SelectPrep($1 + 96 | 0, HEAP32[$5 + 44 >> 2], $1 + 8 | 0);
       if (HEAP32[$1 + 132 >> 2]) {
        break label$4;
       }
       sqlite3WalkSelect($1 + 40 | 0, HEAP32[$5 + 44 >> 2]);
       break label$3;
      }
      label$7: {
       if (!($4 & 16384) & ($6 | 0) != 0 | ($3 | 0) == 1) {
        break label$7;
       }
       $3 = $5 + 48 | 0;
       while (1) {
        $3 = HEAP32[$3 >> 2];
        if (!$3) {
         break label$7;
        }
        $4 = HEAP32[$3 + 8 >> 2];
        if (!sqlite3_stricmp($4, $8)) {
         renameTokenFind($1 + 96 | 0, $1 + 72 | 0, $4);
        }
        $3 = $3 + 4 | 0;
        continue;
       }
      }
      $3 = HEAP32[$5 >> 2];
      if (sqlite3_stricmp($8, $3)) {
       break label$3;
      }
      HEAP32[$1 + 84 >> 2] = $5;
      if (!$6) {
       sqlite3WalkExprList($1 + 40 | 0, HEAP32[$5 + 16 >> 2]);
       $3 = HEAP32[$5 >> 2];
      }
      renameTokenFind($1 + 96 | 0, $1 + 72 | 0, $3);
      break label$3;
     }
     $3 = HEAP32[$1 + 336 >> 2];
     if ($3) {
      renameTokenFind($1 + 96 | 0, $1 + 72 | 0, HEAP32[$3 >> 2]);
      if ($6) {
       break label$3;
      }
      sqlite3WalkExpr($1 + 40 | 0, HEAP32[HEAP32[$1 + 336 >> 2] + 36 >> 2]);
      break label$3;
     }
     $4 = HEAP32[$1 + 340 >> 2];
     $3 = HEAP32[$4 + 4 >> 2];
     if (!(sqlite3_stricmp($3, $8) | HEAP32[HEAP32[$1 + 84 >> 2] + 60 >> 2] != HEAP32[$4 + 24 >> 2])) {
      renameTokenFind($1 + 96 | 0, $1 + 72 | 0, $3);
     }
     if ($6) {
      break label$3;
     }
     $3 = renameResolveTrigger($1 + 96 | 0);
     if ($3) {
      break label$2;
     }
     renameWalkTrigger($1 + 40 | 0, $4);
     $3 = $4 + 28 | 0;
     while (1) {
      $6 = HEAP32[$3 >> 2];
      if (!$6) {
       break label$3;
      }
      $3 = HEAP32[$6 + 12 >> 2];
      label$14: {
       if (!$3) {
        break label$14;
       }
       if (sqlite3_stricmp($3, $8)) {
        break label$14;
       }
       renameTokenFind($1 + 96 | 0, $1 + 72 | 0, $3);
      }
      $3 = 0;
      label$15: {
       $4 = HEAP32[$6 + 16 >> 2];
       if (!$4) {
        break label$15;
       }
       while (1) {
        if (HEAP32[$4 >> 2] <= ($3 | 0)) {
         break label$15;
        }
        $5 = HEAP32[(($3 << 6) + $4 | 0) + 16 >> 2];
        if (!sqlite3_stricmp($5, $8)) {
         renameTokenFind($1 + 96 | 0, $1 + 72 | 0, $5);
         $4 = HEAP32[$6 + 16 >> 2];
        }
        $3 = $3 + 1 | 0;
        continue;
       }
      }
      $3 = $6 + 40 | 0;
      continue;
     }
    }
    $3 = HEAP32[$1 + 108 >> 2];
    if ($3) {
     break label$2;
    }
   }
   $3 = renameEditSql($0, $1 + 72 | 0, $9, $10, 1);
  }
  label$18: {
   label$19: {
    label$20: {
     switch ($3 | 0) {
     case 0:
      break label$18;

     case 1:
      break label$20;

     default:
      break label$19;
     }
    }
    if (!sqlite3WritableSchema($7)) {
     break label$19;
    }
    sqlite3_result_value($0, HEAP32[$2 + 12 >> 2]);
    break label$18;
   }
   if (HEAP32[$1 + 100 >> 2]) {
    renameColumnParseError($0, 29623, HEAP32[$2 + 4 >> 2], HEAP32[$2 + 8 >> 2], $1 + 96 | 0);
    break label$18;
   }
   sqlite3_result_error_code($0, $3);
  }
  renameParseCleanup($1 + 96 | 0);
  renameTokenFree($7, HEAP32[$1 + 72 >> 2]);
  HEAP32[$7 + 360 >> 2] = $11;
 }
 __stack_pointer = $1 + 368 | 0;
}

function sqlite3FkCheck($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  $11 = HEAP32[$0 >> 2];
  if (HEAPU8[$1 + 43 | 0] | !(HEAPU8[$11 + 33 | 0] & 64)) {
   break label$1;
  }
  $16 = $2 + 1 | 0;
  $6 = $1 + 48 | 0;
  $10 = HEAP32[$11 + 16 >> 2];
  $13 = sqlite3SchemaToIndex($11, HEAP32[$1 + 60 >> 2]);
  $18 = HEAP32[$10 + ($13 << 4) >> 2];
  $19 = HEAPU8[$0 + 151 | 0];
  while (1) {
   $6 = HEAP32[$6 >> 2];
   if ($6) {
    HEAP32[$9 + 12 >> 2] = 0;
    HEAP32[$9 + 8 >> 2] = 0;
    label$4: {
     label$5: {
      if (!$4) {
       break label$5;
      }
      if (!sqlite3_stricmp(HEAP32[$1 >> 2], HEAP32[$6 + 8 >> 2])) {
       break label$5;
      }
      if (!fkChildIsModified($1, $6, $4, $5)) {
       break label$4;
      }
     }
     $8 = HEAP32[$6 + 8 >> 2];
     label$6: {
      label$7: {
       label$8: {
        if (HEAPU8[$0 + 151 | 0]) {
         $7 = sqlite3FindTable($11, $8, $18);
         break label$8;
        }
        $7 = sqlite3LocateTable($0, 0, $8, $18);
       }
       if ($7) {
        if (!sqlite3FkLocateIndex($0, $7, $6, $9 + 12 | 0, $9 + 8 | 0)) {
         break label$7;
        }
       }
       if (HEAPU8[$11 + 87 | 0] | !$19) {
        break label$1;
       }
       if ($7) {
        break label$4;
       }
       $10 = sqlite3GetVdbe($0);
       $17 = sqlite3VdbeCurrentAddr($10);
       $7 = HEAP32[$6 + 20 >> 2];
       $12 = ($17 + $7 | 0) + 1 | 0;
       $8 = 0;
       while (1) {
        if (($8 | 0) >= ($7 | 0)) {
         break label$6;
        }
        sqlite3VdbeAddOp2($10, 50, sqlite3TableColumnToStorage(HEAP32[$6 >> 2], HEAP16[(($8 << 3) + $6 | 0) + 36 >> 1]) + $16 | 0, $12);
        $8 = $8 + 1 | 0;
        $7 = HEAP32[$6 + 20 >> 2];
        continue;
       }
      }
      $14 = HEAP32[$9 + 8 >> 2];
      if (!$14) {
       HEAP32[$9 + 4 >> 2] = HEAP32[$6 + 36 >> 2];
       $14 = $9 + 4 | 0;
      }
      $17 = $7 + 32 | 0;
      $12 = 0;
      $15 = HEAP32[$9 + 12 >> 2];
      $8 = 0;
      while (1) {
       if (HEAP32[$6 + 20 >> 2] > ($8 | 0)) {
        $10 = ($8 << 2) + $14 | 0;
        if (HEAP32[$10 >> 2] == HEAP16[$1 + 32 >> 1]) {
         HEAP32[$10 >> 2] = -1;
        }
        if (HEAP32[$11 + 360 >> 2]) {
         $10 = $17;
         $12 = HEAP32[$7 + 4 >> 2];
         $10 = $15 ? HEAP32[$15 + 4 >> 2] + ($8 << 1) | 0 : $10;
         $12 = (sqlite3AuthReadCol($0, HEAP32[$7 >> 2], HEAP32[$12 + Math_imul(HEAP16[$10 >> 1], 12) >> 2], $13) | 0) == 2;
        }
        $8 = $8 + 1 | 0;
        continue;
       }
       break;
      }
      sqlite3TableLock($0, $13, HEAP32[$7 + 20 >> 2], 0, HEAP32[$7 >> 2]);
      HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 40 >> 2] + 1;
      if ($2) {
       fkLookupParent($0, $13, $7, $15, $6, $14, $2, -1, $12);
      }
      label$19: {
       if (!$3) {
        break label$19;
       }
       if (isSetNullAction($0, $6)) {
        break label$19;
       }
       fkLookupParent($0, $13, $7, $15, $6, $14, $3, 1, $12);
      }
      sqlite3DbFree($11, HEAP32[$9 + 8 >> 2]);
      break label$4;
     }
     sqlite3VdbeAddOp2($10, 158, HEAPU8[$6 + 24 | 0], -1);
    }
    $6 = $6 + 4 | 0;
    continue;
   }
   break;
  }
  $16 = ($4 | 0) != 0;
  $6 = sqlite3FkReferences($1);
  $10 = $19;
  while (1) {
   if (!$6) {
    break label$1;
   }
   HEAP32[$9 + 12 >> 2] = 0;
   HEAP32[$9 + 8 >> 2] = 0;
   label$21: {
    if ($4) {
     if (!fkParentIsModified($1, $6, $4, $5)) {
      break label$21;
     }
    }
    if (!(HEAP32[$0 + 116 >> 2] | (HEAPU8[$6 + 24 | 0] | HEAPU8[$11 + 34 | 0] & 8))) {
     if (!HEAPU8[$0 + 20 | 0]) {
      break label$21;
     }
    }
    if (sqlite3FkLocateIndex($0, $1, $6, $9 + 12 | 0, $9 + 8 | 0)) {
     if (!$10) {
      break label$1;
     }
     if (!HEAPU8[$11 + 87 | 0]) {
      break label$21;
     }
     break label$1;
    }
    $8 = sqlite3SrcListAppend($0, 0, 0, 0);
    if ($8) {
     $7 = HEAP32[$6 >> 2];
     HEAP32[$8 + 24 >> 2] = $7;
     HEAP32[$8 + 16 >> 2] = HEAP32[$7 >> 2];
     HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] + 1;
     $7 = HEAP32[$0 + 40 >> 2];
     HEAP32[$0 + 40 >> 2] = $7 + 1;
     HEAP32[$8 + 48 >> 2] = $7;
     if ($3) {
      fkScanChildren($0, $8, $1, HEAP32[$9 + 12 >> 2], $6, HEAP32[$9 + 8 >> 2], $3, -1);
     }
     label$27: {
      if (!$2) {
       break label$27;
      }
      $7 = HEAPU8[($6 + $16 | 0) + 25 | 0];
      fkScanChildren($0, $8, $1, HEAP32[$9 + 12 >> 2], $6, HEAP32[$9 + 8 >> 2], $2, 1);
      if (HEAPU8[$6 + 24 | 0]) {
       break label$27;
      }
      label$28: {
       switch ($7 - 8 | 0) {
       case 0:
       case 2:
        break label$27;

       default:
        break label$28;
       }
      }
      sqlite3MayAbort($0);
     }
     HEAP32[$8 + 16 >> 2] = 0;
     sqlite3SrcListDelete($11, $8);
    }
    sqlite3DbFree($11, HEAP32[$9 + 8 >> 2]);
   }
   $6 = HEAP32[$6 + 12 >> 2];
   continue;
  }
 }
 __stack_pointer = $9 + 16 | 0;
}

function convertToWithoutRowidTable($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $6 = HEAP32[$0 + 8 >> 2];
 $7 = HEAP32[$0 >> 2];
 if (!(HEAPU8[$7 + 178 | 0] & 2)) {
  while (1) {
   if (($2 | 0) < HEAP16[$1 + 34 >> 1]) {
    $3 = HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0;
    label$4: {
     if (!(HEAP8[$3 + 10 | 0] & 1)) {
      break label$4;
     }
     $4 = HEAPU8[$3 + 4 | 0];
     if ($4 & 15) {
      break label$4;
     }
     HEAP8[$3 + 4 | 0] = $4 & 240 | 2;
    }
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | 2048;
 }
 $2 = HEAP32[$0 + 132 >> 2];
 if ($2) {
  sqlite3VdbeChangeP3($6, $2, 2);
 }
 label$6: {
  $2 = HEAP16[$1 + 32 >> 1];
  label$7: {
   if (($2 | 0) >= 0) {
    sqlite3TokenInit($8 + 8 | 0, HEAP32[HEAP32[$1 + 4 >> 2] + Math_imul($2 & 65535, 12) >> 2]);
    label$9: {
     $2 = sqlite3ExprListAppend($0, 0, sqlite3ExprAlloc($7, 59, $8 + 8 | 0, 0));
     if ($2) {
      if (HEAPU8[$0 + 208 | 0] >= 2) {
       sqlite3RenameTokenRemap($0, HEAP32[$2 + 8 >> 2], $1 + 32 | 0);
      }
      HEAP8[$2 + 16 | 0] = HEAPU8[$0 + 206 | 0];
      HEAP16[$1 + 32 >> 1] = 65535;
      sqlite3CreateIndex($0, 0, 0, 0, $2, HEAPU8[$1 + 42 | 0], 0, 0, 0, 0, 2);
      if (!HEAP32[$0 + 36 >> 2]) {
       break label$9;
      }
     }
     HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] & -129;
     break label$6;
    }
    $4 = sqlite3PrimaryKeyIndex($1);
    break label$7;
   }
   $4 = sqlite3PrimaryKeyIndex($1);
   $2 = 1;
   $3 = 1;
   while (1) {
    if ($2 >>> 0 < HEAPU16[$4 + 50 >> 1]) {
     label$14: {
      if (isDupColumn($4, $3, $4, $2)) {
       HEAP16[$4 + 52 >> 1] = HEAPU16[$4 + 52 >> 1] - 1;
       break label$14;
      }
      $0 = HEAP32[$4 + 32 >> 2];
      HEAP32[$0 + ($3 << 2) >> 2] = HEAP32[($2 << 2) + $0 >> 2];
      $0 = HEAP32[$4 + 28 >> 2];
      HEAP8[$3 + $0 | 0] = HEAPU8[$0 + $2 | 0];
      $0 = HEAP32[$4 + 4 >> 2];
      HEAP16[$0 + ($3 << 1) >> 1] = HEAPU16[($2 << 1) + $0 >> 1];
      $3 = $3 + 1 | 0;
     }
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP16[$4 + 50 >> 1] = $3;
  }
  $2 = HEAPU8[$4 + 55 | 0] | HEAPU8[$4 + 56 | 0] << 8;
  $0 = $2 | 32;
  HEAP8[$4 + 55 | 0] = $0;
  HEAP8[$4 + 56 | 0] = $0 >>> 8;
  if (!(HEAPU8[$7 + 178 | 0] & 2)) {
   $0 = $2 | 40;
   HEAP8[$4 + 55 | 0] = $0;
   HEAP8[$4 + 56 | 0] = $0 >>> 8;
  }
  $5 = HEAPU16[$4 + 50 >> 1];
  HEAP16[$4 + 52 >> 1] = $5;
  label$17: {
   if (!$6) {
    break label$17;
   }
   $2 = HEAP32[$4 + 44 >> 2];
   if (!$2) {
    break label$17;
   }
   sqlite3VdbeChangeOpcode($6, $2, 8);
  }
  HEAP32[$4 + 44 >> 2] = HEAP32[$1 + 20 >> 2];
  $2 = $1 + 8 | 0;
  while (1) {
   label$19: {
    label$20: {
     $2 = HEAP32[$2 >> 2];
     if (!$2) {
      $2 = 0;
      $3 = HEAP16[$1 + 34 >> 1];
      $3 = ($3 | 0) > 0 ? $3 : 0;
      $0 = 0;
      while (1) {
       if (($2 | 0) == ($3 | 0)) {
        break label$20;
       }
       if (!hasColumn(HEAP32[$4 + 4 >> 2], $5, $2)) {
        $0 = ((HEAPU16[(HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0) + 10 >> 1] ^ -1) >>> 5 & 1) + $0 | 0;
       }
       $2 = $2 + 1 | 0;
       continue;
      }
     }
     if (((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) & 3) == 2) {
      break label$19;
     }
     $3 = 0;
     $0 = 0;
     while (1) {
      if (($3 | 0) != ($5 | 0)) {
       $0 = !isDupColumn($2, HEAPU16[$2 + 50 >> 1], $4, $3) + $0 | 0;
       $3 = $3 + 1 | 0;
       continue;
      }
      break;
     }
     $3 = HEAPU16[$2 + 50 >> 1];
     if (!$0) {
      HEAP16[$2 + 52 >> 1] = $3;
      break label$19;
     }
     if (resizeIndexObject($7, $2, $0 + $3 | 0)) {
      break label$6;
     }
     $0 = HEAPU16[$2 + 50 >> 1];
     $3 = 0;
     while (1) {
      if (($3 | 0) == ($5 | 0)) {
       break label$19;
      }
      if (!isDupColumn($2, HEAPU16[$2 + 50 >> 1], $4, $3)) {
       HEAP16[HEAP32[$2 + 4 >> 2] + ($0 << 1) >> 1] = HEAPU16[HEAP32[$4 + 4 >> 2] + ($3 << 1) >> 1];
       HEAP32[HEAP32[$2 + 32 >> 2] + ($0 << 2) >> 2] = HEAP32[HEAP32[$4 + 32 >> 2] + ($3 << 2) >> 2];
       if (HEAPU8[HEAP32[$4 + 28 >> 2] + $3 | 0]) {
        $6 = HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8 | 512;
        HEAP8[$2 + 55 | 0] = $6;
        HEAP8[$2 + 56 | 0] = $6 >>> 8;
       }
       $0 = $0 + 1 | 0;
      }
      $3 = $3 + 1 | 0;
      continue;
     }
    }
    if (resizeIndexObject($7, $4, $0 + $5 | 0)) {
     break label$6;
    }
    $2 = 0;
    while (1) {
     if (($2 | 0) < HEAP16[$1 + 34 >> 1]) {
      $3 = HEAP32[$4 + 4 >> 2];
      if (!(hasColumn($3, $5, $2) | HEAPU8[(HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0) + 10 | 0] & 32)) {
       HEAP16[($5 << 1) + $3 >> 1] = $2;
       HEAP32[HEAP32[$4 + 32 >> 2] + ($5 << 2) >> 2] = 32384;
       $5 = $5 + 1 | 0;
      }
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    recomputeColumnsNotIndexed($4);
    break label$6;
   }
   $2 = $2 + 20 | 0;
   continue;
  }
 }
 __stack_pointer = $8 + 16 | 0;
}

function substrFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 label$1: {
  $8 = HEAP32[$2 + 4 >> 2];
  label$2: {
   if ((sqlite3_value_type($8) | 0) == 5) {
    break label$2;
   }
   if (($1 | 0) == 3) {
    if ((sqlite3_value_type(HEAP32[$2 + 8 >> 2]) | 0) == 5) {
     break label$2;
    }
   }
   $17 = sqlite3_value_type(HEAP32[$2 >> 2]);
   $4 = sqlite3_value_int($8);
   $8 = HEAP32[$2 >> 2];
   label$4: {
    if (($17 | 0) == 4) {
     $15 = sqlite3_value_bytes($8);
     $8 = sqlite3_value_blob(HEAP32[$2 >> 2]);
     if (!$8) {
      break label$2;
     }
     break label$4;
    }
    $8 = sqlite3_value_text($8);
    if (!$8) {
     break label$2;
    }
    if (($4 | 0) >= 0) {
     break label$4;
    }
    $7 = $8;
    while (1) {
     $5 = HEAPU8[$7 | 0];
     if (!$5) {
      break label$4;
     }
     $3 = $7 + 1 | 0;
     $7 = $3;
     if ($5 >>> 0 >= 192) {
      while (1) {
       $7 = $3;
       $3 = $7 + 1 | 0;
       if ((HEAPU8[$7 | 0] & 192) == 128) {
        continue;
       }
       break;
      }
     }
     $15 = $15 + 1 | 0;
     continue;
    }
   }
   label$9: {
    if (($1 | 0) == 3) {
     $7 = sqlite3_value_int(HEAP32[$2 + 8 >> 2]);
     $3 = $7 >> 31;
     $9 = ($7 ^ $3) - $3 | 0;
     $7 = ($7 | 0) >= 0;
     $2 = 0;
     break label$9;
    }
    $5 = sqlite3_context_db_handle($0);
    $1 = HEAP32[$5 + 120 >> 2];
    $2 = $1 >> 31;
    $9 = $1;
    $7 = 1;
   }
   $10 = $2;
   $1 = $4;
   $2 = $1 >> 31;
   $11 = $1;
   $12 = $2;
   label$11: {
    if (($1 | 0) < 0) {
     $1 = $15;
     $2 = $1 >> 31;
     $5 = $1;
     $6 = $11;
     $4 = $5 + $6 | 0;
     $1 = $12;
     $3 = $2 + $1 | 0;
     $13 = $4;
     $3 = $4 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
     $14 = $3;
     if (($3 | 0) > 0 | ($3 | 0) >= 0) {
      break label$11;
     }
     $2 = $10;
     $3 = $14;
     $4 = $2 + $3 | 0;
     $5 = $13;
     $6 = $9;
     $1 = $5 + $6 | 0;
     $4 = $1 >>> 0 < $5 >>> 0 ? $4 + 1 | 0 : $4;
     $13 = 0;
     $14 = 0;
     $2 = $1;
     $3 = !!$2 & ($4 | 0) >= 0 | ($4 | 0) > 0;
     $2 = $4;
     $6 = $3 ? $1 : 0;
     $9 = $6;
     $5 = $3 ? $2 : 0;
     $10 = $5;
     break label$11;
    }
    if ($4) {
     $3 = $11;
     $4 = $3 - 1 | 0;
     $13 = $4;
     $5 = $12;
     $1 = !$3;
     $1 = $5 - $1 | 0;
     $14 = $1;
     break label$11;
    }
    $5 = $9;
    $1 = $10;
    $3 = !!$5 & ($1 | 0) >= 0 | ($1 | 0) > 0;
    $5 = $1;
    $2 = $9;
    $6 = $2 - $3 | 0;
    $9 = $6;
    $4 = $2 >>> 0 < $3 >>> 0;
    $4 = $5 - $4 | 0;
    $10 = $4;
   }
   $5 = $13;
   $3 = $9;
   $1 = $5 - $3 | 0;
   $4 = $14;
   $2 = $10;
   $6 = $2 + ($5 >>> 0 < $3 >>> 0) | 0;
   $6 = $4 - $6 | 0;
   $16 = $6;
   $2 = !!$1 & ($6 | 0) >= 0 | ($6 | 0) > 0;
   $5 = $2 ? $1 : 0;
   $4 = $6;
   $3 = $2 ? $4 : 0;
   $1 = $3;
   $6 = $7;
   $4 = $6 ? $13 : $5;
   $11 = $4;
   $3 = $14;
   $5 = $1;
   $2 = $6 ? $3 : $5;
   $12 = $2;
   $2 = $16;
   $5 = ($2 | 0) < 0;
   $4 = $5 ? $13 : $9;
   $2 = $10;
   $3 = $5 ? $3 : $2;
   $1 = $3;
   $2 = $7;
   $6 = $2 ? $9 : $4;
   $9 = $6;
   $3 = $10;
   $4 = $1;
   $5 = $2 ? $3 : $4;
   $10 = $5;
   if (($17 | 0) != 4) {
    while (1) {
     $2 = HEAPU8[$8 | 0];
     $5 = $12;
     if (!$2 | !($5 | $11)) {
      break label$1;
     }
     $7 = $8 + 1 | 0;
     $8 = $7;
     if ($2 >>> 0 >= 192) {
      while (1) {
       $8 = $7;
       $7 = $7 + 1 | 0;
       if ((HEAPU8[$8 | 0] & 192) == 128) {
        continue;
       }
       break;
      }
     }
     $2 = $11;
     $4 = $2 - 1 | 0;
     $11 = $4;
     $5 = $12;
     $1 = !$2;
     $1 = $5 - $1 | 0;
     $12 = $1;
     continue;
    }
   }
   $2 = $15;
   $1 = $2 >> 31;
   $13 = $2;
   $5 = $2;
   $3 = $11;
   $6 = $2 - $3 | 0;
   $14 = $1;
   $2 = $12;
   $4 = $2 + ($5 >>> 0 < $3 >>> 0) | 0;
   $4 = $1 - $4 | 0;
   $1 = $6;
   $2 = !!$1 & ($4 | 0) >= 0 | ($4 | 0) > 0;
   $5 = $2 ? $1 : 0;
   $16 = $5;
   $1 = $4;
   $3 = $2 ? $1 : 0;
   $7 = $3;
   $3 = $10;
   $5 = $12;
   $6 = $3 + $5 | 0;
   $1 = $11;
   $2 = $9;
   $4 = $1 + $2 | 0;
   $6 = $4 >>> 0 < $1 >>> 0 ? $6 + 1 | 0 : $6;
   $1 = $13;
   $2 = $14;
   $5 = $1 >>> 0 < $4 >>> 0 & ($6 | 0) >= ($2 | 0) | ($2 | 0) < ($6 | 0);
   $2 = $5 ? $16 : $9;
   $3 = $7;
   $6 = $10;
   $1 = $5 ? $3 : $6;
   sqlite3_result_blob64($0, $8 + $11 | 0, $2, $1, -1);
  }
  return;
 }
 $3 = $8;
 while (1) {
  $1 = $10;
  if (!(!($2 & 255) | !($1 | $9))) {
   $7 = $3 + 1 | 0;
   label$20: {
    if (($2 & 255) >>> 0 > 191) {
     while (1) {
      $3 = $7;
      $7 = $7 + 1 | 0;
      $2 = HEAPU8[$3 | 0];
      if (($2 & 192) == 128) {
       continue;
      }
      break label$20;
     }
    }
    $2 = HEAPU8[$7 | 0];
    $3 = $7;
   }
   $5 = $9;
   $6 = $5 - 1 | 0;
   $9 = $6;
   $1 = $10;
   $4 = !$5;
   $4 = $1 - $4 | 0;
   $10 = $4;
   continue;
  }
  break;
 }
 $5 = $3 - $8 | 0;
 $4 = $5 >> 31;
 sqlite3_result_text64($0, $8, $5, $4, -1, 1);
}

function sqlite3ExprCodeIN($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 12 >> 2] = 0;
 HEAP32[$10 + 4 >> 2] = 0;
 $14 = HEAP32[$1 + 12 >> 2];
 $6 = HEAPU8[$0 + 23 | 0];
 if (!sqlite3ExprCheckIN($0, $1)) {
  $15 = exprINAffinity($0, $1);
  $7 = HEAP32[$0 >> 2];
  $8 = sqlite3ExprVectorSize(HEAP32[$1 + 12 >> 2]);
  $16 = sqlite3DbMallocZero($7, Math_imul($8, 5) + 1 | 0, 0);
  label$2: {
   if (HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
    break label$2;
   }
   $5 = HEAP32[$0 + 8 >> 2];
   $11 = ($2 | 0) == ($3 | 0);
   $9 = sqlite3FindInIndex($0, $1, 3, $11 ? 0 : $10 + 12 | 0, $16, $10 + 4 | 0);
   HEAP8[$0 + 23 | 0] = 0;
   $17 = exprCodeVector($0, $14, $10 + 8 | 0);
   HEAP8[$0 + 23 | 0] = $6;
   $7 = ($8 | 0) > 0 ? $8 : 0;
   while (1) {
    label$4: {
     if (($4 | 0) == ($7 | 0)) {
      $4 = $7;
      break label$4;
     }
     if (HEAP32[($4 << 2) + $16 >> 2] != ($4 | 0)) {
      break label$4;
     }
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   $6 = $17;
   label$6: {
    if (($4 | 0) == ($8 | 0)) {
     break label$6;
    }
    $6 = sqlite3GetTempRange($0, $8);
    $4 = 0;
    while (1) {
     if (($4 | 0) == ($7 | 0)) {
      break label$6;
     }
     sqlite3VdbeAddOp3($5, 80, $4 + $17 | 0, HEAP32[($4 << 2) + $16 >> 2] + $6 | 0, 0);
     $4 = $4 + 1 | 0;
     continue;
    }
   }
   label$8: {
    if (($9 | 0) == 5) {
     $9 = sqlite3VdbeMakeLabel($0);
     $12 = HEAP32[$1 + 20 >> 2];
     $4 = 0;
     $8 = sqlite3ExprCollSeq($0, HEAP32[$1 + 12 >> 2]);
     $1 = 0;
     if (!$11) {
      $1 = sqlite3GetTempReg($0);
      sqlite3VdbeAddOp3($5, 102, $6, $6, $1);
     }
     while (1) {
      if (($4 | 0) < HEAP32[$12 >> 2]) {
       $11 = ($4 << 4) + $12 | 0;
       $14 = $11 + 8 | 0;
       $7 = sqlite3ExprCodeTemp($0, HEAP32[$14 >> 2], $10);
       label$13: {
        if (!$1) {
         break label$13;
        }
        if (!sqlite3ExprCanBeNull(HEAP32[$11 + 8 >> 2])) {
         break label$13;
        }
        sqlite3VdbeAddOp3($5, 102, $1, $7, $1);
       }
       sqlite3ReleaseTempReg($0, HEAP32[$10 >> 2]);
       label$14: {
        if (!(($2 | 0) == ($3 | 0) & (HEAP32[$12 >> 2] - 1 | 0) <= ($4 | 0))) {
         sqlite3VdbeAddOp4($5, ($6 | 0) == ($7 | 0) ? 51 : 53, $6, $9, $7, $8, -2);
         $7 = HEAPU8[$15 | 0];
         break label$14;
        }
        sqlite3VdbeAddOp4($5, ($6 | 0) == ($7 | 0) ? 50 : 52, $6, $2, $7, $8, -2);
        $7 = HEAPU8[$15 | 0] | 16;
       }
       sqlite3VdbeChangeP5($5, $7 << 24 >> 24 & 65535);
       $4 = $4 + 1 | 0;
       continue;
      }
      break;
     }
     if ($1) {
      sqlite3VdbeAddOp2($5, 50, $1, $3);
      sqlite3VdbeGoto($5, $2);
     }
     sqlite3VdbeResolveLabel($5, $9);
     sqlite3ReleaseTempReg($0, $1);
     break label$8;
    }
    $4 = 0;
    $12 = $2;
    if (!$11) {
     $13 = sqlite3VdbeMakeLabel($0);
     $12 = $13;
    }
    while (1) {
     if (($4 | 0) != ($7 | 0)) {
      if (HEAP32[$0 + 36 >> 2]) {
       break label$2;
      }
      if (sqlite3ExprCanBeNull(sqlite3VectorFieldSubexpr(HEAP32[$1 + 12 >> 2], $4))) {
       sqlite3VdbeAddOp2($5, 50, $4 + $6 | 0, $12);
      }
      $4 = $4 + 1 | 0;
      continue;
     }
     break;
    }
    label$22: {
     if (($9 | 0) == 1) {
      $9 = HEAP32[$10 + 4 >> 2];
      sqlite3VdbeAddOp3($5, 29, $9, $2, $6);
      $1 = sqlite3VdbeAddOp0($5, 8);
      break label$22;
     }
     sqlite3VdbeAddOp4($5, 96, $6, $8, 0, $15, $8);
     $9 = HEAP32[$10 + 4 >> 2];
     if (($2 | 0) == ($3 | 0)) {
      sqlite3VdbeAddOp4Int($5, 27, $9, $2, $6, $8);
      break label$8;
     }
     $1 = sqlite3VdbeAddOp4Int($5, 28, $9, 0, $6, $8);
    }
    $18 = $1;
    $4 = HEAP32[$10 + 12 >> 2];
    if (!(!$4 | ($8 | 0) != 1)) {
     sqlite3VdbeAddOp2($5, 51, $4, $2);
    }
    if (($2 | 0) == ($3 | 0)) {
     sqlite3VdbeGoto($5, $2);
    }
    if ($13) {
     sqlite3VdbeResolveLabel($5, $13);
    }
    $13 = sqlite3VdbeAddOp2($5, 35, $9, $2);
    $11 = $2;
    if (($8 | 0) >= 2) {
     $11 = sqlite3VdbeMakeLabel($0);
    }
    $4 = 0;
    while (1) {
     if (($4 | 0) != ($7 | 0)) {
      $12 = sqlite3GetTempReg($0);
      $1 = sqlite3ExprCollSeq($0, sqlite3VectorFieldSubexpr($14, $4));
      sqlite3VdbeAddOp3($5, 94, $9, $4, $12);
      sqlite3VdbeAddOp4($5, 52, $4 + $6 | 0, $11, $12, $1, -2);
      sqlite3ReleaseTempReg($0, $12);
      $4 = $4 + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3VdbeAddOp2($5, 8, 0, $3);
    if (($8 | 0) >= 2) {
     sqlite3VdbeResolveLabel($5, $11);
     sqlite3VdbeAddOp2($5, 38, $9, $13 + 1 | 0);
     sqlite3VdbeAddOp2($5, 8, 0, $2);
    }
    sqlite3VdbeJumpHere($5, $18);
   }
   if (($6 | 0) == ($17 | 0)) {
    break label$2;
   }
   sqlite3ReleaseTempReg($0, $6);
  }
  sqlite3DbFree(HEAP32[$0 >> 2], $16);
  sqlite3DbFree(HEAP32[$0 >> 2], $15);
 }
 __stack_pointer = $10 + 16 | 0;
}

function sqlite3ProcessJoin($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $6 = HEAP32[$1 + 32 >> 2];
 $2 = $6 + 72 | 0;
 $14 = $6 + 8 | 0;
 label$1: {
  while (1) {
   if ((HEAP32[$6 >> 2] - 1 | 0) <= ($9 | 0)) {
    break label$1;
   }
   label$3: {
    label$4: {
     if (!HEAP32[$14 + 16 >> 2]) {
      break label$4;
     }
     $11 = HEAP32[$2 + 16 >> 2];
     if (!$11) {
      break label$4;
     }
     label$5: {
      label$6: {
       $10 = HEAPU8[$2 + 36 | 0];
       if ($10 & 4) {
        if (HEAP32[$2 + 44 >> 2] | HEAPU8[$2 + 38 | 0] & 4) {
         break label$6;
        }
        $3 = 0;
        $5 = 0;
        while (1) {
         if (($5 | 0) < HEAP16[$11 + 34 >> 1]) {
          $7 = HEAP32[$11 + 4 >> 2] + Math_imul($5, 12) | 0;
          label$10: {
           if (HEAPU8[$7 + 10 | 0] & 2) {
            break label$10;
           }
           $8 = HEAP32[$7 >> 2];
           if (!tableAndColumnIndex($6, 0, $9, $8, 0, 0, 1)) {
            break label$10;
           }
           $7 = sqlite3IdListAppend($0, $3, 0);
           $3 = 0;
           if (!$7) {
            break label$10;
           }
           $3 = sqlite3DbStrDup(HEAP32[$0 >> 2], $8);
           HEAP32[(HEAP32[$7 >> 2] << 3) + $7 >> 2] = $3;
           $3 = $7;
          }
          $5 = $5 + 1 | 0;
          continue;
         }
         break;
        }
        if ($3) {
         HEAP32[$2 + 44 >> 2] = $3;
         $3 = HEAPU8[$2 + 37 | 0] | HEAPU8[$2 + 38 | 0] << 8 | 5120;
         HEAP8[$2 + 37 | 0] = $3;
         HEAP8[$2 + 38 | 0] = $3 >>> 8;
        }
        if (HEAP32[$0 + 36 >> 2]) {
         break label$3;
        }
       }
       $16 = $10 & 32 ? 1 : 2;
       $12 = HEAP32[$2 + 44 >> 2];
       if (!(HEAPU8[$2 + 38 | 0] & 4)) {
        break label$5;
       }
       $17 = $9 + 1 | 0;
       $10 = HEAP32[$0 >> 2];
       $13 = 0;
       while (1) {
        if (HEAP32[$12 >> 2] <= ($13 | 0)) {
         break label$4;
        }
        label$13: {
         $5 = HEAP32[(($13 << 3) + $12 | 0) + 8 >> 2];
         $15 = sqlite3ColumnIndex($11, $5);
         if (($15 | 0) >= 0) {
          if (tableAndColumnIndex($6, 0, $9, $5, $4 + 44 | 0, $4 + 40 | 0, (HEAPU8[$2 + 37 | 0] | HEAPU8[$2 + 38 | 0] << 8) >>> 12 & 1)) {
           break label$13;
          }
         }
         HEAP32[$4 >> 2] = $5;
         sqlite3ErrorMsg($0, 5337, $4);
         break label$3;
        }
        $3 = HEAP32[$4 + 40 >> 2];
        $7 = sqlite3CreateColumnExpr($10, $6, HEAP32[$4 + 44 >> 2], $3);
        sqlite3SrcItemColumnUsed(((HEAP32[$4 + 44 >> 2] << 6) + $6 | 0) + 8 | 0, $3);
        $3 = 0;
        label$15: {
         if (!(HEAPU8[$6 + 44 | 0] & 64)) {
          break label$15;
         }
         while (1) {
          label$17: {
           if (tableAndColumnIndex($6, HEAP32[$4 + 44 >> 2] + 1 | 0, $9, $5, $4 + 44 | 0, $4 + 40 | 0, (HEAPU8[$2 + 37 | 0] | HEAPU8[$2 + 38 | 0] << 8) >>> 12 & 1)) {
            $8 = (HEAP32[$4 + 44 >> 2] << 6) + $6 | 0;
            if (HEAPU8[$8 + 46 | 0] & 4) {
             if ((sqlite3IdListIndex(HEAP32[$8 + 52 >> 2], $5) | 0) >= 0) {
              break label$17;
             }
            }
            HEAP32[$4 + 16 >> 2] = $5;
            sqlite3ErrorMsg($0, 26244, $4 + 16 | 0);
           }
           if (!$3) {
            break label$15;
           }
           $7 = sqlite3ExprFunction($0, sqlite3ExprListAppend($0, $3, $7), 48880, 0);
           break label$15;
          }
          $3 = sqlite3ExprListAppend($0, $3, $7);
          $8 = HEAP32[$4 + 40 >> 2];
          $7 = sqlite3CreateColumnExpr($10, $6, HEAP32[$4 + 44 >> 2], $8);
          sqlite3SrcItemColumnUsed(((HEAP32[$4 + 44 >> 2] << 6) + $6 | 0) + 8 | 0, $8);
          continue;
         }
        }
        $3 = sqlite3CreateColumnExpr($10, $6, $17, $15);
        sqlite3SrcItemColumnUsed($2, $15);
        $5 = sqlite3PExpr($0, 53, $7, $3);
        if ($5) {
         HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] | $16;
         HEAP32[$5 + 36 >> 2] = HEAP32[$3 + 28 >> 2];
        }
        HEAP32[$1 + 36 >> 2] = sqlite3ExprAnd($0, HEAP32[$1 + 36 >> 2], $5);
        $13 = $13 + 1 | 0;
        continue;
       }
      }
      HEAP32[$4 + 32 >> 2] = 0;
      sqlite3ErrorMsg($0, 12748, $4 + 32 | 0);
      break label$3;
     }
     if (!$12) {
      break label$4;
     }
     sqlite3SetJoinExpr($12, HEAP32[$2 + 40 >> 2], $16);
     HEAP32[$1 + 36 >> 2] = sqlite3ExprAnd($0, HEAP32[$1 + 36 >> 2], HEAP32[$2 + 44 >> 2]);
     HEAP32[$2 + 44 >> 2] = 0;
     $3 = HEAPU8[$2 + 37 | 0] | HEAPU8[$2 + 38 | 0] << 8 | 2048;
     HEAP8[$2 + 37 | 0] = $3;
     HEAP8[$2 + 38 | 0] = $3 >>> 8;
    }
    $14 = $14 - -64 | 0;
    $2 = $2 - -64 | 0;
    $9 = $9 + 1 | 0;
    continue;
   }
   break;
  }
  $18 = 1;
 }
 __stack_pointer = $4 + 48 | 0;
 return $18;
}

function sqlite3Fts3Offsets($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 $10 = HEAP32[$1 >> 2];
 $15 = HEAP32[HEAP32[$10 + 36 >> 2] >> 2];
 HEAP32[$2 + 152 >> 2] = 0;
 HEAP32[$2 + 144 >> 2] = 0;
 HEAP32[$2 + 148 >> 2] = 0;
 label$1: {
  if (!HEAP32[$1 + 16 >> 2]) {
   sqlite3_result_text($0, 29623, 0, 0);
   break label$1;
  }
  HEAP32[$2 + 136 >> 2] = 0;
  HEAP32[$2 + 140 >> 2] = 0;
  HEAP32[$2 + 128 >> 2] = 0;
  HEAP32[$2 + 132 >> 2] = 0;
  HEAP32[$2 + 120 >> 2] = 0;
  HEAP32[$2 + 124 >> 2] = 0;
  HEAP32[$2 + 112 >> 2] = 0;
  HEAP32[$2 + 116 >> 2] = 0;
  $3 = fts3ExprLoadDoclists($1, 0, $2 + 156 | 0);
  label$3: {
   if ($3) {
    break label$3;
   }
   $3 = sqlite3Fts3MallocZero(Math_imul(HEAP32[$2 + 156 >> 2], 24), 0);
   HEAP32[$2 + 136 >> 2] = $3;
   label$4: {
    if (!$3) {
     break label$4;
    }
    $5 = HEAP32[$1 + 36 >> 2];
    $9 = HEAP32[$1 + 32 >> 2];
    HEAP32[$2 + 112 >> 2] = $1;
    HEAP32[$2 + 128 >> 2] = $9;
    HEAP32[$2 + 132 >> 2] = $5;
    while (1) {
     if (HEAP32[$10 + 24 >> 2] <= ($12 | 0)) {
      $3 = 0;
      break label$3;
     }
     HEAP32[$2 + 100 >> 2] = 0;
     HEAP32[$2 + 96 >> 2] = 0;
     HEAP32[$2 + 92 >> 2] = 0;
     HEAP32[$2 + 120 >> 2] = 0;
     HEAP32[$2 + 116 >> 2] = $12;
     HEAP32[$2 + 88 >> 2] = 0;
     $3 = fts3ExprIterate(HEAP32[$1 + 16 >> 2], 107, $2 + 112 | 0);
     if ($3) {
      break label$3;
     }
     $13 = $12 + 1 | 0;
     $3 = sqlite3_column_text(HEAP32[$1 + 12 >> 2], $13);
     $7 = sqlite3_column_bytes(HEAP32[$1 + 12 >> 2], $13);
     label$7: {
      if (!$3) {
       if ((sqlite3_column_type(HEAP32[$1 + 12 >> 2], $13) | 0) != 5) {
        break label$4;
       }
       break label$7;
      }
      $3 = sqlite3Fts3OpenTokenizer(HEAP32[$10 + 36 >> 2], HEAP32[$1 + 20 >> 2], $3, $7, $2 + 108 | 0);
      if ($3) {
       break label$3;
      }
      $14 = HEAP32[$2 + 108 >> 2];
      $3 = FUNCTION_TABLE[HEAP32[$15 + 20 >> 2]]($14, $2 + 104 | 0, $2 + 100 | 0, $2 + 96 | 0, $2 + 92 | 0, $2 + 88 | 0) | 0;
      while (1) {
       $7 = HEAP32[$2 + 156 >> 2];
       $17 = ($7 | 0) > 0 ? $7 : 0;
       $18 = HEAP32[$2 + 136 >> 2];
       label$10: {
        while (1) {
         if ($3) {
          break label$10;
         }
         $3 = 0;
         $11 = 2147483647;
         $8 = 0;
         while (1) {
          if (($3 | 0) != ($17 | 0)) {
           $7 = Math_imul($3, 24) + $18 | 0;
           if (HEAP32[$7 >> 2]) {
            $4 = $7;
            $5 = HEAP32[$4 + 8 >> 2];
            $6 = $5;
            $16 = HEAP32[$4 + 12 >> 2];
            $9 = HEAP32[$4 + 16 >> 2];
            $5 = HEAP32[$4 + 20 >> 2];
            $4 = $6;
            $6 = $5 + ($9 >>> 0 > $4 >>> 0) | 0;
            $9 = $4 - $9 | 0;
            $5 = $16;
            $6 = $5 - $6 | 0;
            $16 = $6;
            $4 = $11;
            $6 = $4 >> 31;
            $5 = $9;
            $4 = $6;
            $6 = $16;
            $4 = $5 >>> 0 < $11 >>> 0 & ($4 | 0) >= ($6 | 0) | ($4 | 0) > ($6 | 0);
            $11 = $4 ? $5 : $11;
            $8 = $4 ? $7 : $8;
           }
           $3 = $3 + 1 | 0;
           continue;
          }
          break;
         }
         $3 = 101;
         if (!$8) {
          continue;
         }
         break;
        }
        label$15: {
         if (HEAPU8[HEAP32[$8 >> 2]] <= 1) {
          HEAP32[$8 >> 2] = 0;
          break label$15;
         }
         fts3GetDeltaPosition($8, $8 + 8 | 0);
        }
        $3 = 0;
        $14 = HEAP32[$2 + 108 >> 2];
        while (1) {
         if (!(HEAP32[$2 + 88 >> 2] >= ($11 | 0) | $3)) {
          $3 = FUNCTION_TABLE[HEAP32[$15 + 20 >> 2]]($14, $2 + 104 | 0, $2 + 100 | 0, $2 + 96 | 0, $2 + 92 | 0, $2 + 88 | 0) | 0;
          continue;
         }
         break;
        }
        if (!$3) {
         HEAP32[$2 >> 2] = $12;
         $3 = HEAP32[$2 + 96 >> 2];
         HEAP32[$2 + 8 >> 2] = $3;
         HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 92 >> 2] - $3;
         HEAP32[$2 + 4 >> 2] = ($8 - HEAP32[$2 + 136 >> 2] | 0) / 24;
         $3 = fts3StringAppend($2 + 144 | 0, sqlite3_snprintf(64, $2 + 16 | 0, 29053, $2), -1);
         continue;
        }
        if (($3 | 0) != 101) {
         continue;
        }
        $3 = HEAP32[$10 + 40 >> 2] ? 101 : 267;
        continue;
       }
       break;
      }
      FUNCTION_TABLE[HEAP32[$15 + 16 >> 2]]($14) | 0;
      if (($3 | 0) != 101) {
       break label$3;
      }
     }
     $12 = $13;
     continue;
    }
   }
   $3 = 7;
  }
  sqlite3_free(HEAP32[$2 + 136 >> 2]);
  sqlite3Fts3SegmentsClose($10);
  if ($3) {
   sqlite3_result_error_code($0, $3);
   sqlite3_free(HEAP32[$2 + 144 >> 2]);
   break label$1;
  }
  sqlite3_result_text($0, HEAP32[$2 + 144 >> 2], HEAP32[$2 + 148 >> 2] - 1 | 0, 3);
 }
 __stack_pointer = $2 + 160 | 0;
}

function resolveFromTermToCte($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 $4 = HEAP32[$0 + 264 >> 2];
 label$1: {
  if (HEAP32[$0 + 36 >> 2] | !$4 | (HEAP32[$2 + 4 >> 2] | HEAPU8[$2 + 38 | 0] & 2)) {
   break label$1;
  }
  $4 = searchWith($4, $2, $6 + 60 | 0);
  if (!$4) {
   break label$1;
  }
  $12 = HEAP32[$4 + 12 >> 2];
  if ($12) {
   HEAP32[$6 + 48 >> 2] = HEAP32[$4 >> 2];
   sqlite3ErrorMsg($0, $12, $6 + 48 | 0);
   $12 = 2;
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  $12 = 2;
  if (cannotBeFunction($0, $2)) {
   break label$1;
  }
  $7 = sqlite3DbMallocZero($3, 64, 0);
  if (!$7) {
   break label$1;
  }
  $5 = HEAP32[$4 + 16 >> 2];
  if (!$5) {
   $5 = sqlite3DbMallocZero($3, 20, 0);
   HEAP32[$4 + 16 >> 2] = $5;
   label$4: {
    if ($5) {
     if (sqlite3ParserAddCleanup($0, 46, $5)) {
      break label$4;
     }
    }
    sqlite3DbFree($3, $7);
    break label$1;
   }
   HEAP8[$5 + 18 | 0] = HEAPU8[$4 + 20 | 0];
  }
  HEAP32[$2 + 16 >> 2] = $7;
  HEAP32[$7 + 24 >> 2] = 1;
  $11 = sqlite3DbStrDup($3, HEAP32[$4 >> 2]);
  HEAP16[$7 + 38 >> 1] = 200;
  HEAP16[$7 + 32 >> 1] = 65535;
  HEAP32[$7 >> 2] = $11;
  HEAP32[$7 + 28 >> 2] = HEAP32[$7 + 28 >> 2] | 16896;
  $8 = sqlite3SelectDup($3, HEAP32[$4 + 8 >> 2], 0);
  HEAP32[$2 + 20 >> 2] = $8;
  if (HEAPU8[$3 + 87 | 0]) {
   break label$1;
  }
  HEAP32[$8 + 4 >> 2] = HEAP32[$8 + 4 >> 2] | 67108864;
  $3 = HEAPU8[$2 + 37 | 0] | HEAPU8[$2 + 38 | 0] << 8;
  if ($3 & 2) {
   HEAP32[$6 + 32 >> 2] = HEAP32[$2 + 56 >> 2];
   sqlite3ErrorMsg($0, 28800, $6 + 32 | 0);
   break label$1;
  }
  HEAP32[$2 + 60 >> 2] = $5;
  $3 = $3 | 256;
  HEAP8[$2 + 37 | 0] = $3;
  HEAP8[$2 + 38 | 0] = $3 >>> 8;
  $2 = HEAP32[$5 >> 2];
  HEAP32[$5 >> 2] = $2 + 1;
  if (!(HEAPU8[$5 + 18 | 0] != 1 | ($2 | 0) <= 0)) {
   HEAP8[$5 + 18 | 0] = 0;
  }
  $14 = HEAPU8[$8 | 0] & -2;
  $16 = ($14 | 0) != 134;
  $9 = $8;
  $13 = -1;
  label$8: {
   while (1) {
    if ($16) {
     $9 = $8;
     break label$8;
    }
    if (HEAPU8[$9 | 0] != HEAPU8[$8 | 0]) {
     break label$8;
    }
    $11 = HEAP32[$9 + 32 >> 2];
    $5 = HEAP32[$11 >> 2];
    $2 = 0;
    label$11: {
     while (1) {
      if (($2 | 0) < ($5 | 0)) {
       $3 = ($2 << 6) + $11 | 0;
       label$14: {
        if (HEAP32[$3 + 12 >> 2]) {
         break label$14;
        }
        $10 = HEAP32[$3 + 16 >> 2];
        if (!$10) {
         break label$14;
        }
        if (sqlite3StrICmp($10, HEAP32[$4 >> 2])) {
         break label$14;
        }
        HEAP32[$3 + 24 >> 2] = $7;
        HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] + 1;
        $10 = $3 + 45 | 0;
        $15 = HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8 | 64;
        HEAP8[$10 | 0] = $15;
        HEAP8[$10 + 1 | 0] = $15 >>> 8;
        $10 = HEAP32[$9 + 4 >> 2];
        if ($10 & 8192) {
         break label$11;
        }
        HEAP32[$9 + 4 >> 2] = $10 | 8192;
        if (($13 | 0) < 0) {
         $13 = HEAP32[$0 + 40 >> 2];
         HEAP32[$0 + 40 >> 2] = $13 + 1;
        }
        HEAP32[$3 + 48 >> 2] = $13;
       }
       $2 = $2 + 1 | 0;
       continue;
      }
      break;
     }
     if (!(HEAPU8[$9 + 5 | 0] & 32)) {
      break label$8;
     }
     $9 = HEAP32[$9 + 52 >> 2];
     continue;
    }
    break;
   }
   HEAP32[$6 >> 2] = HEAP32[$4 >> 2];
   sqlite3ErrorMsg($0, 7910, $6);
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = 8019;
  $5 = HEAP32[$0 + 264 >> 2];
  $2 = HEAP32[$6 + 60 >> 2];
  HEAP32[$0 + 264 >> 2] = $2;
  label$16: {
   label$17: {
    if (HEAPU8[$8 + 5 | 0] & 32) {
     HEAP32[$9 + 64 >> 2] = HEAP32[$8 + 64 >> 2];
     $3 = sqlite3WalkSelect($1, $9);
     HEAP32[$9 + 64 >> 2] = 0;
     if (!$3) {
      break label$17;
     }
     break label$16;
    }
    if (sqlite3WalkSelect($1, $8)) {
     break label$16;
    }
   }
   HEAP32[$0 + 264 >> 2] = $2;
   $2 = $8;
   while (1) {
    $3 = $2;
    $2 = HEAP32[$2 + 52 >> 2];
    if ($2) {
     continue;
    }
    break;
   }
   $3 = HEAP32[$3 + 28 >> 2];
   label$20: {
    $2 = HEAP32[$4 + 4 >> 2];
    if (!$2) {
     $2 = $3;
     break label$20;
    }
    if (!$3) {
     break label$20;
    }
    $3 = HEAP32[$3 >> 2];
    $11 = HEAP32[$2 >> 2];
    if (($3 | 0) == ($11 | 0)) {
     break label$20;
    }
    $2 = HEAP32[$4 >> 2];
    HEAP32[$6 + 24 >> 2] = $11;
    HEAP32[$6 + 20 >> 2] = $3;
    HEAP32[$6 + 16 >> 2] = $2;
    sqlite3ErrorMsg($0, 4875, $6 + 16 | 0);
    break label$16;
   }
   sqlite3ColumnsFromExprList($0, $2, $7 + 34 | 0, $7 + 4 | 0);
   if (($14 | 0) == 134) {
    HEAP32[$4 + 12 >> 2] = HEAP32[$8 + 4 >> 2] & 8192 ? 7175 : 6966;
    sqlite3WalkSelect($1, $8);
   }
   HEAP32[$4 + 12 >> 2] = 0;
   HEAP32[$0 + 264 >> 2] = $5;
   $12 = 1;
   break label$1;
  }
  HEAP32[$0 + 264 >> 2] = $5;
 }
 __stack_pointer = $6 - -64 | 0;
 return $12;
}

function valueFromExpr($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 12 >> 2] = 0;
 label$1: {
  while (1) {
   label$3: {
    label$4: {
     label$5: {
      $6 = HEAPU8[$1 | 0];
      switch ($6 - 174 | 0) {
      case 1:
       break label$1;

      case 2:
       break label$3;

      case 0:
       break label$4;

      default:
       break label$5;
      }
     }
     if (($6 | 0) != 181) {
      break label$1;
     }
    }
    $1 = HEAP32[$1 + 12 >> 2];
    continue;
   }
   break;
  }
  $6 = HEAPU8[$1 + 2 | 0];
 }
 label$6: {
  label$7: {
   label$8: {
    label$9: {
     label$10: {
      $5 = $6 & 255;
      if (($5 | 0) != 173) {
       if (($5 | 0) != 36) {
        $10 = 29623;
        $9 = 1;
        break label$10;
       }
       $6 = sqlite3AffinityType(HEAP32[$1 + 8 >> 2], 0);
       $8 = HEAP32[$1 + 12 >> 2];
       $1 = $6 & 255;
       $11 = valueFromExpr($0, $8, $2, $1, $4);
       $6 = HEAP32[$4 >> 2];
       if (!$6) {
        break label$6;
       }
       sqlite3VdbeMemCast($6, $1, $2);
       sqlite3ValueApplyAffinity(HEAP32[$4 >> 2], $3, $2);
       break label$6;
      }
      $10 = 24269;
      $9 = -1;
      $8 = -1;
      label$13: {
       $1 = HEAP32[$1 + 12 >> 2];
       $6 = HEAPU8[$1 | 0];
       switch ($6 - 153 | 0) {
       case 0:
       case 2:
        break label$10;

       default:
        break label$13;
       }
      }
      $1 = valueFromExpr($0, $1, $2, $3, $7 + 12 | 0);
      $5 = HEAP32[$7 + 12 >> 2];
      if ($1 | !$5) {
       break label$9;
      }
      sqlite3VdbeMemNumerify($5);
      $1 = HEAPU16[$5 + 16 >> 1];
      label$14: {
       if ($1 & 8) {
        HEAPF64[$5 >> 3] = -HEAPF64[$5 >> 3];
        break label$14;
       }
       $8 = HEAP32[$5 + 4 >> 2];
       $9 = HEAP32[$5 >> 2];
       if (!$9 & ($8 | 0) == -2147483648) {
        HEAP32[$5 >> 2] = 0;
        HEAP32[$5 + 4 >> 2] = 1138753536;
        HEAP16[$5 + 16 >> 1] = $1 & 62016 | 8;
        break label$14;
       }
       HEAP32[$5 >> 2] = 0 - $9;
       $1 = $8 + (($9 | 0) != 0) | 0;
       $1 = 0 - $1 | 0;
       HEAP32[$5 + 4 >> 2] = $1;
      }
      sqlite3ValueApplyAffinity($5, $3, $2);
      break label$9;
     }
     label$17: {
      label$18: {
       label$19: {
        label$20: {
         label$21: {
          $12 = $6 & 255;
          switch ($12 - 153 | 0) {
          case 1:
           break label$18;

          case 0:
          case 2:
           break label$20;

          default:
           break label$21;
          }
         }
         $5 = 0;
         switch ($12 - 117 | 0) {
         case 4:
          break label$19;

         case 0:
          break label$20;

         case 1:
         case 2:
         case 3:
          break label$9;

         default:
          break label$17;
         }
        }
        $5 = valueNew($0);
        if (!$5) {
         break label$8;
        }
        label$22: {
         if (HEAPU8[$1 + 5 | 0] & 8) {
          $1 = HEAP32[$1 + 8 >> 2];
          $0 = $1 >> 31;
          $10 = $0;
          $0 = $8;
          $8 = $1;
          $1 = $10;
          $1 = __wasm_i64_mul($9, $0, $8, $1);
          $0 = i64toi32_i32$HIGH_BITS;
          sqlite3VdbeMemSetInt64($5, $1, $0);
          break label$22;
         }
         HEAP32[$7 + 4 >> 2] = HEAP32[$1 + 8 >> 2];
         HEAP32[$7 >> 2] = $10;
         $1 = sqlite3MPrintf($0, 5782, $7);
         if (!$1) {
          break label$7;
         }
         sqlite3ValueSetStr($5, $1, 1, 1);
        }
        sqlite3ValueApplyAffinity($5, ($3 | 0) == 65 ? ($6 & 253) == 153 ? 67 : $3 : $3, 1);
        $1 = HEAPU16[$5 + 16 >> 1];
        if ($1 & 44) {
         HEAP16[$5 + 16 >> 1] = $1 & 65533;
        }
        if (($2 | 0) == 1) {
         break label$9;
        }
        $11 = sqlite3VdbeChangeEncoding($5, $2);
        break label$9;
       }
       $5 = valueNew($0);
       HEAP32[$7 + 12 >> 2] = $5;
       if (!$5) {
        break label$8;
       }
       sqlite3VdbeMemSetNull($5);
       break label$9;
      }
      $5 = valueNew($0);
      HEAP32[$7 + 12 >> 2] = $5;
      if (!$5) {
       break label$8;
      }
      $1 = HEAP32[$1 + 8 >> 2] + 2 | 0;
      $6 = sqlite3Strlen30($1) - 1 | 0;
      sqlite3VdbeMemSetStr($5, sqlite3HexToBlob($0, $1, $6), ($6 | 0) / 2 | 0, 0, 0, 1);
      break label$9;
     }
     if (($12 | 0) != 170) {
      break label$9;
     }
     $5 = valueNew($0);
     HEAP32[$7 + 12 >> 2] = $5;
     if (!$5) {
      $5 = 0;
      break label$9;
     }
     HEAP16[$5 + 16 >> 1] = 4;
     HEAP32[$5 >> 2] = !HEAPU8[HEAP32[$1 + 8 >> 2] + 4 | 0];
     HEAP32[$5 + 4 >> 2] = 0;
    }
    HEAP32[$4 >> 2] = $5;
    break label$6;
   }
   $5 = 0;
  }
  sqlite3OomFault($0);
  sqlite3DbFree($0, 0);
  sqlite3ValueFree($5);
  $11 = 7;
 }
 __stack_pointer = $7 + 16 | 0;
 return $11;
}

function sqlite3VdbeHalt($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $1 = HEAP32[$0 >> 2];
 if (HEAPU8[$1 + 87 | 0]) {
  HEAP32[$0 + 36 >> 2] = 7;
 }
 closeAllCursors($0);
 label$2: {
  label$3: {
   if (HEAP8[$0 + 150 | 0] >= 0) {
    break label$3;
   }
   sqlite3VdbeEnter($0);
   $2 = HEAP32[$0 + 36 >> 2];
   label$4: {
    label$5: {
     if (!$2) {
      break label$5;
     }
     label$6: {
      $5 = $2 & 255;
      if ($5 >>> 0 > 13) {
       break label$6;
      }
      $3 = 1;
      if (!(1 << $5 & 9856)) {
       break label$6;
      }
      $5 = 0;
      $4 = HEAPU8[$0 + 150 | 0];
      $2 = $2 & 255;
      if (!(!($4 & 64) | ($2 | 0) != 9)) {
       $4 = 1;
       break label$4;
      }
      if (!(!($4 & 32) | ($2 | 0) != 13 & ($2 | 0) != 7)) {
       $5 = 2;
       $4 = 0;
       break label$4;
      }
      sqlite3RollbackAll($1, 516);
      sqlite3CloseSavepoints($1);
      HEAP8[$1 + 85 | 0] = 1;
      HEAP32[$0 + 40 >> 2] = 0;
      HEAP32[$0 + 44 >> 2] = 0;
      $4 = 1;
      if (!HEAP32[$0 + 36 >> 2]) {
       break label$5;
      }
      break label$4;
     }
     $3 = 0;
     $4 = 1;
     $5 = 0;
     if (HEAPU8[$0 + 146 | 0] != 3) {
      break label$4;
     }
    }
    sqlite3VdbeCheckFk($0, 0);
    $4 = 1;
   }
   label$9: {
    label$10: {
     label$11: {
      if (!(!HEAPU8[$1 + 85 | 0] | (HEAP32[$1 + 404 >> 2] ? 0 : HEAP32[$1 + 380 >> 2] > 0) | HEAP32[$1 + 192 >> 2] != ((HEAPU8[$0 + 150 | 0] ^ -1) >>> 6 & 1))) {
       label$14: {
        if (!(HEAPU8[$0 + 146 | 0] != 3 | $3 ? HEAP32[$0 + 36 >> 2] : 0)) {
         $2 = 1;
         label$17: {
          label$18: {
           if (sqlite3VdbeCheckFk($0, 1)) {
            $3 = 787;
            if (!(HEAPU8[$0 + 150 | 0] & 64)) {
             break label$18;
            }
            break label$2;
           }
           $3 = HEAP32[$1 + 36 >> 2];
           $2 = HEAP32[$1 + 32 >> 2];
           $6 = $2;
           $2 = $3 & 2;
           if ($2) {
            HEAP32[$1 + 32 >> 2] = $6;
            $2 = $3;
            $3 = $2 & -3;
            HEAP32[$1 + 36 >> 2] = $3;
            $3 = 11;
            break label$18;
           }
           $3 = vdbeCommit($1, $0);
           if (!$3) {
            break label$17;
           }
           $2 = 5;
           if (($3 | 0) != 5) {
            break label$18;
           }
           $3 = 5;
           if (HEAPU8[$0 + 150 | 0] & 64) {
            break label$2;
           }
          }
          HEAP32[$0 + 36 >> 2] = $3;
          sqlite3RollbackAll($1, 0);
          HEAP32[$0 + 40 >> 2] = 0;
          HEAP32[$0 + 44 >> 2] = 0;
          break label$14;
         }
         HEAP32[$1 + 512 >> 2] = 0;
         HEAP32[$1 + 516 >> 2] = 0;
         HEAP32[$1 + 520 >> 2] = 0;
         HEAP32[$1 + 524 >> 2] = 0;
         $3 = HEAP32[$1 + 32 >> 2];
         $2 = $3;
         $3 = HEAP32[$1 + 36 >> 2];
         $2 = $2 & -524289;
         HEAP32[$1 + 32 >> 2] = $2;
         HEAP32[$1 + 36 >> 2] = $3;
         sqlite3CommitInternalChanges($1);
         break label$14;
        }
        sqlite3RollbackAll($1, 0);
        HEAP32[$0 + 40 >> 2] = 0;
        HEAP32[$0 + 44 >> 2] = 0;
       }
       $2 = 0;
       HEAP32[$1 + 504 >> 2] = 0;
       if (!$4) {
        break label$11;
       }
       break label$9;
      }
      if (!$4) {
       break label$11;
      }
      $5 = 1;
      if (!HEAP32[$0 + 36 >> 2]) {
       break label$11;
      }
      $2 = 0;
      label$21: {
       switch (HEAPU8[$0 + 146 | 0] - 2 | 0) {
       case 1:
        break label$11;

       case 0:
        break label$21;

       default:
        break label$10;
       }
      }
      $5 = 2;
     }
     $2 = sqlite3VdbeCloseStatement($0, $5);
     if (!$2) {
      $2 = $5;
      break label$9;
     }
     $4 = HEAP32[$0 + 36 >> 2];
     if (!(($4 & 255) != 19 ? $4 : 0)) {
      HEAP32[$0 + 36 >> 2] = $2;
      sqlite3DbFree($1, HEAP32[$0 + 124 >> 2]);
      HEAP32[$0 + 124 >> 2] = 0;
     }
     $2 = $5;
    }
    sqlite3RollbackAll($1, 516);
    sqlite3CloseSavepoints($1);
    HEAP8[$1 + 85 | 0] = 1;
    HEAP32[$0 + 40 >> 2] = 0;
    HEAP32[$0 + 44 >> 2] = 0;
   }
   if (!(HEAPU8[$0 + 150 | 0] & 16)) {
    break label$3;
   }
   $6 = 0;
   $3 = 0;
   if (($2 | 0) != 2) {
    $3 = HEAP32[$0 + 40 >> 2];
    $6 = $3;
    $2 = HEAP32[$0 + 44 >> 2];
    $3 = $2;
   }
   $2 = $3;
   sqlite3VdbeSetChanges($1, $6, $2);
   HEAP32[$0 + 40 >> 2] = 0;
   HEAP32[$0 + 44 >> 2] = 0;
  }
  HEAP32[$1 + 184 >> 2] = HEAP32[$1 + 184 >> 2] - 1;
  $2 = HEAPU8[$0 + 150 | 0];
  if (!($2 & 64)) {
   HEAP32[$1 + 192 >> 2] = HEAP32[$1 + 192 >> 2] - 1;
   $2 = HEAPU8[$0 + 150 | 0];
  }
  if ($2 << 24 >> 24 < 0) {
   HEAP32[$1 + 188 >> 2] = HEAP32[$1 + 188 >> 2] - 1;
  }
  HEAP8[$0 + 149 | 0] = 3;
  if (!HEAPU8[$1 + 87 | 0]) {
   return HEAP32[$0 + 36 >> 2] == 5 ? 5 : 0;
  }
  HEAP32[$0 + 36 >> 2] = 7;
  $2 = 0;
 }
 return $2;
}

function fts3ExprBalance($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $2 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   if (!$1) {
    $5 = 1;
    break label$2;
   }
   $9 = HEAP32[$2 >> 2];
   label$4: {
    if ($9 - 3 >>> 0 <= 1) {
     $4 = $1 << 2;
     $3 = sqlite3_malloc64($4, 0);
     if (!$3) {
      $5 = 7;
      break label$2;
     }
     $10 = memset($3, 0, $4);
     $3 = $2;
     while (1) if (HEAP32[$3 >> 2] != ($9 | 0)) {
      HEAP32[$6 + 12 >> 2] = $3;
      $13 = $1 - 1 | 0;
      $4 = 0;
      label$9: {
       label$10: {
        while (1) {
         $7 = HEAP32[$3 + 8 >> 2];
         HEAP32[$3 + 8 >> 2] = 0;
         $12 = 0;
         if ($7) {
          HEAP32[$7 + 12 >> 2] = 0;
          $12 = $2;
         }
         label$13: {
          $5 = fts3ExprBalance($6 + 12 | 0, $13);
          if (!$5) {
           $3 = 0;
           $2 = HEAP32[$6 + 12 >> 2];
           while (1) {
            if (!(!$2 | ($1 | 0) <= ($3 | 0))) {
             $8 = ($3 << 2) + $10 | 0;
             $5 = HEAP32[$8 >> 2];
             label$17: {
              if (!$5) {
               $5 = $2;
               $2 = 0;
               break label$17;
              }
              HEAP32[$4 + 16 >> 2] = $2;
              HEAP32[$4 + 12 >> 2] = $5;
              HEAP32[$5 + 8 >> 2] = $4;
              HEAP32[$2 + 8 >> 2] = $4;
              $11 = HEAP32[$4 + 8 >> 2];
              $5 = 0;
              HEAP32[$4 + 8 >> 2] = 0;
              $2 = $4;
              $4 = $11;
             }
             HEAP32[$8 >> 2] = $5;
             $3 = $3 + 1 | 0;
             continue;
            }
            break;
           }
           if (!$2) {
            break label$13;
           }
           sqlite3Fts3ExprFree($2);
           $5 = 18;
          }
          $3 = 0;
          $2 = ($1 | 0) > 0 ? $1 : 0;
          while (1) {
           if (($2 | 0) == ($3 | 0)) {
            break label$10;
           }
           sqlite3Fts3ExprFree(HEAP32[($3 << 2) + $10 >> 2]);
           $3 = $3 + 1 | 0;
           continue;
          }
         }
         if ($7) {
          $2 = $7 + 16 | 0;
          while (1) {
           $3 = HEAP32[$2 >> 2];
           $2 = $3 + 12 | 0;
           if (HEAP32[$3 >> 2] == ($9 | 0)) {
            continue;
           }
           break;
          }
          HEAP32[$6 + 12 >> 2] = $3;
          $2 = HEAP32[$7 + 16 >> 2];
          HEAP32[$2 + 8 >> 2] = HEAP32[$7 + 8 >> 2];
          $5 = HEAP32[$7 + 8 >> 2];
          if ($5) {
           HEAP32[$5 + 12 >> 2] = $2;
           $2 = $12;
          }
          HEAP32[$7 + 8 >> 2] = $4;
          $4 = $7;
          continue;
         }
         break;
        }
        $5 = 0;
        $9 = ($1 | 0) > 0 ? $1 : 0;
        $2 = 0;
        $3 = 0;
        while (1) {
         if (($3 | 0) == ($9 | 0)) {
          break label$9;
         }
         $8 = ($3 << 2) + $10 | 0;
         $11 = HEAP32[$8 >> 2];
         if ($11) {
          label$25: {
           if (!$2) {
            $2 = $11;
            break label$25;
           }
           HEAP32[$4 + 16 >> 2] = $2;
           $8 = HEAP32[$8 >> 2];
           HEAP32[$4 + 12 >> 2] = $8;
           HEAP32[$8 + 8 >> 2] = $4;
           HEAP32[$2 + 8 >> 2] = $4;
           $2 = $4;
           $4 = HEAP32[$2 + 8 >> 2];
          }
          HEAP32[$2 + 8 >> 2] = 0;
         }
         $3 = $3 + 1 | 0;
         continue;
        }
       }
       while (1) {
        if ($4) {
         $3 = HEAP32[$4 + 8 >> 2];
         sqlite3_free($4);
         $4 = $3;
         continue;
        }
        break;
       }
       $2 = $12;
      }
      sqlite3_free($10);
      break label$4;
     } else {
      $3 = HEAP32[$3 + 12 >> 2];
      continue;
     }
    }
    if (($9 | 0) != 2) {
     break label$1;
    }
    $3 = HEAP32[$2 + 12 >> 2];
    HEAP32[$6 + 8 >> 2] = $3;
    $4 = HEAP32[$2 + 16 >> 2];
    HEAP32[$6 + 4 >> 2] = $4;
    HEAP32[$2 + 12 >> 2] = 0;
    HEAP32[$2 + 16 >> 2] = 0;
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$4 + 8 >> 2] = 0;
    label$30: {
     $3 = $1 - 1 | 0;
     $5 = fts3ExprBalance($6 + 8 | 0, $3);
     if (!$5) {
      $5 = fts3ExprBalance($6 + 4 | 0, $3);
      if (!$5) {
       break label$30;
      }
      $4 = HEAP32[$6 + 4 >> 2];
     }
     sqlite3Fts3ExprFree($4);
     sqlite3Fts3ExprFree(HEAP32[$6 + 8 >> 2]);
     break label$4;
    }
    $4 = HEAP32[$6 + 8 >> 2];
    HEAP32[$2 + 12 >> 2] = $4;
    HEAP32[$4 + 8 >> 2] = $2;
    $4 = HEAP32[$6 + 4 >> 2];
    HEAP32[$2 + 16 >> 2] = $4;
    HEAP32[$4 + 8 >> 2] = $2;
    $5 = 0;
   }
   if ($5) {
    break label$2;
   }
   $5 = 0;
   break label$1;
  }
  sqlite3Fts3ExprFree($2);
  $2 = 0;
 }
 HEAP32[$0 >> 2] = $2;
 __stack_pointer = $6 + 16 | 0;
 return $5;
}

function sqlite3BtreeIndexMoveto($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $11 = sqlite3VdbeFindCompare($1);
 HEAP8[$1 + 23 | 0] = 0;
 label$1: {
  label$2: {
   label$3: {
    if (HEAPU8[$0 | 0]) {
     break label$3;
    }
    $3 = HEAP32[$0 + 116 >> 2];
    if (!HEAPU8[$3 + 8 | 0]) {
     break label$3;
    }
    if (!cursorOnLastPage($0)) {
     break label$3;
    }
    label$4: {
     $4 = HEAPU16[$3 + 24 >> 1] - 1 | 0;
     $3 = HEAPU16[$0 + 70 >> 1];
     if (($4 | 0) != ($3 | 0)) {
      break label$4;
     }
     $3 = indexCellCompare($0, $3, $1, $11);
     if (($3 | 0) > 0 | HEAPU8[$1 + 23 | 0]) {
      break label$4;
     }
     HEAP32[$2 >> 2] = $3;
     return 0;
    }
    label$5: {
     if (HEAP8[$0 + 68 | 0] <= 0) {
      break label$5;
     }
     if ((indexCellCompare($0, 0, $1, $11) | 0) > 0 | HEAPU8[$1 + 23 | 0]) {
      break label$5;
     }
     HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 251;
     if (HEAPU8[HEAP32[$0 + 116 >> 2]]) {
      break label$2;
     }
     return sqlite3CorruptError(72703);
    }
    HEAP8[$1 + 23 | 0] = 0;
   }
   $6 = moveToRoot($0);
   if (!$6) {
    break label$2;
   }
   if (($6 | 0) != 16) {
    break label$1;
   }
   HEAP32[$2 >> 2] = -1;
   return 0;
  }
  $12 = $0 + 32 | 0;
  while (1) {
   $3 = HEAP32[$0 + 116 >> 2];
   $5 = HEAPU16[$3 + 24 >> 1] - 1 | 0;
   $8 = $5;
   $9 = 0;
   label$7: {
    label$8: {
     while (1) {
      $7 = HEAP32[$3 + 64 >> 2] + ($5 & -2) | 0;
      $7 = HEAP32[$3 + 68 >> 2] + (HEAPU16[$3 + 26 >> 1] & (HEAPU8[$7 | 0] << 8 | HEAPU8[$7 + 1 | 0])) | 0;
      $6 = $7 + 1 | 0;
      $10 = $5 >> 1;
      $5 = HEAPU8[$7 | 0];
      label$10: {
       if ($5 >>> 0 <= HEAPU8[$3 + 11 | 0]) {
        $5 = FUNCTION_TABLE[$11 | 0]($5, $6, $1) | 0;
        break label$10;
       }
       label$12: {
        $6 = HEAP8[$6 | 0];
        if (($6 | 0) < 0) {
         break label$12;
        }
        $5 = ($5 << 7 & 16256) + ($6 & 255) | 0;
        if ($5 >>> 0 > HEAPU16[$3 + 14 >> 1]) {
         break label$12;
        }
        $5 = FUNCTION_TABLE[$11 | 0]($5, $7 + 2 | 0, $1) | 0;
        break label$10;
       }
       FUNCTION_TABLE[HEAP32[$3 + 80 >> 2]]($3, $7 - HEAPU8[$3 + 10 | 0] | 0, $12);
       label$13: {
        $4 = HEAP32[$12 >> 2];
        $5 = $4;
        if (($4 | 0) >= 2) {
         $7 = HEAP32[$0 + 20 >> 2];
         if (($5 >>> 0) / HEAPU32[$7 + 40 >> 2] >>> 0 <= HEAPU32[$7 + 48 >> 2]) {
          break label$13;
         }
        }
        $6 = sqlite3CorruptError(72790);
        break label$7;
       }
       $4 = $4 + 18 | 0;
       $7 = sqlite3Malloc($4, $4 >> 31);
       if (!$7) {
        $6 = 7;
        break label$7;
       }
       HEAP16[$0 + 70 >> 1] = $10;
       $6 = accessPayload($0, 0, $5, $7, 0);
       $4 = $5 + $7 | 0;
       HEAP8[$4 + 16 | 0] = 0;
       HEAP8[$4 + 17 | 0] = 0;
       HEAP8[$4 + 8 | 0] = 0;
       HEAP8[$4 + 9 | 0] = 0;
       HEAP8[$4 + 10 | 0] = 0;
       HEAP8[$4 + 11 | 0] = 0;
       HEAP8[$4 + 12 | 0] = 0;
       HEAP8[$4 + 13 | 0] = 0;
       HEAP8[$4 + 14 | 0] = 0;
       HEAP8[$4 + 15 | 0] = 0;
       HEAP8[$4 | 0] = 0;
       HEAP8[$4 + 1 | 0] = 0;
       HEAP8[$4 + 2 | 0] = 0;
       HEAP8[$4 + 3 | 0] = 0;
       HEAP8[$4 + 4 | 0] = 0;
       HEAP8[$4 + 5 | 0] = 0;
       HEAP8[$4 + 6 | 0] = 0;
       HEAP8[$4 + 7 | 0] = 0;
       HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 251;
       if ($6) {
        sqlite3_free($7);
        break label$7;
       }
       $5 = sqlite3VdbeRecordCompare($5, $7, $1);
       sqlite3_free($7);
      }
      label$17: {
       label$18: {
        if (($5 | 0) < 0) {
         $9 = $10 + 1 | 0;
         break label$18;
        }
        if (!$5) {
         break label$17;
        }
        $8 = $10 - 1 | 0;
       }
       if (($9 | 0) > ($8 | 0)) {
        break label$8;
       }
       $5 = $9 + $8 | 0;
       continue;
      }
      break;
     }
     $6 = 0;
     HEAP32[$2 >> 2] = 0;
     HEAP16[$0 + 70 >> 1] = $10;
     if (!HEAPU8[$1 + 23 | 0]) {
      break label$7;
     }
     $6 = sqlite3CorruptError(72822);
     break label$7;
    }
    if (HEAPU8[$3 + 8 | 0]) {
     HEAP16[$0 + 70 >> 1] = $10;
     HEAP32[$2 >> 2] = $5;
     $6 = 0;
     break label$7;
    }
    $5 = HEAP32[$3 + 56 >> 2];
    label$21: {
     if (HEAPU16[$3 + 24 >> 1] <= ($9 | 0)) {
      $3 = sqlite3Get4byte((HEAPU8[$3 + 9 | 0] + $5 | 0) + 8 | 0);
      break label$21;
     }
     $8 = HEAP32[$3 + 64 >> 2] + ($9 << 1) | 0;
     $3 = sqlite3Get4byte((HEAPU16[$3 + 26 >> 1] & (HEAPU8[$8 | 0] << 8 | HEAPU8[$8 + 1 | 0])) + $5 | 0);
    }
    HEAP16[$0 + 70 >> 1] = $9;
    $6 = moveToChild($0, $3);
    if (!$6) {
     continue;
    }
   }
   break;
  }
  HEAP16[$0 + 50 >> 1] = 0;
 }
 return $6;
}

function sqlite3BtreeDelete($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 + 8 >> 2];
 $6 = HEAP32[$5 + 4 >> 2];
 label$1: {
  label$2: {
   $2 = HEAPU8[$0 | 0];
   if ($2) {
    if ($2 >>> 0 < 3) {
     break label$2;
    }
    $2 = btreeRestoreCursorPosition($0);
    if ($2) {
     break label$1;
    }
    $2 = 0;
    if (HEAPU8[$0 | 0]) {
     break label$1;
    }
   }
   $8 = HEAPU16[$0 + 70 >> 1];
   $3 = HEAP32[$0 + 116 >> 2];
   if ($8 >>> 0 >= HEAPU16[$3 + 24 >> 1]) {
    $2 = sqlite3CorruptError(76317);
    break label$1;
   }
   $10 = HEAP8[$0 + 68 | 0];
   $2 = HEAP32[$3 + 64 >> 2] + ($8 << 1) | 0;
   $9 = HEAPU8[$2 | 0];
   $2 = HEAPU8[$2 + 1 | 0];
   $7 = HEAPU16[$3 + 26 >> 1];
   $11 = HEAP32[$3 + 56 >> 2];
   label$5: {
    if (HEAP32[$3 + 20 >> 2] >= 0) {
     break label$5;
    }
    if (!btreeComputeFreeSpace($3)) {
     break label$5;
    }
    $2 = sqlite3CorruptError(76321);
    break label$1;
   }
   $7 = (($9 << 8 | $2) & $7) + $11 | 0;
   $9 = 0;
   $1 = $1 & 2;
   label$6: {
    if (!$1) {
     break label$6;
    }
    label$7: {
     if (!HEAPU8[$3 + 8 | 0]) {
      break label$7;
     }
     $9 = 1;
     if (((HEAP32[$3 + 20 >> 2] + (FUNCTION_TABLE[HEAP32[$3 + 76 >> 2]]($3, $7) | 0) | 0) + 2 | 0) > ((HEAP32[$6 + 40 >> 2] << 1 >>> 0) / 3 | 0)) {
      break label$7;
     }
     if (HEAPU16[$3 + 24 >> 1] != 1) {
      break label$6;
     }
    }
    $2 = saveCursorKey($0);
    HEAP32[$4 + 28 >> 2] = $2;
    $9 = 0;
    if ($2) {
     break label$1;
    }
   }
   if (!HEAPU8[$3 + 8 | 0]) {
    $2 = sqlite3BtreePrevious($0);
    if ($2) {
     break label$1;
    }
   }
   if (HEAPU8[$0 + 1 | 0] & 32) {
    $2 = saveAllCursors($6, HEAP32[$0 + 64 >> 2], $0);
    if ($2) {
     break label$1;
    }
   }
   if (!(HEAP32[$0 + 112 >> 2] | !HEAPU8[$5 + 11 | 0])) {
    invalidateIncrblobCursors($5, HEAP32[$0 + 64 >> 2], HEAP32[$0 + 32 >> 2], HEAP32[$0 + 36 >> 2], 0);
   }
   $2 = sqlite3PagerWrite(HEAP32[$3 + 72 >> 2]);
   if ($2) {
    break label$1;
   }
   FUNCTION_TABLE[HEAP32[$3 + 80 >> 2]]($3, $7, $4);
   $2 = 0;
   if (HEAP32[$4 + 12 >> 2] != HEAPU16[$4 + 16 >> 1]) {
    $2 = clearCellOverflow($3, $7, $4);
   }
   HEAP32[$4 + 28 >> 2] = $2;
   dropCell($3, $8, HEAPU16[$4 + 18 >> 1], $4 + 28 | 0);
   $2 = HEAP32[$4 + 28 >> 2];
   if ($2) {
    break label$1;
   }
   if (!HEAPU8[$3 + 8 | 0]) {
    $7 = $0 + 116 | 0;
    $5 = HEAP32[$7 >> 2];
    if (HEAP32[$5 + 20 >> 2] < 0) {
     $2 = btreeComputeFreeSpace($5);
     if ($2) {
      break label$1;
     }
    }
    $2 = (HEAP32[$5 + 64 >> 2] + (HEAPU16[$5 + 24 >> 1] << 1) | 0) - 2 | 0;
    $2 = HEAPU16[$5 + 26 >> 1] & (HEAPU8[$2 | 0] << 8 | HEAPU8[$2 + 1 | 0]);
    if ($2 >>> 0 <= 3) {
     $2 = sqlite3CorruptError(76412);
     break label$1;
    }
    $7 = HEAP32[HEAP32[((HEAP8[$0 + 68 | 0] - 1 | 0) > ($10 | 0) ? (($10 << 2) + $0 | 0) + 124 | 0 : $7) >> 2] + 4 >> 2];
    $11 = HEAP32[$5 + 56 >> 2] + $2 | 0;
    $2 = FUNCTION_TABLE[HEAP32[$5 + 76 >> 2]]($5, $11) | 0;
    $12 = HEAP32[$6 + 84 >> 2];
    $6 = sqlite3PagerWrite(HEAP32[$5 + 72 >> 2]);
    HEAP32[$4 + 28 >> 2] = $6;
    if (!$6) {
     insertCell($3, $8, $11 - 4 | 0, $2 + 4 | 0, $12, $7, $4 + 28 | 0);
    }
    dropCell($5, HEAPU16[$5 + 24 >> 1] - 1 | 0, $2, $4 + 28 | 0);
    $2 = HEAP32[$4 + 28 >> 2];
    if ($2) {
     break label$1;
    }
   }
   if ((Math_imul(HEAP32[HEAP32[$0 + 116 >> 2] + 20 >> 2], 3) | 0) > HEAP32[HEAP32[$0 + 20 >> 2] + 40 >> 2] << 1) {
    $2 = balance($0);
    if ($2) {
     break label$1;
    }
   }
   if (HEAP8[$0 + 68 | 0] > ($10 | 0)) {
    releasePageNotNull(HEAP32[$0 + 116 >> 2]);
    $2 = HEAPU8[$0 + 68 | 0] - 1 | 0;
    HEAP8[$0 + 68 | 0] = $2;
    while (1) {
     $6 = $2 << 24 >> 24;
     if (($6 | 0) > ($10 | 0)) {
      HEAP8[$0 + 68 | 0] = $2 - 1;
      releasePage(HEAP32[(($6 << 2) + $0 | 0) + 120 >> 2]);
      $2 = HEAPU8[$0 + 68 | 0];
      continue;
     }
     break;
    }
    HEAP32[$0 + 116 >> 2] = HEAP32[(($6 << 2) + $0 | 0) + 120 >> 2];
    $2 = balance($0);
    if ($2) {
     break label$1;
    }
   }
   if ($9) {
    HEAP8[$0 | 0] = 2;
    $2 = HEAPU16[$3 + 24 >> 1];
    if ($8 >>> 0 >= $2 >>> 0) {
     HEAP32[$0 + 4 >> 2] = -1;
     HEAP16[$0 + 70 >> 1] = $2 - 1;
     $2 = 0;
     break label$1;
    }
    HEAP32[$0 + 4 >> 2] = 1;
    $2 = 0;
    break label$1;
   }
   $2 = moveToRoot($0);
   if ($1) {
    btreeReleaseAllCursorPages($0);
    HEAP8[$0 | 0] = 3;
   }
   if (($2 | 0) != 16) {
    break label$1;
   }
   $2 = 0;
   HEAP32[$4 + 28 >> 2] = 0;
   break label$1;
  }
  $2 = sqlite3CorruptError(76308);
 }
 __stack_pointer = $4 + 32 | 0;
 return $2;
}

function fts3PoslistMerge($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 44 >> 2] = HEAP32[$0 >> 2];
 $6 = HEAP32[$1 >> 2];
 HEAP32[$3 + 40 >> 2] = $6;
 HEAP32[$3 + 36 >> 2] = HEAP32[$2 >> 2];
 while (1) {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         $5 = HEAPU8[$6 | 0];
         label$9: {
          label$10: {
           if (!$5) {
            $4 = HEAP32[$3 + 36 >> 2];
            if (!HEAPU8[$4 | 0]) {
             break label$6;
            }
            $4 = 2147483647;
            break label$10;
           }
           $4 = 0;
           if (($5 | 0) != 1) {
            break label$10;
           }
           $4 = HEAP8[$6 + 1 | 0];
           label$12: {
            if (($4 | 0) < 0) {
             sqlite3Fts3GetVarint32($6 + 1 | 0, $3 + 32 | 0);
             $4 = HEAP32[$3 + 32 >> 2];
             break label$12;
            }
            $4 = $4 & 255;
           }
           if (!$4) {
            break label$9;
           }
          }
          $5 = 2147483647;
          label$14: {
           $7 = HEAP32[$3 + 36 >> 2];
           switch (HEAPU8[$7 | 0]) {
           case 1:
            break label$14;

           case 0:
            break label$7;

           default:
            break label$8;
           }
          }
          $5 = HEAP8[$7 + 1 | 0];
          label$15: {
           if (($5 | 0) < 0) {
            sqlite3Fts3GetVarint32($7 + 1 | 0, $3 + 28 | 0);
            $5 = HEAP32[$3 + 28 >> 2];
            break label$15;
           }
           $5 = $5 & 255;
          }
          if ($5) {
           break label$7;
          }
         }
         $5 = 267;
         break label$2;
        }
        $5 = 0;
       }
       if (($4 | 0) != ($5 | 0)) {
        break label$4;
       }
       HEAP32[$3 + 16 >> 2] = 0;
       HEAP32[$3 + 20 >> 2] = 0;
       HEAP32[$3 + 8 >> 2] = 0;
       HEAP32[$3 + 12 >> 2] = 0;
       HEAP32[$3 >> 2] = 0;
       HEAP32[$3 + 4 >> 2] = 0;
       $4 = fts3PutColNumber($3 + 44 | 0, $4);
       HEAP32[$3 + 36 >> 2] = $7 + $4;
       HEAP32[$3 + 40 >> 2] = $4 + $6;
       fts3GetDeltaVarint($3 + 40 | 0, $3 + 16 | 0);
       fts3GetDeltaVarint($3 + 36 | 0, $3 + 8 | 0);
       $4 = HEAP32[$3 + 20 >> 2];
       $7 = $4;
       $9 = HEAP32[$3 + 16 >> 2];
       if (($4 | 0) >= 0 & $9 >>> 0 >= 2 | ($4 | 0) > 0) {
        $4 = HEAP32[$3 + 12 >> 2];
        $5 = $4;
        $8 = HEAP32[$3 + 8 >> 2];
        if ($8 >>> 0 > 1 & ($4 | 0) >= 0 | ($4 | 0) > 0) {
         break label$5;
        }
       }
       $4 = HEAP32[$3 + 36 >> 2];
       $6 = HEAP32[$3 + 40 >> 2];
      }
      $7 = HEAP32[$3 + 44 >> 2];
      HEAP32[$3 + 44 >> 2] = $7 + 1;
      $5 = 0;
      HEAP8[$7 | 0] = 0;
      HEAP32[$0 >> 2] = HEAP32[$3 + 44 >> 2];
      HEAP32[$1 >> 2] = $6 + 1;
      HEAP32[$2 >> 2] = $4 + 1;
      break label$2;
     }
     while (1) {
      $4 = $5;
      $6 = ($7 | 0) <= ($4 | 0) & $8 >>> 0 > $9 >>> 0 | ($4 | 0) > ($7 | 0);
      $4 = $6 ? $9 : $8;
      fts3PutDeltaVarint($3 + 44 | 0, $3, $4, $6 ? $7 : $5);
      $4 = HEAP32[$3 + 4 >> 2];
      $6 = HEAP32[$3 >> 2];
      $10 = $6 >>> 0 < 2;
      $10 = $4 - $10 | 0;
      HEAP32[$3 >> 2] = $6 - 2;
      HEAP32[$3 + 4 >> 2] = $10;
      $4 = $9;
      $6 = $5;
      label$19: {
       if (($4 | 0) == ($8 | 0) & ($6 | 0) == ($7 | 0)) {
        fts3ReadNextPos($3 + 40 | 0, $3 + 16 | 0);
        fts3ReadNextPos($3 + 36 | 0, $3 + 8 | 0);
        break label$19;
       }
       $4 = $7;
       $6 = $8;
       if (($4 | 0) <= ($5 | 0) & $6 >>> 0 > $9 >>> 0 | ($4 | 0) < ($5 | 0)) {
        fts3ReadNextPos($3 + 40 | 0, $3 + 16 | 0);
        break label$19;
       }
       fts3ReadNextPos($3 + 36 | 0, $3 + 8 | 0);
      }
      $4 = HEAP32[$3 + 20 >> 2];
      $7 = $4;
      $9 = HEAP32[$3 + 16 >> 2];
      $6 = $9;
      $10 = ($6 | 0) != -1 | ($4 | 0) != 2147483647;
      $6 = HEAP32[$3 + 8 >> 2];
      $8 = $6;
      $4 = HEAP32[$3 + 12 >> 2];
      $5 = $4;
      if (($8 | 0) != -1 | ($4 | 0) != 2147483647 | $10) {
       continue;
      }
      break;
     }
     break label$3;
    }
    if (($4 | 0) < ($5 | 0)) {
     HEAP32[$3 + 40 >> 2] = fts3PutColNumber($3 + 44 | 0, $4) + $6;
     fts3ColumnlistCopy($3 + 44 | 0, $3 + 40 | 0);
     break label$3;
    }
    HEAP32[$3 + 36 >> 2] = fts3PutColNumber($3 + 44 | 0, $5) + $7;
    fts3ColumnlistCopy($3 + 44 | 0, $3 + 36 | 0);
   }
   $6 = HEAP32[$3 + 40 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 48 | 0;
 return $5;
}

function fts3auxNextMethod($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 $9 = HEAP32[HEAP32[$0 >> 2] + 12 >> 2];
 $6 = HEAP32[$0 + 96 >> 2];
 $3 = $6;
 $2 = HEAP32[$0 + 100 >> 2];
 $4 = $3 + 1 | 0;
 $6 = $4 ? $2 : $2 + 1 | 0;
 HEAP32[$0 + 96 >> 2] = $4;
 HEAP32[$0 + 100 >> 2] = $6;
 $1 = HEAP32[$0 + 108 >> 2];
 $7 = HEAP32[$0 + 104 >> 2];
 $8 = $7 + 1 | 0;
 $8 = ($1 | 0) > ($8 | 0) ? $1 : $8;
 label$1: {
  label$2: {
   while (1) {
    $7 = $7 + 1 | 0;
    if (($7 | 0) >= ($1 | 0)) {
     break label$2;
    }
    $2 = HEAP32[$0 + 112 >> 2] + ($7 << 4) | 0;
    $6 = HEAP32[$2 >> 2];
    $3 = HEAP32[$2 + 4 >> 2];
    $2 = $6;
    if (!$2 & ($3 | 0) <= 0 | ($3 | 0) < 0) {
     continue;
    }
    break;
   }
   HEAP32[$0 + 104 >> 2] = $7;
   $9 = 0;
   break label$1;
  }
  HEAP32[$0 + 104 >> 2] = $8;
  $9 = sqlite3Fts3SegReaderStep($9, $0 + 4 | 0);
  if (($9 | 0) == 100) {
   $13 = HEAP32[$0 + 52 >> 2];
   $14 = HEAP32[$0 + 56 >> 2];
   label$5: {
    $7 = HEAP32[$0 + 76 >> 2];
    if (!$7) {
     break label$5;
    }
    $9 = 0;
    $1 = HEAP32[$0 + 80 >> 2];
    $8 = HEAP32[$0 + 48 >> 2];
    $7 = memcmp($7, HEAP32[$0 + 44 >> 2], ($1 | 0) < ($8 | 0) ? $1 : $8);
    if (($1 | 0) >= ($8 | 0) | $7 ? ($7 | 0) >= 0 : 0) {
     break label$5;
    }
    HEAP32[$0 + 88 >> 2] = 1;
    break label$1;
   }
   $9 = 7;
   if (fts3auxGrowStatArray($0, 2)) {
    break label$1;
   }
   $7 = 0;
   memset(HEAP32[$0 + 112 >> 2], 0, HEAP32[$0 + 108 >> 2] << 4);
   $1 = 0;
   while (1) {
    if (($7 | 0) < ($14 | 0)) {
     $3 = $10;
     HEAP32[$3 + 8 >> 2] = 0;
     HEAP32[$3 + 12 >> 2] = 0;
     $8 = sqlite3Fts3GetVarint($7 + $13 | 0, $3 + 8 | 0);
     label$8: {
      label$9: {
       label$10: {
        label$11: {
         label$12: {
          switch ($1 | 0) {
          case 2:
           $5 = $10;
           $2 = HEAP32[$5 + 8 >> 2];
           $4 = $2;
           $3 = HEAP32[$5 + 12 >> 2];
           $11 = $3;
           break label$11;

          case 0:
           $1 = HEAP32[$0 + 112 >> 2];
           $3 = HEAP32[$1 >> 2];
           $5 = $3;
           $2 = HEAP32[$1 + 4 >> 2];
           $6 = $5 + 1 | 0;
           $4 = $6 ? $2 : $2 + 1 | 0;
           HEAP32[$1 >> 2] = $6;
           HEAP32[$1 + 4 >> 2] = $4;
           $1 = 1;
           $12 = 0;
           break label$8;

          case 1:
           break label$12;

          default:
           break label$10;
          }
         }
         $2 = $10;
         $4 = HEAP32[$2 + 8 >> 2];
         $5 = HEAP32[$2 + 12 >> 2];
         $11 = $5;
         $2 = $4;
         if ($2 >>> 0 < 2 & ($5 | 0) <= 0 | ($5 | 0) < 0) {
          break label$11;
         }
         $1 = HEAP32[$0 + 112 >> 2];
         $2 = HEAP32[$1 + 16 >> 2];
         $6 = $2;
         $5 = HEAP32[$1 + 20 >> 2];
         $3 = $6 + 1 | 0;
         $6 = $3 ? $5 : $5 + 1 | 0;
         HEAP32[$1 + 16 >> 2] = $3;
         HEAP32[$1 + 20 >> 2] = $6;
        }
        $6 = $11;
        $5 = $4;
        if (!$6 & $5 >>> 0 <= 1) {
         $1 = 0;
         if ($4 - 1 | 0) {
          break label$8;
         }
         $1 = 3;
         break label$8;
        }
        $1 = HEAP32[$0 + 112 >> 2];
        $11 = $1 + ($12 << 4) | 0;
        $4 = $11;
        $5 = HEAP32[$4 + 24 >> 2];
        $6 = HEAP32[$4 + 28 >> 2];
        $4 = $5;
        $3 = $6;
        $2 = $4 + 1 | 0;
        $3 = $2 ? $3 : $3 + 1 | 0;
        $4 = $11 + 24 | 0;
        HEAP32[$4 >> 2] = $2;
        HEAP32[$4 + 4 >> 2] = $3;
        $3 = HEAP32[$1 + 8 >> 2];
        $6 = $3;
        $4 = HEAP32[$1 + 12 >> 2];
        $2 = $4;
        $5 = $6 + 1 | 0;
        $2 = $5 ? $2 : $2 + 1 | 0;
        HEAP32[$1 + 8 >> 2] = $5;
        HEAP32[$1 + 12 >> 2] = $2;
        break label$9;
       }
       $12 = HEAP32[$10 + 8 >> 2];
       if (($12 | 0) <= 0) {
        $15 = 267;
        break label$8;
       }
       if (fts3auxGrowStatArray($0, $12 + 2 | 0)) {
        break label$1;
       }
       $4 = HEAP32[$0 + 112 >> 2] + ($12 << 4) | 0;
       $1 = $4 + 16 | 0;
       $2 = HEAP32[$4 + 16 >> 2];
       $6 = HEAP32[$4 + 20 >> 2];
       $4 = $2;
       $5 = $6;
       $3 = $4 + 1 | 0;
       $5 = $3 ? $5 : $5 + 1 | 0;
       HEAP32[$1 >> 2] = $3;
       HEAP32[$1 + 4 >> 2] = $5;
      }
      $1 = 2;
     }
     $7 = $7 + $8 | 0;
     continue;
    }
    break;
   }
   HEAP32[$0 + 104 >> 2] = 0;
   $9 = $15;
   break label$1;
  }
  HEAP32[$0 + 88 >> 2] = 1;
 }
 __stack_pointer = $10 + 16 | 0;
 return $9 | 0;
}

function sqlite3AddColumn($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $11 = __stack_pointer - 32 | 0;
 __stack_pointer = $11;
 $7 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$7) {
   break label$1;
  }
  $13 = HEAP32[$0 >> 2];
  if (HEAP32[$13 + 128 >> 2] <= HEAP16[$7 + 34 >> 1]) {
   HEAP32[$11 + 16 >> 2] = HEAP32[$7 >> 2];
   sqlite3ErrorMsg($0, 6165, $11 + 16 | 0);
   break label$1;
  }
  if (HEAPU8[$0 + 208 | 0] <= 1) {
   sqlite3DequoteToken($1);
  }
  label$4: {
   label$5: {
    label$6: {
     $5 = HEAP32[$2 + 4 >> 2];
     label$7: {
      label$8: {
       if ($5 >>> 0 < 16) {
        break label$8;
       }
       $3 = $5 - 6 | 0;
       $4 = HEAP32[$2 >> 2];
       if (sqlite3_strnicmp($3 + $4 | 0, 3378, 6)) {
        break label$7;
       }
       while (1) {
        $5 = $3;
        if (!$3) {
         break label$6;
        }
        $3 = $5 - 1 | 0;
        if (HEAP8[HEAPU8[$4 + $3 | 0] + 30288 | 0] & 1) {
         continue;
        }
        break;
       }
       HEAP32[$2 + 4 >> 2] = $5;
       if ($5 >>> 0 < 9) {
        break label$8;
       }
       $3 = $5 - 9 | 0;
       if (sqlite3_strnicmp($4 + $3 | 0, 14935, 9)) {
        break label$7;
       }
       while (1) {
        $5 = $3;
        if (!$3) {
         break label$6;
        }
        $3 = $5 - 1 | 0;
        if (HEAP8[HEAPU8[$4 + $3 | 0] + 30288 | 0] & 1) {
         continue;
        }
        break;
       }
       HEAP32[$2 + 4 >> 2] = $5;
      }
      if ($5 >>> 0 < 3) {
       break label$5;
      }
     }
     sqlite3DequoteToken($2);
     $4 = HEAP32[$2 >> 2];
     $5 = HEAP32[$2 + 4 >> 2];
     $15 = 1;
     $3 = 0;
     while (1) {
      $12 = 65;
      if (($3 | 0) == 6) {
       break label$4;
      }
      label$12: {
       if (HEAPU8[$3 + 48916 | 0] != ($5 | 0)) {
        break label$12;
       }
       if (sqlite3_strnicmp($4, HEAP32[($3 << 2) + 65328 >> 2], $5)) {
        break label$12;
       }
       $5 = 0;
       HEAP32[$2 + 4 >> 2] = 0;
       $15 = ($3 & 2147483643) == 1 ? 5 : 1;
       $17 = ($3 << 4) + 16 | 0;
       $12 = HEAPU8[$3 + 48922 | 0];
       break label$4;
      }
      $3 = $3 + 1 | 0;
      continue;
     }
    }
    $5 = 0;
    HEAP32[$2 + 4 >> 2] = 0;
   }
   $15 = 1;
   $12 = 65;
  }
  $4 = HEAP32[$1 + 4 >> 2];
  $3 = $4 + $5 | 0;
  $6 = $3;
  $8 = $3 >>> 0 < $5 >>> 0 ? 1 : $8;
  $3 = $8;
  $14 = ($5 | 0) != 0;
  $8 = $6;
  $6 = $14 + $8 | 0;
  $3 = $6 >>> 0 < $8 >>> 0 ? $3 + 1 | 0 : $3;
  $8 = $6;
  $6 = $3;
  $3 = $8 + 1 | 0;
  $6 = $3 ? $6 : $6 + 1 | 0;
  $9 = sqlite3DbMallocRaw($13, $3, $6);
  if (!$9) {
   break label$1;
  }
  if (HEAPU8[$0 + 208 | 0] >= 2) {
   sqlite3RenameTokenMap($0, $9, $1);
  }
  $3 = 0;
  $10 = __memcpy($9, HEAP32[$1 >> 2], $4);
  HEAP8[$10 + $4 | 0] = 0;
  sqlite3Dequote($10);
  $16 = sqlite3StrIHash($10);
  $4 = HEAP16[$7 + 34 >> 1];
  $1 = ($4 | 0) > 0 ? $4 : 0;
  $9 = HEAP32[$7 + 4 >> 2];
  $8 = $4;
  $6 = $4 >> 31;
  label$14: {
   label$15: {
    while (1) {
     if (($1 | 0) != ($3 | 0)) {
      label$18: {
       $4 = Math_imul($3, 12) + $9 | 0;
       if (HEAPU8[$4 + 7 | 0] != ($16 | 0)) {
        break label$18;
       }
       if (sqlite3StrICmp($10, HEAP32[$4 >> 2])) {
        break label$18;
       }
       HEAP32[$11 >> 2] = $10;
       sqlite3ErrorMsg($0, 7760, $11);
       break label$15;
      }
      $3 = $3 + 1 | 0;
      continue;
     }
     break;
    }
    $8 = __wasm_i64_mul($8, $6, 12, 0);
    $3 = $8;
    $6 = i64toi32_i32$HIGH_BITS;
    $14 = $3 + 12 | 0;
    $3 = $14 >>> 0 < 12 ? $6 + 1 | 0 : $6;
    $4 = sqlite3DbRealloc($13, $9, $14, $3);
    if ($4) {
     break label$14;
    }
   }
   sqlite3DbFree($13, $10);
   break label$1;
  }
  HEAP32[$7 + 4 >> 2] = $4;
  $1 = HEAP16[$7 + 34 >> 1];
  $3 = Math_imul($1, 12) + $4 | 0;
  HEAP32[$3 + 4 >> 2] = 0;
  HEAP32[$3 + 8 >> 2] = 0;
  HEAP32[$3 >> 2] = $10;
  HEAP8[$3 + 7 | 0] = $16;
  label$19: {
   if (!$5) {
    HEAP8[$3 + 6 | 0] = $15;
    HEAP8[$3 + 4 | 0] = HEAPU8[$3 + 4 | 0] & 15 | $17;
    break label$19;
   }
   $9 = __memcpy((sqlite3Strlen30($10) + $10 | 0) + 1 | 0, HEAP32[$2 >> 2], $5);
   HEAP8[$9 + $5 | 0] = 0;
   sqlite3Dequote($9);
   $12 = sqlite3AffinityType($9, $3);
   HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 4;
  }
  HEAP8[(Math_imul($1, 12) + $4 | 0) + 5 | 0] = $12;
  HEAP16[$7 + 34 >> 1] = HEAPU16[$7 + 34 >> 1] + 1;
  HEAP16[$7 + 36 >> 1] = HEAPU16[$7 + 36 >> 1] + 1;
  HEAP32[$0 + 76 >> 2] = 0;
 }
 __stack_pointer = $11 + 32 | 0;
}

function pagerPlaybackSavepoint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 label$1: {
  label$2: {
   if (!$1) {
    break label$2;
   }
   $15 = sqlite3BitvecCreate(HEAP32[$1 + 20 >> 2]);
   if ($15) {
    break label$2;
   }
   $9 = 7;
   break label$1;
  }
  HEAP32[$0 + 28 >> 2] = HEAP32[($1 ? $1 + 20 | 0 : $0 + 32 | 0) >> 2];
  HEAP8[$0 + 19 | 0] = HEAPU8[$0 + 12 | 0];
  label$4: {
   label$5: {
    label$6: {
     if (!$1) {
      if (!HEAP32[$0 + 232 >> 2]) {
       $7 = $0 + 80 | 0;
       $2 = HEAP32[$0 + 80 >> 2];
       $12 = $2;
       $3 = HEAP32[$0 + 84 >> 2];
       $13 = $3;
       break label$6;
      }
      $9 = pagerRollbackWal($0);
      break label$1;
     }
     $7 = $0 + 80 | 0;
     $3 = HEAP32[$0 + 80 >> 2];
     $12 = $3;
     $2 = HEAP32[$0 + 84 >> 2];
     $13 = $2;
     if (HEAP32[$0 + 232 >> 2]) {
      break label$6;
     }
     $4 = $1;
     $2 = HEAP32[$4 + 8 >> 2];
     $11 = $2;
     $3 = HEAP32[$4 + 12 >> 2];
     $8 = $3;
     $2 = HEAP32[$4 + 4 >> 2];
     $3 = HEAP32[$4 >> 2];
     HEAP32[$7 >> 2] = $3;
     HEAP32[$7 + 4 >> 2] = $2;
     $2 = $8;
     $5 = !($2 | $11);
     $3 = $5 ? $12 : $11;
     $11 = $3;
     $2 = $13;
     $3 = $8;
     $4 = $5 ? $2 : $3;
     $8 = $4;
     while (1) {
      if ($9) {
       break label$4;
      }
      $4 = HEAP32[$7 >> 2];
      $5 = $4;
      $4 = $8;
      $3 = HEAP32[$7 + 4 >> 2];
      $2 = $11;
      if (($4 | 0) <= ($3 | 0) & $2 >>> 0 <= $5 >>> 0 | ($3 | 0) > ($4 | 0)) {
       break label$5;
      }
      $9 = pager_playback_one_page($0, $7, $15, 1, 1);
      continue;
     }
    }
    HEAP32[$7 >> 2] = 0;
    HEAP32[$7 + 4 >> 2] = 0;
   }
   $9 = 0;
  }
  label$10: while (1) {
   label$11: {
    if ($9) {
     break label$11;
    }
    $2 = $7;
    $5 = HEAP32[$2 >> 2];
    $4 = $5;
    $3 = HEAP32[$2 + 4 >> 2];
    $5 = $13;
    $2 = $4;
    $4 = $12;
    if (($3 | 0) >= ($5 | 0) & $2 >>> 0 >= $4 >>> 0 | ($3 | 0) > ($5 | 0)) {
     break label$11;
    }
    HEAP32[$10 >> 2] = 0;
    $2 = $13;
    $9 = readJournalHdr($0, 0, $12, $2, $10, $10 + 12 | 0);
    $14 = HEAP32[$10 >> 2];
    label$12: {
     if ($14) {
      break label$12;
     }
     $14 = 0;
     $2 = HEAP32[$0 + 88 >> 2];
     $4 = $2;
     $3 = HEAP32[$0 + 92 >> 2];
     $2 = $3;
     $3 = HEAP32[$0 + 156 >> 2];
     $5 = $3;
     $3 = $4 + $5 | 0;
     $6 = $3 >>> 0 < $5 >>> 0 ? $2 + 1 | 0 : $2;
     $11 = $3;
     $8 = $6;
     $6 = HEAP32[$0 + 80 >> 2];
     $4 = HEAP32[$0 + 84 >> 2];
     $16 = $4;
     $2 = $3;
     $5 = $6;
     $4 = $8;
     $6 = $16;
     if (($2 | 0) != ($5 | 0) | ($4 | 0) != ($6 | 0)) {
      break label$12;
     }
     $5 = $12;
     $6 = $11;
     $3 = $5 - $6 | 0;
     $11 = $3;
     $2 = $13;
     $3 = $8 + ($6 >>> 0 > $5 >>> 0) | 0;
     $3 = $2 - $3 | 0;
     $6 = $3;
     $3 = HEAP32[$0 + 168 >> 2];
     $2 = $3;
     $5 = HEAP32[$0 + 172 >> 2];
     $4 = $2 + 8 | 0;
     $3 = $4 >>> 0 < 8 ? $5 + 1 | 0 : $5;
     $2 = $3;
     $3 = $6;
     $2 = __wasm_i64_sdiv($11, $3, $4, $2);
     $14 = $2;
    }
    $8 = 0;
    while (1) {
     if ($8 >>> 0 >= $14 >>> 0 | $9) {
      continue label$10;
     }
     $5 = $7;
     $3 = HEAP32[$5 >> 2];
     $6 = $3;
     $2 = HEAP32[$5 + 4 >> 2];
     $3 = $2;
     $2 = $13;
     $5 = $12;
     if (($2 | 0) <= ($3 | 0) & $5 >>> 0 <= $6 >>> 0 | ($3 | 0) > ($2 | 0)) {
      $9 = 0;
      continue label$10;
     } else {
      $8 = $8 + 1 | 0;
      $9 = pager_playback_one_page($0, $7, $15, 1, 1);
      continue;
     }
    }
   }
   break;
  }
  label$16: {
   if (!$1) {
    break label$16;
   }
   $5 = HEAP32[$0 + 168 >> 2];
   $6 = $5;
   $2 = HEAP32[$0 + 172 >> 2];
   $3 = $6 + 4 | 0;
   $4 = $3 >>> 0 < 4 ? $2 + 1 | 0 : $2;
   $8 = HEAP32[$1 + 24 >> 2];
   $6 = __wasm_i64_mul($8, 0, $3, $4);
   $2 = $6;
   $6 = $10;
   HEAP32[$6 >> 2] = $2;
   $4 = i64toi32_i32$HIGH_BITS;
   HEAP32[$6 + 4 >> 2] = $4;
   $14 = HEAP32[$0 + 232 >> 2];
   if ($14) {
    sqlite3WalSavepointUndo($14, $1 + 32 | 0);
    $8 = HEAP32[$1 + 24 >> 2];
    $9 = 0;
   }
   while (1) {
    if (HEAPU32[$0 + 56 >> 2] <= $8 >>> 0 | $9) {
     break label$16;
    }
    $8 = $8 + 1 | 0;
    $9 = pager_playback_one_page($0, $10, $15, 0, 1);
    continue;
   }
  }
  sqlite3BitvecDestroy($15);
  if ($9) {
   break label$1;
  }
  HEAP32[$7 >> 2] = $12;
  $4 = $13;
  HEAP32[$7 + 4 >> 2] = $4;
  $9 = 0;
 }
 __stack_pointer = $10 + 16 | 0;
 return $9;
}

function sqlite3InitOne($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 HEAP8[$0 + 177 | 0] = 1;
 $5 = HEAP32[$0 + 24 >> 2];
 HEAP32[$4 + 100 >> 2] = 0;
 HEAP32[$4 + 96 >> 2] = 24330;
 HEAP32[$4 + 92 >> 2] = 23470;
 $9 = ($1 | 0) == 1 ? 8671 : 8690;
 HEAP32[$4 + 88 >> 2] = $9;
 HEAP32[$4 + 84 >> 2] = $9;
 HEAP32[$4 + 80 >> 2] = 13666;
 HEAP32[$4 + 28 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = $1;
 HEAP32[$4 + 16 >> 2] = $0;
 HEAP32[$4 + 36 >> 2] = 0;
 HEAP32[$4 + 40 >> 2] = 0;
 HEAP32[$4 + 32 >> 2] = $3;
 HEAP32[$4 + 20 >> 2] = $2;
 sqlite3InitCallback($4 + 16 | 0, $4, $4 + 80 | 0, $4);
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] & ($5 | -65);
 $3 = HEAP32[$4 + 28 >> 2];
 label$1: {
  label$2: {
   if ($3) {
    break label$2;
   }
   $7 = HEAP32[$0 + 16 >> 2];
   $3 = $7 + ($1 << 4) | 0;
   $5 = HEAP32[$3 + 4 >> 2];
   if (!$5) {
    $3 = HEAP32[$7 + 28 >> 2];
    HEAP16[$3 + 78 >> 1] = HEAPU16[$3 + 78 >> 1] | 1;
    $3 = 0;
    break label$1;
   }
   sqlite3BtreeEnter($5);
   $10 = $3;
   label$4: {
    $6 = $3 + 4 | 0;
    $3 = HEAP32[$6 >> 2];
    $11 = sqlite3BtreeTxnState($3);
    if ($11) {
     break label$4;
    }
    $3 = sqlite3BtreeBeginTrans($3, 0, 0);
    if (!$3) {
     break label$4;
    }
    sqlite3SetString($2, $0, sqlite3ErrStr($3));
    break label$2;
   }
   $3 = 0;
   while (1) {
    if (($3 | 0) != 5) {
     $5 = $3 + 1 | 0;
     sqlite3BtreeGetMeta(HEAP32[$10 + 4 >> 2], $5, ($4 + 48 | 0) + ($3 << 2) | 0);
     $3 = $5;
     continue;
    }
    break;
   }
   label$7: {
    if (!(HEAPU8[$0 + 35 | 0] & 2)) {
     $8 = HEAP32[$4 + 48 >> 2];
     $5 = HEAP32[$4 + 64 >> 2];
     break label$7;
    }
    HEAP32[$4 - -64 >> 2] = 0;
    HEAP32[$4 + 56 >> 2] = 0;
    HEAP32[$4 + 60 >> 2] = 0;
    HEAP32[$4 + 48 >> 2] = 0;
    HEAP32[$4 + 52 >> 2] = 0;
    $5 = 0;
   }
   $6 = ($1 << 4) + $7 | 0;
   $3 = HEAP32[$6 + 12 >> 2];
   HEAP32[$3 >> 2] = $8;
   label$9: {
    label$10: {
     if (!$5) {
      break label$10;
     }
     if (!(HEAPU8[$0 + 24 | 0] & 64 | $1)) {
      $3 = $5 & 3;
      sqlite3SetTextEncoding($0, $3 ? $3 : 1);
      $3 = HEAP32[$6 + 12 >> 2];
      break label$10;
     }
     if (HEAPU8[$0 + 84 | 0] == ($5 & 3)) {
      break label$10;
     }
     sqlite3SetString($2, $0, 12919);
     $3 = 1;
     break label$9;
    }
    HEAP8[$3 + 77 | 0] = HEAPU8[$0 + 84 | 0];
    if (!HEAP32[$3 + 80 >> 2]) {
     $5 = sqlite3AbsInt32(HEAP32[$4 + 56 >> 2]);
     $5 = $5 ? $5 : -2e3;
     HEAP32[$3 + 80 >> 2] = $5;
     sqlite3BtreeSetCacheSize(HEAP32[$10 + 4 >> 2], $5);
     $3 = HEAP32[$6 + 12 >> 2];
    }
    $5 = HEAP32[$4 + 52 >> 2];
    HEAP8[$3 + 76 | 0] = $5;
    label$13: {
     $8 = $5 & 255;
     if (!$8) {
      HEAP8[$3 + 76 | 0] = 1;
      break label$13;
     }
     if ($8 >>> 0 < 5) {
      break label$13;
     }
     sqlite3SetString($2, $0, 3309);
     $3 = 1;
     break label$9;
    }
    if (!(($5 | 0) < 4 | $1)) {
     $3 = HEAP32[$0 + 32 >> 2];
     $2 = $3;
     $3 = HEAP32[$0 + 36 >> 2];
     HEAP32[$0 + 32 >> 2] = $2 & -3;
     HEAP32[$0 + 36 >> 2] = $3;
    }
    HEAP32[$4 + 40 >> 2] = sqlite3BtreeLastPage(HEAP32[$10 + 4 >> 2]);
    $3 = HEAP32[HEAP32[$0 + 16 >> 2] + ($1 << 4) >> 2];
    HEAP32[$4 + 4 >> 2] = $9;
    HEAP32[$4 >> 2] = $3;
    $3 = sqlite3MPrintf($0, 14371, $4);
    $6 = HEAP32[$0 + 360 >> 2];
    HEAP32[$0 + 360 >> 2] = 0;
    $5 = sqlite3_exec($0, $3, 5, $4 + 16 | 0, 0);
    HEAP32[$0 + 360 >> 2] = $6;
    $6 = HEAP32[$4 + 28 >> 2];
    sqlite3DbFree($0, $3);
    label$16: {
     label$17: {
      $3 = $5 ? $5 : $6;
      label$18: {
       if (!$3) {
        sqlite3AnalysisLoad($0, $1);
        if (HEAPU8[$0 + 87 | 0]) {
         break label$18;
        }
        break label$16;
       }
       if (!HEAPU8[$0 + 87 | 0]) {
        break label$17;
       }
      }
      sqlite3ResetAllSchemasOfConnection($0);
      $7 = HEAP32[$0 + 16 >> 2];
      $3 = 7;
      break label$9;
     }
     if (!(HEAPU8[$0 + 35 | 0] & 8) | ($3 | 0) == 7) {
      break label$9;
     }
    }
    $3 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
    HEAP16[$3 + 78 >> 1] = HEAPU16[$3 + 78 >> 1] | 1;
    $3 = 0;
   }
   if ($11) {
    break label$2;
   }
   sqlite3BtreeCommit(HEAP32[(($1 << 4) + $7 | 0) + 4 >> 2]);
  }
  if (!$3) {
   break label$1;
  }
  if (!(($3 | 0) != 3082 & ($3 | 0) != 7)) {
   sqlite3OomFault($0);
  }
  sqlite3ResetOneSchema($0, $1);
 }
 HEAP8[$0 + 177 | 0] = 0;
 __stack_pointer = $4 + 112 | 0;
 return $3;
}

function fts3EvalIncrPhraseNext($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $5 = __stack_pointer - 128 | 0;
 __stack_pointer = $5;
 $12 = HEAP32[$0 >> 2];
 HEAP8[$5 + 127 | 0] = 0;
 label$1: {
  label$2: {
   if (HEAP32[$1 + 64 >> 2] == 1) {
    $11 = sqlite3Fts3MsrIncrNext($12, HEAP32[$1 + 92 >> 2], $1 + 16 | 0, $1 + 28 | 0, $1 + 32 | 0);
    $7 = !HEAP32[$1 + 28 >> 2];
    break label$2;
   }
   $13 = HEAPU8[$0 + 52 | 0];
   memset($5 + 16 | 0, 0, 96);
   $14 = $13 ? -1 : 1;
   label$4: while (1) {
    $0 = 0;
    $10 = 0;
    $8 = 0;
    $9 = 0;
    if ($7) {
     break label$2;
    }
    while (1) {
     if (!(HEAPU8[$5 + 127 | 0] | (HEAP32[$1 + 64 >> 2] <= ($0 | 0) | $11))) {
      $4 = ($5 + 16 | 0) + Math_imul($0, 24) | 0;
      $11 = incrPhraseTokenNext($12, $1, $0, $4, $5 + 127 | 0);
      label$7: {
       if (HEAP32[$4 >> 2]) {
        break label$7;
       }
       $3 = HEAP32[$4 + 8 >> 2];
       $7 = $3;
       $6 = HEAP32[$4 + 12 >> 2];
       if ($9) {
        $9 = 1;
        $3 = $6;
        $4 = ($10 | 0) != ($7 | 0) | ($8 | 0) != ($3 | 0) ? -1 : 0;
        $3 = $7;
        $4 = $10 >>> 0 > $3 >>> 0 & ($8 | 0) >= ($6 | 0) | ($8 | 0) > ($6 | 0) ? 1 : $4;
        if ((($13 ? 0 - $4 | 0 : $4) | 0) >= 0) {
         break label$7;
        }
       }
       $9 = 1;
       $10 = $7;
       $8 = $6;
      }
      $0 = $0 + 1 | 0;
      continue;
     }
     break;
    }
    $0 = 0;
    while (1) {
     label$10: {
      $4 = HEAP32[$1 + 64 >> 2];
      if (($4 | 0) > ($0 | 0)) {
       while (1) {
        if (HEAPU8[$5 + 127 | 0] | $11) {
         break label$10;
        }
        $4 = ($5 + 16 | 0) + Math_imul($0, 24) | 0;
        if (HEAP32[$4 >> 2]) {
         $11 = 0;
         break label$10;
        }
        $11 = 0;
        $3 = $4;
        $7 = HEAP32[$3 + 8 >> 2];
        $3 = $7;
        $6 = HEAP32[$4 + 12 >> 2];
        $7 = ($10 | 0) != ($3 | 0) | ($8 | 0) != ($6 | 0) ? -1 : 0;
        $9 = $3 >>> 0 > $10 >>> 0;
        $3 = $8;
        if ((Math_imul($9 & ($6 | 0) >= ($3 | 0) | ($3 | 0) < ($6 | 0) ? 1 : $7, $14) | 0) >= 0) {
         break label$10;
        }
        $11 = incrPhraseTokenNext($12, $1, $0, $4, $5 + 127 | 0);
        $3 = HEAP32[$4 + 12 >> 2];
        $6 = $3;
        $7 = HEAP32[$4 + 8 >> 2];
        $3 = $8;
        $4 = ($10 | 0) != ($7 | 0) | ($6 | 0) != ($3 | 0) ? -1 : 0;
        $3 = $6;
        $4 = (Math_imul($10 >>> 0 < $7 >>> 0 & ($8 | 0) <= ($3 | 0) | ($3 | 0) > ($8 | 0) ? 1 : $4, $14) | 0) > 0;
        $3 = $4 ? $7 : $10;
        $10 = $3;
        $8 = $4 ? $6 : $8;
        $0 = $4 ? 0 : $0;
        continue;
       }
      }
      $7 = HEAPU8[$5 + 127 | 0];
      if ($7) {
       continue label$4;
      }
      $0 = HEAP32[(Math_imul($4, 24) + $5 | 0) + 12 >> 2];
      $4 = sqlite3_malloc($0 + 8 | 0);
      if ($4) {
       $6 = __memcpy($4, HEAP32[(Math_imul(HEAP32[$1 + 64 >> 2], 24) + $5 | 0) + 8 >> 2], $0 + 1 | 0);
       $3 = $6 + $0 | 0;
       HEAP8[$3 | 0] = 0;
       HEAP8[$3 + 1 | 0] = 0;
       HEAP8[$3 + 2 | 0] = 0;
       HEAP8[$3 + 3 | 0] = 0;
       HEAP8[$3 + 4 | 0] = 0;
       HEAP8[$3 + 5 | 0] = 0;
       HEAP8[$3 + 6 | 0] = 0;
       HEAP8[$3 + 7 | 0] = 0;
       $0 = 0;
       $3 = 0;
       label$15: {
        while (1) {
         $4 = HEAP32[$1 + 64 >> 2];
         $9 = $4 - 1 | 0;
         if (($9 | 0) <= ($0 | 0)) {
          break label$15;
         }
         label$17: {
          $9 = ($5 + 16 | 0) + Math_imul($0, 24) | 0;
          if (!HEAP32[$9 >> 2]) {
           HEAP32[$5 + 12 >> 2] = HEAP32[$9 + 16 >> 2];
           HEAP32[$5 + 8 >> 2] = $6;
           HEAP32[$5 + 4 >> 2] = $6;
           if (!fts3PoslistPhraseMerge($5 + 4 | 0, ($0 ^ -1) + $4 | 0, 0, 1, $5 + 12 | 0, $5 + 8 | 0)) {
            break label$17;
           }
           $3 = HEAP32[$5 + 4 >> 2] - $6 | 0;
          }
          $0 = $0 + 1 | 0;
          continue;
         }
         break;
        }
        $9 = HEAP32[$1 + 64 >> 2] - 1 | 0;
       }
       if (($0 | 0) == ($9 | 0)) {
        HEAP32[$1 + 32 >> 2] = $3;
        HEAP32[$1 + 28 >> 2] = $6;
        $3 = $1;
        HEAP32[$3 + 16 >> 2] = $10;
        HEAP32[$3 + 20 >> 2] = $8;
        HEAP32[$3 + 24 >> 2] = 1;
        $7 = 0;
        break label$2;
       }
       sqlite3_free($6);
       continue label$4;
      }
      $11 = 7;
      break label$1;
     }
     $0 = $0 + 1 | 0;
     continue;
    }
   }
  }
  HEAP8[$2 | 0] = $7;
 }
 __stack_pointer = $5 + 128 | 0;
 return $11;
}

function sqlite3BtreeIntegrityCheck($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $6 = __stack_pointer - 224 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$1 + 4 >> 2];
 $8 = HEAP32[$7 + 4 >> 2];
 $10 = HEAP32[$2 >> 2];
 $12 = $10 ? $12 : HEAP32[$2 + 4 >> 2] != 1;
 $13 = HEAP32[$8 + 32 >> 2];
 $9 = HEAP32[$8 + 36 >> 2];
 $14 = $9;
 sqlite3BtreeEnter($1);
 HEAP32[$6 + 152 >> 2] = $7;
 HEAP32[$6 + 220 >> 2] = $0;
 HEAP32[$6 + 156 >> 2] = HEAP32[$7 >> 2];
 $1 = btreePagecount($7);
 HEAP32[$6 + 180 >> 2] = 0;
 HEAP32[$6 + 184 >> 2] = 0;
 HEAP32[$6 + 188 >> 2] = 0;
 HEAP32[$6 + 168 >> 2] = $4;
 HEAP32[$6 + 164 >> 2] = $1;
 HEAP32[$6 + 216 >> 2] = 0;
 HEAP32[$6 + 160 >> 2] = 0;
 HEAP32[$6 + 172 >> 2] = 0;
 HEAP32[$6 + 176 >> 2] = 0;
 $11 = $6 + 192 | 0;
 sqlite3StrAccumInit($11, 0, $6 + 48 | 0, 100, 1e9);
 HEAP8[$6 + 213 | 0] = 1;
 $1 = HEAP32[$6 + 164 >> 2];
 label$2: {
  if (!$1) {
   break label$2;
  }
  $1 = sqlite3MallocZero(($1 >>> 3 | 0) + 1 | 0, 0);
  HEAP32[$6 + 160 >> 2] = $1;
  label$3: {
   if (!$1) {
    break label$3;
   }
   $1 = sqlite3PageMalloc(HEAP32[$7 + 36 >> 2]);
   HEAP32[$6 + 216 >> 2] = $1;
   if (!$1) {
    break label$3;
   }
   $1 = (HEAPU32[16232] / HEAPU32[$7 + 36 >> 2] | 0) + 1 | 0;
   if ($1 >>> 0 <= HEAPU32[$6 + 164 >> 2]) {
    setPageReferenced($6 + 152 | 0, $1);
   }
   if (!$12) {
    HEAP32[$6 + 180 >> 2] = 29504;
    $1 = HEAP32[HEAP32[$7 + 12 >> 2] + 56 >> 2];
    checkList($6 + 152 | 0, 1, sqlite3Get4byte($1 + 32 | 0), sqlite3Get4byte($1 + 36 | 0));
    HEAP32[$6 + 180 >> 2] = 0;
   }
   label$6: {
    if (!$10) {
     break label$6;
    }
    if (HEAPU8[$7 + 17 | 0]) {
     $4 = 0;
     $8 = ($3 | 0) > 0 ? $3 : 0;
     $1 = 0;
     while (1) {
      if (($1 | 0) != ($8 | 0)) {
       $0 = HEAP32[($1 << 2) + $2 >> 2];
       $4 = $0 >>> 0 < $4 >>> 0 ? $4 : $0;
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     $1 = sqlite3Get4byte(HEAP32[HEAP32[$7 + 12 >> 2] + 56 >> 2] + 52 | 0);
     if (($4 | 0) == ($1 | 0)) {
      break label$6;
     }
     HEAP32[$6 + 36 >> 2] = $1;
     HEAP32[$6 + 32 >> 2] = $4;
     checkAppendMsg($6 + 152 | 0, 24935, $6 + 32 | 0);
     break label$6;
    }
    if (!sqlite3Get4byte(HEAP32[HEAP32[$7 + 12 >> 2] + 56 >> 2] - -64 | 0)) {
     break label$6;
    }
    checkAppendMsg($6 + 152 | 0, 9512, 0);
   }
   $1 = HEAP32[$7 + 4 >> 2];
   $9 = HEAP32[$1 + 32 >> 2];
   $8 = $9;
   $9 = HEAP32[$1 + 36 >> 2];
   $0 = $8 & -2097153;
   HEAP32[$1 + 32 >> 2] = $0;
   HEAP32[$1 + 36 >> 2] = $9;
   $1 = 0;
   while (1) {
    $4 = HEAP32[$6 + 168 >> 2];
    if (!(!$4 | ($1 | 0) >= ($3 | 0))) {
     $0 = ($1 << 2) + $2 | 0;
     $4 = HEAP32[$0 >> 2];
     if ($4) {
      if (!(!$10 | (!HEAPU8[$7 + 17 | 0] | ($4 | 0) == 1))) {
       checkPtrmap($6 + 152 | 0, $4, 1, 0);
       $4 = HEAP32[$0 >> 2];
      }
      checkTreePage($6 + 152 | 0, $4, $6 + 40 | 0, -1, 2147483647);
     }
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   $8 = HEAP32[$7 + 4 >> 2];
   HEAP32[$8 + 32 >> 2] = $13;
   $9 = $14;
   HEAP32[$8 + 36 >> 2] = $9;
   if (!$10) {
    break label$2;
   }
   $1 = 1;
   while (1) {
    if (!$4 | HEAPU32[$6 + 164 >> 2] < $1 >>> 0) {
     break label$2;
    }
    label$15: {
     if (getPageReferenced($6 + 152 | 0, $1)) {
      break label$15;
     }
     if (wasm2js_i32$0 = (ptrmapPageno($7, $1) | 0) == ($1 | 0), wasm2js_i32$1 = 0, wasm2js_i32$2 = HEAPU8[$7 + 17 | 0], 
     wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
      break label$15;
     }
     HEAP32[$6 + 16 >> 2] = $1;
     checkAppendMsg($6 + 152 | 0, 15010, $6 + 16 | 0);
    }
    label$17: {
     if (!getPageReferenced($6 + 152 | 0, $1)) {
      break label$17;
     }
     if ((ptrmapPageno($7, $1) | 0) != ($1 | 0) | !HEAPU8[$7 + 17 | 0]) {
      break label$17;
     }
     HEAP32[$6 >> 2] = $1;
     checkAppendMsg($6 + 152 | 0, 15786, $6);
    }
    $1 = $1 + 1 | 0;
    $4 = HEAP32[$6 + 168 >> 2];
    continue;
   }
  }
  HEAP32[$6 + 176 >> 2] = 1;
 }
 sqlite3PageFree(HEAP32[$6 + 216 >> 2]);
 sqlite3_free(HEAP32[$6 + 160 >> 2]);
 label$18: {
  if (HEAP32[$6 + 176 >> 2]) {
   sqlite3_str_reset($11);
   $1 = HEAP32[$6 + 172 >> 2] + 1 | 0;
   HEAP32[$6 + 172 >> 2] = $1;
   break label$18;
  }
  $1 = HEAP32[$6 + 172 >> 2];
 }
 HEAP32[$5 >> 2] = $1;
 if (!$1) {
  sqlite3_str_reset($11);
 }
 $1 = sqlite3StrAccumFinish($11);
 __stack_pointer = $6 + 224 | 0;
 return $1;
}

function dlrealloc($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 if (!$0) {
  return dlmalloc($1);
 }
 if ($1 >>> 0 >= 4294967232) {
  HEAP32[17757] = 48;
  return 0;
 }
 $3 = $1 >>> 0 < 11 ? 16 : $1 + 11 & -8;
 $7 = $0 - 4 | 0;
 $8 = HEAP32[$7 >> 2];
 $2 = $8 & -8;
 label$3: {
  label$4: {
   if (!($8 & 3)) {
    if ($3 >>> 0 < 256 | ($3 | 4) >>> 0 > $2 >>> 0) {
     break label$4;
    }
    if ($2 - $3 >>> 0 <= HEAP32[17910] << 1 >>> 0) {
     break label$3;
    }
    break label$4;
   }
   $6 = $0 - 8 | 0;
   $5 = $6 + $2 | 0;
   if ($2 >>> 0 >= $3 >>> 0) {
    $1 = $2 - $3 | 0;
    if ($1 >>> 0 < 16) {
     break label$3;
    }
    HEAP32[$7 >> 2] = $8 & 1 | $3 | 2;
    $3 = $3 + $6 | 0;
    HEAP32[$3 + 4 >> 2] = $1 | 3;
    HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] | 1;
    dispose_chunk($3, $1);
    return $0;
   }
   if (HEAP32[17796] == ($5 | 0)) {
    $2 = HEAP32[17793] + $2 | 0;
    if ($3 >>> 0 >= $2 >>> 0) {
     break label$4;
    }
    HEAP32[$7 >> 2] = $8 & 1 | $3 | 2;
    $1 = $3 + $6 | 0;
    $3 = $2 - $3 | 0;
    HEAP32[$1 + 4 >> 2] = $3 | 1;
    HEAP32[17793] = $3;
    HEAP32[17796] = $1;
    return $0;
   }
   if (HEAP32[17795] == ($5 | 0)) {
    $2 = HEAP32[17792] + $2 | 0;
    if ($3 >>> 0 > $2 >>> 0) {
     break label$4;
    }
    $1 = $2 - $3 | 0;
    label$9: {
     if ($1 >>> 0 >= 16) {
      HEAP32[$7 >> 2] = $8 & 1 | $3 | 2;
      $3 = $3 + $6 | 0;
      HEAP32[$3 + 4 >> 2] = $1 | 1;
      $2 = $2 + $6 | 0;
      HEAP32[$2 >> 2] = $1;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] & -2;
      break label$9;
     }
     HEAP32[$7 >> 2] = $8 & 1 | $2 | 2;
     $1 = $2 + $6 | 0;
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
     $1 = 0;
     $3 = 0;
    }
    HEAP32[17795] = $3;
    HEAP32[17792] = $1;
    return $0;
   }
   $4 = HEAP32[$5 + 4 >> 2];
   if ($4 & 2) {
    break label$4;
   }
   $9 = ($4 & -8) + $2 | 0;
   if ($9 >>> 0 < $3 >>> 0) {
    break label$4;
   }
   $12 = $9 - $3 | 0;
   label$11: {
    if ($4 >>> 0 <= 255) {
     $1 = HEAP32[$5 + 8 >> 2];
     $10 = $4 >>> 3 | 0;
     $4 = ($10 << 3) + 71200 | 0;
     $2 = HEAP32[$5 + 12 >> 2];
     if (($2 | 0) == ($1 | 0)) {
      HEAP32[17790] = HEAP32[17790] & __wasm_rotl_i32(-2, $10);
      break label$11;
     }
     HEAP32[$1 + 12 >> 2] = $2;
     HEAP32[$2 + 8 >> 2] = $1;
     break label$11;
    }
    $11 = HEAP32[$5 + 24 >> 2];
    $4 = HEAP32[$5 + 12 >> 2];
    label$14: {
     if (($5 | 0) != ($4 | 0)) {
      $1 = HEAP32[$5 + 8 >> 2];
      HEAP32[$1 + 12 >> 2] = $4;
      HEAP32[$4 + 8 >> 2] = $1;
      break label$14;
     }
     label$16: {
      $1 = $5 + 20 | 0;
      $2 = HEAP32[$1 >> 2];
      if ($2) {
       break label$16;
      }
      $1 = $5 + 16 | 0;
      $2 = HEAP32[$1 >> 2];
      if ($2) {
       break label$16;
      }
      $4 = 0;
      break label$14;
     }
     while (1) {
      $10 = $1;
      $4 = $2;
      $1 = $2 + 20 | 0;
      $2 = HEAP32[$1 >> 2];
      if ($2) {
       continue;
      }
      $1 = $4 + 16 | 0;
      $2 = HEAP32[$4 + 16 >> 2];
      if ($2) {
       continue;
      }
      break;
     }
     HEAP32[$10 >> 2] = 0;
    }
    if (!$11) {
     break label$11;
    }
    $2 = HEAP32[$5 + 28 >> 2];
    $1 = ($2 << 2) + 71464 | 0;
    label$18: {
     if (HEAP32[$1 >> 2] == ($5 | 0)) {
      HEAP32[$1 >> 2] = $4;
      if ($4) {
       break label$18;
      }
      HEAP32[17791] = HEAP32[17791] & __wasm_rotl_i32(-2, $2);
      break label$11;
     }
     HEAP32[(HEAP32[$11 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $11 >> 2] = $4;
     if (!$4) {
      break label$11;
     }
    }
    HEAP32[$4 + 24 >> 2] = $11;
    $1 = HEAP32[$5 + 16 >> 2];
    if ($1) {
     HEAP32[$4 + 16 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $4;
    }
    $1 = HEAP32[$5 + 20 >> 2];
    if (!$1) {
     break label$11;
    }
    HEAP32[$4 + 20 >> 2] = $1;
    HEAP32[$1 + 24 >> 2] = $4;
   }
   if ($12 >>> 0 <= 15) {
    HEAP32[$7 >> 2] = $8 & 1 | $9 | 2;
    $1 = $6 + $9 | 0;
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
    return $0;
   }
   HEAP32[$7 >> 2] = $8 & 1 | $3 | 2;
   $1 = $3 + $6 | 0;
   HEAP32[$1 + 4 >> 2] = $12 | 3;
   $3 = $6 + $9 | 0;
   HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] | 1;
   dispose_chunk($1, $12);
   return $0;
  }
  $3 = dlmalloc($1);
  if (!$3) {
   return 0;
  }
  $2 = HEAP32[$7 >> 2];
  $2 = ($2 & 3 ? -4 : -8) + ($2 & -8) | 0;
  __memcpy($3, $0, $1 >>> 0 > $2 >>> 0 ? $2 : $1);
  dlfree($0);
  $0 = $3;
 }
 return $0;
}

function sqlite3WindowRewrite($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$1 + 52 >> 2] | !HEAP32[$1 + 68 >> 2] | (HEAPU8[$1 + 6 | 0] & 16 | HEAPU8[$0 + 208 | 0] > 1)) {
   break label$1;
  }
  $13 = sqlite3GetVdbe($0);
  $14 = HEAP32[$1 + 44 >> 2];
  $15 = HEAP32[$1 + 40 >> 2];
  $16 = HEAP32[$1 + 36 >> 2];
  $11 = HEAP32[$1 + 32 >> 2];
  $7 = HEAP32[$0 >> 2];
  HEAP32[$4 + 28 >> 2] = 0;
  $6 = HEAP32[$1 + 68 >> 2];
  $17 = HEAP32[$1 + 4 >> 2];
  $8 = sqlite3DbMallocZero($7, 64, 0);
  if (!$8) {
   $2 = 7;
   sqlite3ErrorToParser($7, 7);
   break label$1;
  }
  $9 = $1;
  sqlite3AggInfoPersistWalkerInit($4, $0);
  sqlite3WalkSelect($4, $1);
  $2 = HEAP32[$1 + 4 >> 2];
  if (!($2 & 8)) {
   HEAP32[$4 + 8 >> 2] = 0;
   HEAP32[$4 + 4 >> 2] = 42;
   sqlite3WalkExprList($4, HEAP32[$1 + 48 >> 2]);
   $2 = HEAP32[$1 + 4 >> 2];
  }
  HEAP32[$9 + 32 >> 2] = 0;
  HEAP32[$9 + 36 >> 2] = 0;
  HEAP32[$9 + 40 >> 2] = 0;
  HEAP32[$9 + 44 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = $2 & -1048585 | 1048576;
  $2 = 0;
  $10 = exprListAppendList($0, exprListAppendList($0, 0, HEAP32[$6 + 8 >> 2], 1), HEAP32[$6 + 12 >> 2], 1);
  label$4: {
   if (!$10) {
    break label$4;
   }
   $3 = HEAP32[$1 + 48 >> 2];
   if (!$3) {
    break label$4;
   }
   $5 = HEAP32[$3 >> 2];
   $12 = HEAP32[$10 >> 2];
   if (($5 | 0) > ($12 | 0)) {
    break label$4;
   }
   HEAP32[$10 >> 2] = $5;
   if (!sqlite3ExprListCompare($10, $3, -1)) {
    sqlite3ExprListDelete($7, HEAP32[$1 + 48 >> 2]);
    HEAP32[$1 + 48 >> 2] = 0;
   }
   HEAP32[$10 >> 2] = $12;
  }
  $3 = HEAP32[$0 + 40 >> 2];
  HEAP32[$6 + 48 >> 2] = $3;
  HEAP32[$0 + 40 >> 2] = $3 + 4;
  selectWindowRewriteEList($0, $6, $11, HEAP32[$1 + 28 >> 2], $8, $4 + 28 | 0);
  selectWindowRewriteEList($0, $6, $11, HEAP32[$1 + 48 >> 2], $8, $4 + 28 | 0);
  $1 = HEAP32[$4 + 28 >> 2];
  if ($1) {
   $2 = HEAP32[$1 >> 2];
  }
  HEAP32[$6 + 76 >> 2] = $2;
  $2 = exprListAppendList($0, exprListAppendList($0, $1, HEAP32[$6 + 8 >> 2], 0), HEAP32[$6 + 12 >> 2], 0);
  HEAP32[$4 + 28 >> 2] = $2;
  $1 = $6;
  while (1) {
   if ($1) {
    $3 = HEAP32[HEAP32[$1 + 72 >> 2] + 20 >> 2];
    label$9: {
     if (HEAPU8[HEAP32[$1 + 44 >> 2] + 6 | 0] & 16) {
      selectWindowRewriteEList($0, $6, $11, $3, $8, $4 + 28 | 0);
      $2 = HEAP32[$4 + 28 >> 2];
      if ($2) {
       $3 = HEAP32[$2 >> 2];
      } else {
       $3 = 0;
      }
      HEAP8[$1 + 96 | 0] = 1;
      HEAP32[$1 + 80 >> 2] = $3;
      break label$9;
     }
     $5 = $2 ? HEAP32[$2 >> 2] : 0;
     HEAP32[$1 + 80 >> 2] = $5;
     $2 = exprListAppendList($0, $2, $3, 0);
     HEAP32[$4 + 28 >> 2] = $2;
    }
    $3 = HEAP32[$1 + 40 >> 2];
    if ($3) {
     $2 = sqlite3ExprListAppend($0, $2, sqlite3ExprDup($7, $3, 0));
     HEAP32[$4 + 28 >> 2] = $2;
    }
    $3 = HEAP32[$0 + 44 >> 2];
    $5 = $3 + 1 | 0;
    HEAP32[$1 + 52 >> 2] = $5;
    $3 = $3 + 2 | 0;
    HEAP32[$0 + 44 >> 2] = $3;
    HEAP32[$1 + 56 >> 2] = $3;
    sqlite3VdbeAddOp2($13, 75, 0, $5);
    $1 = HEAP32[$1 + 36 >> 2];
    continue;
   }
   break;
  }
  if (!$2) {
   $2 = sqlite3ExprListAppend($0, 0, sqlite3Expr($7, 155, 24241));
   HEAP32[$4 + 28 >> 2] = $2;
  }
  $3 = 0;
  $1 = sqlite3SelectNew($0, $2, $11, $16, $15, $14, $10, 0, 0);
  $2 = sqlite3SrcListAppend($0, 0, 0, 0);
  HEAP32[$9 + 32 >> 2] = $2;
  label$17: {
   if ($2) {
    HEAP32[$2 + 28 >> 2] = $1;
    sqlite3SrcListAssignCursors($0, $2);
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 134217792;
    $2 = sqlite3ResultSetOfSelect($0, $1, 64);
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | $17 & 8;
    if (!$2) {
     $3 = 7;
     break label$17;
    }
    $3 = __memcpy($8, $2, 64);
    HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] | 16384;
    HEAP32[HEAP32[$9 + 32 >> 2] + 24 >> 2] = $3;
    $5 = $4 + 8 | 0;
    HEAP32[$5 >> 2] = 0;
    HEAP32[$5 + 4 >> 2] = 0;
    $3 = 0;
    HEAP32[$4 + 24 >> 2] = 0;
    HEAP32[$4 + 16 >> 2] = 0;
    HEAP32[$4 + 20 >> 2] = 0;
    HEAP32[$4 + 8 >> 2] = 43;
    HEAP32[$4 >> 2] = 0;
    HEAP32[$4 + 4 >> 2] = 0;
    HEAP32[$4 + 12 >> 2] = 44;
    HEAP32[$4 + 4 >> 2] = 45;
    sqlite3WalkSelect($4, $1);
    $8 = $2;
    break label$17;
   }
   sqlite3SelectDelete($7, $1);
  }
  $1 = HEAPU8[$7 + 87 | 0];
  sqlite3ParserAddCleanup($0, 46, $8);
  $2 = $1 ? 7 : $3;
 }
 __stack_pointer = $4 + 32 | 0;
 return $2;
}

function getNextNode($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 HEAP32[$0 + 24 >> 2] = 0;
 $11 = $2 >> 31 & $2;
 $7 = $1;
 $5 = $2;
 label$1: {
  label$2: {
   while (1) {
    if (($5 | 0) > 0) {
     if (fts3isspace(HEAP8[$7 | 0])) {
      $7 = $7 + 1 | 0;
      $5 = $5 - 1 | 0;
      continue;
     } else {
      $11 = $5;
      break label$2;
     }
    }
    break;
   }
   $8 = 101;
   if (($2 | 0) >= 0) {
    break label$1;
   }
  }
  $14 = $7 - $1 | 0;
  $5 = 0;
  while (1) {
   label$8: {
    label$9: {
     label$10: {
      label$11: {
       if (($5 | 0) != 4) {
        $12 = $5 << 3;
        $6 = HEAPU8[$12 + 55012 | 0];
        if (($11 | 0) < ($6 | 0)) {
         break label$8;
        }
        if (memcmp($7, HEAP32[$12 + 55008 >> 2], $6)) {
         break label$8;
        }
        HEAP32[$10 + 12 >> 2] = 10;
        if (!(($5 | 0) != 3 | HEAPU8[$7 + 4 | 0] != 47 | (HEAPU8[$7 + 5 | 0] - 48 & 255) >>> 0 > 9)) {
         $6 = $6 + 1 | 0;
         $6 = $6 + sqlite3Fts3ReadInt($6 + $7 | 0, $10 + 12 | 0) | 0;
        }
        $9 = HEAP8[$6 + $7 | 0];
        $13 = $9 & 255;
        $9 = fts3isspace($9);
        if ($9) {
         break label$10;
        }
        $15 = $13 - 34 | 0;
        if ($15 >>> 0 > 7 | !(1 << $15 & 193)) {
         break label$11;
        }
        break label$10;
       }
       label$14: {
        label$15: {
         label$16: {
          $5 = HEAPU8[$7 | 0];
          switch ($5 - 40 | 0) {
          case 0:
           break label$14;

          case 1:
           break label$15;

          default:
           break label$16;
          }
         }
         if (($5 | 0) == 34) {
          $6 = ($11 | 0) > 1 ? $11 : 1;
          $5 = 1;
          while (1) {
           label$19: {
            if (($5 | 0) != ($6 | 0)) {
             if (HEAPU8[$5 + $7 | 0] != 34) {
              break label$19;
             }
             $6 = $5;
            }
            $8 = 1;
            HEAP32[$4 >> 2] = (($6 - $1 | 0) + $7 | 0) + 1;
            if (($6 | 0) == ($11 | 0)) {
             break label$1;
            }
            $8 = getNextString($0, $7 + 1 | 0, $6 - 1 | 0, $3);
            break label$1;
           }
           $5 = $5 + 1 | 0;
           continue;
          }
         }
         $9 = 0;
         $5 = HEAP32[$0 + 16 >> 2];
         $13 = ($5 | 0) > 0 ? $5 : 0;
         $8 = HEAP32[$0 + 20 >> 2];
         $5 = 0;
         while (1) {
          label$22: {
           label$23: {
            if (($5 | 0) == ($13 | 0)) {
             $5 = $8;
             break label$23;
            }
            $12 = HEAP32[HEAP32[$0 + 8 >> 2] + ($5 << 2) >> 2];
            $6 = strlen($12);
            if (($11 | 0) <= ($6 | 0) | HEAPU8[$6 + $7 | 0] != 58) {
             break label$22;
            }
            if (sqlite3_strnicmp($12, $7, $6)) {
             break label$22;
            }
            $9 = ($6 + $14 | 0) + 1 | 0;
           }
           $8 = getNextToken($0, $5, $1 + $9 | 0, $2 - $9 | 0, $3, $4);
           HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + $9;
           break label$1;
          }
          $5 = $5 + 1 | 0;
          continue;
         }
        }
        HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] - 1;
        HEAP32[$4 >> 2] = $14 + 1;
        HEAP32[$3 >> 2] = 0;
        $8 = 101;
        break label$1;
       }
       HEAP32[$10 + 8 >> 2] = 0;
       $8 = 1;
       $5 = HEAP32[$0 + 32 >> 2];
       HEAP32[$0 + 32 >> 2] = $5 + 1;
       if (($5 | 0) > 999) {
        break label$1;
       }
       $8 = fts3ExprParse($0, $7 + 1 | 0, $11 - 1 | 0, $3, $10 + 8 | 0);
       HEAP32[$4 >> 2] = (HEAP32[$10 + 8 >> 2] + $14 | 0) + 1;
       break label$1;
      }
      if ($13) {
       break label$9;
      }
     }
     $8 = sqlite3Fts3MallocZero(48, 0);
     if ($8) {
      HEAP32[$8 >> 2] = HEAPU8[$12 + 55014 | 0];
      HEAP32[$8 + 4 >> 2] = HEAP32[$10 + 12 >> 2];
      HEAP32[$3 >> 2] = $8;
      HEAP32[$4 >> 2] = $6 + $14;
      $8 = 0;
     } else {
      $8 = 7;
     }
     if ($9) {
      break label$1;
     }
    }
    $6 = $13 - 34 | 0;
    if (!$13 | (1 << $6 & 193 ? $6 >>> 0 <= 7 : 0)) {
     break label$1;
    }
   }
   $5 = $5 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $10 + 16 | 0;
 return $8;
}

function sqlite3BeginTrigger($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $11 = __stack_pointer - 96 | 0;
 __stack_pointer = $11;
 $10 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if ($8) {
      if (HEAP32[$2 + 4 >> 2]) {
       sqlite3ErrorMsg($0, 13311, 0);
       break label$2;
      }
      HEAP32[$11 + 92 >> 2] = $1;
      $1 = 1;
      if ($6) {
       break label$4;
      }
      break label$3;
     }
     $1 = sqlite3TwoPartName($0, $1, $2, $11 + 92 | 0);
     if (!$6 | ($1 | 0) < 0) {
      break label$2;
     }
    }
    if (HEAPU8[$10 + 87 | 0]) {
     break label$2;
    }
    if (!(!HEAPU8[$10 + 177 | 0] | ($1 | 0) == 1)) {
     $13 = $6 + 12 | 0;
     sqlite3DbFree($10, HEAP32[$13 >> 2]);
     HEAP32[$6 + 12 >> 2] = 0;
    }
    $13 = sqlite3SrcListLookup($0, $6);
    $1 = HEAPU8[$10 + 177 | 0] | (HEAP32[$2 + 4 >> 2] | !$13) ? $1 : HEAP32[$13 + 60 >> 2] == HEAP32[HEAP32[$10 + 16 >> 2] + 28 >> 2] ? 1 : $1;
    if (HEAPU8[$10 + 87 | 0]) {
     break label$2;
    }
    $13 = HEAP32[$11 + 92 >> 2];
    sqlite3FixInit($11 + 40 | 0, $0, $1, 8940, $13);
    if (sqlite3FixSrcList($11 + 40 | 0, $6)) {
     break label$2;
    }
    $2 = 0;
    label$9: {
     $14 = sqlite3SrcListLookup($0, $6);
     label$10: {
      if (!$14) {
       break label$10;
      }
      if (HEAPU8[$14 + 43 | 0] == 1) {
       sqlite3ErrorMsg($0, 5248, 0);
       break label$10;
      }
      $12 = sqlite3NameFromToken($10, $13);
      if (!$12) {
       break label$3;
      }
      if (sqlite3CheckObjectName($0, $12, 8940, HEAP32[$14 >> 2])) {
       break label$2;
      }
      label$12: {
       if (HEAPU8[$0 + 208 | 0] > 1) {
        break label$12;
       }
       if (!sqlite3HashFind(HEAP32[(HEAP32[$10 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 40 | 0, $12)) {
        break label$12;
       }
       if (!$9) {
        HEAP32[$11 + 32 >> 2] = $13;
        sqlite3ErrorMsg($0, 3512, $11 + 32 | 0);
        break label$2;
       }
       sqlite3CodeVerifySchema($0, $1);
       break label$2;
      }
      $13 = HEAP32[$14 >> 2];
      if (!sqlite3_strnicmp($13, 17751, 7)) {
       sqlite3ErrorMsg($0, 13512, 0);
       break label$1;
      }
      $9 = HEAPU8[$14 + 43 | 0];
      if (!(($3 | 0) == 65 | ($9 | 0) != 2)) {
       HEAP32[$11 + 4 >> 2] = $6 + 8;
       HEAP32[$11 >> 2] = ($3 | 0) == 33 ? 19768 : 19004;
       sqlite3ErrorMsg($0, 18763, $11);
       break label$10;
      }
      if (($9 & 255) == 2 | ($3 | 0) != 65) {
       break label$9;
      }
      HEAP32[$11 + 16 >> 2] = $6 + 8;
      sqlite3ErrorMsg($0, 18820, $11 + 16 | 0);
     }
     if (HEAPU8[$10 + 176 | 0] != 1) {
      break label$1;
     }
     $8 = $10 + 178 | 0;
     HEAP8[$8 | 0] = HEAPU8[$10 + 178 | 0] | 1;
     break label$1;
    }
    if (HEAPU8[$0 + 208 | 0] <= 1) {
     $15 = HEAP32[$10 + 16 >> 2];
     $9 = sqlite3SchemaToIndex($10, HEAP32[$14 + 60 >> 2]);
     $16 = HEAP32[$15 + ($9 << 4) >> 2];
     $2 = $16;
     $9 = ($9 | 0) == 1;
     $2 = $8 ? HEAP32[$15 + 16 >> 2] : $2;
     if (sqlite3AuthCheck($0, $8 ? 5 : $9 ? 5 : 7, $12, $13, $2)) {
      break label$2;
     }
     $2 = 0;
     if (sqlite3AuthCheck($0, 18, $9 ? 8671 : 8690, 0, $16)) {
      break label$1;
     }
    }
    $2 = sqlite3DbMallocZero($10, 36, 0);
    if (!$2) {
     break label$2;
    }
    HEAP32[$2 >> 2] = $12;
    $8 = sqlite3DbStrDup($10, HEAP32[$6 + 16 >> 2]);
    HEAP32[$2 + 4 >> 2] = $8;
    HEAP32[$2 + 20 >> 2] = HEAP32[(HEAP32[$10 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
    $12 = HEAP32[$14 + 60 >> 2];
    HEAP8[$2 + 9 | 0] = ($3 | 0) == 65 ? 1 : ($3 | 0) == 33 ? 1 : 2;
    HEAP8[$2 + 8 | 0] = $4;
    HEAP32[$2 + 24 >> 2] = $12;
    label$18: {
     if (HEAPU8[$0 + 208 | 0] >= 2) {
      sqlite3RenameTokenRemap($0, $8, HEAP32[$6 + 16 >> 2]);
      $12 = $7;
      $7 = 0;
      break label$18;
     }
     $12 = sqlite3ExprDup($10, $7, 1);
    }
    HEAP32[$2 + 16 >> 2] = $5;
    HEAP32[$2 + 12 >> 2] = $12;
    HEAP32[$0 + 244 >> 2] = $2;
    $12 = 0;
    $5 = 0;
    break label$1;
   }
   $12 = 0;
  }
  $2 = 0;
 }
 sqlite3DbFree($10, $12);
 sqlite3SrcListDelete($10, $6);
 sqlite3IdListDelete($10, $5);
 sqlite3ExprDelete($10, $7);
 if (!HEAP32[$0 + 244 >> 2]) {
  sqlite3DeleteTrigger($10, $2);
 }
 __stack_pointer = $11 + 96 | 0;
}

function analyzeAggregate($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $2 = HEAP32[$0 + 24 >> 2];
 $5 = HEAP32[$2 + 8 >> 2];
 $6 = HEAP32[$2 >> 2];
 label$1: {
  label$2: {
   label$3: {
    switch (HEAPU8[$1 | 0] - 167 | 0) {
    case 0:
    case 2:
     $0 = HEAP32[$2 + 4 >> 2];
     if (!$0) {
      break label$2;
     }
     $2 = 0;
     $3 = HEAP32[$0 >> 2];
     $4 = ($3 | 0) > 0 ? $3 : 0;
     $0 = $0 + 8 | 0;
     $7 = 1;
     while (1) {
      if (($2 | 0) == ($4 | 0)) {
       break label$1;
      }
      $3 = HEAP32[$1 + 28 >> 2];
      if (($3 | 0) == HEAP32[$0 + 40 >> 2]) {
       $0 = 0;
       $2 = HEAP32[$5 + 32 >> 2];
       $4 = ($2 | 0) > 0 ? $2 : 0;
       $2 = HEAP32[$5 + 28 >> 2];
       label$7: {
        while (1) {
         if (($0 | 0) != ($4 | 0)) {
          if (HEAP32[$2 + 8 >> 2] == ($3 | 0) & HEAPU16[$2 + 16 >> 1] == HEAPU16[$1 + 32 >> 1]) {
           break label$7;
          }
          $2 = $2 + 20 | 0;
          $0 = $0 + 1 | 0;
          continue;
         }
         break;
        }
        $0 = addAggInfoColumn(HEAP32[$6 >> 2], $5);
        if (($0 | 0) < 0) {
         break label$7;
        }
        $2 = HEAP32[$5 + 28 >> 2] + Math_imul($0, 20) | 0;
        HEAP32[$2 >> 2] = HEAP32[$1 + 44 >> 2];
        $8 = HEAP32[$1 + 28 >> 2];
        HEAP32[$2 + 8 >> 2] = $8;
        $4 = HEAPU16[$1 + 32 >> 1];
        HEAP16[$2 + 16 >> 1] = $4;
        $3 = HEAP32[$6 + 44 >> 2] + 1 | 0;
        HEAP32[$6 + 44 >> 2] = $3;
        HEAP16[$2 + 18 >> 1] = 65535;
        HEAP32[$2 + 12 >> 2] = $3;
        HEAP32[$2 + 4 >> 2] = $1;
        $9 = $2;
        $3 = HEAP32[$5 + 24 >> 2];
        label$11: {
         if (!$3) {
          break label$11;
         }
         $2 = 0;
         $7 = HEAP32[$3 >> 2];
         $7 = ($7 | 0) > 0 ? $7 : 0;
         $3 = $3 + 8 | 0;
         $6 = $4 & 65535;
         while (1) {
          if (($2 | 0) == ($7 | 0)) {
           break label$11;
          }
          $4 = HEAP32[$3 >> 2];
          if (!(!(HEAPU8[$4 | 0] != 167 | HEAP32[$4 + 28 >> 2] != ($8 | 0)) & HEAPU16[$4 + 32 >> 1] == ($6 | 0))) {
           $3 = $3 + 16 | 0;
           $2 = $2 + 1 | 0;
           continue;
          }
          break;
         }
         HEAP16[$9 + 18 >> 1] = $2;
         if ($2 << 16 >> 16 >= 0) {
          break label$7;
         }
        }
        $2 = HEAP32[$5 + 12 >> 2];
        HEAP32[$5 + 12 >> 2] = $2 + 1;
        HEAP16[$9 + 18 >> 1] = $2;
       }
       HEAP16[$1 + 34 >> 1] = $0;
       HEAP8[$1 | 0] = 169;
       HEAP32[$1 + 40 >> 2] = $5;
       break label$2;
      } else {
       $0 = $0 - -64 | 0;
       $2 = $2 + 1 | 0;
       continue;
      }
     }
     ;

    case 1:
     break label$3;

    default:
     break label$1;
    }
   }
   if (HEAPU8[$2 + 26 | 0] & 2 | HEAP32[$0 + 16 >> 2] != HEAPU8[$1 + 2 | 0]) {
    break label$1;
   }
   $0 = HEAP32[$5 + 40 >> 2];
   $2 = 0;
   while (1) {
    label$17: {
     $4 = HEAP32[$5 + 44 >> 2];
     label$18: {
      if (($4 | 0) <= ($2 | 0)) {
       break label$18;
      }
      $3 = HEAP32[$0 >> 2];
      if (($3 | 0) == ($1 | 0)) {
       break label$18;
      }
      if (sqlite3ExprCompare(0, $3, $1, -1)) {
       break label$17;
      }
      $4 = HEAP32[$5 + 44 >> 2];
     }
     label$19: {
      if (($2 | 0) < ($4 | 0)) {
       break label$19;
      }
      $2 = HEAP32[$6 >> 2];
      $4 = HEAPU8[$2 + 84 | 0];
      $0 = 0;
      $2 = addAggInfoFunc($2, $5);
      if (($2 | 0) < 0) {
       break label$19;
      }
      $7 = HEAP32[$5 + 40 >> 2];
      $3 = $7 + Math_imul($2, 20) | 0;
      HEAP32[$3 >> 2] = $1;
      $8 = HEAP32[$6 + 44 >> 2] + 1 | 0;
      HEAP32[$6 + 44 >> 2] = $8;
      HEAP32[$3 + 8 >> 2] = $8;
      $9 = HEAP32[$1 + 20 >> 2];
      if ($9) {
       $0 = HEAP32[$9 >> 2];
      }
      $8 = HEAP32[$1 + 8 >> 2];
      HEAP32[$3 + 4 >> 2] = sqlite3FindFunction(HEAP32[$6 >> 2], $8, $0, $4 & 255, 0);
      $0 = -1;
      if (HEAPU8[$1 + 4 | 0] & 4) {
       $0 = HEAP32[$6 + 40 >> 2];
       HEAP32[$6 + 40 >> 2] = $0 + 1;
      }
      HEAP32[(Math_imul($2, 20) + $7 | 0) + 12 >> 2] = $0;
     }
     HEAP32[$1 + 40 >> 2] = $5;
     HEAP16[$1 + 34 >> 1] = $2;
     break label$2;
    }
    $0 = $0 + 20 | 0;
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  $7 = 1;
 }
 return $7 | 0;
}

function fts3SegReaderNext($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  label$2: {
   $2 = HEAP32[$1 + 72 >> 2];
   if ($2) {
    $2 = HEAP32[$1 + 76 >> 2] + $2 | 0;
   } else {
    $2 = HEAP32[$1 + 40 >> 2];
   }
   if (!(HEAP32[$1 + 40 >> 2] + HEAP32[$1 + 44 >> 2] >>> 0 > $2 >>> 0 ? $2 : 0)) {
    $2 = HEAP32[$1 + 56 >> 2];
    if ($2) {
     $2 = HEAP32[$2 >> 2];
     sqlite3_free(HEAP32[$1 + 40 >> 2]);
     HEAP32[$1 + 40 >> 2] = 0;
     if (!$2) {
      break label$1;
     }
     $4 = HEAP32[$2 + 8 >> 2];
     $8 = HEAP32[$4 >> 2];
     $3 = HEAP32[$1 + 64 >> 2];
     $0 = HEAP32[$2 + 16 >> 2];
     if (($0 | 0) >= HEAP32[$1 + 68 >> 2]) {
      sqlite3_free($3);
      $6 = ($0 << 1) + 2 | 0;
      $3 = sqlite3_malloc($6);
      HEAP32[$1 + 64 >> 2] = $3;
      if (!$3) {
       break label$2;
      }
      HEAP32[$1 + 68 >> 2] = $6;
     }
     __memcpy($3, HEAP32[$2 + 12 >> 2], $0);
     $3 = 0;
     HEAP8[HEAP32[$1 + 64 >> 2] + $0 | 0] = 0;
     HEAP32[$1 + 60 >> 2] = $0;
     $2 = $8 + 1 | 0;
     $0 = sqlite3_malloc($2);
     if (!$0) {
      break label$2;
     }
     $0 = __memcpy($0, HEAP32[$4 + 4 >> 2], $2);
     HEAP32[$1 + 72 >> 2] = $0;
     HEAP32[$1 + 44 >> 2] = $2;
     HEAP32[$1 + 76 >> 2] = $2;
     HEAP32[$1 + 40 >> 2] = $0;
     HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 56 >> 2] + 4;
     break label$1;
    }
    fts3SegReaderSetEof($1);
    $5 = HEAP32[$1 + 32 >> 2];
    $6 = $5;
    $5 = HEAP32[$1 + 36 >> 2];
    $4 = $5;
    $5 = HEAP32[$1 + 20 >> 2];
    $2 = $5;
    $5 = HEAP32[$1 + 16 >> 2];
    $7 = $5;
    $5 = $2;
    if ($7 >>> 0 <= $6 >>> 0 & ($4 | 0) >= ($5 | 0) | ($4 | 0) > ($5 | 0)) {
     break label$1;
    }
    $7 = $6 + 1 | 0;
    $4 = $7 ? $4 : $4 + 1 | 0;
    $6 = $7;
    HEAP32[$1 + 32 >> 2] = $6;
    HEAP32[$1 + 36 >> 2] = $4;
    $2 = $1 + 40 | 0;
    $3 = sqlite3Fts3ReadBlock($0, $6, $4, $2, $1 + 44 | 0);
    if ($3) {
     break label$1;
    }
    $2 = HEAP32[$1 + 40 >> 2];
   }
   $3 = fts3SegReaderRequire($1, $2, 20);
   if ($3) {
    break label$1;
   }
   $3 = HEAP8[$2 | 0];
   label$10: {
    if (($3 | 0) < 0) {
     $3 = sqlite3Fts3GetVarint32($2, $9 + 12 | 0);
     break label$10;
    }
    HEAP32[$9 + 12 >> 2] = $3 & 255;
    $3 = 1;
   }
   $3 = $3 + $2 | 0;
   $2 = HEAP8[$3 | 0];
   label$9: {
    if (($2 | 0) < 0) {
     $0 = sqlite3Fts3GetVarint32($3, $9 + 8 | 0);
     $2 = HEAP32[$9 + 8 >> 2];
     break label$9;
    }
    $2 = $2 & 255;
    HEAP32[$9 + 8 >> 2] = $2;
    $0 = 1;
   }
   label$13: {
    if (($2 | 0) <= 0) {
     break label$13;
    }
    $0 = $0 + $3 | 0;
    if (((HEAP32[$1 + 40 >> 2] + HEAP32[$1 + 44 >> 2] | 0) - $0 | 0) < ($2 | 0)) {
     break label$13;
    }
    $8 = HEAP32[$9 + 12 >> 2];
    if (($8 | 0) > HEAP32[$1 + 60 >> 2]) {
     break label$13;
    }
    $4 = $8 >> 31;
    $7 = $4;
    $5 = $2 + $8 | 0;
    $7 = $5 >>> 0 < $2 >>> 0 ? $7 + 1 | 0 : $7;
    $6 = $5;
    $4 = $7;
    $7 = HEAP32[$1 + 68 >> 2];
    $5 = $7 >> 31;
    $3 = $5;
    $5 = $7;
    $7 = $3;
    if ($5 >>> 0 < $6 >>> 0 & ($4 | 0) >= ($7 | 0) | ($4 | 0) > ($7 | 0)) {
     $5 = $6;
     $6 = $6 << 1;
     $5 = $4 << 1 | $5 >>> 31;
     $4 = $5;
     $3 = sqlite3_realloc64(HEAP32[$1 + 64 >> 2], $6, $4);
     if (!$3) {
      break label$2;
     }
     HEAP32[$1 + 68 >> 2] = $6;
     HEAP32[$1 + 64 >> 2] = $3;
    }
    $3 = fts3SegReaderRequire($1, $0, $2 + 10 | 0);
    if ($3) {
     break label$1;
    }
    __memcpy(HEAP32[$1 + 64 >> 2] + $8 | 0, $0, $2);
    HEAP32[$1 + 60 >> 2] = $2 + $8;
    $3 = $0 + $2 | 0;
    $2 = HEAP8[$3 | 0];
    label$15: {
     if (($2 | 0) < 0) {
      $0 = sqlite3Fts3GetVarint32($3, $1 + 76 | 0);
      $2 = HEAP32[$1 + 76 >> 2];
      break label$15;
     }
     $2 = $2 & 255;
     HEAP32[$1 + 76 >> 2] = $2;
     $0 = 1;
    }
    HEAP32[$1 + 80 >> 2] = 0;
    $0 = $0 + $3 | 0;
    HEAP32[$1 + 72 >> 2] = $0;
    if ((HEAP32[$1 + 40 >> 2] + (HEAP32[$1 + 44 >> 2] - $0 | 0) | 0) < ($2 | 0)) {
     break label$13;
    }
    if (!HEAP32[$1 + 48 >> 2]) {
     $3 = 267;
     if (HEAPU8[($0 + $2 | 0) - 1 | 0]) {
      break label$1;
     }
    }
    $3 = $2 ? 0 : 267;
    break label$1;
   }
   $3 = 267;
   break label$1;
  }
  $3 = 7;
 }
 __stack_pointer = $9 + 16 | 0;
 return $3;
}

function generateSortTail($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $15 = HEAP32[$2 + 24 >> 2];
 $5 = HEAP32[$0 + 8 >> 2];
 $17 = sqlite3VdbeMakeLabel($0);
 $7 = HEAP32[$1 + 28 >> 2];
 $11 = HEAP32[$4 + 4 >> 2];
 $16 = HEAPU8[$4 | 0];
 $6 = HEAP32[$2 >> 2];
 $12 = HEAP32[$2 + 16 >> 2];
 if ($12) {
  sqlite3VdbeAddOp2($5, 9, HEAP32[$2 + 12 >> 2], $12);
  sqlite3VdbeGoto($5, $15);
  sqlite3VdbeResolveLabel($5, HEAP32[$2 + 16 >> 2]);
 }
 $13 = HEAP32[$2 + 8 >> 2];
 label$2: {
  label$3: {
   label$4: {
    label$5: {
     switch ($16 - 9 | 0) {
     case 0:
     case 4:
      break label$4;

     case 1:
      break label$5;

     default:
      break label$3;
     }
    }
    if (!HEAP32[$1 + 12 >> 2]) {
     break label$4;
    }
    sqlite3VdbeAddOp2($5, 75, 0, HEAP32[$4 + 12 >> 2]);
   }
   $8 = HEAP32[$4 + 12 >> 2];
   break label$2;
  }
  $10 = sqlite3GetTempReg($0);
  if (($16 & 253) == 12) {
   $3 = 0;
   $8 = sqlite3GetTempReg($0);
   break label$2;
  }
  $8 = sqlite3GetTempRange($0, $3);
 }
 $14 = HEAP32[$6 >> 2] - HEAP32[$2 + 4 >> 2] | 0;
 $18 = 1;
 label$7: {
  if (HEAP8[$2 + 32 | 0] & 1) {
   $1 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $1;
   $9 = HEAP32[$0 + 40 >> 2];
   HEAP32[$0 + 40 >> 2] = $9 + 1;
   if (HEAP32[$2 + 16 >> 2]) {
    $6 = sqlite3VdbeAddOp0($5, 14);
   } else {
    $6 = 0;
   }
   sqlite3VdbeAddOp3($5, 121, $9, $1, ($3 + $14 | 0) + 1 | 0);
   if ($6) {
    sqlite3VdbeJumpHere($5, $6);
   }
   $19 = sqlite3VdbeAddOp2($5, 33, $13, $15);
   sqlite3VdbeAddOp3($5, 133, $13, $1, $9);
   $18 = 0;
   break label$7;
  }
  $19 = sqlite3VdbeAddOp2($5, 34, $13, $15);
  codeOffset($5, HEAP32[$1 + 12 >> 2], $17);
  if (HEAP32[$1 + 12 >> 2] > 0) {
   sqlite3VdbeAddOp2($5, 86, HEAP32[$1 + 8 >> 2], -1);
  }
  $9 = $13;
 }
 $12 = $7 + 8 | 0;
 $7 = 0;
 $6 = ($3 | 0) > 0 ? $3 : 0;
 $14 = $14 + $18 | 0;
 $1 = $14 - 1 | 0;
 label$13: {
  label$14: {
   label$15: {
    while (1) {
     if (($7 | 0) == ($6 | 0)) {
      label$18: {
       $7 = $3;
       while (1) {
        if (($7 | 0) > 0) {
         $7 = $7 - 1 | 0;
         $6 = HEAPU16[(($7 << 4) + $12 | 0) + 12 >> 1];
         sqlite3VdbeAddOp3($5, 94, $9, $6 ? $6 - 1 | 0 : $1, $7 + $8 | 0);
         $1 = $1 - !$6 | 0;
         continue;
        }
        break;
       }
       $1 = $19 + 1 | 0;
       label$21: {
        label$22: {
         switch ($16 - 9 | 0) {
         case 3:
         case 5:
          sqlite3VdbeAddOp3($5, 94, $9, $14, $8);
          sqlite3VdbeAddOp2($5, 127, $11, $10);
          sqlite3VdbeAddOp3($5, 128, $11, $8, $10);
          sqlite3VdbeChangeP5($5, 8);
          break label$21;

         case 6:
          $7 = HEAP32[$4 + 8 >> 2];
          $6 = $7 >>> 31 | 0;
          $4 = $8 + $6 | 0;
          $9 = $3 - $6 | 0;
          $6 = sqlite3GetTempReg($0);
          sqlite3VdbeAddOp3($5, 97, $4, $9, $6);
          if (($7 | 0) < 0) {
           sqlite3VdbeAddOp3($5, 128, $11, $6, $8);
           break label$21;
          }
          sqlite3VdbeAddOp4Int($5, 138, $11, $6, $8, $7);
          break label$21;

         case 0:
          sqlite3VdbeAddOp2($5, 84, HEAP32[$4 + 12 >> 2], $3);
          break label$21;

         case 2:
          break label$18;

         case 1:
          break label$21;

         default:
          break label$22;
         }
        }
        sqlite3VdbeAddOp1($5, 11, HEAP32[$4 + 4 >> 2]);
       }
       if (!$10) {
        break label$13;
       }
       if (($16 | 0) == 11) {
        break label$15;
       }
       sqlite3ReleaseTempReg($0, $8);
       break label$14;
      }
     } else {
      $1 = !HEAPU16[(($7 << 4) + $12 | 0) + 12 >> 1] + $1 | 0;
      $7 = $7 + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3VdbeAddOp4($5, 97, $8, $3, $10, HEAP32[$4 + 20 >> 2], $3);
    sqlite3VdbeAddOp4Int($5, 138, $11, $10, $8, $3);
    if (!$10) {
     break label$13;
    }
   }
   sqlite3ReleaseTempRange($0, $8, $3);
  }
  sqlite3ReleaseTempReg($0, $10);
 }
 sqlite3VdbeResolveLabel($5, $17);
 sqlite3VdbeAddOp2($5, HEAP8[$2 + 32 | 0] & 1 ? 36 : 38, $13, $1);
 $1 = HEAP32[$2 + 12 >> 2];
 if ($1) {
  sqlite3VdbeAddOp1($5, 67, $1);
 }
 sqlite3VdbeResolveLabel($5, $15);
}

function updateVirtualTable($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0;
 $19 = __stack_pointer - 16 | 0;
 __stack_pointer = $19;
 $9 = HEAP32[$0 + 8 >> 2];
 $11 = HEAP32[$0 >> 2];
 $21 = sqlite3GetVTable($11, $2);
 $12 = HEAP32[$1 + 48 >> 2];
 $8 = HEAP16[$2 + 34 >> 1];
 $13 = HEAP32[$0 + 40 >> 2];
 HEAP32[$0 + 40 >> 2] = $13 + 1;
 $15 = $8 + 2 | 0;
 $18 = sqlite3VdbeAddOp2($9, 118, $13, $15);
 $16 = HEAP32[$0 + 44 >> 2];
 $8 = $16 + $15 | 0;
 HEAP32[$0 + 44 >> 2] = $8;
 $17 = $16 + 1 | 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      if (HEAP32[$1 >> 2] >= 2) {
       label$7: {
        if (!(HEAPU8[$2 + 28 | 0] & 128)) {
         if ($4) {
          $12 = 0;
          $8 = sqlite3ExprDup($11, $4, 0);
          break label$7;
         }
         $12 = 0;
         $8 = sqlite3PExpr($0, 75, 0, 0);
         break label$7;
        }
        $12 = sqlite3PrimaryKeyIndex($2);
        $10 = HEAP16[HEAP32[$12 + 4 >> 2] >> 1];
        $8 = HEAP32[($10 << 2) + $5 >> 2];
        if (($8 | 0) >= 0) {
         $8 = sqlite3ExprDup($11, HEAP32[(($8 << 4) + $3 | 0) + 8 >> 2], 0);
         break label$7;
        }
        $8 = exprRowColumn($0, $10);
       }
       $10 = sqlite3ExprListAppend($0, 0, $8);
       $8 = 0;
       while (1) {
        if (HEAP16[$2 + 34 >> 1] <= ($8 | 0)) {
         break label$5;
        }
        $14 = HEAP32[($8 << 2) + $5 >> 2];
        label$12: {
         if (($14 | 0) >= 0) {
          $14 = sqlite3ExprDup($11, HEAP32[(($14 << 4) + $3 | 0) + 8 >> 2], 0);
          break label$12;
         }
         $14 = exprRowColumn($0, $8);
        }
        $8 = $8 + 1 | 0;
        $10 = sqlite3ExprListAppend($0, $10, $14);
        continue;
       }
      }
      $20 = $8 + 2 | 0;
      HEAP32[$0 + 44 >> 2] = $20;
      $11 = sqlite3WhereBegin($0, $1, $6, 0, 0, 0, 4, 0);
      if (!$11) {
       break label$1;
      }
      $6 = $8 + 1 | 0;
      $14 = $16 + 3 | 0;
      $8 = 0;
      while (1) {
       if (($8 | 0) < HEAP16[$2 + 34 >> 1]) {
        $10 = HEAP32[($8 << 2) + $5 >> 2];
        label$16: {
         if (($10 | 0) >= 0) {
          sqlite3ExprCode($0, HEAP32[(($10 << 4) + $3 | 0) + 8 >> 2], $8 + $14 | 0);
          break label$16;
         }
         sqlite3VdbeAddOp3($9, 175, $12, $8, $8 + $14 | 0);
         sqlite3VdbeChangeP5($9, 1);
        }
        $8 = $8 + 1 | 0;
        continue;
       }
       break;
      }
      label$18: {
       if (!(HEAPU8[$2 + 28 | 0] & 128)) {
        sqlite3VdbeAddOp2($9, 135, $12, $17);
        $8 = $16 + 2 | 0;
        if ($4) {
         sqlite3ExprCode($0, $4, $8);
         break label$18;
        }
        sqlite3VdbeAddOp2($9, 135, $12, $8);
        break label$18;
       }
       $8 = HEAP16[HEAP32[sqlite3PrimaryKeyIndex($2) + 4 >> 2] >> 1];
       sqlite3VdbeAddOp3($9, 175, $12, $8, $17);
       sqlite3VdbeAddOp2($9, 81, $8 + $14 | 0, $16 + 2 | 0);
      }
      if (sqlite3WhereOkOnePass($11, $19 + 8 | 0)) {
       break label$3;
      }
      sqlite3MultiWrite($0);
      sqlite3VdbeAddOp3($9, 97, $17, $15, $6);
      sqlite3VdbeAddOp2($9, 127, $13, $20);
      sqlite3VdbeAddOp3($9, 128, $13, $6, $20);
      break label$4;
     }
     updateFromSelect($0, $13, $12, $10, $1, $6);
     sqlite3ExprListDelete($11, $10);
     $11 = 0;
    }
    if (HEAP32[$1 >> 2] == 1) {
     sqlite3WhereEnd($11);
    }
    $8 = 0;
    $10 = ($15 | 0) > 0 ? $15 : 0;
    $18 = sqlite3VdbeAddOp1($9, 35, $13);
    while (1) if (($8 | 0) == ($10 | 0)) {
     $8 = 1;
     break label$2;
    } else {
     sqlite3VdbeAddOp3($9, 94, $13, $8, $8 + $17 | 0);
     $8 = $8 + 1 | 0;
     continue;
    }
   }
   sqlite3VdbeChangeToNoop($9, $18);
   sqlite3VdbeAddOp1($9, 122, $12);
   $8 = 0;
  }
  sqlite3VtabMakeWritable($0, $2);
  sqlite3VdbeAddOp4($9, 7, 0, $15, $17, $21, -11);
  sqlite3VdbeChangeP5($9, (($7 | 0) == 11 ? 2 : $7) & 65535);
  sqlite3MayAbort($0);
  if ($8) {
   sqlite3VdbeAddOp2($9, 38, $13, $18 + 1 | 0);
   sqlite3VdbeJumpHere($9, $18);
   sqlite3VdbeAddOp2($9, 122, $13, 0);
   break label$1;
  }
  sqlite3WhereEnd($11);
 }
 __stack_pointer = $19 + 16 | 0;
}

function sqlite3ColumnsFromExprList($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 $7 = HEAP32[$0 >> 2];
 sqlite3HashInit($5 + 24 | 0);
 label$1: {
  if (!$1) {
   $0 = 0;
   $9 = 0;
   break label$1;
  }
  $4 = HEAP32[$1 >> 2];
  $0 = ($4 | 0) < 32767 ? $4 : 32767;
  $9 = sqlite3DbMallocZero($7, Math_imul($4, 12), 0);
 }
 HEAP16[$2 >> 1] = $0;
 HEAP32[$3 >> 2] = $9;
 $12 = ($0 | 0) > 0 ? $0 : 0;
 $8 = $9;
 while (1) {
  label$4: {
   label$5: {
    label$6: {
     label$7: {
      label$8: {
       label$9: {
        if (($10 | 0) != ($12 | 0)) {
         if (!HEAPU8[$7 + 87 | 0]) {
          break label$9;
         }
         $12 = $10;
        }
        sqlite3HashClear($5 + 24 | 0);
        if (!HEAPU8[$7 + 87 | 0]) {
         break label$7;
        }
        $0 = 0;
        while (1) {
         if (($0 | 0) == ($12 | 0)) {
          break label$8;
         }
         sqlite3DbFree($7, HEAP32[Math_imul($0, 12) + $9 >> 2]);
         $0 = $0 + 1 | 0;
         continue;
        }
       }
       $11 = ($10 << 4) + $1 | 0;
       $13 = $11 + 8 | 0;
       $6 = HEAP32[$11 + 12 >> 2];
       if (HEAPU8[$11 + 17 | 0] & 3 ? 0 : $6) {
        break label$6;
       }
       $0 = sqlite3ExprSkipCollateAndLikely(HEAP32[$13 >> 2]);
       while (1) {
        $4 = HEAPU8[$0 | 0];
        if (($4 | 0) != 141) {
         label$15: {
          label$16: {
           if (($4 | 0) != 59) {
            if (HEAPU8[$0 + 7 | 0] & 3 | ($4 | 0) != 167) {
             break label$15;
            }
            $4 = HEAP32[$0 + 44 >> 2];
            if (!$4) {
             break label$15;
            }
            label$18: {
             $0 = HEAP16[$0 + 32 >> 1];
             if (($0 | 0) >= 0) {
              break label$18;
             }
             $0 = HEAP16[$4 + 32 >> 1];
             if (($0 | 0) >= 0) {
              break label$18;
             }
             $6 = 14442;
             break label$6;
            }
            $0 = HEAP32[$4 + 4 >> 2] + Math_imul($0 & 65535, 12) | 0;
            break label$16;
           }
           $0 = $0 + 8 | 0;
          }
          $6 = HEAP32[$0 >> 2];
         }
         if (!$6) {
          break label$5;
         }
         break label$6;
        } else {
         $0 = HEAP32[$0 + 16 >> 2];
         continue;
        }
       }
      }
      sqlite3DbFree($7, $9);
      HEAP32[$3 >> 2] = 0;
      HEAP16[$2 >> 1] = 0;
     }
     __stack_pointer = $5 + 48 | 0;
     return;
    }
    if (sqlite3IsTrueOrFalse($6)) {
     break label$5;
    }
    $4 = sqlite3DbStrDup($7, $6);
    break label$4;
   }
   HEAP32[$5 + 16 >> 2] = $10 + 1;
   $4 = sqlite3MPrintf($7, 15907, $5 + 16 | 0);
  }
  HEAP32[$5 + 44 >> 2] = 0;
  while (1) {
   label$21: {
    if (!$4) {
     break label$21;
    }
    $0 = sqlite3HashFind($5 + 24 | 0, $4);
    if (!$0) {
     break label$21;
    }
    if (HEAPU8[$0 + 9 | 0] & 128) {
     HEAP16[$8 + 10 >> 1] = HEAPU16[$8 + 10 >> 1] | 1024;
    }
    $14 = sqlite3Strlen30($4);
    $0 = $14;
    if (($0 | 0) <= 0) {
     $0 = 0;
    } else {
     while (1) {
      label$26: {
       if (($0 | 0) <= 1) {
        $6 = HEAPU8[$4 | 0];
        $0 = 0;
        break label$26;
       }
       $0 = $0 - 1 | 0;
       $6 = HEAPU8[$4 + $0 | 0];
       if ($6 - 58 >>> 0 > 4294967285) {
        continue;
       }
      }
      break;
     }
     $0 = ($6 & 255) == 58 ? $0 : $14;
    }
    HEAP32[$5 >> 2] = $0;
    HEAP32[$5 + 4 >> 2] = $4;
    $0 = HEAP32[$5 + 44 >> 2] + 1 | 0;
    HEAP32[$5 + 44 >> 2] = $0;
    HEAP32[$5 + 8 >> 2] = $0;
    $4 = sqlite3MPrintf($7, 1853, $5);
    if (HEAPU32[$5 + 44 >> 2] < 4) {
     continue;
    }
    sqlite3_randomness(4, $5 + 44 | 0);
    continue;
   }
   break;
  }
  HEAP32[$8 >> 2] = $4;
  HEAP8[$8 + 7 | 0] = sqlite3StrIHash($4);
  if (HEAP8[$11 + 18 | 0] & 1) {
   HEAP16[$8 + 10 >> 1] = HEAPU16[$8 + 10 >> 1] | 1024;
  }
  label$29: {
   if (!$4) {
    break label$29;
   }
   if ((sqlite3HashInsert($5 + 24 | 0, $4, $13) | 0) != ($13 | 0)) {
    break label$29;
   }
   sqlite3OomFault($7);
  }
  $8 = $8 + 12 | 0;
  $10 = $10 + 1 | 0;
  continue;
 }
}

function sqlite3_config($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (HEAP32[16120]) {
   $6 = sqlite3MisuseError(171105);
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = $1;
  label$3: {
   switch ($0 - 4 | 0) {
   case 0:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    $1 = HEAP32[$1 >> 2];
    $3 = HEAP32[$1 + 4 >> 2];
    $4 = HEAP32[$1 >> 2];
    HEAP32[16076] = $4;
    HEAP32[16077] = $3;
    $4 = HEAP32[$1 + 28 >> 2];
    $3 = HEAP32[$1 + 24 >> 2];
    HEAP32[16082] = $3;
    HEAP32[16083] = $4;
    $3 = HEAP32[$1 + 20 >> 2];
    $4 = HEAP32[$1 + 16 >> 2];
    HEAP32[16080] = $4;
    HEAP32[16081] = $3;
    $4 = HEAP32[$1 + 12 >> 2];
    $3 = HEAP32[$1 + 8 >> 2];
    HEAP32[16078] = $3;
    HEAP32[16079] = $4;
    break label$1;

   case 1:
    if (!HEAP32[16076]) {
     sqlite3MemSetDefault();
    }
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    $3 = HEAP32[16077];
    $4 = HEAP32[16076];
    $1 = HEAP32[$1 >> 2];
    HEAP32[$1 >> 2] = $4;
    HEAP32[$1 + 4 >> 2] = $3;
    $4 = HEAP32[16083];
    $3 = HEAP32[16082];
    HEAP32[$1 + 24 >> 2] = $3;
    HEAP32[$1 + 28 >> 2] = $4;
    $3 = HEAP32[16081];
    $4 = HEAP32[16080];
    HEAP32[$1 + 16 >> 2] = $4;
    HEAP32[$1 + 20 >> 2] = $3;
    $4 = HEAP32[16079];
    $3 = HEAP32[16078];
    HEAP32[$1 + 8 >> 2] = $3;
    HEAP32[$1 + 12 >> 2] = $4;
    break label$1;

   case 5:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[16068] = HEAP32[$1 >> 2];
    break label$1;

   case 23:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP8[64280] = HEAP32[$1 >> 2];
    break label$1;

   case 3:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[16114] = HEAP32[$1 >> 2];
    HEAP32[16115] = HEAP32[$1 + 4 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 12;
    HEAP32[16116] = HEAP32[$1 + 8 >> 2];
    break label$1;

   case 20:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[HEAP32[$1 >> 2] >> 2] = 160;
    break label$1;

   case 14:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    __memcpy(64372, HEAP32[$1 >> 2], 52);
    break label$1;

   case 15:
    if (!HEAP32[16095]) {
     sqlite3PCacheSetDefault();
    }
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    __memcpy(HEAP32[$1 >> 2], 64372, 52);
    break label$1;

   case 9:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[16073] = HEAP32[$1 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 8;
    HEAP32[16074] = HEAP32[$1 + 4 >> 2];
    break label$1;

   case 12:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[16127] = HEAP32[$1 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 8;
    HEAP32[16128] = HEAP32[$1 + 4 >> 2];
    break label$1;

   case 13:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP8[64278] = HEAP32[$1 >> 2];
    break label$1;

   case 16:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP8[64279] = HEAP32[$1 >> 2];
    break label$1;

   case 18:
    $1 = HEAP32[$2 + 12 >> 2] + 7 & -8;
    $4 = HEAP32[$1 >> 2];
    $3 = HEAP32[$1 + 4 >> 2];
    HEAP32[16112] = 0;
    HEAP32[16113] = 0;
    $0 = !!$4 & ($3 | 0) >= 0 | ($3 | 0) > 0;
    $5 = $0;
    $4 = $5 ? $4 : 0;
    $0 = $4;
    $4 = $5 ? $3 : 0;
    $3 = $5;
    $0 = $3 ? 0 : $0;
    HEAP32[16110] = $0;
    $5 = $3 ? 0 : $4;
    HEAP32[16111] = $5;
    HEAP32[$2 + 12 >> 2] = $1 + 16;
    break label$1;

   case 21:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[16119] = HEAP32[$1 >> 2];
    break label$1;

   case 22:
    $1 = HEAP32[$2 + 12 >> 2];
    HEAP32[$2 + 12 >> 2] = $1 + 4;
    HEAP32[16075] = HEAP32[$1 >> 2];
    break label$1;

   case 25:
    $1 = HEAP32[$2 + 12 >> 2] + 7 & -8;
    HEAP32[$2 + 12 >> 2] = $1 + 8;
    $0 = HEAP32[$1 + 4 >> 2];
    $5 = HEAP32[$1 >> 2];
    HEAP32[16130] = $5;
    HEAP32[16131] = $0;
    break label$1;

   case 10:
    break label$1;

   default:
    break label$3;
   }
  }
  $6 = 1;
 }
 __stack_pointer = $2 + 16 | 0;
 return $6;
}

function whereLoopAddVirtual($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 4 >> 2] = 0;
 $9 = HEAP32[$0 >> 2];
 $16 = HEAP32[$9 >> 2];
 $8 = 7;
 $21 = HEAP32[$0 + 4 >> 2];
 $6 = $4;
 $12 = HEAP32[$0 + 8 >> 2];
 $9 = allocateIndexInfo($9, $21, $3, $6, (HEAP32[$9 + 4 >> 2] + (HEAPU8[$12 + 16 | 0] << 6) | 0) + 8 | 0, $10 + 10 | 0);
 label$1: {
  if (!$9) {
   break label$1;
  }
  HEAP16[$12 + 44 >> 1] = 0;
  HEAP32[$12 + 40 >> 2] = 1024;
  HEAP16[$12 + 18 >> 1] = 0;
  $14 = $12 + 28 | 0;
  HEAP8[$14 | 0] = HEAPU8[$12 + 28 | 0] & 254;
  $14 = HEAP32[$9 >> 2];
  if (whereLoopResize(HEAP32[$16 >> 2], $12, $14)) {
   freeIndexInfo(HEAP32[$16 >> 2], $9);
   break label$1;
  }
  $6 = $2;
  $15 = HEAPU16[$10 + 10 >> 1];
  $8 = whereLoopAddVirtualOne($0, $1, $6, -1, -1, 0, $9, $15, $10 + 12 | 0, $10 + 4 | 0);
  if (HEAP32[$10 + 4 >> 2]) {
   $5 = $2;
   $8 = whereLoopAddVirtualOne($0, $1, $5, -1, -1, 0, $9, $15, $10 + 12 | 0, 0);
  }
  label$4: {
   if ($8) {
    break label$4;
   }
   $13 = HEAP32[$10 + 12 >> 2];
   $7 = $1;
   $17 = $7 ^ -1;
   $6 = $2;
   $5 = $6 ^ -1;
   $18 = $5;
   $6 = $12;
   $5 = HEAP32[$6 >> 2];
   $3 = $5;
   $7 = HEAP32[$6 + 4 >> 2];
   $5 = $7;
   $7 = $18;
   $5 = $5 & $7;
   $25 = $5;
   $6 = $17;
   $22 = $3 & $6;
   if (!($5 | $22)) {
    $8 = 0;
    if (!$13) {
     break label$4;
    }
   }
   $8 = 0;
   $14 = ($14 | 0) > 0 ? $14 : 0;
   if ($13) {
    $5 = $2;
    $8 = whereLoopAddVirtualOne($0, $1, $5, -1, -1, 1, $9, $15, $10 + 12 | 0, 0);
    $7 = $12;
    $6 = HEAP32[$7 >> 2];
    $3 = $6;
    $6 = $18;
    $5 = HEAP32[$7 + 4 >> 2];
    $6 = $6 & $5;
    $26 = $6;
    $7 = $3;
    $23 = $17 & $7;
    $19 = !($6 | $23);
   }
   $13 = $19;
   while (1) {
    if ($8) {
     break label$4;
    }
    $3 = -1;
    $4 = -1;
    $8 = 0;
    while (1) {
     if (($8 | 0) != ($14 | 0)) {
      $5 = HEAP32[$21 + 24 >> 2] + Math_imul(HEAP32[(HEAP32[$9 + 4 >> 2] + Math_imul($8, 12) | 0) + 8 >> 2], 48) | 0;
      $6 = HEAP32[$5 + 32 >> 2];
      $11 = $6;
      $6 = $18;
      $7 = HEAP32[$5 + 36 >> 2];
      $6 = $6 & $7;
      $7 = $6;
      $5 = $11;
      $20 = $17 & $5;
      $6 = $4;
      $5 = $7;
      $7 = $3;
      $11 = ($6 | 0) == ($5 | 0) & $20 >>> 0 < $7 >>> 0 | $6 >>> 0 > $5 >>> 0;
      $7 = $5;
      $5 = $11 ? $20 : $3;
      $27 = $5;
      $28 = $11 ? $7 : $6;
      $5 = $7;
      $7 = $20;
      $11 = $29;
      $6 = ($5 | 0) == ($24 | 0) & $11 >>> 0 < $7 >>> 0 | $5 >>> 0 > $24 >>> 0;
      $5 = $6 ? $27 : $3;
      $3 = $5;
      $11 = $28;
      $7 = $6 ? $11 : $4;
      $4 = $7;
      $8 = $8 + 1 | 0;
      continue;
     }
     break;
    }
    $6 = $3;
    $7 = $4;
    if (($6 & $7) != -1) {
     $8 = 0;
     $29 = $3;
     $6 = $4;
     $24 = $6;
     $5 = $22;
     $7 = $25;
     if (($5 | 0) == ($3 | 0) & ($7 | 0) == ($6 | 0)) {
      continue;
     }
     $5 = $3;
     $7 = $23;
     $6 = $26;
     $11 = $4;
     if (($5 | 0) == ($7 | 0) & ($6 | 0) == ($11 | 0)) {
      continue;
     }
     $5 = $2;
     $11 = $5 | $4;
     $6 = $3;
     $7 = $1;
     $3 = $6 | $7;
     $7 = $11;
     $8 = whereLoopAddVirtualOne($0, $1, $5, $3, $7, 0, $9, $15, $10 + 12 | 0, 0);
     $6 = $1;
     $5 = $12;
     $7 = HEAP32[$5 >> 2];
     $5 = $7;
     $7 = $2;
     $11 = HEAP32[$12 + 4 >> 2];
     if (($6 | 0) != ($5 | 0) | ($7 | 0) != ($11 | 0)) {
      continue;
     }
     $19 = 1;
     $13 = HEAP32[$10 + 12 >> 2] ? $13 : 1;
     continue;
    }
    break;
   }
   $8 = 0;
   if (!$19) {
    $5 = $2;
    $8 = whereLoopAddVirtualOne($0, $1, $5, $1, $5, 0, $9, $15, $10 + 12 | 0, 0);
    $13 = HEAP32[$10 + 12 >> 2] ? $13 : 1;
   }
   if ($8 | $13) {
    break label$4;
   }
   $5 = $2;
   $8 = whereLoopAddVirtualOne($0, $1, $5, $1, $5, 1, $9, $15, $10 + 12 | 0, 0);
  }
  if (HEAP32[$9 + 28 >> 2]) {
   sqlite3_free(HEAP32[$9 + 24 >> 2]);
  }
  freeIndexInfo(HEAP32[$16 >> 2], $9);
 }
 __stack_pointer = $10 + 16 | 0;
 return $8;
}

function unixLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $5 = HEAPU8[$0 + 16 | 0];
 label$1: {
  if (($5 | 0) >= ($1 | 0)) {
   break label$1;
  }
  $7 = HEAP32[$0 + 8 >> 2];
  $4 = HEAPU8[$7 + 28 | 0];
  if (($4 | 0) != ($5 | 0)) {
   $3 = 5;
   if (($1 | 0) > 1 | $4 >>> 0 > 2) {
    break label$1;
   }
  }
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      label$7: {
       label$8: {
        label$9: {
         label$10: {
          label$11: {
           if (($1 | 0) == 1) {
            if (($4 - 1 & 255) >>> 0 >= 2) {
             HEAP16[$2 + 2 >> 1] = 0;
             HEAP32[$2 + 16 >> 2] = 1;
             HEAP32[$2 + 20 >> 2] = 0;
             break label$11;
            }
            HEAP8[$0 + 16 | 0] = 1;
            HEAP32[$7 + 20 >> 2] = HEAP32[$7 + 20 >> 2] + 1;
            HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] + 1;
            $3 = 0;
            break label$1;
           }
           HEAP16[$2 + 2 >> 1] = 0;
           HEAP32[$2 + 16 >> 2] = 1;
           HEAP32[$2 + 20 >> 2] = 0;
           if (($1 | 0) != 4) {
            break label$10;
           }
           if ($5 >>> 0 > 2) {
            break label$9;
           }
          }
          $3 = ($1 | 0) != 1;
          HEAP16[$2 >> 1] = $3;
          $6 = HEAP32[16232];
          $4 = $6 >> 31;
          HEAP32[$2 + 8 >> 2] = $6;
          HEAP32[$2 + 12 >> 2] = $4;
          if (unixFileLock($0, $2)) {
           $3 = 5;
           $1 = HEAP32[__errno_location() >> 2];
           $5 = sqliteErrorFromPosixError($1);
           if (($5 | 0) == 5) {
            break label$1;
           }
           storeLastErrno($0, $1);
           $3 = $5;
           break label$1;
          }
          if ($3) {
           break label$10;
          }
          HEAP32[$2 + 16 >> 2] = 510;
          HEAP32[$2 + 20 >> 2] = 0;
          $6 = HEAP32[16232] + 2 | 0;
          $4 = $6 >> 31;
          HEAP32[$2 + 8 >> 2] = $6;
          HEAP32[$2 + 12 >> 2] = $4;
          $3 = 0;
          $5 = 0;
          if (unixFileLock($0, $2)) {
           $5 = HEAP32[__errno_location() >> 2];
           $3 = sqliteErrorFromPosixError($5);
          }
          HEAP32[$2 + 16 >> 2] = 1;
          HEAP32[$2 + 20 >> 2] = 0;
          HEAP16[$2 >> 1] = 2;
          $4 = HEAP32[16232];
          $6 = $4 >> 31;
          HEAP32[$2 + 8 >> 2] = $4;
          HEAP32[$2 + 12 >> 2] = $6;
          label$16: {
           label$17: {
            if (!(!unixFileLock($0, $2) | $3)) {
             $5 = HEAP32[__errno_location() >> 2];
             $3 = 2058;
             break label$17;
            }
            if (!$3) {
             break label$16;
            }
            if (($3 | 0) == 5) {
             break label$1;
            }
           }
           storeLastErrno($0, $5);
           break label$1;
          }
          HEAP32[$7 + 20 >> 2] = 1;
          HEAP32[$7 + 24 >> 2] = HEAP32[$7 + 24 >> 2] + 1;
          break label$5;
         }
         if (($1 | 0) != 4) {
          break label$8;
         }
        }
        $3 = 5;
        if (HEAP32[$7 + 20 >> 2] > 1) {
         break label$3;
        }
        HEAP16[$2 >> 1] = 1;
        break label$7;
       }
       HEAP16[$2 >> 1] = 1;
       $4 = 1;
       $3 = 1;
       $6 = 0;
       if (($1 | 0) == 2) {
        break label$6;
       }
      }
      $4 = 510;
      $3 = 2;
      $6 = 0;
     }
     HEAP32[$2 + 16 >> 2] = $4;
     HEAP32[$2 + 20 >> 2] = 0;
     $4 = $3 + HEAP32[16232] | 0;
     $6 = $4 >> 31;
     HEAP32[$2 + 8 >> 2] = $4;
     HEAP32[$2 + 12 >> 2] = $6;
     if (!unixFileLock($0, $2)) {
      break label$5;
     }
     $5 = HEAP32[__errno_location() >> 2];
     $3 = sqliteErrorFromPosixError($5);
     if (($3 | 0) == 5) {
      break label$4;
     }
     storeLastErrno($0, $5);
     if ($3) {
      break label$4;
     }
    }
    HEAP8[$0 + 16 | 0] = $1;
    HEAP8[$7 + 28 | 0] = $1;
    $3 = 0;
    break label$1;
   }
   if (($1 | 0) != 4) {
    break label$1;
   }
  }
  HEAP8[$0 + 16 | 0] = 3;
  HEAP8[$7 + 28 | 0] = 3;
 }
 __stack_pointer = $2 + 32 | 0;
 return $3 | 0;
}

function sqlite3AlterDropColumn($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 $11 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$11 + 87 | 0]) {
   break label$1;
  }
  $3 = sqlite3LocateTableItem($0, 0, $1 + 8 | 0);
  if (!$3) {
   break label$1;
  }
  if (isAlterableTable($0, $3)) {
   break label$1;
  }
  if (isRealTable($0, $3, 1)) {
   break label$1;
  }
  $12 = sqlite3NameFromToken($11, $2);
  if (!$12) {
   break label$1;
  }
  $10 = sqlite3ColumnIndex($3, $12);
  label$2: {
   if (($10 | 0) < 0) {
    HEAP32[$6 >> 2] = $2;
    sqlite3ErrorMsg($0, 28902, $6);
    break label$2;
   }
   $2 = HEAPU16[(HEAP32[$3 + 4 >> 2] + Math_imul($10, 12) | 0) + 10 >> 1];
   if ($2 & 9) {
    HEAP32[$6 + 52 >> 2] = $12;
    HEAP32[$6 + 48 >> 2] = $2 & 1 ? 18056 : 19732;
    sqlite3ErrorMsg($0, 28853, $6 + 48 | 0);
    break label$2;
   }
   if (HEAP16[$3 + 34 >> 1] <= 1) {
    HEAP32[$6 + 16 >> 2] = $12;
    sqlite3ErrorMsg($0, 2058, $6 + 16 | 0);
    break label$2;
   }
   $2 = HEAP32[$11 + 16 >> 2];
   $4 = sqlite3SchemaToIndex($11, HEAP32[$3 + 60 >> 2]);
   $2 = HEAP32[$2 + ($4 << 4) >> 2];
   if (sqlite3AuthCheck($0, 26, $2, HEAP32[$3 >> 2], $12)) {
    break label$2;
   }
   $5 = ($4 | 0) == 1;
   renameTestSchema($0, $2, $5, 29623, 0);
   renameFixQuotes($0, $2, $5);
   HEAP32[$6 + 44 >> 2] = HEAP32[$3 >> 2];
   HEAP32[$6 + 40 >> 2] = $10;
   HEAP32[$6 + 36 >> 2] = $4;
   HEAP32[$6 + 32 >> 2] = $2;
   sqlite3NestedParse($0, 24725, $6 + 32 | 0);
   renameReloadSchema($0, $4, 2);
   renameTestSchema($0, $2, $5, 10483, 1);
   if (HEAP32[$0 + 36 >> 2] | HEAPU8[(HEAP32[$3 + 4 >> 2] + Math_imul($10, 12) | 0) + 10 | 0] & 32) {
    break label$2;
   }
   $7 = sqlite3GetVdbe($0);
   $9 = HEAP32[$0 + 40 >> 2];
   HEAP32[$0 + 40 >> 2] = $9 + 1;
   sqlite3OpenTable($0, $9, $4, $3, 113);
   $16 = sqlite3VdbeAddOp1($7, 35, $9);
   $8 = HEAP32[$0 + 44 >> 2];
   $13 = $8 + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $13;
   label$6: {
    if (!(HEAPU8[$3 + 28 | 0] & 128)) {
     sqlite3VdbeAddOp2($7, 135, $9, $13);
     $5 = 0;
     $4 = 0;
     $2 = HEAP32[$0 + 44 >> 2] + HEAP16[$3 + 34 >> 1] | 0;
     break label$6;
    }
    $4 = sqlite3PrimaryKeyIndex($3);
    HEAP32[$0 + 44 >> 2] = HEAPU16[$4 + 52 >> 1] + $13;
    $2 = 0;
    while (1) {
     $5 = HEAPU16[$4 + 50 >> 1];
     if ($2 >>> 0 < $5 >>> 0) {
      $5 = $2 + 1 | 0;
      sqlite3VdbeAddOp3($7, 94, $9, $2, $13 + $5 | 0);
      $2 = $5;
      continue;
     }
     break;
    }
    $2 = HEAP32[$0 + 44 >> 2];
   }
   $15 = $2 + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $15;
   $14 = $8 + 2 | 0;
   $2 = 0;
   while (1) {
    if (($2 | 0) < HEAP16[$3 + 34 >> 1]) {
     label$12: {
      if (HEAPU8[(HEAP32[$3 + 4 >> 2] + Math_imul($2, 12) | 0) + 10 | 0] & 32 | ($2 | 0) == ($10 | 0)) {
       break label$12;
      }
      label$13: {
       if ($4) {
        $8 = sqlite3TableColumnToIndex($4, $2 << 16 >> 16);
        $17 = sqlite3TableColumnToIndex($4, $10 << 16 >> 16);
        if (HEAPU16[$4 + 50 >> 1] > ($8 | 0)) {
         break label$12;
        }
        $8 = ($8 + $14 | 0) - (($8 | 0) > ($17 | 0)) | 0;
        break label$13;
       }
       $8 = $5 + $14 | 0;
      }
      label$15: {
       if (HEAP16[$3 + 32 >> 1] == ($2 | 0)) {
        sqlite3VdbeAddOp2($7, 75, 0, $8);
        break label$15;
       }
       sqlite3ExprCodeGetColumnOfTable($7, $3, $9, $2, $8);
      }
      $5 = $5 + 1 | 0;
     }
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   if (!$5) {
    HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 1;
    sqlite3VdbeAddOp2($7, 75, 0, $14);
    $5 = 1;
   }
   sqlite3VdbeAddOp3($7, 97, $14, $5, $15);
   label$18: {
    if ($4) {
     sqlite3VdbeAddOp4Int($7, 138, $9, $15, $14, HEAPU16[$4 + 50 >> 1]);
     break label$18;
    }
    sqlite3VdbeAddOp3($7, 128, $9, $15, $13);
   }
   sqlite3VdbeChangeP5($7, 2);
   sqlite3VdbeAddOp2($7, 38, $9, $16 + 1 | 0);
   sqlite3VdbeJumpHere($7, $16);
  }
  $10 = $12;
 }
 sqlite3DbFree($11, $10);
 sqlite3SrcListDelete($11, $1);
 __stack_pointer = $6 - -64 | 0;
}

function sqlite3Normalize($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $11 = sqlite3VdbeDb($0);
 HEAP32[$6 + 12 >> 2] = -1;
 $2 = sqlite3_str_new($11);
 $7 = -1;
 while (1) {
  $5 = $7;
  label$2: {
   $3 = $1 + $13 | 0;
   $4 = HEAPU8[$3 | 0];
   if (!(HEAPU8[$2 + 20 | 0] | !$4)) {
    $8 = sqlite3GetToken($3, $6 + 12 | 0);
    $7 = HEAP32[$6 + 12 >> 2];
    if (($8 | 0) > 0) {
     break label$2;
    }
    $5 = $7;
   }
   if (($5 | 0) != 1) {
    sqlite3_str_append($2, 22442, 1);
   }
   $2 = sqlite3_str_finish($2);
   __stack_pointer = $6 + 16 | 0;
   return $2;
  }
  $12 = ($5 | 0) == 183 ? $12 : $5;
  label$5: {
   label$6: {
    label$7: {
     if ($7 - 153 >>> 0 < 4) {
      break label$7;
     }
     label$8: {
      label$9: {
       label$10: {
        label$11: {
         switch ($7 - 22 | 0) {
         default:
          label$14: {
           switch ($7 - 117 | 0) {
           default:
            if (($7 | 0) == 59) {
             break label$10;
            }
            if (($7 | 0) == 138) {
             break label$9;
            }
            if (($7 | 0) != 183) {
             break label$8;
            }
            break label$5;

           case 4:
            break label$14;

           case 0:
            break label$7;

           case 1:
           case 2:
           case 3:
            break label$8;
           }
          }
          if (($12 | 0) != 45 & ($12 | 0) != 19) {
           break label$7;
          }
          sqlite3_str_append($2, 19645, 5);
          break label$5;

         case 0:
          $9 = $9 + 1 | 0;
          if (($12 | 0) == 49) {
           $14 = $9;
           $10 = HEAP32[$2 + 16 >> 2];
          }
          sqlite3_str_append($2, 26931, 1);
          break label$5;

         case 1:
          break label$11;
         }
        }
        if (!(($9 | 0) != ($14 | 0) | ($10 | 0) <= 0)) {
         HEAP32[$2 + 16 >> 2] = $10 + 1;
         sqlite3_str_append($2, 20559, 5);
         $10 = 0;
        }
        sqlite3_str_append($2, 26910, 1);
        $9 = $9 - 1 | 0;
        break label$5;
       }
       $5 = HEAP32[$2 + 16 >> 2];
       label$18: {
        if (HEAP8[$4 + 30288 | 0] < 0) {
         $4 = sqlite3DbStrNDup($11, $3, $8, 0);
         HEAP32[$6 + 8 >> 2] = 0;
         if (!$4) {
          break label$6;
         }
         sqlite3Dequote($4);
         label$20: {
          if (HEAPU8[$3 | 0] != 34) {
           break label$20;
          }
          if (!sqlite3VdbeUsesDoubleQuotedString($0, $4)) {
           break label$20;
          }
          sqlite3_str_append($2, 21197, 1);
          sqlite3DbFree($11, $4);
          break label$6;
         }
         $3 = sqlite3Strlen30($4);
         label$21: {
          if (!(($3 | 0) != (sqlite3GetToken($4, $6 + 8 | 0) | 0) | HEAP32[$6 + 8 >> 2] != 59)) {
           addSpaceSeparator($2);
           sqlite3_str_append($2, $4, $3);
           break label$21;
          }
          HEAP32[$6 >> 2] = $4;
          sqlite3_str_appendf($2, 28448, $6);
         }
         sqlite3DbFree($11, $4);
         break label$18;
        }
        addSpaceSeparator($2);
        sqlite3_str_append($2, $3, $8);
       }
       while (1) {
        if (HEAPU32[$2 + 16 >> 2] <= $5 >>> 0) {
         break label$6;
        }
        $3 = HEAP32[$2 + 4 >> 2] + $5 | 0;
        HEAP8[$3 | 0] = HEAPU8[HEAPU8[$3 | 0] + 29904 | 0];
        $5 = $5 + 1 | 0;
        continue;
       }
      }
      $10 = 0;
     }
     if (sqlite3IsIdChar($4)) {
      addSpaceSeparator($2);
     }
     $5 = HEAP32[$2 + 16 >> 2];
     sqlite3_str_append($2, $3, $8);
     while (1) {
      if (HEAPU32[$2 + 16 >> 2] <= $5 >>> 0) {
       break label$5;
      }
      $3 = HEAP32[$2 + 4 >> 2] + $5 | 0;
      $4 = $3;
      $3 = HEAPU8[$3 | 0];
      HEAP8[$4 | 0] = $3 & (HEAPU8[$3 + 30288 | 0] ^ -1 | 223);
      $5 = $5 + 1 | 0;
      continue;
     }
    }
    sqlite3_str_append($2, 21197, 1);
    break label$5;
   }
   $10 = 0;
  }
  $13 = $8 + $13 | 0;
  continue;
 }
}

function sqlite3BtreeTableMoveto($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 label$1: {
  label$2: {
   if (HEAPU8[$0 | 0]) {
    break label$2;
   }
   $5 = HEAPU8[$0 + 1 | 0];
   if (!($5 & 2)) {
    break label$2;
   }
   $9 = HEAP32[$0 + 32 >> 2];
   $6 = HEAP32[$0 + 36 >> 2];
   if (($9 | 0) == ($1 | 0) & ($6 | 0) == ($2 | 0)) {
    $5 = 0;
    HEAP32[$4 >> 2] = 0;
    break label$1;
   }
   if (($2 | 0) <= ($6 | 0) & $1 >>> 0 <= $9 >>> 0 | ($2 | 0) < ($6 | 0)) {
    break label$2;
   }
   if ($5 & 8) {
    HEAP32[$4 >> 2] = -1;
    $5 = 0;
    break label$1;
   }
   $5 = $9 + 1 | 0;
   $12 = $5 ? $6 : $6 + 1 | 0;
   $6 = $1;
   if (($5 | 0) != ($6 | 0) | ($2 | 0) != ($12 | 0)) {
    break label$2;
   }
   HEAP32[$4 >> 2] = 0;
   $5 = sqlite3BtreeNext($0);
   if (($5 | 0) == 101) {
    break label$2;
   }
   if ($5) {
    break label$1;
   }
   getCellInfo($0);
   $5 = 0;
   $6 = HEAP32[$0 + 32 >> 2];
   $12 = HEAP32[$0 + 36 >> 2];
   if (($6 | 0) == ($1 | 0) & ($12 | 0) == ($2 | 0)) {
    break label$1;
   }
  }
  $5 = moveToRoot($0);
  if (($5 | 0) != 16) {
   if ($5) {
    break label$1;
   }
   $17 = 1 - $3 | 0;
   while (1) {
    $7 = HEAP32[$0 + 116 >> 2];
    $14 = HEAPU16[$7 + 24 >> 1];
    $13 = $14 - 1 | 0;
    $8 = $13 >> $17;
    $18 = HEAPU8[$7 + 2 | 0];
    $15 = HEAP32[$7 + 64 >> 2];
    $16 = HEAPU16[$7 + 26 >> 1];
    $19 = HEAP32[$7 + 68 >> 2];
    $10 = 0;
    label$7: {
     label$8: {
      label$9: {
       label$10: {
        while (1) {
         $5 = ($8 << 1) + $15 | 0;
         $5 = ((HEAPU8[$5 | 0] << 8 | HEAPU8[$5 + 1 | 0]) & $16) + $19 | 0;
         label$12: {
          if (!$18) {
           break label$12;
          }
          while (1) {
           $3 = $5 + 1 | 0;
           if (HEAP8[$5 | 0] >= 0) {
            $5 = $3;
            break label$12;
           }
           $5 = $3;
           if ($5 >>> 0 < HEAPU32[$7 + 60 >> 2]) {
            continue;
           }
           break;
          }
          $5 = sqlite3CorruptError(72507);
          break label$1;
         }
         sqlite3GetVarint($5, $11 + 8 | 0);
         $6 = HEAP32[$11 + 8 >> 2];
         $9 = $6;
         label$15: {
          $12 = HEAP32[$11 + 12 >> 2];
          $6 = $12;
          label$16: {
           if (($6 | 0) <= ($2 | 0) & $1 >>> 0 > $9 >>> 0 | ($2 | 0) > ($6 | 0)) {
            $10 = $8 + 1 | 0;
            if (($8 | 0) < ($13 | 0)) {
             break label$16;
            }
            $5 = -1;
            break label$9;
           }
           if (($6 | 0) <= ($2 | 0) & $1 >>> 0 >= $9 >>> 0 | ($2 | 0) > ($6 | 0)) {
            break label$15;
           }
           if (($8 | 0) <= ($10 | 0)) {
            break label$10;
           }
           $13 = $8 - 1 | 0;
          }
          $8 = $10 + $13 >> 1;
          continue;
         }
         break;
        }
        HEAP16[$0 + 70 >> 1] = $8;
        if (!HEAPU8[$7 + 8 | 0]) {
         $10 = $8;
         break label$8;
        }
        HEAP32[$0 + 32 >> 2] = $9;
        HEAP32[$0 + 36 >> 2] = $6;
        $5 = 0;
        HEAP16[$0 + 50 >> 1] = 0;
        HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] | 2;
        HEAP32[$4 >> 2] = 0;
        break label$1;
       }
       $5 = 1;
      }
      if (!HEAPU8[$7 + 8 | 0]) {
       break label$8;
      }
      HEAP16[$0 + 70 >> 1] = $8;
      HEAP32[$4 >> 2] = $5;
      $5 = 0;
      break label$7;
     }
     $5 = HEAP32[$7 + 56 >> 2];
     label$19: {
      if (($10 | 0) >= ($14 | 0)) {
       $5 = sqlite3Get4byte((HEAPU8[$7 + 9 | 0] + $5 | 0) + 8 | 0);
       break label$19;
      }
      $3 = ($10 << 1) + $15 | 0;
      $5 = sqlite3Get4byte(((HEAPU8[$3 | 0] << 8 | HEAPU8[$3 + 1 | 0]) & $16) + $5 | 0);
     }
     HEAP16[$0 + 70 >> 1] = $10;
     $5 = moveToChild($0, $5);
     if (!$5) {
      continue;
     }
    }
    break;
   }
   HEAP16[$0 + 50 >> 1] = 0;
   break label$1;
  }
  HEAP32[$4 >> 2] = -1;
  $5 = 0;
 }
 __stack_pointer = $11 + 16 | 0;
 return $5;
}

function sqlite3VdbeDisplayP4($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 208 | 0;
 __stack_pointer = $2;
 sqlite3StrAccumInit($2 + 184 | 0, 0, 0, 0, 1e9);
 $4 = 11018;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     switch (HEAP8[$1 + 1 | 0] + 15 | 0) {
     case 7:
      $1 = HEAP32[$1 + 16 >> 2];
      HEAP32[$2 + 16 >> 2] = HEAPU16[$1 + 6 >> 1];
      sqlite3_str_appendf($2 + 184 | 0, 16079, $2 + 16 | 0);
      while (1) {
       if ($3 >>> 0 < HEAPU16[$1 + 6 >> 1]) {
        $5 = HEAPU8[HEAP32[$1 + 16 >> 2] + $3 | 0];
        $4 = HEAP32[(($3 << 2) + $1 | 0) + 20 >> 2];
        if ($4) {
         $4 = HEAP32[$4 >> 2];
        } else {
         $4 = 29623;
        }
        HEAP32[$2 + 8 >> 2] = strcmp($4, 32384) ? $4 : 20308;
        HEAP32[$2 + 4 >> 2] = $5 & 2 ? 24262 : 29623;
        HEAP32[$2 >> 2] = $5 & 1 ? 24269 : 29623;
        sqlite3_str_appendf($2 + 184 | 0, 5767, $2);
        $3 = $3 + 1 | 0;
        continue;
       }
       break;
      }
      ;
      sqlite3_str_append($2 + 184 | 0, 26910, 1);
      break label$1;

     case 13:
      $3 = HEAP32[$1 + 16 >> 2];
      $1 = HEAPU8[$3 + 4 | 0];
      HEAP32[$2 + 32 >> 2] = HEAP32[$3 >> 2];
      HEAP32[$2 + 36 >> 2] = HEAP32[($1 << 2) + 32400 >> 2];
      sqlite3_str_appendf($2 + 184 | 0, 6027, $2 + 32 | 0);
      break label$1;

     case 8:
      $3 = HEAP32[$1 + 16 >> 2];
      $1 = HEAP32[$3 + 32 >> 2];
      HEAP32[$2 + 52 >> 2] = HEAP8[$3 | 0];
      HEAP32[$2 + 48 >> 2] = $1;
      sqlite3_str_appendf($2 + 184 | 0, 24915, $2 + 48 | 0);
      break label$1;

     case 0:
      $3 = HEAP32[HEAP32[$1 + 16 >> 2] + 4 >> 2];
      $1 = HEAP32[$3 + 32 >> 2];
      HEAP32[$2 + 68 >> 2] = HEAP8[$3 | 0];
      HEAP32[$2 + 64 >> 2] = $1;
      sqlite3_str_appendf($2 + 184 | 0, 24915, $2 - -64 | 0);
      break label$1;

     case 2:
      $3 = HEAP32[$1 + 16 >> 2];
      $1 = HEAP32[$3 >> 2];
      $3 = HEAP32[$3 + 4 >> 2];
      HEAP32[$2 + 80 >> 2] = $1;
      HEAP32[$2 + 84 >> 2] = $3;
      sqlite3_str_appendf($2 + 184 | 0, 14325, $2 + 80 | 0);
      break label$1;

     case 12:
      HEAP32[$2 + 96 >> 2] = HEAP32[$1 + 16 >> 2];
      sqlite3_str_appendf($2 + 184 | 0, 16944, $2 + 96 | 0);
      break label$1;

     case 3:
      HEAPF64[$2 + 112 >> 3] = HEAPF64[HEAP32[$1 + 16 >> 2] >> 3];
      sqlite3_str_appendf($2 + 184 | 0, 12010, $2 + 112 | 0);
      break label$1;

     case 5:
      $3 = HEAP32[$1 + 16 >> 2];
      $1 = HEAPU16[$3 + 16 >> 1];
      if ($1 & 2) {
       $3 = $3 + 8 | 0;
       break label$3;
      }
      if ($1 & 36) {
       $1 = HEAP32[$3 + 4 >> 2];
       $3 = HEAP32[$3 >> 2];
       HEAP32[$2 + 144 >> 2] = $3;
       HEAP32[$2 + 148 >> 2] = $1;
       sqlite3_str_appendf($2 + 184 | 0, 14325, $2 + 144 | 0);
       break label$1;
      }
      if ($1 & 8) {
       HEAPF64[$2 + 128 >> 3] = HEAPF64[$3 >> 3];
       sqlite3_str_appendf($2 + 184 | 0, 12010, $2 + 128 | 0);
       break label$1;
      }
      $4 = $1 & 1 ? 19646 : 25080;
      break label$2;

     case 4:
      HEAP32[$2 + 160 >> 2] = HEAP32[HEAP32[$1 + 16 >> 2] + 8 >> 2];
      sqlite3_str_appendf($2 + 184 | 0, 9475, $2 + 160 | 0);
      break label$1;

     case 1:
      $4 = HEAP32[$1 + 16 >> 2];
      $1 = HEAP32[$4 >> 2];
      $3 = 1;
      while (1) {
       if ($1 >>> 0 >= $3 >>> 0) {
        HEAP32[$2 + 180 >> 2] = HEAP32[($3 << 2) + $4 >> 2];
        HEAP32[$2 + 176 >> 2] = ($3 | 0) == 1 ? 91 : 44;
        sqlite3_str_appendf($2 + 184 | 0, 1848, $2 + 176 | 0);
        $3 = $3 + 1 | 0;
        continue;
       }
       break;
      }
      ;
      sqlite3_str_append($2 + 184 | 0, 17891, 1);
      break label$1;

     case 10:
      $3 = HEAP32[$1 + 16 >> 2];
      break label$3;

     case 11:
      break label$2;

     default:
      break label$4;
     }
    }
    $3 = $1 + 16 | 0;
   }
   $4 = HEAP32[$3 >> 2];
   if (!$4) {
    break label$1;
   }
  }
  sqlite3_str_appendall($2 + 184 | 0, $4);
 }
 if (HEAPU8[$2 + 204 | 0] & 7) {
  sqlite3OomFault($0);
 }
 $3 = sqlite3StrAccumFinish($2 + 184 | 0);
 __stack_pointer = $2 + 208 | 0;
 return $3;
}

function sqlite3ExprIfFalse($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 + 8 >> 2];
 HEAP32[$6 + 12 >> 2] = 0;
 HEAP32[$6 + 8 >> 2] = 0;
 if (!(!$1 | !$5)) {
  $4 = HEAPU8[$1 | 0];
  $7 = $4 ^ 1;
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$10: {
           switch ($4 - 43 | 0) {
           default:
            label$12: {
             switch ($4 - 171 | 0) {
             case 1:
             case 2:
             case 3:
              break label$3;

             case 0:
              break label$8;

             case 4:
              break label$9;

             default:
              break label$12;
             }
            }
            if (($4 | 0) != 19) {
             break label$3;
            }
            sqlite3ExprIfTrue($0, HEAP32[$1 + 12 >> 2], $2, $3);
            $4 = 0;
            break label$2;

           case 0:
           case 1:
            break label$10;

           case 3:
           case 4:
            break label$3;

           case 6:
            break label$4;

           case 5:
            break label$5;

           case 7:
           case 8:
            break label$6;

           case 9:
           case 10:
           case 11:
           case 12:
           case 13:
           case 14:
            break label$7;

           case 2:
            break label$8;
           }
          }
          $7 = sqlite3ExprSimplifiedAndOr($1);
          if (($7 | 0) != ($1 | 0)) {
           sqlite3ExprIfFalse($0, $7, $2, $3);
           $4 = 0;
           break label$2;
          }
          if (($4 | 0) == 44) {
           sqlite3ExprIfFalse($0, HEAP32[$1 + 12 >> 2], $2, $3);
           sqlite3ExprIfFalse($0, HEAP32[$1 + 16 >> 2], $2, $3);
           $4 = 0;
           break label$2;
          }
          $4 = sqlite3VdbeMakeLabel($0);
          sqlite3ExprIfTrue($0, HEAP32[$1 + 12 >> 2], $4, $3 ^ 16);
          sqlite3ExprIfFalse($0, HEAP32[$1 + 16 >> 2], $2, $3);
          sqlite3VdbeResolveLabel($5, $4);
          $4 = 0;
          break label$2;
         }
         $5 = HEAPU8[$1 + 2 | 0];
         $3 = (($5 | 0) != 171) << 4;
         $4 = HEAP32[$1 + 12 >> 2];
         if ((sqlite3ExprTruthValue(HEAP32[$1 + 16 >> 2]) | 0) != (($5 | 0) == 171 | 0)) {
          sqlite3ExprIfFalse($0, $4, $2, $3);
          $4 = 0;
          break label$2;
         }
         sqlite3ExprIfTrue($0, $4, $2, $3);
         $4 = 0;
         break label$2;
        }
        $7 = ($4 | 0) == 45 ? 52 : 53;
        $3 = 128;
       }
       $4 = HEAP32[$1 + 12 >> 2];
       if (sqlite3ExprIsVector($4)) {
        break label$3;
       }
       $5 = sqlite3ExprCodeTemp($0, $4, $6 + 12 | 0);
       $4 = sqlite3ExprCodeTemp($0, HEAP32[$1 + 16 >> 2], $6 + 8 | 0);
       codeCompare($0, HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2], $7, $5, $4, $2, $3, HEAP32[$1 + 4 >> 2] >>> 10 & 1);
       $4 = HEAP32[$6 + 8 >> 2];
       break label$2;
      }
      sqlite3VdbeAddOp2($5, $7, sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 12 | 0), $2);
      $4 = 0;
      break label$2;
     }
     exprCodeBetween($0, $1, $2, 54, $3);
     $4 = 0;
     break label$2;
    }
    if ($3) {
     sqlite3ExprCodeIN($0, $1, $2, $2);
     $4 = 0;
     break label$2;
    }
    $3 = sqlite3VdbeMakeLabel($0);
    sqlite3ExprCodeIN($0, $1, $2, $3);
    sqlite3VdbeResolveLabel($5, $3);
    $4 = 0;
    break label$2;
   }
   $7 = HEAP32[$1 + 4 >> 2];
   if (($7 & 536870913) == 536870912) {
    sqlite3VdbeGoto($5, $2);
    $4 = 0;
    break label$2;
   }
   $4 = 0;
   if (($7 & 268435457) == 268435456) {
    break label$2;
   }
   sqlite3VdbeAddOp3($5, 16, sqlite3ExprCodeTemp($0, $1, $6 + 12 | 0), $2, ($3 | 0) != 0);
   $4 = 0;
  }
  sqlite3ReleaseTempReg($0, HEAP32[$6 + 12 >> 2]);
  sqlite3ReleaseTempReg($0, $4);
 }
 __stack_pointer = $6 + 16 | 0;
}

function sqlite3ExprIfTrue($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 + 8 >> 2];
 HEAP32[$6 + 12 >> 2] = 0;
 HEAP32[$6 + 8 >> 2] = 0;
 if (!(!$1 | !$5)) {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         label$9: {
          label$10: {
           label$11: {
            $4 = HEAPU8[$1 | 0];
            switch ($4 - 43 | 0) {
            case 0:
            case 1:
             break label$10;

            case 3:
            case 4:
             break label$3;

            case 6:
             break label$4;

            case 5:
             break label$5;

            case 7:
            case 8:
             break label$6;

            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
             break label$7;

            case 2:
             break label$8;

            default:
             break label$11;
            }
           }
           label$12: {
            switch ($4 - 171 | 0) {
            case 1:
            case 2:
            case 3:
             break label$3;

            case 0:
             break label$8;

            case 4:
             break label$9;

            default:
             break label$12;
            }
           }
           if (($4 | 0) != 19) {
            break label$3;
           }
           sqlite3ExprIfFalse($0, HEAP32[$1 + 12 >> 2], $2, $3);
           $4 = 0;
           break label$2;
          }
          $7 = sqlite3ExprSimplifiedAndOr($1);
          if (($7 | 0) != ($1 | 0)) {
           sqlite3ExprIfTrue($0, $7, $2, $3);
           $4 = 0;
           break label$2;
          }
          if (($4 | 0) == 44) {
           $4 = sqlite3VdbeMakeLabel($0);
           sqlite3ExprIfFalse($0, HEAP32[$1 + 12 >> 2], $4, $3 ^ 16);
           sqlite3ExprIfTrue($0, HEAP32[$1 + 16 >> 2], $2, $3);
           sqlite3VdbeResolveLabel($5, $4);
           $4 = 0;
           break label$2;
          }
          sqlite3ExprIfTrue($0, HEAP32[$1 + 12 >> 2], $2, $3);
          sqlite3ExprIfTrue($0, HEAP32[$1 + 16 >> 2], $2, $3);
          $4 = 0;
          break label$2;
         }
         $5 = HEAPU8[$1 + 2 | 0] == 171;
         $3 = $5 << 4;
         $4 = HEAP32[$1 + 12 >> 2];
         if ((sqlite3ExprTruthValue(HEAP32[$1 + 16 >> 2]) | 0) != ($5 | 0)) {
          sqlite3ExprIfTrue($0, $4, $2, $3);
          $4 = 0;
          break label$2;
         }
         sqlite3ExprIfFalse($0, $4, $2, $3);
         $4 = 0;
         break label$2;
        }
        $4 = ($4 | 0) == 45 ? 53 : 52;
        $3 = 128;
       }
       $7 = HEAP32[$1 + 12 >> 2];
       if (sqlite3ExprIsVector($7)) {
        break label$3;
       }
       $5 = sqlite3ExprCodeTemp($0, $7, $6 + 12 | 0);
       $7 = sqlite3ExprCodeTemp($0, HEAP32[$1 + 16 >> 2], $6 + 8 | 0);
       codeCompare($0, HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2], $4, $5, $7, $2, $3, HEAP32[$1 + 4 >> 2] >>> 10 & 1);
       $4 = HEAP32[$6 + 8 >> 2];
       break label$2;
      }
      sqlite3VdbeAddOp2($5, $4, sqlite3ExprCodeTemp($0, HEAP32[$1 + 12 >> 2], $6 + 12 | 0), $2);
      $4 = 0;
      break label$2;
     }
     exprCodeBetween($0, $1, $2, 61, $3);
     $4 = 0;
     break label$2;
    }
    $4 = sqlite3VdbeMakeLabel($0);
    sqlite3ExprCodeIN($0, $1, $4, $3 ? $2 : $4);
    sqlite3VdbeGoto($5, $2);
    sqlite3VdbeResolveLabel($5, $4);
    $4 = 0;
    break label$2;
   }
   $7 = HEAP32[$1 + 4 >> 2];
   if (($7 & 268435457) == 268435456) {
    sqlite3VdbeGoto($5, $2);
    $4 = 0;
    break label$2;
   }
   $4 = 0;
   if (($7 & 536870913) == 536870912) {
    break label$2;
   }
   sqlite3VdbeAddOp3($5, 15, sqlite3ExprCodeTemp($0, $1, $6 + 12 | 0), $2, ($3 | 0) != 0);
   $4 = 0;
  }
  sqlite3ReleaseTempReg($0, HEAP32[$6 + 12 >> 2]);
  sqlite3ReleaseTempReg($0, $4);
 }
 __stack_pointer = $6 + 16 | 0;
}

function sqlite3CreateForeignKey($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $12 = __stack_pointer - 32 | 0;
 __stack_pointer = $12;
 $14 = HEAP32[$0 >> 2];
 $10 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$10 | HEAPU8[$0 + 208 | 0] == 1) {
   break label$1;
  }
  label$2: {
   if (!$1) {
    $8 = 1;
    $5 = HEAP16[$10 + 34 >> 1];
    if (($5 | 0) <= 0) {
     break label$1;
    }
    if (!$3 | HEAP32[$3 >> 2] == 1) {
     break label$2;
    }
    $5 = HEAP32[HEAP32[$10 + 4 >> 2] + Math_imul($5 - 1 | 0, 12) >> 2];
    HEAP32[$12 + 20 >> 2] = $2;
    HEAP32[$12 + 16 >> 2] = $5;
    sqlite3ErrorMsg($0, 18500, $12 + 16 | 0);
    break label$1;
   }
   if (!$3) {
    $8 = HEAP32[$1 >> 2];
    break label$2;
   }
   $8 = HEAP32[$3 >> 2];
   if (($8 | 0) == HEAP32[$1 >> 2]) {
    break label$2;
   }
   sqlite3ErrorMsg($0, 13578, 0);
   break label$1;
  }
  $9 = (HEAP32[$2 + 4 >> 2] + ($8 << 3) | 0) + 37 | 0;
  label$5: {
   if (!$3) {
    break label$5;
   }
   $5 = 0;
   $7 = HEAP32[$3 >> 2];
   $7 = ($7 | 0) > 0 ? $7 : 0;
   while (1) {
    if (($5 | 0) == ($7 | 0)) {
     break label$5;
    }
    $15 = sqlite3Strlen30(HEAP32[(($5 << 4) + $3 | 0) + 12 >> 2]) + 1 | 0;
    $9 = $15 + $9 | 0;
    $6 = $15 >>> 0 > $9 >>> 0 ? $6 + 1 | 0 : $6;
    $5 = $5 + 1 | 0;
    continue;
   }
  }
  $6 = sqlite3DbMallocZero($14, $9, $6);
  if (!$6) {
   break label$1;
  }
  HEAP32[$6 >> 2] = $10;
  HEAP32[$6 + 4 >> 2] = HEAP32[$10 + 48 >> 2];
  $5 = (($8 << 3) + $6 | 0) + 36 | 0;
  HEAP32[$6 + 8 >> 2] = $5;
  if (HEAPU8[$0 + 208 | 0] >= 2) {
   sqlite3RenameTokenMap($0, $5, $2);
  }
  $9 = __memcpy($5, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
  HEAP8[$9 + HEAP32[$2 + 4 >> 2] | 0] = 0;
  sqlite3Dequote($9);
  $15 = HEAP32[$2 + 4 >> 2];
  HEAP32[$6 + 20 >> 2] = $8;
  label$8: {
   label$9: {
    if ($1) {
     $16 = ($8 | 0) > 0 ? $8 : 0;
     while (1) {
      if (($13 | 0) == ($16 | 0)) {
       break label$9;
      }
      $5 = 0;
      $7 = HEAP16[$10 + 34 >> 1];
      $11 = ($7 | 0) > 0 ? $7 : 0;
      $7 = ($13 << 4) + $1 | 0;
      while (1) {
       if (($5 | 0) == ($11 | 0)) {
        break label$8;
       }
       $2 = HEAP32[$7 + 12 >> 2];
       if (sqlite3StrICmp(HEAP32[HEAP32[$10 + 4 >> 2] + Math_imul($5, 12) >> 2], $2)) {
        $5 = $5 + 1 | 0;
        continue;
       }
       break;
      }
      $7 = (($13 << 3) + $6 | 0) + 36 | 0;
      HEAP32[$7 >> 2] = $5;
      if (HEAPU8[$0 + 208 | 0] >= 2) {
       sqlite3RenameTokenRemap($0, $7, $2);
      }
      $13 = $13 + 1 | 0;
      continue;
     }
    }
    HEAP32[$6 + 36 >> 2] = HEAP16[$10 + 34 >> 1] - 1;
   }
   label$15: {
    if (!$3) {
     break label$15;
    }
    $7 = ($9 + $15 | 0) + 1 | 0;
    $13 = ($8 | 0) > 0 ? $8 : 0;
    $5 = 0;
    while (1) {
     if (($5 | 0) == ($13 | 0)) {
      break label$15;
     }
     $9 = ($5 << 4) + $3 | 0;
     $8 = $9 + 12 | 0;
     $2 = HEAP32[$8 >> 2];
     $11 = sqlite3Strlen30($2);
     HEAP32[(($5 << 3) + $6 | 0) + 40 >> 2] = $7;
     if (HEAPU8[$0 + 208 | 0] >= 2) {
      sqlite3RenameTokenRemap($0, $7, $2);
      $2 = HEAP32[$9 + 12 >> 2];
     }
     $7 = __memcpy($7, $2, $11) + $11 | 0;
     HEAP8[$7 | 0] = 0;
     $5 = $5 + 1 | 0;
     $7 = $7 + 1 | 0;
     continue;
    }
   }
   HEAP8[$6 + 25 | 0] = $4;
   HEAP8[$6 + 24 | 0] = 0;
   HEAP8[$6 + 26 | 0] = $4 >>> 8;
   $5 = sqlite3HashInsert(HEAP32[$10 + 60 >> 2] + 56 | 0, HEAP32[$6 + 8 >> 2], $6);
   if (($6 | 0) == ($5 | 0)) {
    sqlite3OomFault($14);
    $11 = $6;
    break label$1;
   }
   if ($5) {
    HEAP32[$6 + 12 >> 2] = $5;
    HEAP32[$5 + 16 >> 2] = $6;
   }
   HEAP32[$10 + 48 >> 2] = $6;
   $11 = 0;
   break label$1;
  }
  HEAP32[$12 >> 2] = HEAP32[$7 + 12 >> 2];
  sqlite3ErrorMsg($0, 9780, $12);
  $11 = $6;
 }
 sqlite3DbFree($14, $11);
 sqlite3ExprListDelete($14, $1);
 sqlite3ExprListDelete($14, $3);
 __stack_pointer = $12 + 32 | 0;
}

function resolveCompoundOrderBy($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 $10 = HEAP32[$1 + 48 >> 2];
 label$1: {
  if (!$10) {
   $1 = 0;
   break label$1;
  }
  $2 = HEAP32[$10 >> 2];
  $11 = HEAP32[$0 >> 2];
  label$3: {
   if (($2 | 0) <= HEAP32[$11 + 128 >> 2]) {
    $6 = ($2 | 0) > 0 ? $2 : 0;
    $2 = 0;
    while (1) {
     if (($2 | 0) != ($6 | 0)) {
      $3 = ($2 << 4) + $10 | 0;
      $5 = $3 + 17 | 0;
      $3 = (HEAPU8[$3 + 17 | 0] | HEAPU8[$3 + 18 | 0] << 8) & 65531;
      HEAP8[$5 | 0] = $3;
      HEAP8[$5 + 1 | 0] = $3 >>> 8;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    while (1) {
     $3 = $1;
     HEAP32[$1 + 56 >> 2] = $7;
     $7 = $1;
     $1 = HEAP32[$1 + 52 >> 2];
     if ($1) {
      continue;
     }
     break;
    }
    $14 = $10 + 8 | 0;
    $6 = 1;
    label$8: while (1) {
     if (!($6 ? $3 : 0)) {
      $1 = 0;
      $2 = HEAP32[$10 >> 2];
      $5 = ($2 | 0) > 0 ? $2 : 0;
      $2 = 0;
      while (1) {
       if (($2 | 0) == ($5 | 0)) {
        break label$1;
       }
       $7 = $2 << 4;
       $6 = $2 + 1 | 0;
       $2 = $6;
       if (HEAPU8[($7 + $10 | 0) + 17 | 0] & 4) {
        continue;
       }
       break;
      }
      HEAP32[$9 >> 2] = $6;
      sqlite3ErrorMsg($0, 3103, $9);
      break label$3;
     }
     $13 = HEAP32[$3 + 28 >> 2];
     $2 = 0;
     $1 = $14;
     $7 = 0;
     while (1) {
      $6 = $2;
      label$12: {
       label$13: {
        if (HEAP32[$10 >> 2] > ($7 | 0)) {
         HEAP32[$9 + 12 >> 2] = -1;
         if (HEAPU8[$1 + 9 | 0] & 4) {
          break label$13;
         }
         $8 = sqlite3ExprSkipCollateAndLikely(HEAP32[$1 >> 2]);
         if (!$8) {
          break label$13;
         }
         label$15: {
          if (sqlite3ExprIsInteger($8, $9 + 12 | 0)) {
           $4 = HEAP32[$9 + 12 >> 2];
           $2 = HEAP32[$13 >> 2];
           if (($4 | 0) > 0 & ($4 | 0) <= ($2 | 0)) {
            break label$15;
           }
           resolveOutOfRangeError($0, 19018, $7 + 1 | 0, $2, $8);
           break label$3;
          }
          $4 = resolveAsName($13, $8);
          if (!$4) {
           $4 = 0;
           $2 = sqlite3ExprDup($11, $8, 0);
           label$18: {
            if (HEAPU8[$11 + 87 | 0]) {
             break label$18;
            }
            $4 = resolveOrderByTermToExprList($0, $3, $2);
            if (HEAPU8[$0 + 208 | 0] < 2 | ($4 | 0) <= 0) {
             break label$18;
            }
            resolveOrderByTermToExprList($0, $3, $8);
           }
           sqlite3ExprDelete($11, $2);
          }
          $2 = 1;
          if (($4 | 0) <= 0) {
           break label$12;
          }
         }
         if (HEAPU8[$0 + 208 | 0] <= 1) {
          $12 = sqlite3Expr($11, 155, 0);
          if (!$12) {
           break label$3;
          }
          HEAP32[$12 + 8 >> 2] = $4;
          HEAP32[$12 + 4 >> 2] = HEAP32[$12 + 4 >> 2] | 2048;
          $5 = $1;
          $2 = HEAP32[$1 >> 2];
          if (($8 | 0) != ($2 | 0)) {
           while (1) {
            $5 = $2;
            $2 = HEAP32[$2 + 12 >> 2];
            if (HEAPU8[$2 | 0] == 113) {
             continue;
            }
            break;
           }
           $5 = $5 + 12 | 0;
          }
          HEAP32[$5 >> 2] = $12;
          sqlite3ExprDelete($11, $8);
          HEAP16[$1 + 12 >> 1] = $4;
         }
         $2 = HEAPU8[$1 + 9 | 0] | HEAPU8[$1 + 10 | 0] << 8 | 4;
         HEAP8[$1 + 9 | 0] = $2;
         HEAP8[$1 + 10 | 0] = $2 >>> 8;
         break label$13;
        }
        $3 = HEAP32[$3 + 56 >> 2];
        continue label$8;
       }
       $2 = $6;
      }
      $1 = $1 + 16 | 0;
      $7 = $7 + 1 | 0;
      continue;
     }
    }
   }
   sqlite3ErrorMsg($0, 12638, 0);
  }
  $1 = 1;
 }
 __stack_pointer = $9 + 16 | 0;
 return $1;
}

function sqlite3StartTable($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $9 = __stack_pointer - 32 | 0;
 __stack_pointer = $9;
 $7 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   if (!(!HEAPU8[$7 + 177 | 0] | HEAP32[$7 + 172 >> 2] != 1)) {
    $8 = HEAPU8[$7 + 176 | 0];
    $2 = sqlite3DbStrDup($7, ($8 | 0) == 1 ? 8671 : 8690);
    HEAP32[$9 + 28 >> 2] = $1;
    break label$2;
   }
   $1 = sqlite3TwoPartName($0, $1, $2, $9 + 28 | 0);
   if (($1 | 0) < 0) {
    break label$1;
   }
   label$4: {
    if (!$3) {
     $8 = $1;
     break label$4;
    }
    $8 = 1;
    if (!HEAP32[$2 + 4 >> 2] | ($1 | 0) == 1) {
     break label$4;
    }
    sqlite3ErrorMsg($0, 15588, 0);
    break label$1;
   }
   $1 = HEAP32[$9 + 28 >> 2];
   $2 = sqlite3NameFromToken($7, $1);
   if (HEAPU8[$0 + 208 | 0] < 2) {
    break label$2;
   }
   $2 = sqlite3RenameTokenMap($0, $2, $1);
  }
  $11 = HEAP32[$1 + 4 >> 2];
  HEAP32[$0 + 188 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$0 + 192 >> 2] = $11;
  if (!$2) {
   break label$1;
  }
  label$6: {
   if (sqlite3CheckObjectName($0, $2, $4 ? 1826 : 13666, $2)) {
    break label$6;
   }
   $3 = HEAPU8[$7 + 176 | 0] == 1 ? 1 : $3;
   $10 = HEAP32[HEAP32[$7 + 16 >> 2] + ($8 << 4) >> 2];
   if (sqlite3AuthCheck($0, 18, ($3 | 0) == 1 ? 8671 : 8690, 0, $10)) {
    break label$6;
   }
   if (!$5) {
    if (sqlite3AuthCheck($0, HEAPU8[(($4 << 1) + $3 | 0) + 48672 | 0], $2, 0, $10)) {
     break label$6;
    }
   }
   label$8: {
    label$9: {
     if (HEAPU8[$0 + 208 | 0]) {
      break label$9;
     }
     $3 = HEAP32[HEAP32[$7 + 16 >> 2] + ($8 << 4) >> 2];
     if (sqlite3ReadSchema($0)) {
      break label$6;
     }
     $10 = sqlite3FindTable($7, $2, $3);
     if ($10) {
      if ($6) {
       break label$8;
      }
      $3 = HEAPU8[$10 + 43 | 0];
      HEAP32[$9 + 20 >> 2] = $1;
      HEAP32[$9 + 16 >> 2] = ($3 | 0) == 2 ? 1826 : 13666;
      sqlite3ErrorMsg($0, 3491, $9 + 16 | 0);
      break label$6;
     }
     if (!sqlite3FindIndex($7, $2, $3)) {
      break label$9;
     }
     HEAP32[$9 >> 2] = $2;
     sqlite3ErrorMsg($0, 6709, $9);
     break label$6;
    }
    $1 = sqlite3DbMallocZero($7, 64, 0);
    if (!$1) {
     HEAP32[$0 + 12 >> 2] = 7;
     HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
     break label$6;
    }
    HEAP16[$1 + 32 >> 1] = 65535;
    HEAP32[$1 >> 2] = $2;
    $2 = HEAP32[(HEAP32[$7 + 16 >> 2] + ($8 << 4) | 0) + 12 >> 2];
    HEAP16[$1 + 38 >> 1] = 200;
    HEAP32[$1 + 24 >> 2] = 1;
    HEAP32[$1 + 60 >> 2] = $2;
    HEAP32[$0 + 236 >> 2] = $1;
    if (HEAPU8[$7 + 177 | 0]) {
     break label$1;
    }
    $1 = sqlite3GetVdbe($0);
    if (!$1) {
     break label$1;
    }
    sqlite3BeginWriteOperation($0, 1, $8);
    if ($5) {
     sqlite3VdbeAddOp0($1, 170);
    }
    $2 = HEAP32[$0 + 44 >> 2];
    $6 = $2 + 2 | 0;
    HEAP32[$0 + 92 >> 2] = $6;
    $3 = $2 + 1 | 0;
    HEAP32[$0 + 88 >> 2] = $3;
    $2 = $2 + 3 | 0;
    HEAP32[$0 + 44 >> 2] = $2;
    sqlite3VdbeAddOp3($1, 99, $8, $2, 2);
    sqlite3VdbeUsesBtree($1, $8);
    $10 = sqlite3VdbeAddOp1($1, 15, $2);
    $11 = HEAP32[$7 + 32 >> 2];
    $12 = $11 & 2;
    $11 = 0;
    sqlite3VdbeAddOp3($1, 100, $8, 2, $12 | $11 ? 1 : 4);
    sqlite3VdbeAddOp3($1, 100, $8, 5, HEAPU8[$7 + 84 | 0]);
    sqlite3VdbeJumpHere($1, $10);
    label$13: {
     if ($4 | $5) {
      sqlite3VdbeAddOp2($1, 71, 0, $6);
      break label$13;
     }
     HEAP32[$0 + 132 >> 2] = sqlite3VdbeAddOp3($1, 147, $8, $6, 1);
    }
    sqlite3OpenSchemaTable($0, $8);
    sqlite3VdbeAddOp2($1, 127, 0, $3);
    sqlite3VdbeAddOp4($1, 77, 6, $2, 0, 48676, -1);
    sqlite3VdbeAddOp3($1, 128, 0, $2, $3);
    sqlite3VdbeChangeP5($1, 8);
    sqlite3VdbeAddOp0($1, 122);
    break label$1;
   }
   sqlite3CodeVerifySchema($0, $8);
   sqlite3ForceNotReadOnly($0);
  }
  HEAP8[$0 + 17 | 0] = 1;
  sqlite3DbFree($7, $2);
 }
 __stack_pointer = $9 + 32 | 0;
}

function sqlite3VdbeExpandSql($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = __stack_pointer - 160 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 156 >> 2] = 0;
 $8 = HEAP32[$0 >> 2];
 sqlite3StrAccumInit($2 + 128 | 0, 0, 0, 0, HEAP32[$8 + 120 >> 2]);
 label$1: {
  if (HEAP32[$8 + 196 >> 2] >= 2) {
   $6 = $1;
   while (1) {
    $3 = HEAPU8[$1 | 0];
    if (!$3) {
     break label$1;
    }
    while (1) {
     label$5: {
      $6 = $6 + 1 | 0;
      if (($3 & 255) == 10) {
       break label$5;
      }
      $3 = HEAPU8[$6 | 0];
      if ($3) {
       continue;
      }
     }
     break;
    }
    sqlite3_str_append($2 + 128 | 0, 29574, 3);
    sqlite3_str_append($2 + 128 | 0, $1, $6 - $1 | 0);
    $1 = $6;
    continue;
   }
  }
  if (HEAPU16[$0 + 16 >> 1]) {
   $6 = 1;
   while (1) {
    if (!HEAPU8[$1 | 0]) {
     break label$1;
    }
    $4 = findNextHostParameter($1, $2 + 152 | 0);
    sqlite3_str_append($2 + 128 | 0, $1, $4);
    $3 = HEAP32[$2 + 152 >> 2];
    if (!$3) {
     break label$1;
    }
    $1 = $1 + $4 | 0;
    label$8: {
     if (HEAPU8[$1 | 0] == 63) {
      if (($3 | 0) >= 2) {
       sqlite3GetInt32($1 + 1 | 0, $2 + 156 | 0);
       $4 = HEAP32[$2 + 156 >> 2];
       break label$8;
      }
      HEAP32[$2 + 156 >> 2] = $6;
      $4 = $6;
      break label$8;
     }
     $4 = sqlite3VdbeParameterIndex($0, $1, $3);
     HEAP32[$2 + 156 >> 2] = $4;
    }
    $5 = $4 + 1 | 0;
    $6 = ($6 | 0) < ($5 | 0) ? $5 : $6;
    $1 = $1 + $3 | 0;
    $4 = HEAP32[$0 + 100 >> 2] + Math_imul($4 - 1 | 0, 40) | 0;
    $3 = HEAPU16[$4 + 16 >> 1];
    if ($3 & 1) {
     sqlite3_str_append($2 + 128 | 0, 19646, 4);
     continue;
    }
    if ($3 & 36) {
     $7 = HEAP32[$4 + 4 >> 2];
     $5 = HEAP32[$4 >> 2];
     HEAP32[$2 + 80 >> 2] = $5;
     HEAP32[$2 + 84 >> 2] = $7;
     sqlite3_str_appendf($2 + 128 | 0, 14325, $2 + 80 | 0);
     continue;
    }
    if ($3 & 8) {
     HEAPF64[$2 + 64 >> 3] = HEAPF64[$4 >> 3];
     sqlite3_str_appendf($2 + 128 | 0, 12016, $2 - -64 | 0);
     continue;
    }
    if ($3 & 2) {
     $3 = HEAPU8[$8 + 84 | 0];
     if (($3 | 0) != 1) {
      memset($2 + 88 | 0, 0, 40);
      HEAP32[$2 + 108 >> 2] = $8;
      $7 = HEAP32[$4 + 12 >> 2];
      $5 = $7 >> 31;
      sqlite3VdbeMemSetStr($2 + 88 | 0, HEAP32[$4 + 8 >> 2], $7, $5, $3, 0);
      if ((sqlite3VdbeChangeEncoding($2 + 88 | 0, 1) | 0) == 7) {
       HEAP32[$2 + 136 >> 2] = 0;
       HEAP8[$2 + 148 | 0] = 7;
      }
      $5 = HEAP32[$2 + 96 >> 2];
      $7 = HEAP32[$2 + 100 >> 2];
      $5 = __wasm_rotl_i64($5, $7, 32, 0);
      HEAP32[$2 + 48 >> 2] = $5;
      $7 = i64toi32_i32$HIGH_BITS;
      HEAP32[$2 + 52 >> 2] = $7;
      sqlite3_str_appendf($2 + 128 | 0, 27455, $2 + 48 | 0);
      sqlite3VdbeMemRelease($2 + 88 | 0);
      continue;
     }
     $7 = HEAP32[$4 + 8 >> 2];
     $5 = HEAP32[$4 + 12 >> 2];
     $7 = __wasm_rotl_i64($7, $5, 32, 0);
     HEAP32[$2 + 32 >> 2] = $7;
     $5 = i64toi32_i32$HIGH_BITS;
     HEAP32[$2 + 36 >> 2] = $5;
     sqlite3_str_appendf($2 + 128 | 0, 27455, $2 + 32 | 0);
     continue;
    }
    if ($3 & 1024) {
     HEAP32[$2 + 16 >> 2] = HEAP32[$4 >> 2];
     sqlite3_str_appendf($2 + 128 | 0, 24922, $2 + 16 | 0);
    } else {
     sqlite3_str_append($2 + 128 | 0, 27071, 2);
     $3 = 0;
     $5 = HEAP32[$4 + 12 >> 2];
     $5 = ($5 | 0) > 0 ? $5 : 0;
     while (1) {
      if (($3 | 0) != ($5 | 0)) {
       HEAP32[$2 >> 2] = HEAPU8[HEAP32[$4 + 8 >> 2] + $3 | 0];
       sqlite3_str_appendf($2 + 128 | 0, 1574, $2);
       $3 = $3 + 1 | 0;
       continue;
      }
      break;
     }
     sqlite3_str_append($2 + 128 | 0, 28287, 1);
    }
    continue;
   }
  }
  sqlite3_str_append($2 + 128 | 0, $1, sqlite3Strlen30($1));
 }
 if (HEAPU8[$2 + 148 | 0]) {
  sqlite3_str_reset($2 + 128 | 0);
 }
 $6 = sqlite3StrAccumFinish($2 + 128 | 0);
 __stack_pointer = $2 + 160 | 0;
 return $6;
}

function fts3IntegrityCheck($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 40 >> 2] = 0;
 $3 = fts3SqlStmt($0, 27, $2 + 40 | 0, 0);
 HEAP32[$2 + 44 >> 2] = $3;
 label$1: {
  if ($3) {
   break label$1;
  }
  $6 = HEAP32[$2 + 40 >> 2];
  sqlite3_bind_int($6, 1, HEAP32[$0 + 280 >> 2]);
  sqlite3_bind_int($6, 2, HEAP32[$0 + 256 >> 2]);
  while (1) {
   label$3: {
    label$4: {
     if ($4) {
      break label$4;
     }
     if ((sqlite3_step($6) | 0) != 100) {
      break label$4;
     }
     $3 = 0;
     $4 = sqlite3_column_int($6, 0);
     while (1) {
      if (HEAP32[$0 + 256 >> 2] <= ($3 | 0)) {
       break label$3;
      }
      $12 = fts3ChecksumIndex($0, $4, $3, $2 + 44 | 0) ^ $12;
      $13 = i64toi32_i32$HIGH_BITS ^ $13;
      $3 = $3 + 1 | 0;
      continue;
     }
    }
    $3 = sqlite3_reset($6);
    if ($4) {
     $3 = $4;
     break label$1;
    }
    if ($3) {
     break label$1;
    }
    $14 = HEAP32[HEAP32[$0 + 36 >> 2] >> 2];
    HEAP32[$2 + 36 >> 2] = 0;
    HEAP32[$2 >> 2] = HEAP32[$0 + 224 >> 2];
    $4 = sqlite3_mprintf(6860, $2);
    label$7: {
     if (!$4) {
      $3 = 7;
      HEAP32[$2 + 44 >> 2] = 7;
      break label$7;
     }
     $3 = sqlite3_prepare_v2(HEAP32[$0 + 12 >> 2], $4, -1, $2 + 36 | 0, 0);
     HEAP32[$2 + 44 >> 2] = $3;
     sqlite3_free($4);
    }
    label$9: while (1) {
     label$10: {
      if ($3) {
       break label$10;
      }
      if ((sqlite3_step(HEAP32[$2 + 36 >> 2]) | 0) != 100) {
       break label$10;
      }
      $3 = 0;
      $15 = sqlite3_column_int64(HEAP32[$2 + 36 >> 2], 0);
      $16 = i64toi32_i32$HIGH_BITS;
      $10 = langidFromSelect($0, HEAP32[$2 + 36 >> 2]);
      $5 = 0;
      while (1) {
       if (HEAP32[$0 + 24 >> 2] <= ($5 | 0) | $3) {
        continue label$9;
       }
       if (HEAPU8[HEAP32[$0 + 32 >> 2] + $5 | 0]) {
        $5 = $5 + 1 | 0;
        $3 = 0;
        continue;
       }
       $17 = $5 + 1 | 0;
       $3 = sqlite3_column_text(HEAP32[$2 + 36 >> 2], $17);
       HEAP32[$2 + 32 >> 2] = 0;
       $7 = sqlite3Fts3OpenTokenizer(HEAP32[$0 + 36 >> 2], $10, $3, -1, $2 + 32 | 0);
       $11 = HEAP32[$2 + 32 >> 2];
       label$13: while (1) {
        if (!$7) {
         HEAP32[$2 + 24 >> 2] = 0;
         HEAP32[$2 + 20 >> 2] = 0;
         HEAP32[$2 + 16 >> 2] = 0;
         HEAP32[$2 + 12 >> 2] = 0;
         $7 = FUNCTION_TABLE[HEAP32[$14 + 20 >> 2]]($11, $2 + 28 | 0, $2 + 24 | 0, $2 + 20 | 0, $2 + 16 | 0, $2 + 12 | 0) | 0;
         if ($7) {
          continue;
         }
         $18 = HEAP32[$2 + 28 >> 2];
         $19 = HEAP32[$2 + 24 >> 2];
         $20 = HEAP32[$2 + 12 >> 2];
         $8 = fts3ChecksumEntry($18, $19, $10, 0, $15, $16, $5, $20) ^ $8;
         $9 = $9 ^ i64toi32_i32$HIGH_BITS;
         $3 = 1;
         $4 = HEAP32[$0 + 256 >> 2];
         $6 = ($4 | 0) > 1 ? $4 : 1;
         while (1) {
          if (($3 | 0) == ($6 | 0)) {
           continue label$13;
          }
          $4 = HEAP32[HEAP32[$0 + 260 >> 2] + Math_imul($3, 24) >> 2];
          if (($19 | 0) >= ($4 | 0)) {
           $8 = fts3ChecksumEntry($18, $4, $10, $3, $15, $16, $5, $20) ^ $8;
           $9 = $9 ^ i64toi32_i32$HIGH_BITS;
          }
          $3 = $3 + 1 | 0;
          continue;
         }
        }
        break;
       }
       if ($11) {
        FUNCTION_TABLE[HEAP32[$14 + 16 >> 2]]($11) | 0;
       }
       $3 = ($7 | 0) == 101 ? 0 : $7;
       $5 = $17;
       continue;
      }
     }
     break;
    }
    sqlite3_finalize(HEAP32[$2 + 36 >> 2]);
    break label$1;
   }
   $4 = HEAP32[$2 + 44 >> 2];
   continue;
  }
 }
 HEAP32[$1 >> 2] = ($8 | 0) == ($12 | 0) & ($9 | 0) == ($13 | 0);
 __stack_pointer = $2 + 48 | 0;
 return $3;
}

function vtabCallConstructor($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 80 | 0;
 __stack_pointer = $7;
 $10 = HEAP32[$1 + 44 >> 2];
 HEAP32[$7 + 60 >> 2] = 0;
 $6 = $0 + 400 | 0;
 $8 = HEAP32[$1 + 48 >> 2];
 label$1: {
  label$2: {
   while (1) {
    $5 = HEAP32[$6 >> 2];
    if (!$5) {
     break label$2;
    }
    $6 = $5 + 8 | 0;
    if (HEAP32[$5 + 4 >> 2] != ($1 | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$7 + 48 >> 2] = HEAP32[$1 >> 2];
   HEAP32[$4 >> 2] = sqlite3MPrintf($0, 7004, $7 + 48 | 0);
   $5 = 6;
   break label$1;
  }
  $5 = 7;
  $11 = sqlite3DbStrDup($0, HEAP32[$1 >> 2]);
  if (!$11) {
   break label$1;
  }
  $6 = sqlite3MallocZero(28, 0);
  label$4: {
   if (!$6) {
    sqlite3OomFault($0);
    break label$4;
   }
   HEAP8[$6 + 17 | 0] = 1;
   HEAP32[$6 + 4 >> 2] = $2;
   HEAP32[$6 >> 2] = $0;
   HEAP32[HEAP32[$1 + 48 >> 2] + 4 >> 2] = HEAP32[HEAP32[$0 + 16 >> 2] + (sqlite3SchemaToIndex($0, HEAP32[$1 + 60 >> 2]) << 4) >> 2];
   HEAP32[$7 + 64 >> 2] = $6;
   HEAP32[$7 + 68 >> 2] = $1;
   $5 = HEAP32[$0 + 400 >> 2];
   HEAP32[$7 + 76 >> 2] = 0;
   HEAP32[$7 + 72 >> 2] = $5;
   HEAP32[$0 + 400 >> 2] = $7 - -64;
   $9 = $6 + 8 | 0;
   $5 = FUNCTION_TABLE[$3 | 0]($0, HEAP32[$2 + 12 >> 2], $10, $8, $9, $7 + 60 | 0) | 0;
   HEAP32[$0 + 400 >> 2] = HEAP32[$7 + 72 >> 2];
   if ($5) {
    if (($5 | 0) == 7) {
     sqlite3OomFault($0);
    }
    $2 = HEAP32[$7 + 60 >> 2];
    label$8: {
     if (!$2) {
      HEAP32[$7 >> 2] = $11;
      HEAP32[$4 >> 2] = sqlite3MPrintf($0, 8102, $7);
      break label$8;
     }
     HEAP32[$7 + 16 >> 2] = $2;
     HEAP32[$4 >> 2] = sqlite3MPrintf($0, 8342, $7 + 16 | 0);
     sqlite3_free(HEAP32[$7 + 60 >> 2]);
    }
    sqlite3DbFree($0, $6);
    break label$4;
   }
   $5 = 0;
   $3 = HEAP32[$6 + 8 >> 2];
   if (!$3) {
    break label$4;
   }
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
   HEAP32[$3 + 8 >> 2] = 0;
   HEAP32[HEAP32[$6 + 8 >> 2] >> 2] = HEAP32[$2 >> 2];
   $5 = 1;
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + 1;
   HEAP32[$6 + 12 >> 2] = 1;
   if (!HEAP32[$7 + 76 >> 2]) {
    HEAP32[$7 + 32 >> 2] = HEAP32[$1 >> 2];
    HEAP32[$4 >> 2] = sqlite3MPrintf($0, 8230, $7 + 32 | 0);
    sqlite3VtabUnlock($6);
    break label$4;
   }
   $5 = $1 + 52 | 0;
   HEAP32[$6 + 24 >> 2] = HEAP32[$5 >> 2];
   HEAP32[$1 + 52 >> 2] = $6;
   $9 = 0;
   $8 = 0;
   while (1) {
    if (($9 | 0) < HEAP16[$1 + 34 >> 1]) {
     $5 = 0;
     $12 = Math_imul($9, 12);
     $6 = sqlite3ColumnType($12 + HEAP32[$1 + 4 >> 2] | 0, 29623);
     $10 = sqlite3Strlen30($6);
     $4 = ($10 | 0) > 0 ? $10 : 0;
     label$14: {
      label$15: {
       while (1) {
        if (($4 | 0) == ($5 | 0)) {
         break label$15;
        }
        label$17: {
         $2 = $5 + $6 | 0;
         if (!(sqlite3_strnicmp(10820, $2, 6) | (HEAPU8[$2 - 1 | 0] != 32 ? $5 : 0))) {
          $3 = HEAPU8[$2 + 6 | 0];
          if (($3 | 32) == 32) {
           break label$17;
          }
         }
         $5 = $5 + 1 | 0;
         continue;
        }
        break;
       }
       $8 = $3 ? 7 : 6;
       $4 = $5;
       while (1) {
        $3 = $4 + $8 | 0;
        if (($3 | 0) <= ($10 | 0)) {
         HEAP8[$4 + $6 | 0] = HEAPU8[$3 + $6 | 0];
         $4 = $4 + 1 | 0;
         continue;
        }
        break;
       }
       if (!(HEAPU8[$2 | 0] | !$5)) {
        HEAP8[$2 - 1 | 0] = 0;
       }
       $6 = HEAP32[$1 + 4 >> 2] + $12 | 0;
       HEAP16[$6 + 10 >> 1] = HEAPU16[$6 + 10 >> 1] | 2;
       $8 = 1024;
       $5 = 2;
       break label$14;
      }
      $5 = $8 & 65535;
     }
     HEAP32[$1 + 28 >> 2] = $5 | HEAP32[$1 + 28 >> 2];
     $9 = $9 + 1 | 0;
     continue;
    }
    break;
   }
   $5 = 0;
  }
  sqlite3DbFree($0, $11);
 }
 __stack_pointer = $7 + 80 | 0;
 return $5;
}

function sqlite3CodeRhsOfIN($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$0 + 8 >> 2];
 $3 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if (!(HEAP32[$0 + 52 >> 2] | $3 & 64)) {
   if ($3 & 33554432) {
    $3 = sqlite3VdbeAddOp0($6, 14);
    if (HEAPU8[$1 + 5 | 0] & 16) {
     HEAP32[$5 + 16 >> 2] = HEAP32[HEAP32[$1 + 20 >> 2] + 16 >> 2];
     sqlite3VdbeExplain($0, 0, 16840, $5 + 16 | 0);
    }
    sqlite3VdbeAddOp2($6, 9, HEAP32[$1 + 48 >> 2], HEAP32[$1 + 44 >> 2]);
    sqlite3VdbeAddOp2($6, 115, $2, HEAP32[$1 + 28 >> 2]);
    sqlite3VdbeJumpHere($6, $3);
    break label$1;
   }
   HEAP32[$1 + 4 >> 2] = $3 | 33554432;
   $3 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $3;
   HEAP32[$1 + 48 >> 2] = $3;
   HEAP32[$1 + 44 >> 2] = sqlite3VdbeAddOp2($6, 74, 0, $3) + 1;
   $8 = sqlite3VdbeAddOp0($6, 14);
  }
  $9 = HEAP32[$1 + 12 >> 2];
  $7 = sqlite3ExprVectorSize($9);
  HEAP32[$1 + 28 >> 2] = $2;
  $12 = sqlite3VdbeAddOp2($6, 118, $2, $7);
  $10 = sqlite3KeyInfoAlloc(HEAP32[$0 >> 2], $7, 1);
  $4 = HEAP32[$1 + 20 >> 2];
  label$5: {
   if (HEAPU8[$1 + 5 | 0] & 16) {
    $11 = HEAP32[$4 + 28 >> 2];
    HEAP32[$5 + 4 >> 2] = HEAP32[$4 + 16 >> 2];
    HEAP32[$5 >> 2] = $8 ? 29623 : 29474;
    sqlite3VdbeExplain($0, 1, 16821, $5);
    if (HEAP32[$11 >> 2] != ($7 | 0)) {
     break label$5;
    }
    sqlite3SelectDestInit($5 + 32 | 0, 11, $2);
    HEAP32[$5 + 52 >> 2] = exprINAffinity($0, $1);
    HEAP32[$4 + 8 >> 2] = 0;
    $3 = sqlite3SelectDup(HEAP32[$0 >> 2], $4, 0);
    $4 = HEAP32[$0 >> 2];
    label$7: {
     if (!HEAPU8[$4 + 87 | 0]) {
      $4 = sqlite3Select($0, $3, $5 + 32 | 0);
      sqlite3SelectDelete(HEAP32[$0 >> 2], $3);
      sqlite3DbFree(HEAP32[$0 >> 2], HEAP32[$5 + 52 >> 2]);
      if ($4) {
       break label$7;
      }
      $3 = 0;
      $4 = ($7 | 0) > 0 ? $7 : 0;
      while (1) {
       if (($3 | 0) == ($4 | 0)) {
        break label$5;
       }
       HEAP32[(($3 << 2) + $10 | 0) + 20 >> 2] = sqlite3BinaryCompareCollSeq($0, sqlite3VectorFieldSubexpr($9, $3), HEAP32[(($3 << 4) + $11 | 0) + 8 >> 2]);
       $3 = $3 + 1 | 0;
       continue;
      }
     }
     sqlite3SelectDelete($4, $3);
     sqlite3DbFree(HEAP32[$0 >> 2], HEAP32[$5 + 52 >> 2]);
    }
    sqlite3KeyInfoUnref($10);
    break label$1;
   }
   if (!$4) {
    break label$5;
   }
   $3 = sqlite3ExprAffinity($9);
   HEAP8[$5 + 32 | 0] = $3;
   label$10: {
    if (($3 | 0) <= 64) {
     HEAP8[$5 + 32 | 0] = 65;
     break label$10;
    }
    if (($3 | 0) != 69) {
     break label$10;
    }
    HEAP8[$5 + 32 | 0] = 67;
   }
   if ($10) {
    HEAP32[$10 + 20 >> 2] = sqlite3ExprCollSeq($0, HEAP32[$1 + 12 >> 2]);
   }
   $7 = $4 + 8 | 0;
   $3 = sqlite3GetTempReg($0);
   $11 = sqlite3GetTempReg($0);
   $4 = HEAP32[$4 >> 2];
   while (1) {
    if (($4 | 0) > 0) {
     $9 = HEAP32[$7 >> 2];
     label$15: {
      if ($8) {
       if (sqlite3ExprIsConstant($9)) {
        break label$15;
       }
       sqlite3VdbeChangeToNoop($6, $8 - 1 | 0);
       sqlite3VdbeChangeToNoop($6, $8);
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -33554433;
      }
      $8 = 0;
     }
     sqlite3ExprCode($0, $9, $3);
     sqlite3VdbeAddOp4($6, 97, $3, 1, $11, $5 + 32 | 0, 1);
     sqlite3VdbeAddOp4Int($6, 138, $2, $11, $3, 1);
     $7 = $7 + 16 | 0;
     $4 = $4 - 1 | 0;
     continue;
    }
    break;
   }
   sqlite3ReleaseTempReg($0, $3);
   sqlite3ReleaseTempReg($0, $11);
  }
  if ($10) {
   sqlite3VdbeChangeP4($6, $12, $10, -8);
  }
  if (!$8) {
   break label$1;
  }
  sqlite3VdbeJumpHere($6, $8);
  sqlite3VdbeAddOp3($6, 67, HEAP32[$1 + 48 >> 2], HEAP32[$1 + 44 >> 2], 1);
  sqlite3ClearTempRegCache($0);
 }
 __stack_pointer = $5 - -64 | 0;
}

function unixShmMap($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $11 = __stack_pointer - 128 | 0;
 __stack_pointer = $11;
 $13 = unixShmRegionPerMap();
 $5 = HEAP32[$0 + 36 >> 2];
 label$1: {
  if (!$5) {
   $5 = unixOpenSharedMemory($0);
   if ($5) {
    break label$1;
   }
   $5 = HEAP32[$0 + 36 >> 2];
  }
  $5 = HEAP32[$5 >> 2];
  label$3: {
   if (HEAPU8[$5 + 23 | 0]) {
    $10 = unixLockSharedMemory($0, $5);
    if ($10) {
     break label$3;
    }
    HEAP8[$5 + 23 | 0] = 0;
   }
   $10 = 0;
   $0 = $1 + $13 | 0;
   $14 = $0 - (($0 | 0) % ($13 | 0) | 0) | 0;
   if (($14 | 0) <= HEAPU16[$5 + 20 >> 1]) {
    break label$3;
   }
   HEAP32[$5 + 16 >> 2] = $2;
   label$5: {
    label$6: {
     $0 = HEAP32[$5 + 12 >> 2];
     if (($0 | 0) < 0) {
      break label$6;
     }
     $10 = 4874;
     if (FUNCTION_TABLE[HEAP32[16252]]($0, $11 + 16 | 0) | 0) {
      break label$3;
     }
     $8 = HEAP32[$11 + 56 >> 2];
     $7 = $8;
     $6 = HEAP32[$11 + 60 >> 2];
     $9 = $6;
     $0 = Math_imul($2, $14);
     $6 = $0 >> 31;
     $8 = $6;
     $6 = $9;
     if (($8 | 0) <= ($6 | 0) & $7 >>> 0 >= $0 >>> 0 | ($8 | 0) < ($6 | 0)) {
      break label$6;
     }
     if (!$3) {
      $10 = 0;
      break label$3;
     }
     $6 = __wasm_i64_sdiv($7, $9, 4096, 0);
     $7 = $6;
     $3 = i64toi32_i32$HIGH_BITS;
     $0 = ($0 | 0) / 4096 | 0;
     $6 = ($0 | 0) > ($6 | 0) ? $0 : $6;
     $3 = $6 >> 31;
     $12 = $6;
     $15 = $3;
     $6 = $7;
     $7 = $6;
     $0 = $6 >> 31;
     $9 = $0;
     while (1) {
      $8 = $12;
      $6 = $7;
      $3 = $15;
      if (($8 | 0) == ($6 | 0) & ($3 | 0) == ($9 | 0)) {
       break label$6;
      }
      $0 = $7 << 12 | 4095;
      $6 = $0 >> 31;
      if ((seekAndWriteFd(HEAP32[$5 + 12 >> 2], $0, $6, 29623, 1, $11 + 12 | 0) | 0) != 1) {
       break label$5;
      }
      $6 = $9;
      $7 = $7 + 1 | 0;
      $9 = $7 ? $6 : $6 + 1 | 0;
      continue;
     }
    }
    $0 = sqlite3_realloc(HEAP32[$5 + 24 >> 2], $14 << 2);
    if (!$0) {
     $10 = 3082;
     break label$3;
    }
    HEAP32[$5 + 24 >> 2] = $0;
    $10 = 0;
    $16 = ($13 | 0) > 0 ? $13 : 0;
    $12 = Math_imul($2, $13);
    $8 = $12;
    $9 = $8 >> 31;
    $12 = $8;
    $15 = $9;
    $0 = HEAPU16[$5 + 20 >> 1];
    $7 = $2;
    $9 = $7 >> 31;
    while (1) {
     if (($0 & 65535) >= ($14 | 0)) {
      break label$3;
     }
     $3 = HEAP32[$5 + 12 >> 2];
     label$11: {
      if (($3 | 0) >= 0) {
       $17 = HEAPU8[$5 + 22 | 0] ? 1 : 3;
       $6 = $9;
       $6 = __wasm_i64_mul($0 & 65535, 0, $7, $6);
       $8 = i64toi32_i32$HIGH_BITS;
       $3 = FUNCTION_TABLE[HEAP32[16303]](0, $12, $17, 1, $3, $6, $8) | 0;
       if (($3 | 0) != -1) {
        break label$11;
       }
       $10 = 5386;
       unixLogErrorAtLine(5386, 9463, HEAP32[$5 + 8 >> 2], 40311);
       break label$3;
      }
      $8 = $15;
      $3 = sqlite3_malloc64($12, $8);
      if (!$3) {
       $10 = 7;
       break label$3;
      }
      memset($3, 0, $12);
     }
     $0 = 0;
     while (1) {
      if (($0 | 0) != ($16 | 0)) {
       HEAP32[HEAP32[$5 + 24 >> 2] + (HEAPU16[$5 + 20 >> 1] + $0 << 2) >> 2] = Math_imul($0, $2) + $3;
       $0 = $0 + 1 | 0;
       continue;
      }
      break;
     }
     $0 = HEAPU16[$5 + 20 >> 1] + $13 | 0;
     HEAP16[$5 + 20 >> 1] = $0;
     continue;
    }
   }
   unixLogErrorAtLine(4874, 12436, HEAP32[$5 + 8 >> 2], 40284);
  }
  $0 = 0;
  $0 = HEAPU16[$5 + 20 >> 1] > ($1 | 0) ? HEAP32[HEAP32[$5 + 24 >> 2] + ($1 << 2) >> 2] : $0;
  HEAP32[$4 >> 2] = $0;
  $5 = HEAPU8[$5 + 22 | 0] ? $10 ? $10 : 8 : $10;
 }
 __stack_pointer = $11 + 128 | 0;
 return $5 | 0;
}

function sqlite3UpsertAnalyzeTarget($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $3 = __stack_pointer - 192 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 176 >> 2] = 0;
 HEAP32[$3 + 180 >> 2] = 0;
 HEAP32[$3 + 184 >> 2] = 0;
 HEAP32[$3 + 188 >> 2] = 0;
 HEAP32[$3 + 168 >> 2] = 0;
 HEAP32[$3 + 172 >> 2] = 0;
 HEAP32[$3 + 164 >> 2] = $1;
 HEAP32[$3 + 160 >> 2] = $0;
 $14 = $3 + 100 | 0;
 label$1: {
  while (1) {
   label$3: {
    if (!$2) {
     break label$3;
    }
    $4 = HEAP32[$2 >> 2];
    if (!$4) {
     break label$3;
    }
    $9 = sqlite3ResolveExprListNames($3 + 160 | 0, $4);
    if ($9) {
     break label$1;
    }
    $9 = 1;
    if (sqlite3ResolveExprNames($3 + 160 | 0, HEAP32[$2 + 4 >> 2])) {
     break label$1;
    }
    $12 = HEAP32[$1 + 48 >> 2];
    label$4: {
     $4 = HEAP32[$1 + 24 >> 2];
     $10 = HEAP32[$2 >> 2];
     label$5: {
      if (HEAPU8[$4 + 28 | 0] & 128 | HEAP32[$10 >> 2] != 1) {
       break label$5;
      }
      $6 = HEAP32[$10 + 8 >> 2];
      if (HEAPU8[$6 | 0] != 167) {
       break label$5;
      }
      if (HEAPU16[$6 + 32 >> 1] == 65535) {
       break label$4;
      }
     }
     memset($3 + 48 | 0, 0, 104);
     HEAP32[$3 + 128 >> 2] = $12;
     HEAP8[$3 + 100 | 0] = 167;
     HEAP32[$3 + 60 >> 2] = $14;
     HEAP8[$3 + 48 | 0] = 113;
     $4 = $4 + 8 | 0;
     label$6: {
      while (1) {
       $5 = HEAP32[$4 >> 2];
       if ($5) {
        label$9: {
         if (!HEAPU8[$5 + 54 | 0]) {
          break label$9;
         }
         $11 = HEAPU16[$5 + 50 >> 1];
         if (($11 | 0) != HEAP32[$10 >> 2]) {
          break label$9;
         }
         $4 = HEAP32[$5 + 36 >> 2];
         if ($4) {
          $6 = HEAP32[$2 + 4 >> 2];
          if (!$6) {
           break label$9;
          }
          if (sqlite3ExprCompare($0, $6, $4, $12)) {
           break label$9;
          }
          $11 = HEAPU16[$5 + 50 >> 1];
         }
         $7 = 0;
         while (1) {
          if (($7 | 0) != ($11 | 0)) {
           HEAP32[$3 + 56 >> 2] = HEAP32[HEAP32[$5 + 32 >> 2] + ($7 << 2) >> 2];
           $4 = HEAPU16[HEAP32[$5 + 4 >> 2] + ($7 << 1) >> 1];
           label$13: {
            if (($4 | 0) == 65534) {
             $8 = HEAP32[(HEAP32[$5 + 40 >> 2] + ($7 << 4) | 0) + 8 >> 2];
             if (HEAPU8[$8 | 0] == 113) {
              break label$13;
             }
             HEAP32[$3 + 60 >> 2] = $8;
             $8 = $3 + 48 | 0;
             break label$13;
            }
            HEAP16[$3 + 132 >> 1] = $4;
            HEAP32[$3 + 60 >> 2] = $14;
            $8 = $3 + 48 | 0;
           }
           $4 = 0;
           while (1) {
            if (($4 | 0) == ($11 | 0)) {
             break label$9;
            }
            $6 = $4 << 4;
            $4 = $4 + 1 | 0;
            if ((sqlite3ExprCompare($0, HEAP32[($6 + $10 | 0) + 8 >> 2], $8, $12) | 0) > 1) {
             continue;
            }
            break;
           }
           $7 = $7 + 1 | 0;
           continue;
          }
          break;
         }
         HEAP32[$2 + 28 >> 2] = $5;
         break label$6;
        }
        $4 = $5 + 20 | 0;
        continue;
       }
       break;
      }
      $5 = HEAP32[$2 + 28 >> 2];
     }
     if ($5) {
      break label$4;
     }
     label$16: {
      if (!(HEAP32[$2 + 16 >> 2] | $13)) {
       HEAP8[$3 + 32 | 0] = 0;
       break label$16;
      }
      HEAP32[$3 + 16 >> 2] = $13 + 1;
      sqlite3_snprintf(16, $3 + 32 | 0, 29039, $3 + 16 | 0);
     }
     HEAP32[$3 >> 2] = $3 + 32;
     sqlite3ErrorMsg($0, 2505, $3);
     break label$1;
    }
    $13 = $13 + 1 | 0;
    $2 = HEAP32[$2 + 16 >> 2];
    continue;
   }
   break;
  }
  $9 = 0;
 }
 __stack_pointer = $3 + 192 | 0;
 return $9;
}

function openDatabase($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 8 >> 2] = 0;
 HEAP32[$6 + 4 >> 2] = 0;
 HEAP32[$1 >> 2] = 0;
 $4 = sqlite3_initialize();
 if (!$4) {
  label$2: {
   if (!HEAPU8[64276] | $2 & 32768) {
    break label$2;
   }
   $5 = 1;
   if ($2 & 65536) {
    break label$2;
   }
   $5 = HEAPU8[64277];
  }
  $4 = $2 & 262144 ? $2 & -131073 : HEAP32[16118] ? $2 | 131072 : $2;
  $8 = $4 & -655129;
  HEAP32[$6 + 12 >> 2] = $8;
  $2 = sqlite3MallocZero(536, 0);
  label$5: {
   if (!$2) {
    break label$5;
   }
   if ($5) {
    HEAP32[$2 + 12 >> 2] = 8;
   }
   HEAP8[$2 + 97 | 0] = 109;
   HEAP32[$2 + 20 >> 2] = 2;
   HEAP32[$2 + 304 >> 2] = 1;
   HEAP16[$2 + 308 >> 1] = 0;
   HEAP32[$2 + 16 >> 2] = $2 + 456;
   HEAP32[$2 + 72 >> 2] = $4 & 33554432 ? -1 : 255;
   __memcpy($2 + 120 | 0, 31824, 48);
   HEAP8[$2 + 90 | 0] = 255;
   HEAP8[$2 + 85 | 0] = 1;
   HEAP32[$2 + 164 >> 2] = 0;
   $7 = HEAP32[16111];
   $5 = HEAP32[16110];
   HEAP32[$2 + 180 >> 2] = 65328;
   HEAP32[$2 + 100 >> 2] = 0;
   HEAP32[$2 + 48 >> 2] = $5;
   HEAP32[$2 + 52 >> 2] = $7;
   $7 = HEAP32[$2 + 32 >> 2];
   $5 = $7;
   $7 = HEAP32[$2 + 36 >> 2];
   $5 = $5 | -536575776;
   HEAP32[$2 + 32 >> 2] = $5;
   HEAP32[$2 + 36 >> 2] = $7;
   sqlite3HashInit($2 + 428 | 0);
   sqlite3HashInit($2 + 384 | 0);
   createCollation($2, 32384, 1, 0, 10, 0);
   createCollation($2, 32384, 3, 0, 10, 0);
   createCollation($2, 32384, 2, 0, 10, 0);
   createCollation($2, 19761, 1, 0, 11, 0);
   createCollation($2, 19509, 1, 0, 12, 0);
   if (HEAPU8[$2 + 87 | 0]) {
    break label$5;
   }
   HEAP32[$2 + 60 >> 2] = $8;
   label$7: {
    if (!(1 << ($4 & 7) & 70)) {
     $4 = sqlite3MisuseError(174042);
     break label$7;
    }
    $4 = sqlite3ParseUri($3, $0, $6 + 12 | 0, $2, $6 + 8 | 0, $6 + 4 | 0);
   }
   if ($4) {
    if (($4 | 0) == 7) {
     sqlite3OomFault($2);
    }
    $5 = HEAP32[$6 + 4 >> 2];
    HEAP32[$6 >> 2] = $5;
    sqlite3ErrorWithMsg($2, $4, $5 ? 8342 : 0, $6);
    sqlite3_free($5);
    break label$5;
   }
   $4 = sqlite3BtreeOpen(HEAP32[$2 >> 2], HEAP32[$6 + 8 >> 2], $2, HEAP32[$2 + 16 >> 2] + 4 | 0, 0, HEAP32[$6 + 12 >> 2] | 256);
   if ($4) {
    sqlite3Error($2, ($4 | 0) == 3082 ? 7 : $4);
    break label$5;
   }
   sqlite3BtreeEnter(HEAP32[HEAP32[$2 + 16 >> 2] + 4 >> 2]);
   $4 = sqlite3SchemaGet($2, HEAP32[HEAP32[$2 + 16 >> 2] + 4 >> 2]);
   HEAP32[HEAP32[$2 + 16 >> 2] + 12 >> 2] = $4;
   if (!HEAPU8[$2 + 87 | 0]) {
    sqlite3SetTextEncoding($2, HEAPU8[$4 + 77 | 0]);
   }
   $4 = 0;
   $3 = sqlite3SchemaGet($2, 0);
   $5 = HEAP32[$2 + 16 >> 2];
   HEAP32[$5 + 16 >> 2] = 9403;
   HEAP8[$5 + 8 | 0] = 3;
   HEAP32[$5 >> 2] = 10765;
   HEAP8[$5 + 24 | 0] = 1;
   HEAP32[$5 + 28 >> 2] = $3;
   HEAP8[$2 + 97 | 0] = 118;
   if (HEAPU8[$2 + 87 | 0]) {
    break label$5;
   }
   sqlite3Error($2, 0);
   sqlite3RegisterPerConnectionBuiltinFunctions($2);
   $5 = sqlite3_errcode($2);
   while (1) {
    if (!($4 >>> 0 > 2 | $5)) {
     $5 = FUNCTION_TABLE[HEAP32[($4 << 2) + 51396 >> 2]]($2) | 0;
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   label$15: {
    if (!$5) {
     sqlite3AutoLoadExtensions($2);
     if (!sqlite3_errcode($2)) {
      break label$15;
     }
     break label$5;
    }
    sqlite3Error($2, $5);
   }
   setupLookaside($2, 0, HEAP32[16073], HEAP32[16074]);
   sqlite3_wal_autocheckpoint($2, 1e3);
  }
  $4 = sqlite3_errcode($2);
  label$17: {
   if (($4 & 255) == 7) {
    sqlite3_close($2);
    $2 = 0;
    break label$17;
   }
   if (!$4) {
    break label$17;
   }
   HEAP8[$2 + 97 | 0] = 186;
  }
  HEAP32[$1 >> 2] = $2;
  sqlite3_free_filename(HEAP32[$6 + 8 >> 2]);
 }
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function isLikeOrGlob($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  label$2: {
   $12 = HEAP32[$0 >> 2];
   if (!sqlite3IsLikeFunction($12, $1, $4, $6 + 12 | 0)) {
    break label$2;
   }
   $1 = HEAP32[$1 + 20 >> 2];
   $13 = HEAP32[$1 + 24 >> 2];
   $9 = sqlite3ExprSkipCollate(HEAP32[$1 + 8 >> 2]);
   $14 = HEAPU8[$9 | 0];
   label$3: {
    label$4: {
     if (($14 | 0) == 156) {
      if (HEAPU8[$12 + 34 | 0] & 128) {
       break label$3;
      }
      $1 = HEAP16[$9 + 32 >> 1];
      $11 = sqlite3VdbeGetBoundValue(HEAP32[$0 + 228 >> 2], $1);
      label$6: {
       if (!$11) {
        break label$6;
       }
       if ((sqlite3_value_type($11) | 0) != 3) {
        break label$6;
       }
       $8 = sqlite3_value_text($11);
      }
      sqlite3VdbeSetVarmask(HEAP32[$0 + 8 >> 2], $1);
      break label$4;
     }
     if (($14 | 0) != 117) {
      break label$3;
     }
     $8 = HEAP32[$9 + 8 >> 2];
    }
    label$7: {
     if (!$8) {
      break label$7;
     }
     $4 = 0;
     $15 = HEAPU8[$6 + 15 | 0];
     $16 = HEAPU8[$6 + 12 | 0];
     $5 = $16;
     $10 = HEAPU8[$6 + 13 | 0];
     $17 = HEAPU8[$6 + 14 | 0];
     while (1) {
      $7 = $4;
      $4 = $4 + $8 | 0;
      $1 = HEAPU8[$4 | 0];
      if (!(!$1 | ($1 | 0) == ($5 | 0) | (($1 | 0) == ($10 | 0) | ($1 | 0) == ($17 | 0)))) {
       $4 = $7 + 1 | 0;
       if (($1 | 0) != ($15 | 0)) {
        continue;
       }
       $4 = HEAPU8[$4 + $8 | 0] ? $7 + 2 | 0 : $4;
       continue;
      }
      break;
     }
     if (HEAPU8[$8 | 0] == ($15 | 0) & ($7 | 0) <= 1 | (!$7 | HEAPU8[$4 - 1 | 0] == 255)) {
      break label$7;
     }
     $5 = 0;
     $5 = ($1 | 0) == ($16 | 0) ? !HEAPU8[$4 + 1 | 0] : $5;
     HEAP32[$3 >> 2] = $5;
     label$12: {
      $10 = sqlite3Expr($12, 117, $8);
      if (!$10) {
       break label$12;
      }
      $1 = 0;
      $5 = HEAP32[$10 + 8 >> 2];
      HEAP8[$7 + $5 | 0] = 0;
      $4 = 0;
      while (1) {
       if (($1 | 0) < ($7 | 0)) {
        $1 = (HEAP8[$1 + $5 | 0] == ($15 | 0)) + $1 | 0;
        HEAP8[$4 + $5 | 0] = HEAPU8[$5 + $1 | 0];
        $4 = $4 + 1 | 0;
        $1 = $1 + 1 | 0;
        continue;
       }
       break;
      }
      $1 = $4 + $5 | 0;
      HEAP8[$1 | 0] = 0;
      label$15: {
       if (HEAPU8[$13 | 0] != 167) {
        break label$15;
       }
       if ((sqlite3ExprAffinity($13) | 0) != 66) {
        break label$15;
       }
       if (HEAPU8[$13 + 7 | 0] & 3) {
        break label$12;
       }
       $7 = HEAP32[$13 + 44 >> 2];
       if (!$7 | HEAPU8[$7 + 43 | 0] != 1) {
        break label$12;
       }
      }
      if (!((sqlite3AtoF($5, $6, $4, 1) | 0) > 0 | ($4 | 0) == 1 & HEAPU8[$5 | 0] == 45)) {
       $1 = $1 - 1 | 0;
       HEAP8[$1 | 0] = HEAPU8[$1 | 0] + 1;
       $4 = sqlite3AtoF($5, $6, $4, 1);
       HEAP8[$1 | 0] = HEAPU8[$1 | 0] - 1;
       if (($4 | 0) <= 0) {
        break label$12;
       }
      }
      sqlite3ExprDelete($12, $10);
      sqlite3ValueFree($11);
      break label$2;
     }
     HEAP32[$2 >> 2] = $10;
     if (($14 | 0) != 156) {
      break label$3;
     }
     $1 = HEAP32[$0 + 8 >> 2];
     sqlite3VdbeSetVarmask($1, HEAP16[$9 + 32 >> 1]);
     if (!HEAP32[$3 >> 2] | !HEAPU8[HEAP32[$9 + 8 >> 2] + 1 | 0]) {
      break label$3;
     }
     $4 = sqlite3GetTempReg($0);
     sqlite3ExprCodeTarget($0, $9, $4);
     sqlite3VdbeChangeP3($1, sqlite3VdbeCurrentAddr($1) - 1 | 0, 0);
     sqlite3ReleaseTempReg($0, $4);
     break label$3;
    }
    $8 = 0;
   }
   sqlite3ValueFree($11);
   $1 = ($8 | 0) != 0;
   break label$1;
  }
  $1 = 0;
 }
 __stack_pointer = $6 + 16 | 0;
 return $1;
}

function sqlite3_exec($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 8 >> 2] = 0;
 label$1: {
  if (!sqlite3SafetyCheckOk($0)) {
   $1 = sqlite3MisuseError(129429);
   break label$1;
  }
  sqlite3Error($0, 0);
  $1 = $1 ? $1 : 29623;
  label$3: {
   while (1) {
    label$5: {
     if ($6) {
      break label$5;
     }
     if (!HEAPU8[$1 | 0]) {
      $6 = 0;
      break label$5;
     }
     HEAP32[$5 + 8 >> 2] = 0;
     $6 = sqlite3_prepare_v2($0, $1, -1, $5 + 8 | 0, $5 + 12 | 0);
     if ($6) {
      continue;
     }
     $7 = 0;
     $1 = 0;
     $8 = 0;
     $10 = 0;
     if (!HEAP32[$5 + 8 >> 2]) {
      $6 = 0;
      $1 = HEAP32[$5 + 12 >> 2];
      continue;
     }
     while (1) {
      label$9: {
       $6 = sqlite3_step(HEAP32[$5 + 8 >> 2]);
       label$10: {
        if (!$2) {
         break label$10;
        }
        label$11: {
         label$12: {
          label$13: {
           if (($6 | 0) != 100) {
            if (!(HEAP8[$0 + 33 | 0] & 1) | (($6 | 0) != 101 | $1)) {
             break label$9;
            }
            break label$13;
           }
           if (!$1) {
            break label$13;
           }
           $9 = ($8 | 0) > 0 ? $8 : 0;
           break label$12;
          }
          $8 = sqlite3_column_count(HEAP32[$5 + 8 >> 2]);
          $7 = sqlite3DbMallocRaw($0, $8 << 3 | 4, 0);
          if (!$7) {
           break label$5;
          }
          $1 = 0;
          $9 = ($8 | 0) > 0 ? $8 : 0;
          while (1) {
           if (($1 | 0) != ($9 | 0)) {
            HEAP32[($1 << 2) + $7 >> 2] = sqlite3_column_name(HEAP32[$5 + 8 >> 2], $1);
            $1 = $1 + 1 | 0;
            continue;
           }
           break;
          }
          if (($6 | 0) != 100) {
           break label$11;
          }
         }
         $10 = ($8 << 2) + $7 | 0;
         $1 = 0;
         while (1) {
          if (($1 | 0) != ($9 | 0)) {
           $11 = sqlite3_column_text(HEAP32[$5 + 8 >> 2], $1);
           HEAP32[($1 << 2) + $10 >> 2] = $11;
           label$19: {
            if ($11) {
             break label$19;
            }
            if ((sqlite3_column_type(HEAP32[$5 + 8 >> 2], $1) | 0) == 5) {
             break label$19;
            }
            sqlite3OomFault($0);
            $6 = 100;
            break label$3;
           }
           $1 = $1 + 1 | 0;
           continue;
          }
          break;
         }
         HEAP32[($9 << 2) + $10 >> 2] = 0;
        }
        $1 = 1;
        if (!(FUNCTION_TABLE[$2 | 0]($3, $8, $10, $7) | 0)) {
         break label$10;
        }
        sqlite3VdbeFinalize(HEAP32[$5 + 8 >> 2]);
        HEAP32[$5 + 8 >> 2] = 0;
        $6 = 4;
        sqlite3Error($0, 4);
        break label$3;
       }
       if (($6 | 0) == 100) {
        continue;
       }
      }
      break;
     }
     $6 = sqlite3VdbeFinalize(HEAP32[$5 + 8 >> 2]);
     HEAP32[$5 + 8 >> 2] = 0;
     $9 = HEAP32[$5 + 12 >> 2];
     while (1) {
      $1 = $9;
      $9 = $1 + 1 | 0;
      if (HEAP8[HEAPU8[$1 | 0] + 30288 | 0] & 1) {
       continue;
      }
      break;
     }
     sqlite3DbFree($0, $7);
     continue;
    }
    break;
   }
   $7 = 0;
  }
  $1 = HEAP32[$5 + 8 >> 2];
  if ($1) {
   sqlite3VdbeFinalize($1);
  }
  sqlite3DbFree($0, $7);
  $1 = sqlite3ApiExit($0, $6);
  if (!(!$4 | !$1)) {
   $6 = sqlite3DbStrDup(0, sqlite3_errmsg($0));
   HEAP32[$4 >> 2] = $6;
   if ($6) {
    break label$1;
   }
   $1 = 7;
   sqlite3Error($0, 7);
   break label$1;
  }
  if (!$4) {
   break label$1;
  }
  HEAP32[$4 >> 2] = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $1 | 0;
}

function sqlite3BtreeBeginTrans($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 $7 = HEAP32[$4 >> 2];
 sqlite3BtreeEnter($0);
 label$1: {
  label$2: {
   $3 = HEAPU8[$0 + 8 | 0];
   if (($3 | 0) == 2 | !$1 & ($3 | 0) == 1) {
    break label$2;
   }
   label$3: {
    if (!(HEAPU8[HEAP32[$0 >> 2] + 35 | 0] & 2)) {
     break label$3;
    }
    if (sqlite3PagerIsreadonly($7)) {
     break label$3;
    }
    HEAP16[$4 + 24 >> 1] = HEAPU16[$4 + 24 >> 1] & 65534;
   }
   $5 = HEAPU16[$4 + 24 >> 1];
   if ($1) {
    $3 = 8;
    if ($5 & 1) {
     break label$1;
    }
   }
   label$5: {
    label$6: {
     label$7: {
      if ($1) {
       if ($5 & 128 | HEAPU8[$4 + 20 | 0] == 2) {
        break label$7;
       }
       if (($1 | 0) < 2) {
        break label$5;
       }
       $5 = $4 + 76 | 0;
       while (1) {
        $3 = HEAP32[$5 >> 2];
        if (!$3) {
         break label$5;
        }
        $5 = $3 + 12 | 0;
        $6 = HEAP32[$3 >> 2];
        if (($6 | 0) == ($0 | 0)) {
         continue;
        }
        break;
       }
       break label$6;
      }
      if (!($5 & 128)) {
       break label$5;
      }
     }
     $6 = HEAP32[$4 + 80 >> 2];
    }
    $3 = 262;
    if (HEAP32[$6 >> 2]) {
     break label$1;
    }
   }
   $3 = querySharedCacheTableLock($0, 1, 1);
   if ($3) {
    break label$1;
   }
   $3 = HEAPU16[$4 + 24 >> 1];
   HEAP16[$4 + 24 >> 1] = $3 & 65519;
   if (!HEAP32[$4 + 48 >> 2]) {
    HEAP16[$4 + 24 >> 1] = $3 | 16;
   }
   $6 = ($1 | 0) > 1;
   $5 = 0;
   while (1) {
    label$12: {
     if (!HEAP32[$4 + 12 >> 2]) {
      $5 = 0;
      $3 = lockBtree($4);
      if (!$3) {
       continue;
      }
      break label$12;
     }
     label$14: {
      label$15: {
       if (!$1) {
        $3 = $5;
        break label$15;
       }
       $3 = $5;
       if ($3) {
        break label$15;
       }
       $3 = 8;
       if (HEAP8[$4 + 24 | 0] & 1) {
        break label$12;
       }
       $3 = sqlite3PagerBegin($7, $6, sqlite3TempInMemory(HEAP32[$0 >> 2]));
       if (($3 | 0) == 517) {
        break label$14;
       }
       if ($3) {
        break label$15;
       }
       $3 = newDatabase($4);
      }
      if ($3) {
       break label$12;
      }
      label$17: {
       if (HEAPU8[$0 + 8 | 0]) {
        break label$17;
       }
       HEAP32[$4 + 44 >> 2] = HEAP32[$4 + 44 >> 2] + 1;
       if (!HEAPU8[$0 + 9 | 0]) {
        break label$17;
       }
       HEAP8[$0 + 40 | 0] = 1;
       HEAP32[$0 + 44 >> 2] = HEAP32[$4 + 76 >> 2];
       HEAP32[$4 + 76 >> 2] = $0 + 32;
      }
      $3 = $1 ? 2 : 1;
      HEAP8[$0 + 8 | 0] = $3;
      if (HEAPU8[$4 + 20 | 0] < $3 >>> 0) {
       HEAP8[$4 + 20 | 0] = $3;
      }
      if (!$1) {
       break label$2;
      }
      HEAP32[$4 + 80 >> 2] = $0;
      HEAP16[$4 + 24 >> 1] = HEAPU16[$4 + 24 >> 1] & 65471 | (($1 | 0) > 1) << 6;
      $5 = HEAP32[$4 + 12 >> 2];
      if (HEAP32[$4 + 48 >> 2] == (sqlite3Get4byte(HEAP32[$5 + 56 >> 2] + 28 | 0) | 0)) {
       break label$2;
      }
      $3 = sqlite3PagerWrite(HEAP32[$5 + 72 >> 2]);
      if ($3) {
       break label$1;
      }
      sqlite3Put4byte(HEAP32[$5 + 56 >> 2] + 28 | 0, HEAP32[$4 + 48 >> 2]);
      break label$2;
     }
     $3 = HEAPU8[$4 + 20 | 0] ? 517 : 5;
    }
    unlockBtreeIfUnused($4);
    if (HEAPU8[$4 + 20 | 0] | ($3 & 255) != 5) {
     break label$1;
    }
    $5 = $3;
    if (btreeInvokeBusyHandler($4)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  if ($2) {
   HEAP32[$2 >> 2] = sqlite3Get4byte(HEAP32[HEAP32[$4 + 12 >> 2] + 56 >> 2] + 40 | 0);
  }
  if (!$1) {
   return 0;
  }
  $3 = sqlite3PagerOpenSavepoint($7, HEAP32[HEAP32[$0 >> 2] + 500 >> 2]);
 }
 return $3;
}

function defragmentPage($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $14 = HEAPU16[$0 + 18 >> 1];
 $9 = HEAPU16[$0 + 24 >> 1];
 $15 = $14 + ($9 << 1) | 0;
 $10 = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2];
 $5 = HEAP32[$0 + 56 >> 2];
 $7 = $5 + HEAPU8[$0 + 9 | 0] | 0;
 label$1: {
  label$2: {
   if (HEAPU8[$7 + 7 | 0] > ($1 | 0)) {
    $12 = $10 - 4 | 0;
    break label$2;
   }
   $3 = HEAPU8[$7 + 2 | 0] | HEAPU8[$7 + 1 | 0] << 8;
   $12 = $10 - 4 | 0;
   if (($3 | 0) > ($12 | 0)) {
    return sqlite3CorruptError(68384);
   }
   if (!$3) {
    break label$2;
   }
   $1 = $5 + $3 | 0;
   $6 = HEAPU8[$1 | 0] << 8 | HEAPU8[$1 + 1 | 0];
   if (($12 | 0) < ($6 | 0)) {
    return sqlite3CorruptError(68387);
   }
   if ($6) {
    $2 = $5 + $6 | 0;
    if (HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0]) {
     break label$2;
    }
   }
   $2 = HEAPU8[$7 + 6 | 0] | HEAPU8[$7 + 5 | 0] << 8;
   if ($3 >>> 0 <= $2 >>> 0) {
    return sqlite3CorruptError(68395);
   }
   $8 = HEAPU8[$1 + 3 | 0] | HEAPU8[$1 + 2 | 0] << 8;
   $1 = $8 + $3 | 0;
   label$8: {
    label$9: {
     if ($6) {
      if ($1 >>> 0 > $6 >>> 0) {
       return sqlite3CorruptError(68398);
      }
      $4 = $5 + $6 | 0;
      $9 = HEAPU8[$4 + 2 | 0] << 8 | HEAPU8[$4 + 3 | 0];
      if (($9 + $6 | 0) <= ($10 | 0)) {
       break label$9;
      }
      return sqlite3CorruptError(68400);
     }
     $9 = 0;
     if (($1 | 0) <= ($10 | 0)) {
      break label$8;
     }
     return sqlite3CorruptError(68404);
    }
    memmove(($1 + $9 | 0) + $5 | 0, $1 + $5 | 0, $6 - $1 | 0);
    $8 = $8 + $9 | 0;
   }
   $13 = $5 + $15 | 0;
   $1 = $2 + $8 | 0;
   memmove($5 + $1 | 0, $2 + $5 | 0, $3 - $2 | 0);
   $2 = $5 + $14 | 0;
   while (1) {
    if ($2 >>> 0 < $13 >>> 0) {
     $4 = $8;
     $11 = HEAPU8[$2 + 1 | 0] | HEAPU8[$2 | 0] << 8;
     label$14: {
      if ($11 >>> 0 >= $3 >>> 0) {
       $4 = $9;
       if ($6 >>> 0 <= $11 >>> 0) {
        break label$14;
       }
      }
      $4 = $4 + $11 | 0;
      $4 = $4 << 8 | ($4 & 65280) >>> 8;
      HEAP8[$2 | 0] = $4;
      HEAP8[$2 + 1 | 0] = $4 >>> 8;
     }
     $2 = $2 + 2 | 0;
     continue;
    }
    break;
   }
   $3 = HEAPU8[$7 + 7 | 0];
   break label$1;
  }
  $6 = HEAPU8[$7 + 6 | 0] | HEAPU8[$7 + 5 | 0] << 8;
  $17 = $10 - $6 | 0;
  $18 = $5 + $6 | 0;
  $8 = $5;
  $1 = $10;
  $2 = 0;
  while (1) {
   if (($2 | 0) != ($9 | 0)) {
    $4 = (($2 << 1) + $14 | 0) + $5 | 0;
    $3 = HEAPU8[$4 | 0] << 8 | HEAPU8[$4 + 1 | 0];
    if (!($6 >>> 0 <= $3 >>> 0 & ($3 | 0) <= ($12 | 0))) {
     return sqlite3CorruptError(68433);
    }
    $11 = FUNCTION_TABLE[HEAP32[$0 + 76 >> 2]]($0, $3 + $8 | 0) | 0;
    $1 = $1 - $11 | 0;
    if (($6 | 0) <= ($1 | 0) & ($3 + $11 | 0) <= ($10 | 0)) {
     $16 = $1 << 8 | ($1 & 65280) >>> 8;
     HEAP8[$4 | 0] = $16;
     HEAP8[$4 + 1 | 0] = $16 >>> 8;
     label$20: {
      if (!$13) {
       $13 = 0;
       if (($1 | 0) == ($3 | 0)) {
        break label$20;
       }
       $8 = sqlite3PagerTempSpace(HEAP32[HEAP32[$0 + 52 >> 2] >> 2]);
       __memcpy($8 + $6 | 0, $18, $17);
       $13 = $8;
      }
      __memcpy($1 + $5 | 0, $3 + $8 | 0, $11);
     }
     $2 = $2 + 1 | 0;
     continue;
    } else {
     return sqlite3CorruptError(68439);
    }
   }
   break;
  }
  HEAP8[$7 + 7 | 0] = 0;
  $3 = 0;
 }
 $2 = $1 - $15 | 0;
 if (HEAP32[$0 + 20 >> 2] != ($2 + $3 | 0)) {
  return sqlite3CorruptError(68458);
 }
 HEAP8[$7 + 1 | 0] = 0;
 HEAP8[$7 + 2 | 0] = 0;
 $0 = $1 << 8 | ($1 & 65280) >>> 8;
 HEAP8[$7 + 5 | 0] = $0;
 HEAP8[$7 + 6 | 0] = $0 >>> 8;
 memset($5 + $15 | 0, 0, $2);
 return 0;
}

function whereShortCut($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 96 | 0;
 __stack_pointer = $7;
 $6 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$6 + 44 | 0] & 32) {
   break label$1;
  }
  $8 = HEAP32[$6 + 4 >> 2];
  $3 = HEAP32[$8 + 24 >> 2];
  if (HEAPU8[$3 + 43 | 0] == 1 | HEAPU8[$8 + 45 | 0] & 3) {
   break label$1;
  }
  $11 = HEAP32[$8 + 48 >> 2];
  $1 = HEAP32[$0 + 8 >> 2];
  HEAP16[$1 + 46 >> 1] = 0;
  HEAP32[$1 + 40 >> 2] = 0;
  $10 = $6 + 88 | 0;
  $0 = whereScanInit($7, $10, $11, -1, 130, 0);
  label$2: {
   label$3: {
    label$4: {
     while (1) {
      if ($0) {
       $4 = HEAP32[$0 + 32 >> 2];
       $5 = HEAP32[$0 + 36 >> 2];
       if (!($4 | $5)) {
        break label$4;
       }
       $0 = whereScanNext($7);
       continue;
      }
      break;
     }
     $0 = $3 + 8 | 0;
     while (1) {
      $2 = HEAP32[$0 >> 2];
      if ($2) {
       label$9: {
        if (HEAP32[$2 + 36 >> 2] | !HEAPU8[$2 + 54 | 0]) {
         break label$9;
        }
        $0 = HEAPU16[$2 + 50 >> 1];
        if ($0 >>> 0 > 3) {
         break label$9;
        }
        $9 = HEAPU8[$2 + 55 | 0] & 8 ? 130 : 2;
        $3 = 0;
        label$10: {
         while (1) {
          $0 = $0 & 65535;
          if ($3 >>> 0 >= $0 >>> 0) {
           break label$10;
          }
          $0 = whereScanInit($7, $10, $11, $3, $9, $2);
          label$12: {
           while (1) {
            if (!$0) {
             break label$12;
            }
            $5 = HEAP32[$0 + 32 >> 2];
            $4 = HEAP32[$0 + 36 >> 2];
            if ($5 | $4) {
             $0 = whereScanNext($7);
             continue;
            }
            break;
           }
           HEAP32[HEAP32[$1 + 52 >> 2] + ($3 << 2) >> 2] = $0;
           $3 = $3 + 1 | 0;
           $0 = HEAPU16[$2 + 50 >> 1];
           continue;
          }
          break;
         }
         $0 = HEAPU16[$2 + 50 >> 1];
        }
        if (($0 | 0) != ($3 | 0)) {
         break label$9;
        }
        $9 = 4609;
        HEAP32[$1 + 40 >> 2] = 4609;
        label$15: {
         if (!(HEAPU8[$2 + 55 | 0] & 32)) {
          $4 = HEAP32[$2 + 64 >> 2];
          $12 = $4;
          $5 = HEAP32[$2 + 68 >> 2];
          $10 = $5;
          $4 = HEAP32[$8 + 60 >> 2];
          $0 = $4;
          $5 = HEAP32[$8 + 56 >> 2];
          $8 = $5;
          $4 = $10;
          $5 = $0;
          $5 = $4 & $5;
          $4 = $8 & $12;
          if ($4 | $5) {
           break label$15;
          }
         }
         $9 = 4673;
         HEAP32[$1 + 40 >> 2] = 4673;
        }
        HEAP16[$1 + 24 >> 1] = $3;
        HEAP16[$1 + 44 >> 1] = $3;
        HEAP32[$1 + 32 >> 2] = $2;
        $0 = 39;
        break label$3;
       }
       $0 = $2 + 20 | 0;
       continue;
      }
      break;
     }
     $9 = HEAP32[$1 + 40 >> 2];
     if ($9) {
      break label$2;
     }
     $2 = 0;
     break label$1;
    }
    $9 = 4353;
    HEAP32[$1 + 40 >> 2] = 4353;
    HEAP32[HEAP32[$1 + 52 >> 2] >> 2] = $0;
    HEAP16[$1 + 24 >> 1] = 1;
    HEAP16[$1 + 44 >> 1] = 1;
    $0 = 33;
   }
   HEAP16[$1 + 20 >> 1] = $0;
  }
  HEAP16[$1 + 22 >> 1] = 1;
  HEAP32[$6 + 848 >> 2] = $1;
  HEAP32[$1 + 8 >> 2] = 1;
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP16[$6 + 54 >> 1] = 1;
  HEAP32[$6 + 772 >> 2] = $11;
  $0 = HEAP32[$6 + 8 >> 2];
  if ($0) {
   HEAP8[$6 + 49 | 0] = HEAP32[$0 >> 2];
  }
  if (HEAP8[$6 + 45 | 0] & 1) {
   HEAP8[$6 + 51 | 0] = 1;
  }
  $2 = 1;
  if (HEAPU8[$7 + 25 | 0] < 2) {
   break label$1;
  }
  HEAP32[$1 + 40 >> 2] = $9 | 2097152;
 }
 __stack_pointer = $7 + 96 | 0;
 return $2;
}

function vdbeRecordCompareInt($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = (HEAPU8[$1 | 0] & 63) + $1 | 0;
 label$1: {
  label$2: {
   switch (HEAPU8[$1 + 1 | 0] - 1 | 0) {
   case 1:
    $3 = HEAPU8[$6 + 1 | 0] | HEAP8[$6 | 0] << 8;
    $4 = $3 >> 31;
    $8 = $3;
    $7 = $4;
    break label$1;

   case 2:
    $3 = HEAPU8[$6 + 2 | 0] | (HEAPU8[$6 + 1 | 0] << 8 | HEAP8[$6 | 0] << 16);
    $4 = $3 >> 31;
    $8 = $3;
    $7 = $4;
    break label$1;

   case 3:
    $6 = HEAPU8[$6 | 0] | HEAPU8[$6 + 1 | 0] << 8 | (HEAPU8[$6 + 2 | 0] << 16 | HEAPU8[$6 + 3 | 0] << 24);
    $3 = $6 << 24 | $6 << 8 & 16711680 | ($6 >>> 8 & 65280 | $6 >>> 24);
    $4 = $3 >> 31;
    $8 = $3;
    $7 = $4;
    break label$1;

   case 4:
    $5 = $6;
    $4 = HEAPU8[$5 + 5 | 0];
    $7 = $4;
    $3 = HEAPU8[$5 + 3 | 0];
    $5 = $3;
    $3 = $3 >>> 16 | 0;
    $8 = $3;
    $5 = $5 << 16;
    $4 = $6;
    $3 = HEAPU8[$4 + 2 | 0];
    $10 = $5 | $3 << 24;
    $3 = $3 >>> 8 | 0;
    $4 = $3;
    $3 = $8;
    $4 = $4 | $3;
    $5 = $4;
    $3 = $6;
    $4 = HEAPU8[$3 + 4 | 0];
    $3 = $4;
    $8 = $3 << 8;
    $4 = $3 >>> 24 | 0;
    $3 = $4;
    $4 = $5;
    $3 = $4 | $3;
    $9 = $3;
    $4 = $7;
    $5 = $10;
    $5 = $4 | ($8 | $5);
    $3 = HEAPU8[$6 + 1 | 0] | HEAP8[$6 | 0] << 8;
    $8 = $5;
    $4 = $9;
    $3 = $4 | $3;
    $7 = $3;
    break label$1;

   case 5:
    $4 = $6;
    $3 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8 | (HEAPU8[$4 + 2 | 0] << 16 | HEAPU8[$4 + 3 | 0] << 24);
    $8 = $3;
    $4 = $3;
    $3 = $3 << 24;
    $9 = $3;
    $5 = HEAPU8[$6 + 4 | 0] | HEAPU8[$6 + 5 | 0] << 8 | (HEAPU8[$6 + 6 | 0] << 16 | HEAPU8[$6 + 7 | 0] << 24);
    $7 = $5;
    $4 = $4 << 8;
    $5 = $4 & 16711680;
    $4 = 0;
    $6 = $4;
    $3 = $5;
    $5 = $9;
    $3 = $3 | $5;
    $9 = $3;
    $3 = $7;
    $5 = $8;
    $4 = $3 << 24 | $5 >>> 8;
    $5 = $4 & 65280;
    $10 = $5;
    $5 = $7;
    $4 = $8;
    $3 = $5 << 8 | $4 >>> 24;
    $4 = $3 & 255;
    $5 = $4;
    $4 = $10;
    $5 = $4 | $5;
    $4 = $6;
    $3 = $11;
    $10 = $4 | ($11 | $3);
    $3 = $5;
    $5 = $9;
    $3 = $3 | $5;
    $6 = $3;
    $3 = $7;
    $5 = $8;
    $3 = ($3 & 255) << 24 | $5 >>> 8;
    $3 = $3 & -16777216;
    $5 = 0;
    $9 = $5;
    $5 = $7;
    $4 = $8;
    $5 = ($5 & 16777215) << 8 | $4 >>> 24;
    $4 = 0;
    $11 = $5 & 16711680 | $3;
    $4 = $9;
    $5 = $4;
    $5 = $4 | $5;
    $8 = $5;
    $5 = $7;
    $5 = $5 >>> 8 | 0;
    $9 = $5 & 65280;
    $4 = 0;
    $5 = $4;
    $4 = $7;
    $5 = 0;
    $3 = $5;
    $3 = $3 | $5;
    $5 = $11;
    $7 = $4 >>> 24 | 0;
    $4 = $9;
    $7 = $5 | ($7 | $4);
    $4 = $3;
    $3 = $8;
    $4 = $4 | $3;
    $5 = $4;
    $3 = $10;
    $8 = $7 | $3;
    $4 = $6;
    $5 = $4 | $5;
    $7 = $5;
    break label$1;

   case 8:
    $8 = 1;
    break label$1;

   default:
    return sqlite3VdbeRecordCompare($0, $1, $2) | 0;

   case 7:
    break label$1;

   case 0:
    break label$2;
   }
  }
  $4 = $6;
  $5 = HEAP8[$4 | 0];
  $3 = $5 >> 31;
  $8 = $5;
  $7 = $3;
 }
 $4 = $2;
 $3 = HEAP32[$4 + 8 >> 2];
 $6 = $3;
 $4 = $8;
 $5 = HEAP32[$2 + 12 >> 2];
 $9 = $5;
 $3 = $5;
 $5 = $7;
 if ($6 >>> 0 > $4 >>> 0 & ($3 | 0) >= ($5 | 0) | ($3 | 0) > ($5 | 0)) {
  return HEAP8[$2 + 24 | 0];
 }
 $3 = $6;
 $4 = $7;
 $5 = $9;
 if ($8 >>> 0 > $3 >>> 0 & ($4 | 0) >= ($5 | 0) | ($5 | 0) < ($4 | 0)) {
  return HEAP8[$2 + 25 | 0];
 }
 if (HEAPU16[$2 + 20 >> 1] >= 2) {
  return sqlite3VdbeRecordCompareWithSkip($0, $1, $2, 1) | 0;
 }
 HEAP8[$2 + 26 | 0] = 1;
 return HEAP8[$2 + 22 | 0];
}

function __trunctfdf2($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $12 = __stack_pointer - 32 | 0;
 __stack_pointer = $12;
 $4 = $3;
 $9 = $4 & 2147483647;
 $8 = $9;
 $6 = $2;
 $2 = $6;
 $4 = $6;
 $5 = $4;
 $7 = 1006698496;
 $7 = $9 - $7 | 0;
 $4 = $7;
 $7 = $9;
 $6 = $5;
 $5 = 1140785152;
 $5 = $7 - $5 | 0;
 $9 = $5;
 $5 = $4;
 $7 = $6;
 label$1: {
  if (($9 | 0) == ($5 | 0) & $6 >>> 0 > $6 >>> 0 | $5 >>> 0 < $9 >>> 0) {
   $8 = $2;
   $2 = $8 << 4;
   $7 = $3;
   $5 = $7 << 4 | $8 >>> 28;
   $4 = $5;
   $8 = 0;
   $7 = $8;
   $5 = $1;
   $9 = $5 >>> 28 | 0;
   $5 = $2;
   $2 = $9 | $5;
   $8 = $4;
   $7 = $8 | $7;
   $8 = $7;
   $7 = $1;
   $5 = $7 & 268435455;
   $1 = $5;
   $7 = $0;
   if (($5 | 0) == 134217728 & ($7 | 0) != 0 | $5 >>> 0 > 134217728) {
    $7 = $8;
    $6 = $7 + 1073741824 | 0;
    $9 = $2;
    $4 = $9 + 1 | 0;
    $6 = $4 ? $6 : $6 + 1 | 0;
    $11 = $4;
    $10 = $6;
    break label$1;
   }
   $7 = $2;
   $5 = $7;
   $11 = $5;
   $6 = $8;
   $4 = -1073741824;
   $4 = $6 - $4 | 0;
   $10 = $4;
   $6 = $0;
   $4 = $1;
   if ($6 | ($4 | 0) != 134217728) {
    break label$1;
   }
   $4 = 0;
   $0 = $4;
   $6 = $11;
   $8 = $2;
   $7 = $8 & 1;
   $9 = $6 + $7 | 0;
   $4 = $10;
   $8 = $0;
   $5 = $4 + $8 | 0;
   $11 = $9;
   $5 = $7 >>> 0 > $9 >>> 0 ? $5 + 1 | 0 : $5;
   $10 = $5;
   break label$1;
  }
  $5 = $1;
  $10 = !($5 | $0);
  $5 = $8;
  $6 = $5 >>> 0 < 2147418112;
  $4 = $5;
  if (!(!$7 & ($4 | 0) == 2147418112 ? $10 : $6)) {
   $6 = $2;
   $2 = $6 << 4;
   $7 = $3;
   $4 = $7 << 4 | $6 >>> 28;
   $0 = $4;
   $4 = $1;
   $5 = $4 >>> 28 | 0;
   $6 = 0;
   $7 = $6;
   $6 = $0;
   $7 = $6 | $7;
   $4 = $2;
   $6 = $4 | $5;
   $4 = $7 & 524287;
   $11 = $6;
   $6 = $4 | 2146959360;
   $10 = $6;
   break label$1;
  }
  $10 = 2146435072;
  $6 = $8;
  if ($6 >>> 0 > 1140785151) {
   break label$1;
  }
  $10 = 0;
  $4 = $8;
  $7 = $4 >>> 16 | 0;
  if ($7 >>> 0 < 15249) {
   break label$1;
  }
  $6 = $3;
  $5 = $6 & 65535;
  $4 = $2;
  $2 = $4;
  $4 = $5 | 65536;
  $8 = $4;
  $4 = $1;
  $6 = $8;
  __ashlti3($12 + 16 | 0, $0, $4, $2, $6, $7 - 15233 | 0);
  $6 = $4;
  $4 = $8;
  __lshrti3($12, $0, $6, $2, $4, 15361 - $7 | 0);
  $5 = $12;
  $4 = HEAP32[$5 + 8 >> 2];
  $6 = HEAP32[$5 + 12 >> 2];
  $1 = $4 << 4;
  $4 = $6 << 4 | $4 >>> 28;
  $0 = $4;
  $6 = $12;
  $4 = HEAP32[$6 >> 2];
  $2 = $4;
  $5 = HEAP32[$6 + 4 >> 2];
  $8 = $5;
  $7 = $5 >>> 28 | 0;
  $4 = 0;
  $6 = $4;
  $5 = $1;
  $11 = $5 | $7;
  $4 = $0;
  $6 = $4 | $6;
  $10 = $6;
  $4 = $12;
  $6 = HEAP32[$4 + 16 >> 2];
  $1 = $6;
  $5 = HEAP32[$4 + 20 >> 2];
  $0 = $5;
  $5 = HEAP32[$4 + 24 >> 2];
  $7 = $5;
  $6 = HEAP32[$4 + 28 >> 2];
  $5 = $6;
  $6 = $0;
  $5 = $6 | $5;
  $4 = $1;
  $6 = $4 | $7;
  $0 = ($5 | $6) != 0;
  $6 = $8;
  $5 = $6 & 268435455;
  $7 = $2;
  $4 = $7;
  $6 = $0;
  $2 = $4 | $6;
  $7 = $5;
  $8 = $5;
  $5 = $2;
  if (($7 | 0) == 134217728 & ($5 | 0) != 0 | $7 >>> 0 > 134217728) {
   $5 = $10;
   $4 = $11;
   $8 = $4 + 1 | 0;
   $9 = $8 ? $5 : $5 + 1 | 0;
   $11 = $8;
   $10 = $9;
   break label$1;
  }
  $9 = $8;
  if ($2 | ($9 | 0) != 134217728) {
   break label$1;
  }
  $4 = $11;
  $5 = $4 & 1;
  $7 = $4 + $5 | 0;
  $9 = 0;
  $6 = $10;
  $8 = $9 + $6 | 0;
  $11 = $7;
  $8 = $4 >>> 0 > $7 >>> 0 ? $8 + 1 | 0 : $8;
  $10 = $8;
 }
 __stack_pointer = $12 + 32 | 0;
 $8 = $3;
 $5 = $8 & -2147483648;
 $4 = 0;
 $8 = $11;
 wasm2js_scratch_store_i32(0, $4 | $8);
 $9 = $5;
 $5 = $10;
 $9 = $9 | $5;
 wasm2js_scratch_store_i32(1, $9 | 0);
 return +wasm2js_scratch_load_f64();
}

function fts3SegWriterAdd($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $13 = __stack_pointer - 16 | 0;
 __stack_pointer = $13;
 $7 = HEAP32[$1 >> 2];
 label$1: {
  if (!$7) {
   $6 = 7;
   $7 = sqlite3_malloc(64);
   if (!$7) {
    break label$1;
   }
   $10 = memset($7, 0, 64);
   HEAP32[$1 >> 2] = $10;
   $1 = sqlite3_malloc(HEAP32[$0 + 232 >> 2]);
   HEAP32[$10 + 48 >> 2] = $1;
   if (!$1) {
    break label$1;
   }
   HEAP32[$10 + 40 >> 2] = HEAP32[$0 + 232 >> 2];
   $6 = fts3SqlStmt($0, 10, $13 + 12 | 0, 0);
   if ($6) {
    break label$1;
   }
   $6 = HEAP32[$13 + 12 >> 2];
   if ((sqlite3_step($6) | 0) == 100) {
    $8 = sqlite3_column_int64($6, 0);
    $14 = $8;
    $8 = i64toi32_i32$HIGH_BITS;
    HEAP32[$10 + 8 >> 2] = $14;
    HEAP32[$10 + 12 >> 2] = $8;
    HEAP32[$10 + 16 >> 2] = $14;
    HEAP32[$10 + 20 >> 2] = $8;
   }
   $6 = sqlite3_reset($6);
   if ($6) {
    break label$1;
   }
  }
  $10 = HEAP32[$7 + 44 >> 2];
  $6 = 267;
  $12 = fts3PrefixCompress(HEAP32[$7 + 24 >> 2], HEAP32[$7 + 28 >> 2], $2, $3);
  $1 = $3 - $12 | 0;
  if (($1 | 0) <= 0) {
   break label$1;
  }
  $8 = $12 >> 31;
  $9 = sqlite3Fts3VarintLen($12, $8);
  $8 = $5 >> 31;
  $16 = $8;
  $11 = sqlite3Fts3VarintLen($1, 0);
  $14 = $5;
  $15 = sqlite3Fts3VarintLen($5, $8) + $5 | 0;
  $9 = $11 + (($15 + $1 | 0) + $9 | 0) | 0;
  if (!(($10 | 0) <= 0 | HEAP32[$0 + 232 >> 2] >= ($10 + $9 | 0))) {
   $8 = HEAP32[$7 + 16 >> 2];
   $9 = $8;
   $8 = HEAP32[$7 + 20 >> 2];
   $1 = $8;
   if (($9 | 0) == -1 & ($8 | 0) == 2147483647) {
    break label$1;
   }
   $8 = $1;
   $11 = $9 + 1 | 0;
   $8 = $11 ? $8 : $8 + 1 | 0;
   HEAP32[$7 + 16 >> 2] = $11;
   HEAP32[$7 + 20 >> 2] = $8;
   $8 = $1;
   $6 = fts3WriteSegment($0, $9, $8, HEAP32[$7 + 48 >> 2], $10);
   if ($6) {
    break label$1;
   }
   HEAP32[$0 + 52 >> 2] = HEAP32[$0 + 52 >> 2] + 1;
   $6 = fts3NodeAddTerm($0, $7, $2, $12 + 1 | 0);
   if ($6) {
    break label$1;
   }
   $10 = 0;
   HEAP32[$7 + 28 >> 2] = 0;
   $8 = $3 >> 31;
   $9 = (sqlite3Fts3VarintLen($3, $8) + ($3 + $15 | 0) | 0) + 1 | 0;
   $12 = 0;
   $1 = $3;
  }
  $8 = HEAP32[$7 + 56 >> 2];
  $0 = $8;
  $8 = $9 >> 31;
  $11 = $8 + HEAP32[$7 + 60 >> 2] | 0;
  $8 = $0 + $9 | 0;
  $11 = $9 >>> 0 > $8 >>> 0 ? $11 + 1 | 0 : $11;
  HEAP32[$7 + 56 >> 2] = $8;
  HEAP32[$7 + 60 >> 2] = $11;
  $6 = HEAP32[$7 + 48 >> 2];
  label$5: {
   if (HEAP32[$7 + 40 >> 2] < ($9 | 0)) {
    $6 = sqlite3_realloc($6, $9);
    if (!$6) {
     break label$5;
    }
    HEAP32[$7 + 40 >> 2] = $9;
    HEAP32[$7 + 48 >> 2] = $6;
   }
   $11 = $12 >> 31;
   $6 = sqlite3Fts3PutVarint($6 + $10 | 0, $12, $11);
   $6 = $10 + $6 | 0;
   $11 = $1 >> 31;
   $0 = sqlite3Fts3PutVarint($6 + HEAP32[$7 + 48 >> 2] | 0, $1, $11);
   $6 = $0 + $6 | 0;
   __memcpy($6 + HEAP32[$7 + 48 >> 2] | 0, $2 + $12 | 0, $1);
   $6 = $1 + $6 | 0;
   $11 = $16;
   $1 = sqlite3Fts3PutVarint($6 + HEAP32[$7 + 48 >> 2] | 0, $14, $11);
   $6 = $1 + $6 | 0;
   __memcpy($6 + HEAP32[$7 + 48 >> 2] | 0, $4, $5);
   HEAP32[$7 + 44 >> 2] = $5 + $6;
   label$7: {
    if (HEAP32[$7 + 32 >> 2] >= ($3 | 0)) {
     $6 = HEAP32[$7 + 24 >> 2];
     break label$7;
    }
    $5 = $3 << 1;
    $6 = sqlite3_realloc(HEAP32[$7 + 36 >> 2], $5);
    if (!$6) {
     break label$5;
    }
    HEAP32[$7 + 36 >> 2] = $6;
    HEAP32[$7 + 32 >> 2] = $5;
    HEAP32[$7 + 24 >> 2] = $6;
   }
   __memcpy($6, $2, $3);
   HEAP32[$7 + 28 >> 2] = $3;
   $6 = 0;
   break label$1;
  }
  $6 = 7;
 }
 __stack_pointer = $13 + 16 | 0;
 return $6;
}

function fts3SnippetDetails($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0;
 $14 = __stack_pointer - 16 | 0;
 __stack_pointer = $14;
 $16 = HEAP32[$0 + 20 >> 2];
 $9 = $16;
 $8 = $9 >> 31;
 $16 = $9;
 $22 = $8;
 while (1) {
  label$2: {
   if (HEAP32[$0 + 12 >> 2] > ($18 | 0)) {
    $20 = HEAP32[$0 + 16 >> 2] + Math_imul($18, 40) | 0;
    $7 = HEAP32[$20 + 32 >> 2];
    if (!$7) {
     break label$2;
    }
    HEAP32[$14 + 12 >> 2] = $7;
    $7 = $20;
    $8 = HEAP32[$7 + 24 >> 2];
    $13 = $8;
    $9 = HEAP32[$7 + 28 >> 2];
    $15 = $9;
    $8 = $14;
    HEAP32[$8 >> 2] = $13;
    HEAP32[$8 + 4 >> 2] = $9;
    $9 = $19;
    $7 = $9;
    $11 = $18 & 63;
    $12 = $11 & 31;
    if (($11 & 63) >>> 0 >= 32) {
     $8 = 1 << $12;
     $21 = 0;
    } else {
     $8 = (1 << $12) - 1 & 1 >>> 32 - $12;
     $21 = 1 << $12;
    }
    $23 = $8;
    $9 = $17;
    $11 = $21;
    $24 = $9 | $11;
    $8 = $7;
    $7 = $23;
    $7 = $8 | $7;
    $25 = $7;
    while (1) {
     $8 = $13;
     $11 = $16;
     $9 = $22;
     $7 = $15;
     $12 = $8 >>> 0 < $11 >>> 0 & ($9 | 0) >= ($7 | 0) | ($9 | 0) > ($7 | 0);
     $7 = HEAP32[$0 + 8 >> 2] + $16 | 0;
     $8 = $7 >> 31;
     $10 = $8;
     $9 = $7;
     $11 = $13;
     $8 = $15;
     $7 = $10;
     if ($9 >>> 0 <= $11 >>> 0 & ($8 | 0) >= ($7 | 0) | ($8 | 0) > ($7 | 0) | $12) {
      break label$2;
     }
     $9 = $13;
     $7 = $16;
     $12 = $9 - $7 | 0;
     $11 = $15;
     $8 = $22;
     $10 = $8 + ($7 >>> 0 > $9 >>> 0) | 0;
     $10 = $11 - $10 | 0;
     $9 = $10;
     $7 = $12;
     $8 = $7 & 31;
     if (($7 & 63) >>> 0 >= 32) {
      $9 = 1 << $8;
      $26 = 0;
     } else {
      $9 = (1 << $8) - 1 & 1 >>> 32 - $8;
      $26 = 1 << $8;
     }
     $30 = $9;
     $9 = $2;
     $11 = $19;
     $11 = $9 | $11;
     $7 = $17;
     $10 = $1;
     $9 = $7 | $10;
     $7 = $21;
     $10 = $23;
     $10 = $11 & $10;
     $27 = ($9 & $7 | $10 ? 1 : 1e3) + $27 | 0;
     $7 = HEAP32[$20 >> 2];
     $17 = ($7 | 0) > 0 ? $7 : 0;
     $13 = 0;
     $15 = 0;
     while (1) {
      $10 = $15;
      $7 = $17;
      $11 = $13;
      if (!(!$10 & ($7 | 0) == ($11 | 0))) {
       $11 = $30;
       $7 = $26;
       $9 = $13;
       $8 = $9 & 31;
       if (($9 & 63) >>> 0 >= 32) {
        $10 = 0;
        $11 = $11 >>> $8 | 0;
       } else {
        $10 = $11 >>> $8 | 0;
        $11 = ((1 << $8) - 1 & $11) << 32 - $8 | $7 >>> $8;
       }
       $9 = $28;
       $28 = $9 | $11;
       $7 = $29;
       $7 = $10 | $7;
       $29 = $7;
       $7 = $15;
       $10 = $13;
       $8 = $10 + 1 | 0;
       $12 = $8 ? $7 : $7 + 1 | 0;
       $13 = $8;
       $15 = $12;
       continue;
      }
      break;
     }
     if (HEAPU8[HEAP32[$14 + 12 >> 2]] < 2) {
      $17 = $24;
      $12 = $25;
      $19 = $12;
      break label$2;
     } else {
      fts3GetDeltaPosition($14 + 12 | 0, $14);
      $7 = $14;
      $12 = HEAP32[$7 >> 2];
      $13 = $12;
      $10 = HEAP32[$7 + 4 >> 2];
      $15 = $10;
      $17 = $24;
      $10 = $25;
      $19 = $10;
      continue;
     }
    }
   }
   HEAP32[$3 >> 2] = $16;
   HEAP32[$4 >> 2] = $27;
   $12 = $5;
   HEAP32[$12 >> 2] = $17;
   $10 = $19;
   HEAP32[$12 + 4 >> 2] = $10;
   $12 = $6;
   HEAP32[$12 >> 2] = $28;
   $10 = $29;
   HEAP32[$12 + 4 >> 2] = $10;
   __stack_pointer = $14 + 16 | 0;
   return;
  }
  $18 = $18 + 1 | 0;
  continue;
 }
}

function sqlite3VdbeSorterWrite($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 $0 = HEAP32[$0 + 36 >> 2];
 $11 = HEAP32[$1 + 8 >> 2];
 $6 = HEAP8[$11 + 1 | 0];
 $5 = $6 & 255;
 HEAP32[$12 + 12 >> 2] = $5;
 if (($6 | 0) < 0) {
  sqlite3GetVarint32($11 + 1 | 0, $12 + 12 | 0);
  $5 = HEAP32[$12 + 12 >> 2];
 }
 label$2: {
  if (!(($5 | 0) == 7 | $5 - 1 >>> 0 > 8)) {
   HEAP8[$0 + 60 | 0] = HEAP8[$0 + 60 | 0] & 1;
   break label$2;
  }
  if (!(!($5 & 1) | ($5 | 0) < 11)) {
   HEAP8[$0 + 60 | 0] = HEAPU8[$0 + 60 | 0] & 2;
   break label$2;
  }
  HEAP8[$0 + 60 | 0] = 0;
 }
 $5 = HEAP32[$1 + 12 >> 2];
 $4 = $5 + 8 | 0;
 $2 = $5 >> 31;
 $6 = sqlite3VarintLen($5, $2) + $5 | 0;
 $11 = 0;
 $8 = HEAP32[$0 + 4 >> 2];
 label$5: {
  if (!$8) {
   break label$5;
  }
  label$6: {
   if (HEAP32[$0 + 40 >> 2]) {
    $3 = HEAP32[$0 + 48 >> 2];
    if (!$3) {
     break label$5;
    }
    if (($4 + $3 | 0) > ($8 | 0)) {
     break label$6;
    }
    break label$5;
   }
   $3 = HEAP32[$0 + 44 >> 2];
   if (($3 | 0) > ($8 | 0)) {
    break label$6;
   }
   if (HEAP32[$0 >> 2] >= ($3 | 0)) {
    break label$5;
   }
   if (!sqlite3HeapNearlyFull()) {
    break label$5;
   }
  }
  $11 = vdbeSorterFlushPMA($0);
  HEAP32[$0 + 44 >> 2] = 0;
  HEAP32[$0 + 48 >> 2] = 0;
 }
 $8 = $0 + 44 | 0;
 HEAP32[$8 >> 2] = HEAP32[$0 + 44 >> 2] + $6;
 if (HEAP32[$0 + 8 >> 2] < ($6 | 0)) {
  HEAP32[$0 + 8 >> 2] = $6;
 }
 label$9: {
  label$10: {
   $6 = HEAP32[$0 + 40 >> 2];
   label$11: {
    if ($6) {
     $8 = HEAP32[$0 + 48 >> 2];
     $4 = $8 + $4 | 0;
     $3 = HEAP32[$0 + 52 >> 2];
     if (($4 | 0) > ($3 | 0)) {
      $8 = HEAP32[$0 + 36 >> 2];
      $15 = $8 - $6 | 0;
      $10 = $4;
      $2 = $4 >> 31;
      $13 = $2;
      $4 = $3;
      $2 = $4 >> 31;
      $9 = $4;
      $3 = $2;
      while (1) {
       $2 = $3;
       $7 = $9;
       $4 = $2 << 1 | $7 >>> 31;
       $9 = $7 << 1;
       $2 = $9;
       $3 = $4;
       $7 = $13;
       if ($2 >>> 0 < $10 >>> 0 & ($3 | 0) <= ($7 | 0) | ($3 | 0) < ($7 | 0)) {
        continue;
       }
       break;
      }
      $2 = HEAP32[$0 + 4 >> 2];
      $4 = $2 >> 31;
      $7 = $2;
      $2 = $4;
      $14 = $7 >>> 0 > $9 >>> 0 & ($2 | 0) >= ($3 | 0) | ($2 | 0) > ($3 | 0);
      $2 = $14 ? $9 : $7;
      $9 = $2;
      $7 = $14 ? $3 : $4;
      $3 = $7;
      $7 = $13;
      $2 = $7;
      $4 = $10 >>> 0 < $9 >>> 0 & ($2 | 0) <= ($3 | 0) | ($3 | 0) > ($2 | 0);
      $2 = $4 ? $9 : $10;
      $9 = $2;
      $7 = $13;
      $10 = $4 ? $3 : $7;
      $3 = $10;
      $6 = sqlite3Realloc($6, $2, $3);
      if (!$6) {
       break label$10;
      }
      $4 = $8 ? $15 : -1;
      if (($4 | 0) >= 0) {
       HEAP32[$0 + 36 >> 2] = $6 + $4;
      }
      HEAP32[$0 + 52 >> 2] = $9;
      HEAP32[$0 + 40 >> 2] = $6;
      $8 = HEAP32[$0 + 48 >> 2];
     }
     HEAP32[$0 + 48 >> 2] = ($5 + 15 & -8) + $8;
     $5 = $6 + $8 | 0;
     $4 = HEAP32[$0 + 36 >> 2];
     if (!$4) {
      break label$11;
     }
     HEAP32[$5 + 4 >> 2] = $4 - $6;
     break label$11;
    }
    $2 = $4;
    $10 = $2 >> 31;
    $5 = sqlite3Malloc($2, $10);
    if (!$5) {
     break label$10;
    }
    HEAP32[$5 + 4 >> 2] = HEAP32[$0 + 36 >> 2];
   }
   __memcpy($5 + 8 | 0, HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
   HEAP32[$5 >> 2] = HEAP32[$1 + 12 >> 2];
   HEAP32[$0 + 36 >> 2] = $5;
   break label$9;
  }
  $11 = 7;
 }
 __stack_pointer = $12 + 16 | 0;
 return $11;
}

function getNextString($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $7 = HEAP32[$0 >> 2];
 $13 = HEAP32[$7 >> 2];
 HEAP32[$5 + 28 >> 2] = 0;
 label$1: {
  label$2: {
   $7 = sqlite3Fts3OpenTokenizer($7, HEAP32[$0 + 4 >> 2], $1, $2, $5 + 28 | 0);
   label$3: {
    if (!$7) {
     $8 = HEAP32[$5 + 28 >> 2];
     $7 = 0;
     while (1) {
      if (!$7) {
       HEAP32[$5 + 20 >> 2] = 0;
       HEAP32[$5 + 16 >> 2] = 0;
       HEAP32[$5 + 12 >> 2] = 0;
       HEAP32[$5 + 8 >> 2] = 0;
       $7 = FUNCTION_TABLE[HEAP32[$13 + 20 >> 2]]($8, $5 + 24 | 0, $5 + 20 | 0, $5 + 16 | 0, $5 + 12 | 0, $5 + 8 | 0) | 0;
       if ($7) {
        $6 = $15;
        $4 = $6;
        $14 = $14 + 1 | 0;
        $4 = $14 ? $4 : $4 + 1 | 0;
        $15 = $4;
        continue;
       }
       $4 = $15;
       $4 = __wasm_i64_mul($14, $4, 24, 0);
       $6 = $4;
       $4 = i64toi32_i32$HIGH_BITS;
       $6 = $6 + 144 | 0;
       $4 = $6;
       $6 = 0;
       $9 = fts3ReallocOrFree($9, $4 & -8, $6);
       if (!$9) {
        break label$3;
       }
       $4 = HEAP32[$5 + 20 >> 2] + $10 | 0;
       $6 = $4 >> 31;
       $12 = fts3ReallocOrFree($12, $4, $6);
       if ($12) {
        $11 = ($9 + 120 | 0) + Math_imul($14, 24) | 0;
        $4 = $11;
        HEAP32[$4 >> 2] = 0;
        HEAP32[$4 + 4 >> 2] = 0;
        HEAP32[$4 + 16 >> 2] = 0;
        HEAP32[$4 + 20 >> 2] = 0;
        HEAP32[$4 + 8 >> 2] = 0;
        HEAP32[$4 + 12 >> 2] = 0;
        __memcpy($12 + $10 | 0, HEAP32[$5 + 24 >> 2], HEAP32[$5 + 20 >> 2]);
        $16 = HEAP32[$5 + 20 >> 2];
        HEAP32[$4 + 4 >> 2] = $16;
        $6 = 0;
        $4 = 0;
        $17 = HEAP32[$5 + 12 >> 2];
        if (($17 | 0) < ($2 | 0)) {
         $4 = HEAPU8[$1 + $17 | 0] == 42;
        }
        HEAP32[$11 + 8 >> 2] = $4;
        $10 = $10 + $16 | 0;
        $4 = HEAP32[$5 + 16 >> 2];
        if (($4 | 0) > 0) {
         $6 = HEAPU8[($1 + $4 | 0) - 1 | 0] == 94;
        }
        HEAP32[$11 + 12 >> 2] = $6;
        $6 = $15;
        $4 = $14 + 1 | 0;
        $6 = $4 ? $6 : $6 + 1 | 0;
        $14 = $4;
        $15 = $6;
        $11 = $14;
        continue;
       } else {
        $12 = 0;
        break label$3;
       }
      }
      break;
     }
     FUNCTION_TABLE[HEAP32[$13 + 16 >> 2]]($8) | 0;
     HEAP32[$5 + 28 >> 2] = 0;
    }
    if (($7 | 0) != 101) {
     break label$1;
    }
    $6 = Math_imul($11, 24);
    $9 = fts3ReallocOrFree($9, ($6 + $10 | 0) + 144 | 0, 0);
    if ($9) {
     break label$2;
    }
    $9 = 0;
    $8 = HEAP32[$5 + 28 >> 2];
   }
   if ($8) {
    FUNCTION_TABLE[HEAP32[$13 + 16 >> 2]]($8) | 0;
   }
   sqlite3_free($12);
   sqlite3_free($9);
   $7 = 7;
   $9 = 0;
   break label$1;
  }
  $7 = 0;
  $8 = memset($9, 0, 120);
  $13 = $8 + 48 | 0;
  HEAP32[$8 + 20 >> 2] = $13;
  HEAP32[$8 >> 2] = 5;
  $4 = HEAP32[$0 + 20 >> 2];
  HEAP32[$8 + 112 >> 2] = $11;
  HEAP32[$8 + 116 >> 2] = $4;
  $11 = ($13 + $6 | 0) + 72 | 0;
  if ($12) {
   __memcpy($11, $12, $10);
   sqlite3_free($12);
   $13 = HEAP32[$8 + 20 >> 2];
  }
  $10 = HEAP32[$13 + 64 >> 2];
  $12 = ($10 | 0) > 0 ? $10 : 0;
  while (1) {
   if (($7 | 0) != ($12 | 0)) {
    $10 = Math_imul($7, 24) + $13 | 0;
    HEAP32[$10 + 72 >> 2] = $11;
    $7 = $7 + 1 | 0;
    $11 = HEAP32[$10 + 76 >> 2] + $11 | 0;
    continue;
   }
   break;
  }
  $7 = 0;
 }
 HEAP32[$3 >> 2] = $9;
 __stack_pointer = $5 + 32 | 0;
 return $7;
}

function fts3ScanInteriorNode($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $9 = 267;
 label$1: {
  $10 = sqlite3Fts3GetVarintU($2, $7 + 8 | 0) + $2 | 0;
  $10 = $10 + sqlite3Fts3GetVarintU($10, $7 + 8 | 0) | 0;
  $14 = $2 + $3 | 0;
  if ($10 >>> 0 > $14 >>> 0) {
   break label$1;
  }
  $3 = 0;
  while (1) {
   label$3: {
    label$4: {
     if ($10 >>> 0 < $14 >>> 0) {
      if (!($4 | $5)) {
       $9 = 0;
       break label$4;
      }
      $9 = 0;
      HEAP32[$7 >> 2] = 0;
      label$7: {
       if ($3 & 1) {
        $9 = HEAP8[$10 | 0];
        label$10: {
         if (($9 | 0) < 0) {
          $3 = sqlite3Fts3GetVarint32($10, $7);
          $9 = HEAP32[$7 >> 2];
          break label$10;
         }
         $9 = $9 & 255;
         HEAP32[$7 >> 2] = $9;
         $3 = 1;
        }
        if (($9 | 0) > ($12 | 0)) {
         break label$7;
        }
        $10 = $3 + $10 | 0;
       }
       $3 = HEAP8[$10 | 0];
       label$8: {
        if (($3 | 0) < 0) {
         $3 = sqlite3Fts3GetVarint32($10, $7 + 4 | 0);
         break label$8;
        }
        HEAP32[$7 + 4 >> 2] = $3 & 255;
        $3 = 1;
       }
       $3 = $10 + $3 | 0;
       if (($3 - $2 | 0) < ($9 | 0)) {
        break label$7;
       }
       $10 = HEAP32[$7 + 4 >> 2];
       if (($10 | 0) > ($14 - $3 | 0) | !$10) {
        break label$7;
       }
       $11 = $10 >> 31;
       $8 = $11;
       $11 = $9 >> 31;
       $6 = $11;
       $11 = $8;
       $6 = $11 + $6 | 0;
       $8 = $9 + $10 | 0;
       $6 = $9 >>> 0 > $8 >>> 0 ? $6 + 1 | 0 : $6;
       $12 = $6;
       $6 = $15;
       $11 = $16;
       if (($12 | 0) <= ($6 | 0) & $11 >>> 0 >= $8 >>> 0 | ($6 | 0) > ($12 | 0)) {
        $12 = $13;
        break label$3;
       }
       $16 = $8 << 1;
       $11 = $12;
       $6 = $11 << 1 | $8 >>> 31;
       $15 = $6;
       $12 = sqlite3_realloc64($13, $16, $6);
       if ($12) {
        break label$3;
       }
       $9 = 7;
       break label$4;
      }
      $9 = 267;
      break label$4;
     }
     if ($4) {
      $8 = HEAP32[$7 + 12 >> 2];
      $6 = HEAP32[$7 + 8 >> 2];
      $0 = $6;
      $6 = $4;
      HEAP32[$6 >> 2] = $0;
      HEAP32[$6 + 4 >> 2] = $8;
     }
     $9 = 0;
     if (!$5) {
      break label$4;
     }
     $6 = HEAP32[$7 + 12 >> 2];
     $8 = HEAP32[$7 + 8 >> 2];
     $0 = $8;
     $8 = $5;
     HEAP32[$8 >> 2] = $0;
     HEAP32[$8 + 4 >> 2] = $6;
    }
    sqlite3_free($13);
    break label$1;
   }
   __memcpy($9 + $12 | 0, $3, $10);
   $13 = $12;
   $12 = $9 + $10 | 0;
   $9 = memcmp($0, $13, ($1 | 0) > ($12 | 0) ? $12 : $1);
   label$15: {
    if ($4) {
     if (($1 | 0) >= ($12 | 0) | $9 ? ($9 | 0) >= 0 : 0) {
      break label$15;
     }
     $8 = HEAP32[$7 + 12 >> 2];
     $6 = HEAP32[$7 + 8 >> 2];
     $11 = $6;
     $6 = $4;
     HEAP32[$6 >> 2] = $11;
     HEAP32[$6 + 4 >> 2] = $8;
    }
    $4 = 0;
    if (!$5 | ($9 | 0) >= 0) {
     break label$15;
    }
    $6 = HEAP32[$7 + 12 >> 2];
    $8 = HEAP32[$7 + 8 >> 2];
    $11 = $8;
    $8 = $5;
    HEAP32[$8 >> 2] = $11;
    HEAP32[$8 + 4 >> 2] = $6;
    $5 = 0;
   }
   $10 = $3 + $10 | 0;
   $6 = HEAP32[$7 + 8 >> 2];
   $11 = $6;
   $8 = HEAP32[$7 + 12 >> 2];
   $6 = $11 + 1 | 0;
   $8 = $6 ? $8 : $8 + 1 | 0;
   HEAP32[$7 + 8 >> 2] = $6;
   HEAP32[$7 + 12 >> 2] = $8;
   $3 = 1;
   continue;
  }
 }
 __stack_pointer = $7 + 16 | 0;
 return $9;
}

function sqlite3Fts3Snippet($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $7 = __stack_pointer - 160 | 0;
 __stack_pointer = $7;
 $18 = HEAP32[$1 >> 2];
 HEAP32[$7 + 152 >> 2] = 0;
 HEAP32[$7 + 144 >> 2] = 0;
 HEAP32[$7 + 148 >> 2] = 0;
 label$1: {
  if (!HEAP32[$1 + 16 >> 2]) {
   sqlite3_result_text($0, 29623, 0, 0);
   break label$1;
  }
  $6 = ($6 | 0) > -64 ? $6 : -64;
  $17 = ($6 | 0) < 64 ? $6 : 64;
  $19 = 0 - $17 | 0;
  $12 = 1;
  while (1) {
   HEAP32[$7 + 40 >> 2] = 0;
   HEAP32[$7 + 44 >> 2] = 0;
   $13 = $19;
   $13 = ($17 | 0) >= 0 ? (($12 + $17 | 0) - 1 | 0) / ($12 | 0) | 0 : $13;
   $14 = 0;
   $15 = 0;
   $16 = 0;
   label$5: {
    label$6: {
     while (1) {
      if (($12 | 0) != ($16 | 0)) {
       $10 = ($7 + 48 | 0) + Math_imul($16, 24) | 0;
       $8 = $10;
       HEAP32[$8 >> 2] = 0;
       HEAP32[$8 + 4 >> 2] = 0;
       HEAP32[$8 + 16 >> 2] = 0;
       HEAP32[$8 + 20 >> 2] = 0;
       HEAP32[$8 + 8 >> 2] = 0;
       HEAP32[$8 + 12 >> 2] = 0;
       $6 = 0;
       $8 = -1;
       while (1) {
        if (HEAP32[$18 + 24 >> 2] > ($6 | 0)) {
         HEAP32[$7 + 32 >> 2] = 0;
         HEAP32[$7 + 36 >> 2] = 0;
         HEAP32[$7 + 24 >> 2] = 0;
         HEAP32[$7 + 28 >> 2] = 0;
         HEAP32[$7 + 16 >> 2] = 0;
         HEAP32[$7 + 20 >> 2] = 0;
         HEAP32[$7 + 12 >> 2] = 0;
         label$11: {
          if (($5 | 0) != ($6 | 0) & ($5 | 0) >= 0) {
           break label$11;
          }
          $9 = $15;
          $11 = fts3BestSnippet($13, $1, $6, $14, $9, $7 + 40 | 0, $7 + 16 | 0, $7 + 12 | 0);
          if ($11) {
           break label$6;
          }
          $11 = HEAP32[$7 + 12 >> 2];
          if (($8 | 0) >= ($11 | 0)) {
           break label$11;
          }
          $8 = HEAP32[$7 + 20 >> 2];
          $9 = HEAP32[$7 + 16 >> 2];
          HEAP32[$10 >> 2] = $9;
          HEAP32[$10 + 4 >> 2] = $8;
          $9 = HEAP32[$7 + 36 >> 2];
          $8 = HEAP32[$7 + 32 >> 2];
          $20 = $8;
          $8 = $10;
          HEAP32[$8 + 16 >> 2] = $20;
          HEAP32[$8 + 20 >> 2] = $9;
          $8 = HEAP32[$7 + 28 >> 2];
          $9 = HEAP32[$7 + 24 >> 2];
          HEAP32[$10 + 8 >> 2] = $9;
          HEAP32[$10 + 12 >> 2] = $8;
          $8 = $11;
         }
         $6 = $6 + 1 | 0;
         continue;
        }
        break;
       }
       $16 = $16 + 1 | 0;
       $8 = HEAP32[$10 + 8 >> 2];
       $14 = $14 | $8;
       $9 = HEAP32[$10 + 12 >> 2];
       $8 = $15;
       $8 = $9 | $8;
       $15 = $8;
       continue;
      }
      break;
     }
     $9 = $14;
     $8 = HEAP32[$7 + 40 >> 2];
     $6 = ($9 | 0) != ($8 | 0);
     $8 = HEAP32[$7 + 44 >> 2];
     if (($6 | ($8 | 0) != ($15 | 0)) & ($12 | 0) != 4) {
      break label$5;
     }
     $5 = $12 - 1 | 0;
     $11 = 0;
     $6 = 0;
     while (1) {
      if ($6 >>> 0 >= $12 >>> 0 | $11) {
       break label$6;
      }
      $11 = fts3SnippetText($1, ($7 + 48 | 0) + Math_imul($6, 24) | 0, $6, ($5 | 0) == ($6 | 0), $13, $2, $3, $4, $7 + 144 | 0);
      $6 = $6 + 1 | 0;
      continue;
     }
    }
    sqlite3Fts3SegmentsClose($18);
    if ($11) {
     sqlite3_result_error_code($0, $11);
     sqlite3_free(HEAP32[$7 + 144 >> 2]);
     break label$1;
    }
    sqlite3_result_text($0, HEAP32[$7 + 144 >> 2], -1, 3);
    break label$1;
   }
   $12 = $12 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $7 + 160 | 0;
}

function generateWithRecursiveQuery($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $9 = __stack_pointer - 32 | 0;
 __stack_pointer = $9;
 label$1: {
  if (HEAP32[$1 + 68 >> 2]) {
   sqlite3ErrorMsg($0, 5509, 0);
   break label$1;
  }
  $5 = HEAP32[$0 + 8 >> 2];
  $3 = HEAP32[$1 + 32 >> 2];
  $11 = HEAP32[HEAP32[$1 + 28 >> 2] >> 2];
  if (sqlite3AuthCheck($0, 33, 0, 0, 0)) {
   break label$1;
  }
  $10 = sqlite3VdbeMakeLabel($0);
  HEAP16[$1 + 2 >> 1] = 320;
  computeLimitRegisters($0, $1, $10);
  $15 = HEAP32[$1 + 60 >> 2];
  HEAP32[$1 + 60 >> 2] = 0;
  $16 = HEAP32[$1 + 12 >> 2];
  $14 = HEAP32[$1 + 8 >> 2];
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 0;
  $4 = HEAP32[$3 >> 2];
  $4 = ($4 | 0) > 0 ? $4 : 0;
  $8 = HEAP32[$1 + 48 >> 2];
  while (1) {
   label$4: {
    if (($6 | 0) == ($4 | 0)) {
     $12 = 0;
    } else {
     if (!(HEAPU8[(($6 << 6) + $3 | 0) + 45 | 0] & 64)) {
      break label$4;
     }
     $12 = HEAP32[(($6 << 6) + $3 | 0) + 48 >> 2];
    }
    $7 = HEAP32[$0 + 40 >> 2];
    $6 = $7 + 1 | 0;
    HEAP32[$0 + 40 >> 2] = $6;
    label$7: {
     if (HEAPU8[$1 | 0] == 134) {
      HEAP32[$0 + 40 >> 2] = $7 + 2;
      $3 = $8 ? 6 : 5;
      break label$7;
     }
     $6 = 0;
     $3 = $8 ? 7 : 8;
    }
    sqlite3SelectDestInit($9, $3, $7);
    $13 = HEAP32[$0 + 44 >> 2] + 1 | 0;
    HEAP32[$0 + 44 >> 2] = $13;
    sqlite3VdbeAddOp3($5, 121, $12, $13, $11);
    label$9: {
     if ($8) {
      $3 = multiSelectOrderByKeyInfo($0, $1);
      sqlite3VdbeAddOp4($5, 118, $7, HEAP32[$8 >> 2] + 2 | 0, 0, $3, -8);
      HEAP32[$9 + 24 >> 2] = $8;
      break label$9;
     }
     sqlite3VdbeAddOp2($5, 118, $7, $11);
    }
    label$11: {
     if (!$6) {
      $4 = HEAP32[$1 + 4 >> 2];
      break label$11;
     }
     HEAP32[$1 + 20 >> 2] = sqlite3VdbeAddOp2($5, 118, $6, 0);
     $4 = HEAP32[$1 + 4 >> 2] | 32;
     HEAP32[$1 + 4 >> 2] = $4;
    }
    HEAP32[$1 + 48 >> 2] = 0;
    $3 = $1;
    label$13: {
     while (1) {
      $6 = $3;
      if ($4 & 8) {
       sqlite3ErrorMsg($0, 14769, 0);
       break label$13;
      }
      HEAP8[$6 | 0] = 135;
      $3 = HEAP32[$6 + 52 >> 2];
      $4 = HEAP32[$3 + 4 >> 2];
      if ($4 & 8192) {
       continue;
      }
      break;
     }
     HEAP32[$3 + 56 >> 2] = 0;
     sqlite3VdbeExplain($0, 1, 19354, 0);
     $4 = sqlite3Select($0, $3, $9);
     HEAP32[$3 + 56 >> 2] = $1;
     if ($4) {
      break label$13;
     }
     $11 = sqlite3VdbeAddOp2($5, 35, $7, $10);
     sqlite3VdbeAddOp1($5, 136, $12);
     label$16: {
      if ($8) {
       sqlite3VdbeAddOp3($5, 94, $7, HEAP32[$8 >> 2] + 1 | 0, $13);
       break label$16;
      }
      sqlite3VdbeAddOp2($5, 134, $7, $13);
     }
     sqlite3VdbeAddOp1($5, 130, $7);
     $4 = sqlite3VdbeMakeLabel($0);
     codeOffset($5, $16, $4);
     selectInnerLoop($0, $1, $12, 0, 0, $2, $4, $10);
     if ($14) {
      sqlite3VdbeAddOp2($5, 60, $14, $10);
     }
     sqlite3VdbeResolveLabel($5, $4);
     HEAP32[$6 + 52 >> 2] = 0;
     sqlite3VdbeExplain($0, 1, 19366, 0);
     sqlite3Select($0, $1, $9);
     HEAP32[$6 + 52 >> 2] = $3;
     sqlite3VdbeGoto($5, $11);
     sqlite3VdbeResolveLabel($5, $10);
    }
    sqlite3ExprListDelete(HEAP32[$0 >> 2], HEAP32[$1 + 48 >> 2]);
    HEAP32[$1 + 60 >> 2] = $15;
    HEAP32[$1 + 48 >> 2] = $8;
    break label$1;
   }
   $6 = $6 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $9 + 32 | 0;
}

function windowCodeOp($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $4 = HEAP32[$0 + 8 >> 2];
 $5 = HEAP32[$0 + 4 >> 2];
 $6 = HEAPU8[$5 + 16 | 0];
 $8 = HEAP32[$0 >> 2];
 $9 = sqlite3VdbeMakeLabel($8);
 if (!(($1 | 0) == 2 & HEAPU8[$5 + 17 | 0] == 90)) {
  label$3: {
   label$4: {
    if (($2 | 0) <= 0) {
     break label$4;
    }
    if (HEAPU8[$5 + 16 | 0] == 89) {
     $11 = sqlite3VdbeCurrentAddr($4);
     if (($1 | 0) == 2) {
      if (HEAPU8[$5 + 17 | 0] == 86) {
       windowCodeRangeTest($0, 55, HEAP32[$0 + 40 >> 2], $2, HEAP32[$0 + 32 >> 2], $9);
       break label$3;
      }
      windowCodeRangeTest($0, 57, HEAP32[$0 + 32 >> 2], $2, HEAP32[$0 + 40 >> 2], $9);
      break label$3;
     }
     windowCodeRangeTest($0, 54, HEAP32[$0 + 48 >> 2], $2, HEAP32[$0 + 40 >> 2], $9);
     break label$4;
    }
    sqlite3VdbeAddOp3($4, 49, $2, $9, 1);
   }
   if (HEAP32[$5 + 88 >> 2] | ($1 | 0) != 1) {
    break label$3;
   }
   windowAggFinal($0, 0);
  }
  $12 = sqlite3VdbeCurrentAddr($4);
  if (!(!$2 | HEAPU8[$5 + 17 | 0] != HEAPU8[$5 + 18 | 0] | HEAPU8[$5 + 16 | 0] != 89)) {
   $2 = sqlite3GetTempReg($8);
   $7 = sqlite3GetTempReg($8);
   label$9: {
    label$10: {
     if (($1 | 0) == 2) {
      sqlite3VdbeAddOp2($4, 135, HEAP32[$0 + 32 >> 2], $2);
      sqlite3VdbeAddOp2($4, 135, HEAP32[$0 + 48 >> 2], $7);
      $10 = $7;
      break label$10;
     }
     if (!HEAP32[$0 + 28 >> 2]) {
      break label$9;
     }
     sqlite3VdbeAddOp2($4, 135, HEAP32[$0 + 48 >> 2], $2);
     $10 = HEAP32[$0 + 28 >> 2];
    }
    sqlite3VdbeAddOp3($4, 57, $10, $9, $2);
   }
   sqlite3ReleaseTempReg($8, $2);
   sqlite3ReleaseTempReg($8, $7);
  }
  label$12: {
   label$13: {
    switch ($1 - 1 | 0) {
    case 0:
     $10 = HEAP32[$0 + 44 >> 2];
     $2 = HEAP32[$0 + 40 >> 2];
     windowReturnOneRow($0);
     break label$12;

    case 1:
     $10 = HEAP32[$0 + 36 >> 2];
     $2 = HEAP32[$0 + 32 >> 2];
     $7 = HEAP32[$5 + 88 >> 2];
     if ($7) {
      sqlite3VdbeAddOp2($4, 86, $7, 1);
      break label$12;
     }
     windowAggStep($0, $5, $2, 1, HEAP32[$0 + 20 >> 2]);
     break label$12;

    default:
     break label$13;
    }
   }
   $10 = HEAP32[$0 + 52 >> 2];
   $2 = HEAP32[$0 + 48 >> 2];
   if (HEAP32[$5 + 88 >> 2]) {
    sqlite3VdbeAddOp2($4, 86, HEAP32[$5 + 92 >> 2], 1);
    break label$12;
   }
   windowAggStep($0, $5, $2, 0, HEAP32[$0 + 20 >> 2]);
  }
  if (HEAP32[$0 + 24 >> 2] == ($1 | 0)) {
   sqlite3VdbeAddOp1($4, 130, $2);
   sqlite3VdbeChangeP5($4, 2);
  }
  $1 = sqlite3VdbeCurrentAddr($4);
  label$19: {
   label$20: {
    if (!$3) {
     $3 = ($6 & 255) == 76;
     sqlite3VdbeAddOp2($4, 38, $2, ($3 ? 1 : 2) + $1 | 0);
     $7 = 0;
     if ($3) {
      break label$19;
     }
     sqlite3VdbeAddOp2($4, 8, 0, $9);
     break label$20;
    }
    sqlite3VdbeAddOp2($4, 38, $2, $1 + 2 | 0);
    $7 = sqlite3VdbeAddOp0($4, 8);
    if (($6 & 255) == 76) {
     break label$19;
    }
   }
   $3 = 0;
   $6 = HEAP32[$5 + 12 >> 2];
   $1 = 0;
   label$22: {
    if (!$6) {
     break label$22;
    }
    $6 = HEAP32[$6 >> 2];
    $1 = 0;
    if (!$6) {
     break label$22;
    }
    $3 = $6;
    $1 = sqlite3GetTempRange($8, $6);
   }
   windowReadPeerValues($0, $2, $1);
   windowIfNewPeer($8, HEAP32[$5 + 12 >> 2], $1, $10, $12);
   sqlite3ReleaseTempRange($8, $1, $3);
  }
  if ($11) {
   sqlite3VdbeAddOp2($4, 8, 0, $11);
  }
  sqlite3VdbeResolveLabel($4, $9);
 }
 return $7;
}

function sqlite3Fts3UpdateMethod($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 8 >> 2] = 0;
 label$1: {
  label$2: {
   if (($1 | 0) < 2) {
    break label$2;
   }
   $8 = HEAP32[$0 + 24 >> 2];
   label$3: {
    if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
     break label$3;
    }
    $4 = HEAP32[(($8 << 2) + $2 | 0) + 8 >> 2];
    if ((sqlite3_value_type($4) | 0) == 5) {
     break label$3;
    }
    HEAP32[$5 + 12 >> 2] = fts3SpecialInsert($0, $4);
    $8 = 0;
    break label$1;
   }
   if ((sqlite3_value_int(HEAP32[(($8 << 2) + $2 | 0) + 16 >> 2]) | 0) >= 0) {
    break label$2;
   }
   HEAP32[$5 + 12 >> 2] = 19;
   $8 = 0;
   break label$1;
  }
  $7 = HEAP32[$0 + 24 >> 2];
  $9 = $7 >> 31;
  $6 = $7;
  $7 = $9 << 3 | $7 >>> 29;
  $9 = $6 << 3;
  $6 = $7;
  $7 = $9 + 8 | 0;
  $6 = $7 >>> 0 < 8 ? $6 + 1 | 0 : $6;
  $8 = sqlite3_malloc64($7, $6);
  if (!$8) {
   HEAP32[$5 + 12 >> 2] = 7;
   $8 = 0;
   break label$1;
  }
  $10 = HEAP32[$0 + 24 >> 2] + 1 | 0;
  $11 = memset($8, 0, $10 << 3);
  $4 = fts3Writelock($0);
  HEAP32[$5 + 12 >> 2] = $4;
  if ($4) {
   break label$1;
  }
  label$5: {
   if (HEAP32[$0 + 40 >> 2] | ($1 | 0) < 2) {
    break label$5;
   }
   $4 = HEAP32[((HEAP32[$0 + 24 >> 2] << 2) + $2 | 0) + 12 >> 2];
   if ((sqlite3_value_type($4) | 0) == 5) {
    $4 = HEAP32[$2 + 4 >> 2];
   }
   if ((sqlite3_value_type($4) | 0) == 5) {
    break label$5;
   }
   $6 = HEAP32[$2 >> 2];
   if ((sqlite3_value_type($6) | 0) != 5) {
    $6 = sqlite3_value_int64($6);
    $9 = i64toi32_i32$HIGH_BITS;
    $7 = $9;
    $9 = sqlite3_value_int64($4);
    $12 = ($6 | 0) == ($9 | 0);
    $6 = i64toi32_i32$HIGH_BITS;
    $9 = $6;
    $6 = $7;
    if ($12 & ($9 | 0) == ($6 | 0)) {
     break label$5;
    }
   }
   label$8: {
    if ((sqlite3_vtab_on_conflict(HEAP32[$0 + 12 >> 2]) | 0) == 5) {
     $4 = fts3DeleteByRowid($0, $4, $5 + 8 | 0, $11);
     break label$8;
    }
    $13 = 1;
    $4 = fts3InsertData($0, $2, $3);
   }
   HEAP32[$5 + 12 >> 2] = $4;
   if ($4) {
    break label$1;
   }
  }
  $4 = 1;
  $10 = $10 << 2;
  $10 = $11 + $10 | 0;
  $6 = HEAP32[$2 >> 2];
  if ((sqlite3_value_type($6) | 0) != 5) {
   $4 = fts3DeleteByRowid($0, $6, $5 + 8 | 0, $11);
   HEAP32[$5 + 12 >> 2] = $4;
   $4 = !$4;
  }
  if (!(!$4 | ($1 | 0) < 2)) {
   $1 = sqlite3_value_int(HEAP32[((HEAP32[$0 + 24 >> 2] << 2) + $2 | 0) + 16 >> 2]);
   label$12: {
    label$13: {
     if ($13) {
      break label$13;
     }
     $4 = fts3InsertData($0, $2, $3);
     HEAP32[$5 + 12 >> 2] = $4;
     if (!$4) {
      break label$13;
     }
     if (HEAP32[$0 + 40 >> 2] | ($4 | 0) != 19) {
      break label$12;
     }
     HEAP32[$5 + 12 >> 2] = 267;
     break label$12;
    }
    $7 = HEAP32[$3 >> 2];
    $6 = HEAP32[$3 + 4 >> 2];
    $3 = fts3PendingTermsDocid($0, 0, $1, $7, $6);
    HEAP32[$5 + 12 >> 2] = $3;
    if ($3) {
     break label$12;
    }
    HEAP32[$5 + 12 >> 2] = fts3InsertTerms($0, $1, $2, $10);
   }
   if (HEAPU8[$0 + 238 | 0]) {
    fts3InsertDocsize($5 + 12 | 0, $0, $10);
   }
   HEAP32[$5 + 8 >> 2] = HEAP32[$5 + 8 >> 2] + 1;
  }
  if (!HEAPU8[$0 + 236 | 0]) {
   break label$1;
  }
  fts3UpdateDocTotals($5 + 12 | 0, $0, $10, $11, HEAP32[$5 + 8 >> 2]);
 }
 sqlite3_free($8);
 sqlite3Fts3SegmentsClose($0);
 __stack_pointer = $5 + 16 | 0;
 $0 = HEAP32[$5 + 12 >> 2];
 return $0;
}

function fts3SnippetText($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $9 = __stack_pointer - 48 | 0;
 __stack_pointer = $9;
 $16 = HEAP32[$0 >> 2];
 HEAP32[$9 + 44 >> 2] = 0;
 HEAP32[$9 + 40 >> 2] = HEAP32[$1 + 4 >> 2];
 $13 = HEAP32[$1 + 20 >> 2];
 $10 = HEAP32[$1 + 16 >> 2];
 HEAP32[$9 + 32 >> 2] = $10;
 HEAP32[$9 + 36 >> 2] = $13;
 $1 = HEAP32[$1 >> 2] + 1 | 0;
 $14 = sqlite3_column_text(HEAP32[$0 + 12 >> 2], $1);
 $11 = HEAP32[$0 + 12 >> 2];
 label$1: {
  if (!$14) {
   $1 = (sqlite3_column_type($11, $1) | 0) == 5 ? 0 : 7;
   break label$1;
  }
  $17 = sqlite3_column_bytes($11, $1);
  $1 = HEAP32[$16 + 36 >> 2];
  $18 = HEAP32[$1 >> 2];
  $1 = sqlite3Fts3OpenTokenizer($1, HEAP32[$0 + 20 >> 2], $14, $17, $9 + 28 | 0);
  if ($1) {
   break label$1;
  }
  $19 = HEAP32[$9 + 28 >> 2];
  $20 = ($2 | 0) > 0;
  $1 = 0;
  label$3: {
   while (1) {
    if ($1) {
     break label$3;
    }
    HEAP32[$9 + 20 >> 2] = -1;
    HEAP32[$9 + 16 >> 2] = 0;
    HEAP32[$9 + 12 >> 2] = 0;
    $1 = FUNCTION_TABLE[HEAP32[$18 + 20 >> 2]]($19, $9 + 24 | 0, $9 + 20 | 0, $9 + 16 | 0, $9 + 12 | 0, $9 + 44 | 0) | 0;
    if ($1) {
     if (($1 | 0) != 101) {
      break label$3;
     }
     $1 = fts3StringAppend($8, $14 + $15 | 0, -1);
     break label$3;
    }
    $1 = 0;
    $2 = HEAP32[$9 + 44 >> 2];
    $11 = HEAP32[$9 + 40 >> 2];
    if (($2 | 0) < ($11 | 0)) {
     continue;
    }
    if (!$12) {
     $12 = 1;
     $11 = HEAP32[$9 + 16 >> 2];
     $11 = fts3SnippetShift($16, HEAP32[$0 + 20 >> 2], $4, $14 + $11 | 0, $17 - $11 | 0, $9 + 40 | 0, $9 + 32 | 0);
     if ($11) {
      $1 = $11;
      continue;
     }
     label$8: {
      $11 = HEAP32[$9 + 40 >> 2];
      label$9: {
       if (!(!$20 & ($11 | 0) <= 0)) {
        $2 = fts3StringAppend($8, $7, -1);
        break label$9;
       }
       $2 = HEAP32[$9 + 16 >> 2];
       if (!$2) {
        break label$8;
       }
       $2 = fts3StringAppend($8, $14, $2);
      }
      if (!$2) {
       break label$8;
      }
      $1 = $2;
      continue;
     }
     $2 = HEAP32[$9 + 44 >> 2];
     if (($11 | 0) > ($2 | 0)) {
      continue;
     }
    }
    label$11: {
     if (($4 + $11 | 0) <= ($2 | 0)) {
      if ($3) {
       break label$11;
      }
      break label$3;
     }
     $10 = $2 - $11 | 0;
     $12 = $10 & 31;
     if (($10 & 63) >>> 0 >= 32) {
      $10 = 1 << $12;
      $13 = 0;
     } else {
      $10 = (1 << $12) - 1 & 1 >>> 32 - $12;
      $13 = 1 << $12;
     }
     $12 = $10;
     $10 = HEAP32[$9 + 32 >> 2];
     $13 = $13 & $10;
     $10 = HEAP32[$9 + 36 >> 2];
     $10 = $12 & $10;
     $12 = $10;
     $10 = !($10 | $13);
     if (($2 | 0) > ($11 | 0)) {
      $1 = fts3StringAppend($8, $14 + $15 | 0, HEAP32[$9 + 16 >> 2] - $15 | 0);
     }
     if (!($1 | $10)) {
      $1 = fts3StringAppend($8, $5, -1);
     }
     label$15: {
      if ($1) {
       break label$15;
      }
      $1 = HEAP32[$9 + 16 >> 2];
      $1 = fts3StringAppend($8, $14 + $1 | 0, HEAP32[$9 + 12 >> 2] - $1 | 0);
      $10 = $12;
      if ($1 | !($10 | $13)) {
       break label$15;
      }
      $1 = fts3StringAppend($8, $6, -1);
     }
     $12 = 1;
     $15 = HEAP32[$9 + 12 >> 2];
     continue;
    }
    break;
   }
   $1 = fts3StringAppend($8, $7, -1);
  }
  FUNCTION_TABLE[HEAP32[$18 + 16 >> 2]]($19) | 0;
 }
 __stack_pointer = $9 + 48 | 0;
 return $1;
}

function renameResolveTrigger($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $5 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 244 >> 2];
 HEAP32[$2 + 28 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 24 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 >> 2] = $0;
 $1 = sqlite3FindTable($5, HEAP32[$3 + 4 >> 2], HEAP32[HEAP32[$5 + 16 >> 2] + (sqlite3SchemaToIndex($5, HEAP32[$3 + 24 >> 2]) << 4) >> 2]);
 HEAP32[$0 + 120 >> 2] = $1;
 HEAP8[$0 + 148 | 0] = HEAPU8[$3 + 8 | 0];
 label$1: {
  if ($1) {
   $1 = sqlite3ViewGetColumnNames($0, $1);
   if ($1) {
    break label$1;
   }
  }
  $1 = 0;
  $4 = HEAP32[$3 + 12 >> 2];
  if (!$4) {
   break label$1;
  }
  $1 = sqlite3ResolveExprNames($2, $4);
 }
 $3 = $3 + 28 | 0;
 while (1) {
  label$4: {
   if ($1) {
    break label$4;
   }
   $4 = HEAP32[$3 >> 2];
   if (!$4) {
    break label$4;
   }
   $1 = HEAP32[$4 + 8 >> 2];
   label$5: {
    label$6: {
     if (!$1) {
      break label$6;
     }
     sqlite3SelectPrep($0, $1, $2);
     if (!HEAP32[$0 + 36 >> 2]) {
      break label$6;
     }
     $1 = HEAP32[$0 + 12 >> 2];
     if ($1) {
      break label$5;
     }
    }
    if (!HEAP32[$4 + 12 >> 2]) {
     $1 = 0;
     break label$5;
    }
    $6 = sqlite3TriggerStepSrc($0, $4);
    if (!$6) {
     $1 = 7;
     break label$5;
    }
    $1 = sqlite3SelectNew($0, HEAP32[$4 + 24 >> 2], $6, 0, 0, 0, 0, 0, 0);
    label$9: {
     if (!$1) {
      $6 = 0;
      HEAP32[$4 + 24 >> 2] = 0;
      $7 = 7;
      break label$9;
     }
     sqlite3SelectPrep($0, $1, 0);
     $3 = HEAP32[$0 + 36 >> 2];
     if (HEAP32[$4 + 24 >> 2]) {
      HEAP32[$1 + 28 >> 2] = 0;
     }
     HEAP32[$1 + 32 >> 2] = 0;
     sqlite3SelectDelete($5, $1);
     $7 = ($3 | 0) != 0;
    }
    label$12: {
     $3 = HEAP32[$4 + 16 >> 2];
     if (!$3) {
      break label$12;
     }
     $1 = 0;
     if ($7) {
      break label$12;
     }
     while (1) {
      if (HEAP32[$3 >> 2] <= ($1 | 0)) {
       break label$12;
      }
      $8 = HEAP32[(($1 << 6) + $3 | 0) + 28 >> 2];
      if ($8) {
       sqlite3SelectPrep($0, $8, 0);
       $3 = HEAP32[$4 + 16 >> 2];
      }
      $1 = $1 + 1 | 0;
      continue;
     }
    }
    $1 = HEAPU8[$5 + 87 | 0];
    HEAP32[$2 + 4 >> 2] = $6;
    $1 = $1 ? 7 : $7;
    label$15: {
     if ($1) {
      break label$15;
     }
     $1 = HEAP32[$4 + 20 >> 2];
     if ($1) {
      $1 = sqlite3ResolveExprNames($2, $1);
      if ($1) {
       break label$15;
      }
     }
     $1 = sqlite3ResolveExprListNames($2, HEAP32[$4 + 24 >> 2]);
    }
    $3 = HEAP32[$4 + 32 >> 2];
    if (!(!$3 | $1)) {
     HEAP32[$3 + 32 >> 2] = $6;
     HEAP32[$2 + 24 >> 2] = 512;
     HEAP32[$2 + 8 >> 2] = $3;
     $1 = sqlite3ResolveExprListNames($2, HEAP32[$3 >> 2]);
     label$18: {
      if ($1) {
       break label$18;
      }
      $1 = sqlite3ResolveExprListNames($2, HEAP32[$3 + 8 >> 2]);
      if ($1) {
       break label$18;
      }
      $1 = sqlite3ResolveExprNames($2, HEAP32[$3 + 12 >> 2]);
      if ($1) {
       break label$18;
      }
      $1 = sqlite3ResolveExprNames($2, HEAP32[$3 + 4 >> 2]);
     }
     HEAP32[$2 + 24 >> 2] = 0;
    }
    HEAP32[$2 + 4 >> 2] = 0;
    sqlite3SrcListDelete($5, $6);
   }
   $3 = $4 + 40 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 32 | 0;
 return $1;
}

function walBeginShmUnreliable($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 $6 = walLockShared($0, 3);
 label$1: {
  if ($6) {
   $3 = ($6 | 0) == 5 ? -1 : $6;
   $6 = 0;
   break label$1;
  }
  $6 = 0;
  HEAP16[$0 + 40 >> 1] = 0;
  label$3: {
   label$4: {
    $3 = sqlite3OsShmMap(HEAP32[$0 + 4 >> 2], 0, 0, $5 + 12 | 0);
    if (($3 | 0) != 8) {
     if (($3 | 0) != 1288) {
      break label$1;
     }
     __memcpy($0 + 52 | 0, walIndexHdr($0), 48);
     $3 = sqlite3OsFileSize(HEAP32[$0 + 8 >> 2], $5 + 56 | 0);
     if ($3) {
      break label$1;
     }
     $4 = HEAP32[$5 + 56 >> 2];
     $2 = $4;
     $7 = HEAP32[$5 + 60 >> 2];
     if (($7 | 0) <= 0 & $2 >>> 0 <= 31 | ($7 | 0) < 0) {
      HEAP32[$1 >> 2] = 1;
      $3 = HEAP32[$0 + 68 >> 2] ? -1 : 0;
      break label$1;
     }
     $3 = sqlite3OsRead(HEAP32[$0 + 8 >> 2], $5 + 16 | 0, 32, 0, 0);
     if ($3) {
      break label$1;
     }
     $3 = -1;
     $7 = HEAPU8[$0 + 88 | 0] | HEAPU8[$0 + 89 | 0] << 8 | (HEAPU8[$0 + 90 | 0] << 16 | HEAPU8[$0 + 91 | 0] << 24);
     $10 = $7;
     $7 = HEAP32[$5 + 32 >> 2];
     $4 = $7;
     $2 = HEAPU8[$0 + 84 | 0] | HEAPU8[$0 + 85 | 0] << 8 | (HEAPU8[$0 + 86 | 0] << 16 | HEAPU8[$0 + 87 | 0] << 24);
     $8 = $2;
     $2 = HEAP32[$5 + 36 >> 2];
     $7 = $2;
     $2 = $10;
     if (($4 | 0) != ($8 | 0) | ($7 | 0) != ($2 | 0)) {
      break label$1;
     }
     $9 = HEAP32[$0 + 36 >> 2] + 24 | 0;
     $2 = $9;
     $8 = $2 >> 31;
     $9 = $2;
     $12 = $8;
     $6 = sqlite3_malloc64($2, $8);
     if (!$6) {
      $3 = 7;
      $6 = 0;
      break label$1;
     }
     $8 = HEAP32[$0 + 68 >> 2];
     $8 = __wasm_i64_mul($8, 0, HEAP32[$0 + 36 >> 2] + 24 | 0, 0);
     $4 = $8;
     $2 = i64toi32_i32$HIGH_BITS;
     $4 = $4 + 32 | 0;
     $2 = $4 >>> 0 < 32 ? $2 + 1 | 0 : $2;
     $3 = $4;
     $10 = $2;
     $13 = $6 + 24 | 0;
     $14 = HEAP32[$0 + 80 >> 2];
     $15 = HEAP32[$0 + 76 >> 2];
     while (1) {
      $4 = $12;
      $2 = $10;
      $4 = $4 + $2 | 0;
      $7 = $9;
      $2 = $3;
      $8 = $7 + $2 | 0;
      $4 = $8 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
      $11 = $4;
      $2 = HEAP32[$5 + 60 >> 2];
      $16 = $2;
      $4 = HEAP32[$5 + 56 >> 2];
      $7 = $4;
      $2 = $11;
      $4 = $16;
      if ($7 >>> 0 < $8 >>> 0 & ($2 | 0) >= ($4 | 0) | ($2 | 0) > ($4 | 0)) {
       break label$4;
      }
      $2 = $10;
      $3 = sqlite3OsRead(HEAP32[$0 + 8 >> 2], $6, $9, $3, $2);
      if ($3) {
       break label$3;
      }
      if (!walDecodeFrame($0, $5 + 8 | 0, $5 + 4 | 0, $13, $6)) {
       break label$4;
      }
      if (HEAP32[$5 + 4 >> 2]) {
       $3 = -1;
       break label$3;
      } else {
       $3 = $8;
       $2 = $11;
       $10 = $2;
       continue;
      }
     }
    }
    $3 = -1;
    break label$1;
   }
   $3 = 0;
  }
  HEAP32[$0 + 80 >> 2] = $14;
  HEAP32[$0 + 76 >> 2] = $15;
 }
 sqlite3_free($6);
 if ($3) {
  $6 = 0;
  while (1) {
   if (($6 | 0) < HEAP32[$0 + 24 >> 2]) {
    $9 = $6 << 2;
    sqlite3_free(HEAP32[$9 + HEAP32[$0 + 32 >> 2] >> 2]);
    HEAP32[HEAP32[$0 + 32 >> 2] + $9 >> 2] = 0;
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$0 + 50 | 0] = 0;
  sqlite3WalEndReadTransaction($0);
  HEAP32[$1 >> 2] = 1;
 }
 __stack_pointer = $5 - -64 | 0;
 return $3;
}

function sqlite3FkLocateIndex($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 $12 = HEAP32[$2 + 40 >> 2];
 label$1: {
  label$2: {
   $7 = HEAP32[$2 + 20 >> 2];
   label$3: {
    label$4: {
     if (($7 | 0) == 1) {
      $4 = HEAP16[$1 + 32 >> 1];
      if (($4 | 0) < 0) {
       break label$4;
      }
      if (!$12) {
       break label$3;
      }
      if (sqlite3StrICmp(HEAP32[HEAP32[$1 + 4 >> 2] + Math_imul($4, 12) >> 2], $12)) {
       break label$4;
      }
      break label$1;
     }
     if (!$4) {
      break label$4;
     }
     $5 = sqlite3DbMallocRawNN(HEAP32[$0 >> 2], $7 << 2, 0);
     if (!$5) {
      break label$2;
     }
     HEAP32[$4 >> 2] = $5;
    }
    $13 = ($7 | 0) > 0 ? $7 : 0;
    $4 = $1 + 8 | 0;
    while (1) {
     label$8: {
      label$9: {
       label$10: {
        label$11: {
         $6 = HEAP32[$4 >> 2];
         if ($6) {
          if (HEAP32[$6 + 36 >> 2] | (!HEAPU8[$6 + 54 | 0] | HEAPU16[$6 + 50 >> 1] != ($7 | 0))) {
           break label$9;
          }
          if (!$12) {
           break label$11;
          }
          $8 = 0;
          label$13: while (1) {
           if (($8 | 0) == ($13 | 0)) {
            $8 = $13;
            break label$10;
           }
           $4 = HEAP16[HEAP32[$6 + 4 >> 2] + ($8 << 1) >> 1];
           if (($4 | 0) < 0) {
            break label$10;
           }
           $14 = $8 << 2;
           $10 = HEAP32[$14 + HEAP32[$6 + 32 >> 2] >> 2];
           $11 = HEAP32[$1 + 4 >> 2] + Math_imul($4 & 65535, 12) | 0;
           $4 = sqlite3ColumnColl($11);
           if (sqlite3StrICmp($10, $4 ? $4 : 32384)) {
            break label$10;
           }
           $11 = HEAP32[$11 >> 2];
           $4 = 0;
           while (1) {
            $10 = ($4 | 0) == ($7 | 0);
            if ($10) {
             break label$10;
            }
            $15 = ($4 << 3) + $2 | 0;
            if (sqlite3StrICmp(HEAP32[$15 + 40 >> 2], $11)) {
             $4 = $4 + 1 | 0;
             continue;
            } else {
             if ($5) {
              HEAP32[$5 + $14 >> 2] = HEAP32[$15 + 36 >> 2];
             }
             if ($10) {
              break label$10;
             }
             $8 = $8 + 1 | 0;
             continue label$13;
            }
           }
          }
         }
         if (!HEAPU8[$0 + 151 | 0]) {
          $4 = HEAP32[HEAP32[$2 >> 2] >> 2];
          HEAP32[$9 + 4 >> 2] = HEAP32[$2 + 8 >> 2];
          HEAP32[$9 >> 2] = $4;
          sqlite3ErrorMsg($0, 28373, $9);
         }
         sqlite3DbFree(HEAP32[$0 >> 2], $5);
         break label$2;
        }
        if (((HEAPU8[$6 + 55 | 0] | HEAPU8[$6 + 56 | 0] << 8) & 3) != 2) {
         break label$9;
        }
        if (!$5) {
         break label$8;
        }
        $4 = 0;
        while (1) {
         if (($4 | 0) == ($13 | 0)) {
          break label$8;
         }
         HEAP32[($4 << 2) + $5 >> 2] = HEAP32[(($4 << 3) + $2 | 0) + 36 >> 2];
         $4 = $4 + 1 | 0;
         continue;
        }
       }
       if (($8 | 0) == ($7 | 0)) {
        break label$8;
       }
      }
      $4 = $6 + 20 | 0;
      continue;
     }
     break;
    }
    HEAP32[$3 >> 2] = $6;
   }
   $5 = 0;
   break label$1;
  }
  $5 = 1;
 }
 __stack_pointer = $9 + 16 | 0;
 return $5;
}

function fts3FilterMethod($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $8 = __stack_pointer - 48 | 0;
 __stack_pointer = $8;
 $5 = 1;
 $6 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$6 + 56 >> 2]) {
   break label$1;
  }
  $10 = $1 & 65535;
  if ($10) {
   $11 = HEAP32[$4 >> 2];
   $7 = 1;
  } else {
   $7 = 0;
  }
  if ($1 & 65536) {
   $12 = HEAP32[($7 << 2) + $4 >> 2];
   $5 = $7 + 1 | 0;
  } else {
   $5 = $7;
  }
  $7 = 0;
  label$6: {
   if (!($1 & 131072)) {
    break label$6;
   }
   $9 = HEAP32[($5 << 2) + $4 >> 2];
   $5 = $5 + 1 | 0;
  }
  $7 = $1 & 262144 ? HEAP32[($5 << 2) + $4 >> 2] : $7;
  fts3ClearCursor($0);
  $4 = fts3DocidRange($9, 0, -2147483648);
  HEAP32[$0 + 72 >> 2] = $4;
  $3 = i64toi32_i32$HIGH_BITS;
  HEAP32[$0 + 76 >> 2] = $3;
  $3 = fts3DocidRange($7, -1, 2147483647);
  HEAP32[$0 + 80 >> 2] = $3;
  $4 = i64toi32_i32$HIGH_BITS;
  HEAP32[$0 + 84 >> 2] = $4;
  if ($2) {
   $5 = HEAPU8[$2 | 0] == 68;
  } else {
   $5 = HEAPU8[$6 + 239 | 0];
  }
  HEAP16[$0 + 4 >> 1] = $1;
  HEAP8[$0 + 52 | 0] = $5;
  if ($10 >>> 0 >= 2) {
   $4 = sqlite3_value_text($11);
   if (!$4) {
    $5 = 7;
    if ((sqlite3_value_type($11) | 0) != 5) {
     break label$1;
    }
   }
   $2 = $10 - 2 | 0;
   $5 = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   if ($12) {
    $5 = sqlite3_value_int($12);
    HEAP32[$0 + 20 >> 2] = $5;
   }
   $5 = sqlite3Fts3ExprParse(HEAP32[$6 + 36 >> 2], $5, HEAP32[$6 + 28 >> 2], HEAPU8[$6 + 236 | 0], HEAP32[$6 + 24 >> 2], $2, $4, $0 + 16 | 0, $6 + 8 | 0);
   if ($5) {
    break label$1;
   }
   $5 = fts3EvalStart($0);
   sqlite3Fts3SegmentsClose($6);
   if ($5) {
    break label$1;
   }
   HEAP32[$0 + 32 >> 2] = 0;
   HEAP32[$0 + 36 >> 2] = 0;
   HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 44 >> 2];
  }
  label$14: {
   label$15: {
    label$16: {
     switch ($1 & 65535) {
     case 0:
      $1 = HEAP32[$6 + 224 >> 2];
      label$18: {
       if ($7 | $9) {
        $4 = HEAP32[$0 + 72 >> 2];
        $7 = $4;
        $3 = HEAP32[$0 + 76 >> 2];
        $2 = $3;
        $5 = HEAPU8[$0 + 52 | 0];
        $4 = HEAP32[$0 + 84 >> 2];
        $3 = HEAP32[$0 + 80 >> 2];
        $9 = $3;
        $3 = $8;
        HEAP32[$3 + 16 >> 2] = $9;
        HEAP32[$3 + 20 >> 2] = $4;
        HEAP32[$3 + 24 >> 2] = $5 ? 19869 : 20283;
        HEAP32[$3 + 8 >> 2] = $7;
        $4 = $2;
        HEAP32[$3 + 12 >> 2] = $4;
        HEAP32[$3 >> 2] = $1;
        $1 = sqlite3_mprintf(6647, $3);
        break label$18;
       }
       $5 = HEAPU8[$0 + 52 | 0];
       HEAP32[$8 + 32 >> 2] = $1;
       HEAP32[$8 + 36 >> 2] = $5 ? 19869 : 20283;
       $1 = sqlite3_mprintf(6619, $8 + 32 | 0);
      }
      if (!$1) {
       $5 = 7;
       break label$1;
      }
      HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] + 1;
      $5 = sqlite3_prepare_v3(HEAP32[$6 + 12 >> 2], $1, -1, 1, $0 + 12 | 0, 0);
      HEAP32[$6 + 56 >> 2] = HEAP32[$6 + 56 >> 2] - 1;
      sqlite3_free($1);
      break label$15;

     case 1:
      break label$16;

     default:
      break label$14;
     }
    }
    $5 = fts3CursorSeekStmt($0);
    if ($5) {
     break label$1;
    }
    $5 = sqlite3_bind_value(HEAP32[$0 + 12 >> 2], 1, $11);
   }
   if ($5) {
    break label$1;
   }
  }
  $5 = fts3NextMethod($0);
 }
 __stack_pointer = $8 + 48 | 0;
 return $5 | 0;
}

function accessPayload($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $5 = HEAP32[$0 + 116 >> 2];
 label$1: {
  if (HEAPU16[$0 + 70 >> 1] >= HEAPU16[$5 + 24 >> 1]) {
   $1 = sqlite3CorruptError(71814);
   break label$1;
  }
  $10 = HEAP32[$0 + 20 >> 2];
  getCellInfo($0);
  $6 = HEAP32[$0 + 40 >> 2];
  $7 = HEAPU16[$0 + 48 >> 1];
  if ($6 - HEAP32[$5 + 56 >> 2] >>> 0 > HEAP32[$10 + 40 >> 2] - $7 >>> 0) {
   $1 = sqlite3CorruptError(71829);
   break label$1;
  }
  label$4: {
   if ($1 >>> 0 < $7 >>> 0) {
    $9 = $1 + $2 >>> 0 > $7 >>> 0 ? $7 - $1 | 0 : $2;
    $2 = $2 - $9 | 0;
    $11 = $3 + $9 | 0;
    $9 = copyPayload($1 + $6 | 0, $3, $9, $4, HEAP32[$5 + 72 >> 2]);
    $7 = 0;
    break label$4;
   }
   $11 = $3;
   $7 = $1 - $7 | 0;
  }
  $1 = $9;
  label$6: {
   if ($1 | !$2) {
    break label$6;
   }
   $1 = HEAP32[$10 + 40 >> 2];
   $5 = HEAPU16[$0 + 48 >> 1];
   HEAP32[$8 + 12 >> 2] = sqlite3Get4byte($6 + $5 | 0);
   $3 = $1 - 4 | 0;
   label$7: {
    if (!(HEAPU8[$0 + 1 | 0] & 4)) {
     $5 = ((HEAP32[$0 + 44 >> 2] + ($1 - $5 | 0) | 0) - 5 >>> 0) / ($3 >>> 0) | 0;
     $1 = HEAP32[$0 + 12 >> 2];
     label$9: {
      label$10: {
       if (!$1) {
        $1 = 0;
        break label$10;
       }
       $9 = sqlite3MallocSize($1);
       $1 = HEAP32[$0 + 12 >> 2];
       $6 = $5 << 2;
       if (($9 | 0) >= ($6 | 0)) {
        break label$9;
       }
      }
      $1 = sqlite3Realloc($1, $5 << 3, 0);
      if (!$1) {
       $1 = 7;
       break label$1;
      }
      HEAP32[$0 + 12 >> 2] = $1;
      $6 = $5 << 2;
     }
     $5 = 0;
     memset($1, 0, $6);
     HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] | 4;
     break label$7;
    }
    $5 = ($7 >>> 0) / ($3 >>> 0) | 0;
    $1 = HEAP32[HEAP32[$0 + 12 >> 2] + ($5 << 2) >> 2];
    if (!$1) {
     $5 = 0;
     break label$7;
    }
    HEAP32[$8 + 12 >> 2] = $1;
    $7 = $7 - Math_imul($3, $5) | 0;
   }
   $9 = !$4 << 1;
   while (1) {
    $1 = HEAP32[$8 + 12 >> 2];
    if (!$1) {
     $1 = 0;
     break label$6;
    }
    if (HEAPU32[$10 + 48 >> 2] < $1 >>> 0) {
     $1 = sqlite3CorruptError(71891);
     break label$1;
    }
    $6 = HEAP32[$0 + 12 >> 2];
    HEAP32[$6 + ($5 << 2) >> 2] = $1;
    label$17: {
     if ($3 >>> 0 <= $7 >>> 0) {
      $5 = $5 + 1 | 0;
      $6 = HEAP32[($5 << 2) + $6 >> 2];
      label$19: {
       if ($6) {
        HEAP32[$8 + 12 >> 2] = $6;
        $1 = 0;
        break label$19;
       }
       $1 = getOverflowPage($10, $1, 0, $8 + 12 | 0);
      }
      $7 = $7 - $3 | 0;
      break label$17;
     }
     $6 = $2 + $7 >>> 0 > $3 >>> 0 ? $3 - $7 | 0 : $2;
     $1 = sqlite3PagerGet(HEAP32[$10 >> 2], $1, $8 + 8 | 0, $9);
     if (!$1) {
      $1 = HEAP32[$8 + 8 >> 2];
      $12 = sqlite3PagerGetData($1);
      HEAP32[$8 + 12 >> 2] = sqlite3Get4byte($12);
      $1 = copyPayload(($7 + $12 | 0) + 4 | 0, $11, $6, $4, $1);
      sqlite3PagerUnref(HEAP32[$8 + 8 >> 2]);
      $7 = 0;
     }
     $2 = $2 - $6 | 0;
     if (!$2) {
      break label$1;
     }
     $5 = $5 + 1 | 0;
     $11 = $6 + $11 | 0;
    }
    if (!$1) {
     continue;
    }
    break;
   }
  }
  if (!$2 | $1) {
   break label$1;
  }
  $1 = sqlite3CorruptError(71976);
 }
 __stack_pointer = $8 + 16 | 0;
 return $1;
}

function windowAggStep($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $13 = $3 ? 161 : 162;
 $14 = 1 - $3 | 0;
 $15 = $4 + 1 | 0;
 $9 = HEAP32[$0 >> 2];
 $6 = sqlite3GetVdbe($9);
 $5 = $1;
 while (1) {
  if ($5) {
   $10 = HEAP32[$5 + 44 >> 2];
   $0 = 0;
   $8 = 0;
   if (!HEAPU8[$5 + 96 | 0]) {
    $8 = windowArgCount($5);
   }
   $7 = ($8 | 0) > 0 ? $8 : 0;
   while (1) {
    if (($0 | 0) != ($7 | 0)) {
     label$6: {
      if (!(($0 | 0) == 1 & HEAP32[$10 + 32 >> 2] == 48960)) {
       sqlite3VdbeAddOp3($6, 94, $2, HEAP32[$5 + 80 >> 2] + $0 | 0, $0 + $4 | 0);
       break label$6;
      }
      sqlite3VdbeAddOp3($6, 94, HEAP32[$1 + 48 >> 2], HEAP32[$5 + 80 >> 2] + 1 | 0, $15);
     }
     $0 = $0 + 1 | 0;
     continue;
    }
    break;
   }
   label$9: {
    if (!(HEAP32[$1 + 88 >> 2] | !(HEAPU8[$10 + 5 | 0] & 16) | HEAPU8[$5 + 17 | 0] == 90)) {
     $0 = sqlite3VdbeAddOp1($6, 50, $4);
     label$11: {
      if (!$3) {
       sqlite3VdbeAddOp2($6, 86, HEAP32[$5 + 64 >> 2] + 1 | 0, 1);
       sqlite3VdbeAddOp2($6, 81, $4, HEAP32[$5 + 64 >> 2]);
       $7 = HEAP32[$5 + 64 >> 2];
       sqlite3VdbeAddOp3($6, 97, $7, 2, $7 + 2 | 0);
       sqlite3VdbeAddOp2($6, 138, HEAP32[$5 + 60 >> 2], HEAP32[$5 + 64 >> 2] + 2 | 0);
       break label$11;
      }
      sqlite3VdbeAddOp4Int($6, 22, HEAP32[$5 + 60 >> 2], 0, $4, 1);
      sqlite3VdbeAddOp1($6, 130, HEAP32[$5 + 60 >> 2]);
      sqlite3VdbeJumpHere($6, sqlite3VdbeCurrentAddr($6) - 2 | 0);
     }
     sqlite3VdbeJumpHere($6, $0);
     break label$9;
    }
    $0 = HEAP32[$5 + 64 >> 2];
    if ($0) {
     sqlite3VdbeAddOp2($6, 86, $0 + $14 | 0, 1);
     break label$9;
    }
    if (HEAP32[$10 + 16 >> 2] == 86) {
     break label$9;
    }
    label$14: {
     if (!HEAP32[$5 + 40 >> 2]) {
      $12 = 0;
      break label$14;
     }
     $0 = sqlite3GetTempReg($9);
     sqlite3VdbeAddOp3($6, 94, $2, HEAP32[$5 + 80 >> 2] + $8 | 0, $0);
     $12 = sqlite3VdbeAddOp3($6, 16, $0, 0, 1);
     sqlite3ReleaseTempReg($9, $0);
    }
    $11 = $4;
    label$16: {
     if (!HEAPU8[$5 + 96 | 0]) {
      break label$16;
     }
     $0 = sqlite3VdbeCurrentAddr($6);
     $8 = HEAP32[HEAP32[HEAP32[$5 + 72 >> 2] + 20 >> 2] >> 2];
     $11 = sqlite3GetTempRange($9, $8);
     sqlite3ExprCodeExprList($9, HEAP32[HEAP32[$5 + 72 >> 2] + 20 >> 2], $11, 0, 0);
     $7 = sqlite3VdbeCurrentAddr($6);
     $16 = ($0 | 0) > ($7 | 0) ? $0 : $7;
     while (1) {
      if (($0 | 0) == ($16 | 0)) {
       break label$16;
      }
      $7 = sqlite3VdbeGetOp($6, $0);
      if (!(HEAPU8[$7 | 0] != 94 | HEAP32[$7 + 4 >> 2] != HEAP32[$1 + 48 >> 2])) {
       HEAP32[$7 + 4 >> 2] = $2;
      }
      $0 = $0 + 1 | 0;
      continue;
     }
    }
    if (HEAPU8[$10 + 4 | 0] & 32) {
     sqlite3VdbeAddOp4($6, 85, 0, 0, 0, sqlite3ExprNNCollSeq($9, HEAP32[HEAP32[HEAP32[$5 + 72 >> 2] + 20 >> 2] + 8 >> 2]), -2);
    }
    sqlite3VdbeAddOp3($6, $13, $3, $11, HEAP32[$5 + 52 >> 2]);
    sqlite3VdbeAppendP4($6, $10, -7);
    sqlite3VdbeChangeP5($6, $8 & 255);
    if (HEAPU8[$5 + 96 | 0]) {
     sqlite3ReleaseTempRange($9, $11, $8);
    }
    if (!$12) {
     break label$9;
    }
    sqlite3VdbeJumpHere($6, $12);
   }
   $5 = HEAP32[$5 + 36 >> 2];
   continue;
  }
  break;
 }
}

function vdbePmaReadBlob($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 $5 = HEAP32[$0 >> 2];
 $10 = $5;
 $6 = HEAP32[$0 + 4 >> 2];
 $3 = $6;
 $9 = HEAP32[$0 + 44 >> 2];
 label$1: {
  label$2: {
   if ($9) {
    HEAP32[$2 >> 2] = $9 + $10;
    $5 = $1;
    $6 = $5 >> 31;
    $5 = $6;
    $6 = $3;
    $7 = $5 + $6 | 0;
    $4 = $10;
    $3 = $1 + $4 | 0;
    HEAP32[$0 >> 2] = $3;
    $7 = $1 >>> 0 > $3 >>> 0 ? $7 + 1 | 0 : $7;
    HEAP32[$0 + 4 >> 2] = $7;
    break label$2;
   }
   $8 = HEAP32[$0 + 40 >> 2];
   $4 = $8;
   $7 = $4 >> 31;
   $13 = $4;
   $11 = $7;
   $7 = $3;
   $4 = $11;
   $4 = __wasm_i64_srem($10, $7, $8, $4);
   $9 = $4;
   if (!$4) {
    $7 = HEAP32[$0 + 8 >> 2];
    $6 = $7;
    $5 = $6 - $10 | 0;
    $4 = HEAP32[$0 + 12 >> 2];
    $7 = $3;
    $3 = $7 + ($6 >>> 0 < $10 >>> 0) | 0;
    $3 = $4 - $3 | 0;
    $4 = $13;
    $6 = $3;
    $3 = $11;
    $6 = $5 >>> 0 > $4 >>> 0 & ($6 | 0) >= ($3 | 0) | ($6 | 0) > ($3 | 0) ? $8 : $5;
    $4 = $7;
    $3 = sqlite3OsRead(HEAP32[$0 + 24 >> 2], HEAP32[$0 + 36 >> 2], $6, $10, $4);
    if ($3) {
     break label$1;
    }
    $8 = HEAP32[$0 + 40 >> 2];
   }
   $8 = $8 - $9 | 0;
   if (($8 | 0) >= ($1 | 0)) {
    HEAP32[$2 >> 2] = HEAP32[$0 + 36 >> 2] + $9;
    $3 = HEAP32[$0 + 4 >> 2];
    $2 = $3;
    $6 = $1;
    $4 = HEAP32[$0 >> 2];
    $7 = $6 + $4 | 0;
    $4 = $6;
    $3 = $4 >> 31;
    $4 = $3;
    $3 = $2;
    $5 = $4 + $3 | 0;
    HEAP32[$0 >> 2] = $7;
    $5 = $6 >>> 0 > $7 >>> 0 ? $5 + 1 | 0 : $5;
    HEAP32[$0 + 4 >> 2] = $5;
    break label$2;
   }
   $3 = HEAP32[$0 + 16 >> 2];
   label$6: {
    if (($3 | 0) >= ($1 | 0)) {
     $3 = HEAP32[$0 + 28 >> 2];
     break label$6;
    }
    $4 = ($3 | 0) < 64;
    $6 = $4 ? 128 : $3 << 1;
    $13 = $6;
    $5 = $3 >> 31;
    $3 = $5 << 1 | $3 >>> 31;
    $5 = $4 ? 0 : $3;
    $11 = $5;
    $6 = $1;
    $5 = $6 >> 31;
    $7 = $5;
    while (1) {
     $5 = $11;
     $3 = $5;
     $10 = $13;
     $4 = $10;
     $6 = $5 << 1 | $4 >>> 31;
     $13 = $4 << 1;
     $11 = $6;
     $6 = $5;
     $4 = $7;
     $5 = $10;
     if (($6 | 0) <= ($4 | 0) & $1 >>> 0 > $5 >>> 0 | ($4 | 0) > ($6 | 0)) {
      continue;
     }
     break;
    }
    $5 = $3;
    $3 = sqlite3Realloc(HEAP32[$0 + 28 >> 2], $10, $5);
    if (!$3) {
     $3 = 7;
     break label$1;
    }
    HEAP32[$0 + 28 >> 2] = $3;
    HEAP32[$0 + 16 >> 2] = $10;
   }
   __memcpy($3, HEAP32[$0 + 36 >> 2] + $9 | 0, $8);
   $6 = HEAP32[$0 + 4 >> 2];
   $11 = $6;
   $4 = $8;
   $5 = HEAP32[$0 >> 2];
   $3 = $4 + $5 | 0;
   $6 = $4 >> 31;
   $5 = $6;
   $6 = $11;
   $7 = $5 + $6 | 0;
   HEAP32[$0 >> 2] = $3;
   $7 = $3 >>> 0 < $4 >>> 0 ? $7 + 1 | 0 : $7;
   HEAP32[$0 + 4 >> 2] = $7;
   $9 = $1 - $4 | 0;
   while (1) {
    if (($9 | 0) > 0) {
     $8 = HEAP32[$0 + 40 >> 2];
     $8 = ($8 | 0) > ($9 | 0) ? $9 : $8;
     $3 = vdbePmaReadBlob($0, $8, $12 + 12 | 0);
     if ($3) {
      break label$1;
     }
     __memcpy(HEAP32[$0 + 28 >> 2] + ($1 - $9 | 0) | 0, HEAP32[$12 + 12 >> 2], $8);
     $9 = $9 - $8 | 0;
     continue;
    }
    break;
   }
   HEAP32[$2 >> 2] = HEAP32[$0 + 28 >> 2];
  }
  $3 = 0;
 }
 __stack_pointer = $12 + 16 | 0;
 return $3;
}

function sqlite3WhereRightJoinLoop($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $11 = __stack_pointer - 80 | 0;
 __stack_pointer = $11;
 $12 = HEAP32[$2 + 80 >> 2];
 $14 = HEAP32[$2 + 56 >> 2];
 $5 = HEAP32[$0 >> 2];
 $8 = HEAP32[$5 + 8 >> 2];
 $13 = HEAP32[$0 + 4 >> 2];
 $10 = HEAPU8[$2 + 60 | 0];
 $17 = $13 + ($10 << 6) | 0;
 HEAP32[$11 >> 2] = HEAP32[HEAP32[$17 + 24 >> 2] >> 2];
 sqlite3VdbeExplain($5, 1, 6935, $11);
 $9 = ($1 | 0) > 0 ? $1 : 0;
 while (1) {
  if (($4 | 0) != ($9 | 0)) {
   $1 = Math_imul($4, 96) + $0 | 0;
   $7 = HEAP32[$1 + 848 >> 2];
   $6 = HEAP32[$7 + 8 >> 2];
   $18 = $6;
   $3 = HEAP32[$7 + 12 >> 2];
   $6 = $3;
   sqlite3VdbeAddOp1($8, 136, HEAP32[$1 + 772 >> 2]);
   $1 = HEAP32[$1 + 776 >> 2];
   if ($1) {
    sqlite3VdbeAddOp1($8, 136, $1);
   }
   $7 = $15;
   $15 = $18 | $7;
   $3 = $16;
   $6 = $6 | $3;
   $16 = $6;
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 $4 = ($10 << 6) + $13 | 0;
 $9 = $4 + 8 | 0;
 $10 = 0;
 label$4: {
  if (HEAPU8[$4 + 44 | 0] & 64) {
   break label$4;
  }
  $3 = $12;
  $6 = HEAP32[$3 + 8 >> 2];
  $1 = $6;
  $6 = $16;
  $7 = HEAP32[$3 + 12 >> 2];
  $6 = $6 | $7;
  $3 = $1;
  $7 = $15 | $3;
  $15 = $7 ^ -1;
  $3 = $6 ^ -1;
  $16 = $3;
  $4 = 0;
  while (1) {
   if (HEAP32[$0 + 100 >> 2] <= ($4 | 0)) {
    break label$4;
   }
   $1 = HEAP32[$0 + 112 >> 2] + Math_imul($4, 48) | 0;
   if (HEAPU16[$1 + 12 >> 1] != 8192 ? HEAPU16[$1 + 10 >> 1] & 32770 : 0) {
    break label$4;
   }
   $3 = HEAP32[$1 + 40 >> 2];
   $6 = $3;
   $3 = $16;
   $7 = HEAP32[$1 + 44 >> 2];
   $3 = $3 & $7;
   $7 = $6 & $15;
   label$7: {
    if ($3 | $7) {
     break label$7;
    }
    $1 = HEAP32[$1 >> 2];
    if (HEAPU8[$1 + 4 | 0] & 3) {
     break label$7;
    }
    $10 = sqlite3ExprAnd($5, $10, sqlite3ExprDup(HEAP32[$5 >> 2], $1, 0));
   }
   $4 = $4 + 1 | 0;
   continue;
  }
 }
 $3 = $11;
 HEAP32[$3 + 8 >> 2] = 1;
 HEAP32[$3 + 12 >> 2] = 1;
 __memcpy($3 + 16 | 0, $9, 64);
 HEAP8[$3 + 52 | 0] = 0;
 HEAP8[$5 + 26 | 0] = HEAPU8[$5 + 26 | 0] + 1;
 $12 = sqlite3WhereBegin($5, $3 + 8 | 0, $10, 0, 0, 0, 4096, 0);
 if ($12) {
  $2 = HEAP32[$2 + 4 >> 2];
  $4 = HEAP32[$5 + 44 >> 2];
  $1 = $4 + 1 | 0;
  HEAP32[$5 + 44 >> 2] = $1;
  $3 = sqlite3WhereContinueLabel($12);
  label$9: {
   $9 = HEAP32[$17 + 24 >> 2];
   if (!(HEAPU8[$9 + 28 | 0] & 128)) {
    sqlite3ExprCodeGetColumnOfTable($8, $9, $2, -1, $1);
    $0 = 1;
    break label$9;
   }
   $13 = sqlite3PrimaryKeyIndex($9);
   $0 = HEAPU16[$13 + 50 >> 1];
   HEAP32[$5 + 44 >> 2] = $4 + $0;
   $4 = 0;
   while (1) {
    if (($0 | 0) == ($4 | 0)) {
     break label$9;
    }
    sqlite3ExprCodeGetColumnOfTable($8, $9, $2, HEAP16[HEAP32[$13 + 4 >> 2] + ($4 << 1) >> 1], $1 + $4 | 0);
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  $4 = sqlite3VdbeAddOp4Int($8, 63, HEAP32[$14 + 4 >> 2], 0, $1, $0);
  sqlite3VdbeAddOp4Int($8, 28, HEAP32[$14 >> 2], $3, $1, $0);
  sqlite3VdbeJumpHere($8, $4);
  sqlite3VdbeAddOp2($8, 9, HEAP32[$14 + 8 >> 2], HEAP32[$14 + 12 >> 2]);
  sqlite3WhereEnd($12);
 }
 sqlite3ExprDelete(HEAP32[$5 >> 2], $10);
 sqlite3VdbeExplainPop($5);
 HEAP8[$5 + 26 | 0] = HEAPU8[$5 + 26 | 0] - 1;
 __stack_pointer = $11 + 80 | 0;
}

function fts3BestIndexMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $2 = 1;
 label$1: {
  if (HEAP32[$0 + 56 >> 2]) {
   break label$1;
  }
  HEAP32[$1 + 40 >> 2] = 0;
  HEAP32[$1 + 44 >> 2] = 1095963344;
  HEAP32[$1 + 20 >> 2] = 0;
  $2 = HEAP32[$1 >> 2];
  $12 = ($2 | 0) > 0 ? $2 : 0;
  $7 = -1;
  $8 = -1;
  $9 = -1;
  $5 = -1;
  $2 = 0;
  while (1) {
   label$3: {
    label$4: {
     label$5: {
      if (($2 | 0) != ($12 | 0)) {
       $3 = HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0;
       if (!HEAPU8[$3 + 5 | 0]) {
        if (HEAPU8[$3 + 4 | 0] != 64) {
         break label$3;
        }
        HEAP32[$1 + 40 >> 2] = -981572454;
        HEAP32[$1 + 44 >> 2] = 1246829326;
        HEAP32[$1 + 20 >> 2] = 0;
        fts3SetEstimatedRows($1);
        return 0;
       }
       $6 = HEAP32[$3 >> 2];
       $11 = ($6 | 0) < 0;
       if ($11) {
        $4 = 1;
       } else {
        $4 = (HEAP32[$0 + 24 >> 2] + 1 | 0) == ($6 | 0);
       }
       $3 = HEAPU8[$3 + 4 | 0];
       if (!(!$4 | (($3 | 0) != 2 | ($5 | 0) >= 0))) {
        HEAP32[$1 + 40 >> 2] = 0;
        HEAP32[$1 + 44 >> 2] = 1072693248;
        $10 = 1;
        HEAP32[$1 + 20 >> 2] = 1;
        $5 = $2;
        break label$5;
       }
       if (($3 | 0) == 2) {
        break label$5;
       }
       if (($3 | 0) != 64) {
        break label$4;
       }
       $3 = 64;
       if (HEAP32[$0 + 24 >> 2] < ($6 | 0) | $11) {
        break label$4;
       }
       HEAP32[$1 + 40 >> 2] = 0;
       HEAP32[$1 + 44 >> 2] = 1073741824;
       $10 = $6 + 2 | 0;
       HEAP32[$1 + 20 >> 2] = $10;
       $5 = $2;
       break label$4;
      }
      $2 = 1;
      if (($10 | 0) == 1) {
       fts3SetUniqueFlag($1);
      }
      if (($5 | 0) >= 0) {
       $2 = HEAP32[$1 + 16 >> 2] + ($5 << 3) | 0;
       HEAP8[$2 + 4 | 0] = 1;
       HEAP32[$2 >> 2] = 1;
       $2 = 2;
      }
      if (($7 | 0) >= 0) {
       HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] | 65536;
       HEAP32[HEAP32[$1 + 16 >> 2] + ($7 << 3) >> 2] = $2;
       $2 = $2 + 1 | 0;
      }
      if (($8 | 0) >= 0) {
       HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] | 131072;
       HEAP32[HEAP32[$1 + 16 >> 2] + ($8 << 3) >> 2] = $2;
       $2 = $2 + 1 | 0;
      }
      if (($9 | 0) >= 0) {
       HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 20 >> 2] | 262144;
       HEAP32[HEAP32[$1 + 16 >> 2] + ($9 << 3) >> 2] = $2;
      }
      $2 = 0;
      if (HEAP32[$1 + 8 >> 2] != 1) {
       break label$1;
      }
      $3 = HEAP32[$1 + 12 >> 2];
      $4 = HEAP32[$3 >> 2];
      if (($4 | 0) >= 0 & (HEAP32[$0 + 24 >> 2] + 1 | 0) != ($4 | 0)) {
       break label$1;
      }
      $3 = HEAPU8[$3 + 4 | 0];
      HEAP32[$1 + 32 >> 2] = 1;
      HEAP32[$1 + 24 >> 2] = $3 ? 19869 : 20283;
      break label$1;
     }
     $3 = 2;
     $7 = (HEAP32[$0 + 24 >> 2] + 2 | 0) == ($6 | 0) ? $2 : $7;
    }
    if (!$4) {
     break label$3;
    }
    label$17: {
     switch (__wasm_rotl_i32($3 - 4 | 0, 30) | 0) {
     case 1:
     case 3:
      $9 = $2;
      break label$3;

     case 0:
     case 7:
      break label$17;

     default:
      break label$3;
     }
    }
    $8 = $2;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 return $2 | 0;
}

function replaceFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0;
 $20 = sqlite3_context_db_handle($0);
 label$1: {
  $14 = sqlite3_value_text(HEAP32[$2 >> 2]);
  if (!$14) {
   break label$1;
  }
  $11 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
  $12 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
  if (!$12) {
   break label$1;
  }
  if (!HEAPU8[$12 | 0]) {
   sqlite3_result_value($0, HEAP32[$2 >> 2]);
   return;
  }
  $10 = sqlite3_value_bytes(HEAP32[$2 + 4 >> 2]);
  $19 = sqlite3_value_text(HEAP32[$2 + 8 >> 2]);
  if (!$19) {
   break label$1;
  }
  $13 = sqlite3_value_bytes(HEAP32[$2 + 8 >> 2]);
  $1 = $11 + 1 | 0;
  $3 = $1 >> 31;
  $15 = $1;
  $16 = $3;
  $7 = contextMalloc($0, $1, $3);
  if (!$7) {
   break label$1;
  }
  $21 = $10 - 1 | 0;
  $22 = $11 - $10 | 0;
  $1 = $11 ^ -1;
  $3 = $1 >> 31;
  $23 = $1;
  $24 = $3;
  $1 = $13 - $10 | 0;
  $3 = $1 >> 31;
  $25 = $1;
  $26 = $3;
  $2 = 0;
  while (1) {
   label$4: {
    label$5: {
     label$6: {
      if (($2 | 0) <= ($22 | 0)) {
       label$8: {
        $3 = $2 + $14 | 0;
        $1 = HEAPU8[$3 | 0];
        if (($1 | 0) == HEAPU8[$12 | 0]) {
         if (!memcmp($3, $12, $10)) {
          break label$8;
         }
        }
        HEAP8[$7 + $8 | 0] = $1;
        $8 = $8 + 1 | 0;
        break label$4;
       }
       if (($10 | 0) >= ($13 | 0)) {
        break label$6;
       }
       $6 = $20;
       $3 = HEAP32[$6 + 120 >> 2];
       $1 = $3 >> 31;
       $17 = $3;
       $27 = $1;
       $3 = $26;
       $1 = $16;
       $4 = $3 + $1 | 0;
       $6 = $15;
       $9 = $25;
       $5 = $6 + $9 | 0;
       $15 = $5;
       $4 = $5 >>> 0 < $9 >>> 0 ? $4 + 1 | 0 : $4;
       $16 = $4;
       $1 = $5;
       $3 = $1 - 1 | 0;
       $5 = !$1;
       $5 = $4 - $5 | 0;
       $4 = $17;
       $1 = $5;
       $5 = $27;
       if ($3 >>> 0 > $4 >>> 0 & ($1 | 0) >= ($5 | 0) | ($1 | 0) > ($5 | 0)) {
        sqlite3_result_error_toobig($0);
        sqlite3_free($7);
        return;
       }
       $1 = $18 + 1 | 0;
       if ($18 & $1) {
        $18 = $1;
        break label$6;
       }
       $18 = $1;
       $5 = $24;
       $4 = $16;
       $3 = $5 + $4 | 0;
       $1 = $23;
       $9 = $15;
       $6 = $1 + $9 | 0;
       $3 = $1 >>> 0 > $6 >>> 0 ? $3 + 1 | 0 : $3;
       $17 = $3;
       $4 = $9;
       $9 = $4;
       $4 = $4 >> 31;
       $1 = $9;
       $5 = $1 + $6 | 0;
       $3 = $4;
       $4 = $17;
       $6 = $3 + $4 | 0;
       $6 = $1 >>> 0 > $5 >>> 0 ? $6 + 1 | 0 : $6;
       $1 = sqlite3Realloc($7, $5, $6);
       if ($1) {
        break label$5;
       }
       sqlite3_result_error_nomem($0);
       sqlite3_free($7);
       return;
      }
      $1 = $2 + $14 | 0;
      $2 = $11 - $2 | 0;
      __memcpy($7 + $8 | 0, $1, $2);
      $2 = $2 + $8 | 0;
      HEAP8[$7 + $2 | 0] = 0;
      sqlite3_result_text($0, $7, $2, 3);
      break label$1;
     }
     $1 = $7;
    }
    __memcpy($1 + $8 | 0, $19, $13);
    $2 = $2 + $21 | 0;
    $7 = $1;
    $8 = $8 + $13 | 0;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
}

function expm1($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 label$1: {
  label$2: {
   label$3: {
    wasm2js_scratch_store_f64(+$0);
    $3 = wasm2js_scratch_load_i32(1) | 0;
    $7 = wasm2js_scratch_load_i32(0) | 0;
    $8 = $3;
    label$4: {
     label$5: {
      $2 = $3 & 2147483647;
      if ($2 >>> 0 >= 1078159482) {
       $4 = __DOUBLE_BITS_5($0);
       $3 = $4;
       $2 = i64toi32_i32$HIGH_BITS;
       $4 = $2 & 2147483647;
       $2 = $3;
       if (($4 | 0) == 2146435072 & ($2 | 0) != 0 | $4 >>> 0 > 2146435072) {
        break label$1;
       }
       $2 = $8;
       if (($2 | 0) < 0) {
        return -1;
       }
       if (!($0 > 709.782712893384)) {
        break label$5;
       }
       return $0 * 898846567431158e293;
      }
      if ($2 >>> 0 < 1071001155) {
       break label$3;
      }
      if ($2 >>> 0 > 1072734897) {
       break label$5;
      }
      $3 = $8;
      if (($3 | 0) > 0 | ($3 | 0) >= 0) {
       $2 = 1;
       $6 = 1.9082149292705877e-10;
       $1 = $0 + -.6931471803691238;
       break label$4;
      }
      $2 = -1;
      $6 = -1.9082149292705877e-10;
      $1 = $0 + .6931471803691238;
      break label$4;
     }
     wasm2js_scratch_store_f64(.5);
     $3 = wasm2js_scratch_load_i32(1) | 0;
     $4 = wasm2js_scratch_load_i32(0) | 0;
     $7 = $4;
     $3 = $3 & 2147483647;
     $8 = $3;
     wasm2js_scratch_store_f64(+$0);
     $3 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     $4 = $3 & -2147483648;
     $2 = $10;
     $3 = $7;
     wasm2js_scratch_store_i32(0, $2 | $3);
     $3 = $4;
     $4 = $8;
     $3 = $3 | $4;
     wasm2js_scratch_store_i32(1, $3 | 0);
     $1 = $0 * 1.4426950408889634 + +wasm2js_scratch_load_f64();
     label$9: {
      if (Math_abs($1) < 2147483648) {
       $2 = ~~$1;
       break label$9;
      }
      $2 = -2147483648;
     }
     $1 = +($2 | 0);
     $6 = $1 * 1.9082149292705877e-10;
     $1 = $0 + $1 * -.6931471803691238;
    }
    $0 = $1 - $6;
    $6 = $1 - $0 - $6;
    break label$2;
   }
   if ($2 >>> 0 < 1016070144) {
    break label$1;
   }
   $2 = 0;
  }
  $5 = $0 * .5;
  $1 = $0 * $5;
  $9 = $1 * ($1 * ($1 * ($1 * ($1 * -2.0109921818362437e-7 + 4008217827329362e-21) + -793650757867488e-19) + .0015873015872548146) + -.03333333333333313) + 1;
  $5 = 3 - $9 * $5;
  $5 = $1 * (($9 - $5) / (6 - $0 * $5));
  if (!$2) {
   return $0 - ($0 * $5 - $1);
  }
  $1 = $0 * ($5 - $6) - $6 - $1;
  label$12: {
   switch ($2 + 1 | 0) {
   case 0:
    return ($0 - $1) * .5 + -.5;

   case 2:
    if ($0 < -.25) {
     return ($1 - ($0 + .5)) * -2;
    }
    $0 = $0 - $1;
    return $0 + $0 + 1;

   default:
    break label$12;
   }
  }
  wasm2js_scratch_store_i32(0, 0);
  $4 = $2 + 1023 | 0;
  $3 = $4 << 20;
  wasm2js_scratch_store_i32(1, $3 | 0);
  $6 = +wasm2js_scratch_load_f64();
  if ($2 >>> 0 >= 57) {
   $0 = $0 - $1 + 1;
   return (($2 | 0) == 1024 ? ($0 + $0) * 898846567431158e293 : $0 * $6) + -1;
  }
  wasm2js_scratch_store_i32(0, 0);
  $3 = 1023 - $2 | 0;
  $4 = $3 << 20;
  wasm2js_scratch_store_i32(1, $4 | 0);
  $5 = +wasm2js_scratch_load_f64();
  $0 = $2 >>> 0 <= 19 ? 1 - $5 + ($0 - $1) : $0 - ($1 + $5) + 1;
  $0 = $0 * $6;
 }
 return $0;
}

function sqlite3ExprCompare($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 if (!($2 ? $1 : 0)) {
  return (($1 | 0) != ($2 | 0)) << 1;
 }
 label$2: {
  label$3: {
   if (!(!$0 | HEAPU8[$1 | 0] != 156)) {
    if (exprCompareVariable($0, $1, $2)) {
     break label$3;
    }
   }
   $6 = HEAP32[$2 + 4 >> 2];
   $7 = HEAP32[$1 + 4 >> 2];
   $8 = $6 | $7;
   if ($8 & 2048) {
    if (!($6 & $7 & 2048)) {
     break label$2;
    }
    if (HEAP32[$1 + 8 >> 2] == HEAP32[$2 + 8 >> 2]) {
     break label$3;
    }
    break label$2;
   }
   $5 = HEAPU8[$1 | 0];
   $4 = HEAPU8[$2 | 0];
   if (!(($5 | 0) != 71 & ($5 | 0) == ($4 | 0))) {
    if (($5 | 0) == 113) {
     $4 = 1;
     if ((sqlite3ExprCompare($0, HEAP32[$1 + 12 >> 2], $2, $3) | 0) < 2) {
      break label$3;
     }
     $4 = HEAPU8[$2 | 0];
    }
    if (($4 | 0) != 113) {
     break label$2;
    }
    $4 = 1;
    if ((sqlite3ExprCompare($0, $1, HEAP32[$2 + 12 >> 2], $3) | 0) >= 2) {
     break label$2;
    }
    break label$3;
   }
   $9 = HEAP32[$1 + 8 >> 2];
   label$8: {
    if (!$9) {
     break label$8;
    }
    label$9: {
     label$10: {
      switch ($5 - 168 | 0) {
      default:
       if (($5 | 0) == 113) {
        break label$9;
       }
       $4 = 0;
       if (($5 | 0) == 121) {
        break label$3;
       }

      case 1:
      case 2:
      case 3:
       $10 = HEAP32[$2 + 8 >> 2];
       if (!$10 | ($5 | 0) == 167 | ($5 | 0) == 169) {
        break label$8;
       }
       $4 = 2;
       if (!strcmp($9, $10)) {
        break label$8;
       }
       break label$3;

      case 0:
      case 4:
       break label$10;
      }
     }
     $4 = 2;
     if (sqlite3StrICmp($9, HEAP32[$2 + 8 >> 2])) {
      break label$3;
     }
     $5 = $7 & 16777216;
     if (($6 >>> 24 & 1) != ($5 >>> 24 | 0)) {
      break label$3;
     }
     if (!$5) {
      break label$8;
     }
     if (sqlite3WindowCompare($0, HEAP32[$1 + 44 >> 2], HEAP32[$2 + 44 >> 2], 1)) {
      break label$3;
     }
     $6 = HEAP32[$2 + 4 >> 2];
     $7 = HEAP32[$1 + 4 >> 2];
     break label$8;
    }
    $4 = 2;
    if (sqlite3_stricmp($9, HEAP32[$2 + 8 >> 2])) {
     break label$3;
    }
   }
   $4 = 2;
   if (($6 ^ $7) & 1028) {
    break label$3;
   }
   label$13: {
    if ($8 & 65536) {
     break label$13;
    }
    if ($8 & 4096) {
     break label$3;
    }
    if (!($8 & 32)) {
     if (sqlite3ExprCompare($0, HEAP32[$1 + 12 >> 2], HEAP32[$2 + 12 >> 2], $3)) {
      break label$3;
     }
    }
    if (sqlite3ExprCompare($0, HEAP32[$1 + 16 >> 2], HEAP32[$2 + 16 >> 2], $3)) {
     break label$3;
    }
    if (sqlite3ExprListCompare(HEAP32[$1 + 20 >> 2], HEAP32[$2 + 20 >> 2], $3)) {
     break label$3;
    }
    $0 = HEAPU8[$1 | 0];
    if ($8 & 16384 | (($0 | 0) == 117 | ($0 | 0) == 170)) {
     break label$13;
    }
    if (($0 | 0) == 175 & HEAPU8[$1 + 2 | 0] != HEAPU8[$2 + 2 | 0] | HEAPU16[$1 + 32 >> 1] != HEAPU16[$2 + 32 >> 1]) {
     break label$3;
    }
    if (($0 | 0) == 49) {
     break label$13;
    }
    $1 = HEAP32[$1 + 28 >> 2];
    if (($3 | 0) == ($1 | 0)) {
     break label$13;
    }
    if (HEAP32[$2 + 28 >> 2] != ($1 | 0)) {
     break label$3;
    }
   }
   $4 = 0;
  }
  return $4;
 }
 return 2;
}

function fts3DoRebuild($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  $1 = fts3DeleteAll($0, 0);
  if ($1) {
   break label$1;
  }
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 >> 2] = HEAP32[$0 + 224 >> 2];
  label$2: {
   label$3: {
    $1 = sqlite3_mprintf(6860, $2);
    if (!$1) {
     $4 = 7;
     HEAP32[$2 + 12 >> 2] = 7;
     break label$3;
    }
    $4 = sqlite3_prepare_v2(HEAP32[$0 + 12 >> 2], $1, -1, $2 + 8 | 0, 0);
    HEAP32[$2 + 12 >> 2] = $4;
    sqlite3_free($1);
    if ($4) {
     break label$3;
    }
    $3 = HEAP32[$0 + 24 >> 2];
    $1 = $3 >> 31;
    $3 = __wasm_i64_mul($3, $1, 12, 0);
    $1 = i64toi32_i32$HIGH_BITS;
    $4 = $1;
    $3 = $3 + 12 | 0;
    $4 = $3 >>> 0 < 12 ? $4 + 1 | 0 : $4;
    $5 = sqlite3_malloc64($3, $4);
    if (!$5) {
     $4 = 7;
     HEAP32[$2 + 12 >> 2] = 7;
     break label$3;
    }
    $4 = 0;
    $3 = memset($5, 0, $3);
    $1 = (HEAP32[$0 + 24 >> 2] << 2) + 4 | 0;
    $8 = $3 + $1 | 0;
    $11 = $1 + $8 | 0;
    break label$2;
   }
   $5 = 0;
  }
  while (1) {
   label$7: {
    label$8: {
     if ($4) {
      break label$8;
     }
     if ((sqlite3_step(HEAP32[$2 + 8 >> 2]) | 0) != 100) {
      break label$8;
     }
     $1 = 0;
     $6 = langidFromSelect($0, HEAP32[$2 + 8 >> 2]);
     $4 = sqlite3_column_int64(HEAP32[$2 + 8 >> 2], 0);
     $3 = i64toi32_i32$HIGH_BITS;
     $4 = fts3PendingTermsDocid($0, 0, $6, $4, $3);
     HEAP32[$2 + 12 >> 2] = $4;
     $7 = memset($5, 0, (HEAP32[$0 + 24 >> 2] << 2) + 4 | 0);
     while (1) {
      $3 = $4;
      label$10: {
       while (1) {
        if (HEAP32[$0 + 24 >> 2] <= ($1 | 0) | $3) {
         break label$10;
        }
        if (HEAPU8[HEAP32[$0 + 32 >> 2] + $1 | 0]) {
         $1 = $1 + 1 | 0;
         $3 = 0;
         continue;
        }
        break;
       }
       $3 = $1 + 1 | 0;
       $4 = fts3PendingTermsAdd($0, $6, sqlite3_column_text(HEAP32[$2 + 8 >> 2], $3), $1, ($1 << 2) + $7 | 0);
       HEAP32[$2 + 12 >> 2] = $4;
       $1 = sqlite3_column_bytes(HEAP32[$2 + 8 >> 2], $3);
       $9 = (HEAP32[$0 + 24 >> 2] << 2) + $7 | 0;
       HEAP32[$9 >> 2] = HEAP32[$9 >> 2] + $1;
       $1 = $3;
       continue;
      }
      break;
     }
     if (HEAPU8[$0 + 238 | 0]) {
      fts3InsertDocsize($2 + 12 | 0, $0, $7);
      $4 = HEAP32[$2 + 12 >> 2];
     }
     if ($4) {
      break label$7;
     }
     $1 = 0;
     while (1) {
      if (($1 | 0) <= HEAP32[$0 + 24 >> 2]) {
       $3 = $1 << 2;
       $6 = $8 + $3 | 0;
       HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + HEAP32[$3 + $7 >> 2];
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     $10 = $10 + 1 | 0;
     continue;
    }
    if (HEAPU8[$0 + 236 | 0]) {
     fts3UpdateDocTotals($2 + 12 | 0, $0, $8, $11, $10);
    }
    sqlite3_free($5);
    $1 = HEAP32[$2 + 8 >> 2];
    if (!$1) {
     $1 = HEAP32[$2 + 12 >> 2];
     break label$1;
    }
    $1 = sqlite3_finalize($1);
    $0 = HEAP32[$2 + 12 >> 2];
    $1 = $0 ? $0 : $1;
    break label$1;
   }
   sqlite3_finalize(HEAP32[$2 + 8 >> 2]);
   HEAP32[$2 + 8 >> 2] = 0;
   $4 = 1;
   continue;
  }
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function trimFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 label$1: {
  $3 = HEAP32[$2 >> 2];
  if ((sqlite3_value_type($3) | 0) == 5) {
   break label$1;
  }
  $8 = sqlite3_value_text($3);
  if (!$8) {
   break label$1;
  }
  $4 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
  label$2: {
   label$3: {
    label$4: {
     if (($1 | 0) == 1) {
      $9 = 50676;
      $7 = 50680;
      $5 = 1;
      break label$4;
     }
     $10 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
     if (!$10) {
      break label$1;
     }
     $1 = 0;
     $2 = $10;
     while (1) {
      $5 = HEAPU8[$2 | 0];
      if ($5) {
       $3 = $2 + 1 | 0;
       $2 = $3;
       if ($5 >>> 0 >= 192) {
        while (1) {
         $2 = $3;
         $3 = $2 + 1 | 0;
         if ((HEAPU8[$2 | 0] & 192) == 128) {
          continue;
         }
         break;
        }
       }
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     if (!$1) {
      break label$3;
     }
     $7 = contextMalloc($0, $1 << 3, $1 >>> 29 | 0);
     if (!$7) {
      break label$1;
     }
     $9 = ($1 << 2) + $7 | 0;
     $5 = 0;
     $1 = $10;
     while (1) {
      if (HEAPU8[$1 | 0]) {
       $6 = $5 << 2;
       HEAP32[$6 + $7 >> 2] = $1;
       $3 = $1 + 1 | 0;
       $2 = $3;
       if (HEAPU8[$1 | 0] >= 192) {
        while (1) {
         $2 = $3;
         $3 = $2 + 1 | 0;
         if ((HEAPU8[$2 | 0] & 192) == 128) {
          continue;
         }
         break;
        }
       }
       HEAP32[$6 + $9 >> 2] = $2 - $1;
       $5 = $5 + 1 | 0;
       $1 = $2;
       continue;
      }
      break;
     }
     if (!$5) {
      break label$3;
     }
    }
    $6 = sqlite3_user_data($0);
    label$14: {
     if (!($6 & 1) | !$4) {
      break label$14;
     }
     while (1) {
      $2 = 0;
      $3 = 0;
      while (1) {
       label$17: {
        if (($2 | 0) == ($5 | 0)) {
         break label$17;
        }
        $1 = $2 << 2;
        $3 = HEAP32[$9 + $1 >> 2];
        if ($4 >>> 0 >= $3 >>> 0) {
         if (!memcmp($8, HEAP32[$1 + $7 >> 2], $3)) {
          break label$17;
         }
        }
        $2 = $2 + 1 | 0;
        continue;
       }
       break;
      }
      if ($2 >>> 0 >= $5 >>> 0) {
       break label$14;
      }
      $8 = $3 + $8 | 0;
      $4 = $4 - $3 | 0;
      if ($4) {
       continue;
      }
      break;
     }
     $4 = 0;
    }
    label$19: {
     if (!(!($6 & 2) | !$4)) {
      while (1) {
       $1 = $4;
       $2 = 0;
       while (1) {
        if (($2 | 0) == ($5 | 0)) {
         break label$19;
        }
        label$23: {
         $6 = $2 << 2;
         $3 = HEAP32[$9 + $6 >> 2];
         if ($3 >>> 0 <= $1 >>> 0) {
          $4 = $1 - $3 | 0;
          if (!memcmp($8 + $4 | 0, HEAP32[$7 + $6 >> 2], $3)) {
           break label$23;
          }
         }
         $2 = $2 + 1 | 0;
         continue;
        }
        break;
       }
       $1 = 0;
       if ($4) {
        continue;
       }
       break label$19;
      }
     }
     $1 = $4;
    }
    if (!$10) {
     break label$2;
    }
    sqlite3_free($7);
    break label$2;
   }
   $1 = $4;
  }
  sqlite3_result_text($0, $8, $1, -1);
 }
}

function sqlite3FinishCoding($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (HEAPU8[$0 + 18 | 0]) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  label$2: {
   if (HEAP32[$0 + 36 >> 2]) {
    $1 = 7;
    if (HEAPU8[$3 + 87 | 0]) {
     break label$2;
    }
    break label$1;
   }
   label$4: {
    label$5: {
     $2 = HEAP32[$0 + 8 >> 2];
     if ($2) {
      break label$5;
     }
     $1 = 101;
     if (HEAPU8[$3 + 177 | 0]) {
      break label$2;
     }
     $2 = sqlite3GetVdbe($0);
     if ($2) {
      break label$5;
     }
     HEAP32[$0 + 12 >> 2] = 1;
     $2 = 0;
     break label$4;
    }
    label$6: {
     if (!HEAPU8[$0 + 149 | 0]) {
      break label$6;
     }
     $4 = HEAP32[$0 + 132 >> 2];
     if (!HEAP32[$4 + 96 >> 2]) {
      break label$6;
     }
     sqlite3VdbeAddOp0($2, 83);
     $6 = sqlite3VdbeAddOp1($2, 35, HEAP32[$4 + 92 >> 2]);
     $5 = HEAP32[$4 + 100 >> 2];
     $1 = 0;
     while (1) {
      if (($1 | 0) < HEAP32[$4 + 96 >> 2]) {
       sqlite3VdbeAddOp3($2, 94, HEAP32[$4 + 92 >> 2], $1, $1 + $5 | 0);
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     sqlite3VdbeAddOp2($2, 84, $5, $1);
     sqlite3VdbeAddOp2($2, 38, HEAP32[$4 + 92 >> 2], $6 + 1 | 0);
     sqlite3VdbeJumpHere($2, $6);
    }
    sqlite3VdbeAddOp0($2, 70);
    if (HEAPU8[$3 + 87 | 0] | !(HEAP32[$0 + 68 >> 2] ? 1 : HEAP32[$0 + 84 >> 2])) {
     break label$4;
    }
    $1 = 0;
    sqlite3VdbeJumpHere($2, 0);
    while (1) {
     label$11: {
      if (!(HEAP32[$0 + 84 >> 2] >>> $1 & 1)) {
       break label$11;
      }
      sqlite3VdbeUsesBtree($2, $1);
      $4 = HEAP32[(HEAP32[$3 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
      sqlite3VdbeAddOp4Int($2, 2, $1, HEAP32[$0 + 80 >> 2] >>> $1 & 1, HEAP32[$4 >> 2], HEAP32[$4 + 4 >> 2]);
      if (HEAPU8[$3 + 177 | 0]) {
       break label$11;
      }
      sqlite3VdbeChangeP5($2, 1);
     }
     $1 = $1 + 1 | 0;
     if (($1 | 0) < HEAP32[$3 + 20 >> 2]) {
      continue;
     }
     break;
    }
    $1 = 0;
    while (1) {
     if (($1 | 0) < HEAP32[$0 + 212 >> 2]) {
      sqlite3VdbeAddOp4($2, 170, 0, 0, 0, sqlite3GetVTable($3, HEAP32[HEAP32[$0 + 260 >> 2] + ($1 << 2) >> 2]), -11);
      $1 = $1 + 1 | 0;
      continue;
     }
     break;
    }
    $1 = 0;
    HEAP32[$0 + 212 >> 2] = 0;
    codeTableLocks($0);
    sqlite3AutoincrementBegin($0);
    label$14: {
     $3 = HEAP32[$0 + 68 >> 2];
     if (!$3) {
      break label$14;
     }
     HEAP8[$0 + 23 | 0] = 0;
     while (1) {
      if (HEAP32[$3 >> 2] <= ($1 | 0)) {
       break label$14;
      }
      $4 = ($1 << 4) + $3 | 0;
      $5 = HEAP32[$4 + 20 >> 2];
      if (($5 | 0) > 0) {
       sqlite3ExprCode($0, HEAP32[$4 + 8 >> 2], $5);
      }
      $1 = $1 + 1 | 0;
      continue;
     }
    }
    label$17: {
     if (!HEAPU8[$0 + 149 | 0]) {
      break label$17;
     }
     $1 = HEAP32[$0 + 132 >> 2];
     $3 = HEAP32[$1 + 96 >> 2];
     if (!$3) {
      break label$17;
     }
     sqlite3VdbeAddOp2($2, 118, HEAP32[$1 + 92 >> 2], $3);
    }
    sqlite3VdbeGoto($2, 1);
   }
   $1 = 1;
   if (HEAP32[$0 + 36 >> 2]) {
    break label$2;
   }
   sqlite3VdbeMakeReady($2, $0);
   $1 = 101;
  }
  HEAP32[$0 + 12 >> 2] = $1;
 }
}

function sqlite3InitCallback($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$0 + 8 >> 2];
 $1 = HEAP32[$0 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] | 64;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $4 = 1;
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 1;
  if (HEAPU8[$1 + 87 | 0]) {
   corruptSchema($0, $2, 0);
   break label$1;
  }
  label$3: {
   $7 = HEAP32[$2 + 12 >> 2];
   if (!$7) {
    break label$3;
   }
   $4 = HEAP32[$2 + 16 >> 2];
   label$4: {
    if ($4) {
     $6 = HEAPU8[$4 | 0];
     if (!(($6 & 223) != 67 | (HEAPU8[$4 + 1 | 0] & 223) != 82)) {
      $4 = $1 + 176 | 0;
      $6 = HEAPU8[$4 | 0];
      HEAP8[$1 + 176 | 0] = $3;
      $4 = $1 + 172 | 0;
      label$7: {
       label$8: {
        if (sqlite3GetUInt32($7, $4)) {
         $4 = HEAP32[$0 + 24 >> 2];
         if ($4 >>> 0 >= HEAPU32[$1 + 172 >> 2] | !$4) {
          break label$7;
         }
         if (HEAPU8[64281]) {
          break label$8;
         }
         break label$7;
        }
        if (!HEAPU8[64281]) {
         break label$7;
        }
       }
       corruptSchema($0, $2, 13952);
      }
      HEAP32[$1 + 180 >> 2] = $2;
      $4 = $1 + 178 | 0;
      HEAP8[$4 | 0] = HEAPU8[$1 + 178 | 0] & 254;
      $4 = 0;
      HEAP32[$5 + 12 >> 2] = 0;
      sqlite3Prepare($1, HEAP32[$2 + 16 >> 2], -1, 0, 0, $5 + 12 | 0, 0);
      HEAP8[$1 + 176 | 0] = $6;
      $3 = HEAP32[$1 + 64 >> 2];
      label$10: {
       if (!$3 | HEAP8[$1 + 178 | 0] & 1) {
        break label$10;
       }
       if (HEAP32[$0 + 12 >> 2] < ($3 | 0)) {
        HEAP32[$0 + 12 >> 2] = $3;
       }
       label$12: {
        switch ($3 - 7 | 0) {
        case 0:
         sqlite3OomFault($1);
         break label$10;

        case 2:
         break label$10;

        default:
         break label$12;
        }
       }
       if (($3 & 255) == 6) {
        break label$10;
       }
       corruptSchema($0, $2, sqlite3_errmsg($1));
      }
      HEAP32[$1 + 180 >> 2] = 65328;
      sqlite3_finalize(HEAP32[$5 + 12 >> 2]);
      break label$1;
     }
     $4 = HEAP32[$2 + 4 >> 2];
     if (!$4 | $6) {
      break label$3;
     }
     break label$4;
    }
    $4 = HEAP32[$2 + 4 >> 2];
    if (!$4) {
     break label$3;
    }
   }
   $1 = sqlite3FindIndex($1, $4, HEAP32[HEAP32[$1 + 16 >> 2] + ($3 << 4) >> 2]);
   label$14: {
    if (!$1) {
     corruptSchema($0, $2, 1506);
     break label$14;
    }
    label$16: {
     label$17: {
      $4 = $1 + 44 | 0;
      if (!sqlite3GetUInt32(HEAP32[$2 + 12 >> 2], $4)) {
       break label$17;
      }
      $4 = HEAP32[$1 + 44 >> 2];
      if ($4 >>> 0 < 2 | HEAPU32[$0 + 24 >> 2] < $4 >>> 0) {
       break label$17;
      }
      $4 = 0;
      if (!sqlite3IndexHasDuplicateRootPage($1)) {
       break label$1;
      }
      if (HEAPU8[64281]) {
       break label$16;
      }
      break label$1;
     }
     $4 = 0;
     if (!HEAPU8[64281]) {
      break label$1;
     }
    }
    corruptSchema($0, $2, 13952);
   }
   $4 = 0;
   break label$1;
  }
  $4 = 0;
  corruptSchema($0, $2, 0);
 }
 __stack_pointer = $5 + 16 | 0;
 return $4 | 0;
}

function lockBtree($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 8 >> 2] = 0;
 $1 = sqlite3PagerSharedLock(HEAP32[$0 >> 2]);
 label$1: {
  if ($1) {
   break label$1;
  }
  $1 = btreeGetPage($0, 1, $4 + 12 | 0, 0);
  if ($1) {
   break label$1;
  }
  $7 = HEAP32[$4 + 12 >> 2];
  $2 = HEAP32[$7 + 56 >> 2];
  $6 = sqlite3Get4byte($2 + 28 | 0);
  $3 = HEAP32[$0 >> 2];
  sqlite3PagerPagecount($3, $4 + 8 | 0);
  label$4: {
   label$5: {
    $6 = ((HEAPU8[$2 + 24 | 0] | HEAPU8[$2 + 25 | 0] << 8 | (HEAPU8[$2 + 26 | 0] << 16 | HEAPU8[$2 + 27 | 0] << 24)) == (HEAPU8[$2 + 92 | 0] | HEAPU8[$2 + 93 | 0] << 8 | (HEAPU8[$2 + 94 | 0] << 16 | HEAPU8[$2 + 95 | 0] << 24)) ? $6 : 0) ? $6 : HEAP32[$4 + 8 >> 2];
    label$6: {
     if ($6 ? HEAPU8[HEAP32[$0 + 4 >> 2] + 35 | 0] & 2 : 1) {
      $3 = HEAP32[$0 + 40 >> 2];
      $6 = 0;
      break label$6;
     }
     $1 = 26;
     if (memcmp($2, 32304, 16)) {
      break label$4;
     }
     if (HEAPU8[$2 + 18 | 0] >= 3) {
      HEAP16[$0 + 24 >> 1] = HEAPU16[$0 + 24 >> 1] | 1;
     }
     $5 = HEAPU8[$2 + 19 | 0];
     if ($5 >>> 0 > 2) {
      break label$4;
     }
     label$9: {
      if (HEAPU8[$0 + 24 | 0] & 32 | ($5 | 0) != 2) {
       break label$9;
      }
      HEAP32[$4 + 4 >> 2] = 0;
      $3 = sqlite3PagerOpenWal($3, $4 + 4 | 0);
      if ($3) {
       break label$5;
      }
      if (HEAP32[$4 + 4 >> 2]) {
       break label$9;
      }
      releasePageOne($7);
      $1 = 0;
      break label$1;
     }
     if (memcmp($2 + 21 | 0, 29591, 3)) {
      break label$4;
     }
     $5 = HEAPU8[$2 + 17 | 0] << 16 | HEAPU8[$2 + 16 | 0] << 8;
     if ($5 - 65537 >>> 0 < 4294902016 | $5 - 1 & $5) {
      break label$4;
     }
     HEAP16[$0 + 24 >> 1] = HEAPU16[$0 + 24 >> 1] | 2;
     $8 = HEAPU8[$2 + 20 | 0];
     $3 = $5 - $8 | 0;
     if (HEAP32[$0 + 36 >> 2] != ($5 | 0)) {
      releasePageOne($7);
      HEAP32[$0 + 36 >> 2] = $5;
      HEAP32[$0 + 40 >> 2] = $3;
      freeTempSpace($0);
      $1 = sqlite3PagerSetPagesize(HEAP32[$0 >> 2], $0 + 36 | 0, $8);
      break label$1;
     }
     label$11: {
      $8 = HEAP32[$4 + 8 >> 2];
      if ($8 >>> 0 >= $6 >>> 0) {
       break label$11;
      }
      $6 = $8;
      if (sqlite3WritableSchema(HEAP32[$0 + 4 >> 2])) {
       break label$11;
      }
      $1 = sqlite3CorruptError(70154);
      break label$4;
     }
     if ($3 >>> 0 < 480) {
      break label$4;
     }
     HEAP32[$0 + 40 >> 2] = $3;
     HEAP32[$0 + 36 >> 2] = $5;
     HEAP8[$0 + 17 | 0] = (sqlite3Get4byte($2 + 52 | 0) | 0) != 0;
     HEAP8[$0 + 18 | 0] = (sqlite3Get4byte($2 - -64 | 0) | 0) != 0;
    }
    HEAP32[$0 + 48 >> 2] = $6;
    HEAP32[$0 + 12 >> 2] = $7;
    HEAP16[$0 + 30 >> 1] = $3 - 35;
    $1 = ((($3 << 5) - 384 >>> 0) / 255 | 0) - 23 | 0;
    HEAP16[$0 + 32 >> 1] = $1;
    HEAP16[$0 + 28 >> 1] = $1;
    $1 = ((($3 << 6) - 768 >>> 0) / 255 | 0) - 23 | 0;
    HEAP16[$0 + 26 >> 1] = $1;
    $1 = $1 & 65535;
    HEAP8[$0 + 21 | 0] = $1 >>> 0 < 127 ? $1 : 127;
    $1 = 0;
    break label$1;
   }
   $1 = $3;
  }
  releasePageOne($7);
  HEAP32[$0 + 12 >> 2] = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $1;
}

function unicodeNext($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $9 = HEAP32[$0 + 4 >> 2];
 $11 = $9 + HEAP32[$0 + 8 >> 2] | 0;
 $9 = HEAP32[$0 + 12 >> 2] + $9 | 0;
 $12 = HEAP32[$0 >> 2];
 while (1) {
  $13 = $9;
  if ($9 >>> 0 >= $11 >>> 0) {
   return 101;
  }
  $9 = $13 + 1 | 0;
  $8 = HEAPU8[$13 | 0];
  if ($8 >>> 0 >= 192) {
   $6 = HEAPU8[$8 + 32128 | 0];
   while (1) {
    label$5: {
     if (($9 | 0) == ($11 | 0)) {
      $9 = $11;
      break label$5;
     }
     $8 = HEAPU8[$9 | 0];
     if (($8 & 192) != 128) {
      break label$5;
     }
     $6 = $8 & 63 | $6 << 6;
     $9 = $9 + 1 | 0;
     continue;
    }
    break;
   }
   $8 = ($6 & -2) == 65534 ? 65533 : $6 >>> 0 < 128 ? 65533 : ($6 & -2048) == 55296 ? 65533 : $6;
  }
  if (!unicodeIsAlnum($12, $8)) {
   continue;
  }
  break;
 }
 $10 = HEAP32[$0 + 20 >> 2];
 $7 = $10;
 while (1) {
  $6 = HEAP32[$0 + 24 >> 2];
  if (($6 - 4 | 0) <= ($7 - $10 | 0)) {
   $6 = $6 - -64 | 0;
   $6 = sqlite3_realloc64($10, $6, $6 >> 31);
   if (!$6) {
    return 7;
   }
   $10 = HEAP32[$0 + 20 >> 2];
   HEAP32[$0 + 20 >> 2] = $6;
   HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] - -64;
   $7 = ($7 - $10 | 0) + $6 | 0;
  }
  $6 = sqlite3FtsUnicodeFold($8, HEAP32[$12 + 4 >> 2]);
  label$10: {
   if (!$6) {
    break label$10;
   }
   if (($6 | 0) <= 127) {
    HEAP8[$7 | 0] = $6;
    $7 = $7 + 1 | 0;
    break label$10;
   }
   if ($6 >>> 0 <= 2047) {
    HEAP8[$7 + 1 | 0] = $6 & 63 | 128;
    HEAP8[$7 | 0] = $6 >>> 6 | 192;
    $7 = $7 + 2 | 0;
    break label$10;
   }
   if ($6 >>> 0 <= 65535) {
    HEAP8[$7 + 2 | 0] = $6 & 63 | 128;
    HEAP8[$7 | 0] = $6 >>> 12 | 224;
    HEAP8[$7 + 1 | 0] = $6 >>> 6 & 63 | 128;
    $7 = $7 + 3 | 0;
    break label$10;
   }
   HEAP8[$7 + 3 | 0] = $6 & 63 | 128;
   HEAP8[$7 + 2 | 0] = $6 >>> 6 & 63 | 128;
   HEAP8[$7 + 1 | 0] = $6 >>> 12 & 63 | 128;
   HEAP8[$7 | 0] = $6 >>> 18 & 7 | 240;
   $7 = $7 + 4 | 0;
  }
  label$14: {
   label$15: {
    label$16: {
     if ($9 >>> 0 < $11 >>> 0) {
      $6 = $9 + 1 | 0;
      $8 = HEAPU8[$9 | 0];
      if ($8 >>> 0 < 192) {
       break label$15;
      }
      $8 = HEAPU8[$8 + 32128 | 0];
      while (1) {
       if (($6 | 0) == ($11 | 0)) {
        $6 = $11;
        break label$16;
       }
       $10 = HEAPU8[$6 | 0];
       if (($10 & 192) != 128) {
        break label$16;
       }
       $8 = $10 & 63 | $8 << 6;
       $6 = $6 + 1 | 0;
       continue;
      }
     }
     $6 = $9;
     break label$14;
    }
    $8 = ($8 & -2) == 65534 ? 65533 : $8 >>> 0 < 128 ? 65533 : ($8 & -2048) == 55296 ? 65533 : $8;
   }
   if (!unicodeIsAlnum($12, $8)) {
    if (!sqlite3FtsUnicodeIsdiacritic($8)) {
     break label$14;
    }
   }
   $10 = HEAP32[$0 + 20 >> 2];
   $9 = $6;
   continue;
  }
  break;
 }
 HEAP32[$0 + 12 >> 2] = $6 - HEAP32[$0 + 4 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 + 20 >> 2];
 HEAP32[$2 >> 2] = $7 - HEAP32[$0 + 20 >> 2];
 $6 = HEAP32[$0 + 4 >> 2];
 HEAP32[$3 >> 2] = $13 - $6;
 HEAP32[$4 >> 2] = $9 - $6;
 $9 = HEAP32[$0 + 16 >> 2];
 HEAP32[$0 + 16 >> 2] = $9 + 1;
 HEAP32[$5 >> 2] = $9;
 return 0;
}

function jsonEachColumn($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 144 | 0;
 __stack_pointer = $3;
 $7 = HEAP32[$0 + 40 >> 2];
 $5 = HEAP32[$0 + 12 >> 2];
 $4 = $7 + Math_imul($5, 12) | 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     switch ($2 | 0) {
     case 0:
      if (!$5) {
       break label$1;
      }
      label$12: {
       switch (HEAPU8[$0 + 20 | 0] - 6 | 0) {
       case 1:
        jsonReturn($4, $1);
        break label$1;

       case 0:
        break label$12;

       default:
        break label$1;
       }
      }
      $2 = $0 + 4 | 0;
      if (HEAPU8[$0 + 21 | 0]) {
       if (!HEAP32[$0 + 4 >> 2]) {
        break label$1;
       }
       $2 = (Math_imul(HEAP32[HEAP32[$0 + 48 >> 2] + ($5 << 2) >> 2], 12) + $7 | 0) + 8 | 0;
      }
      sqlite3_result_int64($1, HEAP32[$2 >> 2], 0);
      break label$1;

     case 1:
      jsonReturn(Math_imul(HEAPU8[$4 + 1 | 0] >>> 6 & 1, 12) + $4 | 0, $1);
      break label$1;

     case 2:
      sqlite3_result_text($1, HEAP32[(HEAPU8[Math_imul(HEAPU8[$4 + 1 | 0] >>> 6 & 1, 12) + $4 | 0] << 2) + 51152 >> 2], -1, 0);
      break label$1;

     case 3:
      $0 = Math_imul(HEAPU8[$4 + 1 | 0] >>> 6 & 1, 12) + $4 | 0;
      if (HEAPU8[$0 | 0] > 5) {
       break label$1;
      }
      jsonReturn($0, $1);
      break label$1;

     case 4:
      $0 = HEAPU8[$4 + 1 | 0] >>> 6 & 1;
      $2 = $0 + $5 | 0;
      $6 = $0 >>> 0 > $2 >>> 0 ? 1 : $6;
      sqlite3_result_int64($1, $2, $6);
      break label$1;

     case 5:
      if (!HEAPU8[$0 + 21 | 0] | HEAPU32[$0 + 8 >> 2] >= $5 >>> 0) {
       break label$1;
      }
      $6 = HEAP32[HEAP32[$0 + 48 >> 2] + ($5 << 2) >> 2];
      sqlite3_result_int64($1, $6, 0);
      break label$1;

     case 6:
      jsonInit($3 + 16 | 0, $1);
      label$15: {
       if (HEAPU8[$0 + 21 | 0]) {
        jsonEachComputePath($0, $3 + 16 | 0, HEAP32[$0 + 12 >> 2]);
        break label$15;
       }
       $2 = HEAP32[$0 + 28 >> 2];
       label$17: {
        if ($2) {
         jsonAppendRaw($3 + 16 | 0, $2, strlen($2));
         break label$17;
        }
        jsonAppendChar($3 + 16 | 0, 36);
       }
       label$19: {
        switch (HEAPU8[$0 + 20 | 0] - 6 | 0) {
        case 0:
         HEAP32[$3 >> 2] = HEAP32[$0 + 4 >> 2];
         jsonPrintf(30, $3 + 16 | 0, 17881, $3);
         break label$15;

        case 1:
         break label$19;

        default:
         break label$15;
        }
       }
       jsonAppendObjectPathElement($3 + 16 | 0, $4);
      }
      jsonResult($3 + 16 | 0);
      break label$1;

     case 8:
      break label$2;

     case 7:
      break label$4;

     default:
      break label$3;
     }
    }
    if (!HEAPU8[$0 + 21 | 0]) {
     break label$3;
    }
    jsonInit($3 + 16 | 0, $1);
    jsonEachComputePath($0, $3 + 16 | 0, HEAP32[HEAP32[$0 + 48 >> 2] + (HEAP32[$0 + 12 >> 2] << 2) >> 2]);
    jsonResult($3 + 16 | 0);
    break label$1;
   }
   $0 = HEAP32[$0 + 28 >> 2];
   sqlite3_result_text($1, $0 ? $0 : 28299, -1, 0);
   break label$1;
  }
  sqlite3_result_text($1, HEAP32[$0 + 44 >> 2], -1, 0);
 }
 __stack_pointer = $3 + 144 | 0;
 return 0;
}

function fillInCell($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $4 = HEAPU8[$0 + 10 | 0];
 label$1: {
  if (HEAPU8[$0 + 1 | 0]) {
   $11 = HEAP32[$2 + 16 >> 2];
   $8 = HEAP32[$2 + 28 >> 2];
   $5 = $8 + HEAP32[$2 + 32 >> 2] | 0;
   label$3: {
    if ($5 >>> 0 <= 127) {
     HEAP8[$1 + $4 | 0] = $5;
     $9 = 1;
     break label$3;
    }
    $9 = sqlite3PutVarint($1 + $4 | 0, $5, $5 >> 31) & 255;
   }
   $4 = $9 + $4 | 0;
   $6 = HEAP32[$2 + 12 >> 2];
   $6 = $4 + sqlite3PutVarint($4 + $1 | 0, HEAP32[$2 + 8 >> 2], $6) | 0;
   break label$1;
  }
  $11 = HEAP32[$2 >> 2];
  $6 = HEAP32[$2 + 8 >> 2];
  $8 = $6;
  label$5: {
   if ($8 >>> 0 <= 127) {
    HEAP8[$1 + $4 | 0] = $6;
    $5 = 1;
    break label$5;
   }
   $5 = sqlite3PutVarint($1 + $4 | 0, $6, $6 >> 31) & 255;
  }
  $6 = $5 + $4 | 0;
  $5 = $8;
 }
 $4 = $1 + $6 | 0;
 $2 = HEAPU16[$0 + 14 >> 1];
 label$7: {
  if (($5 | 0) <= ($2 | 0)) {
   $0 = $5 + $6 | 0;
   HEAP32[$3 >> 2] = ($0 | 0) > 4 ? $0 : 4;
   $0 = 0;
   memset(__memcpy($4, $11, $8) + $8 | 0, 0, $5 - $8 | 0);
   break label$7;
  }
  $10 = HEAPU16[$0 + 16 >> 1];
  $9 = HEAP32[$0 + 52 >> 2];
  $0 = $10 + (($5 - $10 >>> 0) % (HEAP32[$9 + 40 >> 2] - 4 >>> 0) | 0) | 0;
  $2 = ($0 | 0) > ($2 | 0) ? $10 : $0;
  $0 = $6 + $2 | 0;
  HEAP32[$3 >> 2] = $0 + 4;
  HEAP32[$7 + 8 >> 2] = 0;
  $3 = $0 + $1 | 0;
  $6 = 0;
  $1 = 0;
  label$9: {
   while (1) {
    $0 = ($2 | 0) > ($5 | 0) ? $5 : $2;
    label$11: {
     if (($8 | 0) >= ($0 | 0)) {
      __memcpy($4, $11, $0);
      break label$11;
     }
     if (($8 | 0) > 0) {
      __memcpy($4, $11, $8);
      $0 = $8;
      break label$11;
     }
     memset($4, 0, $0);
    }
    $5 = $5 - $0 | 0;
    if (($5 | 0) > 0) {
     $8 = $8 - $0 | 0;
     $11 = $0 + $11 | 0;
     $4 = $0 + $4 | 0;
     $2 = $2 - $0 | 0;
     if ($2) {
      continue;
     }
     HEAP32[$7 + 4 >> 2] = 0;
     $0 = $6;
     if (HEAPU8[$9 + 17 | 0]) {
      $4 = HEAP32[16232];
      while (1) {
       $2 = $0;
       $0 = $0 + 1 | 0;
       if (($0 | 0) == (ptrmapPageno($9, $0) | 0) | (($4 >>> 0) / HEAPU32[$9 + 36 >> 2] | 0) == ($2 | 0)) {
        continue;
       }
       break;
      }
      HEAP32[$7 + 8 >> 2] = $0;
     }
     $0 = allocateBtreePage($9, $7 + 4 | 0, $7 + 8 | 0, $0, 0);
     HEAP32[$7 + 12 >> 2] = $0;
     label$17: {
      if (!(!HEAPU8[$9 + 17 | 0] | $0)) {
       $10 = HEAP32[$7 + 8 >> 2];
       ptrmapPut($9, $10, $6 ? 4 : 3, $6, $7 + 12 | 0);
       $0 = HEAP32[$7 + 12 >> 2];
       if (!$0) {
        break label$17;
       }
       releasePage(HEAP32[$7 + 4 >> 2]);
       break label$9;
      }
      if ($0) {
       break label$9;
      }
      $10 = HEAP32[$7 + 8 >> 2];
     }
     sqlite3Put4byte($3, $10);
     releasePage($1);
     $1 = HEAP32[$7 + 4 >> 2];
     $3 = HEAP32[$1 + 56 >> 2];
     sqlite3Put4byte($3, 0);
     $2 = HEAP32[$9 + 40 >> 2] - 4 | 0;
     $4 = HEAP32[$1 + 56 >> 2] + 4 | 0;
     $6 = $10;
     continue;
    }
    break;
   }
   releasePage($1);
   $0 = 0;
   break label$7;
  }
  releasePage($1);
 }
 __stack_pointer = $7 + 16 | 0;
 return $0;
}

function whereScanNext($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $1 = HEAPU8[$0 + 25 | 0];
 $4 = HEAP32[$0 + 4 >> 2];
 $5 = HEAP32[$0 + 16 >> 2];
 while (1) {
  $1 = ($1 & 255) - 1 | 0;
  $8 = HEAP16[(($1 << 1) + $0 | 0) + 72 >> 1];
  $9 = HEAP32[(($1 << 2) + $0 | 0) + 28 >> 2];
  while (1) {
   $1 = HEAP32[$4 + 24 >> 2] + Math_imul($5, 48) | 0;
   while (1) {
    if (HEAP32[$4 + 12 >> 2] > ($5 | 0)) {
     label$5: {
      if (HEAP32[$1 + 20 >> 2] != ($9 | 0) | HEAP32[$1 + 24 >> 2] != ($8 | 0)) {
       break label$5;
      }
      if (($8 | 0) == -2) {
       if (sqlite3ExprCompareSkip(HEAP32[HEAP32[$1 >> 2] + 12 >> 2], HEAP32[$0 + 12 >> 2], $9)) {
        break label$5;
       }
      }
      if (HEAP8[HEAP32[$1 >> 2] + 4 | 0] & 1 & HEAPU8[$0 + 25 | 0] >= 2) {
       break label$5;
      }
      $7 = HEAPU16[$1 + 12 >> 1];
      label$8: {
       if (!($7 & 2048)) {
        break label$8;
       }
       $6 = HEAPU8[$0 + 26 | 0];
       if ($6 >>> 0 > 10) {
        break label$8;
       }
       $3 = whereRightSubexprIsColumn(HEAP32[$1 >> 2]);
       if (!$3) {
        break label$8;
       }
       $2 = 0;
       label$9: {
        while (1) {
         if (($2 | 0) == ($6 | 0)) {
          break label$9;
         }
         if (!(HEAP32[(($2 << 2) + $0 | 0) + 28 >> 2] == HEAP32[$3 + 28 >> 2] & HEAPU16[(($2 << 1) + $0 | 0) + 72 >> 1] == HEAPU16[$3 + 32 >> 1])) {
          $2 = $2 + 1 | 0;
          continue;
         }
         break;
        }
        if (($2 | 0) != ($6 | 0)) {
         break label$8;
        }
       }
       HEAP32[(($6 << 2) + $0 | 0) + 28 >> 2] = HEAP32[$3 + 28 >> 2];
       HEAP16[(($6 << 1) + $0 | 0) + 72 >> 1] = HEAPU16[$3 + 32 >> 1];
       HEAP8[$0 + 26 | 0] = $6 + 1;
       $7 = HEAPU16[$1 + 12 >> 1];
      }
      $2 = $7;
      if (!($2 & HEAP32[$0 + 20 >> 2])) {
       break label$5;
      }
      if (!(!HEAP32[$0 + 8 >> 2] | $2 & 256)) {
       $2 = HEAP32[HEAP32[$4 >> 2] >> 2];
       $3 = HEAP32[$1 >> 2];
       if (!sqlite3IndexAffinityOk($3, HEAP8[$0 + 24 | 0])) {
        break label$5;
       }
       $3 = sqlite3ExprCompareCollSeq($2, $3);
       if (!$3) {
        $3 = HEAP32[HEAP32[$2 >> 2] + 8 >> 2];
       }
       if (sqlite3StrICmp(HEAP32[$3 >> 2], HEAP32[$0 + 8 >> 2])) {
        break label$5;
       }
       $7 = HEAPU16[$1 + 12 >> 1];
      }
      label$15: {
       if (!($7 & 130)) {
        break label$15;
       }
       $2 = HEAP32[HEAP32[$1 >> 2] + 16 >> 2];
       if (!$2 | HEAPU8[$2 | 0] != 167 | HEAP32[$2 + 28 >> 2] != HEAP32[$0 + 28 >> 2]) {
        break label$15;
       }
       if (HEAPU16[$2 + 32 >> 1] == HEAPU16[$0 + 72 >> 1]) {
        break label$5;
       }
      }
      HEAP32[$0 + 4 >> 2] = $4;
      HEAP32[$0 + 16 >> 2] = $5 + 1;
      return $1;
     }
     $1 = $1 + 48 | 0;
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   $5 = 0;
   $4 = HEAP32[$4 + 4 >> 2];
   if ($4) {
    continue;
   }
   break;
  }
  $1 = HEAPU8[$0 + 25 | 0];
  if ($1 >>> 0 < HEAPU8[$0 + 26 | 0]) {
   $1 = $1 + 1 | 0;
   HEAP8[$0 + 25 | 0] = $1;
   $4 = HEAP32[$0 >> 2];
   continue;
  }
  break;
 }
 return 0;
}

function fkLookupParent($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $10 = sqlite3GetVdbe($0);
 $9 = HEAP32[$0 + 40 >> 2];
 $12 = sqlite3VdbeMakeLabel($0);
 if (($7 | 0) < 0) {
  sqlite3VdbeAddOp2($10, 48, HEAPU8[$4 + 24 | 0], $12);
 }
 $14 = $9 - 1 | 0;
 $13 = $6 + 1 | 0;
 $9 = 0;
 while (1) {
  $11 = HEAP32[$4 + 20 >> 2];
  if (($9 | 0) < ($11 | 0)) {
   sqlite3VdbeAddOp2($10, 50, sqlite3TableColumnToStorage(HEAP32[$4 >> 2], HEAP16[($9 << 2) + $5 >> 1]) + $13 | 0, $12);
   $9 = $9 + 1 | 0;
   continue;
  }
  break;
 }
 label$4: {
  if ($8) {
   break label$4;
  }
  if (!$3) {
   $9 = sqlite3GetTempReg($0);
   sqlite3VdbeAddOp2($10, 81, sqlite3TableColumnToStorage(HEAP32[$4 >> 2], HEAP16[$5 >> 1]) + $13 | 0, $9);
   $13 = sqlite3VdbeAddOp2($10, 12, $9, 0);
   if (!(($7 | 0) != 1 | HEAP32[$4 >> 2] != ($2 | 0))) {
    sqlite3VdbeAddOp3($10, 53, $6, $12, $9);
    sqlite3VdbeChangeP5($10, 144);
   }
   sqlite3OpenTable($0, $14, $1, $2, 112);
   sqlite3VdbeAddOp3($10, 30, $14, 0, $9);
   sqlite3VdbeGoto($10, $12);
   sqlite3VdbeJumpHere($10, sqlite3VdbeCurrentAddr($10) - 2 | 0);
   sqlite3VdbeJumpHere($10, $13);
   sqlite3ReleaseTempReg($0, $9);
   break label$4;
  }
  $15 = sqlite3GetTempRange($0, $11);
  sqlite3VdbeAddOp3($10, 112, $14, HEAP32[$3 + 44 >> 2], $1);
  sqlite3VdbeSetP4KeyInfo($0, $3);
  $9 = 0;
  $1 = ($11 | 0) > 0 ? $11 : 0;
  while (1) {
   $8 = HEAP32[$4 >> 2];
   if (($1 | 0) != ($9 | 0)) {
    sqlite3VdbeAddOp2($10, 80, sqlite3TableColumnToStorage($8, HEAP16[($9 << 2) + $5 >> 1]) + $13 | 0, $9 + $15 | 0);
    $9 = $9 + 1 | 0;
    continue;
   }
   break;
  }
  if (!(($7 | 0) != 1 | ($2 | 0) != ($8 | 0))) {
   $16 = (sqlite3VdbeCurrentAddr($10) + $11 | 0) + 1 | 0;
   $9 = 0;
   while (1) {
    if (($1 | 0) != ($9 | 0)) {
     $17 = sqlite3TableColumnToStorage(HEAP32[$4 >> 2], HEAP16[($9 << 2) + $5 >> 1]) + $13 | 0;
     $8 = HEAPU16[HEAP32[$3 + 4 >> 2] + ($9 << 1) >> 1];
     sqlite3VdbeAddOp3($10, 52, $17, $16, (wasm2js_i32$0 = $6, wasm2js_i32$1 = sqlite3TableColumnToStorage(HEAP32[$3 + 12 >> 2], $8 << 16 >> 16) + $13 | 0, 
     wasm2js_i32$2 = HEAPU16[$2 + 32 >> 1] == ($8 | 0), wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1));
     sqlite3VdbeChangeP5($10, 16);
     $9 = $9 + 1 | 0;
     continue;
    }
    break;
   }
   sqlite3VdbeGoto($10, $12);
  }
  sqlite3VdbeAddOp4($10, 96, $15, $11, 0, sqlite3IndexAffinityStr(HEAP32[$0 >> 2], $3), $11);
  sqlite3VdbeAddOp4Int($10, 28, $14, $12, $15, $11);
  sqlite3ReleaseTempRange($0, $15, $11);
 }
 $9 = HEAPU8[$4 + 24 | 0];
 label$12: {
  label$13: {
   if ($9) {
    break label$13;
   }
   if (!(HEAPU8[$0 + 20 | 0] | (HEAP32[$0 + 116 >> 2] | HEAPU8[HEAP32[$0 >> 2] + 34 | 0] & 8))) {
    sqlite3HaltConstraint($0, 787, 2, 0, -1, 4);
    break label$12;
   }
   if (($7 | 0) <= 0) {
    $9 = 0;
    break label$13;
   }
   sqlite3MayAbort($0);
   $9 = HEAPU8[$4 + 24 | 0];
  }
  sqlite3VdbeAddOp2($10, 158, $9 & 255, $7);
 }
 sqlite3VdbeResolveLabel($10, $12);
 sqlite3VdbeAddOp1($10, 122, $14);
}

function sqlite3Fts3CacheDeferredDoclists($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 label$1: {
  if (!HEAP32[$0 + 28 >> 2]) {
   break label$1;
  }
  $10 = $0 + 28 | 0;
  $9 = HEAP32[$0 >> 2];
  $14 = HEAP32[$9 + 36 >> 2];
  $15 = HEAP32[$14 >> 2];
  $3 = sqlite3_column_int64(HEAP32[$0 + 12 >> 2], 0);
  $17 = $3;
  $1 = i64toi32_i32$HIGH_BITS;
  $18 = $1;
  while (1) {
   $1 = HEAP32[$9 + 24 >> 2];
   $3 = $1 >> 31;
   $11 = $1;
   $12 = $3;
   $4 = $6;
   label$4: {
    while (1) {
     $1 = $12;
     if (($5 | 0) >= ($1 | 0) & $7 >>> 0 >= $11 >>> 0 | ($5 | 0) > ($1 | 0) | $4) {
      break label$4;
     }
     if (HEAPU8[$7 + HEAP32[$9 + 32 >> 2] | 0]) {
      $1 = $7 + 1 | 0;
      $3 = $1 ? $5 : $5 + 1 | 0;
      $7 = $1;
      $5 = $3;
      $4 = 0;
      continue;
     }
     break;
    }
    $3 = $7 + 1 | 0;
    $1 = $3 ? $5 : $5 + 1 | 0;
    $11 = $3;
    $12 = $1;
    $4 = sqlite3_column_text(HEAP32[$0 + 12 >> 2], $3);
    HEAP32[$2 + 24 >> 2] = 0;
    $6 = sqlite3Fts3OpenTokenizer($14, HEAP32[$0 + 20 >> 2], $4, -1, $2 + 24 | 0);
    $13 = HEAP32[$2 + 24 >> 2];
    label$7: while (1) {
     if (!$6) {
      HEAP32[$2 + 16 >> 2] = 0;
      HEAP32[$2 + 12 >> 2] = 0;
      HEAP32[$2 + 8 >> 2] = 0;
      HEAP32[$2 + 4 >> 2] = 0;
      $6 = FUNCTION_TABLE[HEAP32[$15 + 20 >> 2]]($13, $2 + 20 | 0, $2 + 16 | 0, $2 + 12 | 0, $2 + 8 | 0, $2 + 4 | 0) | 0;
      HEAP32[$2 + 28 >> 2] = $6;
      $4 = $10;
      while (1) {
       $4 = HEAP32[$4 >> 2];
       if (!$4 | $6) {
        continue label$7;
       }
       $3 = HEAP32[$4 >> 2];
       $6 = 0;
       $8 = HEAP32[$4 + 4 >> 2];
       $1 = $8;
       label$10: {
        if ((($1 | 0) != ($7 | 0) | ($5 | 0) != 0) & HEAP32[$9 + 24 >> 2] > ($1 | 0)) {
         break label$10;
        }
        $8 = HEAP32[$2 + 4 >> 2];
        if ($8 ? HEAP32[$3 + 12 >> 2] : 0) {
         break label$10;
        }
        $1 = HEAP32[$3 + 4 >> 2];
        $16 = HEAP32[$2 + 16 >> 2];
        if (($1 | 0) != ($16 | 0) & (!HEAP32[$3 + 8 >> 2] | ($1 | 0) >= ($16 | 0))) {
         break label$10;
        }
        if (memcmp(HEAP32[$2 + 20 >> 2], HEAP32[$3 >> 2], $1)) {
         break label$10;
        }
        $1 = $8;
        $3 = $1 >> 31;
        $1 = $3;
        $3 = $18;
        fts3PendingListAppend($4 + 12 | 0, $17, $3, $7, $5, $8, $1, $2 + 28 | 0);
        $6 = HEAP32[$2 + 28 >> 2];
       }
       $4 = $4 + 8 | 0;
       continue;
      }
     }
     break;
    }
    if ($13) {
     FUNCTION_TABLE[HEAP32[$15 + 16 >> 2]]($13) | 0;
    }
    if (($6 | 0) == 101) {
     HEAP32[$2 + 28 >> 2] = 0;
     $6 = 0;
    }
    $7 = $11;
    $1 = $12;
    $5 = $1;
    continue;
   }
   break;
  }
  while (1) {
   $4 = HEAP32[$10 >> 2];
   if (!$4 | $6) {
    break label$1;
   }
   if (HEAP32[$4 + 12 >> 2]) {
    $6 = fts3PendingListAppendVarint($4 + 12 | 0, 0, 0);
   } else {
    $6 = 0;
   }
   $10 = $4 + 8 | 0;
   continue;
  }
 }
 __stack_pointer = $2 + 32 | 0;
 return $6;
}

function jsonEachFilter($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 jsonEachCursorReset($0);
 label$1: {
  if (!$1) {
   break label$1;
  }
  $8 = sqlite3_value_text(HEAP32[$4 >> 2]);
  if (!$8) {
   break label$1;
  }
  $3 = sqlite3_value_bytes(HEAP32[$4 >> 2]);
  $2 = $3 >> 31;
  $5 = $3 + 1 | 0;
  $2 = $5 ? $2 : $2 + 1 | 0;
  $6 = sqlite3_malloc64($5, $2);
  HEAP32[$0 + 24 >> 2] = $6;
  $5 = 7;
  if (!$6) {
   break label$1;
  }
  __memcpy($6, $8, $3 + 1 | 0);
  label$2: {
   $6 = $0 + 32 | 0;
   if (jsonParse($6, 0, HEAP32[$0 + 24 >> 2])) {
    if (HEAPU8[$0 + 52 | 0]) {
     break label$2;
    }
    sqlite3_free(HEAP32[HEAP32[$0 >> 2] + 8 >> 2]);
    $5 = sqlite3_mprintf(19385, 0);
    HEAP32[HEAP32[$0 >> 2] + 8 >> 2] = $5;
    $5 = $5 ? 1 : 7;
    break label$2;
   }
   if (HEAPU8[$0 + 21 | 0]) {
    if (jsonParseFindParents($6)) {
     break label$2;
    }
   }
   label$5: {
    if (($1 | 0) == 3) {
     $5 = 0;
     HEAP32[$7 + 12 >> 2] = 0;
     $1 = sqlite3_value_text(HEAP32[$4 + 4 >> 2]);
     if (!$1) {
      break label$1;
     }
     $4 = sqlite3_value_bytes(HEAP32[$4 + 4 >> 2]);
     $2 = $4 >> 31;
     $3 = $4 + 1 | 0;
     $5 = $2;
     $5 = $3 ? $5 : $5 + 1 | 0;
     $5 = sqlite3_malloc64($3, $5);
     HEAP32[$0 + 28 >> 2] = $5;
     if (!$5) {
      $5 = 7;
      break label$1;
     }
     __memcpy($5, $1, $4 + 1 | 0);
     label$8: {
      label$9: {
       if (HEAPU8[$1 | 0] != 36) {
        HEAP32[$7 + 12 >> 2] = $1;
        break label$9;
       }
       $5 = 0;
       $4 = jsonLookupStep($6, 0, HEAP32[$0 + 28 >> 2] + 1 | 0, 0, $7 + 12 | 0);
       $1 = HEAP32[$7 + 12 >> 2];
       if (!$1) {
        break label$8;
       }
      }
      sqlite3_free(HEAP32[HEAP32[$0 >> 2] + 8 >> 2]);
      $5 = jsonPathSyntaxError($1);
      HEAP32[HEAP32[$0 >> 2] + 8 >> 2] = $5;
      jsonEachCursorReset($0);
      $5 = HEAP32[HEAP32[$0 >> 2] + 8 >> 2] ? 1 : 7;
      break label$1;
     }
     if (!$4) {
      break label$1;
     }
     $5 = HEAP32[$0 + 40 >> 2];
     break label$5;
    }
    $5 = HEAP32[$0 + 40 >> 2];
    $4 = $5;
   }
   $5 = ($4 - $5 | 0) / 12 | 0;
   HEAP32[$0 + 8 >> 2] = $5;
   HEAP32[$0 + 12 >> 2] = $5;
   $1 = HEAPU8[$4 | 0];
   HEAP8[$0 + 20 | 0] = $1;
   if ($1 >>> 0 >= 6) {
    $5 = 0;
    HEAP32[$4 + 8 >> 2] = 0;
    $1 = HEAP32[$0 + 12 >> 2];
    $6 = $1 + 1 | 0;
    HEAP32[$0 + 16 >> 2] = $6 + HEAP32[$4 + 4 >> 2];
    if (HEAPU8[$0 + 21 | 0]) {
     $4 = HEAP32[$0 + 40 >> 2];
     HEAP8[$0 + 20 | 0] = HEAPU8[$4 + Math_imul(HEAP32[HEAP32[$0 + 48 >> 2] + ($1 << 2) >> 2], 12) | 0];
     if (!$1) {
      break label$1;
     }
     $1 = $1 - 1 | 0;
     if (!(HEAPU8[(Math_imul($1, 12) + $4 | 0) + 1 | 0] & 64)) {
      break label$1;
     }
     HEAP32[$0 + 12 >> 2] = $1;
     break label$1;
    }
    HEAP32[$0 + 12 >> 2] = $6;
    break label$1;
   }
   HEAP32[$0 + 16 >> 2] = $5 + 1;
   $5 = 0;
   break label$1;
  }
  jsonEachCursorReset($0);
 }
 __stack_pointer = $7 + 16 | 0;
 return $5 | 0;
}

function sqlite3BtreeTransferRow($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = 0;
 $8 = HEAP32[$0 + 20 >> 2];
 $5 = HEAP32[$8 + 84 >> 2];
 getCellInfo($1);
 $4 = HEAP32[$1 + 44 >> 2];
 label$1: {
  if ($4 >>> 0 <= 127) {
   HEAP8[$5 | 0] = $4;
   $7 = $5 + 1 | 0;
   break label$1;
  }
  $7 = sqlite3PutVarint($5, $4, 0) + $5 | 0;
 }
 if (!HEAP32[$0 + 112 >> 2]) {
  $7 = sqlite3PutVarint($7, $2, $3) + $7 | 0;
 }
 $5 = HEAPU16[$1 + 48 >> 1];
 $9 = HEAP32[$1 + 40 >> 2];
 $4 = $5 + $9 | 0;
 $11 = HEAP32[HEAP32[$1 + 116 >> 2] + 60 >> 2];
 label$4: {
  if ($4 >>> 0 > $11 >>> 0) {
   $4 = sqlite3CorruptError(76188);
   break label$4;
  }
  $2 = HEAP32[$1 + 44 >> 2];
  $0 = HEAP32[$0 + 116 >> 2];
  if (!(($2 | 0) != ($5 | 0) | HEAPU16[$0 + 14 >> 1] <= $5 >>> 0)) {
   HEAP32[$8 + 88 >> 2] = (__memcpy($7, $9, $5) + $5 | 0) - HEAP32[$8 + 84 >> 2];
   $4 = 0;
   break label$4;
  }
  $13 = HEAP32[HEAP32[$1 + 20 >> 2] >> 2];
  HEAP32[$6 + 8 >> 2] = 0;
  $3 = $7 - HEAP32[$8 + 84 >> 2] | 0;
  $0 = btreePayloadToLocal($0, $2, 0);
  $10 = $3 + $0 | 0;
  $3 = $0 >>> 0 < $2 >>> 0;
  HEAP32[$8 + 88 >> 2] = $3 ? $10 + 4 | 0 : $10;
  $10 = 0;
  label$7: {
   if ($5 >>> 0 < $2 >>> 0) {
    if ($4 + 4 >>> 0 > $11 >>> 0) {
     break label$7;
    }
    $10 = sqlite3Get4byte($4);
   }
   $12 = $3 ? $0 + $7 | 0 : 0;
   $3 = 0;
   while (1) {
    $2 = $2 - $0 | 0;
    while (1) {
     if ($5) {
      $4 = $0 >>> 0 < $5 >>> 0 ? $0 : $5;
      $7 = __memcpy($7, $9, $4);
      $9 = $4 + $9 | 0;
      $7 = $4 + $7 | 0;
      $0 = $0 - $4 | 0;
      $5 = $5 - $4 | 0;
     } else {
      $5 = 0;
     }
     label$13: {
      if (!$0) {
       $4 = HEAP32[$6 + 12 >> 2];
       $11 = !$4;
       break label$13;
      }
      sqlite3PagerUnref(HEAP32[$6 + 8 >> 2]);
      $11 = 0;
      HEAP32[$6 + 8 >> 2] = 0;
      $4 = sqlite3PagerGet($13, $10, $6 + 8 | 0, 2);
      HEAP32[$6 + 12 >> 2] = $4;
      if ($4) {
       break label$13;
      }
      $5 = sqlite3PagerGetData(HEAP32[$6 + 8 >> 2]);
      $9 = $5 + 4 | 0;
      $10 = sqlite3Get4byte($5);
      $5 = HEAP32[HEAP32[$1 + 20 >> 2] + 40 >> 2] - 4 | 0;
      continue;
     }
     break;
    }
    if (!(!$12 | (!$11 | !$2))) {
     HEAP32[$6 >> 2] = 0;
     HEAP32[$6 + 12 >> 2] = allocateBtreePage($8, $6, $6 + 4 | 0, 0, 0);
     sqlite3Put4byte($12, HEAP32[$6 + 4 >> 2]);
     if (!(!HEAPU8[$8 + 17 | 0] | !$3)) {
      ptrmapPut($8, HEAP32[$6 + 4 >> 2], 4, HEAP32[$3 + 4 >> 2], $6 + 12 | 0);
     }
     releasePage($3);
     $3 = HEAP32[$6 >> 2];
     if ($3) {
      $12 = HEAP32[$3 + 56 >> 2];
      sqlite3Put4byte($12, 0);
      $7 = $12 + 4 | 0;
      $0 = HEAP32[$8 + 40 >> 2] - 4 | 0;
      $0 = $0 >>> 0 < $2 >>> 0 ? $0 : $2;
     }
     $4 = HEAP32[$6 + 12 >> 2];
    }
    if ($4 ? 0 : $2) {
     continue;
    }
    break;
   }
   releasePage($3);
   sqlite3PagerUnref(HEAP32[$6 + 8 >> 2]);
   break label$4;
  }
  $4 = sqlite3CorruptError(76211);
 }
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function readJournalHdr($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 $6 = journalHdrOffset($0);
 $12 = $6;
 $9 = i64toi32_i32$HIGH_BITS;
 $13 = $9;
 HEAP32[$0 + 80 >> 2] = $12;
 HEAP32[$0 + 84 >> 2] = $9;
 $10 = 101;
 $9 = HEAP32[$0 + 156 >> 2];
 $6 = $13;
 $8 = $6;
 $7 = $12;
 $6 = $7 + $9 | 0;
 $7 = $3;
 $8 = $9 >>> 0 > $6 >>> 0 ? $8 + 1 | 0 : $8;
 $9 = $2;
 label$1: {
  if (($7 | 0) <= ($8 | 0) & $6 >>> 0 > $9 >>> 0 | ($8 | 0) > ($7 | 0)) {
   break label$1;
  }
  label$2: {
   if (!$1) {
    $6 = HEAP32[$0 + 88 >> 2];
    $7 = $6;
    $8 = HEAP32[$0 + 92 >> 2];
    $6 = $8;
    $8 = $13;
    if (($7 | 0) == ($12 | 0) & ($6 | 0) == ($8 | 0)) {
     break label$2;
    }
   }
   $10 = sqlite3OsRead(HEAP32[$0 + 68 >> 2], $11 + 8 | 0, 8, $12, $13);
   if ($10) {
    break label$1;
   }
   $10 = 101;
   $7 = $11;
   $9 = HEAPU8[$7 + 8 | 0] | HEAPU8[$7 + 9 | 0] << 8 | (HEAPU8[$7 + 10 | 0] << 16 | HEAPU8[$7 + 11 | 0] << 24);
   $8 = HEAPU8[$7 + 12 | 0] | HEAPU8[$7 + 13 | 0] << 8 | (HEAPU8[$7 + 14 | 0] << 16 | HEAPU8[$7 + 15 | 0] << 24);
   $7 = $9;
   if (($7 | 0) != -117058087 | ($8 | 0) != -681336544) {
    break label$1;
   }
  }
  $7 = $13;
  $6 = $12;
  $9 = $6 + 8 | 0;
  $6 = $9 >>> 0 < 8 ? $7 + 1 | 0 : $7;
  $10 = read32bits(HEAP32[$0 + 68 >> 2], $9, $6, $4);
  if ($10) {
   break label$1;
  }
  $6 = $13;
  $9 = $6;
  $7 = $12;
  $8 = $7 + 12 | 0;
  $9 = $8 >>> 0 < 12 ? $9 + 1 | 0 : $9;
  $10 = read32bits(HEAP32[$0 + 68 >> 2], $8, $9, $0 + 52 | 0);
  if ($10) {
   break label$1;
  }
  $9 = $13;
  $8 = $9;
  $6 = $12;
  $6 = $6 + 16 | 0;
  $8 = $6 >>> 0 < 16 ? $8 + 1 | 0 : $8;
  $10 = read32bits(HEAP32[$0 + 68 >> 2], $6, $8, $5);
  if ($10) {
   break label$1;
  }
  $6 = HEAP32[$0 + 84 >> 2];
  $3 = $6;
  $8 = HEAP32[$0 + 80 >> 2];
  $2 = $8;
  label$4: {
   if ($6 | $8) {
    $1 = HEAP32[$0 + 156 >> 2];
    $10 = 0;
    break label$4;
   }
   $6 = $13;
   $9 = $12;
   $7 = $9 + 20 | 0;
   $6 = $7 >>> 0 < 20 ? $6 + 1 | 0 : $6;
   $10 = read32bits(HEAP32[$0 + 68 >> 2], $7, $6, $11);
   if ($10) {
    break label$1;
   }
   $6 = $13;
   $7 = $6;
   $6 = $12;
   $8 = $6 + 24 | 0;
   $7 = $8 >>> 0 < 24 ? $7 + 1 | 0 : $7;
   $10 = read32bits(HEAP32[$0 + 68 >> 2], $8, $7, $11 + 4 | 0);
   if ($10) {
    break label$1;
   }
   $4 = HEAP32[$11 + 4 >> 2];
   if (!$4) {
    $4 = HEAP32[$0 + 168 >> 2];
    HEAP32[$11 + 4 >> 2] = $4;
   }
   $10 = 101;
   if ($4 - 512 >>> 0 > 65024) {
    break label$1;
   }
   $1 = HEAP32[$11 >> 2];
   if ($1 >>> 0 < 32 | $1 >>> 0 > 65536 | (__wasm_popcnt_i32($4) >>> 0 > 1 | __wasm_popcnt_i32($1) >>> 0 >= 2)) {
    break label$1;
   }
   $10 = sqlite3PagerSetPagesize($0, $11 + 4 | 0, -1);
   HEAP32[$0 + 156 >> 2] = $1;
   $7 = HEAP32[$0 + 80 >> 2];
   $2 = $7;
   $6 = HEAP32[$0 + 84 >> 2];
   $3 = $6;
  }
  $6 = $3;
  $8 = $6;
  $6 = $2;
  $9 = $6 + $1 | 0;
  $8 = $9 >>> 0 < $1 >>> 0 ? $8 + 1 | 0 : $8;
  HEAP32[$0 + 80 >> 2] = $9;
  HEAP32[$0 + 84 >> 2] = $8;
 }
 __stack_pointer = $11 + 16 | 0;
 return $10;
}

function unixOpen($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $5 = __stack_pointer - 544 | 0;
 __stack_pointer = $5;
 $10 = $3 & 1048320;
 $8 = $3 & 4;
 $6 = 0;
 label$1: {
  if (!$8) {
   break label$1;
  }
  $6 = 1;
  if (($10 | 0) == 2048) {
   break label$1;
  }
  $6 = 1;
  if (($10 | 0) == 16384) {
   break label$1;
  }
  $6 = 1;
  if (($10 | 0) == 524288) {
   break label$1;
  }
  $6 = 0;
 }
 if (HEAP32[17716] != (getpid() | 0)) {
  HEAP32[17716] = getpid();
  sqlite3_randomness(0, 0);
 }
 $11 = memset($2, 0, 52);
 label$3: {
  label$4: {
   label$5: {
    label$6: {
     if (($10 | 0) == 256) {
      $2 = findReusableFd($1, $3);
      if ($2) {
       $7 = HEAP32[$2 >> 2];
       break label$6;
      }
      $7 = -1;
      $2 = sqlite3_malloc64(12, 0);
      if ($2) {
       break label$6;
      }
      $2 = 7;
      break label$3;
     }
     $7 = -1;
     if ($1) {
      break label$5;
     }
     $2 = unixGetTempname(HEAP32[$0 + 8 >> 2], $5 + 16 | 0);
     if ($2) {
      break label$3;
     }
     $2 = $5 + 16 | 0;
     break label$4;
    }
    HEAP32[$11 + 28 >> 2] = $2;
   }
   $2 = $1;
  }
  $9 = $2;
  $12 = $3 & 1;
  label$9: {
   label$10: {
    label$11: {
     if (($7 | 0) >= 0) {
      $2 = $3;
      break label$11;
     }
     $2 = findCreateFileMode($9, $3, $5 + 12 | 0, $5 + 8 | 0, $5 + 4 | 0);
     if ($2) {
      break label$3;
     }
     $2 = $3;
     $13 = $3 & 2;
     $14 = $13 | ($3 << 3 & 128 | $8 << 4) | 131072;
     $8 = HEAP32[$5 + 12 >> 2];
     $7 = robust_open($9, $14, $8);
     if (($7 | 0) < 0) {
      $2 = __errno_location();
      if (!(!$6 | HEAP32[$2 >> 2] != 2)) {
       $12 = 0;
       $15 = 1544;
       if (FUNCTION_TABLE[HEAP32[16243]]($9, 0) | 0) {
        break label$10;
       }
      }
      $12 = 1;
      $15 = 0;
      if (!$13 | HEAP32[$2 >> 2] == 31) {
       break label$10;
      }
      $7 = robust_open($9, $14 & 131200, $8);
      if (($7 | 0) < 0) {
       break label$10;
      }
      $2 = $3 & -8 | 1;
     }
     if (!$8 | !($2 & 526336)) {
      break label$11;
     }
     robustFchown($7, HEAP32[$5 + 8 >> 2], HEAP32[$5 + 4 >> 2]);
    }
    if ($4) {
     HEAP32[$4 >> 2] = $2;
    }
    $3 = $3 & 8;
    $4 = HEAP32[$11 + 28 >> 2];
    if ($4) {
     HEAP32[$4 >> 2] = $7;
     HEAP32[$4 + 4 >> 2] = $2 & 3;
    }
    if ($3) {
     FUNCTION_TABLE[HEAP32[16285]]($9) | 0;
    }
    $3 = $3 << 2;
    $3 = $12 ? $3 | 2 : $3;
    $3 = ($10 | 0) == 256 ? $3 : $3 | 128;
    $2 = fillInUnixFile($0, $7, $11, $1, $2 & 64 | ($6 ? $3 | 8 : $3));
    break label$9;
   }
   $2 = (wasm2js_i32$0 = unixLogErrorAtLine(sqlite3CantopenError(41714), 10788, $9, 41714), 
   wasm2js_i32$1 = $15, wasm2js_i32$2 = $12, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
  }
  if (!$2) {
   $2 = 0;
   break label$3;
  }
  sqlite3_free(HEAP32[$11 + 28 >> 2]);
 }
 __stack_pointer = $5 + 544 | 0;
 return $2 | 0;
}

function sqlite3RunParser($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = __stack_pointer - 1264 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$0 >> 2];
 $4 = HEAP32[$3 + 124 >> 2];
 if (!HEAP32[$3 + 184 >> 2]) {
  HEAP32[$3 + 296 >> 2] = 0;
 }
 HEAP32[$0 + 232 >> 2] = $1;
 HEAP32[$0 + 12 >> 2] = 0;
 sqlite3ParserInit($2 + 48 | 0, $0);
 $8 = HEAP32[$3 + 264 >> 2];
 HEAP32[$3 + 264 >> 2] = $0;
 $6 = -1;
 while (1) {
  label$3: {
   $5 = sqlite3GetToken($1, $2 + 1260 | 0);
   $4 = $4 - $5 | 0;
   if (($4 | 0) < 0) {
    HEAP32[$0 + 12 >> 2] = 18;
    HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
    break label$3;
   }
   $7 = HEAP32[$2 + 1260 >> 2];
   label$5: {
    if (($7 | 0) < 164) {
     $6 = $7;
     break label$5;
    }
    if (HEAP32[$3 + 296 >> 2]) {
     HEAP32[$0 + 12 >> 2] = 9;
     HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
     break label$3;
    }
    if (($7 | 0) == 183) {
     $1 = $1 + $5 | 0;
     continue;
    }
    if (!HEAPU8[$1 | 0]) {
     $5 = 0;
     $7 = 0;
     label$10: {
      switch ($6 | 0) {
      default:
       $7 = 1;
       break;

      case 1:
       break label$10;

      case 0:
       break label$3;
      }
     }
     HEAP32[$2 + 1260 >> 2] = $7;
     $6 = $7;
     break label$5;
    }
    label$12: {
     label$13: {
      switch ($7 - 164 | 0) {
      case 1:
       $6 = analyzeOverKeyword($1 + 4 | 0, $6);
       break label$12;

      case 2:
       $6 = analyzeFilterKeyword($1 + 6 | 0, $6);
       break label$12;

      default:
       HEAP32[$2 + 44 >> 2] = $5;
       HEAP32[$2 + 40 >> 2] = $1;
       HEAP32[$2 + 32 >> 2] = $2 + 40;
       sqlite3ErrorMsg($0, 28923, $2 + 32 | 0);
       break label$3;

      case 0:
       break label$13;
      }
     }
     $6 = analyzeWindowKeyword($1 + 6 | 0);
    }
    HEAP32[$2 + 1260 >> 2] = $6;
   }
   HEAP32[$0 + 200 >> 2] = $5;
   HEAP32[$0 + 196 >> 2] = $1;
   $7 = HEAP32[$0 + 200 >> 2];
   HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 196 >> 2];
   HEAP32[$2 + 28 >> 2] = $7;
   sqlite3Parser($2 + 48 | 0, $6, $2 + 24 | 0);
   $1 = $1 + $5 | 0;
   if (!HEAP32[$0 + 12 >> 2]) {
    continue;
   }
  }
  break;
 }
 sqlite3ParserFinalize($2 + 48 | 0);
 if (HEAPU8[$3 + 87 | 0]) {
  HEAP32[$0 + 12 >> 2] = 7;
 }
 $4 = HEAP32[$0 + 4 >> 2];
 label$18: {
  if (!$4) {
   $5 = HEAP32[$0 + 12 >> 2];
   $4 = 0;
   if (!$5 | ($5 | 0) == 101) {
    break label$18;
   }
   HEAP32[$2 + 16 >> 2] = sqlite3ErrStr($5);
   $4 = sqlite3MPrintf($3, 8342, $2 + 16 | 0);
   HEAP32[$0 + 4 >> 2] = $4;
  }
  $5 = HEAP32[$0 + 12 >> 2];
  HEAP32[$2 + 4 >> 2] = HEAP32[$0 + 232 >> 2];
  HEAP32[$2 >> 2] = $4;
  sqlite3_log($5, 28660, $2);
  $4 = 1;
 }
 HEAP32[$0 + 232 >> 2] = $1;
 sqlite3_free(HEAP32[$0 + 260 >> 2]);
 $1 = HEAP32[$0 + 236 >> 2];
 if (!(HEAPU8[$0 + 208 | 0] | !$1)) {
  sqlite3DeleteTable($3, $1);
 }
 $1 = HEAP32[$0 + 244 >> 2];
 if (!(!$1 | HEAPU8[$0 + 208 | 0] > 1)) {
  sqlite3DeleteTrigger($3, $1);
 }
 $1 = HEAP32[$0 + 224 >> 2];
 if ($1) {
  sqlite3DbFreeNN($3, $1);
 }
 HEAP32[$3 + 264 >> 2] = $8;
 __stack_pointer = $2 + 1264 | 0;
 return $4;
}

function fts3DoclistOrMerge($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $7 = __stack_pointer - 48 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 40 >> 2] = 0;
 HEAP32[$7 + 44 >> 2] = 0;
 HEAP32[$7 + 32 >> 2] = 0;
 HEAP32[$7 + 36 >> 2] = 0;
 HEAP32[$7 + 24 >> 2] = 0;
 HEAP32[$7 + 28 >> 2] = 0;
 HEAP32[$7 + 20 >> 2] = $1;
 HEAP32[$7 + 16 >> 2] = $3;
 HEAP32[$7 + 8 >> 2] = 0;
 HEAP32[$5 >> 2] = 0;
 HEAP32[$6 >> 2] = 0;
 $9 = $2 >> 31;
 $10 = $9;
 $9 = $4 >> 31;
 $11 = $9;
 $8 = $4 + $2 | 0;
 $9 = $10;
 $10 = $11 + $9 | 0;
 $10 = $8 >>> 0 < $4 >>> 0 ? $10 + 1 | 0 : $10;
 $9 = $8;
 $8 = $10;
 $11 = $9 + 17 | 0;
 $8 = $11 >>> 0 < 17 ? $8 + 1 | 0 : $8;
 $12 = sqlite3_malloc64($11, $8);
 label$1: {
  if (!$12) {
   $1 = 7;
   break label$1;
  }
  HEAP32[$7 + 12 >> 2] = $12;
  $13 = $1 + $2 | 0;
  fts3GetDeltaVarint3($7 + 20 | 0, $13, 0, $7 + 40 | 0);
  $4 = $3 + $4 | 0;
  fts3GetDeltaVarint3($7 + 16 | 0, $4, 0, $7 + 32 | 0);
  label$3: {
   label$4: {
    while (1) {
     $1 = HEAP32[$7 + 16 >> 2];
     $3 = HEAP32[$7 + 20 >> 2];
     if (!($1 | $3)) {
      break label$4;
     }
     $9 = HEAP32[$7 + 44 >> 2];
     $11 = $9;
     label$6: {
      $9 = HEAP32[$7 + 32 >> 2];
      $15 = $9;
      $2 = $9;
      $8 = HEAP32[$7 + 40 >> 2];
      $14 = $8;
      $10 = $8;
      $8 = HEAP32[$7 + 36 >> 2];
      $16 = $8;
      $9 = $8;
      $8 = $11;
      $17 = ($2 | 0) != ($10 | 0) | ($9 | 0) != ($8 | 0) ? -1 : 0;
      $10 = $8;
      $2 = $14;
      $8 = $9;
      $9 = $15;
      $2 = ($8 | 0) <= ($10 | 0) & $2 >>> 0 > $9 >>> 0 | ($8 | 0) < ($10 | 0) ? 1 : $17;
      $2 = $0 ? 0 - $2 | 0 : $2;
      if (!($2 | (!$1 | !$3))) {
       $2 = $11;
       fts3PutDeltaVarint3($7 + 12 | 0, $0, $7 + 24 | 0, $7 + 8 | 0, $14, $2);
       $1 = fts3PoslistMerge($7 + 12 | 0, $7 + 20 | 0, $7 + 16 | 0);
       if ($1) {
        break label$6;
       }
       fts3GetDeltaVarint3($7 + 20 | 0, $13, $0, $7 + 40 | 0);
       fts3GetDeltaVarint3($7 + 16 | 0, $4, $0, $7 + 32 | 0);
       continue;
      }
      if (!(($3 | 0) != 0 & ($2 | 0) < 0 ? 0 : $1)) {
       $2 = $11;
       fts3PutDeltaVarint3($7 + 12 | 0, $0, $7 + 24 | 0, $7 + 8 | 0, $14, $2);
       fts3PoslistCopy($7 + 12 | 0, $7 + 20 | 0);
       fts3GetDeltaVarint3($7 + 20 | 0, $13, $0, $7 + 40 | 0);
       continue;
      }
      $2 = $16;
      fts3PutDeltaVarint3($7 + 12 | 0, $0, $7 + 24 | 0, $7 + 8 | 0, $15, $2);
      fts3PoslistCopy($7 + 12 | 0, $7 + 16 | 0);
      fts3GetDeltaVarint3($7 + 16 | 0, $4, $0, $7 + 32 | 0);
      continue;
     }
     break;
    }
    sqlite3_free($12);
    $0 = 0;
    HEAP32[$7 + 12 >> 2] = 0;
    $12 = 0;
    break label$3;
   }
   $0 = HEAP32[$7 + 12 >> 2];
   HEAP8[$0 | 0] = 0;
   HEAP8[$0 + 1 | 0] = 0;
   HEAP8[$0 + 2 | 0] = 0;
   HEAP8[$0 + 3 | 0] = 0;
   HEAP8[$0 + 4 | 0] = 0;
   HEAP8[$0 + 5 | 0] = 0;
   HEAP8[$0 + 6 | 0] = 0;
   HEAP8[$0 + 7 | 0] = 0;
   $1 = 0;
  }
  HEAP32[$5 >> 2] = $12;
  HEAP32[$6 >> 2] = $0 - $12;
 }
 __stack_pointer = $7 + 48 | 0;
 return $1;
}

function sqlite3Prepare($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = __stack_pointer - 304 | 0;
 __stack_pointer = $7;
 memset($7 + 32 | 4, 0, 148);
 memset($7 + 228 | 0, 0, 76);
 HEAP32[$7 + 216 >> 2] = HEAP32[$0 + 264 >> 2];
 HEAP32[$0 + 264 >> 2] = $7 + 32;
 HEAP32[$7 + 260 >> 2] = $4;
 HEAP32[$7 + 32 >> 2] = $0;
 if (HEAPU8[$0 + 87 | 0]) {
  sqlite3ErrorMsg($7 + 32 | 0, 1141, 0);
 }
 if ($3 & 1) {
  HEAP8[$7 + 56 | 0] = HEAPU8[$7 + 56 | 0] + 1;
  HEAP16[$0 + 308 >> 1] = 0;
  HEAP32[$0 + 304 >> 2] = HEAP32[$0 + 304 >> 2] + 1;
 }
 HEAP8[$7 + 57 | 0] = $3 >>> 2 & 1;
 label$3: {
  label$4: {
   if (HEAPU8[$0 + 95 | 0]) {
    break label$4;
   }
   $4 = 0;
   while (1) {
    if (HEAP32[$0 + 20 >> 2] <= ($4 | 0)) {
     break label$4;
    }
    label$6: {
     $8 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($4 << 4) | 0) + 4 >> 2];
     if (!$8) {
      break label$6;
     }
     $8 = sqlite3BtreeSchemaLocked($8);
     if (!$8) {
      break label$6;
     }
     HEAP32[$7 >> 2] = HEAP32[HEAP32[$0 + 16 >> 2] + ($4 << 4) >> 2];
     sqlite3ErrorWithMsg($0, $8, 8200, $7);
     break label$3;
    }
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  sqlite3VtabUnlockList($0);
  label$7: {
   label$8: {
    if (!(($2 | 0) < 0 | (HEAPU8[($1 + $2 | 0) - 1 | 0] ? 0 : $2))) {
     if (HEAP32[$0 + 124 >> 2] < ($2 | 0)) {
      break label$7;
     }
     $4 = sqlite3DbStrNDup($0, $1, $2, 0);
     if ($4) {
      sqlite3RunParser($7 + 32 | 0, $4);
      HEAP32[$7 + 264 >> 2] = (HEAP32[$7 + 264 >> 2] - $4 | 0) + $1;
      sqlite3DbFree($0, $4);
      break label$8;
     }
     HEAP32[$7 + 264 >> 2] = $1 + $2;
     break label$8;
    }
    sqlite3RunParser($7 + 32 | 0, $1);
   }
   if ($6) {
    HEAP32[$6 >> 2] = HEAP32[$7 + 264 >> 2];
   }
   if (!HEAPU8[$0 + 177 | 0]) {
    sqlite3VdbeSetSql(HEAP32[$7 + 40 >> 2], $1, HEAP32[$7 + 264 >> 2] - $1 | 0, $3 & 255);
   }
   label$14: {
    label$15: {
     label$16: {
      if (HEAPU8[$0 + 87 | 0]) {
       HEAP8[$7 + 49 | 0] = 0;
       HEAP32[$7 + 44 >> 2] = 7;
       break label$16;
      }
      $4 = HEAP32[$7 + 44 >> 2];
      if (!$4 | ($4 | 0) == 101) {
       break label$15;
      }
     }
     if (!(HEAPU8[$0 + 177 | 0] | !HEAPU8[$7 + 49 | 0])) {
      schemaIsValid($7 + 32 | 0);
     }
     $4 = HEAP32[$7 + 40 >> 2];
     if ($4) {
      sqlite3VdbeFinalize($4);
     }
     $8 = HEAP32[$7 + 44 >> 2];
     $4 = HEAP32[$7 + 36 >> 2];
     if ($4) {
      HEAP32[$7 + 16 >> 2] = $4;
      sqlite3ErrorWithMsg($0, $8, 8342, $7 + 16 | 0);
      sqlite3DbFree($0, HEAP32[$7 + 36 >> 2]);
      break label$14;
     }
     sqlite3Error($0, $8);
     break label$14;
    }
    HEAP32[$5 >> 2] = HEAP32[$7 + 40 >> 2];
    sqlite3ErrorClear($0);
    $8 = 0;
   }
   while (1) {
    $4 = HEAP32[$7 + 156 >> 2];
    if (!$4) {
     break label$3;
    }
    HEAP32[$7 + 156 >> 2] = HEAP32[$4 + 4 >> 2];
    sqlite3DbFree($0, $4);
    continue;
   }
  }
  sqlite3ErrorWithMsg($0, 18, 11880, 0);
  $8 = sqlite3ApiExit($0, 18);
 }
 sqlite3ParseObjectReset($7 + 32 | 0);
 __stack_pointer = $7 + 304 | 0;
 return $8;
}

function fts3IncrmergePush($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 $6 = $1;
 $13 = HEAP32[$6 + 56 >> 2];
 $7 = HEAP32[$6 + 60 >> 2];
 $10 = $7;
 $14 = 1;
 while (1) {
  label$2: {
   if (($14 | 0) == 16) {
    $5 = 0;
    break label$2;
   }
   HEAP32[$11 + 12 >> 2] = 0;
   $4 = ($14 << 5) + $1 | 0;
   $15 = $4 - -64 | 0;
   $16 = $4;
   $17 = HEAP32[$4 + 68 >> 2];
   $8 = fts3PrefixCompress(HEAP32[$15 >> 2], $17, $2, $3);
   $12 = $3 - $8 | 0;
   if (($12 | 0) <= 0) {
    $5 = 267;
    break label$2;
   }
   $7 = $8 >> 31;
   $6 = $7;
   $7 = sqlite3Fts3VarintLen($8, $7) + $12 | 0;
   $18 = $7 + sqlite3Fts3VarintLen($12, 0) | 0;
   $9 = $4;
   $5 = HEAP32[$4 + 80 >> 2];
   label$5: {
    label$6: {
     if (!(HEAP32[$0 + 232 >> 2] < ($18 + $5 | 0) ? $17 : 0)) {
      $4 = $4 + 76 | 0;
      label$9: {
       if ($5) {
        break label$9;
       }
       blobGrowBuffer($4, HEAP32[$0 + 232 >> 2], $11 + 12 | 0);
       if (HEAP32[$11 + 12 >> 2]) {
        $5 = HEAP32[$9 + 80 >> 2];
        break label$9;
       }
       HEAP8[HEAP32[$4 >> 2]] = $14;
       $7 = $10;
       $5 = sqlite3Fts3PutVarint(HEAP32[$4 >> 2] + 1 | 0, $13, $7) + 1 | 0;
       HEAP32[$9 + 80 >> 2] = $5;
      }
      blobGrowBuffer($4, $5 + $18 | 0, $11 + 12 | 0);
      blobGrowBuffer($15, $3, $11 + 12 | 0);
      $13 = 0;
      $10 = 0;
      $5 = HEAP32[$11 + 12 >> 2];
      if ($5) {
       break label$5;
      }
      label$11: {
       if (!HEAP32[$16 + 68 >> 2]) {
        $5 = HEAP32[$9 + 80 >> 2];
        break label$11;
       }
       $7 = $6;
       $5 = sqlite3Fts3PutVarint(HEAP32[$4 >> 2] + HEAP32[$9 + 80 >> 2] | 0, $8, $7) + HEAP32[$9 + 80 >> 2] | 0;
       HEAP32[$9 + 80 >> 2] = $5;
      }
      $5 = sqlite3Fts3PutVarint(HEAP32[$4 >> 2] + $5 | 0, $12, 0) + HEAP32[$9 + 80 >> 2] | 0;
      HEAP32[$9 + 80 >> 2] = $5;
      __memcpy(HEAP32[$4 >> 2] + $5 | 0, $2 + $8 | 0, $12);
      HEAP32[$9 + 80 >> 2] = HEAP32[$9 + 80 >> 2] + $12;
      __memcpy(HEAP32[$15 >> 2], $2, $3);
      $5 = 0;
      $4 = $3;
      break label$6;
     }
     $8 = $4;
     $12 = $4 + 56 | 0;
     $6 = $12;
     $7 = HEAP32[$6 >> 2];
     $4 = $4 + 76 | 0;
     $5 = fts3WriteSegment($0, $7, HEAP32[$6 + 4 >> 2], HEAP32[$4 >> 2], $5);
     HEAP8[HEAP32[$8 + 76 >> 2]] = $14;
     $6 = $13;
     $4 = $6 + 1 | 0;
     $10 = $4 ? $10 : $10 + 1 | 0;
     HEAP32[$9 + 80 >> 2] = sqlite3Fts3PutVarint(HEAP32[$8 + 76 >> 2] + 1 | 0, $4, $10) + 1;
     $10 = HEAP32[$8 + 56 >> 2];
     $13 = $10;
     $6 = HEAP32[$8 + 60 >> 2];
     $10 = $6;
     $7 = $13 + 1 | 0;
     $4 = $7 ? $6 : $6 + 1 | 0;
     HEAP32[$8 + 56 >> 2] = $7;
     HEAP32[$8 + 60 >> 2] = $4;
     $4 = 0;
    }
    HEAP32[$16 + 68 >> 2] = $4;
   }
   if ($5) {
    break label$2;
   }
   $14 = $14 + 1 | 0;
   $6 = $13;
   $4 = $10;
   if ($6 | $4) {
    continue;
   }
  }
  break;
 }
 __stack_pointer = $11 + 16 | 0;
 return $5;
}

function substExpr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $3 = HEAP32[$1 + 4 >> 2];
  if (!(!($3 & 3) | HEAP32[$1 + 36 >> 2] != HEAP32[$0 + 4 >> 2])) {
   HEAP32[$1 + 36 >> 2] = HEAP32[$0 + 8 >> 2];
  }
  $2 = HEAPU8[$1 | 0];
  label$4: {
   label$5: {
    if (($2 | 0) != 179) {
     if ($3 & 32 | HEAP32[$1 + 28 >> 2] != HEAP32[$0 + 4 >> 2] | ($2 | 0) != 167) {
      break label$5;
     }
     $3 = HEAP32[$0 >> 2];
     $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + (HEAP16[$1 + 32 >> 1] << 4) | 0) + 8 >> 2];
     if (sqlite3ExprIsVector($2)) {
      sqlite3VectorErrorMsg($3, $2);
      break label$4;
     }
     $3 = HEAP32[$3 >> 2];
     if (!(!HEAP32[$0 + 12 >> 2] | HEAPU8[$2 | 0] == 167)) {
      memset($4 + 8 | 0, 0, 52);
      HEAP32[$4 + 20 >> 2] = $2;
      HEAP8[$4 + 8 | 0] = 179;
      $2 = HEAP32[$0 + 8 >> 2];
      HEAP32[$4 + 12 >> 2] = 262144;
      HEAP32[$4 + 36 >> 2] = $2;
      $2 = $4 + 8 | 0;
     }
     $2 = sqlite3ExprDup($3, $2, 0);
     if (!HEAPU8[$3 + 87 | 0]) {
      if (HEAP32[$0 + 12 >> 2]) {
       HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 2097152;
      }
      $5 = HEAP32[$1 + 4 >> 2] & 3;
      if ($5) {
       sqlite3SetJoinExpr($2, HEAP32[$1 + 36 >> 2], $5);
      }
      sqlite3ExprDelete($3, $1);
      label$12: {
       label$13: {
        label$14: {
         label$15: {
          $1 = HEAPU8[$2 | 0];
          switch ($1 - 167 | 0) {
          case 0:
           break label$12;

          case 1:
          case 2:
           break label$13;

          case 3:
           break label$14;

          default:
           break label$15;
          }
         }
         if (($1 | 0) != 113) {
          break label$13;
         }
         break label$12;
        }
        $1 = sqlite3ExprTruthValue($2);
        HEAP8[$2 | 0] = 155;
        HEAP32[$2 + 8 >> 2] = $1;
        HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 2048;
       }
       $1 = sqlite3ExprCollSeq(HEAP32[$0 >> 2], $2);
       $0 = HEAP32[$0 >> 2];
       $1 = $1 ? HEAP32[$1 >> 2] : 32384;
       $2 = sqlite3ExprAddCollateString($0, $2, $1);
      }
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] & -513;
      break label$1;
     }
     sqlite3ExprDelete($3, $2);
     break label$4;
    }
    if (HEAP32[$1 + 28 >> 2] != HEAP32[$0 + 4 >> 2]) {
     break label$5;
    }
    HEAP32[$1 + 28 >> 2] = HEAP32[$0 + 8 >> 2];
   }
   HEAP32[$1 + 12 >> 2] = substExpr($0, HEAP32[$1 + 12 >> 2]);
   HEAP32[$1 + 16 >> 2] = substExpr($0, HEAP32[$1 + 16 >> 2]);
   $2 = HEAP32[$1 + 20 >> 2];
   label$18: {
    if (HEAPU8[$1 + 5 | 0] & 16) {
     substSelect($0, $2, 1);
     break label$18;
    }
    substExprList($0, $2);
   }
   if (!(HEAP8[$1 + 7 | 0] & 1)) {
    break label$4;
   }
   $2 = HEAP32[$1 + 44 >> 2];
   HEAP32[$2 + 40 >> 2] = substExpr($0, HEAP32[$2 + 40 >> 2]);
   substExprList($0, HEAP32[$2 + 8 >> 2]);
   substExprList($0, HEAP32[$2 + 12 >> 2]);
  }
  $2 = $1;
 }
 __stack_pointer = $4 - -64 | 0;
 return $2;
}

function renameEditSql($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
 $11 = __stack_pointer - 32 | 0;
 __stack_pointer = $11;
 $18 = sqlite3Strlen30($3);
 $10 = sqlite3Strlen30($2);
 $12 = $10;
 $15 = sqlite3_context_db_handle($0);
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      if ($3) {
       HEAP32[$11 + 16 >> 2] = $3;
       $16 = sqlite3MPrintf($15, 29585, $11 + 16 | 0);
       if ($16) {
        break label$5;
       }
       $6 = 7;
       break label$1;
      }
      $5 = $12;
      $8 = $5 << 1;
      $12 = $8 | 1;
      $5 = $5 >>> 31 | 0;
      $7 = $5;
      $8 = __wasm_i64_mul($12, $5, 3, 0);
      $5 = i64toi32_i32$HIGH_BITS;
      $6 = sqlite3DbMallocZero($15, $8, $5);
      if ($6) {
       break label$4;
      }
      $0 = 7;
      break label$2;
     }
     $5 = HEAP32[$1 + 4 >> 2];
     $8 = $5 >> 31;
     $6 = $5;
     $7 = $8;
     $17 = sqlite3Strlen30($16) - 1 | 0;
     $5 = $17;
     $8 = $5 >> 31;
     $5 = $8;
     $8 = $7;
     $5 = __wasm_i64_mul($6, $8, $17, $5);
     $6 = $5;
     $8 = i64toi32_i32$HIGH_BITS;
     $5 = $8;
     $7 = $12 + $6 | 0;
     $8 = $7;
     $7 = $8 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
     $5 = $8 + 1 | 0;
     $7 = $5 ? $7 : $7 + 1 | 0;
     $6 = sqlite3DbMallocZero($15, $5, $7);
     if ($6) {
      break label$3;
     }
     $0 = 7;
     break label$2;
    }
    $19 = (($10 << 2) + $6 | 0) + 2 | 0;
    $13 = $6 + $12 | 0;
   }
   $8 = $13;
   $14 = __memcpy($6, $2, $10);
   $12 = $10 << 1;
   while (1) {
    if (HEAP32[$1 >> 2]) {
     $6 = renameColumnTokenNext($1);
     $9 = HEAP32[$6 + 4 >> 2];
     label$9: {
      if ($3) {
       label$11: {
        if ($4) {
         break label$11;
        }
        if (!sqlite3IsIdChar(HEAPU8[$9 | 0])) {
         break label$11;
        }
        $7 = $18;
        $5 = $3;
        break label$9;
       }
       $7 = (HEAPU8[HEAP32[$6 + 8 >> 2] + $9 | 0] == 34) + $17 | 0;
       $5 = $16;
       break label$9;
      }
      $7 = $6 + 8 | 0;
      $9 = __memcpy($8, $9, HEAP32[$7 >> 2]);
      HEAP8[$9 + HEAP32[$6 + 8 >> 2] | 0] = 0;
      sqlite3Dequote($9);
      $7 = HEAPU8[HEAP32[$6 + 4 >> 2] + HEAP32[$6 + 8 >> 2] | 0];
      HEAP32[$11 >> 2] = $9;
      HEAP32[$11 + 4 >> 2] = ($7 | 0) == 39 ? 29598 : 29623;
      $5 = sqlite3_snprintf($12, $19, 5829, $11);
      $7 = sqlite3Strlen30($5);
      $9 = HEAP32[$6 + 4 >> 2];
     }
     $9 = $9 - $2 | 0;
     $13 = HEAP32[$6 + 8 >> 2];
     if (($13 | 0) != ($7 | 0)) {
      $13 = $9 + $13 | 0;
      memmove(($9 + $7 | 0) + $14 | 0, $13 + $14 | 0, $10 - $13 | 0);
      $10 = ($7 - HEAP32[$6 + 8 >> 2] | 0) + $10 | 0;
      HEAP8[$14 + $10 | 0] = 0;
     }
     __memcpy($9 + $14 | 0, $5, $7);
     sqlite3DbFree($15, $6);
     continue;
    }
    break;
   }
   sqlite3_result_text($0, $14, -1, -1);
   sqlite3DbFree($15, $14);
   $0 = 0;
  }
  $6 = $0;
  sqlite3_free($16);
 }
 __stack_pointer = $11 + 32 | 0;
 return $6;
}

function sqlite3Atoi64($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 label$1: {
  if (($3 | 0) == 1) {
   $5 = 1;
   $6 = $0;
   break label$1;
  }
  $7 = 3 - $3 | 0;
  $6 = $2 & -2;
  while (1) {
   if (!(HEAPU8[$0 + $7 | 0] | ($6 | 0) <= ($7 | 0))) {
    $7 = $7 + 2 | 0;
    continue;
   }
   break;
  }
  $2 = $7 ^ 1;
  $12 = ($6 | 0) > ($7 | 0);
  $5 = 2;
  $6 = ($3 & 1) + $0 | 0;
 }
 $3 = $5;
 $0 = $0 + $2 | 0;
 label$5: {
  while (1) {
   $11 = 1;
   if ($0 >>> 0 <= $6 >>> 0) {
    break label$5;
   }
   $7 = HEAPU8[$6 | 0];
   if (HEAP8[$7 + 30288 | 0] & 1) {
    $6 = $3 + $6 | 0;
    continue;
   }
   break;
  }
  label$8: {
   switch ($7 - 43 | 0) {
   case 2:
    $6 = $3 + $6 | 0;
    $11 = 0;
    break label$5;

   case 0:
    break label$8;

   default:
    break label$5;
   }
  }
  $6 = $3 + $6 | 0;
 }
 $7 = $6;
 while (1) {
  if (HEAPU8[$7 | 0] == 48 & $0 >>> 0 > $7 >>> 0) {
   $7 = $3 + $7 | 0;
   continue;
  } else {
   $2 = 0;
   while (1) {
    label$14: {
     $4 = $2 + $7 | 0;
     $14 = $4 >>> 0 >= $0 >>> 0;
     if ($14) {
      break label$14;
     }
     $4 = HEAPU8[$4 | 0];
     if (($4 - 48 & 255) >>> 0 > 9) {
      break label$14;
     }
     $2 = $2 + $3 | 0;
     $9 = $13;
     $10 = __wasm_i64_mul($10, $9, 10, 0);
     $9 = i64toi32_i32$HIGH_BITS;
     $5 = $9;
     $9 = $10;
     $8 = $4 & 255;
     $4 = $9 + $8 | 0;
     $10 = $5;
     $5 = $10;
     $5 = $4 >>> 0 < $8 >>> 0 ? $5 + 1 | 0 : $5;
     $10 = $4 - 48 | 0;
     $4 = $4 >>> 0 < 48;
     $4 = $5 - $4 | 0;
     $13 = $4;
     continue;
    }
    break;
   }
   $9 = $11;
   $8 = $9 ? -1 : 0;
   $15 = $8;
   $5 = $9 ? 2147483647 : -2147483648;
   $16 = $5;
   $4 = $10;
   $10 = 0 - $4 | 0;
   $8 = $13;
   $9 = 0 - ($8 + (($4 | 0) != 0) | 0) | 0;
   $5 = $11 ? $8 : $9;
   $17 = $5;
   $8 = $11;
   $4 = $8 ? $4 : $10;
   $5 = $13;
   $9 = ($5 | 0) < 0;
   $4 = $9 ? $15 : $4;
   $5 = $4;
   $4 = $1;
   HEAP32[$4 >> 2] = $5;
   $8 = $16;
   $5 = $17;
   HEAP32[$4 + 4 >> 2] = $9 ? $8 : $5;
   label$15: {
    if (!$2) {
     $4 = -1;
     if (($6 | 0) == ($7 | 0)) {
      break label$15;
     }
    }
    $4 = $12;
    if ($12) {
     break label$15;
    }
    $4 = $12;
    if ($14) {
     break label$15;
    }
    $6 = $2;
    while (1) {
     $4 = 1;
     if (!(HEAP8[HEAPU8[$6 + $7 | 0] + 30288 | 0] & 1)) {
      break label$15;
     }
     $6 = $3 + $6 | 0;
     if ($7 + $6 >>> 0 < $0 >>> 0) {
      continue;
     }
     break;
    }
    $4 = 0;
   }
   $6 = Math_imul($3, 19);
   label$18: {
    if ($6 >>> 0 > $2 >>> 0) {
     break label$18;
    }
    $0 = 1;
    if ($2 >>> 0 <= $6 >>> 0) {
     $0 = compare2pow63($7, $3);
     if (($0 | 0) < 0) {
      break label$18;
     }
    }
    $5 = $11;
    $8 = $5 ? -1 : 0;
    $2 = $8;
    $8 = $1;
    HEAP32[$8 >> 2] = $2;
    $9 = $5 ? 2147483647 : -2147483648;
    HEAP32[$8 + 4 >> 2] = $9;
    $4 = $0 ? 2 : $5 ? 3 : $4;
   }
  }
  break;
 }
 return $4;
}

function sqlite3ConstructBloomFilter($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $8 = HEAP32[$2 + 80 >> 2];
 $9 = HEAP32[$0 >> 2];
 $10 = HEAP32[$9 + 8 >> 2];
 $16 = sqlite3VdbeAddOp0($10, 14);
 while (1) {
  sqlite3WhereExplainBloomFilter($9, $0, $2);
  $15 = sqlite3VdbeMakeLabel($9);
  $13 = HEAP32[$2 + 4 >> 2];
  $5 = HEAP32[$9 + 44 >> 2] + 1 | 0;
  HEAP32[$9 + 44 >> 2] = $5;
  HEAP32[$2 + 52 >> 2] = $5;
  $11 = HEAP32[$0 + 4 >> 2] + (HEAPU8[$2 + 60 | 0] << 6) | 0;
  $6 = sqlite3LogEstToInt(HEAP16[HEAP32[$11 + 24 >> 2] + 38 >> 1]);
  $7 = i64toi32_i32$HIGH_BITS;
  $12 = !$7 & $6 >>> 0 < 1e7;
  $14 = $12 ? $7 : 0;
  $6 = $12 ? $6 : 1e7;
  $7 = !$14 & $6 >>> 0 > 1e4 | ($14 | 0) != 0;
  $12 = $14;
  $6 = $7 ? $6 : 1e4;
  sqlite3VdbeAddOp2($10, 77, $6, $5);
  $7 = $11 + 8 | 0;
  $6 = sqlite3VdbeAddOp1($10, 35, $13);
  $5 = HEAP32[$0 + 112 >> 2];
  $11 = $5 + Math_imul(HEAP32[$0 + 100 >> 2], 48) | 0;
  while (1) {
   if ($5 >>> 0 < $11 >>> 0) {
    label$4: {
     if (HEAPU8[$5 + 10 | 0] & 2) {
      break label$4;
     }
     if (!sqlite3ExprIsTableConstraint(HEAP32[$5 >> 2], $7)) {
      break label$4;
     }
     sqlite3ExprIfFalse($9, HEAP32[$5 >> 2], $15, 16);
    }
    $5 = $5 + 48 | 0;
    continue;
   }
   break;
  }
  label$5: {
   if (HEAP8[$8 + 41 | 0] & 1) {
    $5 = sqlite3GetTempReg($9);
    sqlite3VdbeAddOp2($10, 135, $13, $5);
    sqlite3VdbeAddOp4Int($10, 180, HEAP32[$2 + 52 >> 2], 0, $5, 1);
    sqlite3ReleaseTempReg($9, $5);
    break label$5;
   }
   $11 = HEAP32[$8 + 32 >> 2];
   $5 = 0;
   $7 = HEAPU16[$8 + 24 >> 1];
   $12 = sqlite3GetTempRange($9, $7);
   while (1) {
    if (($5 | 0) != ($7 | 0)) {
     sqlite3ExprCodeGetColumnOfTable($10, HEAP32[$11 + 12 >> 2], $13, HEAP16[HEAP32[$11 + 4 >> 2] + ($5 << 1) >> 1], $5 + $12 | 0);
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   sqlite3VdbeAddOp4Int($10, 180, HEAP32[$2 + 52 >> 2], 0, $12, $7);
   sqlite3ReleaseTempRange($9, $12, $7);
  }
  sqlite3VdbeResolveLabel($10, $15);
  sqlite3VdbeAddOp2($10, 38, HEAP32[$2 + 4 >> 2], $6 + 1 | 0);
  sqlite3VdbeJumpHere($10, $6);
  HEAP32[$8 + 40 >> 2] = HEAP32[$8 + 40 >> 2] & -4194305;
  label$9: {
   if (HEAPU8[HEAP32[$9 >> 2] + 82 | 0] & 16) {
    break label$9;
   }
   $11 = HEAPU8[$0 + 48 | 0];
   while (1) {
    $1 = $1 + 1 | 0;
    if (($11 | 0) <= ($1 | 0)) {
     break label$9;
    }
    $5 = Math_imul($1, 96) + $0 | 0;
    if (HEAPU8[(HEAP32[$0 + 4 >> 2] + (HEAPU8[$5 + 828 | 0] << 6) | 0) + 44 | 0] & 72) {
     continue;
    }
    $8 = HEAP32[$5 + 848 >> 2];
    if (!$8) {
     continue;
    }
    $2 = HEAP32[$8 >> 2];
    $7 = $2;
    $6 = HEAP32[$8 + 4 >> 2];
    $2 = $4;
    $2 = $6 & $2;
    $12 = $3;
    $6 = $7 & $12;
    if ($2 | $6 | (HEAP32[$8 + 40 >> 2] & 4194308) != 4194304) {
     continue;
    }
    break;
   }
   $2 = $5 + 768 | 0;
   if (($1 | 0) < ($11 | 0)) {
    continue;
   }
  }
  break;
 }
 sqlite3VdbeJumpHere($10, $16);
}

function sqlite3AlterFinishAddColumn($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $4 = HEAP32[$0 >> 2];
  $2 = HEAP32[$4 + 16 >> 2];
  $5 = HEAP32[$0 + 236 >> 2];
  $9 = sqlite3SchemaToIndex($4, HEAP32[$5 + 60 >> 2]);
  $7 = HEAP32[$2 + ($9 << 4) >> 2];
  $10 = HEAP32[$5 + 4 >> 2];
  $11 = HEAP16[$5 + 34 >> 1] - 1 | 0;
  $12 = $10 + Math_imul($11, 12) | 0;
  $2 = sqlite3ColumnExpr($5, $12);
  $8 = HEAP32[$5 >> 2] + 16 | 0;
  if (sqlite3AuthCheck($0, 26, $7, HEAP32[sqlite3FindTable($4, $8, $7) >> 2], 0)) {
   break label$1;
  }
  $6 = HEAPU16[$12 + 10 >> 1];
  if ($6 & 1) {
   sqlite3ErrorMsg($0, 10612, 0);
   break label$1;
  }
  if (HEAP32[$5 + 8 >> 2]) {
   sqlite3ErrorMsg($0, 10644, 0);
   break label$1;
  }
  label$4: {
   if (!($6 & 96)) {
    $2 = $2 ? HEAPU8[HEAP32[$2 + 12 >> 2]] == 121 ? 0 : $2 : 0;
    if (!(!(HEAPU8[$4 + 33 | 0] & 64) | (!HEAP32[$5 + 48 >> 2] | !$2))) {
     sqlite3ErrorIfNotEmpty($0, $7, $8, 12356);
    }
    if (!(!(HEAPU8[(Math_imul($11, 12) + $10 | 0) + 4 | 0] & 15) | $2)) {
     sqlite3ErrorIfNotEmpty($0, $7, $8, 19515);
    }
    if (!$2) {
     break label$4;
    }
    HEAP32[$3 + 44 >> 2] = 0;
    if (sqlite3ValueFromExpr($4, $2, 1, 65, $3 + 44 | 0)) {
     break label$1;
    }
    $2 = HEAP32[$3 + 44 >> 2];
    if (!$2) {
     sqlite3ErrorIfNotEmpty($0, $7, $8, 2813);
    }
    sqlite3ValueFree($2);
    break label$4;
   }
   if (!($6 & 64)) {
    break label$4;
   }
   sqlite3ErrorIfNotEmpty($0, $7, $8, 10671);
  }
  $6 = sqlite3DbStrNDup($4, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], 0);
  if ($6) {
   $1 = (HEAP32[$1 + 4 >> 2] + $6 | 0) - 1 | 0;
   while (1) {
    label$13: {
     if ($1 >>> 0 <= $6 >>> 0) {
      break label$13;
     }
     $2 = HEAPU8[$1 | 0];
     if (HEAP8[$2 + 30288 | 0] & 1 ? 0 : ($2 | 0) != 59) {
      break label$13;
     }
     HEAP8[$1 | 0] = 0;
     $1 = $1 - 1 | 0;
     continue;
    }
    break;
   }
   $1 = HEAP32[$5 + 44 >> 2];
   HEAP32[$3 + 32 >> 2] = $8;
   HEAP32[$3 + 28 >> 2] = $1;
   HEAP32[$3 + 24 >> 2] = $6;
   HEAP32[$3 + 20 >> 2] = $1;
   HEAP32[$3 + 16 >> 2] = $7;
   sqlite3NestedParse($0, 19208, $3 + 16 | 0);
   sqlite3DbFree($4, $6);
  }
  $1 = sqlite3GetVdbe($0);
  if (!$1) {
   break label$1;
  }
  $4 = sqlite3GetTempReg($0);
  sqlite3VdbeAddOp3($1, 99, $9, $4, 2);
  sqlite3VdbeUsesBtree($1, $9);
  sqlite3VdbeAddOp2($1, 86, $4, -2);
  sqlite3VdbeAddOp2($1, 49, $4, sqlite3VdbeCurrentAddr($1) + 2 | 0);
  sqlite3VdbeAddOp3($1, 100, $9, 2, 3);
  sqlite3ReleaseTempReg($0, $4);
  renameReloadSchema($0, $9, 3);
  if (!HEAP32[$5 + 16 >> 2] & (!(HEAPU8[(Math_imul($11, 12) + $10 | 0) + 4 | 0] & 15) | !(HEAPU8[$12 + 10 | 0] & 96))) {
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = $7;
  HEAP32[$3 >> 2] = $8;
  sqlite3NestedParse($0, 27761, $3);
 }
 __stack_pointer = $3 + 48 | 0;
}

function fts3EvalDeferredPhrase($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $7 = HEAP32[$1 + 24 >> 2] ? HEAP32[$1 + 28 >> 2] : $7;
 $6 = -1;
 while (1) {
  label$3: {
   label$4: {
    label$5: {
     if (HEAP32[$1 + 64 >> 2] > ($3 | 0)) {
      $4 = HEAP32[(Math_imul($3, 24) + $1 | 0) + 88 >> 2];
      if (!$4) {
       break label$3;
      }
      $8 = sqlite3Fts3DeferredTokenList($4, $2 + 28 | 0, $2 + 24 | 0);
      if ($8) {
       break label$5;
      }
      $4 = HEAP32[$2 + 28 >> 2];
      if (!$4) {
       sqlite3_free($5);
       sqlite3_free($7);
       HEAP32[$1 + 28 >> 2] = 0;
       HEAP32[$1 + 32 >> 2] = 0;
       break label$5;
      }
      if (!$5) {
       $9 = HEAP32[$2 + 24 >> 2];
       break label$4;
      }
      HEAP32[$2 + 20 >> 2] = $4;
      HEAP32[$2 + 16 >> 2] = $5;
      HEAP32[$2 + 12 >> 2] = $4;
      fts3PoslistPhraseMerge($2 + 20 | 0, $3 - $6 | 0, 0, 1, $2 + 16 | 0, $2 + 12 | 0);
      sqlite3_free($5);
      $9 = HEAP32[$2 + 20 >> 2] - $4 | 0;
      if ($9) {
       break label$4;
      }
      sqlite3_free($4);
      sqlite3_free($7);
      HEAP32[$1 + 28 >> 2] = 0;
      HEAP32[$1 + 32 >> 2] = 0;
      break label$5;
     }
     $8 = 0;
     label$9: {
      label$10: {
       if (($6 | 0) < 0) {
        break label$10;
       }
       $3 = HEAP32[$1 + 44 >> 2];
       if (($3 | 0) < 0) {
        HEAP32[$1 + 32 >> 2] = $9;
        HEAP32[$1 + 28 >> 2] = $5;
        $3 = HEAP32[$0 + 36 >> 2];
        $0 = HEAP32[$0 + 32 >> 2];
        HEAP32[$1 + 24 >> 2] = 1;
        HEAP32[$1 + 16 >> 2] = $0;
        HEAP32[$1 + 20 >> 2] = $3;
        break label$10;
       }
       label$12: {
        if ($3 >>> 0 > $6 >>> 0) {
         HEAP32[$2 + 28 >> 2] = $5;
         HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
         $4 = $3 - $6 | 0;
         break label$12;
        }
        $4 = HEAP32[$1 + 28 >> 2];
        HEAP32[$2 + 24 >> 2] = $5;
        HEAP32[$2 + 28 >> 2] = $4;
        $4 = $6 - $3 | 0;
       }
       $0 = $9 + 8 | 0;
       $3 = $0 >> 31;
       $3 = sqlite3Fts3MallocZero($0, $3);
       HEAP32[$2 + 20 >> 2] = $3;
       if (!$3) {
        break label$9;
       }
       HEAP32[$1 + 28 >> 2] = $3;
       $3 = 0;
       label$14: {
        if (fts3PoslistPhraseMerge($2 + 20 | 0, $4, 0, 1, $2 + 28 | 0, $2 + 24 | 0)) {
         HEAP32[$1 + 24 >> 2] = 1;
         $3 = HEAP32[$2 + 20 >> 2] - HEAP32[$1 + 28 >> 2] | 0;
         break label$14;
        }
        sqlite3_free(HEAP32[$2 + 20 >> 2]);
        HEAP32[$1 + 28 >> 2] = 0;
       }
       HEAP32[$1 + 32 >> 2] = $3;
       sqlite3_free($5);
      }
      if (HEAP32[$1 + 28 >> 2] == ($7 | 0)) {
       break label$5;
      }
      sqlite3_free($7);
      break label$5;
     }
     sqlite3_free($5);
     $8 = 7;
    }
    __stack_pointer = $2 + 32 | 0;
    return $8;
   }
   $6 = $3;
   $5 = $4;
  }
  $3 = $3 + 1 | 0;
  continue;
 }
}

function fts3ExprParse($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 12 >> 2] = 0;
 $5 = 1;
 $10 = $2;
 while (1) {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         if (!$9) {
          HEAP32[$8 + 8 >> 2] = 0;
          HEAP32[$8 + 4 >> 2] = 0;
          $9 = getNextNode($0, $1, $10, $8 + 8 | 0, $8 + 4 | 0);
          if ($9) {
           break label$3;
          }
          $7 = HEAP32[$8 + 8 >> 2];
          if (!$7) {
           break label$3;
          }
          $13 = HEAP32[$7 >> 2];
          $14 = ($13 | 0) != 5;
          if (!$14) {
           $11 = 0;
           $15 = ($5 | 0) != 0;
           $9 = 1;
           break label$8;
          }
          $15 = ($5 | 0) != 0;
          $12 = HEAP32[$7 + 12 >> 2];
          $9 = ($12 | 0) != 0;
          $11 = !$12;
          if (!$5 | $12) {
           break label$8;
          }
          break label$7;
         }
         $7 = HEAP32[$8 + 12 >> 2];
         HEAP32[$4 >> 2] = $2 - $10;
         $5 = ($9 | 0) == 101 ? $7 ? $5 ? 1 : $9 : $9 : $9;
         $6 = 0;
         if (($5 | 0) == 101) {
          break label$4;
         }
         break label$5;
        }
        label$11: {
         label$12: {
          label$13: {
           if (!($11 | $15)) {
            $5 = sqlite3Fts3MallocZero(48, 0);
            if ($5) {
             break label$13;
            }
            $5 = 7;
            break label$6;
           }
           if ($6) {
            break label$12;
           }
           $6 = 0;
           break label$11;
          }
          HEAP32[$5 >> 2] = 3;
          insertBinaryOperator($8 + 12 | 0, $6, $5);
          $6 = $5;
         }
         if (!(($13 | 0) != 1 | $9) & HEAP32[$6 >> 2] != 5) {
          break label$7;
         }
         if (!($9 & $14)) {
          break label$11;
         }
         $5 = 1;
         if (HEAP32[$6 >> 2] == 1) {
          break label$6;
         }
        }
        label$16: {
         label$17: {
          if ($9) {
           if (!HEAP32[$8 + 12 >> 2]) {
            break label$17;
           }
           HEAP32[$6 + 16 >> 2] = $7;
           HEAP32[$7 + 8 >> 2] = $6;
           break label$16;
          }
          insertBinaryOperator($8 + 12 | 0, $6, $7);
          break label$16;
         }
         HEAP32[$8 + 12 >> 2] = $7;
        }
        $9 = 0;
        break label$2;
       }
       $5 = 1;
      }
      sqlite3Fts3ExprFree($7);
      $7 = HEAP32[$8 + 12 >> 2];
     }
     sqlite3Fts3ExprFree($7);
     $7 = 0;
     sqlite3Fts3ExprFree(0);
     $6 = $5;
    }
    HEAP32[$3 >> 2] = $7;
    __stack_pointer = $8 + 16 | 0;
    return $6;
   }
   $11 = $5;
   $7 = $6;
  }
  $6 = HEAP32[$8 + 4 >> 2];
  $1 = $6 + $1 | 0;
  $10 = $10 - $6 | 0;
  $5 = $11;
  $6 = $7;
  continue;
 }
}

function atan2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $2 = __DOUBLE_BITS_2($1);
 $4 = $2;
 $3 = i64toi32_i32$HIGH_BITS;
 $2 = $3 & 2147483647;
 $3 = $4;
 label$1: {
  if (!$3 & ($2 | 0) == 2146435072 | $2 >>> 0 < 2146435072) {
   $3 = __DOUBLE_BITS_2($0);
   $5 = $3;
   $2 = i64toi32_i32$HIGH_BITS;
   $3 = $2 & 2147483647;
   $2 = $5;
   if (!$2 & ($3 | 0) == 2146435072 | $3 >>> 0 < 2146435072) {
    break label$1;
   }
  }
  return $0 + $1;
 }
 wasm2js_scratch_store_f64(+$1);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $4 = $5;
 $6 = $2;
 $10 = $4;
 if (!($4 | $2 - 1072693248)) {
  return atan($0);
 }
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $9 = $6 >>> 30 & 2;
 $7 = $9 | $3 >>> 31;
 $4 = $3;
 $3 = $5;
 $2 = $4;
 $4 = $2 & 2147483647;
 label$4: {
  if (!($3 | $4)) {
   label$6: {
    switch ($7 - 2 | 0) {
    case 0:
     return 3.141592653589793;

    case 1:
     break label$6;

    default:
     break label$4;
    }
   }
   return -3.141592653589793;
  }
  $6 = $6 & 2147483647;
  if (!($10 | $6)) {
   wasm2js_scratch_store_f64(1.5707963267948966);
   $2 = wasm2js_scratch_load_i32(1) | 0;
   $4 = wasm2js_scratch_load_i32(0) | 0;
   $5 = $4;
   $3 = $2 & 2147483647;
   $6 = $3;
   wasm2js_scratch_store_f64(+$0);
   $3 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $4 = $3 & -2147483648;
   $3 = $5;
   $5 = $11;
   wasm2js_scratch_store_i32(0, $3 | $5);
   $2 = $4;
   $4 = $6;
   $2 = $2 | $4;
   wasm2js_scratch_store_i32(1, $2 | 0);
   return +wasm2js_scratch_load_f64();
  }
  label$9: {
   if (($6 | 0) == 2146435072) {
    if (($4 | 0) != 2146435072) {
     break label$9;
    }
    return HEAPF64[($7 << 3) + 58688 >> 3];
   }
   if (!(($4 | 0) != 2146435072 & $6 + 67108864 >>> 0 >= $4 >>> 0)) {
    wasm2js_scratch_store_f64(1.5707963267948966);
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $4 = wasm2js_scratch_load_i32(0) | 0;
    $5 = $4;
    $3 = $2 & 2147483647;
    $6 = $3;
    wasm2js_scratch_store_f64(+$0);
    $3 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    $4 = $3 & -2147483648;
    $3 = $5;
    $5 = $11;
    wasm2js_scratch_store_i32(0, $3 | $5);
    $2 = $4;
    $4 = $6;
    $2 = $2 | $4;
    wasm2js_scratch_store_i32(1, $2 | 0);
    return +wasm2js_scratch_load_f64();
   }
   label$12: {
    if ($9) {
     $8 = 0;
     if ($4 + 67108864 >>> 0 < $6 >>> 0) {
      break label$12;
     }
    }
    $8 = atan(fabs($0 / $1));
   }
   $0 = $8;
   label$14: {
    switch ($7 | 0) {
    case 1:
     return -$0;

    case 2:
     return 3.141592653589793 - ($0 + -12246467991473532e-32);

    case 0:
     break label$4;

    default:
     break label$14;
    }
   }
   return $0 + -12246467991473532e-32 + -3.141592653589793;
  }
  $0 = HEAPF64[($7 << 3) + 58720 >> 3];
 }
 return $0;
}

function setupLookaside($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = 5;
 if ((sqlite3LookasideUsed($0, 0) | 0) <= 0) {
  if (HEAPU8[$0 + 312 | 0]) {
   sqlite3_free(HEAP32[$0 + 352 >> 2]);
  }
  $9 = $2 & -8;
  $4 = ($9 | 0) < 5;
  label$3: {
   if (!($4 | ($3 | 0) <= 0)) {
    $6 = $3;
    $5 = $6 >> 31;
    $6 = $5;
    $5 = $2 >> 31;
    $8 = $5;
    $5 = $6;
    $6 = $8;
    $6 = __wasm_i64_mul($3, $5, $2, $6);
    $8 = $6;
    $5 = i64toi32_i32$HIGH_BITS;
    $3 = $5;
    $2 = $4 ? 0 : $9;
    label$5: {
     if ($1) {
      $4 = $1;
      break label$5;
     }
     sqlite3BeginBenignMalloc();
     $5 = $3;
     $4 = sqlite3Malloc($8, $5);
     sqlite3EndBenignMalloc();
     if (!$4) {
      $4 = 0;
      break label$5;
     }
     $6 = sqlite3MallocSize($4);
     $5 = $6 >> 31;
     $8 = $6;
     $3 = $5;
    }
    if ($2 >>> 0 >= 384) {
     $5 = $3;
     $6 = __wasm_i64_sdiv($8, $5, $2 + 384 | 0, 0);
     $10 = $6;
     $6 = Math_imul($6, $2);
     $5 = $6 >> 31;
     $2 = $5;
     $11 = $6;
     $5 = $3;
     $6 = $2;
     $2 = $6 + ($8 >>> 0 < $11 >>> 0) | 0;
     $2 = $5 - $2 | 0;
     $7 = __wasm_i64_sdiv($8 - $11 | 0, $2, 128, 0);
     break label$3;
    }
    if ($2 >>> 0 >= 256) {
     $7 = __wasm_i64_sdiv($8, $3, $2 + 128 | 0, 0);
     $10 = $7;
     $7 = Math_imul($7, $2);
     $2 = $7 >> 31;
     $5 = $8;
     $11 = $7;
     $6 = $5 - $7 | 0;
     $7 = $2;
     $5 = __wasm_i64_sdiv($6, $3 - ($7 + ($5 >>> 0 < $11 >>> 0) | 0) | 0, 128, 0);
     $7 = $5;
     break label$3;
    }
    $5 = __wasm_i64_sdiv($8, $3, $2, 0);
    $10 = $5;
    $9 = $2;
    break label$3;
   }
   $4 = 0;
   $9 = 0;
  }
  HEAP32[$0 + 332 >> 2] = 0;
  HEAP32[$0 + 336 >> 2] = 0;
  HEAP32[$0 + 352 >> 2] = $4;
  HEAP16[$0 + 310 >> 1] = $9;
  HEAP16[$0 + 308 >> 1] = $9;
  label$10: {
   if ($4) {
    $3 = 0;
    $5 = ($10 | 0) > 0 ? $10 : 0;
    $2 = 0;
    while (1) {
     if (($2 | 0) != ($5 | 0)) {
      HEAP32[$4 >> 2] = $3;
      HEAP32[$0 + 332 >> 2] = $4;
      $2 = $2 + 1 | 0;
      $3 = $4;
      $4 = $4 + $9 | 0;
      continue;
     }
     break;
    }
    HEAP32[$0 + 348 >> 2] = $4;
    HEAP32[$0 + 340 >> 2] = 0;
    HEAP32[$0 + 344 >> 2] = 0;
    $3 = 0;
    $9 = ($7 | 0) > 0 ? $7 : 0;
    $2 = 0;
    while (1) {
     if (($2 | 0) != ($9 | 0)) {
      HEAP32[$4 >> 2] = $3;
      HEAP32[$0 + 340 >> 2] = $4;
      $2 = $2 + 1 | 0;
      $3 = $4;
      $4 = $4 + 128 | 0;
      continue;
     }
     break;
    }
    HEAP32[$0 + 304 >> 2] = 0;
    HEAP8[$0 + 312 | 0] = !$1;
    HEAP32[$0 + 356 >> 2] = $4;
    $4 = $10 + $7 | 0;
    break label$10;
   }
   HEAP8[$0 + 312 | 0] = 0;
   HEAP16[$0 + 308 >> 1] = 0;
   HEAP32[$0 + 304 >> 2] = 1;
   HEAP32[$0 + 356 >> 2] = $0;
   HEAP32[$0 + 348 >> 2] = $0;
   HEAP32[$0 + 340 >> 2] = 0;
   HEAP32[$0 + 344 >> 2] = 0;
   HEAP32[$0 + 352 >> 2] = $0;
   $4 = 0;
  }
  HEAP32[$0 + 316 >> 2] = $4;
  $4 = 0;
 }
 return $4;
}

function sqlite3AlterRenameTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $3 = __stack_pointer - 144 | 0;
 __stack_pointer = $3;
 $7 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$7 + 87 | 0]) {
   break label$1;
  }
  $6 = sqlite3LocateTableItem($0, 0, $1 + 8 | 0);
  if (!$6) {
   break label$1;
  }
  $5 = HEAP32[$7 + 16 >> 2];
  $8 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$6 + 60 >> 2]);
  $5 = HEAP32[$5 + ($8 << 4) >> 2];
  $2 = sqlite3NameFromToken($7, $2);
  if (!$2) {
   break label$1;
  }
  label$2: {
   label$3: {
    label$4: {
     if (sqlite3FindTable($7, $2, $5)) {
      break label$4;
     }
     if (sqlite3FindIndex($7, $2, $5)) {
      break label$4;
     }
     if (!sqlite3IsShadowTableOf($7, $6, $2)) {
      break label$3;
     }
    }
    HEAP32[$3 + 128 >> 2] = $2;
    sqlite3ErrorMsg($0, 7701, $3 + 128 | 0);
    break label$2;
   }
   if (isAlterableTable($0, $6)) {
    break label$2;
   }
   if (sqlite3CheckObjectName($0, $2, 13666, $2)) {
    break label$2;
   }
   $4 = HEAP32[$6 >> 2];
   if (HEAPU8[$6 + 43 | 0] == 2) {
    HEAP32[$3 >> 2] = $4;
    sqlite3ErrorMsg($0, 15085, $3);
    break label$2;
   }
   if (sqlite3AuthCheck($0, 26, $5, $4, 0)) {
    break label$2;
   }
   if (sqlite3ViewGetColumnNames($0, $6)) {
    break label$2;
   }
   if (HEAPU8[$6 + 43 | 0] == 1) {
    $4 = sqlite3GetVTable($7, $6);
    $11 = HEAP32[HEAP32[HEAP32[$4 + 8 >> 2] >> 2] + 76 >> 2] ? $4 : 0;
   }
   $9 = sqlite3GetVdbe($0);
   if (!$9) {
    break label$2;
   }
   sqlite3MayAbort($0);
   $4 = HEAP32[$6 >> 2];
   $12 = sqlite3Utf8CharLen($4, -1);
   HEAP32[$3 + 116 >> 2] = $4;
   $10 = ($8 | 0) == 1;
   HEAP32[$3 + 112 >> 2] = $10;
   HEAP32[$3 + 108 >> 2] = $2;
   HEAP32[$3 + 104 >> 2] = $4;
   HEAP32[$3 + 100 >> 2] = $5;
   HEAP32[$3 + 96 >> 2] = $5;
   sqlite3NestedParse($0, 27577, $3 + 96 | 0);
   HEAP32[$3 + 84 >> 2] = $4;
   HEAP32[$3 + 80 >> 2] = $12;
   HEAP32[$3 + 76 >> 2] = $2;
   HEAP32[$3 + 72 >> 2] = $2;
   HEAP32[$3 + 68 >> 2] = $2;
   HEAP32[$3 + 64 >> 2] = $5;
   sqlite3NestedParse($0, 21694, $3 - -64 | 0);
   if (sqlite3FindTable($7, 14088, $5)) {
    HEAP32[$3 + 56 >> 2] = HEAP32[$6 >> 2];
    HEAP32[$3 + 52 >> 2] = $2;
    HEAP32[$3 + 48 >> 2] = $5;
    sqlite3NestedParse($0, 19150, $3 + 48 | 0);
   }
   if (!$10) {
    HEAP32[$3 + 36 >> 2] = $2;
    HEAP32[$3 + 32 >> 2] = $5;
    HEAP32[$3 + 28 >> 2] = $4;
    HEAP32[$3 + 24 >> 2] = $2;
    HEAP32[$3 + 20 >> 2] = $4;
    HEAP32[$3 + 16 >> 2] = $5;
    sqlite3NestedParse($0, 26412, $3 + 16 | 0);
   }
   if ($11) {
    $4 = HEAP32[$0 + 44 >> 2] + 1 | 0;
    HEAP32[$0 + 44 >> 2] = $4;
    sqlite3VdbeLoadString($9, $4, $2);
    sqlite3VdbeAddOp4($9, 176, $4, 0, 0, $11, -11);
   }
   renameReloadSchema($0, $8, 1);
   renameTestSchema($0, $5, $10, 13250, 0);
  }
  $4 = $2;
 }
 sqlite3SrcListDelete($7, $1);
 sqlite3DbFree($7, $4);
 __stack_pointer = $3 + 144 | 0;
}

function fts3SegmentMerge($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 92 >> 2] = 0;
 HEAP32[$4 + 88 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 $5 = sqlite3Fts3SegReaderCursor($0, $1, $2, $3, 0, 0, 1, 0, $4 + 16 | 0);
 label$1: {
  if ($5) {
   break label$1;
  }
  $6 = HEAP32[$4 + 20 >> 2];
  if (!$6) {
   break label$1;
  }
  label$2: {
   label$3: {
    if (($3 | 0) == -1) {
     break label$3;
    }
    $5 = fts3SegmentMaxLevel($0, $1, $2, $4 + 8 | 0);
    if ($5) {
     break label$1;
    }
    if (($3 | 0) != -2) {
     break label$3;
    }
    if (!(HEAP32[HEAP32[HEAP32[$4 + 16 >> 2] >> 2] + 56 >> 2] | ($6 | 0) != 1)) {
     $5 = 101;
     break label$1;
    }
    HEAP32[$4 + 80 >> 2] = 0;
    HEAP32[$4 + 84 >> 2] = 0;
    HEAP32[$4 + 72 >> 2] = 0;
    HEAP32[$4 + 76 >> 2] = 0;
    $6 = HEAP32[$4 + 12 >> 2];
    $10 = HEAP32[$4 + 8 >> 2];
    $9 = $10;
    $8 = $6;
    $5 = 3;
    break label$2;
   }
   $5 = $3 + 1 | 0;
   $6 = getAbsoluteLevel($0, $1, $2, $5);
   $9 = $6;
   $8 = i64toi32_i32$HIGH_BITS;
   $5 = fts3AllocateSegdirIdx($0, $1, $2, $5, $4 + 92 | 0);
   if ($5) {
    break label$1;
   }
   HEAP32[$4 + 80 >> 2] = 0;
   HEAP32[$4 + 84 >> 2] = 0;
   HEAP32[$4 + 72 >> 2] = 0;
   HEAP32[$4 + 76 >> 2] = 0;
   $10 = HEAP32[$4 + 8 >> 2];
   $6 = HEAP32[$4 + 12 >> 2];
   $5 = ($3 | 0) == -1 ? 1 : $9 >>> 0 <= $10 >>> 0 & ($6 | 0) >= ($8 | 0) | ($6 | 0) > ($8 | 0) ? 1 : 3;
  }
  HEAP32[$4 + 84 >> 2] = $5;
  $5 = sqlite3Fts3SegReaderStart($0, $4 + 16 | 0, $4 + 72 | 0);
  while (1) {
   label$6: {
    label$7: {
     label$8: {
      if ($5) {
       break label$8;
      }
      $5 = sqlite3Fts3SegReaderStep($0, $4 + 16 | 0);
      if (($5 | 0) == 100) {
       break label$7;
      }
      if ($5) {
       break label$8;
      }
      if (($3 | 0) != -1) {
       $5 = fts3DeleteSegdir($0, $1, $2, $3, HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2]);
       $7 = HEAP32[$4 + 88 >> 2];
       if ($5 | !$7) {
        break label$1;
       }
       break label$6;
      }
      $7 = HEAP32[$4 + 88 >> 2];
      if ($7) {
       break label$6;
      }
      $7 = 0;
      $5 = 0;
      break label$1;
     }
     $7 = HEAP32[$4 + 88 >> 2];
     break label$1;
    }
    $5 = fts3SegWriterAdd($0, $4 + 88 | 0, HEAP32[$4 + 56 >> 2], HEAP32[$4 + 60 >> 2], HEAP32[$4 + 64 >> 2], HEAP32[$4 + 68 >> 2]);
    continue;
   }
   break;
  }
  $5 = fts3SegWriterFlush($0, $7, $9, $8, HEAP32[$4 + 92 >> 2]);
  if ($5) {
   break label$1;
  }
  if (($3 | 0) != -1) {
   $5 = 0;
   if (($8 | 0) >= ($6 | 0) & $9 >>> 0 >= $10 >>> 0 | ($6 | 0) < ($8 | 0)) {
    break label$1;
   }
  }
  $5 = fts3PromoteSegments($0, $9, $8, HEAP32[$7 + 56 >> 2], HEAP32[$7 + 60 >> 2]);
 }
 fts3SegWriterFree($7);
 sqlite3Fts3SegReaderFinish($4 + 16 | 0);
 __stack_pointer = $4 + 96 | 0;
 return $5;
}

function fts3NodeAddTerm($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $5 = HEAP32[$1 >> 2];
      if (!$5) {
       $8 = HEAP32[$0 + 232 >> 2];
       break label$5;
      }
      $4 = HEAP32[$5 + 32 >> 2];
      $10 = HEAP32[$5 + 16 >> 2];
      $9 = fts3PrefixCompress($10, HEAP32[$5 + 20 >> 2], $2, $3);
      $7 = $3 - $9 | 0;
      if (($7 | 0) <= 0) {
       $3 = 267;
       break label$1;
      }
      $11 = $9 >> 31;
      $8 = sqlite3Fts3VarintLen($9, $11) + ($4 + $7 | 0) | 0;
      $12 = $8 + sqlite3Fts3VarintLen($7, 0) | 0;
      $8 = HEAP32[$0 + 232 >> 2];
      if (($12 | 0) > ($8 | 0)) {
       if ($10) {
        break label$5;
       }
       $1 = sqlite3_malloc($12);
       HEAP32[$5 + 36 >> 2] = $1;
       if (!$1) {
        break label$4;
       }
       $10 = HEAP32[$5 + 16 >> 2];
      }
      if ($10) {
       $4 = sqlite3Fts3PutVarint(HEAP32[$5 + 36 >> 2] + $4 | 0, $9, $11) + $4 | 0;
      }
      $1 = sqlite3Fts3PutVarint(HEAP32[$5 + 36 >> 2] + $4 | 0, $7, 0);
      $4 = $4 + $1 | 0;
      __memcpy($4 + HEAP32[$5 + 36 >> 2] | 0, $2 + $9 | 0, $7);
      HEAP32[$5 + 32 >> 2] = $4 + $7;
      HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
      $4 = HEAP32[$5 + 28 >> 2];
      if (HEAP32[$5 + 24 >> 2] < ($3 | 0)) {
       $1 = $3 << 1;
       $4 = sqlite3_realloc($4, $1);
       if (!$4) {
        break label$4;
       }
       HEAP32[$5 + 28 >> 2] = $4;
       HEAP32[$5 + 24 >> 2] = $1;
      }
      HEAP32[$5 + 16 >> 2] = $4;
      __memcpy($4, $2, $3);
      HEAP32[$5 + 20 >> 2] = $3;
      $3 = 0;
      break label$1;
     }
     $4 = sqlite3_malloc($8 + 40 | 0);
     HEAP32[$6 + 12 >> 2] = $4;
     if (!$4) {
      break label$4;
     }
     HEAP32[$4 >> 2] = 0;
     HEAP32[$4 + 4 >> 2] = 0;
     HEAP32[$4 + 32 >> 2] = 11;
     HEAP32[$4 + 24 >> 2] = 0;
     HEAP32[$4 + 28 >> 2] = 0;
     HEAP32[$4 + 16 >> 2] = 0;
     HEAP32[$4 + 20 >> 2] = 0;
     HEAP32[$4 + 8 >> 2] = 0;
     HEAP32[$4 + 12 >> 2] = 0;
     HEAP32[$4 + 36 >> 2] = $4 + 40;
     if (!$5) {
      break label$3;
     }
     HEAP32[$6 + 8 >> 2] = HEAP32[$5 >> 2];
     $3 = fts3NodeAddTerm($0, $6 + 8 | 0, $2, $3);
     $2 = HEAP32[$6 + 8 >> 2];
     if (!HEAP32[$5 >> 2]) {
      HEAP32[$5 >> 2] = $2;
     }
     HEAP32[$5 + 4 >> 2] = $4;
     $0 = HEAP32[$5 + 8 >> 2];
     HEAP32[$4 >> 2] = $2;
     HEAP32[$4 + 8 >> 2] = $0;
     HEAP32[$4 + 28 >> 2] = HEAP32[$5 + 28 >> 2];
     HEAP32[$4 + 24 >> 2] = HEAP32[$5 + 24 >> 2];
     HEAP32[$5 + 28 >> 2] = 0;
     break label$2;
    }
    $3 = 7;
    break label$1;
   }
   HEAP32[$4 + 8 >> 2] = $4;
   $3 = fts3NodeAddTerm($0, $6 + 12 | 0, $2, $3);
   $4 = HEAP32[$6 + 12 >> 2];
  }
  HEAP32[$1 >> 2] = $4;
 }
 __stack_pointer = $6 + 16 | 0;
 return $3;
}

function freePage2($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 label$1: {
  if (!($2 >>> 0 >= 2 & HEAPU32[$0 + 48 >> 2] >= $2 >>> 0)) {
   $3 = sqlite3CorruptError(73436);
   break label$1;
  }
  $6 = HEAP32[$0 + 12 >> 2];
  label$4: {
   if ($1) {
    HEAP32[$4 + 8 >> 2] = $1;
    sqlite3PagerRef(HEAP32[$1 + 72 >> 2]);
    break label$4;
   }
   $1 = btreePageLookup($0, $2);
   HEAP32[$4 + 8 >> 2] = $1;
  }
  $3 = sqlite3PagerWrite(HEAP32[$6 + 72 >> 2]);
  HEAP32[$4 + 4 >> 2] = $3;
  label$6: {
   if ($3) {
    break label$6;
   }
   $3 = HEAP32[$6 + 56 >> 2] + 36 | 0;
   $5 = sqlite3Get4byte($3);
   sqlite3Put4byte($3, $5 + 1 | 0);
   if (HEAPU8[$0 + 24 | 0] & 4) {
    if (!$1) {
     $3 = btreeGetPage($0, $2, $4 + 8 | 0, 0);
     if ($3) {
      break label$6;
     }
     $1 = HEAP32[$4 + 8 >> 2];
    }
    $3 = sqlite3PagerWrite(HEAP32[$1 + 72 >> 2]);
    HEAP32[$4 + 4 >> 2] = $3;
    if ($3) {
     break label$6;
    }
    memset(HEAP32[$1 + 56 >> 2], 0, HEAP32[HEAP32[$1 + 52 >> 2] + 36 >> 2]);
   }
   if (HEAPU8[$0 + 17 | 0]) {
    ptrmapPut($0, $2, 2, 0, $4 + 4 | 0);
    $3 = HEAP32[$4 + 4 >> 2];
    if ($3) {
     break label$6;
    }
   }
   label$10: {
    if (!$5) {
     $5 = 0;
     break label$10;
    }
    $5 = sqlite3Get4byte(HEAP32[$6 + 56 >> 2] + 32 | 0);
    label$12: {
     if ($5 >>> 0 > btreePagecount($0) >>> 0) {
      $3 = sqlite3CorruptError(73483);
      break label$12;
     }
     $3 = btreeGetPage($0, $5, $4 + 12 | 0, 0);
     if ($3) {
      break label$6;
     }
     $7 = HEAP32[$4 + 12 >> 2];
     $8 = sqlite3Get4byte(HEAP32[$7 + 56 >> 2] + 4 | 0);
     $3 = HEAP32[$0 + 40 >> 2] >>> 2 | 0;
     if ($8 >>> 0 > $3 - 2 >>> 0) {
      $3 = sqlite3CorruptError(73494);
      break label$12;
     }
     if ($3 - 8 >>> 0 <= $8 >>> 0) {
      break label$10;
     }
     $3 = sqlite3PagerWrite(HEAP32[$7 + 72 >> 2]);
     if ($3) {
      break label$6;
     }
     sqlite3Put4byte(HEAP32[$7 + 56 >> 2] + 4 | 0, $8 + 1 | 0);
     sqlite3Put4byte((HEAP32[$7 + 56 >> 2] + ($8 << 2) | 0) + 8 | 0, $2);
     if (!(!$1 | HEAPU8[$0 + 24 | 0] & 4)) {
      sqlite3PagerDontWrite(HEAP32[$1 + 72 >> 2]);
     }
     $3 = btreeSetHasContent($0, $2);
    }
    HEAP32[$4 + 4 >> 2] = $3;
    break label$6;
   }
   if (!$1) {
    $3 = btreeGetPage($0, $2, $4 + 8 | 0, 0);
    if ($3) {
     break label$6;
    }
    $1 = HEAP32[$4 + 8 >> 2];
   }
   $3 = sqlite3PagerWrite(HEAP32[$1 + 72 >> 2]);
   if ($3) {
    break label$6;
   }
   sqlite3Put4byte(HEAP32[$1 + 56 >> 2], $5);
   $3 = 0;
   sqlite3Put4byte(HEAP32[$1 + 56 >> 2] + 4 | 0, 0);
   sqlite3Put4byte(HEAP32[$6 + 56 >> 2] + 32 | 0, $2);
  }
  $2 = HEAP32[$4 + 8 >> 2];
  if ($2) {
   HEAP8[$2 | 0] = 0;
  }
  releasePage($2);
  releasePage(HEAP32[$4 + 12 >> 2]);
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function sqlite3PagerSharedLock($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 label$1: {
  label$2: {
   if (!HEAP32[$0 + 232 >> 2]) {
    if (HEAPU8[$0 + 17 | 0]) {
     break label$2;
    }
    HEAP32[$2 + 28 >> 2] = 1;
    $1 = pager_wait_on_lock($0, 1);
    if ($1) {
     break label$1;
    }
    label$4: {
     if (HEAPU8[$0 + 18 | 0] <= 1) {
      $1 = hasHotJournal($0, $2 + 28 | 0);
      if ($1) {
       break label$1;
      }
      if (!HEAP32[$2 + 28 >> 2]) {
       break label$4;
      }
     }
     $1 = 776;
     if (HEAPU8[$0 + 14 | 0]) {
      break label$1;
     }
     $1 = pagerLockDb($0, 4);
     if ($1) {
      break label$1;
     }
     label$6: {
      label$7: {
       label$8: {
        if (!HEAP32[HEAP32[$0 + 68 >> 2] >> 2]) {
         $1 = 0;
         if (HEAPU8[$0 + 5 | 0] == 2) {
          break label$8;
         }
         $3 = HEAP32[$0 >> 2];
         $1 = sqlite3OsAccess($3, HEAP32[$0 + 188 >> 2], 0, $2);
         label$10: {
          if ($1 | !HEAP32[$2 >> 2]) {
           break label$10;
          }
          HEAP32[$2 + 24 >> 2] = 0;
          $1 = sqlite3OsOpen($3, HEAP32[$0 + 188 >> 2], HEAP32[$0 + 68 >> 2], 2050, $2 + 24 | 0);
          if ($1) {
           break label$10;
          }
          $1 = 0;
          if (!(HEAP8[$2 + 24 | 0] & 1)) {
           break label$10;
          }
          $1 = sqlite3CantopenError(59193);
          sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
         }
         if (!HEAP32[HEAP32[$0 + 68 >> 2] >> 2]) {
          break label$8;
         }
        }
        $1 = pagerSyncHotJournal($0);
        if ($1) {
         break label$6;
        }
        $1 = pager_playback($0, !HEAPU8[$0 + 12 | 0]);
        HEAP8[$0 + 17 | 0] = 0;
        break label$7;
       }
       if (HEAPU8[$0 + 4 | 0]) {
        break label$7;
       }
       pagerUnlockDb($0, 1);
      }
      if (!$1) {
       break label$4;
      }
     }
     $1 = pager_error($0, $1);
     break label$1;
    }
    label$11: {
     if (HEAPU8[$0 + 12 | 0] | !HEAPU8[$0 + 24 | 0]) {
      break label$11;
     }
     $1 = sqlite3OsRead(HEAP32[$0 + 64 >> 2], $2, 16, 24, 0);
     if ($1) {
      if (($1 | 0) != 522) {
       break label$1;
      }
      HEAP32[$2 + 8 >> 2] = 0;
      HEAP32[$2 + 12 >> 2] = 0;
      HEAP32[$2 >> 2] = 0;
      HEAP32[$2 + 4 >> 2] = 0;
     }
     if (!memcmp($0 + 112 | 0, $2, 16)) {
      break label$11;
     }
     pager_reset($0);
    }
    $1 = pagerOpenWalIfPresent($0);
    if (!HEAP32[$0 + 232 >> 2]) {
     break label$2;
    }
   }
   $1 = pagerBeginReadTransaction($0);
  }
  if (HEAPU8[$0 + 12 | 0] | (HEAPU8[$0 + 17 | 0] | $1)) {
   break label$1;
  }
  $1 = pagerPagecount($0, $0 + 28 | 0);
 }
 label$13: {
  if ($1) {
   pager_unlock($0);
   break label$13;
  }
  HEAP8[$0 + 24 | 0] = 1;
  HEAP8[$0 + 17 | 0] = 1;
 }
 __stack_pointer = $2 + 32 | 0;
 return $1;
}

function memjrnlCreateFile($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
 $8 = __stack_pointer - 32 | 0;
 __stack_pointer = $8;
 $3 = HEAP32[$0 + 16 >> 2];
 $10 = $3;
 $1 = HEAP32[$0 + 20 >> 2];
 $11 = $1;
 $12 = HEAP32[$0 + 12 >> 2];
 $19 = HEAP32[$0 + 8 >> 2];
 $15 = HEAP32[$0 + 4 >> 2];
 $20 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 44 >> 2];
 $1 = HEAP32[$0 + 40 >> 2];
 $2 = $1;
 $1 = $8;
 HEAP32[$1 + 24 >> 2] = $2;
 HEAP32[$1 + 28 >> 2] = $3;
 $1 = HEAP32[$0 + 36 >> 2];
 $3 = HEAP32[$0 + 32 >> 2];
 $2 = $3;
 $3 = $8;
 HEAP32[$3 + 16 >> 2] = $2;
 HEAP32[$3 + 20 >> 2] = $1;
 $3 = HEAP32[$0 + 28 >> 2];
 $1 = HEAP32[$0 + 24 >> 2];
 $2 = $1;
 $1 = $8;
 HEAP32[$1 + 8 >> 2] = $2;
 HEAP32[$1 + 12 >> 2] = $3;
 $21 = HEAP32[$0 + 60 >> 2];
 $16 = HEAP32[$0 + 48 >> 2];
 label$1: {
  label$2: {
   $17 = HEAP32[$0 + 52 >> 2];
   $18 = HEAP32[$0 + 56 >> 2];
   $7 = memset($0, 0, 64);
   $4 = sqlite3OsOpen($17, $18, $7, $16, 0);
   if ($4) {
    break label$2;
   }
   $9 = $15;
   $0 = $12;
   while (1) {
    if ($0) {
     $4 = $10;
     $5 = $13;
     $6 = $4 - $5 | 0;
     $3 = $11;
     $1 = $14;
     $2 = $1 + ($4 >>> 0 < $5 >>> 0) | 0;
     $22 = $6;
     $4 = $9;
     $2 = $4 >> 31;
     $6 = $2;
     $2 = $1;
     $3 = $5;
     $5 = $4;
     $1 = $3 + $5 | 0;
     $4 = $6;
     $6 = $2 + $4 | 0;
     $6 = $1 >>> 0 < $5 >>> 0 ? $6 + 1 | 0 : $6;
     $5 = $10;
     $3 = $11;
     $9 = $5 >>> 0 < $1 >>> 0 & ($6 | 0) >= ($3 | 0) | ($6 | 0) > ($3 | 0) ? $22 : $9;
     $2 = $14;
     $4 = sqlite3OsWrite($7, $0 + 4 | 0, $9, $13, $2);
     if ($4) {
      break label$2;
     }
     $6 = $9;
     $2 = $6 >> 31;
     $3 = $6;
     $5 = $13;
     $4 = $3 + $5 | 0;
     $6 = $2;
     $2 = $14;
     $1 = $6 + $2 | 0;
     $13 = $4;
     $1 = $3 >>> 0 > $4 >>> 0 ? $1 + 1 | 0 : $1;
     $14 = $1;
     $0 = HEAP32[$0 >> 2];
     continue;
    }
    break;
   }
   memjrnlFreeChunks($12);
   $4 = 0;
   break label$1;
  }
  sqlite3OsClose($7);
  HEAP32[$7 + 16 >> 2] = $10;
  $1 = $11;
  HEAP32[$7 + 20 >> 2] = $1;
  HEAP32[$7 + 12 >> 2] = $12;
  HEAP32[$7 + 8 >> 2] = $19;
  HEAP32[$7 + 4 >> 2] = $15;
  HEAP32[$7 >> 2] = $20;
  $2 = $8;
  $1 = HEAP32[$2 + 24 >> 2];
  $5 = HEAP32[$2 + 28 >> 2];
  $3 = $1;
  $0 = $7 + 24 | 0;
  $1 = $0;
  HEAP32[$1 + 16 >> 2] = $3;
  HEAP32[$1 + 20 >> 2] = $5;
  $1 = HEAP32[$2 + 20 >> 2];
  $5 = HEAP32[$2 + 16 >> 2];
  HEAP32[$7 + 32 >> 2] = $5;
  HEAP32[$7 + 36 >> 2] = $1;
  $5 = HEAP32[$2 + 12 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  $0 = $1;
  $1 = $7;
  HEAP32[$1 + 24 >> 2] = $0;
  HEAP32[$1 + 28 >> 2] = $5;
  HEAP32[$1 + 60 >> 2] = $21;
  HEAP32[$1 + 56 >> 2] = $18;
  HEAP32[$1 + 52 >> 2] = $17;
  HEAP32[$1 + 48 >> 2] = $16;
 }
 __stack_pointer = $8 + 32 | 0;
 return $4;
}

function pushOntoSorter($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $12 = HEAP32[HEAP32[$1 >> 2] >> 2];
 $8 = HEAP8[$1 + 32 | 0] & 1;
 $13 = !$8;
 $14 = ($12 + $13 | 0) + $5 | 0;
 $10 = HEAP32[$1 + 4 >> 2];
 if ($6) {
  $9 = $3 - $6 | 0;
 } else {
  $7 = HEAP32[$0 + 44 >> 2];
  HEAP32[$0 + 44 >> 2] = $14 + $7;
  $9 = $7 + 1 | 0;
 }
 $7 = HEAP32[$2 + 12 >> 2];
 label$3: {
  if ($7) {
   $15 = $7 + 1 | 0;
   break label$3;
  }
  $15 = HEAP32[$2 + 8 >> 2];
 }
 $7 = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 24 >> 2] = sqlite3VdbeMakeLabel($0);
 sqlite3ExprCodeExprList($0, HEAP32[$1 >> 2], $9, $4, $4 ? 5 : 1);
 if (!$8) {
  sqlite3VdbeAddOp2($7, 126, HEAP32[$1 + 8 >> 2], $9 + $12 | 0);
 }
 if (!(($5 | 0) <= 0 | $6)) {
  sqlite3ExprCodeMove($0, $3, ($9 + $12 | 0) + $13 | 0, $5);
 }
 $6 = 0;
 $5 = 0;
 label$7: {
  if (($10 | 0) > 0) {
   $5 = makeSorterRecord($0, $1, $2, $9, $14);
   $3 = HEAP32[$1 + 4 >> 2];
   $4 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 44 >> 2] = $3 + $4;
   $4 = $4 + 1 | 0;
   label$9: {
    if (!$8) {
     $13 = sqlite3VdbeAddOp1($7, 16, $9 + $12 | 0);
     break label$9;
    }
    $13 = sqlite3VdbeAddOp1($7, 120, HEAP32[$1 + 8 >> 2]);
   }
   sqlite3VdbeAddOp3($7, 90, $4, $9, HEAP32[$1 + 4 >> 2]);
   if (HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
    break label$7;
   }
   $11 = sqlite3VdbeGetOp($7, HEAP32[$1 + 20 >> 2]);
   HEAP32[$11 + 8 >> 2] = $14 - $3;
   $8 = HEAP32[$11 + 16 >> 2];
   memset(HEAP32[$8 + 16 >> 2], 0, HEAPU16[$8 + 6 >> 1]);
   sqlite3VdbeChangeP4($7, -1, $8, -8);
   HEAP32[$11 + 16 >> 2] = sqlite3KeyInfoFromExprList($0, HEAP32[$1 >> 2], $10, HEAPU16[$8 + 8 >> 1] + (HEAPU16[$8 + 6 >> 1] ^ -1) | 0);
   $3 = sqlite3VdbeCurrentAddr($7);
   $8 = $3 + 1 | 0;
   sqlite3VdbeAddOp3($7, 13, $8, 0, $8);
   $11 = sqlite3VdbeMakeLabel($0);
   HEAP32[$1 + 16 >> 2] = $11;
   $8 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $8;
   HEAP32[$1 + 12 >> 2] = $8;
   sqlite3VdbeAddOp2($7, 9, $8, $11);
   sqlite3VdbeAddOp1($7, 146, HEAP32[$1 + 8 >> 2]);
   if ($15) {
    sqlite3VdbeAddOp2($7, 16, $15, HEAP32[$1 + 24 >> 2]);
   }
   sqlite3VdbeJumpHere($7, $13);
   sqlite3ExprCodeMove($0, $9, $4, HEAP32[$1 + 4 >> 2]);
   sqlite3VdbeJumpHere($7, $3);
  }
  if ($15) {
   $4 = HEAP32[$1 + 8 >> 2];
   sqlite3VdbeAddOp2($7, 59, $15, sqlite3VdbeCurrentAddr($7) + 4 | 0);
   sqlite3VdbeAddOp2($7, 31, $4, 0);
   $6 = sqlite3VdbeAddOp4Int($7, 39, $4, 0, $9 + $10 | 0, $12 - $10 | 0);
   sqlite3VdbeAddOp1($7, 130, $4);
  }
  if (!$5) {
   $5 = makeSorterRecord($0, $1, $2, $9, $14);
  }
  sqlite3VdbeAddOp4Int($7, HEAP8[$1 + 32 | 0] & 1 ? 139 : 138, HEAP32[$1 + 8 >> 2], $5, $9 + $10 | 0, $14 - $10 | 0);
  if (!$6) {
   break label$7;
  }
  $1 = HEAP32[$1 + 28 >> 2];
  if (!$1) {
   $1 = sqlite3VdbeCurrentAddr($7);
  }
  sqlite3VdbeChangeP2($7, $6, $1);
 }
}

function vdbeRecordDecodeInt($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  switch ($0 | 0) {
  case 0:
  case 1:
   $0 = HEAP8[$1 | 0];
   $2 = $0 >> 31;
   i64toi32_i32$HIGH_BITS = $2;
   return $0;

  case 2:
   $2 = HEAPU8[$1 + 1 | 0] | HEAP8[$1 | 0] << 8;
   $0 = $2 >> 31;
   i64toi32_i32$HIGH_BITS = $0;
   return $2;

  case 3:
   $0 = HEAPU8[$1 + 2 | 0] | (HEAPU8[$1 + 1 | 0] << 8 | HEAP8[$1 | 0] << 16);
   $2 = $0 >> 31;
   i64toi32_i32$HIGH_BITS = $2;
   return $0;

  case 4:
   $1 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
   $2 = $1 << 24 | $1 << 8 & 16711680 | ($1 >>> 8 & 65280 | $1 >>> 24);
   $0 = $2 >> 31;
   i64toi32_i32$HIGH_BITS = $0;
   return $2;

  case 5:
   $2 = HEAPU8[$1 + 5 | 0];
   $5 = $2;
   $0 = HEAPU8[$1 + 3 | 0];
   $3 = $0;
   $0 = $0 >>> 16 | 0;
   $4 = $0;
   $2 = $1;
   $0 = HEAPU8[$2 + 2 | 0];
   $6 = $0 << 24;
   $0 = $0 >>> 8 | 0;
   $2 = $0;
   $0 = $4;
   $2 = $0 | $2;
   $4 = $2;
   $0 = $1;
   $2 = HEAPU8[$0 + 4 | 0];
   $0 = $2;
   $7 = $0 << 8;
   $2 = $0 >>> 24 | 0;
   $0 = $2;
   $2 = $4;
   $0 = $0 | $2;
   $4 = $0;
   $2 = $5;
   $3 = $3 << 16;
   $3 = $6 | $3;
   $5 = $2 | ($7 | $3);
   $0 = HEAPU8[$1 + 1 | 0] | HEAP8[$1 | 0] << 8;
   $3 = $4;
   $2 = $3;
   $0 = $0 | $2;
   i64toi32_i32$HIGH_BITS = $0;
   $3 = $5;
   return $3;

  case 6:
   $2 = $1;
   $3 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
   $5 = $3;
   $2 = $3;
   $3 = $2 << 24;
   $0 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
   $1 = $0;
   $0 = $2;
   $2 = $0 << 8;
   $0 = $2 & 16711680;
   $4 = $0;
   $2 = 0;
   $6 = $2;
   $0 = $3;
   $3 = $4;
   $3 = $0 | $3;
   $4 = $3;
   $3 = $1;
   $0 = $5;
   $2 = $3 << 24 | $0 >>> 8;
   $0 = $2 & 65280;
   $7 = $0;
   $0 = $1;
   $2 = $5;
   $3 = $0 << 8 | $2 >>> 24;
   $2 = $3 & 255;
   $0 = $2;
   $2 = $7;
   $0 = $0 | $2;
   $7 = $0;
   $2 = $6;
   $3 = $8;
   $8 = $2 | ($8 | $3);
   $0 = $4;
   $3 = $7;
   $3 = $0 | $3;
   $4 = $3;
   $3 = $1;
   $0 = $5;
   $3 = ($3 & 255) << 24 | $0 >>> 8;
   $3 = $3 & -16777216;
   $0 = 0;
   $6 = $0;
   $0 = $1;
   $2 = $5;
   $0 = ($0 & 16777215) << 8 | $2 >>> 24;
   $7 = $0 & 16711680 | $3;
   $2 = 0;
   $0 = $2;
   $2 = $6;
   $0 = $0 | $2;
   $5 = $0;
   $0 = $1;
   $0 = $0 >>> 8 | 0;
   $6 = $0 & 65280;
   $2 = 0;
   $0 = $2;
   $2 = $1;
   $0 = 0;
   $3 = $0;
   $3 = $0 | $3;
   $0 = $7;
   $1 = $2 >>> 24 | 0;
   $2 = $6;
   $1 = $0 | ($1 | $2);
   $2 = $3;
   $3 = $5;
   $2 = $2 | $3;
   $0 = $2;
   $2 = $4;
   $0 = $0 | $2;
   i64toi32_i32$HIGH_BITS = $0;
   $3 = $8;
   $3 = $1 | $3;
   return $3;

  default:
   break label$1;
  }
 }
 i64toi32_i32$HIGH_BITS = 0;
 $0 = $0 - 8 | 0;
 return $0;
}

function sqlite3ExprCollSeq($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   label$3: while (1) {
    $2 = $1;
    if (!$2) {
     break label$2;
    }
    label$4: {
     $1 = HEAPU8[$2 | 0];
     if (($1 | 0) == 176) {
      $1 = HEAPU8[$2 + 2 | 0];
     }
     label$5: {
      label$7: {
       label$8: {
        label$9: {
         label$10: {
          label$11: {
           label$12: {
            $1 = $1 & 255;
            switch ($1 - 167 | 0) {
            case 0:
            case 2:
             break label$11;

            case 1:
             break label$8;

            default:
             break label$12;
            }
           }
           label$13: {
            switch ($1 - 174 | 0) {
            case 3:
             break label$10;

            case 0:
             break label$7;

            case 1:
            case 2:
             break label$8;

            default:
             break label$13;
            }
           }
           if (($1 | 0) == 36) {
            break label$7;
           }
           if (($1 | 0) == 77) {
            break label$11;
           }
           if (($1 | 0) != 113) {
            break label$8;
           }
           break label$4;
          }
          $3 = HEAP32[$2 + 44 >> 2];
          if (!$3) {
           break label$9;
          }
          $2 = HEAP16[$2 + 32 >> 1];
          $1 = 0;
          if (($2 | 0) < 0) {
           break label$1;
          }
          $1 = sqlite3FindCollSeq($4, HEAPU8[$4 + 84 | 0], sqlite3ColumnColl(HEAP32[$3 + 4 >> 2] + Math_imul($2 & 65535, 12) | 0), 0);
          break label$1;
         }
         $2 = HEAP32[$2 + 20 >> 2] + 8 | 0;
         break label$5;
        }
        if (($1 | 0) == 113) {
         break label$4;
        }
       }
       if (!(HEAPU8[$2 + 5 | 0] & 2)) {
        break label$2;
       }
       $1 = HEAP32[$2 + 12 >> 2];
       if (HEAPU8[$1 + 5 | 0] & 2 ? $1 : 0) {
        continue;
       }
       $5 = HEAP32[$2 + 16 >> 2];
       $1 = $5;
       $3 = HEAP32[$2 + 20 >> 2];
       if (!$3) {
        continue;
       }
       $1 = $5;
       if (HEAPU8[$4 + 87 | 0]) {
        continue;
       }
       $2 = 0;
       $1 = HEAP32[$3 >> 2];
       $6 = ($1 | 0) > 0 ? $1 : 0;
       while (1) {
        if (($2 | 0) == ($6 | 0)) {
         $1 = $5;
         continue label$3;
        }
        $1 = $2 << 4;
        $2 = $2 + 1 | 0;
        $1 = HEAP32[($1 + $3 | 0) + 8 >> 2];
        if (!(HEAPU8[$1 + 5 | 0] & 2)) {
         continue;
        }
        break;
       }
       continue;
      }
      $2 = $2 + 12 | 0;
     }
     $1 = HEAP32[$2 >> 2];
     continue;
    }
    break;
   }
   $1 = sqlite3GetCollSeq($0, HEAPU8[$4 + 84 | 0], 0, HEAP32[$2 + 8 >> 2]);
   break label$1;
  }
  $1 = 0;
 }
 return sqlite3CheckCollSeq($0, $1) ? 0 : $1;
}

function sqlite3VdbeMakeReady($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$0 + 128 >> 2] = HEAP32[$1 + 224 >> 2];
 HEAP32[$1 + 224 >> 2] = 0;
 $10 = HEAP16[$1 + 204 >> 1];
 $7 = HEAP32[$0 >> 2];
 $4 = HEAP32[$1 + 44 >> 2];
 $9 = HEAP32[$1 + 40 >> 2];
 HEAP32[$3 + 28 >> 2] = HEAP32[$1 + 96 >> 2];
 $5 = Math_imul(HEAP32[$0 + 108 >> 2], 20) + 7 & -8;
 HEAP32[$3 >> 2] = $5 + HEAP32[$0 + 104 >> 2];
 $2 = HEAP32[$1 + 48 >> 2] - $5 & -8;
 $8 = $2 >> 31;
 $5 = $2;
 $2 = $3;
 HEAP32[$2 + 8 >> 2] = $5;
 HEAP32[$2 + 12 >> 2] = $8;
 resolveP2Values($0, $2 + 28 | 0);
 $4 = $4 + $9 | 0;
 $5 = !$9 & ($4 | 0) > 0;
 $5 = $5 + $4 | 0;
 $6 = HEAPU8[$1 + 20 | 0] ? (HEAPU8[$1 + 21 | 0] != 0) << 5 : $6;
 $6 = $6 | HEAPU8[$0 + 150 | 0] & -33;
 HEAP8[$0 + 150 | 0] = $6;
 $4 = HEAPU8[$1 + 207 | 0];
 if ($4) {
  HEAP8[$0 + 150 | 0] = $4 << 2 & 12 | $6 & 243;
  $1 = HEAPU8[$1 + 207 | 0] == 2;
  sqlite3VdbeSetNumCols($0, $1 ? 4 : 8);
  $5 = ($5 | 0) > 10 ? $5 : 10;
  $6 = $1 ? 12 : 8;
  $4 = $1 << 3;
  $1 = $4;
  while (1) {
   if (($1 | 0) != ($6 | 0)) {
    sqlite3VdbeSetColName($0, $1 - $4 | 0, 0, HEAP32[($1 << 2) + 34400 >> 2], 0);
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  $6 = HEAPU8[$0 + 150 | 0];
 }
 HEAP8[$0 + 150 | 0] = $6 & 252;
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 $4 = Math_imul($5, 40);
 HEAP32[$0 + 88 >> 2] = allocSpace($2, 0, $4, 0);
 $11 = Math_imul($10, 40);
 HEAP32[$0 + 100 >> 2] = allocSpace($2, 0, $11, 0);
 $12 = HEAP32[$2 + 28 >> 2] << 2;
 HEAP32[$0 + 92 >> 2] = allocSpace($2, 0, $12, 0);
 $1 = $9 << 2;
 HEAP32[$0 + 96 >> 2] = allocSpace($2, 0, $1, 0);
 $8 = HEAP32[$2 + 16 >> 2];
 $2 = HEAP32[$2 + 20 >> 2];
 label$5: {
  label$6: {
   label$7: {
    if ($2 | $8) {
     $6 = sqlite3DbMallocRawNN($7, $8, $2);
     HEAP32[$0 + 208 >> 2] = $6;
     HEAP32[$3 + 8 >> 2] = $8;
     HEAP32[$3 + 12 >> 2] = $2;
     HEAP32[$3 >> 2] = $6;
     if (HEAPU8[$7 + 87 | 0]) {
      break label$7;
     }
     HEAP32[$0 + 88 >> 2] = allocSpace($3, HEAP32[$0 + 88 >> 2], $4, 0);
     HEAP32[$0 + 100 >> 2] = allocSpace($3, HEAP32[$0 + 100 >> 2], $11, 0);
     HEAP32[$0 + 92 >> 2] = allocSpace($3, HEAP32[$0 + 92 >> 2], $12, 0);
     HEAP32[$0 + 96 >> 2] = allocSpace($3, HEAP32[$0 + 96 >> 2], $1, 0);
     break label$6;
    }
    if (!HEAPU8[$7 + 87 | 0]) {
     break label$6;
    }
   }
   HEAP16[$0 + 16 >> 1] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 + 24 >> 2] = 0;
   break label$5;
  }
  HEAP16[$0 + 16 >> 1] = $10;
  HEAP32[$0 + 24 >> 2] = $9;
  initMemArray(HEAP32[$0 + 100 >> 2], $10, $7, 1);
  HEAP32[$0 + 20 >> 2] = $5;
  initMemArray(HEAP32[$0 + 88 >> 2], $5, $7, 0);
  memset(HEAP32[$0 + 96 >> 2], 0, $1);
 }
 sqlite3VdbeRewind($0);
 __stack_pointer = $3 + 32 | 0;
}

function fts3ChecksumIndex($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 88 >> 2] = 0;
 HEAP32[$4 + 80 >> 2] = 0;
 HEAP32[$4 + 84 >> 2] = 0;
 memset($4 + 24 | 0, 0, 56);
 HEAP32[$4 + 92 >> 2] = 19;
 label$1: {
  $6 = sqlite3Fts3SegReaderCursor($0, $1, $2, -2, 0, 0, 0, 1, $4 + 24 | 0);
  if ($6) {
   break label$1;
  }
  $6 = sqlite3Fts3SegReaderStart($0, $4 + 24 | 0, $4 + 80 | 0);
  if ($6) {
   break label$1;
  }
  label$2: while (1) {
   $6 = sqlite3Fts3SegReaderStep($0, $4 + 24 | 0);
   if (($6 | 0) != 100) {
    break label$1;
   }
   $16 = HEAP32[$4 + 76 >> 2];
   $6 = HEAP32[$4 + 72 >> 2];
   $12 = 0;
   $13 = 0;
   HEAP32[$4 + 16 >> 2] = 0;
   HEAP32[$4 + 20 >> 2] = 0;
   HEAP32[$4 + 8 >> 2] = 0;
   HEAP32[$4 + 12 >> 2] = 0;
   $16 = $6 + $16 | 0;
   $6 = sqlite3Fts3GetVarint($6, $4 + 16 | 0) + $6 | 0;
   $8 = HEAP32[$4 + 16 >> 2];
   $14 = $8;
   $11 = HEAP32[$4 + 20 >> 2];
   while (1) {
    if ($6 >>> 0 >= $16 >>> 0) {
     continue label$2;
    }
    HEAP32[$4 >> 2] = 0;
    HEAP32[$4 + 4 >> 2] = 0;
    $6 = sqlite3Fts3GetVarintU($6, $4) + $6 | 0;
    if ($16 >>> 0 <= $6 >>> 0) {
     continue;
    }
    $8 = HEAP32[$4 + 4 >> 2];
    $15 = $8;
    $10 = HEAP32[$4 >> 2];
    $7 = $10;
    if (!$8 & $7 >>> 0 <= 1) {
     HEAP32[$4 + 8 >> 2] = 0;
     HEAP32[$4 + 12 >> 2] = 0;
     $7 = $15;
     if ($7 | $10) {
      $6 = sqlite3Fts3GetVarint($6, $4 + 8 | 0) + $6 | 0;
      $12 = 0;
      $13 = 0;
      continue;
     }
     $6 = sqlite3Fts3GetVarintU($6, $4) + $6 | 0;
     $7 = HEAP32[$4 >> 2];
     $10 = $7;
     $8 = HEAP32[$4 + 4 >> 2];
     $15 = $8;
     if (HEAPU8[$0 + 239 | 0]) {
      $5 = $14;
      $9 = $5 - $10 | 0;
      $14 = $9;
      $8 = $11;
      $7 = $15;
      $11 = $8 - ($7 + ($5 >>> 0 < $10 >>> 0) | 0) | 0;
      $12 = 0;
      $13 = 0;
      continue;
     }
     $5 = $15;
     $9 = $11 + $5 | 0;
     $8 = $14;
     $7 = $10 + $8 | 0;
     $14 = $7;
     $9 = $7 >>> 0 < $10 >>> 0 ? $9 + 1 | 0 : $9;
     $11 = $9;
     $12 = 0;
     $13 = 0;
    } else {
     $8 = $15;
     $9 = $13;
     $7 = $8 + $9 | 0;
     $5 = $10 + $12 | 0;
     $8 = $5 - 2 | 0;
     $12 = $8;
     $7 = $5 >>> 0 < $10 >>> 0 ? $7 + 1 | 0 : $7;
     $5 = $5 >>> 0 < 2;
     $5 = $7 - $5 | 0;
     $13 = $5;
     $5 = $11;
     $5 = fts3ChecksumEntry(HEAP32[$4 + 64 >> 2], HEAP32[$4 + 68 >> 2], $1, $2, $14, $5, HEAP32[$4 + 8 >> 2], $8);
     $17 = $5 ^ $17;
     $5 = $18;
     $9 = i64toi32_i32$HIGH_BITS;
     $5 = $5 ^ $9;
     $18 = $5;
    }
    continue;
   }
  }
 }
 sqlite3Fts3SegReaderFinish($4 + 24 | 0);
 HEAP32[$3 >> 2] = $6;
 __stack_pointer = $4 + 96 | 0;
 $5 = $18;
 i64toi32_i32$HIGH_BITS = $5;
 $7 = $17;
 return $7;
}

function btreeCreateTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 label$1: {
  label$2: {
   label$3: {
    $5 = HEAP32[$0 + 4 >> 2];
    label$4: {
     if (HEAPU8[$5 + 17 | 0]) {
      invalidateAllOverflowCache($5);
      sqlite3BtreeGetMeta($0, 4, $3 + 24 | 0);
      $6 = HEAP32[$3 + 24 >> 2];
      if ($6 >>> 0 > btreePagecount($5) >>> 0) {
       break label$3;
      }
      $7 = HEAP32[16232];
      while (1) {
       $4 = $6;
       $6 = $4 + 1 | 0;
       if (($6 | 0) == (ptrmapPageno($5, $6) | 0) | (($7 >>> 0) / HEAPU32[$5 + 36 >> 2] | 0) == ($4 | 0)) {
        continue;
       }
       break;
      }
      HEAP32[$3 + 24 >> 2] = $6;
      $4 = allocateBtreePage($5, $3 + 12 | 0, $3 + 16 | 0, $6, 1);
      HEAP32[$3 + 20 >> 2] = $4;
      if ($4) {
       break label$1;
      }
      $7 = HEAP32[$3 + 16 >> 2];
      label$7: {
       if (($7 | 0) != ($6 | 0)) {
        HEAP8[$3 + 11 | 0] = 0;
        HEAP32[$3 + 4 >> 2] = 0;
        $4 = saveAllCursors($5, 0, 0);
        releasePage(HEAP32[$3 + 12 >> 2]);
        if ($4) {
         break label$1;
        }
        $4 = btreeGetPage($5, $6, $3 + 28 | 0, 0);
        if ($4) {
         break label$1;
        }
        $4 = ptrmapGet($5, $6, $3 + 11 | 0, $3 + 4 | 0);
        $9 = HEAPU8[$3 + 11 | 0];
        if (($9 - 1 & 255) >>> 0 <= 1) {
         $4 = sqlite3CorruptError(76576);
        }
        $8 = HEAP32[$3 + 28 >> 2];
        if ($4) {
         releasePage($8);
         break label$1;
        }
        $4 = relocatePage($5, $8, $9, HEAP32[$3 + 4 >> 2], $7, 0);
        releasePage($8);
        if ($4) {
         break label$1;
        }
        $4 = btreeGetPage($5, $6, $3 + 28 | 0, 0);
        if ($4) {
         break label$1;
        }
        $7 = HEAP32[$3 + 28 >> 2];
        $4 = sqlite3PagerWrite(HEAP32[$7 + 72 >> 2]);
        HEAP32[$3 + 20 >> 2] = $4;
        if (!$4) {
         break label$7;
        }
        break label$2;
       }
       $7 = HEAP32[$3 + 12 >> 2];
       HEAP32[$3 + 28 >> 2] = $7;
      }
      ptrmapPut($5, $6, 1, 0, $3 + 20 | 0);
      $4 = HEAP32[$3 + 20 >> 2];
      if ($4) {
       break label$2;
      }
      $4 = sqlite3BtreeUpdateMeta($0, 4, $6);
      HEAP32[$3 + 20 >> 2] = $4;
      if ($4) {
       break label$2;
      }
      break label$4;
     }
     $4 = allocateBtreePage($5, $3 + 28 | 0, $3 + 24 | 0, 1, 0);
     HEAP32[$3 + 20 >> 2] = $4;
     if ($4) {
      break label$1;
     }
     $7 = HEAP32[$3 + 28 >> 2];
    }
    zeroPage($7, $2 & 1 ? 13 : 10);
    sqlite3PagerUnref(HEAP32[$7 + 72 >> 2]);
    HEAP32[$1 >> 2] = HEAP32[$3 + 24 >> 2];
    $4 = 0;
    break label$1;
   }
   $4 = sqlite3CorruptError(76528);
   break label$1;
  }
  releasePage($7);
 }
 __stack_pointer = $3 + 32 | 0;
 return $4;
}

function freeSpace($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $9 = $1 + $2 | 0;
 $4 = HEAPU8[$0 + 9 | 0];
 $11 = $4 + 1 | 0;
 $8 = HEAP32[$0 + 56 >> 2];
 $10 = $8 + $4 | 0;
 label$1: {
  if (!(HEAPU8[$10 + 2 | 0] | HEAPU8[$8 + $11 | 0])) {
   $12 = $11;
   $4 = $2;
   $3 = $1;
   $6 = $3 >>> 8 | 0;
   break label$1;
  }
  $4 = $11;
  label$3: {
   while (1) {
    $12 = $4;
    $6 = $4 & 65535;
    $5 = $6 + $8 | 0;
    $7 = HEAPU8[$5 | 0];
    $14 = HEAPU8[$5 + 1 | 0];
    $4 = $14 | $7 << 8;
    $3 = $4;
    if ($3 >>> 0 >= $1 >>> 0) {
     break label$3;
    }
    if ($6 + 4 >>> 0 <= $3 >>> 0) {
     continue;
    }
    break;
   }
   if (!($4 & 65535)) {
    break label$3;
   }
   return sqlite3CorruptError(68684);
  }
  $15 = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2];
  if ($15 - 4 >>> 0 < $3 >>> 0) {
   return sqlite3CorruptError(68689);
  }
  label$6: {
   if (!(!($4 & 65535) | $9 + 3 >>> 0 < $3 >>> 0)) {
    if ($3 >>> 0 < $9 >>> 0) {
     return sqlite3CorruptError(68701);
    }
    $7 = $3 + $8 | 0;
    $13 = (HEAPU8[$7 + 2 | 0] << 8 | HEAPU8[$7 + 3 | 0]) + $3 | 0;
    if ($15 >>> 0 < $13 >>> 0) {
     return sqlite3CorruptError(68704);
    }
    $16 = $3 - $9 | 0;
    $14 = HEAPU8[$7 + 1 | 0];
    $7 = HEAPU8[$7 | 0];
    $4 = $13 - $1 | 0;
    break label$6;
   }
   $13 = $9;
   $4 = $2;
  }
  label$10: {
   label$11: {
    if ($6 >>> 0 <= $11 >>> 0) {
     break label$11;
    }
    $3 = (HEAPU8[$5 + 3 | 0] | HEAPU8[$5 + 2 | 0] << 8) + $6 | 0;
    if ($3 + 3 >>> 0 < $1 >>> 0) {
     break label$11;
    }
    if ($1 >>> 0 >= $3 >>> 0) {
     $4 = $13 - $12 | 0;
     $16 = ($1 - $3 | 0) + $16 | 0;
     $1 = $12;
     break label$10;
    }
    return sqlite3CorruptError(68717);
   }
  }
  $3 = $1;
  $5 = $10 + 7 | 0;
  $6 = HEAPU8[$5 | 0];
  if ($6 >>> 0 < ($16 & 255) >>> 0) {
   return sqlite3CorruptError(68723);
  }
  HEAP8[$10 + 7 | 0] = $6 - $16;
  $9 = $13;
  $1 = $3 & 65535;
  $6 = $1 >>> 8 | 0;
 }
 $15 = $10 + 5 | 0;
 $5 = HEAPU8[$10 + 6 | 0] | HEAPU8[$15 | 0] << 8;
 label$14: {
  if ($5 >>> 0 >= $1 >>> 0) {
   if ($1 >>> 0 < $5 >>> 0) {
    return sqlite3CorruptError(68732);
   }
   if (($12 & 65535) != ($11 | 0)) {
    return sqlite3CorruptError(68733);
   }
   $3 = $8 + $11 | 0;
   HEAP8[$3 + 1 | 0] = $14;
   HEAP8[$3 | 0] = $7;
   HEAP8[$10 + 6 | 0] = $9;
   HEAP8[$10 + 5 | 0] = $9 >>> 8;
   break label$14;
  }
  $5 = ($12 & 65535) + $8 | 0;
  HEAP8[$5 + 1 | 0] = $3;
  HEAP8[$5 | 0] = $6;
 }
 if (HEAPU8[HEAP32[$0 + 52 >> 2] + 24 | 0] & 12) {
  memset($1 + $8 | 0, 0, $4 & 65535);
 }
 $3 = $1 + $8 | 0;
 HEAP8[$3 + 1 | 0] = $14;
 HEAP8[$3 | 0] = $7;
 HEAP8[$3 + 3 | 0] = $4;
 HEAP8[$3 + 2 | 0] = $4 >>> 8;
 HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $2;
 return 0;
}

function sqlite3WindowCodeInit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = HEAP32[HEAP32[HEAP32[HEAP32[$1 + 32 >> 2] + 28 >> 2] + 28 >> 2] >> 2];
 $3 = HEAP32[$1 + 68 >> 2];
 $4 = sqlite3GetVdbe($0);
 sqlite3VdbeAddOp2($4, 118, HEAP32[$3 + 48 >> 2], $2);
 $1 = HEAP32[$3 + 48 >> 2];
 sqlite3VdbeAddOp2($4, 115, $1 + 1 | 0, $1);
 $1 = HEAP32[$3 + 48 >> 2];
 sqlite3VdbeAddOp2($4, 115, $1 + 2 | 0, $1);
 $1 = HEAP32[$3 + 48 >> 2];
 sqlite3VdbeAddOp2($4, 115, $1 + 3 | 0, $1);
 $1 = HEAP32[$3 + 8 >> 2];
 if ($1) {
  $1 = HEAP32[$1 >> 2];
  $2 = HEAP32[$0 + 44 >> 2];
  $5 = $2 + 1 | 0;
  HEAP32[$3 + 68 >> 2] = $5;
  $1 = $1 + $2 | 0;
  HEAP32[$0 + 44 >> 2] = $1;
  sqlite3VdbeAddOp3($4, 75, 0, $5, $1);
 }
 $1 = HEAP32[$0 + 44 >> 2] + 1 | 0;
 HEAP32[$0 + 44 >> 2] = $1;
 HEAP32[$3 + 84 >> 2] = $1;
 sqlite3VdbeAddOp2($4, 71, 1, $1);
 label$2: {
  if (!HEAPU8[$3 + 20 | 0]) {
   $1 = $3;
   while (1) {
    if (!$1) {
     break label$2;
    }
    $2 = HEAP32[$1 + 44 >> 2];
    label$5: {
     if (!(!(HEAPU8[$2 + 5 | 0] & 16) | HEAPU8[$1 + 17 | 0] == 90)) {
      $2 = sqlite3KeyInfoFromExprList($0, HEAP32[HEAP32[$1 + 72 >> 2] + 20 >> 2], 0, 0);
      $5 = HEAP32[$0 + 40 >> 2];
      HEAP32[$0 + 40 >> 2] = $5 + 1;
      HEAP32[$1 + 60 >> 2] = $5;
      $6 = HEAP32[$0 + 44 >> 2];
      HEAP32[$1 + 64 >> 2] = $6 + 1;
      HEAP32[$0 + 44 >> 2] = $6 + 3;
      if (!(!$2 | HEAPU8[HEAP32[HEAP32[$1 + 44 >> 2] + 32 >> 2] + 1 | 0] != 105)) {
       HEAP8[HEAP32[$2 + 16 >> 2]] = 1;
       $5 = HEAP32[$1 + 60 >> 2];
      }
      sqlite3VdbeAddOp2($4, 118, $5, 2);
      sqlite3VdbeAppendP4($4, $2, -8);
      sqlite3VdbeAddOp2($4, 71, 0, HEAP32[$1 + 64 >> 2] + 1 | 0);
      break label$5;
     }
     $2 = HEAP32[$2 + 32 >> 2];
     if (!(($2 | 0) != 48960 & ($2 | 0) != 48970)) {
      $5 = HEAP32[$0 + 44 >> 2];
      HEAP32[$1 + 64 >> 2] = $5 + 1;
      $2 = HEAP32[$0 + 40 >> 2];
      HEAP32[$0 + 40 >> 2] = $2 + 1;
      HEAP32[$1 + 60 >> 2] = $2;
      HEAP32[$0 + 44 >> 2] = $5 + 2;
      sqlite3VdbeAddOp2($4, 115, $2, HEAP32[$3 + 48 >> 2]);
      break label$5;
     }
     if (($2 | 0) != 48738 & ($2 | 0) != 48743) {
      break label$5;
     }
     $2 = HEAP32[$0 + 40 >> 2];
     HEAP32[$0 + 40 >> 2] = $2 + 1;
     HEAP32[$1 + 60 >> 2] = $2;
     sqlite3VdbeAddOp2($4, 115, $2, HEAP32[$3 + 48 >> 2]);
    }
    $1 = HEAP32[$1 + 36 >> 2];
    continue;
   }
  }
  $1 = HEAP32[$0 + 44 >> 2];
  $2 = $1 + 1 | 0;
  HEAP32[$3 + 88 >> 2] = $2;
  $1 = $1 + 2 | 0;
  HEAP32[$0 + 44 >> 2] = $1;
  HEAP32[$3 + 92 >> 2] = $1;
  $1 = HEAP32[$0 + 40 >> 2];
  HEAP32[$0 + 40 >> 2] = $1 + 1;
  HEAP32[$3 + 60 >> 2] = $1;
  sqlite3VdbeAddOp2($4, 71, 1, $2);
  sqlite3VdbeAddOp2($4, 71, 0, HEAP32[$3 + 92 >> 2]);
  sqlite3VdbeAddOp2($4, 115, HEAP32[$3 + 60 >> 2], HEAP32[$3 + 48 >> 2]);
 }
}

function pager_end_transaction($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (HEAPU8[$0 + 17 | 0] <= 1) {
   $4 = 0;
   if (HEAPU8[$0 + 18 | 0] < 2) {
    break label$1;
   }
  }
  releaseAllSavepoints($0);
  $4 = HEAP32[$0 + 68 >> 2];
  label$3: {
   if (!HEAP32[$4 >> 2]) {
    break label$3;
   }
   if (sqlite3JournalIsInMemory($4)) {
    sqlite3OsClose($4);
    break label$3;
   }
   label$5: {
    label$6: {
     label$7: {
      label$8: {
       $3 = HEAPU8[$0 + 5 | 0];
       switch ($3 - 1 | 0) {
       case 0:
        break label$6;

       case 2:
        break label$8;

       default:
        break label$7;
       }
      }
      $3 = 0;
      label$9: {
       if (!(HEAP32[$0 + 80 >> 2] | HEAP32[$0 + 84 >> 2])) {
        break label$9;
       }
       $3 = sqlite3OsTruncate($4, 0, 0);
       if ($3) {
        break label$9;
       }
       $3 = 0;
       if (!HEAPU8[$0 + 8 | 0]) {
        break label$9;
       }
       $3 = sqlite3OsSync(HEAP32[$0 + 68 >> 2], HEAPU8[$0 + 10 | 0]);
      }
      HEAP32[$0 + 80 >> 2] = 0;
      HEAP32[$0 + 84 >> 2] = 0;
      break label$3;
     }
     if (!HEAPU8[$0 + 4 | 0] | ($3 | 0) == 5) {
      break label$5;
     }
    }
    $3 = 1;
    $3 = $1 ? $3 : HEAPU8[$0 + 12 | 0] != 0;
    $3 = zeroJournalHdr($0, $3);
    HEAP32[$0 + 80 >> 2] = 0;
    HEAP32[$0 + 84 >> 2] = 0;
    break label$3;
   }
   $1 = HEAPU8[$0 + 12 | 0];
   sqlite3OsClose($4);
   $3 = 0;
   if ($1) {
    break label$3;
   }
   $3 = sqlite3OsDelete(HEAP32[$0 >> 2], HEAP32[$0 + 188 >> 2], HEAPU8[$0 + 9 | 0]);
  }
  sqlite3BitvecDestroy(HEAP32[$0 + 60 >> 2]);
  HEAP32[$0 + 48 >> 2] = 0;
  HEAP32[$0 + 60 >> 2] = 0;
  if (!$3) {
   label$12: {
    label$13: {
     if (!HEAPU8[$0 + 15 | 0]) {
      if (!pagerFlushOnCommit($0, $2)) {
       break label$13;
      }
     }
     sqlite3PcacheCleanAll(HEAP32[$0 + 228 >> 2]);
     break label$12;
    }
    sqlite3PcacheClearWritable(HEAP32[$0 + 228 >> 2]);
   }
   sqlite3PcacheTruncate(HEAP32[$0 + 228 >> 2], HEAP32[$0 + 28 >> 2]);
  }
  $4 = HEAP32[$0 + 232 >> 2];
  label$15: {
   if ($4) {
    sqlite3WalEndWriteTransaction($4);
    break label$15;
   }
   if (!$2 | $3) {
    break label$15;
   }
   $3 = 0;
   $4 = HEAP32[$0 + 28 >> 2];
   if ($4 >>> 0 >= HEAPU32[$0 + 36 >> 2]) {
    break label$15;
   }
   $3 = pager_truncate($0, $4);
  }
  if (!(!$2 | $3)) {
   $3 = sqlite3OsFileControl(HEAP32[$0 + 64 >> 2], 22, 0);
   $3 = ($3 | 0) == 12 ? 0 : $3;
  }
  $2 = 0;
  label$18: {
   if (HEAPU8[$0 + 4 | 0]) {
    break label$18;
   }
   $4 = HEAP32[$0 + 232 >> 2];
   if ($4) {
    $2 = 0;
    if (!sqlite3WalExclusiveMode($4, 0)) {
     break label$18;
    }
   }
   $2 = pagerUnlockDb($0, 1);
  }
  HEAP8[$0 + 20 | 0] = 0;
  HEAP8[$0 + 17 | 0] = 1;
  $4 = $3 ? $3 : $2;
 }
 $3 = $4;
 return $3;
}

function pager_write_pagelist($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $5 = HEAP32[$0 + 64 >> 2];
 label$1: {
  if (!HEAP32[$5 >> 2]) {
   $5 = pagerOpentemp($0, $5, HEAP32[$0 + 152 >> 2]);
   if ($5) {
    break label$1;
   }
  }
  $5 = 0;
  $6 = HEAP32[$0 + 28 >> 2];
  $7 = HEAP32[$0 + 40 >> 2];
  if ($6 >>> 0 <= $7 >>> 0 | !HEAP32[$1 + 16 >> 2] & HEAPU32[$1 + 24 >> 2] <= $7 >>> 0) {
   break label$1;
  }
  $2 = HEAP32[$0 + 168 >> 2];
  $3 = HEAP32[$0 + 172 >> 2];
  $2 = __wasm_i64_mul($2, $3, $6, 0);
  $3 = $2;
  $2 = $8;
  HEAP32[$2 + 8 >> 2] = $3;
  $3 = i64toi32_i32$HIGH_BITS;
  HEAP32[$2 + 12 >> 2] = $3;
  sqlite3OsFileControlHint(HEAP32[$0 + 64 >> 2], 5, $2 + 8 | 0);
  HEAP32[$0 + 40 >> 2] = HEAP32[$0 + 28 >> 2];
 }
 while (1) {
  if (!(!$1 | $5)) {
   $5 = 0;
   $6 = HEAP32[$1 + 24 >> 2];
   if (!(HEAPU8[$1 + 28 | 0] & 16 | $6 >>> 0 > HEAPU32[$0 + 28 >> 2])) {
    $3 = HEAP32[$0 + 168 >> 2];
    $4 = $3;
    $2 = HEAP32[$0 + 172 >> 2];
    $3 = __wasm_i64_mul($3, $2, $6 - 1 | 0, 0);
    $5 = $3;
    $2 = i64toi32_i32$HIGH_BITS;
    $3 = $2;
    $7 = ($6 | 0) != 1;
    if (!$7) {
     pager_write_changecounter($1);
     $2 = HEAP32[$0 + 168 >> 2];
     $4 = $2;
    }
    $2 = HEAP32[$1 + 4 >> 2];
    $5 = sqlite3OsWrite(HEAP32[$0 + 64 >> 2], $2, $4, $5, $3);
    if (!$7) {
     $4 = $2;
     $3 = HEAPU8[$4 + 24 | 0] | HEAPU8[$4 + 25 | 0] << 8 | (HEAPU8[$4 + 26 | 0] << 16 | HEAPU8[$4 + 27 | 0] << 24);
     $2 = HEAPU8[$4 + 28 | 0] | HEAPU8[$4 + 29 | 0] << 8 | (HEAPU8[$4 + 30 | 0] << 16 | HEAPU8[$4 + 31 | 0] << 24);
     HEAP8[$0 + 112 | 0] = $3;
     HEAP8[$0 + 113 | 0] = $3 >>> 8;
     HEAP8[$0 + 114 | 0] = $3 >>> 16;
     HEAP8[$0 + 115 | 0] = $3 >>> 24;
     HEAP8[$0 + 116 | 0] = $2;
     HEAP8[$0 + 117 | 0] = $2 >>> 8;
     HEAP8[$0 + 118 | 0] = $2 >>> 16;
     HEAP8[$0 + 119 | 0] = $2 >>> 24;
     $3 = HEAPU8[$4 + 36 | 0] | HEAPU8[$4 + 37 | 0] << 8 | (HEAPU8[$4 + 38 | 0] << 16 | HEAPU8[$4 + 39 | 0] << 24);
     $2 = HEAPU8[$4 + 32 | 0] | HEAPU8[$4 + 33 | 0] << 8 | (HEAPU8[$4 + 34 | 0] << 16 | HEAPU8[$4 + 35 | 0] << 24);
     HEAP8[$0 + 120 | 0] = $2;
     HEAP8[$0 + 121 | 0] = $2 >>> 8;
     HEAP8[$0 + 122 | 0] = $2 >>> 16;
     HEAP8[$0 + 123 | 0] = $2 >>> 24;
     HEAP8[$0 + 124 | 0] = $3;
     HEAP8[$0 + 125 | 0] = $3 >>> 8;
     HEAP8[$0 + 126 | 0] = $3 >>> 16;
     HEAP8[$0 + 127 | 0] = $3 >>> 24;
    }
    if (HEAPU32[$0 + 36 >> 2] < $6 >>> 0) {
     HEAP32[$0 + 36 >> 2] = $6;
    }
    HEAP32[$0 + 208 >> 2] = HEAP32[$0 + 208 >> 2] + 1;
    sqlite3BackupUpdate(HEAP32[$0 + 96 >> 2], $6, HEAP32[$1 + 4 >> 2]);
   }
   $1 = HEAP32[$1 + 16 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $8 + 16 | 0;
 return $5;
}

function fcntlSizeHint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $10 = __stack_pointer - 112 | 0;
 __stack_pointer = $10;
 label$1: {
  label$2: {
   if (HEAP32[$0 + 40 >> 2] <= 0) {
    break label$2;
   }
   $3 = 1802;
   if (FUNCTION_TABLE[HEAP32[16252]](HEAP32[$0 + 12 >> 2], $10) | 0) {
    break label$1;
   }
   $8 = $0;
   $4 = HEAP32[$8 + 40 >> 2];
   $6 = $4 >> 31;
   $11 = $4;
   $9 = $6;
   $4 = $6;
   $6 = $2;
   $5 = $4 + $6 | 0;
   $8 = $1;
   $7 = $11;
   $3 = $8 + $7 | 0;
   $4 = $3 - 1 | 0;
   $5 = $3 >>> 0 < $7 >>> 0 ? $5 + 1 | 0 : $5;
   $3 = !$3;
   $3 = $5 - $3 | 0;
   $2 = $3;
   $6 = $9;
   $6 = __wasm_i64_srem($4, $3, $7, $6);
   $3 = i64toi32_i32$HIGH_BITS;
   $1 = $3;
   $7 = $6;
   $8 = $4 - $7 | 0;
   $15 = $8;
   $3 = $2;
   $6 = $1;
   $4 = $6 + ($4 >>> 0 < $7 >>> 0) | 0;
   $4 = $3 - $4 | 0;
   $14 = $4;
   $3 = $10;
   $4 = HEAP32[$3 + 40 >> 2];
   $1 = $4;
   $5 = HEAP32[$3 + 44 >> 2];
   $2 = $5;
   $4 = $5;
   $5 = $14;
   $7 = $1;
   $3 = $8;
   if (($4 | 0) >= ($5 | 0) & $7 >>> 0 >= $3 >>> 0 | ($5 | 0) < ($4 | 0)) {
    break label$2;
   }
   $7 = $10;
   $3 = HEAP32[$7 + 48 >> 2];
   $5 = $3 >> 31;
   $12 = $3;
   $9 = $5;
   $5 = $2;
   $3 = $9;
   $3 = __wasm_i64_srem($1, $5, $12, $3);
   $13 = $3 ^ -1;
   $5 = i64toi32_i32$HIGH_BITS;
   $3 = $5 ^ -1;
   $11 = $3;
   $7 = $9;
   $3 = $2;
   $8 = $7 + $3 | 0;
   $4 = $12;
   $5 = $1;
   $6 = $4 + $5 | 0;
   $1 = $6;
   $8 = $4 >>> 0 > $6 >>> 0 ? $8 + 1 | 0 : $8;
   $5 = $8;
   $8 = $11;
   $6 = $8 + $5 | 0;
   $4 = $1;
   $3 = $13;
   $7 = $4 + $3 | 0;
   $1 = $7;
   $6 = $4 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
   $2 = $6;
   $8 = $15;
   $5 = $8 - 1 | 0;
   $13 = $5;
   $6 = $14;
   $7 = !$8;
   $7 = $6 - $7 | 0;
   $16 = $7;
   $8 = $9;
   $5 = $8 + $7 | 0;
   $4 = $12;
   $6 = $13;
   $3 = $4 + $6 | 0;
   $17 = $3;
   $5 = $3 >>> 0 < $4 >>> 0 ? $5 + 1 | 0 : $5;
   $18 = $5;
   while (1) {
    $6 = $18;
    $5 = $2;
    $4 = $17;
    $7 = $1;
    if (($6 | 0) <= ($5 | 0) & $4 >>> 0 <= $7 >>> 0 | ($5 | 0) > ($6 | 0)) {
     break label$2;
    }
    $4 = $1;
    $6 = $15;
    $7 = $2;
    $5 = $14;
    $8 = $4 >>> 0 < $6 >>> 0 & ($7 | 0) <= ($5 | 0) | ($7 | 0) < ($5 | 0);
    $5 = $8 ? $4 : $13;
    $11 = $5;
    $4 = $7;
    $7 = $16;
    $6 = $8 ? $4 : $7;
    $5 = $9;
    $3 = $6 + $5 | 0;
    $4 = $12;
    $8 = $11;
    $7 = $4 + $8 | 0;
    $1 = $7;
    $3 = $4 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
    $2 = $3;
    $3 = $6;
    if ((seekAndWrite($0, $8, $3, 29623, 1) | 0) == 1) {
     continue;
    }
    break;
   }
   $3 = 778;
   break label$1;
  }
  $3 = 0;
 }
 __stack_pointer = $10 + 112 | 0;
 return $3;
}

function sqlite3VdbeMemSetStr($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 label$1: {
  label$2: {
   if (!$1) {
    sqlite3VdbeMemSetNull($0);
    break label$2;
   }
   $15 = HEAP32[$0 + 20 >> 2];
   if ($15) {
    $6 = $15;
    $7 = HEAP32[$6 + 120 >> 2];
    $11 = $7 >> 31;
   } else {
    $7 = 1e9;
    $11 = 0;
   }
   $14 = $7;
   $9 = $11;
   label$6: {
    label$7: {
     label$8: {
      $11 = $3;
      if (($11 | 0) < 0) {
       $12 = 1;
       if (($4 | 0) == 1) {
        break label$8;
       }
       while (1) {
        $13 = 514;
        $7 = $14;
        if (($9 | 0) <= ($8 | 0) & $10 >>> 0 > $7 >>> 0 | ($9 | 0) < ($8 | 0)) {
         break label$7;
        }
        if (!(HEAPU8[($10 | 1) + $1 | 0] | HEAPU8[$1 + $10 | 0])) {
         break label$7;
        }
        $7 = $10;
        $6 = $7 + 2 | 0;
        $2 = $6 >>> 0 < 2 ? $8 + 1 | 0 : $8;
        $10 = $6;
        $8 = $2;
        continue;
       }
      }
      $13 = $4 ? 2 : 16;
      $12 = $4 ? $4 : 1;
      $10 = $2;
      $2 = $3;
      $8 = $2;
      break label$6;
     }
     $10 = strlen($1);
     $13 = 514;
     break label$6;
    }
    $12 = $4;
   }
   $11 = $14;
   if (($9 | 0) <= ($8 | 0) & $10 >>> 0 > $11 >>> 0 | ($9 | 0) < ($8 | 0)) {
    label$12: {
     if ($5 + 1 >>> 0 < 2) {
      break label$12;
     }
     if (($5 | 0) == 1) {
      sqlite3DbFree($15, $1);
      break label$12;
     }
     FUNCTION_TABLE[$5 | 0]($1);
    }
    sqlite3VdbeMemSetNull($0);
    sqlite3ErrorToParser(HEAP32[$0 + 20 >> 2], 18);
    return 18;
   }
   label$14: {
    if (($5 | 0) == -1) {
     $6 = ($12 | 0) == 1;
     $7 = $6 ? 1 : 2;
     $4 = $7;
     $7 = 0;
     $2 = $3 >> 31;
     $7 = $7 & $2;
     $5 = 7;
     $6 = $3 >> 31;
     $2 = $4;
     $2 = $6 & $2;
     $11 = $2 + $10 | 0;
     $6 = $7 + $8 | 0;
     $14 = $11;
     $7 = $11;
     $6 = $7 >>> 0 < $10 >>> 0 ? $6 + 1 | 0 : $6;
     $9 = $6;
     $6 = $7 >>> 0 > 32 & ($9 | 0) >= 0 | ($9 | 0) > 0;
     if (sqlite3VdbeMemClearAndResize($0, $6 ? $11 : 32)) {
      break label$1;
     }
     __memcpy(HEAP32[$0 + 8 >> 2], $1, $14);
     break label$14;
    }
    sqlite3VdbeMemRelease($0);
    HEAP32[$0 + 8 >> 2] = $1;
    if (($5 | 0) == 1) {
     HEAP32[$0 + 32 >> 2] = $1;
     HEAP32[$0 + 24 >> 2] = sqlite3DbMallocSize(HEAP32[$0 + 20 >> 2], $1);
     break label$14;
    }
    HEAP32[$0 + 36 >> 2] = $5;
    $13 = ($5 ? 4096 : 8192) | $13;
   }
   HEAP8[$0 + 18 | 0] = $12;
   HEAP16[$0 + 16 >> 1] = $13;
   HEAP32[$0 + 12 >> 2] = $10 & 2147483647;
   if ($12 >>> 0 < 2) {
    break label$2;
   }
   $5 = 7;
   if (sqlite3VdbeMemHandleBom($0)) {
    break label$1;
   }
  }
  $5 = 0;
 }
 return $5;
}

function jsonMergePatch($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 label$1: {
  if (HEAPU8[$2 | 0] != 7) {
   break label$1;
  }
  label$2: {
   $11 = Math_imul($1, 12);
   $3 = $11 + HEAP32[$0 + 8 >> 2] | 0;
   if (HEAPU8[$3 | 0] == 7) {
    $12 = $1;
    $10 = 1;
    label$4: while (1) {
     if (HEAPU32[$2 + 4 >> 2] <= $10 >>> 0) {
      break label$2;
     }
     $6 = Math_imul($10, 12) + $2 | 0;
     $8 = HEAP32[$6 + 8 >> 2];
     $9 = HEAP32[$6 + 4 >> 2];
     $7 = HEAP32[$3 + 4 >> 2];
     $5 = 1;
     while (1) {
      label$6: {
       label$7: {
        if ($5 >>> 0 >= $7 >>> 0) {
         break label$7;
        }
        $4 = Math_imul($5, 12) + $3 | 0;
        if (HEAP32[$4 + 4 >> 2] != ($9 | 0)) {
         break label$6;
        }
        if (strncmp(HEAP32[$4 + 8 >> 2], $8, $9)) {
         break label$6;
        }
        $4 = $5 + 1 | 0;
        $7 = Math_imul($4, 12);
        $13 = $7 + $3 | 0;
        $14 = HEAPU8[$13 + 1 | 0];
        if ($14 & 20) {
         break label$7;
        }
        $6 = $6 + 12 | 0;
        if (!HEAPU8[$6 | 0]) {
         HEAP8[$13 + 1 | 0] = $14 | 4;
         break label$7;
        }
        $6 = jsonMergePatch($0, $1 + $4 | 0, $6);
        if (!$6) {
         $3 = 0;
         break label$2;
        }
        $3 = HEAP32[$0 + 8 >> 2] + $11 | 0;
        $4 = $7 + $3 | 0;
        if (($6 | 0) == ($4 | 0)) {
         break label$7;
        }
        HEAP32[$4 + 8 >> 2] = $6;
        HEAP8[$4 + 1 | 0] = HEAPU8[$4 + 1 | 0] | 16;
       }
       $4 = $10 + 1 | 0;
       label$10: {
        if (HEAPU32[$3 + 4 >> 2] > $5 >>> 0) {
         break label$10;
        }
        $7 = Math_imul($4, 12) + $2 | 0;
        if (!HEAPU8[$7 | 0]) {
         break label$10;
        }
        $3 = 0;
        $5 = jsonParseAddNode($0, 7, 2, 0);
        jsonParseAddNode($0, 5, $9, $8);
        $9 = jsonParseAddNode($0, 1, 0, 0);
        if (HEAPU8[$0 + 20 | 0]) {
         break label$2;
        }
        jsonRemoveAllNulls($2);
        $8 = HEAP32[$0 + 8 >> 2];
        $3 = $8 + Math_imul($12, 12) | 0;
        HEAP32[$3 + 8 >> 2] = $5 - $12;
        HEAP8[$3 + 1 | 0] = HEAPU8[$3 + 1 | 0] | 32;
        $3 = HEAP32[$0 + 8 >> 2] + Math_imul($9, 12) | 0;
        HEAP32[$3 + 8 >> 2] = $7;
        HEAP8[$3 + 1 | 0] = HEAPU8[$3 + 1 | 0] | 16;
        $3 = $8 + $11 | 0;
        $12 = $5;
       }
       $10 = jsonNodeSize(Math_imul($4, 12) + $2 | 0) + $4 | 0;
       continue label$4;
      }
      $5 = $5 + 1 | 0;
      $5 = $5 + jsonNodeSize(Math_imul($5, 12) + $3 | 0) | 0;
      continue;
     }
    }
   }
   jsonRemoveAllNulls($2);
   break label$1;
  }
  return $3;
 }
 return $2;
}

function unicodeAddExceptions($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $7 = $2 + $3 | 0;
 $5 = $2;
 while (1) {
  label$2: {
   if ($5 >>> 0 < $7 >>> 0) {
    $3 = $5 + 1 | 0;
    $4 = HEAPU8[$5 | 0];
    if ($4 >>> 0 < 192) {
     $5 = $3;
     break label$2;
    }
    $4 = HEAPU8[$4 + 32128 | 0];
    while (1) {
     label$6: {
      if (($3 | 0) == ($7 | 0)) {
       $3 = $7;
      } else {
       $5 = HEAPU8[$3 | 0];
       if (($5 & 192) == 128) {
        break label$6;
       }
      }
      $5 = $3;
      $4 = ($4 & -2) == 65534 ? 65533 : $4 >>> 0 < 128 ? 65533 : ($4 & -2048) == 55296 ? 65533 : $4;
      break label$2;
     }
     $4 = $5 & 63 | $4 << 6;
     $3 = $3 + 1 | 0;
     continue;
    }
   }
   label$9: {
    if (!$6) {
     break label$9;
    }
    $6 = sqlite3_realloc64(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2] + $6 << 2, 0);
    if (!$6) {
     return 7;
    }
    $8 = HEAP32[$0 + 8 >> 2];
    label$11: while (1) {
     label$12: {
      if ($2 >>> 0 < $7 >>> 0) {
       $3 = $2 + 1 | 0;
       $4 = HEAPU8[$2 | 0];
       if ($4 >>> 0 < 192) {
        $2 = $3;
        break label$12;
       }
       $4 = HEAPU8[$4 + 32128 | 0];
       while (1) {
        label$16: {
         if (($3 | 0) == ($7 | 0)) {
          $2 = $7;
         } else {
          $5 = HEAPU8[$3 | 0];
          if (($5 & 192) == 128) {
           break label$16;
          }
          $2 = $3;
         }
         $4 = ($4 & -2) == 65534 ? 65533 : $4 >>> 0 < 128 ? 65533 : ($4 & -2048) == 55296 ? 65533 : $4;
         break label$12;
        }
        $4 = $5 & 63 | $4 << 6;
        $3 = $3 + 1 | 0;
        continue;
       }
      }
      HEAP32[$0 + 8 >> 2] = $8;
      HEAP32[$0 + 12 >> 2] = $6;
      break label$9;
     }
     if ((sqlite3FtsUnicodeIsalnum($4) | 0) == ($1 | 0)) {
      continue;
     }
     if (sqlite3FtsUnicodeIsdiacritic($4)) {
      continue;
     }
     $3 = 0;
     $5 = ($8 | 0) > 0 ? $8 : 0;
     while (1) {
      label$20: {
       if (($3 | 0) != ($5 | 0)) {
        if (HEAP32[($3 << 2) + $6 >> 2] < ($4 | 0)) {
         break label$20;
        }
        $5 = $3;
       }
       $3 = $8;
       while (1) {
        if (($3 | 0) > ($5 | 0)) {
         $9 = ($3 << 2) + $6 | 0;
         $3 = $3 - 1 | 0;
         HEAP32[$9 >> 2] = HEAP32[($3 << 2) + $6 >> 2];
         continue;
        }
        break;
       }
       HEAP32[($5 << 2) + $6 >> 2] = $4;
       $8 = $8 + 1 | 0;
       continue label$11;
      }
      $3 = $3 + 1 | 0;
      continue;
     }
    }
   }
   return 0;
  }
  if ((sqlite3FtsUnicodeIsalnum($4) | 0) == ($1 | 0)) {
   continue;
  }
  $6 = !sqlite3FtsUnicodeIsdiacritic($4) + $6 | 0;
  continue;
 }
}

function codeAllEqualityTerms($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $11 = HEAP32[$1 + 80 >> 2];
 $5 = HEAP32[$11 + 32 >> 2];
 $6 = HEAPU16[$11 + 46 >> 1];
 $7 = HEAP32[$0 + 44 >> 2];
 $10 = HEAPU16[$11 + 24 >> 1];
 $13 = $10 + $3 | 0;
 HEAP32[$0 + 44 >> 2] = $7 + $13;
 $8 = $7 + 1 | 0;
 $9 = HEAP32[$0 + 8 >> 2];
 $3 = HEAP32[$0 >> 2];
 $12 = sqlite3DbStrDup($3, sqlite3IndexAffinityStr($3, $5));
 label$1: {
  if (!$6) {
   $6 = 0;
   break label$1;
  }
  $5 = HEAP32[$1 + 8 >> 2];
  $3 = 0;
  sqlite3VdbeAddOp3($9, 75, 0, $8, $6 + $7 | 0);
  sqlite3VdbeAddOp1($9, $2 ? 31 : 35, $5);
  $7 = sqlite3VdbeAddOp0($9, 8);
  HEAP32[$1 + 20 >> 2] = sqlite3VdbeAddOp4Int($9, $2 ? 20 : 23, $5, 0, $8, $6);
  sqlite3VdbeJumpHere($9, $7);
  while (1) {
   if (($3 | 0) == ($6 | 0)) {
    break label$1;
   }
   sqlite3VdbeAddOp3($9, 94, $5, $3, $3 + $8 | 0);
   $3 = $3 + 1 | 0;
   continue;
  }
 }
 $10 = $6 >>> 0 > $10 >>> 0 ? $6 : $10;
 $3 = $6;
 while (1) {
  if (($3 | 0) == ($10 | 0)) {
   while (1) {
    if (($6 | 0) != ($10 | 0)) {
     $3 = HEAP32[HEAP32[$11 + 52 >> 2] + ($6 << 2) >> 2];
     $5 = HEAPU16[$3 + 12 >> 1];
     label$8: {
      label$9: {
       if ($5 & 1) {
        if (!(HEAPU8[HEAP32[$3 >> 2] + 5 | 0] & 16) | !$12) {
         break label$8;
        }
        $3 = $6 + $12 | 0;
        break label$9;
       }
       if ($5 & 256) {
        break label$8;
       }
       $5 = HEAP32[HEAP32[$3 >> 2] + 16 >> 2];
       label$11: {
        if (HEAPU8[$3 + 11 | 0] & 8) {
         break label$11;
        }
        if (!sqlite3ExprCanBeNull($5)) {
         break label$11;
        }
        sqlite3VdbeAddOp2($9, 50, $6 + $8 | 0, HEAP32[$1 + 12 >> 2]);
       }
       if (HEAP32[$0 + 36 >> 2]) {
        break label$8;
       }
       $3 = $6 + $12 | 0;
       label$12: {
        if ((sqlite3CompareAffinity($5, HEAP8[$3 | 0]) | 0) != 65) {
         $7 = HEAPU8[$3 | 0];
         break label$12;
        }
        HEAP8[$3 | 0] = 65;
        $7 = 65;
       }
       if (!sqlite3ExprNeedsNoAffinityChange($5, $7 << 24 >> 24)) {
        break label$8;
       }
      }
      HEAP8[$3 | 0] = 65;
     }
     $6 = $6 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$4 >> 2] = $12;
  } else {
   $5 = $3 + $8 | 0;
   $7 = codeEqualityTerm($0, HEAP32[HEAP32[$11 + 52 >> 2] + ($3 << 2) >> 2], $1, $3, $2, $5);
   label$15: {
    if (($5 | 0) == ($7 | 0)) {
     break label$15;
    }
    if (($13 | 0) == 1) {
     sqlite3ReleaseTempReg($0, $8);
     $8 = $7;
     break label$15;
    }
    sqlite3VdbeAddOp2($9, 80, $7, $5);
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 return $8;
}

function fts3TruncateSegment($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 56 >> 2] = 0;
 HEAP32[$6 + 48 >> 2] = 0;
 HEAP32[$6 + 52 >> 2] = 0;
 HEAP32[$6 + 40 >> 2] = 0;
 HEAP32[$6 + 32 >> 2] = 0;
 HEAP32[$6 + 36 >> 2] = 0;
 HEAP32[$6 + 24 >> 2] = 0;
 HEAP32[$6 + 28 >> 2] = 0;
 HEAP32[$6 + 20 >> 2] = 0;
 $7 = fts3SqlStmt($0, 32, $6 + 20 | 0, 0);
 if (!$7) {
  $7 = HEAP32[$6 + 20 >> 2];
  $8 = $2;
  sqlite3_bind_int64($7, 1, $1, $8);
  sqlite3_bind_int($7, 2, $3);
  if ((sqlite3_step($7) | 0) == 100) {
   $9 = sqlite3_column_blob($7, 4);
   $12 = sqlite3_column_bytes($7, 4);
   $8 = sqlite3_column_int64($7, 1);
   $13 = $8;
   $14 = i64toi32_i32$HIGH_BITS;
   $9 = fts3TruncateNode($9, $12, $6 + 48 | 0, $4, $5, $6 + 24 | 0);
  }
  $7 = (wasm2js_i32$0 = $9, wasm2js_i32$1 = sqlite3_reset($7), wasm2js_i32$2 = $9, 
  wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
 }
 while (1) {
  label$4: {
   if ($7) {
    break label$4;
   }
   $8 = HEAP32[$6 + 28 >> 2];
   $9 = HEAP32[$6 + 24 >> 2];
   if (!($8 | $9)) {
    break label$4;
   }
   HEAP32[$6 + 16 >> 2] = 0;
   HEAP32[$6 + 12 >> 2] = 0;
   $7 = sqlite3Fts3ReadBlock($0, $9, $8, $6 + 16 | 0, $6 + 12 | 0);
   label$5: {
    if ($7) {
     break label$5;
    }
    $7 = fts3TruncateNode(HEAP32[$6 + 16 >> 2], HEAP32[$6 + 12 >> 2], $6 + 32 | 0, $4, $5, $6 + 24 | 0);
    if ($7) {
     break label$5;
    }
    $7 = fts3WriteSegment($0, $9, $8, HEAP32[$6 + 32 >> 2], HEAP32[$6 + 36 >> 2]);
   }
   sqlite3_free(HEAP32[$6 + 16 >> 2]);
   $10 = $9;
   $11 = $8;
   continue;
  }
  break;
 }
 $8 = $11;
 label$6: {
  if (!($8 | $10) | $7) {
   break label$6;
  }
  HEAP32[$6 + 16 >> 2] = 0;
  $7 = fts3SqlStmt($0, 17, $6 + 16 | 0, 0);
  if ($7) {
   break label$6;
  }
  $7 = HEAP32[$6 + 16 >> 2];
  $8 = $14;
  sqlite3_bind_int64($7, 1, $13, $8);
  $8 = $11;
  sqlite3_bind_int64($7, 2, $10 - 1 | 0, $8 - !$10 | 0);
  sqlite3_step($7);
  $7 = sqlite3_reset($7);
 }
 label$7: {
  if ($7) {
   break label$7;
  }
  HEAP32[$6 + 16 >> 2] = 0;
  $7 = fts3SqlStmt($0, 33, $6 + 16 | 0, 0);
  if ($7) {
   break label$7;
  }
  $0 = HEAP32[$6 + 16 >> 2];
  sqlite3_bind_int64($0, 1, $10, $11);
  sqlite3_bind_blob($0, 2, HEAP32[$6 + 48 >> 2], HEAP32[$6 + 52 >> 2], 0);
  sqlite3_bind_int64($0, 3, $1, $2);
  sqlite3_bind_int($0, 4, $3);
  sqlite3_step($0);
  $7 = sqlite3_reset($0);
  sqlite3_bind_null($0, 2);
 }
 sqlite3_free(HEAP32[$6 + 48 >> 2]);
 sqlite3_free(HEAP32[$6 + 32 >> 2]);
 __stack_pointer = $6 - -64 | 0;
 return $7;
}

function sqlite3WhereExplainOneScan($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = __stack_pointer - 224 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 + 116 >> 2];
 label$1: {
  if (HEAPU8[($5 ? $5 : $0) + 207 | 0] != 2) {
   break label$1;
  }
  $6 = HEAP32[$2 + 80 >> 2];
  $5 = HEAP32[$6 + 40 >> 2];
  if ($5 & 8192 | $3 & 32) {
   break label$1;
  }
  $9 = HEAPU8[$2 + 60 | 0];
  $8 = (($9 << 6) + $1 | 0) + 8 | 0;
  $11 = HEAP32[$0 >> 2];
  $10 = $5 & 48;
  $7 = 1;
  label$2: {
   if ($10) {
    break label$2;
   }
   if (!($5 & 1024)) {
    $7 = 1;
    if (HEAPU16[$6 + 24 >> 1]) {
     break label$2;
    }
   }
   $7 = ($3 & 3) != 0;
  }
  $2 = HEAP32[$0 + 8 >> 2];
  sqlite3StrAccumInit($4 + 200 | 0, $11, $4 + 96 | 0, 100, 1e9);
  HEAP32[$4 + 80 >> 2] = $7 ? 19701 : 19480;
  HEAP8[$4 + 221 | 0] = 1;
  HEAP32[$4 + 84 >> 2] = $8;
  sqlite3_str_appendf($4 + 200 | 0, 18739, $4 + 80 | 0);
  label$4: {
   if (!($5 & 1280)) {
    $8 = HEAP32[$6 + 32 >> 2];
    label$6: {
     if (!(((HEAPU8[$8 + 55 | 0] | HEAPU8[$8 + 56 | 0] << 8) & 3) == 2 ? HEAPU8[HEAP32[(($9 << 6) + $1 | 0) + 24 >> 2] + 28 | 0] & 128 : 0)) {
      $3 = 18122;
      if ($5 & 131072) {
       break label$6;
      }
      $3 = 18155;
      if ($5 & 16384) {
       break label$6;
      }
      $3 = $5 & 64 ? 6842 : 6851;
      break label$6;
     }
     $3 = 18056;
     if (!$7) {
      break label$4;
     }
    }
    sqlite3_str_append($4 + 200 | 0, 29438, 7);
    HEAP32[$4 >> 2] = HEAP32[$8 >> 2];
    sqlite3_str_appendf($4 + 200 | 0, $3, $4);
    explainIndexRange($4 + 200 | 0, $6);
    break label$4;
   }
   if (!(!($5 & 256) | !($5 & 15))) {
    HEAP32[$4 + 64 >> 2] = 14442;
    sqlite3_str_appendf($4 + 200 | 0, 6036, $4 - -64 | 0);
    $3 = 61;
    label$10: {
     if ($5 & 5) {
      break label$10;
     }
     if (($10 | 0) == 48) {
      HEAP32[$4 + 48 >> 2] = 14442;
      sqlite3_str_appendf($4 + 200 | 0, 6949, $4 + 48 | 0);
      $3 = 60;
      break label$10;
     }
     $3 = $5 & 32 ? 62 : 60;
    }
    HEAP32[$4 + 32 >> 2] = $3;
    sqlite3_str_appendf($4 + 200 | 0, 25515, $4 + 32 | 0);
    break label$4;
   }
   if (!($5 & 1024)) {
    break label$4;
   }
   $5 = HEAP32[$6 + 24 >> 2];
   HEAP32[$4 + 20 >> 2] = HEAP32[$6 + 32 >> 2];
   HEAP32[$4 + 16 >> 2] = $5;
   sqlite3_str_appendf($4 + 200 | 0, 5834, $4 + 16 | 0);
  }
  if (HEAPU8[(($9 << 6) + $1 | 0) + 44 | 0] & 8) {
   sqlite3_str_appendf($4 + 200 | 0, 19436, 0);
  }
  $5 = sqlite3StrAccumFinish($4 + 200 | 0);
  sqlite3VdbeAddOp4($2, 185, sqlite3VdbeCurrentAddr($2), HEAP32[$0 + 220 >> 2], 0, $5, -6);
 }
 __stack_pointer = $4 + 224 | 0;
}

function fts3EvalTestExpr($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = 1;
 label$1: {
  if (HEAP32[$2 >> 2]) {
   break label$1;
  }
  label$2: {
   switch (HEAP32[$1 >> 2] - 1 | 0) {
   case 0:
   case 2:
    label$6: {
     if (!fts3EvalTestExpr($0, HEAP32[$1 + 12 >> 2], $2)) {
      break label$6;
     }
     if (!fts3EvalTestExpr($0, HEAP32[$1 + 16 >> 2], $2)) {
      break label$6;
     }
     if (fts3EvalNearTest($1, $2)) {
      break label$1;
     }
    }
    $4 = 0;
    if (HEAP32[$1 >> 2] != 1) {
     break label$1;
    }
    $2 = HEAP32[$1 + 8 >> 2];
    if (HEAP32[$2 >> 2] == 1 ? $2 : 0) {
     break label$1;
    }
    while (1) {
     $2 = HEAP32[$1 + 20 >> 2];
     if (!$2) {
      $2 = HEAP32[$1 + 16 >> 2];
      $3 = HEAP32[$2 + 28 >> 2];
      $5 = $3;
      $3 = HEAP32[$0 + 32 >> 2];
      $6 = ($3 | 0) == HEAP32[$2 + 24 >> 2];
      $3 = HEAP32[$0 + 36 >> 2];
      if ($6 & ($3 | 0) == ($5 | 0)) {
       fts3EvalInvalidatePoslist(HEAP32[$2 + 20 >> 2]);
      }
      $1 = HEAP32[$1 + 12 >> 2];
      continue;
     }
     break;
    }
    ;
    $3 = HEAP32[$0 + 32 >> 2];
    if (($3 | 0) != HEAP32[$1 + 24 >> 2] | HEAP32[$0 + 36 >> 2] != HEAP32[$1 + 28 >> 2]) {
     break label$1;
    }
    fts3EvalInvalidatePoslist($2);
    return 0;

   case 3:
    return (fts3EvalTestExpr($0, HEAP32[$1 + 12 >> 2], $2) | fts3EvalTestExpr($0, HEAP32[$1 + 16 >> 2], $2)) != 0;

   case 1:
    if (!fts3EvalTestExpr($0, HEAP32[$1 + 12 >> 2], $2)) {
     return 0;
    }
    return !fts3EvalTestExpr($0, HEAP32[$1 + 16 >> 2], $2);

   default:
    break label$2;
   }
  }
  label$12: {
   label$13: {
    label$14: {
     if (!HEAP32[$0 + 28 >> 2]) {
      break label$14;
     }
     if (HEAPU8[$1 + 34 | 0]) {
      break label$13;
     }
     $3 = HEAP32[$1 + 24 >> 2];
     if (($3 | 0) != HEAP32[$0 + 32 >> 2] | HEAP32[$0 + 36 >> 2] != HEAP32[$1 + 28 >> 2]) {
      break label$14;
     }
     $4 = HEAP32[$1 + 20 >> 2];
     if (HEAP32[$4 + 28 >> 2]) {
      break label$12;
     }
    }
    $4 = 0;
    if (HEAPU8[$1 + 32 | 0]) {
     break label$1;
    }
    $3 = HEAP32[$1 + 24 >> 2];
    $2 = $3;
    $3 = HEAP32[$0 + 36 >> 2];
    $5 = $3;
    $3 = HEAP32[$1 + 28 >> 2];
    if (HEAP32[$0 + 32 >> 2] != ($2 | 0) | ($5 | 0) != ($3 | 0)) {
     break label$1;
    }
    return HEAP32[HEAP32[$1 + 20 >> 2] + 32 >> 2] > 0;
   }
   $4 = HEAP32[$1 + 20 >> 2];
   fts3EvalInvalidatePoslist($4);
  }
  HEAP32[$2 >> 2] = fts3EvalDeferredPhrase($0, $4);
  $2 = HEAP32[$4 + 28 >> 2];
  $3 = HEAP32[$0 + 36 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 32 >> 2];
  HEAP32[$1 + 28 >> 2] = $3;
  $4 = ($2 | 0) != 0;
 }
 return $4;
}

function updateAccumulator($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $9 = HEAP32[$0 + 8 >> 2];
 HEAP8[$2 | 0] = 1;
 $7 = HEAP32[$2 + 40 >> 2];
 while (1) {
  if (HEAP32[$2 + 44 >> 2] > ($13 | 0)) {
   $4 = HEAP32[$7 >> 2];
   $5 = HEAP32[$4 + 20 >> 2];
   $11 = 0;
   label$3: {
    if (!(HEAP8[$4 + 7 | 0] & 1)) {
     $10 = 0;
     break label$3;
    }
    $4 = HEAP32[HEAP32[$4 + 44 >> 2] + 40 >> 2];
    if (!(!(HEAP32[HEAP32[$7 + 4 >> 2] + 4 >> 2] & 32) | (!HEAP32[$2 + 36 >> 2] | !$1))) {
     if (!$6) {
      $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
      HEAP32[$0 + 44 >> 2] = $6;
     }
     sqlite3VdbeAddOp2($9, 80, $1, $6);
    }
    $10 = sqlite3VdbeMakeLabel($0);
    sqlite3ExprIfFalse($0, $4, $10, 16);
   }
   label$7: {
    if (!$5) {
     $12 = 0;
     break label$7;
    }
    $12 = HEAP32[$5 >> 2];
    $11 = sqlite3GetTempRange($0, $12);
    sqlite3ExprCodeExprList($0, $5, $11, 0, 1);
    $4 = HEAP32[$7 + 12 >> 2];
    if (($4 | 0) < 0) {
     break label$7;
    }
    if (!$10) {
     $10 = sqlite3VdbeMakeLabel($0);
     $4 = HEAP32[$7 + 12 >> 2];
    }
    HEAP32[$7 + 12 >> 2] = codeDistinct($0, $3, $4, $10, $5, $11);
   }
   if (HEAPU8[HEAP32[$7 + 4 >> 2] + 4 | 0] & 32) {
    $4 = $5 + 8 | 0;
    $8 = 0;
    $5 = 0;
    while (1) {
     if (!(($5 | 0) >= ($12 | 0) | $8)) {
      $5 = $5 + 1 | 0;
      $8 = sqlite3ExprCollSeq($0, HEAP32[$4 >> 2]);
      $4 = $4 + 16 | 0;
      continue;
     }
     break;
    }
    $8 = $8 ? $8 : HEAP32[HEAP32[$0 >> 2] + 8 >> 2];
    label$14: {
     if ($6) {
      break label$14;
     }
     if (!HEAP32[$2 + 36 >> 2]) {
      $6 = 0;
      break label$14;
     }
     $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
     HEAP32[$0 + 44 >> 2] = $6;
    }
    sqlite3VdbeAddOp4($9, 85, $6, 0, 0, $8, -2);
   }
   sqlite3VdbeAddOp3($9, 162, 0, $11, HEAP32[$7 + 8 >> 2]);
   sqlite3VdbeAppendP4($9, HEAP32[$7 + 4 >> 2], -7);
   sqlite3VdbeChangeP5($9, $12 & 255);
   sqlite3ReleaseTempRange($0, $11, $12);
   if ($10) {
    sqlite3VdbeResolveLabel($9, $10);
   }
   $7 = $7 + 20 | 0;
   $13 = $13 + 1 | 0;
   continue;
  }
  break;
 }
 label$17: {
  if (!$6) {
   $8 = 0;
   if (!$1) {
    break label$17;
   }
   $6 = $1;
   if (!HEAP32[$2 + 36 >> 2]) {
    break label$17;
   }
  }
  $8 = sqlite3VdbeAddOp1($9, 15, $6);
 }
 $5 = HEAP32[$2 + 28 >> 2];
 $4 = 0;
 while (1) {
  if (($4 | 0) < HEAP32[$2 + 36 >> 2]) {
   sqlite3ExprCode($0, HEAP32[$5 + 4 >> 2], HEAP32[$5 + 12 >> 2]);
   $5 = $5 + 20 | 0;
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP8[$2 | 0] = 0;
 if ($8) {
  sqlite3VdbeJumpHereOrPopInst($9, $8);
 }
}

function selectWindowRewriteExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = HEAPU8[$1 | 0];
 $6 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   label$3: {
    $3 = HEAP32[$0 + 24 >> 2];
    if (HEAP32[$3 + 16 >> 2]) {
     if (($2 | 0) != 167) {
      break label$1;
     }
     $0 = 0;
     $4 = HEAP32[$3 + 4 >> 2];
     $5 = HEAP32[$4 >> 2];
     $2 = ($5 | 0) > 0 ? $5 : 0;
     while (1) {
      label$6: {
       if (($0 | 0) != ($2 | 0)) {
        if (HEAP32[$1 + 28 >> 2] != HEAP32[(($0 << 6) + $4 | 0) + 48 >> 2]) {
         break label$6;
        }
        $2 = $0;
       }
       $4 = 0;
       if (($2 | 0) == ($5 | 0)) {
        break label$1;
       }
       break label$3;
      }
      $0 = $0 + 1 | 0;
      continue;
     }
    }
    label$8: {
     switch ($2 - 167 | 0) {
     case 0:
     case 1:
      break label$3;

     case 5:
      break label$8;

     default:
      break label$2;
     }
    }
    if (!(HEAP8[$1 + 7 | 0] & 1)) {
     break label$2;
    }
    $2 = $3;
    while (1) {
     $0 = HEAP32[$2 >> 2];
     if (!$0) {
      break label$3;
     }
     $2 = $0 + 36 | 0;
     $4 = 1;
     if (HEAP32[$1 + 44 >> 2] != ($0 | 0)) {
      continue;
     }
     break;
    }
    break label$1;
   }
   $4 = 2;
   $0 = HEAP32[$6 >> 2];
   if (HEAPU8[$0 + 87 | 0]) {
    break label$1;
   }
   label$10: {
    label$11: {
     $2 = HEAP32[$3 + 8 >> 2];
     if ($2) {
      $0 = 0;
      while (1) {
       if (HEAP32[$2 >> 2] > ($0 | 0)) {
        if (!sqlite3ExprCompare(0, HEAP32[(($0 << 4) + $2 | 0) + 8 >> 2], $1, -1)) {
         break label$11;
        }
        $0 = $0 + 1 | 0;
        $2 = HEAP32[$3 + 8 >> 2];
        continue;
       }
       break;
      }
      $0 = HEAP32[$6 >> 2];
     }
     $0 = sqlite3ExprDup($0, $1, 0);
     if (!(!$0 | HEAPU8[$0 | 0] != 168)) {
      HEAP8[$0 | 0] = 172;
     }
     $2 = sqlite3ExprListAppend($6, HEAP32[$3 + 8 >> 2], $0);
     HEAP32[$3 + 8 >> 2] = $2;
     $0 = -1;
     $5 = 1;
     break label$10;
    }
    $2 = HEAP32[$3 + 8 >> 2];
    $5 = 0;
   }
   if ($2) {
    $2 = HEAP32[$1 + 4 >> 2];
    HEAP32[$1 + 4 >> 2] = $2 | 134217728;
    sqlite3ExprDelete(HEAP32[$6 >> 2], $1);
    $1 = memset($1, 0, 52);
    HEAP8[$1 | 0] = 167;
    $2 = $2 & 512;
    $0 = $5 ? HEAP32[HEAP32[$3 + 8 >> 2] >> 2] - 1 | 0 : $0;
    HEAP16[$1 + 32 >> 1] = $0;
    HEAP32[$1 + 28 >> 2] = HEAP32[HEAP32[$3 >> 2] + 48 >> 2];
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[$1 + 4 >> 2] = $2;
    HEAP32[$1 + 44 >> 2] = $0;
   }
   if (HEAPU8[HEAP32[$6 >> 2] + 87 | 0]) {
    break label$1;
   }
  }
  $4 = 0;
 }
 return $4 | 0;
}

function walTryBeginRead($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  if (($3 | 0) >= 6) {
   $4 = 15;
   if ($3 >>> 0 > 100) {
    break label$1;
   }
   $5 = $3 - 9 | 0;
   sqlite3OsSleep(HEAP32[$0 >> 2], $3 >>> 0 > 9 ? Math_imul(Math_imul($5, $5), 39) : 1);
  }
  label$3: {
   if ($2) {
    break label$3;
   }
   if (!HEAPU8[$0 + 50 | 0]) {
    $4 = walIndexReadHdr($0, $1);
    if (($4 | 0) == 5) {
     $4 = -1;
     if (!HEAP32[HEAP32[$0 + 32 >> 2] >> 2]) {
      break label$1;
     }
     $3 = walLockShared($0, 2);
     if (!$3) {
      walUnlockShared($0, 2);
      return -1;
     }
     $4 = ($3 | 0) == 5 ? 261 : $3;
    }
    if ($4) {
     break label$1;
    }
    if (!HEAPU8[$0 + 50 | 0]) {
     break label$3;
    }
   }
   return walBeginShmUnreliable($0, $1);
  }
  $5 = 0;
  $4 = 0;
  label$7: {
   $7 = walCkptInfo($0);
   if (HEAP32[$7 >> 2] != HEAP32[$0 + 68 >> 2] | $2) {
    break label$7;
   }
   $4 = walLockShared($0, 3);
   walShmBarrier($0);
   if (($4 | 0) == 5) {
    break label$7;
   }
   if ($4) {
    break label$1;
   }
   if (memcmp(walIndexHdr($0), $0 + 52 | 0, 48)) {
    walUnlockShared($0, 3);
    return -1;
   }
   HEAP16[$0 + 40 >> 1] = 0;
   return 0;
  }
  $8 = $7 + 4 | 0;
  $6 = HEAP32[$0 + 68 >> 2];
  $3 = 1;
  $2 = 0;
  while (1) {
   if (($3 | 0) != 5) {
    $1 = HEAP32[($3 << 2) + $8 >> 2];
    $9 = $1;
    $1 = $1 >>> 0 < $2 >>> 0 | $1 >>> 0 > $6 >>> 0;
    $2 = $1 ? $2 : $9;
    $5 = $1 ? $5 : $3;
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  label$11: {
   label$12: {
    if (HEAPU8[$0 + 46 | 0] & 2) {
     break label$12;
    }
    $3 = 1;
    if ($5 ? $2 >>> 0 >= $6 >>> 0 : 0) {
     break label$11;
    }
    while (1) {
     if (($3 | 0) == 5) {
      break label$12;
     }
     $1 = $3 + 3 | 0;
     $4 = walLockExclusive($0, $1, 1);
     if (($4 | 0) != 5) {
      if ($4) {
       break label$1;
      }
      HEAP32[($3 << 2) + $8 >> 2] = $6;
      walUnlockExclusive($0, $1, 1);
      $2 = $6;
      $5 = $3;
      break label$11;
     } else {
      $3 = $3 + 1 | 0;
      $4 = 5;
      continue;
     }
    }
   }
   if ($5) {
    break label$11;
   }
   return ($4 | 0) == 5 ? -1 : 1288;
  }
  $1 = $5 + 3 | 0;
  $3 = walLockShared($0, $1);
  if ($3) {
   return ($3 | 0) == 5 ? -1 : $3;
  }
  HEAP32[$0 + 100 >> 2] = HEAP32[$7 >> 2] + 1;
  walShmBarrier($0);
  label$17: {
   if (HEAP32[($5 << 2) + $8 >> 2] == ($2 | 0)) {
    if (!memcmp(walIndexHdr($0), $0 + 52 | 0, 48)) {
     break label$17;
    }
   }
   walUnlockShared($0, $1);
   return -1;
  }
  HEAP16[$0 + 40 >> 1] = $5;
  $4 = 0;
 }
 return $4;
}

function whereLoopAddAll($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $1 = HEAP32[$0 >> 2];
 $15 = HEAP32[HEAP32[$1 >> 2] >> 2];
 $6 = HEAP32[$1 + 4 >> 2];
 $9 = HEAPU8[$1 + 48 | 0];
 $2 = HEAP32[$0 + 8 >> 2];
 whereLoopInit($2);
 HEAP32[$0 + 20 >> 2] = 2e4;
 $3 = $6 + 8 | 0;
 $9 = $3 + ($9 << 6) | 0;
 $16 = $1 + 504 | 0;
 label$1: {
  while (1) {
   label$3: {
    if ($3 >>> 0 >= $9 >>> 0) {
     break label$3;
    }
    HEAP8[$2 + 16 | 0] = $17;
    HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 1e3;
    HEAP32[$2 + 8 >> 2] = sqlite3WhereGetMask($16, HEAP32[$3 + 40 >> 2]);
    HEAP32[$2 + 12 >> 2] = i64toi32_i32$HIGH_BITS;
    $1 = HEAPU8[$3 + 36 | 0];
    label$4: {
     if ($1 & 98 ? 1 : $18) {
      $4 = $4 | $10;
      $18 = $1 >>> 4 & 1;
      $1 = $1 & 64 ? 1 : $11;
      $5 = $5 | $12;
      break label$4;
     }
     $4 = $11 ? $4 : 0;
     $18 = 0;
     $1 = ($11 | 0) != 0;
     $5 = $11 ? $5 : 0;
    }
    $11 = $1;
    $13 = 0;
    $14 = 0;
    $6 = $3;
    label$6: {
     label$7: {
      label$9: {
       if (HEAPU8[HEAP32[$3 + 16 >> 2] + 43 | 0] == 1) {
        while (1) {
         label$12: {
          $7 = $13;
          $8 = $14;
          $1 = $6;
          $6 = $1 - -64 | 0;
          if ($9 >>> 0 <= $6 >>> 0) {
           break label$12;
          }
          if (!($7 | $8)) {
           $13 = 0;
           $14 = 0;
           if (!(HEAPU8[$1 + 100 | 0] & 34)) {
            continue;
           }
          }
          $13 = sqlite3WhereGetMask($16, HEAP32[$1 + 104 >> 2]) | $7;
          $14 = i64toi32_i32$HIGH_BITS | $8;
          continue;
         }
         break;
        }
        $1 = whereLoopAddVirtual($0, $5, $4, $7, $8);
        break label$9;
       }
       $7 = 0;
       $8 = 0;
       $1 = whereLoopAddBtree($0, $5, $4);
      }
      label$8: {
       if (!$1) {
        if (!HEAPU8[HEAP32[$0 + 4 >> 2] + 9 | 0]) {
         $12 = HEAP32[$2 + 8 >> 2] | $12;
         $10 = $10 | HEAP32[$2 + 12 >> 2];
         break label$8;
        }
        $1 = whereLoopAddOr($0, $5, $4, $7, $8);
       }
       $12 = HEAP32[$2 + 8 >> 2] | $12;
       $10 = HEAP32[$2 + 12 >> 2] | $10;
       if (($1 | 0) == 101) {
        break label$7;
       }
       if ($1) {
        break label$1;
       }
      }
      if (HEAPU8[$15 + 87 | 0]) {
       break label$3;
      }
      break label$6;
     }
     sqlite3_log(28, 11777, 0);
    }
    $3 = $3 - -64 | 0;
    $17 = $17 + 1 | 0;
    continue;
   }
   break;
  }
  $1 = 0;
 }
 whereLoopClear($15, $2);
 return $1;
}

function btreeParseCellPtr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = HEAP8[$1 | 0];
 $11 = $4 & 255;
 label$1: {
  if (($4 | 0) >= 0) {
   $7 = $1;
   break label$1;
  }
  $11 = $11 & 127;
  $4 = 0;
  while (1) {
   $3 = $4 + 1 | 0;
   $7 = $3 + $1 | 0;
   $5 = HEAP8[$7 | 0];
   $11 = $5 & 127 | $11 << 7;
   if (($5 | 0) >= 0) {
    break label$1;
   }
   $5 = $4 >>> 0 < 7;
   $4 = $3;
   if ($5) {
    continue;
   }
   break;
  }
 }
 $4 = HEAP8[$7 + 1 | 0];
 $8 = $4 & 255;
 $10 = $7 + 1 | 0;
 $3 = 0;
 label$4: {
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $3 = $8;
  $6 = $3 << 7;
  $3 = 0;
  $4 = HEAP8[$7 + 2 | 0];
  $5 = $4 & 127;
  $8 = $6 & 16256 | $5;
  $10 = $7 + 2 | 0;
  $9 = $3;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $3 = $8;
  $6 = $9;
  $5 = $6 << 7 | $3 >>> 25;
  $4 = HEAP8[$7 + 3 | 0];
  $6 = $4 & 127;
  $8 = $3 << 7 | $6;
  $10 = $7 + 3 | 0;
  $3 = $5;
  $9 = $3;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $5 = $8;
  $3 = $9;
  $6 = $3 << 7 | $5 >>> 25;
  $4 = HEAP8[$7 + 4 | 0];
  $3 = $4 & 127;
  $8 = $5 << 7 | $3;
  $10 = $7 + 4 | 0;
  $5 = $6;
  $9 = $5;
  $3 = $5;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $6 = $8;
  $5 = $9;
  $3 = $5 << 7 | $6 >>> 25;
  $4 = HEAP8[$7 + 5 | 0];
  $5 = $4 & 127;
  $8 = $6 << 7 | $5;
  $10 = $7 + 5 | 0;
  $6 = $3;
  $9 = $6;
  $3 = $6;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $3 = $8;
  $6 = $9;
  $5 = $6 << 7 | $3 >>> 25;
  $4 = HEAP8[$7 + 6 | 0];
  $6 = $4 & 127;
  $8 = $3 << 7 | $6;
  $10 = $7 + 6 | 0;
  $3 = $5;
  $9 = $3;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $5 = $8;
  $3 = $9;
  $6 = $3 << 7 | $5 >>> 25;
  $4 = HEAP8[$7 + 7 | 0];
  $3 = $4 & 127;
  $8 = $5 << 7 | $3;
  $10 = $7 + 7 | 0;
  $5 = $6;
  $9 = $5;
  $3 = $5;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $6 = $8;
  $5 = $9;
  $3 = $5 << 7 | $6 >>> 25;
  $4 = HEAP8[$7 + 8 | 0];
  $5 = $4 & 127;
  $8 = $6 << 7 | $5;
  $10 = $7 + 8 | 0;
  $6 = $3;
  $9 = $6;
  $3 = $6;
  if (($4 | 0) >= 0) {
   break label$4;
  }
  $3 = $7;
  $6 = HEAPU8[$3 + 9 | 0];
  $4 = $6;
  $3 = $8;
  $5 = $9;
  $6 = $5 << 8 | $3 >>> 24;
  $5 = $4;
  $8 = $3 << 8 | $5;
  $10 = $7 + 9 | 0;
  $3 = $6;
 }
 HEAP32[$2 + 12 >> 2] = $11;
 $5 = $2;
 HEAP32[$5 >> 2] = $8;
 HEAP32[$5 + 4 >> 2] = $3;
 $4 = $10;
 $4 = $4 + 1 | 0;
 HEAP32[$5 + 8 >> 2] = $4;
 if (HEAPU16[$0 + 14 >> 1] >= $11 >>> 0) {
  HEAP16[$2 + 16 >> 1] = $11;
  $4 = ($4 - $1 | 0) + $11 | 0;
  HEAP16[$2 + 18 >> 1] = $4 & 65532 ? $4 : 4;
  return;
 }
 btreeParseCellAdjustSizeForOverflow($0, $1, $2);
}

function isAuxiliaryVtabOperator($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  label$2: {
   $5 = HEAPU8[$1 | 0];
   if ($5 - 51 >>> 0 < 2) {
    break label$2;
   }
   label$3: {
    switch ($5 - 171 | 0) {
    case 0:
     break label$2;

    case 1:
     break label$3;

    default:
     break label$1;
    }
   }
   $7 = HEAP32[$1 + 20 >> 2];
   if (!$7 | HEAP32[$7 >> 2] != 2) {
    break label$1;
   }
   label$4: {
    $10 = HEAP32[$7 + 24 >> 2];
    if (HEAPU8[$10 | 0] != 167) {
     break label$4;
    }
    $5 = HEAP32[$10 + 44 >> 2];
    if (!$5 | HEAPU8[$5 + 43 | 0] != 1) {
     break label$4;
    }
    $6 = HEAP32[$1 + 8 >> 2];
    $5 = 0;
    while (1) {
     if (($5 | 0) == 4) {
      break label$4;
     }
     if (sqlite3StrICmp($6, HEAP32[($5 << 3) + 48992 >> 2])) {
      $5 = $5 + 1 | 0;
      continue;
     } else {
      HEAP8[$2 | 0] = HEAPU8[($5 << 3) + 48996 | 0];
      HEAP32[$4 >> 2] = HEAP32[$7 + 8 >> 2];
      HEAP32[$3 >> 2] = $10;
      $8 = 1;
      break label$1;
     }
    }
   }
   $5 = HEAP32[$7 + 8 >> 2];
   if (HEAPU8[$5 | 0] != 167) {
    break label$1;
   }
   $6 = HEAP32[$5 + 44 >> 2];
   if (!$6 | HEAPU8[$6 + 43 | 0] != 1) {
    break label$1;
   }
   $0 = HEAP32[sqlite3GetVTable($0, $6) + 8 >> 2];
   $6 = HEAP32[HEAP32[$0 >> 2] + 72 >> 2];
   if (!$6) {
    break label$1;
   }
   $1 = FUNCTION_TABLE[$6 | 0]($0, 2, HEAP32[$1 + 8 >> 2], $9 + 12 | 0, $9 + 8 | 0) | 0;
   if (($1 | 0) < 150) {
    break label$1;
   }
   HEAP8[$2 | 0] = $1;
   HEAP32[$4 >> 2] = HEAP32[$7 + 24 >> 2];
   HEAP32[$3 >> 2] = $5;
   $8 = 1;
   break label$1;
  }
  $7 = HEAP32[$1 + 16 >> 2];
  $0 = HEAP32[$1 + 12 >> 2];
  $8 = 0;
  label$8: {
   if (HEAPU8[$0 | 0] != 167) {
    break label$8;
   }
   $6 = HEAP32[$0 + 44 >> 2];
   $8 = 0;
   if (!$6) {
    break label$8;
   }
   $8 = HEAPU8[$6 + 43 | 0] == 1;
  }
  label$9: {
   if (!$7) {
    $6 = $0;
    $0 = 0;
    break label$9;
   }
   label$11: {
    if (HEAPU8[$7 | 0] != 167) {
     break label$11;
    }
    $6 = HEAP32[$7 + 44 >> 2];
    if (!$6 | HEAPU8[$6 + 43 | 0] != 1) {
     break label$11;
    }
    $8 = $8 + 1 | 0;
    $6 = $7;
    break label$9;
   }
   $6 = $0;
   $0 = $7;
  }
  HEAP32[$3 >> 2] = $6;
  HEAP32[$4 >> 2] = $0;
  if (($5 | 0) == 52) {
   HEAP8[$2 | 0] = 68;
   $5 = HEAPU8[$1 | 0];
  }
  if (($5 & 255) == 171) {
   HEAP8[$2 | 0] = 69;
   $5 = HEAPU8[$1 | 0];
  }
  if (($5 & 255) != 51) {
   break label$1;
  }
  HEAP8[$2 | 0] = 70;
 }
 __stack_pointer = $9 + 16 | 0;
 return $8;
}

function fts3SnippetShift($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $10 = __stack_pointer - 32 | 0;
 __stack_pointer = $10;
 $12 = $6;
 $13 = HEAP32[$12 >> 2];
 $18 = $13;
 $7 = HEAP32[$12 + 4 >> 2];
 $19 = $7;
 label$1: {
  if (!($7 | $13)) {
   break label$1;
  }
  while (1) {
   $7 = $16;
   $20 = $7;
   $8 = $7;
   $12 = $17;
   $11 = $12 + 1 | 0;
   $8 = $11 ? $8 : $8 + 1 | 0;
   $17 = $11;
   $16 = $8;
   $8 = $19;
   $7 = $18;
   $15 = $12;
   $13 = $15 & 31;
   if (($15 & 63) >>> 0 >= 32) {
    $8 = $8 >>> $13 | 0;
   } else {
    $8 = ((1 << $13) - 1 & $8) << 32 - $13 | $7 >>> $13;
   }
   $7 = 0;
   if (!($7 | $8 & 1)) {
    continue;
   }
   break;
  }
  $17 = 0;
  $16 = 0;
  while (1) {
   $7 = $16;
   $9 = $17;
   $13 = $9 + 1 | 0;
   $11 = $13 ? $7 : $7 + 1 | 0;
   $17 = $13;
   $16 = $11;
   $11 = $19;
   $7 = $18;
   $15 = ($9 ^ -1) + $2 | 0;
   $8 = $15 & 31;
   if (($15 & 63) >>> 0 >= 32) {
    $11 = $11 >>> $8 | 0;
   } else {
    $11 = ((1 << $8) - 1 & $11) << 32 - $8 | $7 >>> $8;
   }
   $7 = 0;
   if (!($7 | $11 & 1)) {
    continue;
   }
   break;
  }
  $9 = $12 - $9 | 0;
  if (($9 | 0) < 2) {
   break label$1;
  }
  $7 = ($9 | 0) / 2 | 0;
  HEAP32[$10 + 28 >> 2] = 0;
  $9 = HEAP32[$0 + 36 >> 2];
  $0 = HEAP32[$9 >> 2];
  $14 = sqlite3Fts3OpenTokenizer($9, $1, $3, $4, $10 + 24 | 0);
  if ($14) {
   break label$1;
  }
  $4 = $2 + $7 | 0;
  $14 = HEAP32[$10 + 24 >> 2];
  $9 = 0;
  label$4: {
   while (1) {
    if (!$9) {
     if (HEAP32[$10 + 28 >> 2] >= ($4 | 0)) {
      FUNCTION_TABLE[HEAP32[$0 + 16 >> 2]]($14) | 0;
      break label$4;
     } else {
      HEAP32[$10 + 16 >> 2] = 0;
      HEAP32[$10 + 12 >> 2] = 0;
      HEAP32[$10 + 8 >> 2] = 0;
      $9 = FUNCTION_TABLE[HEAP32[$0 + 20 >> 2]]($14, $10 + 20 | 0, $10 + 16 | 0, $10 + 12 | 0, $10 + 8 | 0, $10 + 28 | 0) | 0;
      continue;
     }
    }
    break;
   }
   FUNCTION_TABLE[HEAP32[$0 + 16 >> 2]]($14) | 0;
   if (($9 | 0) == 101) {
    break label$4;
   }
   $14 = $9;
   break label$1;
  }
  $14 = 0;
  $9 = HEAP32[$10 + 28 >> 2] + ((($9 | 0) != 0) - $2 | 0) | 0;
  if (($9 | 0) <= 0) {
   break label$1;
  }
  HEAP32[$5 >> 2] = HEAP32[$5 >> 2] + $9;
  $7 = $19;
  $12 = $18;
  $11 = 0;
  $8 = $9 & 31;
  if (($9 & 63) >>> 0 >= 32) {
   $0 = $7 >>> $8 | 0;
  } else {
   $11 = $7 >>> $8 | 0;
   $0 = ((1 << $8) - 1 & $7) << 32 - $8 | $12 >>> $8;
  }
  $12 = $6;
  HEAP32[$12 >> 2] = $0;
  HEAP32[$12 + 4 >> 2] = $11;
 }
 __stack_pointer = $10 + 32 | 0;
 return $14;
}

function codeRowTrigger($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 320 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 + 116 >> 2];
 $8 = HEAP32[$0 >> 2];
 $6 = sqlite3DbMallocZero($8, 24, 0);
 label$1: {
  if (!$6) {
   break label$1;
  }
  $10 = $5 ? $5 : $0;
  HEAP32[$6 + 4 >> 2] = HEAP32[$10 + 124 >> 2];
  HEAP32[$10 + 124 >> 2] = $6;
  $5 = sqlite3DbMallocZero($8, 28, 0);
  HEAP32[$6 + 8 >> 2] = $5;
  if (!$5) {
   break label$1;
  }
  sqlite3VdbeLinkSubProgram(HEAP32[$10 + 8 >> 2], $5);
  HEAP32[$6 + 16 >> 2] = -1;
  HEAP32[$6 + 20 >> 2] = -1;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 >> 2] = $1;
  sqlite3ParseObjectInit($4 + 16 | 0, $8);
  HEAP32[$4 + 316 >> 2] = 0;
  HEAP32[$4 + 308 >> 2] = 0;
  HEAP32[$4 + 312 >> 2] = 0;
  HEAP32[$4 + 300 >> 2] = 0;
  HEAP32[$4 + 304 >> 2] = 0;
  HEAP32[$4 + 292 >> 2] = 0;
  HEAP32[$4 + 296 >> 2] = 0;
  HEAP32[$4 + 136 >> 2] = $2;
  HEAP32[$4 + 132 >> 2] = $10;
  HEAP32[$4 + 288 >> 2] = $4 + 16;
  HEAP32[$4 + 264 >> 2] = HEAP32[$1 >> 2];
  HEAP8[$4 + 164 | 0] = HEAPU8[$1 + 8 | 0];
  HEAP32[$4 + 152 >> 2] = HEAP32[$0 + 136 >> 2];
  HEAP8[$4 + 41 | 0] = HEAPU8[$0 + 25 | 0];
  $7 = sqlite3GetVdbe($4 + 16 | 0);
  label$2: {
   if ($7) {
    $2 = HEAP32[$1 >> 2];
    if ($2) {
     HEAP32[$4 >> 2] = $2;
     sqlite3VdbeChangeP4($7, -1, sqlite3MPrintf($8, 6921, $4), -6);
    }
    $9 = HEAP32[$1 + 12 >> 2];
    label$5: {
     if (!$9) {
      $2 = 0;
      break label$5;
     }
     $2 = 0;
     $9 = sqlite3ExprDup($8, $9, 0);
     label$7: {
      if (HEAPU8[$8 + 87 | 0]) {
       break label$7;
      }
      if (sqlite3ResolveExprNames($4 + 288 | 0, $9)) {
       break label$7;
      }
      $2 = sqlite3VdbeMakeLabel($4 + 16 | 0);
      sqlite3ExprIfFalse($4 + 16 | 0, $9, $2, 16);
     }
     sqlite3ExprDelete($8, $9);
    }
    codeTriggerProgram($4 + 16 | 0, HEAP32[$1 + 28 >> 2], $3);
    if ($2) {
     sqlite3VdbeResolveLabel($7, $2);
    }
    sqlite3VdbeAddOp0($7, 70);
    transferParseError($0, $4 + 16 | 0);
    if (!HEAP32[$0 + 36 >> 2]) {
     HEAP32[$5 >> 2] = sqlite3VdbeTakeOpArray($7, $5 + 4 | 0, $10 + 96 | 0);
    }
    HEAP32[$5 + 8 >> 2] = HEAP32[$4 + 60 >> 2];
    $0 = HEAP32[$4 + 56 >> 2];
    HEAP32[$5 + 20 >> 2] = $1;
    HEAP32[$5 + 12 >> 2] = $0;
    HEAP32[$6 + 16 >> 2] = HEAP32[$4 + 156 >> 2];
    HEAP32[$6 + 20 >> 2] = HEAP32[$4 + 160 >> 2];
    sqlite3VdbeDelete($7);
    break label$2;
   }
   transferParseError($0, $4 + 16 | 0);
  }
  sqlite3ParseObjectReset($4 + 16 | 0);
  $7 = $6;
 }
 __stack_pointer = $4 + 320 | 0;
 return $7;
}

function syncJournal($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 $2 = sqlite3PagerExclusiveLock($0);
 label$1: {
  if ($2) {
   break label$1;
  }
  label$2: {
   if (HEAPU8[$0 + 7 | 0]) {
    break label$2;
   }
   if (!(!HEAP32[HEAP32[$0 + 68 >> 2] >> 2] | HEAPU8[$0 + 5 | 0] == 4)) {
    $5 = sqlite3OsDeviceCharacteristics(HEAP32[$0 + 64 >> 2]);
    $7 = $5 & 512;
    label$4: {
     if ($7) {
      $5 = $5 & 1024;
      break label$4;
     }
     $4 = $6;
     HEAP32[$4 + 8 >> 2] = -117058087;
     HEAP32[$4 + 12 >> 2] = -681336544;
     sqlite3Put4byte($4 + 16 | 0, HEAP32[$0 + 48 >> 2]);
     $8 = HEAP32[$0 + 68 >> 2];
     $2 = $4 + 24 | 0;
     $3 = journalHdrOffset($0);
     $9 = $3;
     $4 = i64toi32_i32$HIGH_BITS;
     $10 = $4;
     $2 = sqlite3OsRead($8, $2, 8, $3, $4);
     label$6: {
      if (!$2) {
       $2 = $6;
       $4 = HEAPU8[$2 + 24 | 0] | HEAPU8[$2 + 25 | 0] << 8 | (HEAPU8[$2 + 26 | 0] << 16 | HEAPU8[$2 + 27 | 0] << 24);
       $3 = HEAPU8[$2 + 28 | 0] | HEAPU8[$2 + 29 | 0] << 8 | (HEAPU8[$2 + 30 | 0] << 16 | HEAPU8[$2 + 31 | 0] << 24);
       $2 = $4;
       if (($2 | 0) != -117058087 | ($3 | 0) != -681336544) {
        break label$6;
       }
       $2 = $10;
       $2 = sqlite3OsWrite(HEAP32[$0 + 68 >> 2], 32268, 1, $9, $2);
      }
      if (($2 | 0) == 522) {
       break label$6;
      }
      if ($2) {
       break label$1;
      }
     }
     $5 = $5 & 1024;
     if (!($5 | !HEAPU8[$0 + 8 | 0])) {
      $2 = sqlite3OsSync(HEAP32[$0 + 68 >> 2], HEAPU8[$0 + 10 | 0]);
      if ($2) {
       break label$1;
      }
     }
     $2 = HEAP32[$0 + 88 >> 2];
     $3 = HEAP32[$0 + 92 >> 2];
     $2 = sqlite3OsWrite(HEAP32[$0 + 68 >> 2], $6 + 8 | 0, 12, $2, $3);
     if ($2) {
      break label$1;
     }
    }
    if (!$5) {
     $2 = HEAPU8[$0 + 10 | 0];
     $2 = sqlite3OsSync(HEAP32[$0 + 68 >> 2], $2 | (($2 | 0) == 3) << 4);
     if ($2) {
      break label$1;
     }
    }
    $2 = HEAP32[$0 + 84 >> 2];
    $3 = HEAP32[$0 + 80 >> 2];
    HEAP32[$0 + 88 >> 2] = $3;
    HEAP32[$0 + 92 >> 2] = $2;
    if (!$1 | $7) {
     break label$2;
    }
    HEAP32[$0 + 48 >> 2] = 0;
    $2 = writeJournalHdr($0);
    if (!$2) {
     break label$2;
    }
    break label$1;
   }
   $3 = HEAP32[$0 + 84 >> 2];
   $2 = HEAP32[$0 + 80 >> 2];
   HEAP32[$0 + 88 >> 2] = $2;
   HEAP32[$0 + 92 >> 2] = $3;
  }
  sqlite3PcacheClearSyncFlags(HEAP32[$0 + 228 >> 2]);
  HEAP8[$0 + 17 | 0] = 4;
  $2 = 0;
 }
 __stack_pointer = $6 + 32 | 0;
 return $2;
}

function fts3EvalSelectDeferred($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $11 = HEAP32[$0 >> 2];
 HEAP32[$6 + 12 >> 2] = 0;
 label$1: {
  if (HEAP32[$11 + 40 >> 2]) {
   break label$1;
  }
  $13 = ($3 | 0) > 0 ? $3 : 0;
  $3 = 0;
  while (1) {
   if (($3 | 0) != ($13 | 0)) {
    $4 = Math_imul($3, 24) + $2 | 0;
    if (HEAP32[$4 + 12 >> 2] == ($1 | 0)) {
     $9 = HEAP32[$4 + 16 >> 2] + $9 | 0;
     $10 = $10 + 1 | 0;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = 0;
  if (!$9 | ($10 | 0) < 2) {
   break label$1;
  }
  $14 = $10 - 1 | 0;
  $4 = fts3EvalAverageDocsize($0, $6 + 12 | 0);
  $15 = HEAP32[$6 + 12 >> 2];
  $7 = 1;
  while (1) {
   if (($8 | 0) >= ($10 | 0)) {
    break label$1;
   }
   $3 = 0;
   $5 = 0;
   if ($4) {
    break label$1;
   }
   while (1) {
    if (($3 | 0) != ($13 | 0)) {
     $4 = Math_imul($3, 24);
     $9 = $4 + $2 | 0;
     label$8: {
      if (!HEAP32[$9 + 8 >> 2]) {
       break label$8;
      }
      $4 = $2 + $4 | 0;
      if (HEAP32[$4 + 12 >> 2] != ($1 | 0) | (HEAP32[$4 + 16 >> 2] >= HEAP32[$5 + 16 >> 2] ? $5 : 0)) {
       break label$8;
      }
      $5 = $9;
     }
     $3 = $3 + 1 | 0;
     continue;
    }
    break;
   }
   label$10: {
    label$11: {
     if (!$8) {
      $7 = $7 << 2;
      break label$11;
     }
     $3 = ($7 | 0) / 4 | 0;
     if (HEAP32[$5 + 16 >> 2] >= (Math_imul((($12 + $3 | 0) - 1 | 0) / ($3 | 0) | 0, $15) | 0)) {
      $3 = HEAP32[$5 + 8 >> 2];
      $4 = sqlite3Fts3DeferToken($0, $3, HEAP32[$5 + 20 >> 2]);
      fts3SegReaderCursorFree(HEAP32[$3 + 20 >> 2]);
      HEAP32[$3 + 20 >> 2] = 0;
      break label$10;
     }
     $7 = $8 >>> 0 < 12 ? $7 << 2 : $7;
     $4 = 0;
     if (($8 | 0) == ($14 | 0) | HEAP32[HEAP32[$5 >> 2] + 64 >> 2] < 2) {
      break label$10;
     }
    }
    $3 = HEAP32[$5 + 8 >> 2];
    HEAP32[$6 + 8 >> 2] = 0;
    HEAP32[$6 + 4 >> 2] = 0;
    $4 = fts3TermSelect($11, $3, HEAP32[$5 + 20 >> 2], $6 + 8 | 0, $6 + 4 | 0);
    if ($4) {
     break label$10;
    }
    $4 = fts3EvalPhraseMergeToken($11, HEAP32[$5 >> 2], HEAP32[$5 + 4 >> 2], HEAP32[$6 + 4 >> 2], HEAP32[$6 + 8 >> 2]);
    if ($4) {
     break label$10;
    }
    $3 = HEAP32[$5 >> 2];
    $3 = fts3DoclistCountDocids(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2]);
    $12 = $8 ? ($3 | 0) < ($12 | 0) ? $3 : $12 : $3;
    $4 = 0;
   }
   HEAP32[$5 + 8 >> 2] = 0;
   $8 = $8 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function pager_delsuper($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $7 = 7;
 $10 = HEAP32[$0 >> 2];
 $3 = HEAP32[$10 + 4 >> 2] << 1;
 $2 = $3 >> 31;
 $0 = sqlite3MallocZero($3, $2);
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = sqlite3OsOpen($10, $1, $0, 16385, 0);
  if ($2) {
   $7 = $2;
   break label$1;
  }
  $9 = HEAP32[$10 + 4 >> 2];
  $2 = sqlite3OsFileSize($0, $5 + 8 | 0);
  if ($2) {
   $7 = $2;
   break label$1;
  }
  $3 = HEAP32[$5 + 12 >> 2];
  $8 = $3;
  $2 = HEAP32[$5 + 8 >> 2];
  $4 = $2;
  $13 = HEAP32[$10 + 8 >> 2] + 1 | 0;
  $2 = $13;
  $3 = $2 >> 31;
  $4 = $4 + $2 | 0;
  $2 = $3;
  $3 = $8;
  $11 = $2 + $3 | 0;
  $11 = $4 >>> 0 < $13 >>> 0 ? $11 + 1 | 0 : $11;
  $3 = $4;
  $4 = $11;
  $2 = $3 + 6 | 0;
  $4 = $2 >>> 0 < 6 ? $4 + 1 | 0 : $4;
  $8 = sqlite3Malloc($2, $4);
  if (!$8) {
   break label$1;
  }
  HEAP8[$8 | 0] = 0;
  HEAP8[$8 + 1 | 0] = 0;
  HEAP8[$8 + 2 | 0] = 0;
  HEAP8[$8 + 3 | 0] = 0;
  label$5: {
   $12 = $8 + 4 | 0;
   $6 = HEAP32[$5 + 8 >> 2];
   $7 = sqlite3OsRead($0, $12, $6, 0, 0);
   label$6: {
    if ($7) {
     break label$6;
    }
    $2 = $0 + $9 | 0;
    $14 = ($6 + $12 | 0) + 2 | 0;
    HEAP8[HEAP32[$5 + 8 >> 2] + $12 | 0] = 0;
    HEAP8[(HEAP32[$5 + 8 >> 2] + $12 | 0) + 1 | 0] = 0;
    $6 = $12;
    while (1) {
     $4 = HEAP32[$5 + 8 >> 2];
     $11 = $4;
     $3 = HEAP32[$5 + 12 >> 2];
     $9 = $3;
     $4 = $6 - $12 | 0;
     $3 = $4 >> 31;
     $15 = $3;
     $7 = $4;
     $3 = $9;
     $4 = $15;
     if ($7 >>> 0 < $11 >>> 0 & ($3 | 0) >= ($4 | 0) | ($4 | 0) < ($3 | 0)) {
      $7 = sqlite3OsAccess($10, $6, 0, $5 + 4 | 0);
      if ($7) {
       break label$6;
      }
      label$9: {
       if (!HEAP32[$5 + 4 >> 2]) {
        break label$9;
       }
       $9 = sqlite3OsOpen($10, $6, $2, 16385, 0);
       if ($9) {
        break label$5;
       }
       $9 = readSuperJournal($2, $14, $13);
       sqlite3OsClose($2);
       if ($9) {
        break label$5;
       }
       if (!HEAPU8[$14 | 0]) {
        break label$9;
       }
       if (!strcmp($14, $1)) {
        break label$6;
       }
      }
      $6 = (sqlite3Strlen30($6) + $6 | 0) + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3OsClose($0);
    $7 = sqlite3OsDelete($10, $1, 0);
   }
   $6 = $8;
   break label$1;
  }
  $6 = $8;
  $7 = $9;
 }
 sqlite3_free($6);
 if ($0) {
  sqlite3OsClose($0);
  sqlite3_free($0);
 }
 __stack_pointer = $5 + 16 | 0;
 return $7;
}

function exprImpliesNotNull($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 while (1) {
  if (!sqlite3ExprCompare($0, $1, $2, $3)) {
   return HEAPU8[$2 | 0] != 121;
  }
  $6 = 0;
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      label$7: {
       label$8: {
        label$9: {
         label$10: {
          $5 = HEAPU8[$1 | 0];
          switch ($5 - 102 | 0) {
          case 11:
           break label$3;

          case 12:
           break label$4;

          case 10:
           break label$5;

          case 0:
          case 6:
          case 7:
          case 8:
           break label$8;

          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 9:
           break label$9;

          default:
           break label$10;
          }
         }
         label$11: {
          switch ($5 - 48 | 0) {
          default:
           switch ($5 - 173 | 0) {
           case 0:
           case 1:
           case 8:
            break label$3;

           case 3:
           case 4:
           case 5:
           case 6:
           case 7:
            break label$5;

           case 2:
            break label$7;

           default:
            break label$6;
           }
           ;

          case 1:
           if (!$4) {
            break label$4;
           }
           $4 = 1;
           if (HEAPU8[$1 + 5 | 0] & 16) {
            break label$5;
           }
           break label$3;

          case 0:
           break label$11;

          case 2:
          case 3:
           break label$5;

          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
           break label$9;
          }
         }
         if ($4) {
          break label$5;
         }
         $6 = 1;
         $5 = HEAP32[$1 + 20 >> 2];
         if (exprImpliesNotNull($0, HEAP32[$5 + 8 >> 2], $2, $3, 1)) {
          break label$5;
         }
         $4 = 1;
         if (!exprImpliesNotNull($0, HEAP32[$5 + 24 >> 2], $2, $3, 1)) {
          break label$3;
         }
         break label$5;
        }
        $4 = 1;
       }
       if (!exprImpliesNotNull($0, HEAP32[$1 + 16 >> 2], $2, $3, $4)) {
        break label$3;
       }
       return 1;
      }
      if ($4) {
       break label$5;
      }
      $4 = 1;
      if (HEAPU8[$1 + 2 | 0] == 45) {
       break label$3;
      }
      break label$5;
     }
     if (($5 | 0) == 19) {
      break label$4;
     }
    }
    return $6;
   }
   $4 = 1;
  }
  $1 = HEAP32[$1 + 12 >> 2];
  continue;
 }
}

function unixShmLock($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = 5130;
 $5 = HEAP32[$0 + 36 >> 2];
 label$1: {
  if (!$5) {
   break label$1;
  }
  $6 = HEAP32[$5 >> 2];
  if (!$6) {
   break label$1;
  }
  $4 = $1 + $2 | 0;
  $10 = 1 << $1;
  $7 = (1 << $4) - $10 | 0;
  $6 = $6 + 36 | 0;
  label$2: {
   if ($3 & 1) {
    $8 = HEAPU16[$5 + 10 >> 1];
    $9 = HEAPU16[$5 + 12 >> 1];
    if (!(($8 | $9) & $7)) {
     break label$2;
    }
    $11 = ($1 | 0) > ($4 | 0) ? $1 : $4;
    $4 = $1;
    $3 = 1;
    while (1) {
     if (($4 | 0) != ($11 | 0)) {
      $3 = HEAP32[($4 << 2) + $6 >> 2] > ($8 >>> $4 & 1) ? 0 : $3;
      $4 = $4 + 1 | 0;
      continue;
     }
     break;
    }
    label$6: {
     if ($3) {
      $4 = unixShmSystemLock($0, 2, $1 + 120 | 0, $2);
      if ($4) {
       break label$1;
      }
      memset(($1 << 2) + $6 | 0, 0, $2 << 2);
      $8 = HEAPU16[$5 + 10 >> 1];
      $9 = HEAPU16[$5 + 12 >> 1];
      break label$6;
     }
     if (!($8 & $10)) {
      break label$6;
     }
     $4 = ($1 << 2) + $6 | 0;
     HEAP32[$4 >> 2] = HEAP32[$4 >> 2] - 1;
    }
    $4 = $7 ^ -1;
    HEAP16[$5 + 10 >> 1] = $8 & $4;
    HEAP16[$5 + 12 >> 1] = $4 & $9;
    break label$2;
   }
   label$8: {
    label$9: {
     label$10: {
      if (!($3 & 4)) {
       $3 = ($1 | 0) > ($4 | 0) ? $1 : $4;
       $4 = $1;
       while (1) {
        if (($3 | 0) == ($4 | 0)) {
         break label$8;
        }
        if (!(HEAP32[($4 << 2) + $6 >> 2] ? HEAPU16[$5 + 12 >> 1] >>> $4 & 1 : 1)) {
         break label$10;
        }
        $4 = $4 + 1 | 0;
        continue;
       }
      }
      $4 = 0;
      $3 = HEAPU16[$5 + 10 >> 1];
      if ($7 & $3) {
       break label$1;
      }
      $6 = ($1 << 2) + $6 | 0;
      $4 = HEAP32[$6 >> 2];
      if (($4 | 0) >= 0) {
       break label$9;
      }
     }
     return 5;
    }
    if (!$4) {
     $4 = unixShmSystemLock($0, 0, $1 + 120 | 0, $2);
     if ($4) {
      break label$1;
     }
     $4 = HEAP32[$6 >> 2];
     $3 = HEAPU16[$5 + 10 >> 1];
    }
    HEAP16[$5 + 10 >> 1] = $3 | $7;
    HEAP32[$6 >> 2] = $4 + 1;
    break label$2;
   }
   $4 = unixShmSystemLock($0, 1, $1 + 120 | 0, $2);
   if ($4) {
    break label$1;
   }
   HEAP16[$5 + 12 >> 1] = HEAPU16[$5 + 12 >> 1] | $7;
   while (1) {
    if (($1 | 0) == ($3 | 0)) {
     break label$2;
    }
    HEAP32[($1 << 2) + $6 >> 2] = -1;
    $1 = $1 + 1 | 0;
    continue;
   }
  }
  $4 = 0;
 }
 return $4 | 0;
}

function sqlite3_table_column_metadata($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $10 = __stack_pointer - 32 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 28 >> 2] = 0;
 sqlite3BtreeEnterAll($0);
 $15 = sqlite3Init($0, $10 + 28 | 0);
 $13 = 0;
 label$1: {
  if ($15) {
   break label$1;
  }
  label$2: {
   $1 = sqlite3FindTable($0, $2, $1);
   if (!$1) {
    break label$2;
   }
   $13 = 0;
   if (HEAPU8[$1 + 43 | 0] == 2) {
    break label$1;
   }
   label$3: {
    label$4: {
     if (!$3) {
      break label$4;
     }
     $14 = HEAP16[$1 + 34 >> 1];
     $11 = ($14 | 0) > 0 ? $14 : 0;
     while (1) {
      label$7: {
       if (($9 | 0) != ($11 | 0)) {
        $12 = HEAP32[$1 + 4 >> 2] + Math_imul($9, 12) | 0;
        if (sqlite3StrICmp(HEAP32[$12 >> 2], $3)) {
         break label$7;
        }
        $11 = $9;
       }
       if (($11 | 0) == ($14 | 0)) {
        $11 = 0;
        $14 = 0;
        $9 = 0;
        $13 = 0;
        if (HEAPU8[$1 + 28 | 0] & 128) {
         break label$1;
        }
        if (!sqlite3IsRowid($3)) {
         break label$2;
        }
        $9 = HEAP16[$1 + 32 >> 1];
        if (($9 | 0) < 0) {
         break label$4;
        }
        $11 = $9 & 65535;
        $12 = HEAP32[$1 + 4 >> 2] + Math_imul($11, 12) | 0;
       }
       if (!$12) {
        break label$4;
       }
       $14 = sqlite3ColumnType($12, 0);
       $16 = sqlite3ColumnColl($12);
       $17 = HEAP16[$12 + 10 >> 1] & 1;
       $18 = (HEAPU8[$12 + 4 | 0] & 15) != 0;
       $9 = 0;
       if (HEAP16[$1 + 32 >> 1] != ($11 | 0)) {
        break label$3;
       }
       $9 = HEAP32[$1 + 28 >> 2] >>> 3 & 1;
       break label$3;
      }
      $9 = $9 + 1 | 0;
      continue;
     }
    }
    $17 = 1;
    $14 = 19010;
    $9 = 0;
   }
   $11 = $1;
   $13 = $16 ? $16 : 32384;
   break label$1;
  }
  $13 = 0;
 }
 $12 = $13;
 if ($4) {
  HEAP32[$4 >> 2] = $14;
 }
 if ($5) {
  HEAP32[$5 >> 2] = $12;
 }
 if ($6) {
  HEAP32[$6 >> 2] = $18;
 }
 if ($7) {
  HEAP32[$7 >> 2] = $17;
 }
 if ($8) {
  HEAP32[$8 >> 2] = $9;
 }
 $9 = HEAP32[$10 + 28 >> 2];
 if (!($11 | $15)) {
  sqlite3DbFree($0, $9);
  HEAP32[$10 + 20 >> 2] = $3;
  HEAP32[$10 + 16 >> 2] = $2;
  $9 = sqlite3MPrintf($0, 5994, $10 + 16 | 0);
  HEAP32[$10 + 28 >> 2] = $9;
  $15 = 1;
 }
 HEAP32[$10 >> 2] = $9;
 sqlite3ErrorWithMsg($0, $15, $9 ? 8342 : 0, $10);
 sqlite3DbFree($0, HEAP32[$10 + 28 >> 2]);
 $0 = sqlite3ApiExit($0, $15);
 __stack_pointer = $10 + 32 | 0;
 return $0;
}

function renameQuotefixFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $1 = __stack_pointer - 336 | 0;
 __stack_pointer = $1;
 $4 = sqlite3_context_db_handle($0);
 $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $6 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
 $7 = HEAP32[$4 + 360 >> 2];
 HEAP32[$4 + 360 >> 2] = 0;
 sqlite3BtreeEnterAll($4);
 if (!(!$3 | !$6)) {
  $3 = renameParseSql($1 - -64 | 0, $3, $4, $6, 0);
  label$2: {
   if (!$3) {
    HEAP32[$1 + 48 >> 2] = 0;
    HEAP32[$1 + 52 >> 2] = 0;
    HEAP32[$1 + 56 >> 2] = 0;
    HEAP32[$1 + 28 >> 2] = 0;
    HEAP32[$1 + 40 >> 2] = 0;
    HEAP32[$1 + 44 >> 2] = 0;
    HEAP32[$1 + 20 >> 2] = 0;
    HEAP32[$1 + 24 >> 2] = 0;
    HEAP32[$1 + 16 >> 2] = 88;
    HEAP32[$1 + 12 >> 2] = 92;
    HEAP32[$1 + 32 >> 2] = $1 + 40;
    HEAP32[$1 + 8 >> 2] = $1 - -64;
    $3 = HEAP32[$1 + 300 >> 2];
    label$4: {
     label$5: {
      if ($3) {
       if (HEAPU8[$3 + 43 | 0] == 2) {
        $5 = HEAP32[$3 + 44 >> 2];
        HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] & -2097153;
        HEAP32[$1 + 76 >> 2] = 0;
        sqlite3SelectPrep($1 - -64 | 0, $5, 0);
        $3 = HEAPU8[$4 + 87 | 0] ? 7 : HEAP32[$1 + 76 >> 2];
        if ($3) {
         break label$4;
        }
        sqlite3WalkSelect($1 + 8 | 0, $5);
        break label$5;
       }
       sqlite3WalkExprList($1 + 8 | 0, HEAP32[$3 + 16 >> 2]);
       $3 = 0;
       while (1) {
        $5 = HEAP32[$1 + 300 >> 2];
        if (HEAP16[$5 + 34 >> 1] <= ($3 | 0)) {
         break label$5;
        }
        sqlite3WalkExpr($1 + 8 | 0, sqlite3ColumnExpr($5, HEAP32[$5 + 4 >> 2] + Math_imul($3, 12) | 0));
        $3 = $3 + 1 | 0;
        continue;
       }
      }
      $3 = HEAP32[$1 + 304 >> 2];
      if ($3) {
       sqlite3WalkExprList($1 + 8 | 0, HEAP32[$3 + 40 >> 2]);
       sqlite3WalkExpr($1 + 8 | 0, HEAP32[HEAP32[$1 + 304 >> 2] + 36 >> 2]);
       break label$5;
      }
      $3 = renameResolveTrigger($1 - -64 | 0);
      if ($3) {
       break label$4;
      }
      renameWalkTrigger($1 + 8 | 0, HEAP32[$1 + 308 >> 2]);
     }
     $3 = renameEditSql($0, $1 + 40 | 0, $6, 0, 0);
    }
    renameTokenFree($4, HEAP32[$1 + 40 >> 2]);
    if (!$3) {
     break label$2;
    }
   }
   if (!(!sqlite3WritableSchema($4) | ($3 | 0) != 1)) {
    sqlite3_result_value($0, HEAP32[$2 + 4 >> 2]);
    break label$2;
   }
   sqlite3_result_error_code($0, $3);
  }
  renameParseCleanup($1 - -64 | 0);
 }
 HEAP32[$4 + 360 >> 2] = $7;
 __stack_pointer = $1 + 336 | 0;
}

function fts3DoclistPhraseMerge($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 40 >> 2] = 0;
 HEAP32[$6 + 44 >> 2] = 0;
 HEAP32[$6 + 32 >> 2] = 0;
 HEAP32[$6 + 36 >> 2] = 0;
 HEAP32[$6 + 24 >> 2] = 0;
 HEAP32[$6 + 28 >> 2] = 0;
 $9 = HEAP32[$5 >> 2];
 $11 = HEAP32[$4 >> 2];
 HEAP32[$6 + 20 >> 2] = $2;
 HEAP32[$6 + 16 >> 2] = $11;
 HEAP32[$6 + 8 >> 2] = 0;
 $10 = $11;
 label$1: {
  label$2: {
   if (!$0) {
    break label$2;
   }
   $7 = $9 >> 31;
   $8 = $7;
   $7 = $9 + 10 | 0;
   $8 = $7 >>> 0 < 10 ? $8 + 1 | 0 : $8;
   $10 = sqlite3_malloc64($7, $8);
   if ($10) {
    break label$2;
   }
   $2 = 7;
   break label$1;
  }
  HEAP32[$6 + 12 >> 2] = $10;
  $3 = $2 + $3 | 0;
  fts3GetDeltaVarint3($6 + 20 | 0, $3, 0, $6 + 40 | 0);
  $9 = $9 + $11 | 0;
  fts3GetDeltaVarint3($6 + 16 | 0, $9, 0, $6 + 32 | 0);
  while (1) {
   if (!(!HEAP32[$6 + 20 >> 2] | !HEAP32[$6 + 16 >> 2])) {
    $2 = HEAP32[$6 + 44 >> 2];
    $14 = $2;
    $8 = HEAP32[$6 + 40 >> 2];
    $15 = $8;
    $7 = $8;
    $2 = HEAP32[$6 + 32 >> 2];
    $12 = $2;
    $8 = HEAP32[$6 + 36 >> 2];
    $2 = $8;
    $8 = $14;
    $13 = ($7 | 0) != ($12 | 0) | ($2 | 0) != ($8 | 0) ? -1 : 0;
    $7 = $2;
    $2 = $15;
    $2 = ($8 | 0) >= ($7 | 0) & $12 >>> 0 < $2 >>> 0 | ($8 | 0) > ($7 | 0) ? 1 : $13;
    $2 = $0 ? 0 - $2 | 0 : $2;
    if (!$2) {
     $2 = HEAP32[$6 + 8 >> 2];
     $12 = HEAP32[$6 + 24 >> 2];
     $7 = HEAP32[$6 + 28 >> 2];
     $8 = $7;
     $13 = HEAP32[$6 + 12 >> 2];
     $7 = $14;
     fts3PutDeltaVarint3($6 + 12 | 0, $0, $6 + 24 | 0, $6 + 8 | 0, $15, $7);
     if (!fts3PoslistPhraseMerge($6 + 12 | 0, $1, 0, 1, $6 + 20 | 0, $6 + 16 | 0)) {
      HEAP32[$6 + 24 >> 2] = $12;
      $7 = $8;
      HEAP32[$6 + 28 >> 2] = $7;
      HEAP32[$6 + 12 >> 2] = $13;
      HEAP32[$6 + 8 >> 2] = $2;
     }
     fts3GetDeltaVarint3($6 + 20 | 0, $3, $0, $6 + 40 | 0);
     fts3GetDeltaVarint3($6 + 16 | 0, $9, $0, $6 + 32 | 0);
     continue;
    }
    if (($2 | 0) < 0) {
     fts3PoslistCopy(0, $6 + 20 | 0);
     fts3GetDeltaVarint3($6 + 20 | 0, $3, $0, $6 + 40 | 0);
    } else {
     fts3PoslistCopy(0, $6 + 16 | 0);
     fts3GetDeltaVarint3($6 + 16 | 0, $9, $0, $6 + 32 | 0);
    }
    continue;
   }
   break;
  }
  HEAP32[$5 >> 2] = HEAP32[$6 + 12 >> 2] - $10;
  $2 = 0;
  if (!$0) {
   break label$1;
  }
  sqlite3_free($11);
  HEAP32[$4 >> 2] = $10;
 }
 __stack_pointer = $6 + 48 | 0;
 return $2;
}

function __letf2($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $14 = 1;
 $9 = $0;
 $10 = $1;
 $12 = ($9 | $10) != 0;
 $9 = $3;
 $10 = $9 & 2147483647;
 $13 = $10;
 $8 = $2;
 $2 = $8;
 $15 = ($10 | 0) == 2147418112 & ($8 | 0) != 0 | $10 >>> 0 > 2147418112;
 $9 = $10;
 $11 = $8;
 label$1: {
  if (!$11 & ($9 | 0) == 2147418112 ? $12 : $15) {
   break label$1;
  }
  $8 = $4;
  $11 = $5;
  $15 = ($8 | $11) != 0;
  $8 = $7;
  $11 = $8 & 2147483647;
  $12 = $11;
  $10 = $6;
  $6 = $10;
  $8 = $10;
  $16 = ($11 | 0) == 2147418112 & ($8 | 0) != 0 | $11 >>> 0 > 2147418112;
  $8 = $11;
  $9 = $10;
  if (!$9 & ($8 | 0) == 2147418112 ? $15 : $16) {
   break label$1;
  }
  $10 = $0;
  $11 = $4;
  $15 = $10 | $11;
  $9 = $1;
  $8 = $5;
  $8 = $9 | $8;
  $14 = $8;
  $10 = $12;
  $8 = $13;
  $10 = $10 | $8;
  $13 = $10;
  $11 = $6;
  $9 = $2;
  $11 = $11 | $9;
  $8 = $15;
  $10 = $14;
  $9 = $13;
  $9 = $10 | $9;
  if (!($11 | $8 | $9)) {
   return 0;
  }
  $9 = $3;
  $8 = $7;
  $8 = $9 & $8;
  $10 = $2;
  $11 = $6;
  if (($8 | 0) > 0 | ($8 | 0) >= 0) {
   $14 = -1;
   $9 = $1;
   $8 = $5;
   $10 = $4;
   $11 = $0;
   $13 = ($9 | 0) == ($8 | 0) & $10 >>> 0 > $11 >>> 0 | $9 >>> 0 < $8 >>> 0;
   $10 = $2;
   $8 = $6;
   $11 = $3;
   $9 = $7;
   $12 = $10 >>> 0 < $8 >>> 0 & ($11 | 0) <= ($9 | 0) | ($11 | 0) < ($9 | 0);
   $9 = $8;
   $8 = $10;
   $10 = $11;
   $11 = $7;
   if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $13 : $12) {
    break label$1;
   }
   $11 = $4;
   $9 = $0;
   $4 = $11 ^ $9;
   $10 = $5;
   $8 = $1;
   $10 = $10 ^ $8;
   $0 = $10;
   $10 = $3;
   $9 = $7;
   $9 = $10 ^ $9;
   $1 = $9;
   $11 = $6;
   $8 = $2;
   $11 = $11 ^ $8;
   $9 = $0;
   $8 = $1;
   $8 = $9 | $8;
   $10 = $4;
   $9 = $11 | $10;
   return ($9 | $8) != 0;
  }
  $14 = -1;
  $9 = $1;
  $8 = $5;
  $10 = $4;
  $11 = $0;
  $13 = ($9 | 0) == ($8 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 > $8 >>> 0;
  $10 = $2;
  $8 = $6;
  $11 = $3;
  $9 = $7;
  $12 = $10 >>> 0 > $8 >>> 0 & ($11 | 0) >= ($9 | 0) | ($11 | 0) > ($9 | 0);
  $9 = $8;
  $8 = $10;
  $10 = $11;
  $11 = $7;
  if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $13 : $12) {
   break label$1;
  }
  $11 = $4;
  $9 = $0;
  $4 = $11 ^ $9;
  $10 = $5;
  $8 = $1;
  $10 = $10 ^ $8;
  $0 = $10;
  $10 = $3;
  $9 = $7;
  $9 = $10 ^ $9;
  $1 = $9;
  $11 = $6;
  $8 = $2;
  $11 = $11 ^ $8;
  $9 = $0;
  $8 = $1;
  $8 = $9 | $8;
  $10 = $4;
  $9 = $11 | $10;
  $14 = ($9 | $8) != 0;
 }
 return $14;
}

function instrFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = HEAP32[$2 >> 2];
 $3 = sqlite3_value_type($4);
 $1 = sqlite3_value_type(HEAP32[$2 + 4 >> 2]);
 if (!(($3 | 0) == 5 | ($1 | 0) == 5)) {
  $4 = sqlite3_value_bytes($4);
  $5 = 1;
  label$2: {
   label$3: {
    $6 = sqlite3_value_bytes(HEAP32[$2 + 4 >> 2]);
    if (($6 | 0) <= 0) {
     $2 = 0;
     break label$3;
    }
    label$5: {
     label$6: {
      label$7: {
       label$8: {
        label$9: {
         label$10: {
          $3 = ($3 | 0) == 4;
          $9 = $3 & ($1 | 0) == 4;
          label$11: {
           if ($9) {
            $3 = sqlite3_value_blob(HEAP32[$2 >> 2]);
            $1 = sqlite3_value_blob(HEAP32[$2 + 4 >> 2]);
            break label$11;
           }
           $5 = HEAP32[$2 >> 2];
           if (($1 | 0) == 4 | $3) {
            break label$10;
           }
           $3 = sqlite3_value_text($5);
           $1 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
          }
          if ($1) {
           break label$7;
          }
          break label$9;
         }
         $8 = sqlite3_value_dup($5);
         $3 = sqlite3_value_text($8);
         if ($3) {
          break label$8;
         }
        }
        $2 = 0;
        break label$5;
       }
       $4 = sqlite3_value_bytes($8);
       $7 = sqlite3_value_dup(HEAP32[$2 + 4 >> 2]);
       $1 = sqlite3_value_text($7);
       if (!$1) {
        $2 = $7;
        break label$5;
       }
       $6 = sqlite3_value_bytes($7);
       break label$6;
      }
      if (!$4) {
       break label$6;
      }
      $2 = 0;
      if (!$3) {
       break label$5;
      }
     }
     $2 = HEAPU8[$1 | 0];
     $5 = 1;
     label$15: while (1) {
      label$16: {
       label$17: {
        if (($4 | 0) < ($6 | 0)) {
         $5 = 0;
         break label$17;
        }
        if (HEAPU8[$3 | 0] != ($2 | 0)) {
         break label$16;
        }
        if (memcmp($3, $1, $6)) {
         break label$16;
        }
       }
       $2 = $7;
       break label$3;
      }
      $5 = $5 + 1 | 0;
      while (1) {
       $3 = $3 + 1 | 0;
       $4 = $4 - 1 | 0;
       if ($9) {
        continue label$15;
       }
       if ((HEAPU8[$3 | 0] & 192) == 128) {
        continue;
       }
       break;
      }
      continue;
     }
    }
    sqlite3_result_error_nomem($0);
    break label$2;
   }
   sqlite3_result_int($0, $5);
  }
  sqlite3_value_free($8);
  sqlite3_value_free($2);
 }
}

function __getf2($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $16 = -1;
 $9 = $0;
 $10 = $1;
 $12 = ($9 | $10) != 0;
 $9 = $3;
 $10 = $9 & 2147483647;
 $13 = $10;
 $8 = $2;
 $2 = $8;
 $14 = ($10 | 0) == 2147418112 & ($8 | 0) != 0 | $10 >>> 0 > 2147418112;
 $9 = $10;
 $11 = $8;
 label$1: {
  if (!$11 & ($9 | 0) == 2147418112 ? $12 : $14) {
   break label$1;
  }
  $8 = $4;
  $11 = $5;
  $14 = ($8 | $11) != 0;
  $8 = $7;
  $11 = $8 & 2147483647;
  $12 = $11;
  $10 = $6;
  $6 = $10;
  $8 = $10;
  $15 = ($11 | 0) == 2147418112 & ($8 | 0) != 0 | $11 >>> 0 > 2147418112;
  $8 = $11;
  $9 = $10;
  if (!$9 & ($8 | 0) == 2147418112 ? $14 : $15) {
   break label$1;
  }
  $10 = $0;
  $11 = $4;
  $15 = $10 | $11;
  $9 = $1;
  $8 = $5;
  $8 = $9 | $8;
  $14 = $8;
  $10 = $12;
  $8 = $13;
  $10 = $10 | $8;
  $13 = $10;
  $11 = $6;
  $9 = $2;
  $11 = $11 | $9;
  $8 = $15;
  $10 = $14;
  $9 = $13;
  $9 = $10 | $9;
  if (!($11 | $8 | $9)) {
   return 0;
  }
  $9 = $3;
  $8 = $7;
  $8 = $9 & $8;
  $10 = $2;
  $11 = $6;
  if (($8 | 0) > 0 | ($8 | 0) >= 0) {
   $9 = $1;
   $8 = $5;
   $10 = $4;
   $11 = $0;
   $13 = ($9 | 0) == ($8 | 0) & $10 >>> 0 > $11 >>> 0 | $9 >>> 0 < $8 >>> 0;
   $10 = $2;
   $8 = $6;
   $11 = $3;
   $9 = $7;
   $12 = $10 >>> 0 < $8 >>> 0 & ($11 | 0) <= ($9 | 0) | ($11 | 0) < ($9 | 0);
   $9 = $8;
   $8 = $10;
   $10 = $11;
   $11 = $7;
   if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $13 : $12) {
    break label$1;
   }
   $11 = $4;
   $9 = $0;
   $4 = $11 ^ $9;
   $10 = $5;
   $8 = $1;
   $10 = $10 ^ $8;
   $0 = $10;
   $10 = $3;
   $9 = $7;
   $9 = $10 ^ $9;
   $1 = $9;
   $11 = $6;
   $8 = $2;
   $11 = $11 ^ $8;
   $9 = $0;
   $8 = $1;
   $8 = $9 | $8;
   $10 = $4;
   $9 = $11 | $10;
   return ($9 | $8) != 0;
  }
  $9 = $1;
  $8 = $5;
  $10 = $4;
  $11 = $0;
  $13 = ($9 | 0) == ($8 | 0) & $10 >>> 0 < $11 >>> 0 | $9 >>> 0 > $8 >>> 0;
  $10 = $2;
  $8 = $6;
  $11 = $3;
  $9 = $7;
  $12 = $10 >>> 0 > $8 >>> 0 & ($11 | 0) >= ($9 | 0) | ($11 | 0) > ($9 | 0);
  $9 = $8;
  $8 = $10;
  $10 = $11;
  $11 = $7;
  if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $13 : $12) {
   break label$1;
  }
  $11 = $4;
  $9 = $0;
  $4 = $11 ^ $9;
  $10 = $5;
  $8 = $1;
  $10 = $10 ^ $8;
  $0 = $10;
  $10 = $3;
  $9 = $7;
  $9 = $10 ^ $9;
  $1 = $9;
  $11 = $6;
  $8 = $2;
  $11 = $11 ^ $8;
  $9 = $0;
  $8 = $1;
  $8 = $9 | $8;
  $10 = $4;
  $9 = $11 | $10;
  $16 = ($9 | $8) != 0;
 }
 return $16;
}

function qsort($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = __stack_pointer - 208 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 8 >> 2] = 1;
 HEAP32[$4 + 12 >> 2] = 0;
 $7 = Math_imul($1, $2);
 label$1: {
  if (!$7) {
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = $2;
  HEAP32[$4 + 20 >> 2] = $2;
  $1 = $2;
  $6 = $1;
  $5 = 2;
  while (1) {
   $8 = $2 + $6 | 0;
   $6 = $1;
   $1 = $1 + $8 | 0;
   HEAP32[($4 + 16 | 0) + ($5 << 2) >> 2] = $1;
   $5 = $5 + 1 | 0;
   if ($1 >>> 0 < $7 >>> 0) {
    continue;
   }
   break;
  }
  $6 = ($0 + $7 | 0) - $2 | 0;
  label$3: {
   if ($6 >>> 0 <= $0 >>> 0) {
    $6 = 0;
    $5 = 1;
    $1 = 1;
    $8 = 0;
    break label$3;
   }
   $5 = 1;
   $1 = 1;
   while (1) {
    label$6: {
     if (($5 & 3) == 3) {
      sift($0, $2, $3, $1, $4 + 16 | 0);
      shr($4 + 8 | 0, 2);
      $1 = $1 + 2 | 0;
      break label$6;
     }
     $7 = $1 - 1 | 0;
     label$8: {
      if (HEAPU32[($4 + 16 | 0) + ($7 << 2) >> 2] >= $6 - $0 >>> 0) {
       trinkle($0, $2, $3, $5, HEAP32[$4 + 12 >> 2], $1, 0, $4 + 16 | 0);
       break label$8;
      }
      sift($0, $2, $3, $1, $4 + 16 | 0);
     }
     if (($1 | 0) == 1) {
      shl($4 + 8 | 0, 1);
      $1 = 0;
      break label$6;
     }
     shl($4 + 8 | 0, $7);
     $1 = 1;
    }
    $7 = HEAP32[$4 + 8 >> 2];
    $5 = $7 | 1;
    HEAP32[$4 + 8 >> 2] = $5;
    $0 = $0 + $2 | 0;
    if ($6 >>> 0 > $0 >>> 0) {
     continue;
    }
    break;
   }
   $6 = HEAP32[$4 + 12 >> 2];
   $9 = ($6 | 0) != 0;
   $8 = $7 >>> 0 > 1;
  }
  $7 = 0 - $2 | 0;
  trinkle($0, $2, $3, $5, $6, $1, 0, $4 + 16 | 0);
  if (!($9 ? 1 : $8 | ($1 | 0) != 1)) {
   break label$1;
  }
  while (1) {
   label$12: {
    if (($1 | 0) <= 1) {
     $5 = pntz($5, $6);
     shr($4 + 8 | 0, $5);
     $1 = $1 + $5 | 0;
     $6 = HEAP32[$4 + 12 >> 2];
     $5 = HEAP32[$4 + 8 >> 2];
     break label$12;
    }
    shl($4 + 8 | 0, 2);
    HEAP32[$4 + 8 >> 2] = HEAP32[$4 + 8 >> 2] ^ 7;
    shr($4 + 8 | 0, 1);
    $9 = $0 + $7 | 0;
    $8 = $1 - 2 | 0;
    trinkle($9 - HEAP32[($4 + 16 | 0) + ($8 << 2) >> 2] | 0, $2, $3, HEAP32[$4 + 8 >> 2], HEAP32[$4 + 12 >> 2], $1 - 1 | 0, 1, $4 + 16 | 0);
    shl($4 + 8 | 0, 1);
    $5 = HEAP32[$4 + 8 >> 2] | 1;
    HEAP32[$4 + 8 >> 2] = $5;
    $6 = HEAP32[$4 + 12 >> 2];
    trinkle($9, $2, $3, $5, $6, $8, 1, $4 + 16 | 0);
    $1 = $8;
   }
   $0 = $0 + $7 | 0;
   if (($1 | 0) != 1 | ($5 | 0) != 1 | $6) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 + 208 | 0;
}

function computeJD($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  if (HEAPU8[$0 + 40 | 0]) {
   break label$1;
  }
  label$2: {
   label$3: {
    label$4: {
     if (!HEAPU8[$0 + 42 | 0]) {
      $6 = 2e3;
      $3 = 1;
      $1 = 1;
      break label$4;
     }
     $6 = HEAP32[$0 + 8 >> 2];
     if ($6 - 1e4 >>> 0 < 4294952583) {
      break label$3;
     }
     $3 = HEAP32[$0 + 12 >> 2];
     $1 = HEAP32[$0 + 16 >> 2];
    }
    if (!HEAPU8[$0 + 41 | 0]) {
     break label$2;
    }
   }
   datetimeError($0);
   return;
  }
  HEAP8[$0 + 40 | 0] = 1;
  $2 = ($3 | 0) < 3;
  $1 = ((Math_imul($2 ? $3 + 12 | 0 : $3, 306001) + 306001 | 0) / 1e4 | 0) + $1 | 0;
  $3 = $6 - $2 | 0;
  $1 = $1 + ((Math_imul($3, 36525) + 172251900 >>> 0) / 100 | 0) | 0;
  $3 = $3 << 16 >> 16;
  $4 = (+(($1 + (($3 | 0) / 400 << 16 >> 16) | 0) + ((($3 | 0) / -100 << 16) + 131072 >> 16) | 0) + -1524.5) * 864e5;
  label$6: {
   if (Math_abs($4) < 0x8000000000000000) {
    $1 = Math_abs($4) >= 1 ? ~~($4 > 0 ? Math_min(Math_floor($4 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($4 - +(~~$4 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $7 = ~~$4 >>> 0;
    break label$6;
   }
   $1 = -2147483648;
  }
  $3 = $1;
  $2 = $0;
  HEAP32[$2 >> 2] = $7;
  HEAP32[$2 + 4 >> 2] = $1;
  if (!HEAPU8[$0 + 43 | 0]) {
   break label$1;
  }
  $2 = Math_imul(HEAP32[$0 + 24 >> 2], 6e4) + Math_imul(HEAP32[$0 + 20 >> 2], 36e5) | 0;
  $1 = $2 >> 31;
  $8 = $2;
  $9 = $1;
  $4 = HEAPF64[$0 + 32 >> 3] * 1e3;
  label$8: {
   if (Math_abs($4) < 0x8000000000000000) {
    $1 = Math_abs($4) >= 1 ? ~~($4 > 0 ? Math_min(Math_floor($4 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($4 - +(~~$4 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $5 = ~~$4 >>> 0;
    break label$8;
   }
   $1 = -2147483648;
  }
  $2 = $3;
  $1 = $1 + $2 | 0;
  $5 = $7 + $5 | 0;
  $6 = $5;
  $1 = $5 >>> 0 < $7 >>> 0 ? $1 + 1 | 0 : $1;
  $3 = $1;
  $1 = $9;
  $5 = $3 + $1 | 0;
  $1 = $8;
  $2 = $1 + $6 | 0;
  $5 = $2 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $7 = $2;
  $3 = $5;
  $1 = $0;
  HEAP32[$1 >> 2] = $2;
  HEAP32[$1 + 4 >> 2] = $5;
  if (!HEAPU8[$0 + 44 | 0]) {
   break label$1;
  }
  HEAP8[$0 + 44 | 0] = 0;
  HEAP16[$0 + 42 >> 1] = 0;
  $1 = Math_imul(HEAP32[$0 + 28 >> 2], 6e4);
  $5 = $1 >> 31;
  $2 = $5;
  $6 = $1;
  HEAP32[$0 >> 2] = $7 - $1;
  $5 = $3;
  $1 = $2;
  $2 = $1 + ($7 >>> 0 < $6 >>> 0) | 0;
  $2 = $5 - $2 | 0;
  HEAP32[$0 + 4 >> 2] = $2;
 }
}

function sqlite3ComputeGeneratedColumns($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 sqlite3TableAffinity(HEAP32[$0 + 8 >> 2], $2, $1);
 label$1: {
  if (!(HEAPU8[$2 + 28 | 0] & 64)) {
   break label$1;
  }
  label$2: {
   label$3: {
    $3 = sqlite3VdbeGetOp(HEAP32[$0 + 8 >> 2], -1);
    switch (HEAPU8[$3 | 0] - 95 | 0) {
    case 0:
     break label$2;

    case 1:
     break label$3;

    default:
     break label$1;
    }
   }
   $7 = HEAP32[$3 + 16 >> 2];
   $3 = 0;
   while (1) {
    $5 = $4 + $7 | 0;
    if (!HEAPU8[$5 | 0]) {
     break label$1;
    }
    $8 = HEAPU16[(HEAP32[$2 + 4 >> 2] + Math_imul($3, 12) | 0) + 10 >> 1];
    if (!($8 & 32)) {
     if ($8 & 64) {
      HEAP8[$5 | 0] = 64;
     }
     $4 = $4 + 1 | 0;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
  }
  HEAP32[$3 + 12 >> 2] = 1;
 }
 $3 = 0;
 $7 = HEAP16[$2 + 34 >> 1];
 $5 = ($7 | 0) > 0 ? $7 : 0;
 while (1) {
  if (($3 | 0) != ($5 | 0)) {
   $4 = HEAP32[$2 + 4 >> 2] + Math_imul($3, 12) | 0;
   $8 = HEAPU16[$4 + 10 >> 1];
   if ($8 & 96) {
    HEAP16[$4 + 10 >> 1] = $8 | 128;
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$6 + 24 >> 2] = 0;
 HEAP32[$6 + 28 >> 2] = 0;
 HEAP32[$6 + 20 >> 2] = 58;
 HEAP32[$6 + 40 >> 2] = $2;
 HEAP32[$0 + 52 >> 2] = 0 - $1;
 $5 = 0;
 $4 = 0;
 $3 = 0;
 label$10: while (1) {
  $9 = $7 << 16 >> 16;
  while (1) {
   $8 = $4;
   $7 = $5;
   if (($3 | 0) < ($9 | 0)) {
    $4 = HEAP32[$2 + 4 >> 2] + Math_imul($3, 12) | 0;
    $9 = HEAPU16[$4 + 10 >> 1];
    label$13: {
     if ($9 & 128) {
      $5 = $4 + 10 | 0;
      HEAP16[$5 >> 1] = $9 | 256;
      HEAP16[$6 + 36 >> 1] = 0;
      sqlite3WalkExpr($6 + 16 | 0, sqlite3ColumnExpr($2, $4));
      HEAP16[$4 + 10 >> 1] = HEAPU16[$4 + 10 >> 1] & 65279;
      if (HEAPU8[$6 + 36 | 0] & 128) {
       $5 = $7;
       break label$13;
      }
      sqlite3ExprCodeGeneratedColumn($0, $2, $4, sqlite3TableColumnToStorage($2, $3 << 16 >> 16) + $1 | 0);
      HEAP16[$4 + 10 >> 1] = HEAPU16[$4 + 10 >> 1] & 65407;
      $5 = 1;
     } else {
      $5 = $7;
     }
     $4 = $8;
    }
    $3 = $3 + 1 | 0;
    $7 = HEAPU16[$2 + 34 >> 1];
    continue label$10;
   }
   if ($8) {
    $5 = 0;
    $4 = 0;
    $3 = 0;
    if ($7) {
     continue;
    }
   }
   break;
  }
  break;
 }
 if ($8) {
  HEAP32[$6 >> 2] = HEAP32[$8 >> 2];
  sqlite3ErrorMsg($0, 28522, $6);
 }
 HEAP32[$0 + 52 >> 2] = 0;
 __stack_pointer = $6 + 48 | 0;
}

function windowReturnOneRow($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $3 = HEAP32[$0 + 8 >> 2];
 label$1: {
  $7 = HEAP32[$0 + 4 >> 2];
  if (HEAP32[$7 + 88 >> 2]) {
   windowFullScan($0);
   break label$1;
  }
  $5 = HEAP32[$0 >> 2];
  $1 = $7;
  while (1) {
   if (!$1) {
    break label$1;
   }
   $6 = HEAP32[$1 + 44 >> 2];
   $2 = HEAP32[$6 + 32 >> 2];
   label$4: {
    label$5: {
     if (!(($2 | 0) != 48960 & ($2 | 0) != 48970)) {
      $4 = HEAP32[$1 + 60 >> 2];
      $8 = sqlite3VdbeMakeLabel($5);
      $2 = sqlite3GetTempReg($5);
      sqlite3VdbeAddOp2($3, 75, 0, HEAP32[$1 + 56 >> 2]);
      label$7: {
       if (HEAP32[$6 + 32 >> 2] == 48960) {
        sqlite3VdbeAddOp3($3, 94, HEAP32[$7 + 48 >> 2], HEAP32[$1 + 80 >> 2] + 1 | 0, $2);
        windowCheckValue($5, $2, 2);
        break label$7;
       }
       sqlite3VdbeAddOp2($3, 71, 1, $2);
      }
      sqlite3VdbeAddOp3($3, 106, $2, HEAP32[$1 + 64 >> 2], $2);
      sqlite3VdbeAddOp3($3, 54, HEAP32[$1 + 64 >> 2] + 1 | 0, $8, $2);
      sqlite3VdbeAddOp3($3, 29, $4, 0, $2);
      sqlite3VdbeAddOp3($3, 94, $4, HEAP32[$1 + 80 >> 2], HEAP32[$1 + 56 >> 2]);
      break label$5;
     }
     if (($2 | 0) != 48738 & ($2 | 0) != 48743) {
      break label$4;
     }
     $4 = HEAP32[HEAP32[HEAP32[$1 + 72 >> 2] + 20 >> 2] >> 2];
     $10 = HEAP32[$1 + 60 >> 2];
     $8 = sqlite3VdbeMakeLabel($5);
     $2 = sqlite3GetTempReg($5);
     $9 = HEAP32[$7 + 48 >> 2];
     label$9: {
      if (($4 | 0) <= 2) {
       sqlite3VdbeAddOp2($3, 75, 0, HEAP32[$1 + 56 >> 2]);
       break label$9;
      }
      sqlite3VdbeAddOp3($3, 94, $9, HEAP32[$1 + 80 >> 2] + 2 | 0, HEAP32[$1 + 56 >> 2]);
     }
     sqlite3VdbeAddOp2($3, 135, $9, $2);
     $6 = HEAP32[$6 + 32 >> 2];
     label$11: {
      if (($4 | 0) <= 1) {
       sqlite3VdbeAddOp2($3, 86, $2, ($6 | 0) == 48738 ? 1 : -1);
       break label$11;
      }
      $4 = sqlite3GetTempReg($5);
      sqlite3VdbeAddOp3($3, 94, $9, HEAP32[$1 + 80 >> 2] + 1 | 0, $4);
      sqlite3VdbeAddOp3($3, ($6 | 0) == 48738 ? 106 : 107, $4, $2, $2);
      sqlite3ReleaseTempReg($5, $4);
     }
     sqlite3VdbeAddOp3($3, 29, $10, $8, $2);
     sqlite3VdbeAddOp3($3, 94, $10, HEAP32[$1 + 80 >> 2], HEAP32[$1 + 56 >> 2]);
    }
    sqlite3VdbeResolveLabel($3, $8);
    sqlite3ReleaseTempReg($5, $2);
   }
   $1 = HEAP32[$1 + 36 >> 2];
   continue;
  }
 }
 sqlite3VdbeAddOp2($3, 9, HEAP32[$0 + 16 >> 2], HEAP32[$0 + 12 >> 2]);
}

function sqlite3AlterRenameColumn($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 $8 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   $6 = sqlite3LocateTableItem($0, 0, $1 + 8 | 0);
   if (!$6) {
    break label$2;
   }
   $5 = 0;
   if (isAlterableTable($0, $6)) {
    break label$1;
   }
   $5 = 0;
   if (isRealTable($0, $6, 0)) {
    break label$1;
   }
   $5 = HEAP32[$8 + 16 >> 2];
   $11 = sqlite3SchemaToIndex($8, HEAP32[$6 + 60 >> 2]);
   $9 = HEAP32[$5 + ($11 << 4) >> 2];
   if (sqlite3AuthCheck($0, 26, $9, HEAP32[$6 >> 2], 0)) {
    break label$2;
   }
   $12 = sqlite3NameFromToken($8, $2);
   $5 = 0;
   if (!$12) {
    break label$1;
   }
   $10 = HEAP16[$6 + 34 >> 1];
   $5 = ($10 | 0) > 0 ? $10 : 0;
   while (1) {
    label$4: {
     if (($7 | 0) != ($5 | 0)) {
      if (sqlite3StrICmp(HEAP32[HEAP32[$6 + 4 >> 2] + Math_imul($7, 12) >> 2], $12)) {
       break label$4;
      }
      $5 = $7;
     }
     label$6: {
      label$7: {
       label$8: {
        if (($5 | 0) == ($10 | 0)) {
         HEAP32[$4 >> 2] = $2;
         sqlite3ErrorMsg($0, 28902, $4);
         break label$8;
        }
        $2 = ($11 | 0) == 1;
        renameTestSchema($0, $9, $2, 29623, 0);
        renameFixQuotes($0, $9, $2);
        sqlite3MayAbort($0);
        $7 = sqlite3NameFromToken($8, $3);
        if ($7) {
         break label$7;
        }
       }
       $7 = 0;
       break label$6;
      }
      $3 = HEAPU8[HEAP32[$3 >> 2]];
      $10 = HEAP32[$6 >> 2];
      HEAP32[$4 + 76 >> 2] = $10;
      HEAP32[$4 + 72 >> 2] = $2;
      HEAP32[$4 - -64 >> 2] = $7;
      $3 = HEAPU8[$3 + 30288 | 0] & 128;
      HEAP32[$4 + 68 >> 2] = $3;
      HEAP32[$4 + 60 >> 2] = $5;
      HEAP32[$4 + 56 >> 2] = $10;
      HEAP32[$4 + 52 >> 2] = $9;
      HEAP32[$4 + 48 >> 2] = $9;
      sqlite3NestedParse($0, 25120, $4 + 48 | 0);
      $6 = HEAP32[$6 >> 2];
      HEAP32[$4 + 32 >> 2] = $3;
      HEAP32[$4 + 28 >> 2] = $7;
      HEAP32[$4 + 24 >> 2] = $5;
      HEAP32[$4 + 20 >> 2] = $6;
      HEAP32[$4 + 16 >> 2] = $9;
      sqlite3NestedParse($0, 26281, $4 + 16 | 0);
      renameReloadSchema($0, $11, 1);
      renameTestSchema($0, $9, $2, 13250, 1);
     }
     $5 = $12;
     break label$1;
    }
    $7 = $7 + 1 | 0;
    continue;
   }
  }
  $5 = 0;
 }
 sqlite3SrcListDelete($8, $1);
 sqlite3DbFree($8, $5);
 sqlite3DbFree($8, $7);
 __stack_pointer = $4 + 80 | 0;
}

function fts3MatchinfoLcs($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = sqlite3Fts3MallocZero(HEAP32[$0 + 24 >> 2] << 4, 0);
 if (!$6) {
  return 7;
 }
 fts3ExprIterate(HEAP32[$0 + 16 >> 2], 114, $6);
 $3 = HEAP32[$1 + 8 >> 2];
 $4 = ($3 | 0) > 0 ? $3 : 0;
 $3 = 0;
 while (1) {
  if (($3 | 0) == ($4 | 0)) {
   label$5: while (1) {
    label$4: {
     $7 = 0;
     $3 = 0;
     if (HEAP32[$1 + 4 >> 2] <= ($9 | 0)) {
      $4 = 0;
      break label$4;
     }
     while (1) {
      label$8: {
       if (HEAP32[$1 + 8 >> 2] <= ($3 | 0)) {
        $10 = 0;
        break label$8;
       }
       $2 = ($3 << 4) + $6 | 0;
       $5 = $2 + 8 | 0;
       $4 = sqlite3Fts3EvalPhrasePoslist($0, HEAP32[$2 >> 2], $9, $5);
       if ($4) {
        break label$4;
       }
       if (HEAP32[$2 + 8 >> 2]) {
        HEAP32[$2 + 12 >> 2] = HEAP32[$2 + 4 >> 2];
        fts3LcsIteratorAdvance($2);
        if (!HEAP32[$2 + 8 >> 2]) {
         $4 = 267;
         break label$4;
        }
        $7 = $7 + 1 | 0;
       }
       $3 = $3 + 1 | 0;
       continue;
      }
      break;
     }
     while (1) {
      label$13: {
       if (($7 | 0) > 0) {
        $3 = 0;
        $2 = HEAP32[$1 + 8 >> 2];
        $11 = ($2 | 0) > 0 ? $2 : 0;
        $8 = 0;
        $4 = 0;
        while (1) {
         if (($3 | 0) == ($11 | 0)) {
          break label$13;
         }
         $2 = $3 << 4;
         $5 = $6 + $2 | 0;
         label$16: {
          if (!HEAP32[$5 + 8 >> 2]) {
           $2 = 0;
           break label$16;
          }
          $8 = (HEAP32[($2 + $6 | 0) + 12 >> 2] >= HEAP32[$8 + 12 >> 2] ? $8 : 0) ? $8 : $5;
          label$20: {
           if ($4) {
            $2 = 1;
            if (HEAP32[$5 + 12 >> 2] != HEAP32[$5 - 4 >> 2]) {
             break label$20;
            }
           }
           $2 = $4 + 1 | 0;
          }
          $10 = ($2 | 0) > ($10 | 0) ? $2 : $10;
         }
         $3 = $3 + 1 | 0;
         $4 = $2;
         continue;
        }
       }
       HEAP32[HEAP32[$1 + 28 >> 2] + ($9 << 2) >> 2] = $10;
       $9 = $9 + 1 | 0;
       continue label$5;
      }
      $7 = $7 - ((fts3LcsIteratorAdvance($8) | 0) != 0) | 0;
      continue;
     }
    }
    break;
   }
  } else {
   $5 = ($3 << 4) + $6 | 0;
   $2 = $2 - HEAP32[HEAP32[HEAP32[$5 >> 2] + 20 >> 2] + 64 >> 2] | 0;
   HEAP32[$5 + 4 >> 2] = $2;
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3_free($6);
 return $4;
}

function sqlite3VdbeNextOpcode($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $12 = HEAP32[$0 + 108 >> 2];
 label$1: {
  if (!$1) {
   break label$1;
  }
  if (HEAPU8[$1 + 16 | 0] & 16) {
   $13 = HEAP32[$1 + 8 >> 2];
   $10 = HEAP32[$1 + 12 >> 2] >>> 2 | 0;
  }
  while (1) {
   if (($7 | 0) == ($10 | 0)) {
    break label$1;
   }
   $12 = HEAP32[HEAP32[($7 << 2) + $13 >> 2] + 4 >> 2] + $12 | 0;
   $7 = $7 + 1 | 0;
   continue;
  }
 }
 $18 = $0 + 104 | 0;
 $14 = HEAP32[$3 >> 2];
 while (1) {
  label$6: {
   $11 = $14;
   $14 = $11 + 1 | 0;
   if (($12 | 0) <= ($11 | 0)) {
    HEAP32[$0 + 36 >> 2] = 0;
    $8 = 101;
    $7 = $11;
    break label$6;
   }
   $9 = $18;
   label$8: {
    $6 = HEAP32[$0 + 108 >> 2];
    $7 = $11;
    if (($6 | 0) > ($7 | 0)) {
     break label$8;
    }
    $7 = $11 - $6 | 0;
    $6 = 0;
    while (1) {
     $9 = HEAP32[($6 << 2) + $13 >> 2];
     $8 = HEAP32[$9 + 4 >> 2];
     if (($8 | 0) > ($7 | 0)) {
      break label$8;
     }
     $6 = $6 + 1 | 0;
     $7 = $7 - $8 | 0;
     continue;
    }
   }
   $15 = HEAP32[$9 >> 2];
   label$10: {
    if (!$1) {
     break label$10;
    }
    $9 = Math_imul($7, 20) + $15 | 0;
    if (HEAPU8[$9 + 1 | 0] != 252) {
     break label$10;
    }
    $6 = 0;
    $8 = ($10 | 0) > 0 ? $10 : 0;
    $16 = $10 + 1 | 0;
    $17 = $16 << 2;
    while (1) {
     label$12: {
      if (($6 | 0) != ($8 | 0)) {
       if (HEAP32[($6 << 2) + $13 >> 2] != HEAP32[$9 + 16 >> 2]) {
        break label$12;
       }
       $8 = $6;
      }
      if (($10 | 0) != ($8 | 0)) {
       break label$10;
      }
      $6 = sqlite3VdbeMemGrow($1, $17, ($10 | 0) != 0);
      HEAP32[$0 + 36 >> 2] = $6;
      if ($6) {
       $8 = 1;
       break label$6;
      }
      $13 = HEAP32[$1 + 8 >> 2];
      HEAP32[$13 + ($10 << 2) >> 2] = HEAP32[$9 + 16 >> 2];
      HEAP32[$1 + 12 >> 2] = $17;
      HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 16;
      $12 = HEAP32[HEAP32[$9 + 16 >> 2] + 4 >> 2] + $12 | 0;
      $10 = $16;
      break label$10;
     }
     $6 = $6 + 1 | 0;
     continue;
    }
   }
   $8 = 0;
   if (!$2) {
    break label$6;
   }
   $6 = HEAPU8[Math_imul($7, 20) + $15 | 0];
   if (($6 | 0) == 185) {
    break label$6;
   }
   if (($6 | 0) != 64 | ($11 | 0) <= 0) {
    continue;
   }
  }
  break;
 }
 HEAP32[$3 >> 2] = $14;
 HEAP32[$4 >> 2] = $7;
 HEAP32[$5 >> 2] = $15;
 return $8;
}

function setupSequence($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 HEAP8[$0 + 48 | 0] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 $5 = $1;
 $1 = HEAP32[$0 + 4 >> 2];
 $6 = $1;
 label$1: {
  label$2: {
   $2 = $5;
   $7 = HEAP32[$0 >> 2];
   $9 = HEAP32[$0 + 12 >> 2];
   $1 = $9;
   if ($2 >>> 0 < $7 >>> 0 & ($6 | 0) >= ($1 | 0) | ($6 | 0) > ($1 | 0)) {
    $2 = HEAP32[$0 + 16 >> 2];
    $10 = $2;
    $1 = HEAP32[$0 + 20 >> 2];
    $11 = $1;
    if (($1 | 0) > 0 | ($1 | 0) >= 0) {
     break label$1;
    }
    HEAP8[$0 + 48 | 0] = 1;
    $2 = $5;
    $5 = $7 - $2 | 0;
    $1 = $9;
    $3 = $1 + ($2 >>> 0 > $7 >>> 0) | 0;
    $3 = $6 - $3 | 0;
    $9 = $3;
    if (!$3 & ($5 | 0) == -1) {
     $4 = 1;
     $2 = $10;
     if (!$2 & ($11 | 0) == -2147483648) {
      break label$2;
     }
     $3 = $10;
     $1 = 0 - $3 | 0;
     $4 = __wasm_i64_udiv(-1, 0, $1, 0 - ((($3 | 0) != 0) + $11 | 0) | 0);
     $8 = i64toi32_i32$HIGH_BITS;
     break label$2;
    }
    $2 = $10;
    if (!$2 & ($11 | 0) == -2147483648) {
     break label$1;
    }
    $1 = (($10 | 0) != 0) + $11 | 0;
    $1 = 0 - $1 | 0;
    $3 = $1;
    $1 = $9;
    $3 = __wasm_i64_udiv($5, $1, 0 - $10 | 0, $3);
    $4 = $3;
    $1 = i64toi32_i32$HIGH_BITS;
    $8 = $1;
    break label$2;
   }
   $2 = $7;
   $1 = $6;
   $3 = $9;
   if ($2 >>> 0 < $5 >>> 0 & ($1 | 0) <= ($3 | 0) | ($1 | 0) < ($3 | 0)) {
    $2 = HEAP32[$0 + 16 >> 2];
    $4 = $2;
    $1 = HEAP32[$0 + 20 >> 2];
    $8 = $1;
    if (!$4 & ($1 | 0) <= 0 | ($1 | 0) < 0) {
     $4 = 0;
     $8 = 0;
     break label$1;
    }
    HEAP8[$0 + 48 | 0] = 1;
    $3 = $5;
    $2 = $7;
    $10 = $3 - $2 | 0;
    $1 = $6;
    $3 = $8;
    $3 = __wasm_i64_udiv($10, $9 - ($1 + ($5 >>> 0 < $2 >>> 0) | 0) | 0, $4, $3);
    $4 = $3;
    $8 = i64toi32_i32$HIGH_BITS;
    break label$2;
   }
   $2 = $5;
   if (($2 | 0) != ($7 | 0) | ($9 | 0) != ($6 | 0)) {
    break label$1;
   }
   HEAP8[$0 + 48 | 0] = 1;
   break label$1;
  }
  HEAP32[$0 + 24 >> 2] = $4;
  HEAP32[$0 + 28 >> 2] = $8;
 }
 label$7: {
  if (!HEAPU8[$0 + 49 | 0]) {
   $4 = 0;
   $8 = 0;
   break label$7;
  }
  $2 = $8;
  $2 = genSeqMember($7, $6, HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], $4, $2);
  $7 = $2;
  $6 = i64toi32_i32$HIGH_BITS;
 }
 HEAP32[$0 + 40 >> 2] = $7;
 HEAP32[$0 + 44 >> 2] = $6;
 HEAP32[$0 + 32 >> 2] = $4;
 HEAP32[$0 + 36 >> 2] = $8;
}

function sqlite3GetInt32($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 label$1: {
  label$2: {
   label$3: {
    $7 = HEAPU8[$0 | 0];
    if (($7 | 0) == 45) {
     $0 = $0 + 1 | 0;
     $11 = -1;
     $11 = -1;
     break label$3;
    }
    if (($7 | 0) != 48) {
     if (($7 | 0) != 43) {
      break label$3;
     }
     $0 = $0 + 1 | 0;
     break label$3;
    }
    if (!(HEAPU8[HEAPU8[$0 + 2 | 0] + 30288 | 0] & 8) | (HEAPU8[$0 + 1 | 0] | 32) != 120) {
     break label$3;
    }
    $5 = $0 + 2 | 0;
    while (1) {
     $6 = $5;
     $5 = $6 + 1 | 0;
     $0 = HEAPU8[$6 | 0];
     if (($0 | 0) == 48) {
      continue;
     }
     break;
    }
    $5 = 0;
    $7 = 0;
    while (1) {
     $2 = HEAPU8[($0 & 255) + 30288 | 0] & 8;
     if (!(!$2 | $5 >>> 0 > 7)) {
      $7 = sqlite3HexToInt($0 << 24 >> 24) + ($7 << 4) | 0;
      $5 = $5 + 1 | 0;
      $0 = HEAPU8[$6 + $5 | 0];
      continue;
     }
     break;
    }
    $5 = 0;
    if (($7 | 0) < 0) {
     break label$1;
    }
    if (!$2) {
     break label$2;
    }
    break label$1;
   }
   $6 = HEAPU8[$0 | 0];
   if ($6 - 58 >>> 0 < 4294967286) {
    break label$1;
   }
   while (1) {
    if (($6 & 255) != 48) {
     label$11: {
      $6 = 0;
      while (1) {
       if (($6 | 0) == 11) {
        break label$11;
       }
       $5 = HEAPU8[$0 + $6 | 0];
       if (($5 - 48 & 255) >>> 0 > 9) {
        break label$11;
       }
       $2 = $9;
       $3 = __wasm_i64_mul($10, $2, 10, 0);
       $10 = $3;
       $2 = i64toi32_i32$HIGH_BITS;
       $9 = $2;
       $4 = $5;
       $2 = $4 & 255;
       $3 = $2 - 48 | 0;
       $8 = $3;
       $2 = 0;
       $3 = $2;
       $2 = $9;
       $3 = $2 + $3 | 0;
       $4 = $10 + $8 | 0;
       $3 = $4 >>> 0 < $8 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = $4;
       $9 = $3;
       $6 = $6 + 1 | 0;
       continue;
      }
     }
    } else {
     $6 = HEAPU8[$0 + 1 | 0];
     $0 = $0 + 1 | 0;
     continue;
    }
    break;
   }
   $5 = 0;
   $3 = $9;
   $4 = $11 + $3 | 0;
   $2 = $10;
   $8 = $11;
   $3 = $2 + $8 | 0;
   $4 = $3 >>> 0 < $8 >>> 0 ? $4 + 1 | 0 : $4;
   if ($3 >>> 0 > 2147483647 & ($4 | 0) >= 0 | ($4 | 0) > 0 | $6 >>> 0 > 10) {
    break label$1;
   }
   $4 = $9;
   $3 = $4 + (($10 | 0) != 0) | 0;
   $3 = 0 - $3 | 0;
   $2 = $10;
   $4 = ($7 | 0) == 45;
   $2 = $4 ? 0 - $2 | 0 : $2;
   $8 = $9;
   $7 = $2;
  }
  HEAP32[$1 >> 2] = $7;
  $5 = 1;
 }
 return $5;
}

function padcFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 label$1: {
  if (($1 | 0) == 2) {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
    sqlite3_result_null($0);
    return;
   }
   $1 = sqlite3_value_text(HEAP32[$2 >> 2]);
   $3 = sqlite3_value_int64(HEAP32[$2 + 4 >> 2]);
   $11 = $3;
   $4 = i64toi32_i32$HIGH_BITS;
   $12 = $4;
   if (($4 | 0) < 0) {
    sqlite3_result_error($0, 8544, -1);
    return;
   }
   $2 = sqlite3Utf8CharLen_1($1);
   $4 = $2;
   $5 = $4 >> 31;
   $13 = $4;
   $4 = $12;
   $14 = $5;
   $3 = $11;
   label$5: {
    if (($4 | 0) <= ($5 | 0) & $3 >>> 0 <= $2 >>> 0 | ($5 | 0) > ($4 | 0)) {
     $8 = sqlite3StrDup($1);
     if (!$8) {
      break label$1;
     }
     sqlite3_result_text($0, $8, -1, -1);
     break label$5;
    }
    $15 = strlen($1);
    $8 = sqlite3_malloc(($15 + ($11 - $2 | 0) | 0) + 1 | 0);
    if (!$8) {
     break label$1;
    }
    $6 = $14 + ($11 >>> 0 < $13 >>> 0) | 0;
    $6 = $12 - $6 | 0;
    $4 = $13;
    $7 = $11 - $4 | 0;
    $3 = $6 >>> 1 | 0;
    $6 = ($6 & 1) << 31 | $7 >>> 1;
    $7 = $3;
    $5 = $6 + 1 | 0;
    $7 = $5 ? $7 : $7 + 1 | 0;
    $16 = $5;
    $6 = $7;
    $9 = 1;
    $2 = $8;
    while (1) {
     $3 = $9;
     $4 = $16;
     $7 = $10;
     if (!(($3 | 0) == ($4 | 0) & ($7 | 0) == ($6 | 0))) {
      HEAP8[$2 | 0] = 32;
      $3 = $10;
      $5 = $3;
      $4 = $9;
      $3 = $4 + 1 | 0;
      $5 = $3 ? $5 : $5 + 1 | 0;
      $9 = $3;
      $10 = $5;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    $3 = $16;
    $9 = $3;
    $4 = 0;
    $10 = $4;
    $2 = strcpy($2, $1) + $15 | 0;
    while (1) {
     $3 = $14;
     $4 = $10;
     $3 = $3 + $4 | 0;
     $5 = $9;
     $6 = $13;
     $7 = $5 + $6 | 0;
     $3 = $6 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
     $4 = $7;
     $6 = $11;
     $5 = $12;
     if (!($4 >>> 0 > $6 >>> 0 & ($3 | 0) >= ($5 | 0) | ($5 | 0) < ($3 | 0))) {
      HEAP8[$2 | 0] = 32;
      $4 = $10;
      $6 = $9;
      $3 = $6 + 1 | 0;
      $7 = $3 ? $4 : $4 + 1 | 0;
      $9 = $3;
      $10 = $7;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP8[$2 | 0] = 0;
   }
   sqlite3_result_text($0, $8, -1, -1);
   sqlite3_free($8);
   return;
  }
  __assert_fail(23018, 17353, 880, 17280);
  abort();
 }
 sqlite3_result_error_nomem($0);
}

function writeJournalHdr($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $3 = HEAP32[$0 + 104 >> 2];
 $6 = ($3 | 0) > 0 ? $3 : 0;
 $8 = HEAP32[$0 + 156 >> 2];
 $2 = HEAP32[$0 + 168 >> 2];
 $7 = $2;
 $1 = HEAP32[$0 + 172 >> 2];
 $9 = $1;
 $5 = HEAP32[$0 + 224 >> 2];
 while (1) {
  if (($4 | 0) != ($6 | 0)) {
   $3 = HEAP32[$0 + 100 >> 2] + Math_imul($4, 48) | 0;
   $1 = HEAP32[$3 + 8 >> 2];
   $2 = HEAP32[$3 + 12 >> 2];
   if (!($1 | $2)) {
    $1 = HEAP32[$0 + 84 >> 2];
    $2 = HEAP32[$0 + 80 >> 2];
    HEAP32[$3 + 8 >> 2] = $2;
    HEAP32[$3 + 12 >> 2] = $1;
   }
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 $1 = journalHdrOffset($0);
 HEAP32[$0 + 88 >> 2] = $1;
 $2 = i64toi32_i32$HIGH_BITS;
 HEAP32[$0 + 92 >> 2] = $2;
 HEAP32[$0 + 80 >> 2] = $1;
 HEAP32[$0 + 84 >> 2] = $2;
 $4 = $7;
 $6 = $4 >>> 0 > $8 >>> 0 ? $8 : $4;
 label$4: {
  label$5: {
   if (!(HEAPU8[$0 + 7 | 0] | HEAPU8[$0 + 5 | 0] == 4)) {
    if (!(sqlite3OsDeviceCharacteristics(HEAP32[$0 + 64 >> 2]) & 512)) {
     break label$5;
    }
   }
   $1 = $5;
   HEAP8[$1 | 0] = 217;
   HEAP8[$1 + 1 | 0] = 213;
   HEAP8[$1 + 2 | 0] = 5;
   HEAP8[$1 + 3 | 0] = 249;
   HEAP8[$1 + 4 | 0] = 32;
   HEAP8[$1 + 5 | 0] = 161;
   HEAP8[$1 + 6 | 0] = 99;
   HEAP8[$1 + 7 | 0] = 215;
   sqlite3Put4byte($1 + 8 | 0, -1);
   $2 = -681336544;
   break label$4;
  }
  $1 = $5;
  HEAP8[$1 | 0] = 0;
  HEAP8[$1 + 1 | 0] = 0;
  HEAP8[$1 + 2 | 0] = 0;
  HEAP8[$1 + 3 | 0] = 0;
  HEAP8[$1 + 4 | 0] = 0;
  HEAP8[$1 + 5 | 0] = 0;
  HEAP8[$1 + 6 | 0] = 0;
  HEAP8[$1 + 7 | 0] = 0;
  HEAP8[$1 + 8 | 0] = 0;
  HEAP8[$1 + 9 | 0] = 0;
  HEAP8[$1 + 10 | 0] = 0;
  HEAP8[$1 + 11 | 0] = 0;
  $2 = 0;
 }
 sqlite3_randomness(4, $0 + 52 | 0);
 sqlite3Put4byte($5 + 12 | 0, HEAP32[$0 + 52 >> 2]);
 sqlite3Put4byte($5 + 16 | 0, HEAP32[$0 + 32 >> 2]);
 sqlite3Put4byte($5 + 20 | 0, HEAP32[$0 + 156 >> 2]);
 sqlite3Put4byte($5 + 24 | 0, HEAP32[$0 + 168 >> 2]);
 $3 = 0;
 memset($5 + 28 | 0, 0, $6 - 28 | 0);
 $7 = $6;
 $4 = 0;
 while (1) {
  if (!(HEAPU32[$0 + 156 >> 2] <= $4 >>> 0 | $3)) {
   $2 = HEAP32[$0 + 80 >> 2];
   $1 = HEAP32[$0 + 84 >> 2];
   $3 = sqlite3OsWrite(HEAP32[$0 + 68 >> 2], $5, $6, $2, $1);
   $2 = HEAP32[$0 + 84 >> 2];
   $1 = HEAP32[$0 + 80 >> 2];
   $1 = $1 + $7 | 0;
   HEAP32[$0 + 80 >> 2] = $1;
   HEAP32[$0 + 84 >> 2] = $7 >>> 0 > $1 >>> 0 ? $2 + 1 | 0 : $2;
   $4 = $4 + $6 | 0;
   continue;
  }
  break;
 }
 return $3;
}

function editPage($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $6 = HEAP32[$0 + 64 >> 2];
 $11 = HEAPU8[$0 + 9 | 0];
 $13 = HEAP32[$0 + 56 >> 2];
 $12 = HEAPU8[$0 + 12 | 0];
 $5 = HEAPU16[$0 + 24 >> 1];
 $7 = $5;
 label$1: {
  if (($1 | 0) < ($2 | 0)) {
   $7 = pageFreeArray($0, $1, $2 - $1 | 0, $4);
   if (($7 | 0) > ($5 | 0)) {
    $5 = sqlite3CorruptError(74387);
    break label$1;
   }
   $9 = HEAP32[$0 + 64 >> 2];
   memmove($9, ($7 << 1) + $9 | 0, $5 << 1);
   $7 = $5 - $7 | 0;
  }
  $9 = ($3 << 1) + $6 | 0;
  $6 = ($1 + $5 | 0) + $12 | 0;
  $5 = $2 + $3 | 0;
  if (($6 | 0) > ($5 | 0)) {
   $7 = $7 - pageFreeArray($0, $5, $6 - $5 | 0, $4) | 0;
  }
  $10 = $11 + $13 | 0;
  $5 = (((HEAPU8[$10 + 6 | 0] | HEAPU8[$10 + 5 | 0] << 8) - 1 & 65535) + $13 | 0) + 1 | 0;
  HEAP32[$8 + 12 >> 2] = $5;
  label$5: {
   if ($5 >>> 0 < $9 >>> 0 | HEAPU32[$0 + 60 >> 2] < $5 >>> 0) {
    break label$5;
   }
   if (($1 | 0) > ($2 | 0)) {
    $5 = HEAP32[$0 + 64 >> 2];
    $6 = $1 - $2 | 0;
    $6 = ($3 | 0) > ($6 | 0) ? $6 : $3;
    memmove($5 + ($6 << 1) | 0, $5, $7 << 1);
    if (pageInsertArray($0, $9, $8 + 12 | 0, $5, $2, $6, $4)) {
     break label$5;
    }
    $7 = $7 + $6 | 0;
   }
   $5 = 0;
   while (1) {
    if (HEAPU8[$0 + 12 | 0] > $5 >>> 0) {
     $11 = HEAPU16[(($5 << 1) + $0 | 0) + 28 >> 1] + $1 | 0;
     $6 = $11 - $2 | 0;
     if (!(($6 | 0) < 0 | ($3 | 0) <= ($6 | 0))) {
      $12 = HEAP32[$0 + 64 >> 2] + ($6 << 1) | 0;
      if (($7 | 0) > ($6 | 0)) {
       memmove($12 + 2 | 0, $12, $7 - $6 << 1);
      }
      cachedCellSize($4, $11);
      if (pageInsertArray($0, $9, $8 + 12 | 0, $12, $11, 1, $4)) {
       break label$5;
      }
      $7 = $7 + 1 | 0;
     }
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   if (pageInsertArray($0, $9, $8 + 12 | 0, HEAP32[$0 + 64 >> 2] + ($7 << 1) | 0, $2 + $7 | 0, $3 - $7 | 0, $4)) {
    break label$5;
   }
   HEAP8[$0 + 12 | 0] = 0;
   HEAP16[$0 + 24 >> 1] = $3;
   HEAP8[$10 + 3 | 0] = $3 >>> 8;
   HEAP8[$10 + 4 | 0] = HEAPU8[$0 + 24 | 0];
   $0 = HEAP32[$8 + 12 >> 2] - $13 | 0;
   $0 = $0 << 8 | ($0 & 65280) >>> 8;
   HEAP8[$10 + 5 | 0] = $0;
   HEAP8[$10 + 6 | 0] = $0 >>> 8;
   $5 = 0;
   break label$1;
  }
  populateCellCache($4, $2, $3);
  $5 = rebuildPage($4, $2, $3, $0);
 }
 __stack_pointer = $8 + 16 | 0;
 return $5;
}

function sqlite3ViewGetColumnNames($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $2 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$1 + 43 | 0] == 1) {
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] + 1;
   $5 = sqlite3VtabCallConnect($0, $1);
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] - 1;
   break label$1;
  }
  $3 = HEAP16[$1 + 34 >> 1];
  if (($3 | 0) > 0) {
   break label$1;
  }
  if (($3 | 0) < 0) {
   HEAP32[$6 >> 2] = HEAP32[$1 >> 2];
   sqlite3ErrorMsg($0, 15248, $6);
   $5 = 1;
   break label$1;
  }
  $3 = sqlite3SelectDup($2, HEAP32[$1 + 44 >> 2], 0);
  label$4: {
   if (!$3) {
    $5 = 1;
    break label$4;
   }
   $8 = HEAPU8[$0 + 208 | 0];
   HEAP8[$0 + 208 | 0] = 0;
   $9 = HEAP32[$0 + 40 >> 2];
   $10 = HEAP32[$0 + 100 >> 2];
   sqlite3SrcListAssignCursors($0, HEAP32[$3 + 32 >> 2]);
   $7 = $1 + 34 | 0;
   HEAP16[$7 >> 1] = 65535;
   HEAP16[$2 + 308 >> 1] = 0;
   $11 = HEAP32[$2 + 360 >> 2];
   HEAP32[$2 + 360 >> 2] = 0;
   $5 = 1;
   HEAP32[$2 + 304 >> 2] = HEAP32[$2 + 304 >> 2] + 1;
   $4 = sqlite3ResultSetOfSelect($0, $3, 64);
   HEAP32[$2 + 360 >> 2] = $11;
   HEAP32[$0 + 100 >> 2] = $10;
   HEAP32[$0 + 40 >> 2] = $9;
   label$6: {
    if (!$4) {
     HEAP16[$7 >> 1] = 0;
     break label$6;
    }
    $5 = HEAP32[$1 + 16 >> 2];
    if ($5) {
     sqlite3ColumnsFromExprList($0, $5, $7, $1 + 4 | 0);
     $5 = 0;
     if (HEAP32[$0 + 36 >> 2] | HEAP32[HEAP32[$3 + 28 >> 2] >> 2] != HEAP16[$7 >> 1]) {
      break label$6;
     }
     sqlite3SelectAddColumnTypeAndCollation($0, $1, $3, 64);
     break label$6;
    }
    HEAP16[$1 + 34 >> 1] = HEAPU16[$4 + 34 >> 1];
    HEAP32[$1 + 4 >> 2] = HEAP32[$4 + 4 >> 2];
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | HEAP32[$4 + 28 >> 2] & 98;
    $5 = 0;
    HEAP32[$4 + 4 >> 2] = 0;
    HEAP16[$4 + 34 >> 1] = 0;
   }
   HEAP16[$1 + 36 >> 1] = HEAPU16[$1 + 34 >> 1];
   sqlite3DeleteTable($2, $4);
   sqlite3SelectDelete($2, $3);
   $4 = HEAP32[$2 + 304 >> 2] - 1 | 0;
   HEAP32[$2 + 304 >> 2] = $4;
   $3 = 0;
   $3 = $4 ? $3 : HEAPU16[$2 + 310 >> 1];
   HEAP16[$2 + 308 >> 1] = $3;
   HEAP8[$0 + 208 | 0] = $8;
  }
  $0 = HEAP32[$1 + 60 >> 2];
  HEAP16[$0 + 78 >> 1] = HEAPU16[$0 + 78 >> 1] | 2;
  if (!HEAPU8[$2 + 87 | 0]) {
   break label$1;
  }
  sqlite3DeleteColumnNames($2, $1);
 }
 __stack_pointer = $6 + 16 | 0;
 return $5;
}

function balance_quick($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!HEAPU16[$1 + 24 >> 1]) {
   $4 = sqlite3CorruptError(74500);
   break label$1;
  }
  $5 = HEAP32[$1 + 52 >> 2];
  $4 = allocateBtreePage($5, $3 + 92 | 0, $3 + 84 | 0, 0, 0);
  if ($4) {
   break label$1;
  }
  $4 = HEAP32[$1 + 36 >> 2];
  HEAP32[$3 + 80 >> 2] = $4;
  HEAP16[$3 + 78 >> 1] = FUNCTION_TABLE[HEAP32[$1 + 76 >> 2]]($1, $4);
  $6 = HEAP32[$3 + 92 >> 2];
  zeroPage($6, 13);
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = 1;
  HEAP32[$3 + 20 >> 2] = $3 + 78;
  HEAP32[$3 + 16 >> 2] = $3 + 80;
  $4 = HEAP32[$1 + 60 >> 2];
  HEAP32[$3 + 48 >> 2] = 2;
  HEAP32[$3 + 24 >> 2] = $4;
  $4 = rebuildPage($3 + 8 | 0, 0, 1, $6);
  HEAP32[$3 + 88 >> 2] = $4;
  if ($4) {
   releasePage($6);
   break label$1;
  }
  HEAP32[$6 + 20 >> 2] = (HEAP32[$5 + 40 >> 2] - (HEAPU16[$6 + 18 >> 1] + HEAPU16[$3 + 78 >> 1] | 0) | 0) - 2;
  label$4: {
   if (!HEAPU8[$5 + 17 | 0]) {
    break label$4;
   }
   ptrmapPut($5, HEAP32[$3 + 84 >> 2], 5, HEAP32[$0 + 4 >> 2], $3 + 88 | 0);
   if (HEAPU16[$3 + 78 >> 1] <= HEAPU16[$6 + 16 >> 1]) {
    break label$4;
   }
   ptrmapPutOvflPtr($6, $6, HEAP32[$3 + 80 >> 2], $3 + 88 | 0);
  }
  $7 = $2 + 4 | 0;
  $4 = (HEAP32[$1 + 64 >> 2] + (HEAPU16[$1 + 24 >> 1] << 1) | 0) - 2 | 0;
  $8 = HEAP32[$1 + 56 >> 2] + (HEAPU16[$1 + 26 >> 1] & (HEAPU8[$4 | 0] << 8 | HEAPU8[$4 + 1 | 0])) | 0;
  $4 = 0;
  while (1) {
   label$6: {
    $9 = $4 + 1 | 0;
    $5 = $9 + $8 | 0;
    HEAP32[$3 + 80 >> 2] = $5;
    $10 = $4 + $8 | 0;
    if (HEAP8[$10 | 0] >= 0) {
     break label$6;
    }
    $11 = $4 >>> 0 < 8;
    $4 = $9;
    if ($11) {
     continue;
    }
   }
   break;
  }
  $8 = $10 + 10 | 0;
  while (1) {
   label$8: {
    $4 = $5 + 1 | 0;
    HEAP32[$3 + 80 >> 2] = $4;
    $5 = HEAP8[$5 | 0];
    HEAP8[$7 | 0] = $5;
    $7 = $7 + 1 | 0;
    if (($5 | 0) >= 0) {
     break label$8;
    }
    $5 = $4;
    if ($4 >>> 0 < $8 >>> 0) {
     continue;
    }
   }
   break;
  }
  if (!HEAP32[$3 + 88 >> 2]) {
   insertCell($0, HEAPU16[$0 + 24 >> 1], $2, $7 - $2 | 0, 0, HEAP32[$1 + 4 >> 2], $3 + 88 | 0);
  }
  sqlite3Put4byte((HEAPU8[$0 + 9 | 0] + HEAP32[$0 + 56 >> 2] | 0) + 8 | 0, HEAP32[$3 + 84 >> 2]);
  releasePage($6);
  $4 = HEAP32[$3 + 88 >> 2];
 }
 __stack_pointer = $3 + 96 | 0;
 return $4;
}

function renameTableTest($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $4 = __stack_pointer - 304 | 0;
 __stack_pointer = $4;
 $5 = sqlite3_context_db_handle($0);
 $8 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $3 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
 $11 = sqlite3_value_int(HEAP32[$2 + 16 >> 2]);
 $1 = $5;
 $12 = HEAP32[$1 + 32 >> 2];
 $10 = sqlite3_value_text(HEAP32[$2 + 20 >> 2]);
 $9 = sqlite3_value_int(HEAP32[$2 + 24 >> 2]);
 $13 = HEAP32[$1 + 360 >> 2];
 HEAP32[$1 + 360 >> 2] = 0;
 if (!(!$8 | !$3)) {
  $6 = HEAP32[$5 + 32 >> 2];
  $7 = HEAP32[$1 + 36 >> 2];
  if ($9) {
   $1 = $6;
   $9 = $1 & -1610612737;
   $1 = $5;
   HEAP32[$1 + 32 >> 2] = $9;
   HEAP32[$1 + 36 >> 2] = $7;
  }
  $3 = renameParseSql($4 + 32 | 0, $8, $5, $3, $11);
  $1 = HEAP32[$5 + 36 >> 2];
  $7 = $1;
  $1 = HEAP32[$5 + 32 >> 2];
  $6 = $1 | $6 & 1610612736;
  $1 = $5;
  HEAP32[$1 + 32 >> 2] = $6;
  HEAP32[$1 + 36 >> 2] = $7;
  label$3: {
   label$4: {
    if ($3) {
     break label$4;
    }
    $1 = 0;
    $7 = $1;
    label$5: {
     $6 = $12 & 67108864;
     if ($1 | $6) {
      break label$5;
     }
     $3 = HEAP32[$4 + 268 >> 2];
     if (!$3 | HEAPU8[$3 + 43 | 0] != 2) {
      break label$5;
     }
     HEAP32[$4 + 28 >> 2] = 0;
     $1 = $4;
     HEAP32[$1 + 20 >> 2] = 0;
     HEAP32[$1 + 24 >> 2] = 0;
     HEAP32[$1 + 12 >> 2] = 0;
     HEAP32[$1 + 16 >> 2] = 0;
     HEAP32[$1 + 4 >> 2] = 0;
     HEAP32[$1 + 8 >> 2] = 0;
     HEAP32[$1 >> 2] = $1 + 32;
     sqlite3SelectPrep($1 + 32 | 0, HEAP32[$3 + 44 >> 2], $1);
     $3 = HEAP32[$1 + 68 >> 2] ? HEAP32[$1 + 44 >> 2] : 0;
     break label$4;
    }
    $3 = HEAP32[$4 + 276 >> 2];
    if (!$3) {
     break label$3;
    }
    if (!($6 | $7)) {
     $3 = renameResolveTrigger($4 + 32 | 0);
     if ($3) {
      break label$4;
     }
     $3 = HEAP32[$4 + 276 >> 2];
    }
    if ((sqlite3SchemaToIndex($5, HEAP32[$3 + 24 >> 2]) | 0) != (sqlite3FindDbName($5, $8) | 0)) {
     break label$3;
    }
    sqlite3_result_int($0, 1);
    break label$3;
   }
   if (!$3 | !$10) {
    break label$3;
   }
   if (sqlite3WritableSchema($5)) {
    break label$3;
   }
   renameColumnParseError($0, $10, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2], $4 + 32 | 0);
  }
  renameParseCleanup($4 + 32 | 0);
 }
 HEAP32[$5 + 360 >> 2] = $13;
 __stack_pointer = $4 + 304 | 0;
}

function sqlite3CodeSubselect($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $6 = HEAP32[$0 + 8 >> 2];
  $5 = HEAP32[$1 + 20 >> 2];
  $2 = HEAP32[$1 + 4 >> 2];
  if ($2 & 33554432) {
   HEAP32[$4 + 16 >> 2] = HEAP32[$5 + 16 >> 2];
   sqlite3VdbeExplain($0, 0, 16884, $4 + 16 | 0);
   sqlite3VdbeAddOp2($6, 9, HEAP32[$1 + 48 >> 2], HEAP32[$1 + 44 >> 2]);
   $2 = HEAP32[$1 + 28 >> 2];
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = $2 | 33554432;
  $2 = 1;
  $3 = HEAP32[$0 + 44 >> 2] + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $3;
  HEAP32[$1 + 48 >> 2] = $3;
  HEAP32[$1 + 44 >> 2] = sqlite3VdbeAddOp2($6, 74, 0, $3) + 1;
  if (!(HEAPU8[$1 + 4 | 0] & 64)) {
   $7 = sqlite3VdbeAddOp0($6, 14);
  }
  HEAP32[$4 + 4 >> 2] = HEAP32[$5 + 16 >> 2];
  HEAP32[$4 >> 2] = $7 ? 29623 : 29474;
  sqlite3VdbeExplain($0, 1, 16863, $4);
  $3 = HEAPU8[$1 | 0] != 138;
  $2 = $3 ? $2 : HEAP32[HEAP32[$5 + 28 >> 2] >> 2];
  $8 = HEAP32[$0 + 44 >> 2];
  sqlite3SelectDestInit($4 + 32 | 0, 0, $8 + 1 | 0);
  HEAP32[$0 + 44 >> 2] = $2 + $8;
  label$5: {
   if (!$3) {
    HEAP8[$4 + 32 | 0] = 10;
    $3 = HEAP32[$4 + 36 >> 2];
    HEAP32[$4 + 44 >> 2] = $3;
    HEAP32[$4 + 48 >> 2] = $2;
    sqlite3VdbeAddOp3($6, 75, 0, $3, ($2 + $3 | 0) - 1 | 0);
    break label$5;
   }
   HEAP8[$4 + 32 | 0] = 3;
   sqlite3VdbeAddOp2($6, 71, 0, HEAP32[$4 + 36 >> 2]);
  }
  $2 = HEAP32[$0 >> 2];
  label$7: {
   if (HEAP32[$5 + 60 >> 2]) {
    $3 = sqlite3Expr($2, 155, 24241);
    if ($3) {
     HEAP8[$3 + 1 | 0] = 67;
     $3 = sqlite3PExpr($0, 52, sqlite3ExprDup($2, HEAP32[HEAP32[$5 + 60 >> 2] + 12 >> 2], 0), $3);
    } else {
     $3 = 0;
    }
    sqlite3ExprDelete($2, HEAP32[HEAP32[$5 + 60 >> 2] + 12 >> 2]);
    HEAP32[HEAP32[$5 + 60 >> 2] + 12 >> 2] = $3;
    break label$7;
   }
   HEAP32[$5 + 60 >> 2] = sqlite3PExpr($0, 148, sqlite3Expr($2, 155, 23470), 0);
  }
  $2 = 0;
  HEAP32[$5 + 8 >> 2] = 0;
  if (sqlite3Select($0, $5, $4 + 32 | 0)) {
   HEAP8[$1 + 2 | 0] = HEAPU8[$1 | 0];
   HEAP8[$1 | 0] = 182;
   break label$1;
  }
  $2 = HEAP32[$4 + 36 >> 2];
  HEAP32[$1 + 28 >> 2] = $2;
  if ($7) {
   sqlite3VdbeJumpHere($6, $7);
  }
  sqlite3VdbeAddOp3($6, 67, HEAP32[$1 + 48 >> 2], HEAP32[$1 + 44 >> 2], 1);
  sqlite3ClearTempRegCache($0);
 }
 __stack_pointer = $4 - -64 | 0;
 return $2;
}

function fts3PromoteSegments($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $8 = __stack_pointer - 32 | 0;
 __stack_pointer = $8;
 $5 = fts3SqlStmt($0, 37, $8 + 28 | 0, 0);
 label$1: {
  if ($5) {
   break label$1;
  }
  $5 = $2;
  $6 = $5;
  $9 = $1;
  $12 = $9 + 1 | 0;
  $6 = $12 ? $6 : $6 + 1 | 0;
  $7 = HEAP32[$8 + 28 >> 2];
  sqlite3_bind_int64($7, 1, $12, $6);
  $6 = $5;
  $9 = __wasm_i64_sdiv($9, $6, 1024, 0);
  $5 = $9;
  $6 = i64toi32_i32$HIGH_BITS;
  $9 = $6 << 10 | $5 >>> 22;
  $6 = $5 << 10;
  $5 = $9;
  sqlite3_bind_int64($7, 2, $6 | 1023, $5);
  $5 = $4;
  $6 = __wasm_i64_mul($3, $5, 3, 0);
  $5 = i64toi32_i32$HIGH_BITS;
  $6 = __wasm_i64_sdiv($6, $5, 2, 0);
  $12 = $6;
  $5 = i64toi32_i32$HIGH_BITS;
  $13 = $5;
  while (1) {
   label$3: {
    $11 = $10;
    if ((sqlite3_step($7) | 0) != 100) {
     break label$3;
    }
    $6 = $8;
    HEAP32[$6 + 16 >> 2] = 0;
    HEAP32[$6 + 20 >> 2] = 0;
    fts3ReadEndBlockField($7, 2, $6 + 8 | 0, $6 + 16 | 0);
    $11 = 0;
    $5 = HEAP32[$6 + 16 >> 2];
    $3 = $5;
    $6 = HEAP32[$6 + 20 >> 2];
    $4 = $6;
    $9 = $3;
    if (!$9 & ($6 | 0) <= 0 | ($6 | 0) < 0) {
     break label$3;
    }
    $10 = 1;
    $9 = $4;
    $6 = $13;
    $5 = $12;
    if (($9 | 0) <= ($6 | 0) & $3 >>> 0 <= $5 >>> 0 | ($9 | 0) < ($6 | 0)) {
     continue;
    }
   }
   break;
  }
  $5 = sqlite3_reset($7);
  if (!$11) {
   break label$1;
  }
  HEAP32[$8 + 16 >> 2] = 0;
  HEAP32[$8 + 8 >> 2] = 0;
  if ($5) {
   break label$1;
  }
  $5 = fts3SqlStmt($0, 38, $8 + 16 | 0, 0);
  if ($5) {
   break label$1;
  }
  $5 = fts3SqlStmt($0, 39, $8 + 8 | 0, 0);
  if ($5) {
   break label$1;
  }
  sqlite3_bind_int64($7, 1, $1, $2);
  $10 = HEAP32[$8 + 16 >> 2];
  $11 = 0;
  label$4: {
   while (1) {
    if ((sqlite3_step($7) | 0) != 100) {
     break label$4;
    }
    sqlite3_bind_int($10, 1, $11);
    sqlite3_bind_int($10, 2, sqlite3_column_int($7, 0));
    sqlite3_bind_int($10, 3, sqlite3_column_int($7, 1));
    sqlite3_step($10);
    $11 = $11 + 1 | 0;
    $5 = sqlite3_reset($10);
    if (!$5) {
     continue;
    }
    break;
   }
   sqlite3_reset($7);
   break label$1;
  }
  $5 = sqlite3_reset($7);
  if ($5) {
   break label$1;
  }
  $7 = HEAP32[$8 + 8 >> 2];
  sqlite3_bind_int64($7, 1, $1, $2);
  sqlite3_step($7);
  $5 = sqlite3_reset($7);
 }
 __stack_pointer = $8 + 32 | 0;
 return $5;
}

function balance($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $7 = $0 + 124 | 0;
 $1 = HEAP32[$0 + 116 >> 2];
 while (1) {
  label$2: {
   label$3: {
    if (HEAP32[$1 + 20 >> 2] >= 0) {
     break label$3;
    }
    if (!btreeComputeFreeSpace($1)) {
     break label$3;
    }
    $2 = 0;
    break label$2;
   }
   label$4: {
    label$5: {
     if (!HEAPU8[$1 + 12 | 0]) {
      $2 = 0;
      if ((Math_imul(HEAP32[$1 + 20 >> 2], 3) | 0) <= HEAP32[HEAP32[$0 + 20 >> 2] + 40 >> 2] << 1) {
       break label$2;
      }
      $4 = HEAPU8[$0 + 68 | 0];
      if (!$4) {
       break label$2;
      }
      break label$5;
     }
     $4 = HEAPU8[$0 + 68 | 0];
     if ($4) {
      break label$5;
     }
     $2 = anotherValidCursor($0);
     if ($2) {
      break label$2;
     }
     $2 = balance_deeper($1, $7);
     if ($2) {
      break label$2;
     }
     HEAP32[$0 + 120 >> 2] = $1;
     $2 = 0;
     HEAP16[$0 + 70 >> 1] = 0;
     HEAP16[$0 + 72 >> 1] = 0;
     HEAP8[$0 + 68 | 0] = 1;
     $1 = $7;
     break label$4;
    }
    $2 = ($4 << 24 >> 24) - 1 | 0;
    $8 = HEAPU16[(($2 << 1) + $0 | 0) + 72 >> 1];
    $3 = HEAP32[(($2 << 2) + $0 | 0) + 120 >> 2];
    $2 = sqlite3PagerWrite(HEAP32[$3 + 72 >> 2]);
    label$7: {
     if ($2) {
      break label$7;
     }
     if (HEAP32[$3 + 20 >> 2] < 0) {
      $2 = btreeComputeFreeSpace($3);
      if ($2) {
       break label$7;
      }
     }
     label$9: {
      if (!HEAPU8[$1 + 2 | 0] | HEAPU8[$1 + 12 | 0] != 1 | (HEAP32[$3 + 4 >> 2] == 1 | HEAPU16[$1 + 28 >> 1] != HEAPU16[$1 + 24 >> 1])) {
       break label$9;
      }
      if (HEAPU16[$3 + 24 >> 1] != ($8 | 0)) {
       break label$9;
      }
      $2 = balance_quick($3, $1, $6 + 3 | 0);
      break label$7;
     }
     $9 = sqlite3PageMalloc(HEAP32[HEAP32[$0 + 20 >> 2] + 36 >> 2]);
     $2 = balance_nonroot($3, $8, $9, ($4 | 0) == 1, HEAP8[$0 + 3 | 0] & 1);
     if ($5) {
      sqlite3PageFree($5);
     }
     $5 = $9;
    }
    HEAP8[$1 + 12 | 0] = 0;
    releasePage($1);
    $1 = HEAPU8[$0 + 68 | 0] - 1 | 0;
    HEAP8[$0 + 68 | 0] = $1;
    $1 = (($1 << 24 >> 24 << 2) + $0 | 0) + 120 | 0;
   }
   $1 = HEAP32[$1 >> 2];
   HEAP32[$0 + 116 >> 2] = $1;
   if (!$2) {
    continue;
   }
  }
  break;
 }
 if ($5) {
  sqlite3PageFree($5);
 }
 __stack_pointer = $6 + 16 | 0;
 return $2;
}

function fts3PendingListAppend($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 $8 = HEAP32[$0 >> 2];
 HEAP32[$12 + 12 >> 2] = $8;
 $13 = $1;
 $9 = $2;
 $10 = $9;
 label$1: {
  label$2: {
   if ($8) {
    $9 = HEAP32[$8 + 16 >> 2];
    $13 = $9;
    $9 = $2;
    $11 = HEAP32[$8 + 20 >> 2];
    $10 = $11;
    if (($13 | 0) == ($1 | 0) & ($9 | 0) == ($11 | 0)) {
     break label$2;
    }
    HEAP32[$8 >> 2] = HEAP32[$8 >> 2] + 1;
    $9 = $13;
    $13 = $1 - $9 | 0;
    $11 = $10;
    $10 = $11 + ($1 >>> 0 < $9 >>> 0) | 0;
    $10 = $2 - $10 | 0;
   }
   $8 = fts3PendingListAppendVarint($12 + 12 | 0, $13, $10);
   if ($8) {
    break label$1;
   }
   $8 = HEAP32[$12 + 12 >> 2];
   HEAP32[$8 + 32 >> 2] = 0;
   HEAP32[$8 + 36 >> 2] = 0;
   HEAP32[$8 + 24 >> 2] = -1;
   HEAP32[$8 + 28 >> 2] = -1;
   HEAP32[$8 + 16 >> 2] = $1;
   $10 = $2;
   HEAP32[$8 + 20 >> 2] = $10;
  }
  $10 = $4;
  label$4: {
   label$5: {
    if (!!$3 & ($10 | 0) >= 0 | ($10 | 0) > 0) {
     $9 = HEAP32[$8 + 24 >> 2];
     $1 = $3;
     $10 = HEAP32[$8 + 28 >> 2];
     if (($9 | 0) == ($1 | 0) & ($10 | 0) == ($4 | 0)) {
      break label$5;
     }
     $8 = fts3PendingListAppendVarint($12 + 12 | 0, 1, 0);
     if ($8) {
      break label$1;
     }
     $9 = $4;
     $8 = fts3PendingListAppendVarint($12 + 12 | 0, $3, $9);
     if ($8) {
      break label$1;
     }
     $8 = HEAP32[$12 + 12 >> 2];
     HEAP32[$8 + 32 >> 2] = 0;
     HEAP32[$8 + 36 >> 2] = 0;
     HEAP32[$8 + 24 >> 2] = $3;
     HEAP32[$8 + 28 >> 2] = $4;
     break label$5;
    }
    $9 = $4;
    if (($9 | 0) < 0) {
     break label$4;
    }
   }
   $9 = HEAP32[$8 + 36 >> 2];
   $2 = $9;
   $1 = HEAP32[$8 + 32 >> 2];
   $10 = $1;
   $11 = $5 - $10 | 0;
   $9 = $6;
   $1 = $2;
   $13 = $1 + ($5 >>> 0 < $10 >>> 0) | 0;
   $13 = $9 - $13 | 0;
   $9 = $11;
   $11 = $13;
   $1 = $9 + 2 | 0;
   $11 = $1 >>> 0 < 2 ? $11 + 1 | 0 : $11;
   $8 = fts3PendingListAppendVarint($12 + 12 | 0, $1, $11);
   if ($8) {
    break label$1;
   }
   $9 = HEAP32[$12 + 12 >> 2];
   HEAP32[$9 + 32 >> 2] = $5;
   $11 = $6;
   HEAP32[$9 + 36 >> 2] = $11;
  }
  $8 = 0;
 }
 HEAP32[$7 >> 2] = $8;
 __stack_pointer = $12 + 16 | 0;
 $8 = HEAP32[$12 + 12 >> 2];
 if (($8 | 0) == HEAP32[$0 >> 2]) {
  $8 = 0;
 } else {
  HEAP32[$0 >> 2] = $8;
  $8 = 1;
 }
 return $8;
}

function fts3EvalGatherStats($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 label$1: {
  if (HEAP32[$1 + 40 >> 2]) {
   break label$1;
  }
  $8 = HEAP32[$0 + 32 >> 2];
  $3 = HEAP32[$0 + 36 >> 2];
  $9 = $3;
  $6 = HEAP32[$0 >> 2];
  while (1) {
   $2 = $1;
   $1 = HEAP32[$2 + 8 >> 2];
   if (HEAP32[$1 >> 2] == 1 ? $1 : 0) {
    continue;
   }
   break;
  }
  $7 = HEAPU8[$2 + 32 | 0];
  $3 = HEAP32[$2 + 24 >> 2];
  $10 = $3;
  $11 = HEAP32[$2 + 28 >> 2];
  $1 = $2;
  while (1) {
   if ($1) {
    $3 = HEAP32[$1 >> 2] != 5 ? HEAP32[$1 + 16 >> 2] : $1;
    $5 = sqlite3_malloc64(Math_imul(HEAP32[$6 + 24 >> 2], 12), 0);
    HEAP32[$3 + 40 >> 2] = $5;
    if ($5) {
     memset($5, 0, Math_imul(HEAP32[$6 + 24 >> 2], 12));
     $1 = HEAP32[$1 + 12 >> 2];
     continue;
    } else {
     $5 = 7;
     break label$1;
    }
   }
   break;
  }
  fts3EvalRestart($0, $2, $4 + 12 | 0);
  while (1) {
   $5 = HEAP32[$4 + 12 >> 2];
   if (!($5 | HEAPU8[$0 + 6 | 0])) {
    while (1) {
     if (!HEAPU8[$0 + 7 | 0]) {
      sqlite3_reset(HEAP32[$0 + 12 >> 2]);
     }
     fts3EvalNextRow($0, $2, $4 + 12 | 0);
     $1 = HEAPU8[$2 + 32 | 0];
     HEAP32[$0 + 88 >> 2] = 1;
     HEAP8[$0 + 7 | 0] = 1;
     HEAP8[$0 + 6 | 0] = $1;
     $3 = HEAP32[$2 + 28 >> 2];
     HEAP32[$0 + 32 >> 2] = HEAP32[$2 + 24 >> 2];
     HEAP32[$0 + 36 >> 2] = $3;
     if (!(HEAP32[$2 >> 2] != 1 | $1)) {
      if (sqlite3Fts3EvalTestDeferred($0, $4 + 12 | 0)) {
       continue;
      }
     }
     break;
    }
    if (HEAP32[$4 + 12 >> 2] | HEAPU8[$0 + 6 | 0]) {
     continue;
    }
    fts3EvalUpdateCounts($2, HEAP32[$6 + 24 >> 2]);
    continue;
   }
   break;
  }
  HEAP32[$0 + 32 >> 2] = $8;
  $3 = $9;
  HEAP32[$0 + 36 >> 2] = $3;
  HEAP8[$0 + 6 | 0] = 0;
  if ($7) {
   HEAP8[$2 + 32 | 0] = $7;
   break label$1;
  }
  fts3EvalRestart($0, $2, $4 + 12 | 0);
  while (1) {
   fts3EvalNextRow($0, $2, $4 + 12 | 0);
   if (HEAPU8[$2 + 32 | 0]) {
    HEAP32[$4 + 12 >> 2] = 267;
    $5 = 267;
   } else {
    $5 = HEAP32[$4 + 12 >> 2];
   }
   $3 = HEAP32[$2 + 24 >> 2];
   $1 = ($10 | 0) == ($3 | 0);
   $3 = $11;
   if ($1 & ($3 | 0) == HEAP32[$2 + 28 >> 2]) {
    break label$1;
   }
   if (!$5) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function fts3IncrmergeWriter($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 12 >> 2] = 0;
 HEAP32[$10 + 8 >> 2] = 0;
 $7 = fts3SqlStmt($0, 29, $10 + 12 | 0, 0);
 label$1: {
  if ($7) {
   break label$1;
  }
  $7 = HEAP32[$10 + 12 >> 2];
  $6 = $2;
  sqlite3_bind_int64($7, 1, $1, $6);
  $11 = $4;
  $6 = HEAP32[$11 + 4 >> 2];
  $8 = $6 >> 31;
  sqlite3_bind_int64($7, 2, $6, $8);
  if ((sqlite3_step($7) | 0) == 100) {
   $14 = sqlite3_column_int($7, 0);
  }
  $7 = sqlite3_reset($7);
  if ($7) {
   break label$1;
  }
  $7 = fts3SqlStmt($0, 10, $10 + 8 | 0, 0);
  if ($7) {
   break label$1;
  }
  $7 = HEAP32[$10 + 8 >> 2];
  if ((sqlite3_step($7) | 0) == 100) {
   $8 = sqlite3_column_int64($7, 0);
   $13 = $8;
   $6 = i64toi32_i32$HIGH_BITS;
   $15 = $6;
   HEAP32[$5 + 24 >> 2] = $13;
   HEAP32[$5 + 28 >> 2] = $6;
   $8 = $14 << 4;
   $6 = $8 >> 31;
   $9 = $6;
   $11 = $13;
   $12 = $8;
   $4 = $11 + $8 | 0;
   $6 = $15;
   $8 = $9;
   $9 = $6 + $8 | 0;
   $9 = $4 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
   $6 = $4;
   $4 = !$6;
   $4 = $9 - $4 | 0;
   $8 = $6 - 1 | 0;
   $6 = $5;
   HEAP32[$6 + 32 >> 2] = $8;
   HEAP32[$6 + 36 >> 2] = $4;
  }
  $7 = sqlite3_reset($7);
  if ($7) {
   break label$1;
  }
  $4 = HEAP32[$5 + 32 >> 2];
  $6 = HEAP32[$5 + 36 >> 2];
  $7 = fts3WriteSegment($0, $4, $6, 0, 0);
  if ($7) {
   break label$1;
  }
  HEAP32[$5 + 16 >> 2] = $3;
  HEAP32[$5 >> 2] = $14;
  $4 = $5;
  HEAP32[$4 + 8 >> 2] = $1;
  $6 = $2;
  HEAP32[$4 + 12 >> 2] = $6;
  $4 = $14;
  $6 = $4 >> 31;
  $13 = $4;
  $15 = $6;
  $6 = HEAP32[$5 + 24 >> 2];
  $0 = $6;
  $4 = HEAP32[$5 + 28 >> 2];
  $3 = $4;
  $1 = 0;
  $2 = 0;
  while (1) {
   $4 = $2;
   $9 = $1;
   if (!(!$4 & ($9 | 0) == 16)) {
    $9 = $2;
    $4 = $15;
    $4 = __wasm_i64_mul($1, $9, $13, $4);
    $6 = $4;
    $12 = $0;
    $11 = $6 + $12 | 0;
    $9 = i64toi32_i32$HIGH_BITS;
    $4 = $9;
    $9 = $3;
    $8 = $4 + $9 | 0;
    $12 = ($1 << 5) + $5 | 0;
    HEAP32[$12 + 56 >> 2] = $11;
    $8 = $6 >>> 0 > $11 >>> 0 ? $8 + 1 | 0 : $8;
    HEAP32[$12 + 60 >> 2] = $8;
    $8 = $2;
    $9 = $1;
    $4 = $9 + 1 | 0;
    $11 = $4 ? $8 : $8 + 1 | 0;
    $1 = $4;
    $2 = $11;
    continue;
   }
   break;
  }
  $7 = 0;
 }
 __stack_pointer = $10 + 16 | 0;
 return $7;
}

function nodeReaderNext($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$0 + 28 >> 2];
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$5 + 8 >> 2] = 0;
 HEAP32[$5 + 4 >> 2] = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 $4 = HEAP32[$0 + 16 >> 2];
 if (!(!$3 | !($1 | $4))) {
  $4 = $4 + 1 | 0;
  $1 = $4 ? $1 : $1 + 1 | 0;
  HEAP32[$0 + 16 >> 2] = $4;
  HEAP32[$0 + 20 >> 2] = $1;
 }
 $2 = HEAP32[$0 + 8 >> 2];
 $6 = HEAP32[$0 + 4 >> 2];
 label$2: {
  if (($2 | 0) >= ($6 | 0)) {
   $2 = 0;
   HEAP32[$0 >> 2] = 0;
   break label$2;
  }
  $1 = HEAP32[$0 >> 2];
  if ($3) {
   $7 = $2 + $1 | 0;
   $4 = HEAP8[$7 | 0];
   label$5: {
    if (($4 | 0) < 0) {
     $4 = sqlite3Fts3GetVarint32($7, $5 + 12 | 0);
     break label$5;
    }
    HEAP32[$5 + 12 >> 2] = $4 & 255;
    $4 = 1;
   }
   $2 = $4 + $2 | 0;
   HEAP32[$0 + 8 >> 2] = $2;
  }
  $4 = $2 + $1 | 0;
  $1 = HEAP8[$4 | 0];
  label$7: {
   if (($1 | 0) < 0) {
    $1 = sqlite3Fts3GetVarint32($4, $5 + 8 | 0);
    break label$7;
   }
   HEAP32[$5 + 8 >> 2] = $1 & 255;
   $1 = 1;
  }
  $1 = $1 + $2 | 0;
  HEAP32[$0 + 8 >> 2] = $1;
  $2 = 267;
  $4 = HEAP32[$5 + 12 >> 2];
  if (($4 | 0) > ($3 | 0)) {
   break label$2;
  }
  $3 = HEAP32[$5 + 8 >> 2];
  if (($3 | 0) > ($6 - $1 | 0) | !$3) {
   break label$2;
  }
  $1 = $0 + 24 | 0;
  $6 = $3 + $4 | 0;
  blobGrowBuffer($1, $6, $5 + 4 | 0);
  $2 = HEAP32[$5 + 4 >> 2];
  if ($2) {
   break label$2;
  }
  $2 = 0;
  $1 = HEAP32[$0 + 24 >> 2];
  if (!$1) {
   break label$2;
  }
  __memcpy($1 + $4 | 0, HEAP32[$0 >> 2] + HEAP32[$0 + 8 >> 2] | 0, $3);
  HEAP32[$0 + 28 >> 2] = $6;
  $3 = HEAP32[$0 + 8 >> 2] + $3 | 0;
  HEAP32[$0 + 8 >> 2] = $3;
  $1 = HEAP32[$0 + 16 >> 2];
  if (HEAP32[$0 + 20 >> 2] | $1) {
   break label$2;
  }
  $1 = HEAP32[$0 >> 2] + $3 | 0;
  $2 = HEAP8[$1 | 0];
  label$9: {
   if (($2 | 0) < 0) {
    $2 = sqlite3Fts3GetVarint32($1, $0 + 40 | 0);
    $1 = HEAP32[$0 + 40 >> 2];
    $3 = HEAP32[$0 + 8 >> 2];
    break label$9;
   }
   $1 = $2 & 255;
   HEAP32[$0 + 40 >> 2] = $1;
   $2 = 1;
  }
  $3 = $2 + $3 | 0;
  HEAP32[$0 + 8 >> 2] = $3;
  $2 = 267;
  if ((HEAP32[$0 + 4 >> 2] - $3 | 0) < ($1 | 0)) {
   break label$2;
  }
  HEAP32[$0 + 8 >> 2] = $3 + $1;
  HEAP32[$0 + 36 >> 2] = HEAP32[$0 >> 2] + $3;
  $2 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $2;
}

function fts3SegReaderCursor($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $10 = __stack_pointer - 32 | 0;
 __stack_pointer = $10;
 HEAP32[$10 + 28 >> 2] = 0;
 label$1: {
  label$2: {
   if (($3 | 0) < 0) {
    label$4: {
     if (!HEAP32[$0 + 260 >> 2] | HEAP32[$0 + 280 >> 2] != ($1 | 0)) {
      break label$4;
     }
     HEAP32[$10 + 16 >> 2] = 0;
     $9 = sqlite3Fts3SegReaderPending($0, $2, $4, $5, ($6 | $7) != 0, $10 + 16 | 0);
     if ($9) {
      break label$4;
     }
     $11 = HEAP32[$10 + 16 >> 2];
     if (!$11) {
      break label$4;
     }
     $9 = fts3SegReaderCursorAppend($8, $11);
    }
    $11 = 0;
    if (($3 | 0) == -1) {
     break label$1;
    }
    if ($9) {
     break label$2;
    }
   }
   $9 = sqlite3Fts3AllSegdirs($0, $1, $2, $3, $10 + 28 | 0);
   $11 = HEAP32[$10 + 28 >> 2];
  }
  $1 = $6 ? $10 + 8 | 0 : 0;
  $2 = $6 | $7;
  $7 = !$2;
  while (1) {
   if ($9) {
    break label$1;
   }
   $9 = sqlite3_step($11);
   if (($9 | 0) != 100) {
    break label$1;
   }
   HEAP32[$10 + 24 >> 2] = 0;
   $9 = sqlite3_column_int64($11, 1);
   HEAP32[$10 + 16 >> 2] = $9;
   HEAP32[$10 + 20 >> 2] = i64toi32_i32$HIGH_BITS;
   HEAP32[$10 + 8 >> 2] = sqlite3_column_int64($11, 2);
   $9 = i64toi32_i32$HIGH_BITS;
   HEAP32[$10 + 12 >> 2] = $9;
   $9 = sqlite3_column_int64($11, 3);
   $14 = $9;
   $15 = i64toi32_i32$HIGH_BITS;
   $6 = sqlite3_column_bytes($11, 4);
   $3 = sqlite3_column_blob($11, 4);
   $9 = HEAP32[$10 + 20 >> 2];
   $13 = $9;
   $12 = HEAP32[$10 + 16 >> 2];
   label$6: {
    if (!$3 | (!$4 | !($9 | $12))) {
     break label$6;
    }
    $9 = fts3SelectLeaf($0, $4, $5, $3, $6, $10 + 16 | 0, $1);
    if ($9) {
     break label$1;
    }
    $9 = HEAP32[$10 + 16 >> 2];
    $12 = $9;
    $13 = HEAP32[$10 + 20 >> 2];
    if ($2) {
     break label$6;
    }
    HEAP32[$10 + 8 >> 2] = $12;
    HEAP32[$10 + 12 >> 2] = $13;
   }
   $9 = HEAP32[$10 + 12 >> 2];
   $16 = $9;
   $9 = $13;
   $9 = sqlite3Fts3SegReaderNew(HEAP32[$8 + 4 >> 2] + 1 | 0, $7, $12, $9, HEAP32[$10 + 8 >> 2], $16, $14, $15, $3, $6, $10 + 24 | 0);
   if ($9) {
    break label$1;
   }
   $9 = fts3SegReaderCursorAppend($8, HEAP32[$10 + 24 >> 2]);
   continue;
  }
 }
 $11 = sqlite3_reset($11);
 __stack_pointer = $10 + 32 | 0;
 return ($9 | 0) == 101 ? $11 : $9;
}

function getNextToken($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 $8 = ($3 | 0) > 0 ? $3 : 0;
 $10 = HEAP32[$0 >> 2];
 $11 = HEAP32[$10 >> 2];
 label$1: {
  label$2: {
   while (1) {
    label$4: {
     label$5: {
      if (($7 | 0) != ($8 | 0)) {
       $9 = HEAPU8[$2 + $7 | 0] - 34 | 0;
       if ($9 >>> 0 > 7 | !(1 << $9 & 193)) {
        break label$5;
       }
       $8 = $7;
      }
      HEAP32[$5 >> 2] = $8;
      $7 = 0;
      $10 = sqlite3Fts3OpenTokenizer($10, HEAP32[$0 + 4 >> 2], $2, $8, $6 + 28 | 0);
      if ($10) {
       break label$1;
      }
      HEAP32[$6 + 20 >> 2] = 0;
      HEAP32[$6 + 16 >> 2] = 0;
      HEAP32[$6 + 12 >> 2] = 0;
      HEAP32[$6 + 8 >> 2] = 0;
      $12 = HEAP32[$6 + 28 >> 2];
      $9 = FUNCTION_TABLE[HEAP32[$11 + 20 >> 2]]($12, $6 + 24 | 0, $6 + 20 | 0, $6 + 16 | 0, $6 + 12 | 0, $6 + 8 | 0) | 0;
      if (!$9) {
       $7 = sqlite3Fts3MallocZero(HEAP32[$6 + 20 >> 2] + 144 | 0, 0);
       if (!$7) {
        $10 = 7;
        $8 = HEAP32[$6 + 12 >> 2];
        break label$4;
       }
       HEAP32[$7 >> 2] = 5;
       HEAP32[$7 + 116 >> 2] = $1;
       HEAP32[$7 + 112 >> 2] = 1;
       HEAP32[$7 + 20 >> 2] = $7 + 48;
       $9 = HEAP32[$6 + 20 >> 2];
       $8 = $7 + 144 | 0;
       HEAP32[$7 + 120 >> 2] = $8;
       HEAP32[$7 + 124 >> 2] = $9;
       __memcpy($8, HEAP32[$6 + 24 >> 2], $9);
       $8 = HEAP32[$6 + 12 >> 2];
       if (!(($8 | 0) >= ($3 | 0) | HEAPU8[$2 + $8 | 0] != 42)) {
        HEAP32[$7 + 128 >> 2] = 1;
        $8 = $8 + 1 | 0;
        HEAP32[$6 + 12 >> 2] = $8;
       }
       $10 = 0;
       if (!HEAP32[$0 + 12 >> 2]) {
        break label$4;
       }
       $9 = HEAP32[$6 + 16 >> 2];
       while (1) {
        if (($9 | 0) <= 0) {
         break label$4;
        }
        $9 = $9 - 1 | 0;
        if (HEAPU8[$9 + $2 | 0] != 94) {
         break label$4;
        }
        HEAP32[$7 + 132 >> 2] = 1;
        HEAP32[$6 + 16 >> 2] = $9;
        continue;
       }
      }
      $10 = $8 ? ($9 | 0) == 101 ? 0 : $9 : $9;
      break label$2;
     }
     $7 = $7 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$5 >> 2] = $8;
  }
  FUNCTION_TABLE[HEAP32[$11 + 16 >> 2]]($12) | 0;
 }
 HEAP32[$4 >> 2] = $7;
 __stack_pointer = $6 + 32 | 0;
 return $10;
}

function sqlite3Step($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   $1 = HEAPU8[$0 + 149 | 0];
   if (($1 | 0) == 2) {
    break label$2;
   }
   while (1) {
    label$4: {
     switch (($1 & 255) - 1 | 0) {
     case 0:
      if (HEAPU8[$0 + 150 | 0] & 3) {
       HEAP32[$0 + 36 >> 2] = 17;
       $1 = 1;
       if (HEAP8[$0 + 148 | 0] >= 0) {
        break label$1;
       }
       $1 = sqlite3VdbeTransferError($0);
       break label$1;
      }
      $1 = HEAP32[$2 + 184 >> 2];
      if (!$1) {
       HEAP32[$2 + 296 >> 2] = 0;
      }
      if (!(!HEAP32[$0 + 196 >> 2] | (HEAPU8[$2 + 177 | 0] | !(HEAPU8[$2 + 94 | 0] & 130)))) {
       sqlite3OsCurrentTimeInt64(HEAP32[$2 >> 2], $0 + 136 | 0);
       $1 = HEAP32[$2 + 184 >> 2];
      }
      HEAP32[$2 + 184 >> 2] = $1 + 1;
      $1 = HEAPU8[$0 + 150 | 0];
      if (!($1 & 64)) {
       HEAP32[$2 + 192 >> 2] = HEAP32[$2 + 192 >> 2] + 1;
       $1 = HEAPU8[$0 + 150 | 0];
      }
      if ($1 << 24 >> 24 < 0) {
       HEAP32[$2 + 188 >> 2] = HEAP32[$2 + 188 >> 2] + 1;
      }
      HEAP8[$0 + 149 | 0] = 2;
      HEAP32[$0 + 32 >> 2] = 0;
      break label$2;

     case 2:
      break label$4;

     default:
      break label$2;
     }
    }
    sqlite3_reset($0);
    $1 = HEAPU8[$0 + 149 | 0];
    continue;
   }
  }
  label$11: {
   if (HEAPU8[$0 + 150 | 0] & 12) {
    $3 = sqlite3VdbeList($0);
    break label$11;
   }
   HEAP32[$2 + 196 >> 2] = HEAP32[$2 + 196 >> 2] + 1;
   $3 = sqlite3VdbeExec($0);
   HEAP32[$2 + 196 >> 2] = HEAP32[$2 + 196 >> 2] - 1;
  }
  if (($3 | 0) == 100) {
   HEAP32[$2 + 64 >> 2] = 100;
   return 100;
  }
  $1 = HEAP32[$0 + 140 >> 2];
  if (!!HEAP32[$0 + 136 >> 2] & ($1 | 0) >= 0 | ($1 | 0) > 0) {
   invokeProfileCallback($2, $0);
  }
  $1 = 101;
  label$15: {
   if (($3 | 0) == 101) {
    if (!HEAPU8[$2 + 85 | 0]) {
     break label$15;
    }
    $1 = doWalCallbacks($2);
    HEAP32[$0 + 36 >> 2] = $1;
    $1 = $1 ? 1 : 101;
    break label$15;
   }
   $1 = $3;
   if (HEAP8[$0 + 148 | 0] >= 0) {
    break label$15;
   }
   $1 = sqlite3VdbeTransferError($0);
  }
  HEAP32[$2 + 64 >> 2] = $1;
  if ((sqlite3ApiExit(HEAP32[$0 >> 2], HEAP32[$0 + 36 >> 2]) | 0) != 7) {
   break label$1;
  }
  HEAP32[$0 + 36 >> 2] = 7;
  $1 = HEAP8[$0 + 148 | 0] >= 0 ? $1 : 7;
 }
 return HEAP32[$2 + 72 >> 2] & $1;
}

function fts3GetMatchinfo($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 $7 = HEAP32[$1 >> 2];
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 40 >> 2] = 0;
 HEAP32[$3 + 44 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 16 >> 2] = $1;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = HEAP32[$7 + 24 >> 2];
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     $4 = HEAP32[$1 + 92 >> 2];
     label$5: {
      label$6: {
       if ($4) {
        if (!strcmp(HEAP32[$4 + 12 >> 2], $2)) {
         $5 = 1;
         break label$6;
        }
        sqlite3Fts3MIBufferFree($4);
        HEAP32[$1 + 92 >> 2] = 0;
       }
       $4 = fts3ExprPhraseCount(HEAP32[$1 + 16 >> 2]);
       HEAP32[$1 + 24 >> 2] = $4;
       HEAP32[$3 + 24 >> 2] = $4;
       $4 = 0;
       label$9: {
        while (1) {
         $8 = $2 + $4 | 0;
         $5 = HEAPU8[$8 | 0];
         if (!$5) {
          break label$9;
         }
         HEAP32[$3 + 8 >> 2] = 0;
         if (!fts3MatchinfoCheck($7, $5 << 24 >> 24, $3 + 8 | 0)) {
          $4 = $4 + 1 | 0;
          $6 = fts3MatchinfoSize($3 + 16 | 0, HEAP8[$8 | 0]) + $6 | 0;
          continue;
         }
         break;
        }
        $4 = HEAP32[$3 + 8 >> 2];
        sqlite3_result_error($0, $4, -1);
        sqlite3_free($4);
        break label$1;
       }
       $8 = 1;
       $4 = fts3MIBufferNew($6, $2);
       HEAP32[$1 + 88 >> 2] = 1;
       HEAP32[$1 + 92 >> 2] = $4;
       $5 = 0;
       if (!$4) {
        break label$5;
       }
      }
      $6 = fts3MIBufferAlloc($4, $3 + 12 | 0);
      if ($6) {
       break label$4;
      }
     }
     $4 = 7;
     $1 = 0;
     break label$3;
    }
    $7 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 44 >> 2] = $7;
    HEAP32[$3 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
    $4 = fts3MatchinfoValues($1, $8, $3 + 16 | 0, $2);
    if (!$5) {
     fts3MIBufferSetGlobal(HEAP32[$1 + 92 >> 2]);
    }
    if (!$4) {
     break label$2;
    }
    $1 = $6;
   }
   $5 = $1;
   sqlite3_result_error_code($0, $4);
   if (!$5) {
    break label$1;
   }
   FUNCTION_TABLE[$5 | 0](HEAP32[$3 + 12 >> 2]);
   break label$1;
  }
  sqlite3_result_blob($0, $7, HEAP32[HEAP32[$1 + 92 >> 2] + 4 >> 2] << 2, $6);
 }
 __stack_pointer = $3 + 48 | 0;
}

function codeVectorCompare($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $10 = HEAP32[$1 + 16 >> 2];
 $6 = HEAP32[$0 + 8 >> 2];
 $11 = HEAP32[$1 + 12 >> 2];
 $7 = sqlite3ExprVectorSize($11);
 $8 = sqlite3VdbeMakeLabel($0);
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $1 = HEAP32[$1 + 4 >> 2];
  if ((sqlite3ExprVectorSize($10) | 0) != ($7 | 0)) {
   sqlite3ErrorMsg($0, 14966, 0);
   break label$1;
  }
  $16 = $1 >>> 10 & 1;
  $17 = exprCodeSubselect($0, $11);
  $18 = exprCodeSubselect($0, $10);
  sqlite3VdbeAddOp2($6, 71, 1, $2);
  $9 = ($3 | 0) == 52 ? 53 : ($3 | 0) == 57 ? 54 : ($3 | 0) == 55 ? 56 : $3;
  $19 = $7 - 2 | 0;
  $13 = $7 - 1 | 0;
  $20 = ($4 | 0) != 128;
  $7 = 0;
  $1 = 0;
  while (1) {
   HEAP32[$5 + 12 >> 2] = 0;
   HEAP32[$5 + 8 >> 2] = 0;
   HEAP32[$5 + 4 >> 2] = 0;
   HEAP32[$5 >> 2] = 0;
   if ($7) {
    sqlite3VdbeJumpHere($6, $7);
   }
   $14 = exprVectorRegister($0, $11, $1, $17, $5 + 4 | 0, $5 + 12 | 0);
   $15 = exprVectorRegister($0, $10, $1, $18, $5, $5 + 8 | 0);
   $7 = sqlite3VdbeCurrentAddr($6);
   $12 = $9 & 255;
   codeCompare($0, HEAP32[$5 + 4 >> 2], HEAP32[$5 >> 2], $12, $14, $15, $8, $4, $16);
   sqlite3ReleaseTempReg($0, HEAP32[$5 + 12 >> 2]);
   sqlite3ReleaseTempReg($0, HEAP32[$5 + 8 >> 2]);
   label$5: {
    label$6: {
     switch ($12 - 54 | 0) {
     case 0:
     case 2:
      break label$6;

     default:
      break label$5;
     }
    }
    if (($1 | 0) >= ($13 | 0)) {
     break label$5;
    }
    $7 = sqlite3VdbeAddOp0($6, 58);
   }
   label$7: {
    if (!$20) {
     sqlite3VdbeAddOp2($6, 71, 0, $2);
     break label$7;
    }
    sqlite3VdbeAddOp3($6, 92, $14, $2, $15);
   }
   if (($1 | 0) != ($13 | 0)) {
    label$10: {
     if (($12 | 0) == 53) {
      sqlite3VdbeAddOp2($6, 51, $2, $8);
      $9 = 53;
      break label$10;
     }
     sqlite3VdbeAddOp2($6, 8, 0, $8);
     $9 = ($1 | 0) == ($19 | 0) ? $3 : $9;
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3VdbeJumpHere($6, $7);
  sqlite3VdbeResolveLabel($6, $8);
  if (($3 | 0) != 52) {
   break label$1;
  }
  sqlite3VdbeAddOp2($6, 19, $2, $2);
 }
 __stack_pointer = $5 + 16 | 0;
}

function ntileValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 label$1: {
  $3 = sqlite3_aggregate_context($0, 24);
  if (!$3) {
   break label$1;
  }
  $1 = $3;
  $5 = HEAP32[$1 + 8 >> 2];
  $6 = $5;
  $2 = HEAP32[$1 + 12 >> 2];
  $9 = $2;
  $1 = $6;
  if (!$1 & ($2 | 0) <= 0 | ($2 | 0) < 0) {
   break label$1;
  }
  $14 = $0;
  $0 = $3;
  $1 = HEAP32[$0 >> 2];
  $10 = $1;
  $2 = HEAP32[$0 + 4 >> 2];
  $11 = $2;
  $1 = $9;
  $1 = __wasm_i64_sdiv($10, $2, $6, $1);
  $7 = $1;
  $2 = i64toi32_i32$HIGH_BITS;
  $8 = $2;
  label$2: {
   if (!$1) {
    $2 = HEAP32[$3 + 16 >> 2];
    $1 = HEAP32[$0 + 20 >> 2];
    $0 = $2;
    $3 = $0 + 1 | 0;
    $4 = $3 ? $1 : $1 + 1 | 0;
    $2 = $3;
    $5 = $4;
    break label$2;
   }
   $1 = $3;
   $4 = HEAP32[$1 + 16 >> 2];
   $12 = $4;
   $0 = HEAP32[$1 + 20 >> 2];
   $13 = $0;
   $1 = $7;
   $4 = $1;
   $7 = 0;
   $8 = $1;
   $15 = $1;
   $1 = $1 >> 31;
   $16 = $1;
   $0 = $9;
   $0 = __wasm_i64_mul($4, $1, $6, $0);
   $1 = i64toi32_i32$HIGH_BITS;
   $3 = $1;
   $4 = $10;
   $5 = $0;
   $2 = $4 - $0 | 0;
   $10 = $2;
   $1 = $11;
   $0 = $3;
   $3 = $0 + ($4 >>> 0 < $5 >>> 0) | 0;
   $3 = $1 - $3 | 0;
   $11 = $3;
   $3 = $8;
   $2 = $3 + 1 | 0;
   $1 = $7;
   $6 = $2;
   $1 = $2 >> 31;
   $9 = $1;
   $1 = $11;
   $3 = $9;
   $3 = __wasm_i64_mul($10, $1, $2, $3);
   $7 = $3;
   $1 = i64toi32_i32$HIGH_BITS;
   $8 = $1;
   $1 = $13;
   $3 = $8;
   $5 = $7;
   $2 = $12;
   if (($1 | 0) <= ($3 | 0) & $5 >>> 0 > $2 >>> 0 | ($1 | 0) < ($3 | 0)) {
    $2 = $13;
    $1 = $9;
    $1 = __wasm_i64_sdiv($12, $2, $6, $1);
    $5 = $1;
    $2 = i64toi32_i32$HIGH_BITS;
    $4 = $5 + 1 | 0;
    $0 = $4 ? $2 : $2 + 1 | 0;
    $2 = $4;
    $5 = $0;
    break label$2;
   }
   $3 = $7;
   $1 = $12 - $3 | 0;
   $0 = $13;
   $5 = $8;
   $4 = $5 + ($2 >>> 0 < $3 >>> 0) | 0;
   $4 = $0 - $4 | 0;
   $2 = $16;
   $2 = __wasm_i64_sdiv($1, $4, $15, $2);
   $3 = $2;
   $4 = i64toi32_i32$HIGH_BITS;
   $2 = $4;
   $4 = $11;
   $1 = $2 + $4 | 0;
   $0 = $10;
   $5 = $0 + $3 | 0;
   $1 = $5 >>> 0 < $3 >>> 0 ? $1 + 1 | 0 : $1;
   $4 = $5;
   $2 = $4 + 1 | 0;
   $5 = $2 ? $1 : $1 + 1 | 0;
  }
  $6 = $2;
  sqlite3_result_int64($14, $6, $5);
 }
}

function whereOmitNoopJoin($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $3 = $0 + 504 | 0;
 $5 = sqlite3WhereExprListUsage($3, HEAP32[$0 + 12 >> 2]);
 $8 = $5;
 $1 = i64toi32_i32$HIGH_BITS;
 $9 = $1;
 $4 = HEAP32[$0 + 8 >> 2];
 if ($4) {
  $1 = sqlite3WhereExprListUsage($3, $4);
  $8 = $8 | $1;
  $5 = i64toi32_i32$HIGH_BITS;
  $1 = $9;
  $1 = $5 | $1;
  $9 = $1;
 }
 $6 = HEAPU8[$0 + 48 | 0];
 $10 = $6;
 $11 = -1;
 $12 = -1;
 label$2: while (1) {
  $7 = $10;
  if (($7 | 0) >= 2) {
   $10 = $7 - 1 | 0;
   $15 = Math_imul($10, 96) + $0 | 0;
   $3 = HEAP32[$15 + 848 >> 2];
   $4 = HEAP32[$0 + 4 >> 2] + (HEAPU8[$3 + 16 | 0] << 6) | 0;
   if ((HEAPU8[$4 + 44 | 0] & 24) != 8 | !(HEAPU8[$3 + 41 | 0] & 16 ? 1 : HEAP8[$0 + 45 | 0] & 1)) {
    continue;
   }
   $1 = HEAP32[$3 + 8 >> 2];
   $13 = $1;
   $5 = $1;
   $1 = $9;
   $2 = HEAP32[$3 + 12 >> 2];
   $14 = $2;
   $1 = $1 & $2;
   $2 = $5 & $8;
   if ($1 | $2) {
    continue;
   }
   $17 = $4;
   $3 = HEAP32[$0 + 112 >> 2];
   $16 = $3 + Math_imul(HEAP32[$0 + 100 >> 2], 48) | 0;
   $4 = $3;
   while (1) {
    if ($4 >>> 0 < $16 >>> 0) {
     $5 = $13;
     $2 = HEAP32[$4 + 40 >> 2];
     $5 = $5 & $2;
     $1 = HEAP32[$4 + 44 >> 2];
     $2 = $14;
     $2 = $1 & $2;
     if ($5 | $2) {
      $1 = HEAP32[$4 >> 2];
      if (!(HEAP8[$1 + 4 | 0] & 1) | HEAP32[$1 + 36 >> 2] != HEAP32[$17 + 48 >> 2]) {
       continue label$2;
      }
     }
     $4 = $4 + 48 | 0;
     continue;
    }
    break;
   }
   $4 = $15 + 768 | 0;
   while (1) {
    if ($3 >>> 0 < $16 >>> 0) {
     $5 = $13;
     $2 = HEAP32[$3 + 40 >> 2];
     $1 = $2;
     $2 = $14;
     $2 = $2 & HEAP32[$3 + 44 >> 2];
     if ($5 & $1 | $2) {
      HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 4;
     }
     $3 = $3 + 48 | 0;
     continue;
    }
    break;
   }
   $2 = $14;
   $1 = $2 ^ -1;
   $5 = $11;
   $2 = $13 ^ -1;
   $11 = $5 & $2;
   $12 = $12 & $1;
   $3 = $6 & 255;
   if (($7 | 0) != ($3 | 0)) {
    memmove($4, (Math_imul($7, 96) + $0 | 0) + 768 | 0, Math_imul($3 - $7 | 0, 96));
    $6 = HEAPU8[$0 + 48 | 0];
   }
   $6 = $6 - 1 | 0;
   HEAP8[$0 + 48 | 0] = $6;
   continue;
  }
  break;
 }
 i64toi32_i32$HIGH_BITS = $12;
 $2 = $11;
 return $2;
}

function clearDatabasePage($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 label$1: {
  if (btreePagecount($0) >>> 0 < $1 >>> 0) {
   $5 = sqlite3CorruptError(76666);
   break label$1;
  }
  $5 = getAndInitPage($0, $1, $6 + 28 | 0, 0, 0);
  if ($5) {
   break label$1;
  }
  $4 = HEAP32[$6 + 28 >> 2];
  label$3: {
   label$4: {
    if (HEAPU8[$0 + 16 | 0] & 4) {
     break label$4;
    }
    if ((sqlite3PagerPageRefcount(HEAP32[$4 + 72 >> 2]) | 0) == ((($1 | 0) == 1 ? 2 : 1) | 0)) {
     break label$4;
    }
    $5 = sqlite3CorruptError(76673);
    break label$3;
   }
   $8 = HEAPU8[$4 + 9 | 0];
   $1 = 0;
   while (1) {
    $7 = HEAPU16[$4 + 24 >> 1];
    if ($7 >>> 0 > $1 >>> 0) {
     $7 = HEAP32[$4 + 64 >> 2] + ($1 << 1) | 0;
     $7 = HEAP32[$4 + 56 >> 2] + (HEAPU16[$4 + 26 >> 1] & (HEAPU8[$7 | 0] << 8 | HEAPU8[$7 + 1 | 0])) | 0;
     if (!HEAPU8[$4 + 8 | 0]) {
      $5 = clearDatabasePage($0, sqlite3Get4byte($7), 1, $3);
      if ($5) {
       break label$3;
      }
     }
     FUNCTION_TABLE[HEAP32[$4 + 80 >> 2]]($4, $7, $6);
     if (HEAP32[$6 + 12 >> 2] != HEAPU16[$6 + 16 >> 1]) {
      $5 = clearCellOverflow($4, $7, $6);
      if ($5) {
       break label$3;
      }
     }
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$6 + 24 >> 2] = 0;
   label$9: {
    label$10: {
     if (!HEAPU8[$4 + 8 | 0]) {
      $5 = clearDatabasePage($0, sqlite3Get4byte((HEAP32[$4 + 56 >> 2] + $8 | 0) + 8 | 0), 1, $3);
      HEAP32[$6 + 24 >> 2] = $5;
      if ($5) {
       break label$3;
      }
      if (HEAPU8[$4 + 1 | 0] | !$3) {
       break label$9;
      }
      $7 = HEAPU16[$4 + 24 >> 1];
      break label$10;
     }
     if (!$3) {
      break label$9;
     }
    }
    $0 = HEAP32[$3 + 4 >> 2];
    $1 = $7 & 65535;
    $5 = $1 + HEAP32[$3 >> 2] | 0;
    HEAP32[$3 >> 2] = $5;
    $0 = $1 >>> 0 > $5 >>> 0 ? $0 + 1 | 0 : $0;
    HEAP32[$3 + 4 >> 2] = $0;
   }
   if ($2) {
    freePage($4, $6 + 24 | 0);
    $5 = HEAP32[$6 + 24 >> 2];
    break label$3;
   }
   $5 = sqlite3PagerWrite(HEAP32[$4 + 72 >> 2]);
   if ($5) {
    break label$3;
   }
   zeroPage($4, HEAPU8[HEAP32[$4 + 56 >> 2] + $8 | 0] | 8);
   $5 = 0;
  }
  releasePage($4);
 }
 __stack_pointer = $6 + 32 | 0;
 return $5;
}

function writeSuperJournal($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  if (!$1 | HEAPU8[$0 + 5 | 0] == 4) {
   break label$1;
  }
  $2 = HEAP32[$0 + 68 >> 2];
  if (!HEAP32[$2 >> 2]) {
   break label$1;
  }
  HEAP8[$0 + 20 | 0] = 1;
  while (1) {
   $5 = HEAP8[$1 + $8 | 0];
   if ($5) {
    $8 = $8 + 1 | 0;
    $10 = $5 + $10 | 0;
    continue;
   }
   break;
  }
  label$4: {
   if (!HEAPU8[$0 + 8 | 0]) {
    $6 = HEAP32[$0 + 80 >> 2];
    $7 = $6;
    $3 = HEAP32[$0 + 84 >> 2];
    $4 = $3;
    break label$4;
   }
   $3 = journalHdrOffset($0);
   $7 = $3;
   $6 = i64toi32_i32$HIGH_BITS;
   $4 = $6;
   HEAP32[$0 + 80 >> 2] = $7;
   HEAP32[$0 + 84 >> 2] = $6;
  }
  $6 = $4;
  $5 = write32bits($2, $7, $6, HEAP32[$0 + 164 >> 2]);
  if ($5) {
   break label$1;
  }
  $2 = $7 + 4 | 0;
  $4 = $2 >>> 0 < 4 ? $4 + 1 | 0 : $4;
  $7 = $2;
  $5 = sqlite3OsWrite(HEAP32[$0 + 68 >> 2], $1, $8, $2, $4);
  if ($5) {
   break label$1;
  }
  $2 = $4;
  $6 = $7;
  $3 = $6 + $8 | 0;
  $2 = $3 >>> 0 < $8 >>> 0 ? $2 + 1 | 0 : $2;
  $7 = $3;
  $4 = $2;
  $5 = write32bits(HEAP32[$0 + 68 >> 2], $3, $2, $8);
  if ($5) {
   break label$1;
  }
  $3 = $4;
  $1 = $7 + 4 | 0;
  $3 = $1 >>> 0 < 4 ? $3 + 1 | 0 : $3;
  $5 = write32bits(HEAP32[$0 + 68 >> 2], $1, $3, $10);
  if ($5) {
   break label$1;
  }
  $3 = $4;
  $2 = $7;
  $6 = $2 + 8 | 0;
  $1 = $6 >>> 0 < 8 ? $3 + 1 | 0 : $3;
  $5 = sqlite3OsWrite(HEAP32[$0 + 68 >> 2], 32260, 8, $6, $1);
  if ($5) {
   break label$1;
  }
  $2 = HEAP32[$0 + 84 >> 2];
  $1 = HEAP32[$0 + 80 >> 2];
  $3 = $1;
  $1 = $8 + 20 | 0;
  $4 = $3 + $1 | 0;
  HEAP32[$0 + 80 >> 2] = $4;
  $6 = $4 >>> 0 < $1 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$0 + 84 >> 2] = $6;
  $5 = sqlite3OsFileSize(HEAP32[$0 + 68 >> 2], $9 + 8 | 0);
  if ($5) {
   break label$1;
  }
  $5 = 0;
  $6 = HEAP32[$0 + 80 >> 2];
  $7 = $6;
  $3 = HEAP32[$0 + 84 >> 2];
  $4 = $3;
  $2 = $9;
  $3 = HEAP32[$2 + 8 >> 2];
  $6 = HEAP32[$2 + 12 >> 2];
  $1 = $3;
  $2 = $7;
  $3 = $6;
  if ($1 >>> 0 <= $2 >>> 0 & ($4 | 0) >= ($3 | 0) | ($3 | 0) < ($4 | 0)) {
   break label$1;
  }
  $2 = $4;
  $5 = sqlite3OsTruncate(HEAP32[$0 + 68 >> 2], $7, $2);
 }
 __stack_pointer = $9 + 16 | 0;
 return $5;
}

function fts3BestSnippet($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $8 = __stack_pointer + -64 | 0;
 __stack_pointer = $8;
 $12 = fts3ExprLoadDoclists($1, $8 + 60 | 0, 0);
 label$1: {
  if ($12) {
   break label$1;
  }
  $14 = sqlite3Fts3MallocZero(Math_imul(HEAP32[$8 + 60 >> 2], 40), 0);
  HEAP32[$8 + 48 >> 2] = $14;
  if (!$14) {
   $12 = 7;
   break label$1;
  }
  HEAP32[$8 + 40 >> 2] = $0;
  HEAP32[$8 + 36 >> 2] = $2;
  HEAP32[$8 + 52 >> 2] = -1;
  HEAP32[$8 + 44 >> 2] = HEAP32[$8 + 60 >> 2];
  HEAP32[$8 + 32 >> 2] = $1;
  $12 = fts3ExprIterate(HEAP32[$1 + 16 >> 2], 108, $8 + 32 | 0);
  if (!$12) {
   $1 = 0;
   $0 = HEAP32[$8 + 60 >> 2];
   $0 = ($0 | 0) > 0 ? $0 : 0;
   $14 = HEAP32[$8 + 48 >> 2];
   while (1) {
    if (($0 | 0) != ($1 | 0)) {
     if (HEAP32[(Math_imul($1, 40) + $14 | 0) + 16 >> 2]) {
      $10 = $5;
      $11 = HEAP32[$10 >> 2];
      $15 = $11;
      $9 = HEAP32[$10 + 4 >> 2];
      $16 = $9;
      $13 = $1 & 63;
      $9 = $13 & 31;
      if (($13 & 63) >>> 0 >= 32) {
       $11 = 1 << $9;
       $13 = 0;
      } else {
       $11 = (1 << $9) - 1 & 1 >>> 32 - $9;
       $13 = 1 << $9;
      }
      $10 = $11;
      $9 = $15;
      $11 = $9 | $13;
      $9 = $5;
      HEAP32[$9 >> 2] = $11;
      $11 = $16;
      $10 = $11 | $10;
      HEAP32[$9 + 4 >> 2] = $10;
     }
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$6 >> 2] = $2;
   $1 = -1;
   while (1) {
    if (!fts3SnippetNextCandidate($8 + 32 | 0)) {
     $10 = $4;
     fts3SnippetDetails($8 + 32 | 0, $3, $10, $8 + 28 | 0, $8 + 24 | 0, $8 + 16 | 0, $8 + 8 | 0);
     $5 = HEAP32[$8 + 24 >> 2];
     if (($5 | 0) <= ($1 | 0)) {
      continue;
     }
     HEAP32[$6 + 4 >> 2] = HEAP32[$8 + 28 >> 2];
     $9 = HEAP32[$8 + 12 >> 2];
     $10 = HEAP32[$8 + 8 >> 2];
     $0 = $10;
     $10 = $6;
     HEAP32[$10 + 16 >> 2] = $0;
     HEAP32[$10 + 20 >> 2] = $9;
     $10 = HEAP32[$8 + 20 >> 2];
     $9 = HEAP32[$8 + 16 >> 2];
     $0 = $9;
     $9 = $6;
     HEAP32[$9 + 8 >> 2] = $0;
     HEAP32[$9 + 12 >> 2] = $10;
     $1 = $5;
     continue;
    }
    break;
   }
   HEAP32[$7 >> 2] = $1;
  }
  sqlite3_free(HEAP32[$8 + 48 >> 2]);
 }
 __stack_pointer = $8 - -64 | 0;
 return $12;
}

function sqlite3RefillIndex($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 $4 = HEAP32[$1 + 12 >> 2];
 $8 = HEAP32[$0 + 40 >> 2];
 HEAP32[$0 + 40 >> 2] = $8 + 2;
 $11 = HEAP32[$1 >> 2];
 $3 = HEAP32[$0 >> 2];
 $5 = HEAP32[$3 + 16 >> 2];
 $6 = sqlite3SchemaToIndex($3, HEAP32[$1 + 24 >> 2]);
 label$1: {
  if (sqlite3AuthCheck($0, 27, $11, 0, HEAP32[$5 + ($6 << 4) >> 2])) {
   break label$1;
  }
  sqlite3TableLock($0, $6, HEAP32[$4 + 20 >> 2], 1, HEAP32[$4 >> 2]);
  $3 = sqlite3GetVdbe($0);
  if (!$3) {
   break label$1;
  }
  $7 = ($2 | 0) >= 0;
  $11 = $7 ? $2 : HEAP32[$1 + 44 >> 2];
  $9 = sqlite3KeyInfoOfIndex($0, $1);
  $5 = HEAP32[$0 + 40 >> 2];
  HEAP32[$0 + 40 >> 2] = $5 + 1;
  $13 = HEAPU16[$1 + 50 >> 1];
  $12 = sqlite3KeyInfoRef($9);
  sqlite3VdbeAddOp4($3, 119, $5, 0, $13, $12, -8);
  sqlite3OpenTable($0, $8, $6, $4, 112);
  $9 = sqlite3VdbeAddOp2($3, 35, $8, 0);
  $4 = sqlite3GetTempReg($0);
  sqlite3MultiWrite($0);
  sqlite3GenerateIndexKey($0, $1, $8, $4, 0, $10 + 12 | 0, 0, 0);
  sqlite3VdbeAddOp2($3, 139, $5, $4);
  sqlite3ResolvePartIdxLabel($0, HEAP32[$10 + 12 >> 2]);
  sqlite3VdbeAddOp2($3, 38, $8, $9 + 1 | 0);
  sqlite3VdbeJumpHere($3, $9);
  if (!$7) {
   sqlite3VdbeAddOp2($3, 145, $11, $6);
  }
  $7 = $8 + 1 | 0;
  sqlite3VdbeAddOp4($3, 113, $7, $11, $6, $12, -8);
  sqlite3VdbeChangeP5($3, $2 >>> 27 & 16 ^ 17);
  $2 = sqlite3VdbeAddOp2($3, 33, $5, 0);
  label$4: {
   if (HEAPU8[$1 + 54 | 0]) {
    $9 = sqlite3VdbeGoto($3, 1);
    $6 = sqlite3VdbeCurrentAddr($3);
    sqlite3VdbeAddOp4Int($3, 132, $5, $9, $4, HEAPU16[$1 + 50 >> 1]);
    sqlite3UniqueConstraint($0, 2, $1);
    sqlite3VdbeJumpHere($3, $9);
    break label$4;
   }
   sqlite3MayAbort($0);
   $6 = sqlite3VdbeCurrentAddr($3);
  }
  sqlite3VdbeAddOp3($3, 133, $5, $4, $7);
  if (!(HEAPU8[$1 + 56 | 0] & 2)) {
   sqlite3VdbeAddOp1($3, 137, $7);
  }
  sqlite3VdbeAddOp2($3, 138, $7, $4);
  sqlite3VdbeChangeP5($3, 16);
  sqlite3ReleaseTempReg($0, $4);
  sqlite3VdbeAddOp2($3, 36, $5, $6);
  sqlite3VdbeJumpHere($3, $2);
  sqlite3VdbeAddOp1($3, 122, $8);
  sqlite3VdbeAddOp1($3, 122, $7);
  sqlite3VdbeAddOp1($3, 122, $5);
 }
 __stack_pointer = $10 + 16 | 0;
}

function fcntl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 label$1: {
  label$2: {
   switch ($1 - 1 | 0) {
   default:
    if (($1 | 0) == 9) {
     break label$1;
    }
    break;

   case 0:
   case 2:
    break label$1;

   case 1:
    break label$2;
   }
  }
  HEAP32[$3 + 120 >> 2] = $2 + 4;
  $4 = HEAP32[$2 >> 2];
 }
 $4 = ($1 | 0) == 4 ? $4 | 32768 : $4;
 label$4: {
  label$5: {
   if ($1 >>> 0 > 16) {
    break label$5;
   }
   label$6: {
    if (!(1 << $1 & 98400)) {
     if (($1 | 0) == 7) {
      break label$6;
     }
     if (($1 | 0) != 9) {
      break label$5;
     }
     HEAP32[$3 + 48 >> 2] = $3 + 120;
     HEAP32[$3 + 52 >> 2] = 0;
     $1 = __syscall_fcntl64($0 | 0, 16, $3 + 48 | 0) | 0;
     if ($1) {
      if (($1 | 0) == -28) {
       HEAP32[$3 + 32 >> 2] = $4;
       HEAP32[$3 + 36 >> 2] = 0;
       $1 = __syscall_fcntl64($0 | 0, 9, $3 + 32 | 0) | 0;
       break label$4;
      }
      $1 = __syscall_ret($1);
      break label$4;
     }
     $1 = HEAP32[$3 + 124 >> 2];
     $1 = HEAP32[$3 + 120 >> 2] == 2 ? 0 - $1 | 0 : $1;
     break label$4;
    }
    HEAP32[$3 + 112 >> 2] = $4;
    HEAP32[$3 + 116 >> 2] = 0;
    $1 = __syscall_ret(__syscall_fcntl64($0 | 0, $1 | 0, $3 + 112 | 0) | 0);
    break label$4;
   }
   HEAP32[$3 + 16 >> 2] = $4;
   HEAP32[$3 + 20 >> 2] = 0;
   $1 = __syscall_ret(__syscall_fcntl64($0 | 0, 7, $3 + 16 | 0) | 0);
   break label$4;
  }
  if (($1 | 0) != 1030) {
   HEAP32[$3 >> 2] = $4;
   HEAP32[$3 + 4 >> 2] = 0;
   $1 = __syscall_ret(__syscall_fcntl64($0 | 0, $1 | 0, $3 | 0) | 0);
   break label$4;
  }
  HEAP32[$3 + 96 >> 2] = $4;
  HEAP32[$3 + 100 >> 2] = 0;
  $1 = __syscall_fcntl64($0 | 0, 1030, $3 + 96 | 0) | 0;
  if (($1 | 0) != -28) {
   $1 = __syscall_ret($1);
   break label$4;
  }
  HEAP32[$3 + 80 >> 2] = 0;
  HEAP32[$3 + 84 >> 2] = 0;
  $1 = __syscall_fcntl64($0 | 0, 1030, $3 + 80 | 0) | 0;
  if (($1 | 0) != -28) {
   if (($1 | 0) >= 0) {
    __wasi_fd_close($1 | 0) | 0;
   }
   $1 = __syscall_ret(-28);
   break label$4;
  }
  HEAP32[$3 + 64 >> 2] = $4;
  HEAP32[$3 + 68 >> 2] = 0;
  $1 = __syscall_ret(__syscall_fcntl64($0 | 0, 0, $3 - -64 | 0) | 0);
 }
 __stack_pointer = $3 + 128 | 0;
 return $1 | 0;
}

function generateOutputSubroutine($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $8 = HEAP32[$0 + 8 >> 2];
 $11 = sqlite3VdbeCurrentAddr($8);
 $9 = sqlite3VdbeMakeLabel($0);
 if ($5) {
  $12 = sqlite3VdbeAddOp1($8, 16, $5);
  $10 = $5 + 1 | 0;
  $6 = sqlite3VdbeAddOp4($8, 90, HEAP32[$2 + 12 >> 2], $10, HEAP32[$2 + 16 >> 2], sqlite3KeyInfoRef($6), -8) + 2 | 0;
  sqlite3VdbeAddOp3($8, 13, $6, $9, $6);
  sqlite3VdbeJumpHere($8, $12);
  sqlite3VdbeAddOp3($8, 80, HEAP32[$2 + 12 >> 2], $10, HEAP32[$2 + 16 >> 2] - 1 | 0);
  sqlite3VdbeAddOp2($8, 71, 1, $5);
 }
 $5 = 0;
 if (!HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
  codeOffset($8, HEAP32[$1 + 12 >> 2], $9);
  label$3: {
   label$4: {
    switch (HEAPU8[$3 | 0] - 10 | 0) {
    case 2:
     $5 = sqlite3GetTempReg($0);
     $6 = sqlite3GetTempReg($0);
     sqlite3VdbeAddOp3($8, 97, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2], $5);
     sqlite3VdbeAddOp2($8, 127, HEAP32[$3 + 4 >> 2], $6);
     sqlite3VdbeAddOp3($8, 128, HEAP32[$3 + 4 >> 2], $5, $6);
     sqlite3VdbeChangeP5($8, 8);
     sqlite3ReleaseTempReg($0, $6);
     sqlite3ReleaseTempReg($0, $5);
     break label$3;

    case 1:
     $5 = sqlite3GetTempReg($0);
     $6 = HEAP32[$2 + 16 >> 2];
     sqlite3VdbeAddOp4($8, 97, HEAP32[$2 + 12 >> 2], $6, $5, HEAP32[$3 + 20 >> 2], $6);
     sqlite3VdbeAddOp4Int($8, 138, HEAP32[$3 + 4 >> 2], $5, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
     sqlite3ReleaseTempReg($0, $5);
     break label$3;

    case 0:
     sqlite3ExprCodeMove($0, HEAP32[$2 + 12 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$2 + 16 >> 2]);
     break label$3;

    case 3:
     $5 = HEAP32[$3 + 12 >> 2];
     if (!$5) {
      $5 = sqlite3GetTempRange($0, HEAP32[$2 + 16 >> 2]);
      HEAP32[$3 + 12 >> 2] = $5;
      HEAP32[$3 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
     }
     sqlite3ExprCodeMove($0, HEAP32[$2 + 12 >> 2], $5, HEAP32[$2 + 16 >> 2]);
     sqlite3VdbeAddOp1($8, 11, HEAP32[$3 + 4 >> 2]);
     break label$3;

    default:
     break label$4;
    }
   }
   sqlite3VdbeAddOp2($8, 84, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]);
  }
  $0 = HEAP32[$1 + 8 >> 2];
  if ($0) {
   sqlite3VdbeAddOp2($8, 60, $0, $7);
  }
  sqlite3VdbeResolveLabel($8, $9);
  sqlite3VdbeAddOp1($8, 67, $4);
  $5 = $11;
 }
 return $5;
}

function exprDup($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 label$2: {
  if ($3) {
   $10 = 134217728;
   $5 = HEAP32[$3 >> 2];
   break label$2;
  }
  $5 = dupedExprSize($1, $2);
  $5 = sqlite3DbMallocRawNN($0, $5, $5 >> 31);
 }
 label$1: {
  if (!$5) {
   break label$1;
  }
  $4 = dupedExprStructSize($1, $2);
  label$4: {
   if (HEAPU8[$1 + 5 | 0] & 8) {
    break label$4;
   }
   $8 = HEAP32[$1 + 8 >> 2];
   if (!$8) {
    break label$4;
   }
   $6 = sqlite3Strlen30($8) + 1 | 0;
  }
  $8 = $4 & 4095;
  label$5: {
   if ($2) {
    __memcpy($5, $1, $8);
    break label$5;
   }
   $9 = exprStructSize($1);
   $11 = __memcpy($5, $1, $9);
   if ($9 >>> 0 > 51) {
    break label$5;
   }
   memset($9 + $11 | 0, 0, 52 - $9 | 0);
  }
  $4 = HEAP32[$5 + 4 >> 2] & -134430721 | ($4 & 81920 | $10);
  HEAP32[$5 + 4 >> 2] = $4;
  if ($6) {
   $4 = $5 + $8 | 0;
   HEAP32[$5 + 8 >> 2] = $4;
   __memcpy($4, HEAP32[$1 + 8 >> 2], $6);
   $4 = HEAP32[$5 + 4 >> 2];
  }
  $6 = HEAP32[$1 + 4 >> 2];
  if (!(($6 | $4) & 8454144)) {
   $4 = HEAP32[$1 + 20 >> 2];
   label$9: {
    if ($6 & 4096) {
     $4 = sqlite3SelectDup($0, $4, $2);
     break label$9;
    }
    $4 = sqlite3ExprListDup($0, $4, $2);
   }
   HEAP32[$5 + 20 >> 2] = $4;
  }
  $4 = HEAP32[$5 + 4 >> 2];
  if ($4 & 16859136) {
   HEAP32[$7 + 12 >> 2] = dupedExprNodeSize($1, $2) + $5;
   if (!($4 & 8454144)) {
    $2 = 0;
    $4 = 0;
    $6 = HEAP32[$1 + 12 >> 2];
    if ($6) {
     $4 = exprDup($0, $6, 1, $7 + 12 | 0);
    }
    HEAP32[$5 + 12 >> 2] = $4;
    $4 = HEAP32[$1 + 16 >> 2];
    if ($4) {
     $2 = exprDup($0, $4, 1, $7 + 12 | 0);
    }
    HEAP32[$5 + 16 >> 2] = $2;
   }
   if (HEAP8[$1 + 7 | 0] & 1) {
    HEAP32[$5 + 44 >> 2] = sqlite3WindowDup($0, $5, HEAP32[$1 + 44 >> 2]);
   }
   if (!$3) {
    break label$1;
   }
   HEAP32[$3 >> 2] = HEAP32[$7 + 12 >> 2];
   break label$1;
  }
  if (HEAPU8[$1 + 6 | 0] & 129) {
   break label$1;
  }
  $3 = HEAP32[$1 + 12 >> 2];
  if (HEAPU8[$5 | 0] != 178) {
   $3 = sqlite3ExprDup($0, $3, 0);
  }
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = sqlite3ExprDup($0, HEAP32[$1 + 16 >> 2], 0);
 }
 __stack_pointer = $7 + 16 | 0;
 return $5;
}

function readDbPage($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$5 + 12 >> 2] = 0;
 label$1: {
  label$2: {
   label$3: {
    $1 = HEAP32[$3 + 232 >> 2];
    if (!$1) {
     break label$3;
    }
    $1 = sqlite3WalFindFrame($1, HEAP32[$0 + 24 >> 2], $5 + 12 | 0);
    if ($1) {
     break label$1;
    }
    $1 = HEAP32[$5 + 12 >> 2];
    if (!$1) {
     break label$3;
    }
    $1 = sqlite3WalReadFrame(HEAP32[$3 + 232 >> 2], $1, HEAP32[$3 + 168 >> 2], HEAP32[$0 + 4 >> 2]);
    break label$2;
   }
   $6 = HEAP32[$3 + 64 >> 2];
   $7 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$3 + 168 >> 2];
   $4 = $2;
   $1 = HEAP32[$3 + 172 >> 2];
   $2 = __wasm_i64_mul($2, $1, HEAP32[$0 + 24 >> 2] - 1 | 0, 0);
   $1 = i64toi32_i32$HIGH_BITS;
   $1 = sqlite3OsRead($6, $7, $4, $2, $1);
   $1 = ($1 | 0) == 522 ? 0 : $1;
  }
  if (HEAP32[$0 + 24 >> 2] != 1) {
   break label$1;
  }
  if ($1) {
   $2 = $3;
   HEAP32[$2 + 112 >> 2] = -1;
   HEAP32[$2 + 116 >> 2] = -1;
   HEAP32[$2 + 120 >> 2] = -1;
   HEAP32[$2 + 124 >> 2] = -1;
   break label$1;
  }
  $0 = HEAP32[$0 + 4 >> 2];
  $1 = HEAPU8[$0 + 24 | 0] | HEAPU8[$0 + 25 | 0] << 8 | (HEAPU8[$0 + 26 | 0] << 16 | HEAPU8[$0 + 27 | 0] << 24);
  $2 = HEAPU8[$0 + 28 | 0] | HEAPU8[$0 + 29 | 0] << 8 | (HEAPU8[$0 + 30 | 0] << 16 | HEAPU8[$0 + 31 | 0] << 24);
  $4 = $1;
  $1 = $3;
  HEAP8[$1 + 112 | 0] = $4;
  HEAP8[$1 + 113 | 0] = $4 >>> 8;
  HEAP8[$1 + 114 | 0] = $4 >>> 16;
  HEAP8[$1 + 115 | 0] = $4 >>> 24;
  HEAP8[$1 + 116 | 0] = $2;
  HEAP8[$1 + 117 | 0] = $2 >>> 8;
  HEAP8[$1 + 118 | 0] = $2 >>> 16;
  HEAP8[$1 + 119 | 0] = $2 >>> 24;
  $1 = HEAPU8[$0 + 36 | 0] | HEAPU8[$0 + 37 | 0] << 8 | (HEAPU8[$0 + 38 | 0] << 16 | HEAPU8[$0 + 39 | 0] << 24);
  $2 = HEAPU8[$0 + 32 | 0] | HEAPU8[$0 + 33 | 0] << 8 | (HEAPU8[$0 + 34 | 0] << 16 | HEAPU8[$0 + 35 | 0] << 24);
  $0 = $2;
  $2 = $3;
  HEAP8[$2 + 120 | 0] = $0;
  HEAP8[$2 + 121 | 0] = $0 >>> 8;
  HEAP8[$2 + 122 | 0] = $0 >>> 16;
  HEAP8[$2 + 123 | 0] = $0 >>> 24;
  HEAP8[$2 + 124 | 0] = $1;
  HEAP8[$2 + 125 | 0] = $1 >>> 8;
  HEAP8[$2 + 126 | 0] = $1 >>> 16;
  HEAP8[$2 + 127 | 0] = $1 >>> 24;
  $1 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $1;
}

function sqlite3DropTable($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$5 + 87 | 0]) {
   break label$1;
  }
  if (sqlite3ReadSchema($0)) {
   break label$1;
  }
  if ($3) {
   HEAP8[$5 + 91 | 0] = HEAPU8[$5 + 91 | 0] + 1;
  }
  $4 = sqlite3LocateTableItem($0, $2, $1 + 8 | 0);
  label$3: {
   if (!$3) {
    if (!$4) {
     break label$1;
    }
    break label$3;
   }
   HEAP8[$5 + 91 | 0] = HEAPU8[$5 + 91 | 0] - 1;
   if ($4) {
    break label$3;
   }
   sqlite3CodeVerifyNamedSchema($0, HEAP32[$1 + 12 >> 2]);
   sqlite3ForceNotReadOnly($0);
   break label$1;
  }
  $3 = sqlite3SchemaToIndex($5, HEAP32[$4 + 60 >> 2]);
  if (HEAPU8[$4 + 43 | 0] == 1) {
   if (sqlite3ViewGetColumnNames($0, $4)) {
    break label$1;
   }
  }
  $7 = HEAP32[HEAP32[$5 + 16 >> 2] + ($3 << 4) >> 2];
  if (sqlite3AuthCheck($0, 9, ($3 | 0) == 1 ? 8671 : 8690, 0, $7)) {
   break label$1;
  }
  label$6: {
   if ($2) {
    $8 = ($3 | 0) == 1 ? 15 : 17;
   } else {
    if (HEAPU8[$4 + 43 | 0] == 1) {
     $8 = 30;
     $9 = HEAP32[HEAP32[sqlite3GetVTable($5, $4) + 4 >> 2] + 4 >> 2];
     break label$6;
    }
    $8 = ($3 | 0) == 1 ? 13 : 11;
   }
   $9 = 0;
  }
  if (sqlite3AuthCheck($0, $8, HEAP32[$4 >> 2], $9, $7)) {
   break label$1;
  }
  if (sqlite3AuthCheck($0, 9, HEAP32[$4 >> 2], 0, $7)) {
   break label$1;
  }
  if (tableMayNotBeDropped($5, $4)) {
   HEAP32[$6 + 32 >> 2] = HEAP32[$4 >> 2];
   sqlite3ErrorMsg($0, 15220, $6 + 32 | 0);
   break label$1;
  }
  $7 = HEAPU8[$4 + 43 | 0];
  label$11: {
   if ($2) {
    if (($7 & 255) == 2) {
     break label$11;
    }
    HEAP32[$6 + 16 >> 2] = HEAP32[$4 >> 2];
    sqlite3ErrorMsg($0, 6585, $6 + 16 | 0);
    break label$1;
   }
   if (($7 & 255) != 2) {
    break label$11;
   }
   HEAP32[$6 >> 2] = HEAP32[$4 >> 2];
   sqlite3ErrorMsg($0, 6067, $6);
   break label$1;
  }
  if (!sqlite3GetVdbe($0)) {
   break label$1;
  }
  sqlite3BeginWriteOperation($0, 1, $3);
  if (!$2) {
   sqlite3ClearStatTables($0, $3, 11231, HEAP32[$4 >> 2]);
   sqlite3FkDropTable($0, $1, $4);
  }
  sqlite3CodeDropTable($0, $4, $3, $2);
 }
 sqlite3SrcListDelete($5, $1);
 __stack_pointer = $6 + 48 | 0;
}

function sqlite3LeaveMutexAndCloseZombie($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (HEAPU8[$0 + 97 | 0] != 167) {
   break label$1;
  }
  if (connectionIsBusy($0)) {
   break label$1;
  }
  sqlite3RollbackAll($0, 0);
  sqlite3CloseSavepoints($0);
  while (1) {
   $2 = HEAP32[$0 + 16 >> 2];
   if (($1 | 0) < HEAP32[$0 + 20 >> 2]) {
    $2 = ($1 << 4) + $2 | 0;
    $3 = HEAP32[$2 + 4 >> 2];
    label$4: {
     if (!$3) {
      break label$4;
     }
     sqlite3BtreeClose($3);
     HEAP32[$2 + 4 >> 2] = 0;
     if (($1 | 0) == 1) {
      break label$4;
     }
     HEAP32[$2 + 12 >> 2] = 0;
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  $1 = HEAP32[$2 + 28 >> 2];
  if ($1) {
   sqlite3SchemaClear($1);
  }
  sqlite3VtabUnlockList($0);
  sqlite3CollapseDatabaseArray($0);
  $3 = $0 + 420 | 0;
  while (1) {
   $3 = HEAP32[$3 >> 2];
   if ($3) {
    $1 = HEAP32[$3 + 8 >> 2];
    while (1) {
     functionDestroy($0, $1);
     $2 = HEAP32[$1 + 12 >> 2];
     sqlite3DbFree($0, $1);
     $1 = $2;
     if ($1) {
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  sqlite3HashClear($0 + 412 | 0);
  $4 = $0 + 436 | 0;
  while (1) {
   $4 = HEAP32[$4 >> 2];
   if ($4) {
    $5 = HEAP32[$4 + 8 >> 2];
    $1 = 0;
    while (1) {
     if (($1 | 0) != 3) {
      $2 = Math_imul($1, 20) + $5 | 0;
      $3 = HEAP32[$2 + 16 >> 2];
      if ($3) {
       FUNCTION_TABLE[$3 | 0](HEAP32[$2 + 8 >> 2]);
      }
      $1 = $1 + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3DbFree($0, $5);
    continue;
   }
   break;
  }
  sqlite3HashClear($0 + 428 | 0);
  $1 = $0 + 392 | 0;
  while (1) {
   $1 = HEAP32[$1 >> 2];
   if ($1) {
    $2 = HEAP32[$1 + 8 >> 2];
    sqlite3VtabEponymousTableClear($0, $2);
    sqlite3VtabModuleUnref($0, $2);
    continue;
   }
   break;
  }
  sqlite3HashClear($0 + 384 | 0);
  sqlite3Error($0, 0);
  sqlite3ValueFree(HEAP32[$0 + 288 >> 2]);
  HEAP8[$0 + 97 | 0] = 213;
  sqlite3DbFree($0, HEAP32[HEAP32[$0 + 16 >> 2] + 28 >> 2]);
  $1 = HEAP32[$0 + 256 >> 2];
  if ($1) {
   FUNCTION_TABLE[$1 | 0](HEAP32[$0 + 252 >> 2]);
  }
  HEAP8[$0 + 97 | 0] = 206;
  if (HEAPU8[$0 + 312 | 0]) {
   sqlite3_free(HEAP32[$0 + 352 >> 2]);
  }
  sqlite3_free($0);
 }
}

function codeReturningTrigger($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 192 | 0;
 __stack_pointer = $4;
 $9 = HEAP32[$0 + 8 >> 2];
 $8 = HEAP32[$0 >> 2];
 $5 = HEAP32[$0 + 132 >> 2];
 memset($4 + 112 | 0, 0, 76);
 memset($4 + 40 | 0, 0, 72);
 $6 = sqlite3ExprListDup($8, HEAP32[$5 + 4 >> 2], 0);
 HEAP32[$4 + 88 >> 2] = -1;
 HEAP32[$4 - -64 >> 2] = $2;
 HEAP32[$4 + 140 >> 2] = $6;
 HEAP32[$4 + 40 >> 2] = 1;
 HEAP32[$4 + 144 >> 2] = $4 + 40;
 sqlite3SelectPrep($0, $4 + 112 | 0, 0);
 if (!HEAP32[$0 + 36 >> 2]) {
  sqlite3GenerateColumnNames($0, $4 + 112 | 0);
 }
 sqlite3ExprListDelete($8, HEAP32[$4 + 140 >> 2]);
 $6 = sqlite3ExpandReturning($0, HEAP32[$5 + 4 >> 2], $2);
 label$2: {
  if (HEAPU8[$8 + 87 | 0]) {
   break label$2;
  }
  HEAP32[$4 + 36 >> 2] = 0;
  HEAP32[$4 + 28 >> 2] = 0;
  HEAP32[$4 + 32 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = 0;
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  if (!HEAP32[$5 + 96 >> 2]) {
   HEAP32[$5 + 96 >> 2] = HEAP32[$6 >> 2];
   $7 = HEAP32[$0 + 40 >> 2];
   HEAP32[$0 + 40 >> 2] = $7 + 1;
   HEAP32[$5 + 92 >> 2] = $7;
  }
  HEAP32[$4 + 32 >> 2] = 1024;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 + 8 >> 2] = $0;
  $3 = HEAPU8[$1 + 8 | 0];
  HEAP32[$0 + 120 >> 2] = $2;
  HEAP8[$0 + 148 | 0] = $3;
  if (sqlite3ResolveExprListNames($4 + 8 | 0, $6) | HEAPU8[$8 + 87 | 0]) {
   break label$2;
  }
  $2 = HEAP32[$0 + 44 >> 2];
  $3 = HEAP32[$6 >> 2];
  HEAP32[$0 + 44 >> 2] = ($2 + $3 | 0) + 2;
  $10 = $2 + 1 | 0;
  HEAP32[$5 + 100 >> 2] = $10;
  $2 = 0;
  $7 = ($3 | 0) > 0 ? $3 : 0;
  while (1) {
   if (($2 | 0) != ($7 | 0)) {
    $3 = HEAP32[(($2 << 4) + $6 | 0) + 8 >> 2];
    $1 = $2 + $10 | 0;
    sqlite3ExprCodeFactorable($0, $3, $1);
    if ((sqlite3ExprAffinity($3) | 0) == 69) {
     sqlite3VdbeAddOp1($9, 87, $1);
    }
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  $2 = $7 + $10 | 0;
  sqlite3VdbeAddOp3($9, 97, $10, $7, $2);
  $3 = $2 + 1 | 0;
  sqlite3VdbeAddOp2($9, 127, HEAP32[$5 + 92 >> 2], $3);
  sqlite3VdbeAddOp3($9, 128, HEAP32[$5 + 92 >> 2], $2, $3);
 }
 sqlite3ExprListDelete($8, $6);
 HEAP32[$0 + 120 >> 2] = 0;
 HEAP8[$0 + 148 | 0] = 0;
 __stack_pointer = $4 + 192 | 0;
}

function sqlite3VdbeList($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 >> 2];
 $4 = HEAP32[$0 + 88 >> 2];
 $7 = $4 + 40 | 0;
 $1 = 1;
 $1 = (HEAPU8[$0 + 150 | 0] & 12) != 4 ? HEAP8[$5 + 35 | 0] & 1 : $1;
 releaseMemArray($7, 8);
 HEAP32[$0 + 120 >> 2] = 0;
 label$2: {
  if (HEAP32[$0 + 36 >> 2] == 7) {
   sqlite3OomFault($5);
   $1 = 1;
   break label$2;
  }
  $2 = $1 ? HEAP32[$0 + 88 >> 2] + 360 | 0 : $2;
  $1 = sqlite3VdbeNextOpcode($0, $2, (HEAPU8[$0 + 150 | 0] & 12) == 8, $0 + 32 | 0, $6 + 12 | 0, $6 + 8 | 0);
  if ($1) {
   break label$2;
  }
  $1 = HEAP32[$6 + 12 >> 2];
  $2 = HEAP32[$6 + 8 >> 2];
  if (HEAP32[$5 + 296 >> 2]) {
   HEAP32[$0 + 36 >> 2] = 9;
   sqlite3VdbeError($0, sqlite3ErrStr(9), 0);
   $1 = 1;
   break label$2;
  }
  $8 = Math_imul($1, 20) + $2 | 0;
  $10 = sqlite3VdbeDisplayP4($5, $8);
  $9 = 8;
  label$6: {
   if ((HEAPU8[$0 + 150 | 0] & 12) == 8) {
    $1 = Math_imul($1, 20) + $2 | 0;
    $2 = HEAP32[$1 + 4 >> 2];
    $3 = $2 >> 31;
    sqlite3VdbeMemSetInt64($7, $2, $3);
    $3 = HEAP32[$1 + 8 >> 2];
    $2 = $3 >> 31;
    sqlite3VdbeMemSetInt64($4 + 80 | 0, $3, $2);
    $2 = HEAP32[$1 + 12 >> 2];
    $3 = $2 >> 31;
    sqlite3VdbeMemSetInt64($4 + 120 | 0, $2, $3);
    $9 = 4;
    $1 = 4;
    break label$6;
   }
   $3 = $1 >> 31;
   sqlite3VdbeMemSetInt64($7, $1, $3);
   sqlite3VdbeMemSetStr($4 + 80 | 0, sqlite3OpcodeName(HEAPU8[$8 | 0]), -1, -1, 1, 0);
   $1 = Math_imul($1, 20) + $2 | 0;
   $3 = HEAP32[$1 + 4 >> 2];
   $2 = $3 >> 31;
   sqlite3VdbeMemSetInt64($4 + 120 | 0, $3, $2);
   $2 = HEAP32[$1 + 8 >> 2];
   $3 = $2 >> 31;
   sqlite3VdbeMemSetInt64($4 + 160 | 0, $2, $3);
   $3 = HEAP32[$1 + 12 >> 2];
   $2 = $3 >> 31;
   sqlite3VdbeMemSetInt64($4 + 200 | 0, $3, $2);
   $2 = HEAPU16[$1 + 2 >> 1];
   sqlite3VdbeMemSetInt64($4 + 280 | 0, $2, 0);
   sqlite3VdbeMemSetNull($4 + 320 | 0);
   $1 = 6;
  }
  sqlite3VdbeMemSetStr(Math_imul($1, 40) + $4 | 0, $10, -1, -1, 1, 3);
  HEAP32[$0 + 120 >> 2] = $7;
  HEAP16[$0 + 144 >> 1] = $9;
  $5 = HEAPU8[$5 + 87 | 0];
  HEAP32[$0 + 36 >> 2] = $5 ? 7 : 0;
  $1 = $5 ? 1 : 100;
 }
 __stack_pointer = $6 + 16 | 0;
 return $1;
}
function sqlite3FinishTrigger($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 96 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 244 >> 2];
 HEAP32[$0 + 244 >> 2] = 0;
 label$1: {
  label$2: {
   if (HEAP32[$0 + 36 >> 2] | !$3) {
    break label$2;
   }
   $7 = HEAP32[$3 >> 2];
   $6 = sqlite3SchemaToIndex($5, HEAP32[$3 + 20 >> 2]);
   HEAP32[$3 + 28 >> 2] = $1;
   while (1) {
    if ($1) {
     HEAP32[$1 + 4 >> 2] = $3;
     $1 = HEAP32[$1 + 40 >> 2];
     continue;
    }
    break;
   }
   sqlite3TokenInit($4 + 32 | 0, $7);
   sqlite3FixInit($4 + 40 | 0, $0, $6, 8940, $4 + 32 | 0);
   $1 = 0;
   if (sqlite3FixTriggerStep($4 + 40 | 0, HEAP32[$3 + 28 >> 2])) {
    break label$2;
   }
   if (sqlite3FixExpr($4 + 40 | 0, HEAP32[$3 + 12 >> 2])) {
    break label$2;
   }
   label$5: {
    if (HEAPU8[$0 + 208 | 0] >= 2) {
     HEAP32[$0 + 244 >> 2] = $3;
     $3 = 0;
     break label$5;
    }
    if (HEAPU8[$5 + 177 | 0]) {
     break label$5;
    }
    $8 = sqlite3GetVdbe($0);
    if (!$8) {
     break label$2;
    }
    sqlite3BeginWriteOperation($0, 0, $6);
    $2 = sqlite3DbStrNDup($5, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2], 0);
    $9 = HEAP32[HEAP32[$5 + 16 >> 2] + ($6 << 4) >> 2];
    $10 = HEAP32[$3 + 4 >> 2];
    HEAP32[$4 + 28 >> 2] = $2;
    HEAP32[$4 + 24 >> 2] = $10;
    HEAP32[$4 + 20 >> 2] = $7;
    HEAP32[$4 + 16 >> 2] = $9;
    sqlite3NestedParse($0, 26692, $4 + 16 | 0);
    sqlite3DbFree($5, $2);
    sqlite3ChangeCookie($0, $6);
    HEAP32[$4 >> 2] = $7;
    sqlite3VdbeAddParseSchemaOp($8, $6, sqlite3MPrintf($5, 27474, $4), 0);
   }
   if (!HEAPU8[$5 + 177 | 0]) {
    break label$2;
   }
   $0 = sqlite3HashInsert(HEAP32[(HEAP32[$5 + 16 >> 2] + ($6 << 4) | 0) + 12 >> 2] + 40 | 0, $7, $3);
   if ($0) {
    sqlite3OomFault($5);
    break label$1;
   }
   $0 = 0;
   $1 = HEAP32[$3 + 20 >> 2];
   if (($1 | 0) == HEAP32[$3 + 24 >> 2]) {
    $1 = sqlite3HashFind($1 + 8 | 0, HEAP32[$3 + 4 >> 2]);
    HEAP32[$3 + 32 >> 2] = HEAP32[$1 + 56 >> 2];
    HEAP32[$1 + 56 >> 2] = $3;
   }
   $1 = 0;
   break label$1;
  }
  $0 = $3;
 }
 sqlite3DeleteTrigger($5, $0);
 sqlite3DeleteTriggerStep($5, $1);
 __stack_pointer = $4 + 96 | 0;
}

function sqlite3ExprAssignVarNumber($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $10 = HEAP32[$0 >> 2];
  $9 = HEAP32[$1 + 8 >> 2];
  $5 = $9;
  $6 = HEAP8[$5 + 1 | 0];
  $4 = $6 >> 31;
  label$2: {
   $11 = $4;
   label$3: {
    if (!($6 | $4)) {
     $3 = HEAPU16[$0 + 204 >> 1] + 1 | 0;
     HEAP16[$0 + 204 >> 1] = $3;
     break label$3;
    }
    label$5: {
     label$6: {
      if (HEAPU8[$9 | 0] == 63) {
       label$8: {
        if (($2 | 0) == 2) {
         $5 = $6;
         $4 = $5 >>> 0 < 48;
         $6 = $5 - 48 | 0;
         $4 = $11 - $4 | 0;
         $5 = $4;
         break label$8;
        }
        $7 = (sqlite3Atoi64($9 + 1 | 0, $8 + 8 | 0, $2 - 1 | 0, 1) | 0) != 0;
        $4 = HEAP32[$8 + 8 >> 2];
        $6 = $4;
        $5 = HEAP32[$8 + 12 >> 2];
       }
       $11 = $5;
       $7 = !$6 & ($5 | 0) <= 0 | ($5 | 0) < 0 | $7;
       $3 = HEAP32[$10 + 156 >> 2];
       $4 = $3 >> 31;
       $5 = $4;
       $4 = $11;
       if ($3 >>> 0 < $6 >>> 0 & ($5 | 0) <= ($4 | 0) | ($5 | 0) < ($4 | 0) | $7) {
        break label$2;
       }
       $3 = $6 << 16 >> 16;
       if (($3 | 0) <= HEAP16[$0 + 204 >> 1]) {
        break label$6;
       }
       HEAP16[$0 + 204 >> 1] = $3;
       $7 = HEAP32[$0 + 224 >> 2];
       break label$5;
      }
      $7 = HEAP32[$0 + 224 >> 2];
      $3 = sqlite3VListNameToNum($7, $9, $2);
      if ($3 & 65535) {
       break label$3;
      }
      $3 = HEAPU16[$0 + 204 >> 1] + 1 | 0;
      HEAP16[$0 + 204 >> 1] = $3;
      break label$5;
     }
     $7 = HEAP32[$0 + 224 >> 2];
     if (sqlite3VListNumToName($7, $3)) {
      break label$3;
     }
    }
    HEAP32[$0 + 224 >> 2] = sqlite3VListAdd($10, $7, $9, $2, $3 << 16 >> 16);
   }
   HEAP16[$1 + 32 >> 1] = $3;
   if (HEAP32[$10 + 156 >> 2] >= $3 << 16 >> 16) {
    break label$1;
   }
   sqlite3ErrorMsg($0, 5475, 0);
   sqlite3RecordErrorOffsetOfExpr(HEAP32[$0 >> 2], $1);
   break label$1;
  }
  HEAP32[$8 >> 2] = $3;
  sqlite3ErrorMsg($0, 15939, $8);
  sqlite3RecordErrorOffsetOfExpr(HEAP32[$0 >> 2], $1);
 }
 __stack_pointer = $8 + 16 | 0;
}

function sqlite3AddPrimaryKey($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 $5 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$5) {
   break label$1;
  }
  $6 = HEAP32[$5 + 28 >> 2];
  if ($6 & 4) {
   HEAP32[$9 >> 2] = HEAP32[$5 >> 2];
   sqlite3ErrorMsg($0, 1284, $9);
   break label$1;
  }
  HEAP32[$5 + 28 >> 2] = $6 | 4;
  label$3: {
   if (!$1) {
    $6 = HEAP16[$5 + 34 >> 1] - 1 | 0;
    $10 = HEAP32[$5 + 4 >> 2] + Math_imul($6, 12) | 0;
    makeColumnPartOfPrimaryKey($0, $10);
    $7 = 1;
    break label$3;
   }
   $11 = HEAP32[$1 >> 2];
   $14 = ($11 | 0) > 0 ? $11 : 0;
   $6 = -1;
   while (1) {
    label$6: {
     if (($12 | 0) != ($14 | 0)) {
      $8 = sqlite3ExprSkipCollate(HEAP32[(($12 << 4) + $1 | 0) + 8 >> 2]);
      sqlite3StringToId($8);
      if (HEAPU8[$8 | 0] != 59) {
       break label$6;
      }
      $6 = 0;
      $7 = HEAP16[$5 + 34 >> 1];
      $7 = ($7 | 0) > 0 ? $7 : 0;
      $8 = HEAP32[$8 + 8 >> 2];
      while (1) {
       if (($6 | 0) == ($7 | 0)) {
        $6 = $7;
        break label$6;
       }
       $13 = HEAP32[$5 + 4 >> 2] + Math_imul($6, 12) | 0;
       if (sqlite3StrICmp($8, HEAP32[$13 >> 2])) {
        $6 = $6 + 1 | 0;
        continue;
       } else {
        makeColumnPartOfPrimaryKey($0, $13);
        $10 = $13;
        break label$6;
       }
      }
     }
     $7 = ($11 | 0) == 1;
     break label$3;
    }
    $12 = $12 + 1 | 0;
    continue;
   }
  }
  if (!(!$7 | !$10 | ($4 | 0) == 1 | (HEAPU8[$10 + 4 | 0] & -16) != 64)) {
   if (!(!$1 | HEAPU8[$0 + 208 | 0] < 2)) {
    sqlite3RenameTokenRemap($0, $5 + 32 | 0, sqlite3ExprSkipCollate(HEAP32[$1 + 8 >> 2]));
   }
   HEAP8[$5 + 42 | 0] = $2;
   HEAP16[$5 + 32 >> 1] = $6;
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] | $3 << 3;
   if ($1) {
    HEAP8[$0 + 206 | 0] = HEAPU8[$1 + 16 | 0];
   }
   sqlite3HasExplicitNulls($0, $1);
   break label$1;
  }
  if ($3) {
   sqlite3ErrorMsg($0, 17986, 0);
   break label$1;
  }
  sqlite3CreateIndex($0, 0, 0, 0, $1, $2, 0, 0, $4, 0, 2);
  $1 = 0;
 }
 sqlite3ExprListDelete(HEAP32[$0 >> 2], $1);
 __stack_pointer = $9 + 16 | 0;
}

function sqlite3VdbeSerialGet($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  switch ($1 | 0) {
  case 10:
   HEAP32[$2 + 12 >> 2] = 0;
   HEAP16[$2 + 16 >> 1] = 1025;
   HEAP32[$2 >> 2] = 0;
   return;

  case 0:
  case 11:
   HEAP16[$2 + 16 >> 1] = 1;
   return;

  case 1:
   $3 = HEAP8[$0 | 0];
   $4 = $3 >> 31;
   $5 = $3;
   HEAP16[$2 + 16 >> 1] = 4;
   HEAP32[$2 >> 2] = $5;
   HEAP32[$2 + 4 >> 2] = $4;
   return;

  case 2:
   $1 = HEAPU8[$0 + 1 | 0];
   $0 = HEAP8[$0 | 0];
   HEAP16[$2 + 16 >> 1] = 4;
   $3 = $0 << 8 | $1;
   $4 = $3 >> 31;
   HEAP32[$2 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = $4;
   return;

  case 3:
   $1 = HEAPU8[$0 + 2 | 0];
   $6 = HEAPU8[$0 + 1 | 0];
   $0 = HEAP8[$0 | 0];
   HEAP16[$2 + 16 >> 1] = 4;
   $3 = $6 << 8 | $0 << 16 | $1;
   $4 = $3 >> 31;
   HEAP32[$2 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = $4;
   return;

  case 4:
   $1 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
   HEAP16[$2 + 16 >> 1] = 4;
   $3 = $1 << 8 & 16711680 | $1 << 24 | ($1 >>> 8 & 65280 | $1 >>> 24);
   $4 = $3 >> 31;
   HEAP32[$2 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = $4;
   return;

  case 5:
   $1 = HEAPU8[$0 + 1 | 0];
   $6 = HEAP8[$0 | 0];
   $4 = HEAPU8[$0 + 5 | 0];
   $5 = $4;
   $3 = HEAPU8[$0 + 4 | 0];
   $7 = $3;
   $4 = HEAPU8[$0 + 3 | 0];
   $3 = HEAPU8[$0 + 2 | 0];
   $0 = $3;
   HEAP16[$2 + 16 >> 1] = 4;
   $3 = $4 >>> 16 | 0;
   $8 = $4 << 16;
   $9 = $3;
   $4 = $0;
   $0 = $4 >>> 8 | 0;
   $3 = $8;
   $8 = $3 | $4 << 24;
   $4 = $0;
   $0 = $9;
   $4 = $4 | $0;
   $0 = $7;
   $3 = $0 >>> 24 | 0;
   $9 = $0 << 8;
   $0 = $3;
   $3 = $4;
   $0 = $3 | $0;
   $7 = $0;
   $3 = $5;
   $4 = $8;
   $4 = $3 | ($9 | $4);
   $0 = $6 << 8 | $1;
   HEAP32[$2 >> 2] = $4;
   $3 = $7;
   $0 = $3 | $0;
   HEAP32[$2 + 4 >> 2] = $0;
   return;

  case 6:
  case 7:
   serialGet($0, $1, $2);
   return;

  case 8:
  case 9:
   HEAP16[$2 + 16 >> 1] = 4;
   HEAP32[$2 >> 2] = $1 - 8;
   HEAP32[$2 + 4 >> 2] = 0;
   return;

  default:
   break label$1;
  }
 }
 HEAP32[$2 + 8 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1 - 12 >>> 1;
 HEAP16[$2 + 16 >> 1] = HEAPU16[(($1 & 1) << 1) + 33344 >> 1];
}

function unixOpenSharedMemory($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = __stack_pointer - 128 | 0;
 __stack_pointer = $4;
 $3 = sqlite3_malloc64(16, 0);
 label$1: {
  if (!$3) {
   $1 = 7;
   break label$1;
  }
  HEAP32[$3 >> 2] = 0;
  HEAP32[$3 + 4 >> 2] = 0;
  HEAP32[$3 + 8 >> 2] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  label$3: {
   $8 = HEAP32[$0 + 8 >> 2];
   $5 = HEAP32[$8 + 40 >> 2];
   label$4: {
    if ($5) {
     break label$4;
    }
    $7 = HEAP32[$0 + 32 >> 2];
    $1 = 1802;
    if (FUNCTION_TABLE[HEAP32[16252]](HEAP32[$0 + 12 >> 2], $4 + 16 | 0) | 0) {
     break label$3;
    }
    $6 = strlen($7);
    $2 = $6 + 74 | 0;
    $5 = sqlite3_malloc64($2, 0);
    if (!$5) {
     $1 = 7;
     break label$3;
    }
    $1 = 0;
    $2 = memset($5, 0, $2);
    $9 = $2 + 68 | 0;
    HEAP32[$2 + 8 >> 2] = $9;
    HEAP32[$4 >> 2] = $7;
    $6 = sqlite3_snprintf($6 + 6 | 0, $9, 10964, $4);
    HEAP32[$2 + 12 >> 2] = -1;
    $7 = HEAP32[$0 + 8 >> 2];
    HEAP32[$7 + 40 >> 2] = $2;
    HEAP32[$2 >> 2] = $7;
    if (HEAPU8[64276]) {
     HEAP32[$2 + 4 >> 2] = 8;
    }
    if (HEAPU8[$8 + 29 | 0]) {
     break label$4;
    }
    label$7: {
     if (!sqlite3_uri_boolean(HEAP32[$0 + 32 >> 2], 10951, 0)) {
      $1 = robust_open($6, 131138, HEAP32[$4 + 28 >> 2] & 511);
      HEAP32[$2 + 12 >> 2] = $1;
      break label$7;
     }
     $1 = HEAP32[$2 + 12 >> 2];
    }
    if (($1 | 0) < 0) {
     $1 = robust_open($6, 131072, HEAP32[$4 + 28 >> 2] & 511);
     HEAP32[$2 + 12 >> 2] = $1;
     if (($1 | 0) < 0) {
      $1 = unixLogErrorAtLine(sqlite3CantopenError(40140), 10788, $6, 40140);
      break label$3;
     }
     HEAP8[$2 + 22 | 0] = 1;
    }
    robustFchown($1, HEAP32[$4 + 36 >> 2], HEAP32[$4 + 40 >> 2]);
    $1 = unixLockSharedMemory($0, $2);
    if (($1 | 0) == 1288) {
     break label$4;
    }
    if ($1) {
     break label$3;
    }
   }
   HEAP32[$3 >> 2] = $5;
   HEAP32[$5 + 28 >> 2] = HEAP32[$5 + 28 >> 2] + 1;
   HEAP32[$0 + 36 >> 2] = $3;
   HEAP32[$3 + 4 >> 2] = HEAP32[$5 + 32 >> 2];
   HEAP32[$5 + 32 >> 2] = $3;
   break label$1;
  }
  unixShmPurge($0);
  sqlite3_free($3);
 }
 __stack_pointer = $4 + 128 | 0;
 return $1;
}

function readSuperJournal($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP8[$1 | 0] = 0;
 $5 = sqlite3OsFileSize($0, $3 + 16 | 0);
 label$1: {
  if ($5) {
   break label$1;
  }
  $6 = HEAP32[$3 + 20 >> 2];
  $11 = $6;
  $10 = HEAP32[$3 + 16 >> 2];
  $7 = $10;
  if ($7 >>> 0 < 16 & ($6 | 0) <= 0 | ($6 | 0) < 0) {
   break label$1;
  }
  $4 = $10;
  $8 = $4 - 16 | 0;
  $7 = $11;
  $5 = read32bits($0, $8, $7 - ($4 >>> 0 < 16) | 0, $3 + 28 | 0);
  if ($5) {
   break label$1;
  }
  $5 = 0;
  $9 = HEAP32[$3 + 28 >> 2];
  if ($9 >>> 0 >= $2 >>> 0 | !$9) {
   break label$1;
  }
  $4 = HEAP32[$3 + 20 >> 2];
  $11 = $4;
  $10 = HEAP32[$3 + 16 >> 2];
  $7 = $10;
  $6 = $7 - 16 | 0;
  $8 = $7 >>> 0 < 16;
  $8 = $4 - $8 | 0;
  $7 = $8;
  $4 = $9;
  if (($7 | 0) <= 0 & $4 >>> 0 > $6 >>> 0 | ($7 | 0) < 0) {
   break label$1;
  }
  $4 = $11;
  $6 = $10 >>> 0 < 12;
  $6 = $4 - $6 | 0;
  $5 = read32bits($0, $10 - 12 | 0, $6, $3 + 12 | 0);
  if ($5) {
   break label$1;
  }
  $6 = HEAP32[$3 + 16 >> 2];
  $4 = $6;
  $8 = $4 - 8 | 0;
  $5 = sqlite3OsRead($0, $3 + 4 | 0, 8, $8, HEAP32[$3 + 20 >> 2] - ($4 >>> 0 < 8) | 0);
  if ($5) {
   break label$1;
  }
  $5 = 0;
  $4 = HEAPU8[$3 + 8 | 0] | HEAPU8[$3 + 9 | 0] << 8 | (HEAPU8[$3 + 10 | 0] << 16 | HEAPU8[$3 + 11 | 0] << 24);
  if ((HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24)) != -117058087 | ($4 | 0) != -681336544) {
   break label$1;
  }
  $7 = HEAP32[$3 + 16 >> 2];
  $6 = $7 - $9 | 0;
  $4 = HEAP32[$3 + 20 >> 2];
  $8 = $7 >>> 0 < $9 >>> 0;
  $8 = $4 - $8 | 0;
  $4 = $6;
  $6 = $4 >>> 0 < 16;
  $6 = $8 - $6 | 0;
  $5 = sqlite3OsRead($0, $1, $9, $4 - 16 | 0, $6);
  if ($5) {
   break label$1;
  }
  $5 = 0;
  $0 = HEAP32[$3 + 12 >> 2];
  while (1) {
   if (($5 | 0) != ($9 | 0)) {
    $0 = $0 - HEAP8[$1 + $5 | 0] | 0;
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$3 + 12 >> 2] = $0;
  $5 = 0;
  if ($0) {
   HEAP32[$3 + 28 >> 2] = 0;
   $9 = 0;
  }
  $0 = $1 + $9 | 0;
  HEAP8[$0 | 0] = 0;
  HEAP8[$0 + 1 | 0] = 0;
 }
 __stack_pointer = $3 + 32 | 0;
 return $5;
}

function incrVacuumStep($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 label$1: {
  label$2: {
   if ((ptrmapPageno($0, $2) | 0) == ($2 | 0) | ((HEAPU32[16232] / HEAPU32[$0 + 36 >> 2] | 0) + 1 | 0) == ($2 | 0)) {
    break label$2;
   }
   if (!sqlite3Get4byte(HEAP32[HEAP32[$0 + 12 >> 2] + 56 >> 2] + 36 | 0)) {
    $4 = 101;
    break label$1;
   }
   $4 = ptrmapGet($0, $2, $5 + 31 | 0, $5 + 24 | 0);
   if ($4) {
    break label$1;
   }
   label$4: {
    label$5: {
     label$6: {
      $6 = HEAPU8[$5 + 31 | 0];
      switch ($6 - 1 | 0) {
      case 1:
       break label$5;

      case 0:
       break label$6;

      default:
       break label$4;
      }
     }
     $4 = sqlite3CorruptError(70745);
     break label$1;
    }
    if ($3) {
     break label$2;
    }
    $4 = allocateBtreePage($0, $5 + 16 | 0, $5 + 20 | 0, $2, 1);
    if ($4) {
     break label$1;
    }
    releasePage(HEAP32[$5 + 16 >> 2]);
    break label$2;
   }
   $4 = btreeGetPage($0, $2, $5 + 16 | 0, 0);
   if ($4) {
    break label$1;
   }
   $7 = $3 ? 0 : $1;
   $8 = !$3 << 1;
   while (1) {
    $9 = btreePagecount($0);
    $4 = allocateBtreePage($0, $5 + 12 | 0, $5 + 20 | 0, $7, $8);
    if ($4) {
     releasePage(HEAP32[$5 + 16 >> 2]);
     break label$1;
    }
    releasePage(HEAP32[$5 + 12 >> 2]);
    $4 = HEAP32[$5 + 20 >> 2];
    if ($9 >>> 0 < $4 >>> 0) {
     releasePage(HEAP32[$5 + 16 >> 2]);
     $4 = sqlite3CorruptError(70797);
     break label$1;
    }
    if ($1 >>> 0 < $4 >>> 0 ? $3 : 0) {
     continue;
    }
    break;
   }
   $1 = HEAP32[$5 + 16 >> 2];
   $4 = relocatePage($0, $1, $6, HEAP32[$5 + 24 >> 2], $4, $3);
   releasePage($1);
   if ($4) {
    break label$1;
   }
  }
  $4 = 0;
  if ($3) {
   break label$1;
  }
  $1 = (HEAPU32[16232] / HEAPU32[$0 + 36 >> 2] | 0) + 2 | 0;
  while (1) {
   $3 = ($1 | 0) == ($2 | 0);
   $4 = $2 - 1 | 0;
   $2 = $4;
   if ($3) {
    continue;
   }
   $2 = $4;
   if (($4 | 0) == (ptrmapPageno($0, $4) | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$0 + 48 >> 2] = $4;
  HEAP8[$0 + 19 | 0] = 1;
  $4 = 0;
 }
 __stack_pointer = $5 + 32 | 0;
 return $4;
}

function seriesBestIndex($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = -1;
 HEAP32[$5 + 4 >> 2] = -1;
 HEAP32[$5 + 8 >> 2] = -1;
 $2 = HEAP32[$1 >> 2];
 $10 = ($2 | 0) > 0 ? $2 : 0;
 $2 = HEAP32[$1 + 4 >> 2];
 label$1: {
  while (1) {
   label$3: {
    if (($4 | 0) == ($10 | 0)) {
     $3 = 0;
     $2 = 0;
     while (1) {
      if (($2 | 0) == 3) {
       break label$3;
      }
      $4 = HEAP32[($5 + 4 | 0) + ($2 << 2) >> 2];
      if (($4 | 0) >= 0) {
       $4 = HEAP32[$1 + 16 >> 2] + ($4 << 3) | 0;
       HEAP8[$4 + 4 | 0] = 1;
       $3 = $3 + 1 | 0;
       HEAP32[$4 >> 2] = $3;
      }
      $2 = $2 + 1 | 0;
      continue;
     }
    }
    $3 = HEAP32[$2 >> 2];
    label$7: {
     if (($3 | 0) <= 0) {
      break label$7;
     }
     if ($3 >>> 0 >= 4) {
      break label$1;
     }
     $3 = $3 - 1 | 0;
     $7 = $3 ? $7 : 1;
     $8 = 1 << $3;
     if (!HEAPU8[$2 + 5 | 0]) {
      $9 = $8 | $9;
      break label$7;
     }
     if (HEAPU8[$2 + 4 | 0] != 2) {
      break label$7;
     }
     HEAP32[($5 + 4 | 0) + ($3 << 2) >> 2] = $4;
     $6 = $6 | $8;
    }
    $2 = $2 + 12 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  label$9: {
   if (!$7) {
    sqlite3_free(HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 8 >> 2] = sqlite3_mprintf(13672, 0);
    $2 = 1;
    break label$9;
   }
   $2 = 19;
   if (($6 ^ -1) & $9) {
    break label$9;
   }
   label$11: {
    if (($6 & 3) == 3) {
     HEAP32[$1 + 48 >> 2] = 1e3;
     HEAP32[$1 + 52 >> 2] = 0;
     HEAPF64[$1 + 40 >> 3] = ($6 << 29 >> 31) + 2 | 0;
     if (HEAP32[$1 + 8 >> 2] <= 0) {
      break label$11;
     }
     $2 = HEAP32[$1 + 12 >> 2];
     if (HEAP32[$2 >> 2]) {
      break label$11;
     }
     $2 = HEAPU8[$2 + 4 | 0];
     HEAP32[$1 + 32 >> 2] = 1;
     $6 = ($2 ? 8 : 16) | $6;
     break label$11;
    }
    HEAP32[$1 + 48 >> 2] = 2147483647;
    HEAP32[$1 + 52 >> 2] = 0;
   }
   HEAP32[$1 + 20 >> 2] = $6;
   $2 = 0;
  }
  __stack_pointer = $5 + 16 | 0;
  return $2 | 0;
 }
 __assert_fail(23026, 17414, 475, 1519);
 abort();
}

function groupConcatStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   break label$1;
  }
  $3 = sqlite3_aggregate_context($0, 36);
  if (!$3) {
   break label$1;
  }
  $4 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = HEAP32[sqlite3_context_db_handle($0) + 120 >> 2];
  label$2: {
   if (($1 | 0) == 1) {
    if ($4) {
     sqlite3_str_appendchar($3, 1, 44);
     break label$2;
    }
    HEAP32[$3 + 28 >> 2] = 1;
    break label$2;
   }
   $0 = HEAP32[$2 + 4 >> 2];
   label$5: {
    label$6: {
     label$7: {
      if ($4) {
       $0 = sqlite3_value_text($0);
       $5 = sqlite3_value_bytes(HEAP32[$2 + 4 >> 2]);
       label$9: {
        if (!$0) {
         $5 = 0;
         break label$9;
        }
        sqlite3_str_append($3, $0, $5);
       }
       $0 = HEAP32[$3 + 32 >> 2];
       if (HEAP32[$3 + 28 >> 2] == ($5 | 0)) {
        if (!$0) {
         break label$2;
        }
        $6 = $3 + 32 | 0;
        break label$7;
       }
       $6 = $3 + 32 | 0;
       if ($0) {
        break label$7;
       }
       $1 = sqlite3_malloc64((HEAP32[$3 + 24 >> 2] << 2) + 4 | 0, 0);
       if (!$1) {
        break label$5;
       }
       $0 = HEAP32[$3 + 24 >> 2];
       $4 = (($0 | 0) > 1 ? $0 : 1) - 1 | 0;
       $0 = 0;
       while (1) {
        if (($0 | 0) == ($4 | 0)) {
         break label$6;
        }
        HEAP32[($0 << 2) + $1 >> 2] = HEAP32[$3 + 28 >> 2];
        $0 = $0 + 1 | 0;
        continue;
       }
      }
      HEAP32[$3 + 28 >> 2] = sqlite3_value_bytes($0);
      break label$2;
     }
     $1 = sqlite3_realloc64($0, HEAP32[$3 + 24 >> 2] << 2, 0);
     if (!$1) {
      break label$5;
     }
    }
    $0 = HEAP32[$3 + 24 >> 2];
    if (($0 | 0) > 0) {
     HEAP32[(($0 << 2) + $1 | 0) - 4 >> 2] = $5;
    }
    HEAP32[$6 >> 2] = $1;
    break label$2;
   }
   sqlite3StrAccumSetError($3, 7);
  }
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 1;
  $0 = sqlite3_value_text(HEAP32[$2 >> 2]);
  $2 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
  if (!$0) {
   break label$1;
  }
  sqlite3_str_append($3, $0, $2);
 }
}

function jsonExtractFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 $5 = sqlite3_user_data($0);
 label$1: {
  if (($1 | 0) < 2) {
   break label$1;
  }
  $6 = jsonParseCached($0, $2, $0);
  if (!$6) {
   break label$1;
  }
  if (($1 | 0) == 2) {
   $4 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
   if (!$4) {
    break label$1;
   }
   if ($5 & 3) {
    label$4: {
     if (HEAPU8[$4 | 0] != 36) {
      jsonInit($3, $0);
      $1 = HEAPU8[$4 | 0];
      label$6: {
       if ($1 - 58 >>> 0 >= 4294967286) {
        jsonAppendRaw($3, 17893, 2);
        jsonAppendRaw($3, $4, strlen($4));
        jsonAppendRaw($3, 17891, 2);
        break label$6;
       }
       jsonAppendRaw($3, 24265, ($1 | 0) == 91 ? 1 : 2);
       jsonAppendRaw($3, $4, strlen($4));
       jsonAppendChar($3, 0);
      }
      $4 = 0;
      if (!HEAPU8[$3 + 25 | 0]) {
       $4 = jsonLookup($6, HEAP32[$3 + 4 >> 2], 0, $0);
      }
      jsonReset($3);
      break label$4;
     }
     $4 = jsonLookup($6, $4, 0, $0);
    }
    if (!$4) {
     break label$1;
    }
    if ($5 & 1) {
     jsonReturnJson($4, $0, 0);
     break label$1;
    }
    jsonReturn($4, $0);
    sqlite3_result_subtype($0, 0);
    break label$1;
   }
   $5 = jsonLookup($6, $4, 0, $0);
   if (HEAPU8[$6 + 21 | 0] | !$5) {
    break label$1;
   }
   jsonReturn($5, $0);
   break label$1;
  }
  jsonInit($3, $0);
  jsonAppendChar($3, 91);
  $5 = 1;
  label$10: {
   label$11: {
    while (1) {
     if (($1 | 0) == ($5 | 0)) {
      break label$11;
     }
     $4 = jsonLookup($6, sqlite3_value_text(HEAP32[($5 << 2) + $2 >> 2]), 0, $0);
     if (!HEAPU8[$6 + 21 | 0]) {
      jsonAppendSeparator($3);
      label$14: {
       if ($4) {
        jsonRenderNode($4, $3, 0);
        break label$14;
       }
       jsonAppendRaw($3, 11103, 4);
      }
      $5 = $5 + 1 | 0;
      continue;
     }
     break;
    }
    if (($1 | 0) != ($5 | 0)) {
     break label$10;
    }
   }
   jsonAppendChar($3, 93);
   jsonResult($3);
   sqlite3_result_subtype($0, 74);
  }
  jsonReset($3);
 }
 __stack_pointer = $3 + 128 | 0;
}

function appendOnePathElement($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 4224 | 0;
 __stack_pointer = $4;
 label$1: {
  label$2: {
   label$3: {
    if (HEAPU8[$1 | 0] != 46) {
     break label$3;
    }
    if (($2 | 0) == 1) {
     break label$1;
    }
    if (($2 | 0) != 2 | HEAPU8[$1 + 1 | 0] != 46) {
     break label$3;
    }
    $2 = HEAP32[$0 + 16 >> 2];
    if (($2 | 0) < 2) {
     break label$2;
    }
    $1 = HEAP32[$0 + 8 >> 2];
    while (1) {
     $2 = $2 - 1 | 0;
     HEAP32[$0 + 16 >> 2] = $2;
     if (HEAPU8[$1 + $2 | 0] != 47) {
      continue;
     }
     break;
    }
    break label$1;
   }
   $3 = HEAP32[$0 + 16 >> 2];
   if (HEAP32[$0 + 12 >> 2] <= (($3 + $2 | 0) + 2 | 0)) {
    HEAP32[$0 >> 2] = 1;
    break label$1;
   }
   HEAP32[$0 + 16 >> 2] = $3 + 1;
   HEAP8[HEAP32[$0 + 8 >> 2] + $3 | 0] = 47;
   __memcpy(HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 16 >> 2] | 0, $1, $2);
   $1 = HEAP32[$0 + 16 >> 2] + $2 | 0;
   HEAP32[$0 + 16 >> 2] = $1;
   if (HEAP32[$0 >> 2]) {
    break label$1;
   }
   HEAP8[HEAP32[$0 + 8 >> 2] + $1 | 0] = 0;
   $1 = HEAP32[$0 + 8 >> 2];
   if (FUNCTION_TABLE[HEAP32[16318]]($1, $4 + 4112 | 0) | 0) {
    if (HEAP32[__errno_location() >> 2] == 44) {
     break label$1;
    }
    HEAP32[$0 >> 2] = unixLogErrorAtLine(sqlite3CantopenError(41961), 3276, $1, 41961);
    break label$1;
   }
   if ((HEAP32[$4 + 4124 >> 2] & 61440) != 40960) {
    break label$1;
   }
   $3 = HEAP32[$0 + 4 >> 2];
   HEAP32[$0 + 4 >> 2] = $3 + 1;
   label$7: {
    label$8: {
     if (($3 | 0) >= 201) {
      $2 = sqlite3CantopenError(41967);
      break label$8;
     }
     $3 = 0;
     $5 = FUNCTION_TABLE[HEAP32[16315]]($1, $4, 4096) | 0;
     if ($5 - 4096 >>> 0 > 4294963200) {
      break label$7;
     }
     $2 = unixLogErrorAtLine(sqlite3CantopenError(41972), 11348, $1, 41972);
    }
    HEAP32[$0 >> 2] = $2;
    break label$1;
   }
   HEAP8[$4 + $5 | 0] = 0;
   $3 = HEAPU8[$4 | 0] != 47 ? HEAP32[$0 + 16 >> 2] + ($2 ^ -1) | 0 : $3;
   HEAP32[$0 + 16 >> 2] = $3;
   appendAllPathElements($0, $4);
   break label$1;
  }
  HEAP32[$0 >> 2] = 1;
 }
 __stack_pointer = $4 + 4224 | 0;
}

function whereLoopOutputAdjust($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$1 + 8 >> 2];
 $14 = ($7 | HEAP32[$1 >> 2]) ^ -1;
 $8 = HEAP32[$1 + 12 >> 2];
 $15 = ($8 | HEAP32[$1 + 4 >> 2]) ^ -1;
 $9 = HEAP32[$0 + 20 >> 2];
 $12 = HEAP32[$0 + 24 >> 2];
 $4 = $12;
 while (1) {
  if (($9 | 0) > 0) {
   $10 = HEAP32[$4 + 40 >> 2];
   $11 = HEAP32[$4 + 44 >> 2];
   label$3: {
    if (HEAPU8[$4 + 10 | 0] & 2 | ($14 & $10 | $15 & $11 | !($7 & $10 | $8 & $11))) {
     break label$3;
    }
    $3 = HEAPU16[$1 + 44 >> 1];
    while (1) {
     if ($3) {
      $3 = $3 - 1 | 0;
      $5 = HEAP32[HEAP32[$1 + 52 >> 2] + ($3 << 2) >> 2];
      if (!$5) {
       continue;
      }
      if (($4 | 0) == ($5 | 0)) {
       break label$3;
      }
      $5 = HEAP32[$5 + 16 >> 2];
      if (($5 | 0) < 0 | (Math_imul($5, 48) + $12 | 0) != ($4 | 0)) {
       continue;
      }
      break label$3;
     }
     break;
    }
    if (!(!(HEAPU8[(HEAP32[HEAP32[$0 >> 2] + 4 >> 2] + (HEAPU8[$1 + 16 | 0] << 6) | 0) + 44 | 0] & 72 ? HEAPU8[$4 + 12 | 0] & 63 : 1) | (($7 | 0) != ($10 | 0) | ($8 | 0) != ($11 | 0)))) {
     HEAP32[$1 + 40 >> 2] = HEAP32[$1 + 40 >> 2] | 8388608;
    }
    $3 = HEAPU16[$1 + 22 >> 1];
    $5 = HEAP16[$4 + 8 >> 1];
    if (($5 | 0) <= 0) {
     HEAP16[$1 + 22 >> 1] = $3 + $5;
     break label$3;
    }
    HEAP16[$1 + 22 >> 1] = $3 - 1;
    if (!(HEAPU8[$4 + 12 | 0] & 130)) {
     break label$3;
    }
    $3 = HEAP32[HEAP32[$4 >> 2] + 16 >> 2];
    HEAP32[$6 + 12 >> 2] = 0;
    $3 = sqlite3ExprIsInteger($3, $6 + 12 | 0);
    $5 = HEAP32[$6 + 12 >> 2];
    $3 = $3 ? ($5 | 0) > -2 ? ($5 | 0) < 2 ? 10 : 20 : 20 : 20;
    if ($3 >>> 0 <= ($13 & 65535) >>> 0) {
     break label$3;
    }
    HEAP16[$4 + 10 >> 1] = HEAPU16[$4 + 10 >> 1] | 8192;
    $13 = $3;
   }
   $4 = $4 + 48 | 0;
   $9 = $9 - 1 | 0;
   continue;
  }
  break;
 }
 $3 = $2 - ($13 & 65535) | 0;
 if (($3 | 0) < HEAP16[$1 + 22 >> 1]) {
  HEAP16[$1 + 22 >> 1] = $3;
 }
 __stack_pointer = $6 + 16 | 0;
}

function autoVacuumCommit($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 $10 = HEAP32[$1 >> 2];
 invalidateAllOverflowCache($1);
 label$1: {
  if (HEAPU8[$1 + 18 | 0]) {
   break label$1;
  }
  label$2: {
   $3 = btreePagecount($1);
   if (($3 | 0) != (ptrmapPageno($1, $3) | 0)) {
    $8 = HEAP32[$1 + 36 >> 2];
    if (((HEAPU32[16232] / ($8 >>> 0) | 0) + 1 | 0) != ($3 | 0)) {
     break label$2;
    }
   }
   return sqlite3CorruptError(70916);
  }
  $6 = sqlite3Get4byte(HEAP32[HEAP32[$1 + 12 >> 2] + 56 >> 2] + 36 | 0);
  $4 = $6;
  label$4: {
   $7 = HEAP32[$0 >> 2];
   $9 = HEAP32[$7 + 260 >> 2];
   if (!$9) {
    break label$4;
   }
   $5 = HEAP32[$7 + 20 >> 2];
   $5 = ($5 | 0) > 0 ? $5 : 0;
   $4 = HEAP32[$7 + 16 >> 2];
   while (1) {
    label$6: {
     if (($2 | 0) != ($5 | 0)) {
      if (HEAP32[(($2 << 4) + $4 | 0) + 4 >> 2] != ($0 | 0)) {
       break label$6;
      }
      $5 = $2;
     }
     $2 = FUNCTION_TABLE[$9 | 0](HEAP32[$7 + 252 >> 2], HEAP32[($5 << 4) + $4 >> 2], $3, $6, $8) | 0;
     $4 = $2 >>> 0 < $6 >>> 0 ? $2 : $6;
     if ($4) {
      break label$4;
     }
     return 0;
    }
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  $0 = finalDbSize($1, $3, $4);
  if ($3 >>> 0 < $0 >>> 0) {
   return sqlite3CorruptError(70943);
  }
  $2 = 0;
  if ($0 >>> 0 < $3 >>> 0) {
   $2 = saveAllCursors($1, 0, 0);
  }
  $5 = ($4 | 0) == ($6 | 0);
  while (1) {
   if (!($0 >>> 0 >= $3 >>> 0 | $2)) {
    $2 = incrVacuumStep($1, $0, $3, $5);
    $3 = $3 - 1 | 0;
    continue;
   }
   break;
  }
  $3 = 0;
  if (!(!$6 | ($2 | 0) != 101 & ($2 | 0) != 0)) {
   $2 = sqlite3PagerWrite(HEAP32[HEAP32[$1 + 12 >> 2] + 72 >> 2]);
   if (($4 | 0) == ($6 | 0)) {
    sqlite3Put4byte(HEAP32[HEAP32[$1 + 12 >> 2] + 56 >> 2] + 32 | 0, 0);
    sqlite3Put4byte(HEAP32[HEAP32[$1 + 12 >> 2] + 56 >> 2] + 36 | 0, 0);
   }
   sqlite3Put4byte(HEAP32[HEAP32[$1 + 12 >> 2] + 56 >> 2] + 28 | 0, $0);
   HEAP32[$1 + 48 >> 2] = $0;
   HEAP8[$1 + 19 | 0] = 1;
  }
  if (!$2) {
   break label$1;
  }
  sqlite3PagerRollback($10);
  $3 = $2;
 }
 return $3;
}

function rebuildPage($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $9 = HEAP32[$3 + 64 >> 2];
 $4 = HEAP32[$3 + 52 >> 2];
 $13 = sqlite3PagerTempSpace(HEAP32[$4 >> 2]);
 $10 = HEAP32[$3 + 56 >> 2];
 $7 = $10 + HEAPU8[$3 + 9 | 0] | 0;
 $5 = HEAPU8[$7 + 6 | 0] | HEAPU8[$7 + 5 | 0] << 8;
 $4 = HEAP32[$4 + 40 >> 2];
 $5 = $5 >>> 0 > $4 >>> 0 ? 0 : $5;
 $14 = $10 + $5 | 0;
 __memcpy($5 + $13 | 0, $14, $4 - $5 | 0);
 $11 = $4 + $10 | 0;
 while (1) {
  $4 = $6;
  if (HEAP32[(($4 << 2) + $0 | 0) + 40 >> 2] <= ($1 | 0)) {
   $6 = $4 + 1 | 0;
   if ($4 >>> 0 < 6) {
    continue;
   }
  }
  break;
 }
 $17 = $1 + $2 | 0;
 $5 = $11;
 while (1) {
  $6 = ($4 << 2) + $0 | 0;
  $18 = $6;
  $15 = HEAP32[$6 + 16 >> 2];
  label$4: {
   while (1) {
    $6 = HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2];
    $12 = HEAPU16[HEAP32[$0 + 12 >> 2] + ($1 << 1) >> 1];
    $8 = $6 + $12 | 0;
    label$6: {
     label$7: {
      if (!($6 >>> 0 < $14 >>> 0 | $6 >>> 0 >= $11 >>> 0)) {
       if ($8 >>> 0 <= $11 >>> 0) {
        break label$7;
       }
       return sqlite3CorruptError(74180);
      }
      if ($8 >>> 0 <= $15 >>> 0 | $6 >>> 0 >= $15 >>> 0) {
       break label$6;
      }
      return sqlite3CorruptError(74185);
     }
     $6 = ($6 - $10 | 0) + $13 | 0;
    }
    $5 = $5 - $12 | 0;
    $8 = $5 - $10 | 0;
    $16 = $8 << 8 | ($8 & 65280) >>> 8;
    HEAP8[$9 | 0] = $16;
    HEAP8[$9 + 1 | 0] = $16 >>> 8;
    $9 = $9 + 2 | 0;
    if ($9 >>> 0 > $5 >>> 0) {
     return sqlite3CorruptError(74191);
    }
    memmove($5, $6, $12);
    $1 = $1 + 1 | 0;
    if (($17 | 0) <= ($1 | 0)) {
     break label$4;
    }
    if (HEAP32[$18 + 40 >> 2] > ($1 | 0)) {
     continue;
    }
    break;
   }
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP8[$3 + 12 | 0] = 0;
 HEAP16[$3 + 24 >> 1] = $2;
 HEAP8[$7 + 1 | 0] = 0;
 HEAP8[$7 + 2 | 0] = 0;
 HEAP8[$7 + 3 | 0] = HEAPU8[$3 + 25 | 0];
 HEAP8[$7 + 4 | 0] = HEAPU8[$3 + 24 | 0];
 HEAP8[$7 + 6 | 0] = $8;
 HEAP8[$7 + 5 | 0] = $8 >>> 8;
 HEAP8[$7 + 7 | 0] = 0;
 return 0;
}

function windowFullScan($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $2 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 $4 = HEAP32[$3 + 12 >> 2];
 if ($4) {
  $6 = HEAP32[$4 >> 2];
 }
 $1 = HEAP32[$0 + 8 >> 2];
 $7 = HEAP32[$3 + 60 >> 2];
 $9 = sqlite3VdbeMakeLabel($2);
 $5 = sqlite3VdbeMakeLabel($2);
 $10 = sqlite3GetTempReg($2);
 $8 = sqlite3GetTempReg($2);
 if ($6) {
  $11 = sqlite3GetTempRange($2, $6);
  $12 = sqlite3GetTempRange($2, $6);
 }
 sqlite3VdbeAddOp2($1, 135, HEAP32[$3 + 48 >> 2], $10);
 windowReadPeerValues($0, HEAP32[$3 + 48 >> 2], $11);
 $4 = $3;
 while (1) {
  if ($4) {
   sqlite3VdbeAddOp2($1, 75, 0, HEAP32[$4 + 52 >> 2]);
   $4 = HEAP32[$4 + 36 >> 2];
   continue;
  }
  break;
 }
 sqlite3VdbeAddOp3($1, 22, $7, $5, HEAP32[$3 + 88 >> 2]);
 $4 = sqlite3VdbeCurrentAddr($1);
 sqlite3VdbeAddOp2($1, 135, $7, $8);
 sqlite3VdbeAddOp3($1, 54, HEAP32[$3 + 92 >> 2], $5, $8);
 $5 = HEAPU8[$3 + 20 | 0];
 label$5: {
  if (($5 | 0) == 66) {
   break label$5;
  }
  if (($5 | 0) == 85) {
   sqlite3VdbeAddOp3($1, 53, $10, $9, $8);
   break label$5;
  }
  $13 = HEAP32[$3 + 12 >> 2];
  if ($13) {
   $14 = sqlite3KeyInfoFromExprList($2, $13, 0, 0);
   $5 = HEAPU8[$3 + 20 | 0];
  }
  if (($5 & 255) == 94) {
   $15 = sqlite3VdbeAddOp3($1, 53, $10, 0, $8);
  }
  label$9: {
   if ($14) {
    windowReadPeerValues($0, $7, $12);
    sqlite3VdbeAddOp3($1, 90, $12, $11, $6);
    sqlite3VdbeAppendP4($1, $14, -8);
    $5 = sqlite3VdbeCurrentAddr($1) + 1 | 0;
    sqlite3VdbeAddOp3($1, 13, $5, $9, $5);
    break label$9;
   }
   sqlite3VdbeAddOp2($1, 8, 0, $9);
  }
  if (!$15) {
   break label$5;
  }
  sqlite3VdbeJumpHere($1, $15);
 }
 windowAggStep($0, $3, $7, 0, HEAP32[$0 + 20 >> 2]);
 sqlite3VdbeResolveLabel($1, $9);
 sqlite3VdbeAddOp2($1, 38, $7, $4);
 sqlite3VdbeJumpHere($1, $4 - 1 | 0);
 sqlite3VdbeJumpHere($1, $4 + 1 | 0);
 sqlite3ReleaseTempReg($2, $8);
 sqlite3ReleaseTempReg($2, $10);
 if ($6) {
  sqlite3ReleaseTempRange($2, $12, $6);
  sqlite3ReleaseTempRange($2, $11, $6);
 }
 windowAggFinal($0, 1);
}

function sqlite3FindTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  label$2: {
   if ($2) {
    $5 = HEAP32[$0 + 20 >> 2];
    $4 = ($5 | 0) > 0 ? $5 : 0;
    $6 = $0;
    $5 = $0 + 16 | 0;
    label$4: {
     while (1) {
      if (($3 | 0) != ($4 | 0)) {
       $0 = HEAP32[$6 + 16 >> 2];
       if (!sqlite3StrICmp($2, HEAP32[$0 + ($3 << 4) >> 2])) {
        break label$4;
       }
       $3 = $3 + 1 | 0;
       continue;
      }
      break;
     }
     $4 = 0;
     if (sqlite3StrICmp($2, 10765)) {
      break label$1;
     }
     $0 = HEAP32[$6 + 16 >> 2];
     $3 = 0;
    }
    $4 = sqlite3HashFind(HEAP32[(($3 << 4) + $0 | 0) + 12 >> 2] + 8 | 0, $1);
    if ($4) {
     break label$1;
    }
    $4 = 0;
    if (sqlite3_strnicmp($1, 17751, 7)) {
     break label$1;
    }
    $2 = $1 + 7 | 0;
    $0 = 1;
    if (($3 | 0) == 1) {
     $1 = 8671;
     if (!sqlite3StrICmp($2, 17644)) {
      break label$2;
     }
     if (!sqlite3StrICmp($2, 17663)) {
      break label$2;
     }
     if (!sqlite3StrICmp($2, 8697)) {
      break label$2;
     }
     break label$1;
    }
    if (sqlite3StrICmp($2, 17663)) {
     break label$1;
    }
    $1 = 8690;
    $0 = $3;
    break label$2;
   }
   $4 = sqlite3HashFind(HEAP32[HEAP32[$0 + 16 >> 2] + 28 >> 2] + 8 | 0, $1);
   if ($4) {
    break label$1;
   }
   $5 = $0 + 16 | 0;
   $4 = sqlite3HashFind(HEAP32[HEAP32[$5 >> 2] + 12 >> 2] + 8 | 0, $1);
   if ($4) {
    break label$1;
   }
   $3 = 2;
   while (1) {
    if (HEAP32[$0 + 20 >> 2] > ($3 | 0)) {
     $2 = $3 << 4;
     $3 = $3 + 1 | 0;
     $4 = sqlite3HashFind(HEAP32[(HEAP32[$0 + 16 >> 2] + $2 | 0) + 12 >> 2] + 8 | 0, $1);
     if (!$4) {
      continue;
     }
     break label$1;
    }
    break;
   }
   $4 = 0;
   if (sqlite3_strnicmp($1, 17751, 7)) {
    break label$1;
   }
   $3 = $1 + 7 | 0;
   if (!sqlite3StrICmp($3, 17663)) {
    $1 = 8690;
    $0 = 0;
    break label$2;
   }
   if (sqlite3StrICmp($3, 17644)) {
    break label$1;
   }
   $1 = 8671;
   $0 = 1;
  }
  $4 = sqlite3HashFind(HEAP32[(HEAP32[$5 >> 2] + ($0 << 4) | 0) + 12 >> 2] + 8 | 0, $1);
 }
 return $4;
}

function fts3EvalNearTest($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $5 = 1;
 label$1: {
  if (HEAP32[$1 >> 2] | HEAP32[$0 >> 2] != 1) {
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2];
  if (HEAP32[$2 >> 2] == 1 ? $2 : 0) {
   break label$1;
  }
  $2 = $0;
  while (1) {
   $5 = HEAP32[$2 + 12 >> 2];
   if ($5) {
    $3 = HEAP32[HEAP32[$2 + 16 >> 2] + 20 >> 2];
    $3 = HEAP32[$3 + 32 >> 2];
    $4 = $3 >> 31;
    $2 = $3;
    $3 = $4;
    $4 = $7;
    $4 = $3 + $4 | 0;
    $3 = $9;
    $7 = $2;
    $8 = $3 + $7 | 0;
    $9 = $8;
    $4 = $8 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
    $7 = $4;
    $2 = $5;
    continue;
   }
   break;
  }
  $4 = HEAP32[$2 + 20 >> 2];
  $4 = HEAP32[$4 + 32 >> 2];
  $3 = $4 >> 31;
  $5 = $4;
  $4 = $3;
  $3 = $7;
  $8 = $3 + $4 | 0;
  $4 = $9;
  $7 = $5;
  $3 = $4 + $7 | 0;
  $8 = $3 >>> 0 < $7 >>> 0 ? $8 + 1 | 0 : $8;
  label$5: {
   $4 = $8 << 1 | $3 >>> 31;
   $3 = sqlite3_malloc64($3 << 1, $4);
   if (!$3) {
    HEAP32[$1 >> 2] = 7;
    $5 = 0;
    break label$5;
   }
   $5 = HEAP32[$2 + 20 >> 2];
   HEAP32[$6 + 12 >> 2] = HEAP32[$5 + 28 >> 2];
   HEAP32[$6 + 8 >> 2] = HEAP32[$5 + 64 >> 2];
   $5 = 1;
   while (1) {
    label$8: {
     if (!$5) {
      break label$8;
     }
     $2 = HEAP32[$2 + 8 >> 2];
     if (!$2 | HEAP32[$2 >> 2] != 1) {
      break label$8;
     }
     $5 = fts3EvalNearTrim(HEAP32[$2 + 4 >> 2], $3, $6 + 12 | 0, $6 + 8 | 0, HEAP32[HEAP32[$2 + 16 >> 2] + 20 >> 2]);
     continue;
    }
    break;
   }
   $2 = HEAP32[HEAP32[$0 + 16 >> 2] + 20 >> 2];
   HEAP32[$6 + 12 >> 2] = HEAP32[$2 + 28 >> 2];
   HEAP32[$6 + 8 >> 2] = HEAP32[$2 + 64 >> 2];
   while (1) {
    $0 = HEAP32[$0 + 12 >> 2];
    if (!$0 | !$5) {
     break label$5;
    }
    $2 = $0;
    if (HEAP32[$2 >> 2] == 1) {
     $2 = HEAP32[$0 + 16 >> 2];
    }
    $5 = HEAP32[HEAP32[$0 + 8 >> 2] + 4 >> 2];
    $5 = fts3EvalNearTrim($5, $3, $6 + 12 | 0, $6 + 8 | 0, HEAP32[$2 + 20 >> 2]);
    continue;
   }
  }
  sqlite3_free($3);
 }
 __stack_pointer = $6 + 16 | 0;
 return $5;
}

function checkList($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $10 = HEAP32[$0 + 20 >> 2];
 $5 = $3;
 label$1: {
  while (1) {
   label$3: {
    if (!$2 | !HEAP32[$0 + 16 >> 2]) {
     break label$3;
    }
    if (checkRef($0, $2)) {
     break label$3;
    }
    $6 = $5 - 1 | 0;
    if (sqlite3PagerGet(HEAP32[$0 + 4 >> 2], $2, $4 + 44 | 0, 0)) {
     HEAP32[$4 + 32 >> 2] = $2;
     checkAppendMsg($0, 16527, $4 + 32 | 0);
     break label$1;
    } else {
     $8 = sqlite3PagerGetData(HEAP32[$4 + 44 >> 2]);
     label$6: {
      label$7: {
       label$8: {
        if ($1) {
         $9 = sqlite3Get4byte($8 + 4 | 0);
         $7 = HEAP32[$0 >> 2];
         if (HEAPU8[$7 + 17 | 0]) {
          checkPtrmap($0, $2, 2, 0);
          $7 = HEAP32[$0 >> 2];
         }
         if ($9 >>> 0 > (HEAP32[$7 + 40 >> 2] >>> 2 | 0) - 2 >>> 0) {
          break label$8;
         }
         $2 = 0;
         $7 = ($9 | 0) > 0 ? $9 : 0;
         while (1) {
          if (($2 | 0) != ($7 | 0)) {
           $5 = sqlite3Get4byte((($2 << 2) + $8 | 0) + 8 | 0);
           if (HEAPU8[HEAP32[$0 >> 2] + 17 | 0]) {
            checkPtrmap($0, $5, 2, 0);
           }
           checkRef($0, $5);
           $2 = $2 + 1 | 0;
           continue;
          }
          break;
         }
         $5 = $6 - $9 | 0;
         break label$6;
        }
        if (!HEAPU8[HEAP32[$0 >> 2] + 17 | 0] | !$6) {
         break label$7;
        }
        checkPtrmap($0, sqlite3Get4byte($8), 4, $2);
        break label$7;
       }
       HEAP32[$4 + 16 >> 2] = $2;
       checkAppendMsg($0, 16574, $4 + 16 | 0);
       $5 = $5 - 2 | 0;
       break label$6;
      }
      $5 = $6;
     }
     $2 = sqlite3Get4byte($8);
     sqlite3PagerUnref(HEAP32[$4 + 44 >> 2]);
     continue;
    }
   }
   break;
  }
  $6 = $5;
 }
 if (!(!$6 | HEAP32[$0 + 20 >> 2] != ($10 | 0))) {
  HEAP32[$4 >> 2] = $1 ? 12188 : 11671;
  HEAP32[$4 + 8 >> 2] = $3;
  HEAP32[$4 + 4 >> 2] = $3 - $6;
  checkAppendMsg($0, 16651, $4);
 }
 __stack_pointer = $4 + 48 | 0;
}

function sqlite3Fts3DoclistPrev($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $12 = HEAP32[$3 >> 2];
 HEAP32[$7 + 12 >> 2] = $12;
 label$1: {
  if (!$12) {
   $14 = 1;
   $9 = $0 ? -1 : 1;
   $6 = $9;
   $8 = $0 ? -1 : 0;
   $15 = $8;
   $12 = $1 + $2 | 0;
   $0 = 0;
   while (1) {
    if ($1 >>> 0 < $12 >>> 0) {
     $0 = sqlite3Fts3GetVarint($1, $7) + $1 | 0;
     HEAP32[$7 + 8 >> 2] = $0;
     $8 = HEAP32[$7 >> 2];
     $9 = HEAP32[$7 + 4 >> 2];
     $1 = $9;
     fts3PoslistCopy(0, $7 + 8 | 0);
     $11 = $10;
     $9 = $16;
     $2 = $8;
     $8 = $1;
     $8 = __wasm_i64_mul($14, $9, $2, $8);
     $10 = $11 + $8 | 0;
     $8 = $13;
     $9 = i64toi32_i32$HIGH_BITS;
     $2 = $8 + $9 | 0;
     $2 = $10 >>> 0 < $11 >>> 0 ? $2 + 1 | 0 : $2;
     $13 = $2;
     $1 = HEAP32[$7 + 8 >> 2];
     while (1) {
      if (!(HEAPU8[$1 | 0] | $1 >>> 0 >= $12 >>> 0)) {
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     HEAP32[$7 + 8 >> 2] = $1;
     $14 = $6;
     $2 = $15;
     $16 = $2;
     continue;
    }
    break;
   }
   HEAP32[$5 >> 2] = $12 - $0;
   HEAP32[$3 >> 2] = $0;
   HEAP32[$4 >> 2] = $10;
   $2 = $13;
   HEAP32[$4 + 4 >> 2] = $2;
   break label$1;
  }
  fts3GetReverseVarint($7 + 12 | 0, $1, $7);
  $9 = $4;
  $2 = HEAP32[$9 >> 2];
  $13 = $2;
  $10 = HEAP32[$7 >> 2];
  $11 = $10;
  $8 = 0 - $11 | 0;
  $2 = HEAP32[$7 + 4 >> 2];
  $10 = $2 + (($11 | 0) != 0) | 0;
  $10 = 0 - $10 | 0;
  $9 = $10;
  $2 = $0 ? $2 : $9;
  $11 = $0 ? $11 : $8;
  $10 = $11;
  $9 = $13 + $11 | 0;
  $11 = $2;
  $2 = HEAP32[$4 + 4 >> 2];
  $8 = $11 + $2 | 0;
  HEAP32[$4 >> 2] = $9;
  $8 = $9 >>> 0 < $10 >>> 0 ? $8 + 1 | 0 : $8;
  HEAP32[$4 + 4 >> 2] = $8;
  $12 = HEAP32[$7 + 12 >> 2];
  label$7: {
   if (($12 | 0) == ($1 | 0)) {
    HEAP8[$6 | 0] = 1;
    break label$7;
   }
   fts3ReversePoslist($1, $7 + 12 | 0);
   $1 = HEAP32[$7 + 12 >> 2];
   HEAP32[$5 >> 2] = $12 - $1;
  }
  HEAP32[$3 >> 2] = $1;
 }
 __stack_pointer = $7 + 16 | 0;
}

function sqlite3WindowUpdate($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  $4 = HEAP32[$2 >> 2];
  label$2: {
   if (!(HEAPU8[$2 + 16 | 0] | !$4)) {
    $4 = windowFind($0, $1, $4);
    if (!$4) {
     break label$1;
    }
    HEAP32[$2 + 8 >> 2] = sqlite3ExprListDup(HEAP32[$0 >> 2], HEAP32[$4 + 8 >> 2], 0);
    HEAP32[$2 + 12 >> 2] = sqlite3ExprListDup(HEAP32[$0 >> 2], HEAP32[$4 + 12 >> 2], 0);
    HEAP32[$2 + 24 >> 2] = sqlite3ExprDup(HEAP32[$0 >> 2], HEAP32[$4 + 24 >> 2], 0);
    HEAP32[$2 + 28 >> 2] = sqlite3ExprDup(HEAP32[$0 >> 2], HEAP32[$4 + 28 >> 2], 0);
    HEAP8[$2 + 17 | 0] = HEAPU8[$4 + 17 | 0];
    HEAP8[$2 + 18 | 0] = HEAPU8[$4 + 18 | 0];
    $1 = HEAPU8[$4 + 16 | 0];
    HEAP8[$2 + 16 | 0] = $1;
    HEAP8[$2 + 20 | 0] = HEAPU8[$4 + 20 | 0];
    break label$2;
   }
   sqlite3WindowChain($0, $2, $1);
   $1 = HEAPU8[$2 + 16 | 0];
  }
  label$4: {
   label$5: {
    if (!(HEAP32[$2 + 28 >> 2] ? 1 : HEAP32[$2 + 24 >> 2]) | ($1 & 255) != 89) {
     break label$5;
    }
    $1 = HEAP32[$2 + 12 >> 2];
    if (HEAP32[$1 >> 2] == 1 ? $1 : 0) {
     break label$5;
    }
    sqlite3ErrorMsg($0, 10279, 0);
    break label$4;
   }
   if (!(HEAP8[$3 + 6 | 0] & 1)) {
    break label$4;
   }
   if (!HEAP32[$2 + 40 >> 2]) {
    $4 = HEAP32[$0 >> 2];
    $1 = HEAP32[$3 + 32 >> 2];
    $0 = 0;
    while (1) {
     if (($0 | 0) == 8) {
      break label$4;
     }
     if (HEAP32[($0 << 4) + 48752 >> 2] == ($1 | 0)) {
      sqlite3ExprDelete($4, HEAP32[$2 + 24 >> 2]);
      sqlite3ExprDelete($4, HEAP32[$2 + 28 >> 2]);
      HEAP8[$2 + 20 | 0] = 0;
      $0 = $0 << 4;
      HEAP8[$2 + 18 | 0] = HEAP32[$0 + 48764 >> 2];
      $1 = HEAPU8[$0 + 48760 | 0];
      HEAP8[$2 + 17 | 0] = $1;
      HEAP8[$2 + 16 | 0] = HEAP32[$0 + 48756 >> 2];
      HEAP32[$2 + 24 >> 2] = 0;
      HEAP32[$2 + 28 >> 2] = 0;
      if (($1 | 0) != 86) {
       break label$4;
      }
      HEAP32[$2 + 24 >> 2] = sqlite3Expr($4, 155, 23470);
      break label$4;
     } else {
      $0 = $0 + 1 | 0;
      continue;
     }
    }
   }
   sqlite3ErrorMsg($0, 4623, 0);
  }
  HEAP32[$2 + 44 >> 2] = $3;
 }
}

function fixSelectCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $4 = HEAP32[$0 + 24 >> 2];
 $9 = HEAP32[HEAP32[$4 >> 2] >> 2];
 $10 = sqlite3FindDbName($9, HEAP32[$4 + 40 >> 2]);
 $7 = HEAP32[$1 + 32 >> 2];
 label$1: {
  if (!$7) {
   $4 = 0;
   break label$1;
  }
  $11 = $4 + 4 | 0;
  $3 = $7 + 8 | 0;
  label$3: {
   while (1) {
    if (HEAP32[$7 >> 2] > ($5 | 0)) {
     if (!HEAPU8[$4 + 36 | 0]) {
      $2 = HEAP32[$3 + 4 >> 2];
      label$7: {
       if (!$2) {
        $2 = HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8;
        break label$7;
       }
       if ((sqlite3FindDbName($9, $2) | 0) != ($10 | 0)) {
        $5 = HEAP32[$4 >> 2];
        $0 = HEAP32[$4 + 48 >> 2];
        $1 = HEAP32[$4 + 44 >> 2];
        HEAP32[$6 + 8 >> 2] = $2;
        HEAP32[$6 >> 2] = $1;
        HEAP32[$6 + 4 >> 2] = $0;
        sqlite3ErrorMsg($5, 6355, $6);
        break label$3;
       }
       sqlite3DbFree($9, $2);
       HEAP32[$3 + 4 >> 2] = 0;
       $2 = $3 + 37 | 0;
       $8 = $2;
       $2 = HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8 | 512;
       HEAP8[$8 | 0] = $2;
       HEAP8[$8 + 1 | 0] = $2 >>> 8;
      }
      $8 = HEAP32[$4 + 32 >> 2];
      $2 = $2 | 128;
      HEAP8[$3 + 37 | 0] = $2;
      HEAP8[$3 + 38 | 0] = $2 >>> 8;
      HEAP32[$3 >> 2] = $8;
     }
     $2 = ($5 << 6) + $7 | 0;
     if (!(HEAPU8[$2 + 46 | 0] & 4)) {
      if (sqlite3WalkExpr($11, HEAP32[$2 + 52 >> 2])) {
       break label$3;
      }
     }
     $3 = $3 - -64 | 0;
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   $4 = 0;
   if (!HEAP32[$1 + 64 >> 2]) {
    break label$1;
   }
   $5 = 0;
   while (1) {
    $3 = HEAP32[$1 + 64 >> 2];
    if (HEAP32[$3 >> 2] <= ($5 | 0)) {
     break label$1;
    }
    $7 = Math_imul($5, 24);
    $5 = $5 + 1 | 0;
    if (!sqlite3WalkSelect($0, HEAP32[($3 + $7 | 0) + 20 >> 2])) {
     continue;
    }
    break;
   }
  }
  $4 = 2;
 }
 __stack_pointer = $6 + 16 | 0;
 return $4 | 0;
}

function __multi3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $11 = $2;
 $9 = $8;
 $9 = __wasm_i64_mul($1, $11, $7, $9);
 $8 = $9;
 $11 = i64toi32_i32$HIGH_BITS;
 $7 = $11;
 $11 = $4;
 $9 = $6;
 $9 = __wasm_i64_mul($3, $11, $5, $9);
 $13 = $9;
 $11 = i64toi32_i32$HIGH_BITS;
 $9 = $11;
 $11 = $7;
 $12 = $11 + $9 | 0;
 $9 = $8;
 $10 = $9 + $13 | 0;
 $14 = $10;
 $12 = $10 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
 $10 = $12;
 $9 = 0;
 $4 = $9;
 $11 = 0;
 $8 = $11;
 $12 = $6;
 $3 = $12;
 $9 = $2;
 $7 = $9;
 $12 = __wasm_i64_mul($6, $4, $9, $11);
 $13 = $12;
 $11 = i64toi32_i32$HIGH_BITS;
 $12 = $11;
 $11 = $10;
 $10 = $11 + $12 | 0;
 $9 = $14;
 $9 = $9 + $13 | 0;
 $10 = $9 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
 $15 = $9;
 $16 = $10;
 $11 = $5;
 $5 = $11;
 $9 = 0;
 $6 = $9;
 $10 = $1;
 $1 = $10;
 $11 = 0;
 $2 = $11;
 $11 = $6;
 $10 = $2;
 $10 = __wasm_i64_mul($5, $11, $1, $10);
 $14 = $10;
 $10 = 0;
 $2 = $10;
 $11 = i64toi32_i32$HIGH_BITS;
 $10 = $6;
 $9 = $8;
 $9 = __wasm_i64_mul($5, $10, $7, $9);
 $13 = $9;
 $12 = $11 + $9 | 0;
 $10 = i64toi32_i32$HIGH_BITS;
 $9 = $10;
 $10 = $2;
 $9 = $9 + $10 | 0;
 $5 = $12;
 $9 = $12 >>> 0 < $13 >>> 0 ? $9 + 1 | 0 : $9;
 $6 = $9;
 $11 = 0;
 $10 = $11;
 $11 = $16;
 $12 = $11 + $10 | 0;
 $9 = $15;
 $13 = $6;
 $9 = $9 + $13 | 0;
 $12 = $9 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
 $7 = $9;
 $6 = $12;
 $12 = $2;
 $9 = $4;
 $9 = __wasm_i64_mul($1, $12, $3, $9);
 $12 = i64toi32_i32$HIGH_BITS;
 $1 = $12;
 $11 = $5;
 $13 = $11;
 $12 = $9;
 $10 = $11 + $12 | 0;
 $9 = 0;
 $11 = $9;
 $9 = $1;
 $9 = $11 + $9 | 0;
 $1 = $10;
 $9 = $13 >>> 0 > $10 >>> 0 ? $9 + 1 | 0 : $9;
 $2 = $9;
 $12 = 0;
 $9 = $12;
 $12 = $6;
 $10 = $9 + $12 | 0;
 $9 = $7;
 $13 = $2;
 $11 = $9 + $13 | 0;
 $10 = $11 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
 $9 = $0;
 HEAP32[$9 + 8 >> 2] = $11;
 HEAP32[$9 + 12 >> 2] = $10;
 $9 = 0;
 $2 = $9;
 $12 = $14;
 $9 = $12;
 $13 = 0;
 $3 = $9 | $13;
 $9 = $0;
 HEAP32[$9 >> 2] = $3;
 $10 = $1;
 $12 = $2;
 $10 = $10 | $12;
 HEAP32[$9 + 4 >> 2] = $10;
}

function fts3IncrmergeAppend($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $11 = HEAP32[$2 + 52 >> 2];
 $14 = HEAP32[$2 + 48 >> 2];
 $6 = HEAP32[$2 + 44 >> 2];
 $10 = HEAP32[$2 + 40 >> 2];
 HEAP32[$5 + 12 >> 2] = 0;
 $12 = $1 - -64 | 0;
 $8 = fts3PrefixCompress(HEAP32[$12 >> 2], HEAP32[$1 + 68 >> 2], $10, $6);
 $2 = $6 - $8 | 0;
 label$1: {
  if (($2 | 0) <= 0) {
   $2 = 267;
   break label$1;
  }
  $4 = $8;
  $3 = $4 >> 31;
  $7 = sqlite3Fts3VarintLen($4, $3) + $2 | 0;
  $4 = $11;
  $3 = $4 >> 31;
  $2 = $7 + sqlite3Fts3VarintLen($2, 0) | 0;
  $7 = sqlite3Fts3VarintLen($4, $3) + $4 | 0;
  $2 = $2 + $7 | 0;
  $13 = $1 + 76 | 0;
  $9 = HEAP32[$1 + 80 >> 2];
  if (!(($9 | 0) <= 0 | HEAP32[$0 + 232 >> 2] >= ($2 + $9 | 0))) {
   $3 = HEAP32[$1 + 56 >> 2];
   $4 = HEAP32[$1 + 60 >> 2];
   $2 = fts3WriteSegment($0, $3, $4, HEAP32[$1 + 76 >> 2], $9);
   HEAP32[$5 + 12 >> 2] = $2;
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
   if (!$2) {
    HEAP32[$5 + 12 >> 2] = fts3IncrmergePush($0, $1, $10, $8 + 1 | 0);
   }
   $9 = 0;
   HEAP32[$1 + 80 >> 2] = 0;
   HEAP32[$1 + 68 >> 2] = 0;
   $4 = HEAP32[$1 + 56 >> 2];
   $0 = $4;
   $3 = HEAP32[$1 + 60 >> 2];
   $0 = $0 + 1 | 0;
   $3 = $0 ? $3 : $3 + 1 | 0;
   HEAP32[$1 + 56 >> 2] = $0;
   HEAP32[$1 + 60 >> 2] = $3;
   $3 = $6 >> 31;
   $2 = (sqlite3Fts3VarintLen($6, $3) + ($6 + $7 | 0) | 0) + 1 | 0;
  }
  $0 = HEAP32[$1 + 44 >> 2];
  $8 = $0;
  $0 = $2 >> 31;
  $7 = $0;
  $3 = HEAP32[$1 + 40 >> 2];
  $4 = $2 + $3 | 0;
  $0 = $8;
  $3 = $7;
  $0 = $0 + $3 | 0;
  HEAP32[$1 + 40 >> 2] = $4;
  $0 = $2 >>> 0 > $4 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$1 + 44 >> 2] = $0;
  blobGrowBuffer($13, $2 + $9 | 0, $5 + 12 | 0);
  $2 = HEAP32[$5 + 12 >> 2];
  if ($2) {
   break label$1;
  }
  if (!HEAP32[$1 + 80 >> 2]) {
   HEAP32[$1 + 80 >> 2] = 1;
   HEAP8[HEAP32[$1 + 76 >> 2]] = 0;
  }
  $2 = fts3AppendToNode($13, $12, $10, $6, $14, $11);
 }
 __stack_pointer = $5 + 16 | 0;
 return $2;
}

function memjrnlWrite($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $5 = HEAP32[$0 + 8 >> 2];
 $6 = ($2 >> 31) + $4 | 0;
 $7 = $2;
 $8 = $3;
 $9 = $7 + $8 | 0;
 label$1: {
  $6 = $8 >>> 0 > $9 >>> 0 ? $6 + 1 | 0 : $6;
  $7 = $6;
  $8 = $9;
  if (!(($7 | 0) <= 0 & $8 >>> 0 <= $5 >>> 0 | ($7 | 0) < 0 | ($5 | 0) <= 0)) {
   $10 = memjrnlCreateFile($0);
   if ($10) {
    break label$1;
   }
   return sqlite3OsWrite($0, $1, $2, $3, $4) | 0;
  }
  label$3: {
   $8 = $3;
   if (!!$8 & ($4 | 0) >= 0 | ($4 | 0) > 0) {
    $8 = HEAP32[$0 + 16 >> 2];
    $7 = $8;
    $6 = $3;
    $8 = $4;
    if (($7 | 0) == ($6 | 0) & ($8 | 0) == HEAP32[$0 + 20 >> 2]) {
     break label$3;
    }
    $7 = $4;
    memjrnlTruncate($0, $3, $7);
    break label$3;
   }
   $6 = $3;
   $7 = $4;
   if ($6 | $7) {
    break label$3;
   }
   $5 = HEAP32[$0 + 12 >> 2];
   if (!$5) {
    break label$3;
   }
   __memcpy($5 + 4 | 0, $1, $2);
   break label$1;
  }
  $11 = $0 + 12 | 0;
  while (1) {
   if (($2 | 0) <= 0) {
    break label$1;
   }
   $8 = HEAP32[$0 + 24 >> 2];
   $6 = HEAP32[$0 + 16 >> 2];
   $5 = $6;
   $7 = HEAP32[$0 + 20 >> 2];
   $3 = $7;
   $4 = HEAP32[$0 + 4 >> 2];
   $6 = $4;
   $7 = $6 >> 31;
   $6 = $7;
   $7 = $3;
   $6 = __wasm_i64_srem($5, $7, $4, $6);
   label$6: {
    if ($6) {
     $5 = $8;
     break label$6;
    }
    $5 = sqlite3_malloc($4 + 4 | 0);
    if (!$5) {
     return 3082;
    }
    HEAP32[$5 >> 2] = 0;
    HEAP32[($8 ? $8 : $11) >> 2] = $5;
    HEAP32[$0 + 24 >> 2] = $5;
   }
   $3 = ($5 + $6 | 0) + 4 | 0;
   $5 = $4 - $6 | 0;
   $5 = ($2 | 0) < ($5 | 0) ? $2 : $5;
   __memcpy($3, $1, $5);
   $6 = HEAP32[$0 + 20 >> 2];
   $3 = $6;
   $7 = HEAP32[$0 + 16 >> 2];
   $4 = $7 + $5 | 0;
   $6 = $5 >> 31;
   $7 = $6;
   $6 = $3;
   $9 = $7 + $6 | 0;
   HEAP32[$0 + 16 >> 2] = $4;
   $9 = $5 >>> 0 > $4 >>> 0 ? $9 + 1 | 0 : $9;
   HEAP32[$0 + 20 >> 2] = $9;
   $2 = $2 - $5 | 0;
   $1 = $1 + $5 | 0;
   continue;
  }
 }
 return $10 | 0;
}

function vdbeIncrPopulate($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 $14 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[$0 + 12 >> 2];
 $15 = $2;
 $4 = $0;
 $1 = HEAP32[$4 + 8 >> 2];
 $16 = $1;
 vdbePmaWriterInit(HEAP32[$4 + 48 >> 2], $6 + 8 | 0, HEAP32[HEAP32[HEAP32[$4 >> 2] + 8 >> 2] + 12 >> 2], $1, $2);
 while (1) {
  label$2: {
   if ($10) {
    break label$2;
   }
   $8 = HEAP32[$14 + 12 >> 2] + Math_imul(HEAP32[HEAP32[$14 + 8 >> 2] + 4 >> 2], 56) | 0;
   if (!HEAP32[$8 + 24 >> 2]) {
    break label$2;
   }
   $4 = $6;
   $2 = HEAP32[$4 + 24 >> 2];
   $1 = $2 >> 31;
   $11 = $2;
   $12 = $1;
   $9 = HEAP32[$8 + 20 >> 2];
   $2 = $9;
   $1 = $2 >> 31;
   $9 = $2;
   $13 = $1;
   $1 = HEAP32[$6 + 32 >> 2];
   $7 = $1;
   $3 = $2 + $1 | 0;
   $2 = HEAP32[$6 + 36 >> 2];
   $1 = $2;
   $2 = $13;
   $5 = $1 + $2 | 0;
   $1 = $3;
   $5 = $3 >>> 0 < $7 >>> 0 ? $5 + 1 | 0 : $5;
   $4 = $5;
   $5 = $12;
   $3 = $4 + $5 | 0;
   $2 = $11;
   $7 = $1;
   $1 = $2 + $7 | 0;
   $3 = $1 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
   $5 = $1;
   $1 = $3;
   $3 = $13;
   $2 = sqlite3VarintLen($9, $3);
   $3 = $2 >> 31;
   $7 = $2;
   $2 = $3;
   $3 = $1;
   $1 = $2 + $3 | 0;
   $4 = $7 + $5 | 0;
   $1 = $4 >>> 0 < $7 >>> 0 ? $1 + 1 | 0 : $1;
   $11 = $4;
   $12 = $1;
   $3 = $0;
   $1 = HEAP32[$3 + 16 >> 2];
   $5 = $1 >> 31;
   $7 = $1;
   $1 = $5;
   $5 = $15;
   $4 = $1 + $5 | 0;
   $3 = $16;
   $2 = $7 + $3 | 0;
   $4 = $2 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
   $3 = $4;
   $5 = $11;
   $4 = $12;
   if ($2 >>> 0 < $5 >>> 0 & ($4 | 0) >= ($3 | 0) | ($3 | 0) < ($4 | 0)) {
    break label$2;
   }
   $5 = $13;
   vdbePmaWriteVarint($6 + 8 | 0, $9, $5);
   vdbePmaWriteBlob($6 + 8 | 0, HEAP32[$8 + 32 >> 2], $9);
   $10 = vdbeMergeEngineStep(HEAP32[$0 + 4 >> 2], $6 + 4 | 0);
   continue;
  }
  break;
 }
 $8 = vdbePmaWriterFinish($6 + 8 | 0, $0 + 56 | 0);
 __stack_pointer = $6 + 48 | 0;
 return $10 ? $10 : $8;
}

function sqlite3_declare_vtab($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = __stack_pointer - 288 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$0 + 400 >> 2];
 label$1: {
  if (!(HEAP32[$3 + 12 >> 2] ? 0 : $3)) {
   sqlite3Error($0, 21);
   $0 = sqlite3MisuseError(148048);
   break label$1;
  }
  $4 = HEAP32[$3 + 4 >> 2];
  sqlite3ParseObjectInit($2 + 16 | 0, $0);
  $5 = 1;
  HEAP8[$2 + 167 | 0] = 1;
  HEAP8[$2 + 224 | 0] = 1;
  $6 = $0 + 177 | 0;
  $7 = HEAPU8[$6 | 0];
  HEAP8[$0 + 177 | 0] = 0;
  HEAP32[$2 + 152 >> 2] = 1;
  label$4: {
   label$5: {
    if (sqlite3RunParser($2 + 16 | 0, $1)) {
     break label$5;
    }
    $1 = HEAP32[$2 + 252 >> 2];
    if (HEAPU8[$0 + 87 | 0] | !$1 | HEAPU8[$1 + 43 | 0]) {
     break label$5;
    }
    $5 = 0;
    label$6: {
     if (HEAP32[$4 + 4 >> 2]) {
      break label$6;
     }
     HEAP32[$4 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
     sqlite3ExprListDelete($0, HEAP32[$1 + 52 >> 2]);
     $5 = HEAPU16[$1 + 34 >> 1];
     HEAP16[$4 + 36 >> 1] = $5;
     HEAP16[$4 + 34 >> 1] = $5;
     HEAP32[$4 + 28 >> 2] = HEAP32[$4 + 28 >> 2] | HEAP32[$1 + 28 >> 2] & 640;
     $5 = 0;
     HEAP32[$1 + 4 >> 2] = 0;
     HEAP16[$1 + 34 >> 1] = 0;
     if (!(!(HEAPU8[$1 + 28 | 0] & 128) | !HEAP32[HEAP32[HEAP32[HEAP32[$3 >> 2] + 4 >> 2] >> 2] + 52 >> 2])) {
      $5 = HEAPU16[sqlite3PrimaryKeyIndex($1) + 50 >> 1] != 1;
     }
     $6 = HEAP32[$1 + 8 >> 2];
     if (!$6) {
      break label$6;
     }
     HEAP32[$4 + 8 >> 2] = $6;
     HEAP32[$1 + 8 >> 2] = 0;
     HEAP32[$6 + 12 >> 2] = $4;
    }
    HEAP32[$3 + 12 >> 2] = 1;
    break label$4;
   }
   $3 = HEAP32[$2 + 20 >> 2];
   HEAP32[$2 >> 2] = $3;
   sqlite3ErrorWithMsg($0, 1, $3 ? 8342 : 0, $2);
   sqlite3DbFree($0, HEAP32[$2 + 20 >> 2]);
  }
  HEAP8[$2 + 224 | 0] = 0;
  $3 = HEAP32[$2 + 24 >> 2];
  if ($3) {
   sqlite3VdbeFinalize($3);
  }
  sqlite3DeleteTable($0, HEAP32[$2 + 252 >> 2]);
  sqlite3ParseObjectReset($2 + 16 | 0);
  HEAP8[$0 + 177 | 0] = $7;
  $0 = sqlite3ApiExit($0, $5);
 }
 __stack_pointer = $2 + 288 | 0;
 return $0;
}

function fkScanChildren($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $9 = __stack_pointer - 32 | 0;
 __stack_pointer = $9;
 $11 = HEAP32[$0 >> 2];
 $13 = sqlite3GetVdbe($0);
 if (($7 | 0) < 0) {
  $14 = sqlite3VdbeAddOp2($13, 48, HEAPU8[$4 + 24 | 0], 0);
 }
 $15 = $4 + 36 | 0;
 while (1) {
  if (($8 | 0) < HEAP32[$4 + 20 >> 2]) {
   $12 = $3 ? HEAPU16[HEAP32[$3 + 4 >> 2] + ($8 << 1) >> 1] : 65535;
   $10 = sqlite3ExprAnd($0, $10, sqlite3PExpr($0, 53, exprTableRegister($0, $2, $6, $12 << 16 >> 16), sqlite3Expr($11, 59, HEAP32[HEAP32[HEAP32[$4 >> 2] + 4 >> 2] + Math_imul(HEAP16[($5 ? ($8 << 2) + $5 | 0 : $15) >> 1], 12) >> 2])));
   $8 = $8 + 1 | 0;
   continue;
  }
  break;
 }
 if (!(HEAP32[$4 >> 2] != ($2 | 0) | ($7 | 0) <= 0)) {
  label$7: {
   if (HEAPU8[$2 + 28 | 0] & 128) {
    $5 = 0;
    $8 = 0;
    while (1) {
     if ($8 >>> 0 < HEAPU16[$3 + 50 >> 1]) {
      $12 = HEAP16[HEAP32[$3 + 4 >> 2] + ($8 << 1) >> 1];
      $5 = sqlite3ExprAnd($0, $5, sqlite3PExpr($0, 45, exprTableRegister($0, $2, $6, $12), sqlite3Expr($11, 59, HEAP32[HEAP32[$2 + 4 >> 2] + Math_imul($12, 12) >> 2])));
      $8 = $8 + 1 | 0;
      continue;
     }
     break;
    }
    $8 = sqlite3PExpr($0, 19, $5, 0);
    break label$7;
   }
   $8 = sqlite3PExpr($0, 52, exprTableRegister($0, $2, $6, -1), exprTableColumn($11, $2, HEAP32[$1 + 48 >> 2]));
  }
  $10 = sqlite3ExprAnd($0, $10, $8);
 }
 HEAP32[$9 + 24 >> 2] = 0;
 HEAP32[$9 + 28 >> 2] = 0;
 HEAP32[$9 + 16 >> 2] = 0;
 HEAP32[$9 + 20 >> 2] = 0;
 HEAP32[$9 + 8 >> 2] = 0;
 HEAP32[$9 + 12 >> 2] = 0;
 HEAP32[$9 + 4 >> 2] = $1;
 HEAP32[$9 >> 2] = $0;
 sqlite3ResolveExprNames($9, $10);
 label$11: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$11;
  }
  $8 = sqlite3WhereBegin($0, $1, $10, 0, 0, 0, 0, 0);
  sqlite3VdbeAddOp2($13, 158, HEAPU8[$4 + 24 | 0], $7);
  if (!$8) {
   break label$11;
  }
  sqlite3WhereEnd($8);
 }
 sqlite3ExprDelete($11, $10);
 if ($14) {
  sqlite3VdbeJumpHereOrPopInst($13, $14);
 }
 __stack_pointer = $9 + 32 | 0;
}

function fts3IncrmergeRelease($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $3 = HEAP32[$2 >> 2];
 HEAP32[$7 + 12 >> 2] = $3;
 $4 = 15;
 label$1: {
  while (1) {
   if (($4 | 0) < 0) {
    break label$1;
   }
   $5 = ($4 << 5) + $1 | 0;
   if (HEAP32[$5 + 80 >> 2] <= 0) {
    sqlite3_free(HEAP32[$5 + 76 >> 2]);
    sqlite3_free(HEAP32[$5 - -64 >> 2]);
    $4 = $4 - 1 | 0;
    continue;
   }
   break;
  }
  label$4: {
   if ($4) {
    break label$4;
   }
   blobGrowBuffer($1 + 108 | 0, 11, $7 + 12 | 0);
   $4 = 1;
   $3 = HEAP32[$7 + 12 >> 2];
   if ($3) {
    break label$4;
   }
   HEAP8[HEAP32[$1 + 108 >> 2]] = 1;
   HEAP32[$1 + 112 >> 2] = sqlite3Fts3PutVarint(HEAP32[$1 + 108 >> 2] + 1 | 0, HEAP32[$1 + 56 >> 2], HEAP32[$1 + 60 >> 2]) + 1;
   $3 = 0;
  }
  $5 = 0;
  while (1) {
   if (($4 | 0) != ($5 | 0)) {
    $6 = ($5 << 5) + $1 | 0;
    $8 = HEAP32[$6 + 80 >> 2];
    if (!(($8 | 0) <= 0 | $3)) {
     $3 = fts3WriteSegment($0, HEAP32[$6 + 56 >> 2], HEAP32[$6 + 60 >> 2], HEAP32[$6 + 76 >> 2], $8);
    }
    sqlite3_free(HEAP32[$6 + 76 >> 2]);
    sqlite3_free(HEAP32[$6 - -64 >> 2]);
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  if (!$3) {
   if (!HEAPU8[$1 + 48 | 0]) {
    $10 = HEAP32[$1 + 44 >> 2];
    $11 = HEAP32[$1 + 40 >> 2];
   }
   $3 = HEAP32[$1 + 12 >> 2];
   $9 = HEAP32[$1 + 8 >> 2] + 1 | 0;
   $3 = $9 ? $3 : $3 + 1 | 0;
   $8 = $3;
   $3 = HEAP32[$1 + 24 >> 2];
   $12 = $3;
   $3 = HEAP32[$1 + 60 >> 2];
   $13 = $3;
   $3 = HEAP32[$1 + 32 >> 2];
   $14 = $3;
   $5 = HEAP32[$1 + 16 >> 2];
   $3 = HEAP32[$1 + 28 >> 2];
   $6 = ($4 << 5) + $1 | 0;
   $3 = fts3WriteSegdir($0, $9, $8, $5, $12, $3, HEAP32[$1 + 56 >> 2], $13, $14, HEAP32[$1 + 36 >> 2], $11, $10, HEAP32[$6 + 76 >> 2], HEAP32[$6 + 80 >> 2]);
  }
  $4 = ($4 << 5) + $1 | 0;
  sqlite3_free(HEAP32[$4 + 76 >> 2]);
  sqlite3_free(HEAP32[$4 - -64 >> 2]);
  HEAP32[$2 >> 2] = $3;
 }
 __stack_pointer = $7 + 16 | 0;
}

function sqlite3SrcListDup($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $3 = HEAP32[$1 >> 2];
  $6 = ($3 | 0) > 0 ? $3 << 6 | 8 : 72;
  $4 = $6 >> 31;
  $7 = sqlite3DbMallocRawNN($0, $6, $4);
  if (!$7) {
   break label$1;
  }
  $5 = HEAP32[$1 >> 2];
  HEAP32[$7 >> 2] = $5;
  HEAP32[$7 + 4 >> 2] = $5;
  while (1) {
   if (HEAP32[$1 >> 2] <= ($8 | 0)) {
    return $7;
   }
   $5 = $8 << 6;
   $3 = $7 + $5 | 0;
   $5 = $1 + $5 | 0;
   HEAP32[$3 + 8 >> 2] = HEAP32[$5 + 8 >> 2];
   HEAP32[$3 + 12 >> 2] = sqlite3DbStrDup($0, HEAP32[$5 + 12 >> 2]);
   HEAP32[$3 + 16 >> 2] = sqlite3DbStrDup($0, HEAP32[$5 + 16 >> 2]);
   HEAP32[$3 + 20 >> 2] = sqlite3DbStrDup($0, HEAP32[$5 + 20 >> 2]);
   HEAP32[$3 + 44 >> 2] = HEAP32[$5 + 44 >> 2];
   HEAP32[$3 + 48 >> 2] = HEAP32[$5 + 48 >> 2];
   HEAP32[$3 + 32 >> 2] = HEAP32[$5 + 32 >> 2];
   HEAP32[$3 + 36 >> 2] = HEAP32[$5 + 36 >> 2];
   $4 = $3 + 45 | 0;
   $4 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8;
   if ($4 & 2) {
    HEAP32[$3 - -64 >> 2] = sqlite3DbStrDup($0, HEAP32[$5 - -64 >> 2]);
    $4 = HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8;
   }
   $6 = HEAP32[$5 + 68 >> 2];
   HEAP32[$3 + 68 >> 2] = $6;
   if ($4 & 256) {
    HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + 1;
    $4 = HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8;
   }
   if ($4 & 4) {
    HEAP32[$3 - -64 >> 2] = sqlite3ExprListDup($0, HEAP32[$5 - -64 >> 2], $2);
   }
   $4 = HEAP32[$5 + 24 >> 2];
   HEAP32[$3 + 24 >> 2] = $4;
   if ($4) {
    HEAP32[$4 + 24 >> 2] = HEAP32[$4 + 24 >> 2] + 1;
   }
   HEAP32[$3 + 28 >> 2] = sqlite3SelectDup($0, HEAP32[$5 + 28 >> 2], $2);
   $4 = HEAP32[$5 + 52 >> 2];
   label$9: {
    if (HEAPU8[$5 + 46 | 0] & 4) {
     $4 = sqlite3IdListDup($0, $4);
     break label$9;
    }
    $4 = sqlite3ExprDup($0, $4, $2);
   }
   HEAP32[$3 + 52 >> 2] = $4;
   $6 = HEAP32[$5 + 60 >> 2];
   $4 = HEAP32[$5 + 56 >> 2];
   HEAP32[$3 + 56 >> 2] = $4;
   HEAP32[$3 + 60 >> 2] = $6;
   $8 = $8 + 1 | 0;
   continue;
  }
 }
 return 0;
}

function atan($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$0);
 $4 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $1 = $4 & 2147483647;
 if ($1 >>> 0 >= 1141899264) {
  wasm2js_scratch_store_f64(1.5707963267948966);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $7 = $4;
  $2 = $1 & 2147483647;
  $8 = $2;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $4 = $2 & -2147483648;
  $1 = $4;
  $2 = $7;
  wasm2js_scratch_store_i32(0, $9 | $2);
  $4 = $8;
  $1 = $4 | $1;
  wasm2js_scratch_store_i32(1, $1 | 0);
  $5 = +wasm2js_scratch_load_f64();
  $1 = __DOUBLE_BITS($0);
  $4 = $1;
  $2 = i64toi32_i32$HIGH_BITS;
  $1 = $2 & 2147483647;
  $2 = $4;
  return ($1 | 0) == 2146435072 & ($2 | 0) != 0 | $1 >>> 0 > 2146435072 ? $0 : $5;
 }
 label$2: {
  label$3: {
   if ($1 >>> 0 <= 1071382527) {
    $2 = -1;
    if ($1 >>> 0 >= 1044381696) {
     break label$3;
    }
    break label$2;
   }
   $0 = fabs($0);
   if ($1 >>> 0 <= 1072889855) {
    if ($1 >>> 0 <= 1072037887) {
     $0 = ($0 + $0 + -1) / ($0 + 2);
     $2 = 0;
     break label$3;
    }
    $0 = ($0 + -1) / ($0 + 1);
    $2 = 1;
    break label$3;
   }
   if ($1 >>> 0 <= 1073971199) {
    $0 = ($0 + -1.5) / ($0 * 1.5 + 1);
    $2 = 2;
    break label$3;
   }
   $0 = -1 / $0;
   $2 = 3;
  }
  $6 = $0 * $0;
  $3 = $6 * $6;
  $5 = $3 * ($3 * ($3 * ($3 * ($3 * -.036531572744216916 + -.058335701337905735) + -.0769187620504483) + -.11111110405462356) + -.19999999999876483);
  $3 = $6 * ($3 * ($3 * ($3 * ($3 * ($3 * .016285820115365782 + .049768779946159324) + .06661073137387531) + .09090887133436507) + .14285714272503466) + .3333333333333293);
  if ($1 >>> 0 <= 1071382527) {
   return $0 - $0 * ($5 + $3);
  }
  $1 = $2 << 3;
  $0 = HEAPF64[$1 + 58624 >> 3] - ($0 * ($5 + $3) - HEAPF64[$1 + 58656 >> 3] - $0);
  $2 = $4;
  $0 = ($2 | 0) < 0 ? -$0 : $0;
 }
 return $0;
}

function sqlite3GenerateColumnNames($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 if (!(HEAPU8[$0 + 207 | 0] | HEAPU8[$0 + 16 | 0])) {
  $5 = HEAP32[$0 >> 2];
  $6 = HEAP32[$0 + 8 >> 2];
  while (1) {
   $2 = $1;
   $1 = HEAP32[$2 + 52 >> 2];
   if ($1) {
    continue;
   }
   break;
  }
  $10 = HEAP32[$2 + 32 >> 2];
  $7 = HEAP32[$2 + 28 >> 2];
  HEAP8[$0 + 16 | 0] = 1;
  $8 = HEAP32[$5 + 32 >> 2];
  sqlite3VdbeSetNumCols($6, HEAP32[$7 >> 2]);
  $11 = $8 & 68;
  $8 = $8 & 4;
  $12 = 0;
  $1 = 0;
  while (1) {
   if (($1 | 0) < HEAP32[$7 >> 2]) {
    $2 = ($1 << 4) + $7 | 0;
    $9 = HEAP32[$2 + 8 >> 2];
    $3 = HEAP32[$2 + 12 >> 2];
    label$5: {
     if (!(!$3 | HEAPU8[$2 + 17 | 0] & 3)) {
      sqlite3VdbeSetColName($6, $1, 0, $3, -1);
      break label$5;
     }
     if (!(!($11 | $13) | HEAPU8[$9 | 0] != 167)) {
      $2 = HEAP32[$9 + 44 >> 2];
      label$8: {
       label$9: {
        $3 = HEAP16[$9 + 32 >> 1];
        if (($3 | 0) >= 0) {
         break label$9;
        }
        $3 = HEAP16[$2 + 32 >> 1];
        if (($3 | 0) >= 0) {
         break label$9;
        }
        $3 = 14442;
        break label$8;
       }
       $3 = HEAP32[HEAP32[$2 + 4 >> 2] + Math_imul($3 & 65535, 12) >> 2];
      }
      if ($8 | $12) {
       $2 = HEAP32[$2 >> 2];
       HEAP32[$4 + 20 >> 2] = $3;
       HEAP32[$4 + 16 >> 2] = $2;
       sqlite3VdbeSetColName($6, $1, 0, sqlite3MPrintf($5, 6016, $4 + 16 | 0), 1);
       break label$5;
      }
      sqlite3VdbeSetColName($6, $1, 0, $3, -1);
      break label$5;
     }
     label$11: {
      if (!$3) {
       HEAP32[$4 >> 2] = $1 + 1;
       $2 = sqlite3MPrintf($5, 15907, $4);
       break label$11;
      }
      $2 = sqlite3DbStrDup($5, $3);
     }
     sqlite3VdbeSetColName($6, $1, 0, $2, 1);
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  generateColumnTypes($0, $10, $7);
 }
 __stack_pointer = $4 + 32 | 0;
}

function fts3SegReaderNextDocid($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $4 = HEAP32[$1 + 80 >> 2];
 HEAP32[$5 + 12 >> 2] = $4;
 label$1: {
  if (!(!HEAPU8[$0 + 239 | 0] | !HEAP32[$1 + 56 >> 2])) {
   HEAP8[$5 + 11 | 0] = 0;
   if ($2) {
    HEAP32[$2 >> 2] = $4;
    HEAP32[$3 >> 2] = HEAP32[$1 + 84 >> 2] - 1;
   }
   sqlite3Fts3DoclistPrev(0, HEAP32[$1 + 72 >> 2], HEAP32[$1 + 76 >> 2], $5 + 12 | 0, $1 + 88 | 0, $1 + 84 | 0, $5 + 11 | 0);
   HEAP32[$1 + 80 >> 2] = HEAPU8[$5 + 11 | 0] ? 0 : HEAP32[$5 + 12 >> 2];
   break label$1;
  }
  $7 = HEAP32[$1 + 72 >> 2] + HEAP32[$1 + 76 >> 2] | 0;
  while (1) {
   $6 = HEAPU8[$4 | 0];
   if ($8 | $6) {
    $8 = $6 & 128;
    $4 = $4 + 1 | 0;
    continue;
   }
   if (!(!HEAP32[$1 + 52 >> 2] | HEAP32[$1 + 40 >> 2] + HEAP32[$1 + 48 >> 2] >>> 0 > $4 >>> 0)) {
    $6 = fts3SegReaderIncrRead($1);
    if (!$6) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $4 = $4 + 1 | 0;
  HEAP32[$5 + 12 >> 2] = $4;
  if ($2) {
   HEAP32[$2 >> 2] = HEAP32[$1 + 80 >> 2];
   HEAP32[$3 >> 2] = (HEAP32[$1 + 80 >> 2] ^ -1) + $4;
  }
  label$8: {
   while (1) {
    if ($4 >>> 0 < $7 >>> 0) {
     if (HEAPU8[$4 | 0]) {
      break label$8;
     }
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   $6 = 0;
   HEAP32[$1 + 80 >> 2] = 0;
   break label$1;
  }
  $6 = fts3SegReaderRequire($1, $4, 10);
  if ($6) {
   break label$1;
  }
  HEAP32[$1 + 80 >> 2] = sqlite3Fts3GetVarintU($4, $5) + $4;
  $2 = HEAP32[$1 + 92 >> 2];
  $6 = $2;
  $2 = HEAP32[$5 >> 2];
  $3 = $2;
  $7 = 0 - $2 | 0;
  $4 = HEAP32[$5 + 4 >> 2];
  $2 = $4;
  $8 = 0 - ($2 + (($3 | 0) != 0) | 0) | 0;
  $2 = HEAPU8[$0 + 239 | 0];
  $3 = $2 ? $7 : $3;
  $0 = $3;
  $3 = $2 ? $8 : $4;
  $7 = $3 + $6 | 0;
  $2 = HEAP32[$1 + 88 >> 2];
  $4 = $0 + $2 | 0;
  $7 = $0 >>> 0 > $4 >>> 0 ? $7 + 1 | 0 : $7;
  HEAP32[$1 + 88 >> 2] = $4;
  HEAP32[$1 + 92 >> 2] = $7;
  $6 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $6;
}

function posixUnlock($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $7 = HEAPU8[$0 + 16 | 0];
 label$1: {
  if (($7 | 0) <= ($1 | 0)) {
   break label$1;
  }
  $5 = HEAP32[$0 + 8 >> 2];
  label$2: {
   if ($7 >>> 0 >= 2) {
    label$4: {
     if (($1 | 0) != 1) {
      break label$4;
     }
     HEAP32[$2 + 16 >> 2] = 510;
     HEAP32[$2 + 20 >> 2] = 0;
     HEAP32[$2 >> 2] = 0;
     $4 = HEAP32[16232] + 2 | 0;
     $3 = $4 >> 31;
     HEAP32[$2 + 8 >> 2] = $4;
     HEAP32[$2 + 12 >> 2] = $3;
     if (!unixFileLock($0, $2)) {
      break label$4;
     }
     storeLastErrno($0, HEAP32[__errno_location() >> 2]);
     $6 = 2314;
     break label$1;
    }
    HEAP32[$2 >> 2] = 2;
    HEAP32[$2 + 16 >> 2] = 2;
    HEAP32[$2 + 20 >> 2] = 0;
    $3 = HEAP32[16232];
    $4 = $3 >> 31;
    HEAP32[$2 + 8 >> 2] = $3;
    HEAP32[$2 + 12 >> 2] = $4;
    if (unixFileLock($0, $2)) {
     break label$2;
    }
    HEAP8[$5 + 28 | 0] = 1;
   }
   $7 = $0 + 16 | 0;
   if (!$1) {
    $6 = HEAP32[$5 + 20 >> 2] - 1 | 0;
    HEAP32[$5 + 20 >> 2] = $6;
    label$6: {
     if ($6) {
      $4 = 1;
      $3 = 0;
      break label$6;
     }
     HEAP32[$2 + 16 >> 2] = 0;
     HEAP32[$2 + 20 >> 2] = 0;
     HEAP32[$2 + 8 >> 2] = 0;
     HEAP32[$2 + 12 >> 2] = 0;
     HEAP32[$2 >> 2] = 2;
     $4 = unixFileLock($0, $2);
     label$8: {
      if (!$4) {
       $3 = $5 + 28 | 0;
       break label$8;
      }
      storeLastErrno($0, HEAP32[__errno_location() >> 2]);
      HEAP8[$5 + 28 | 0] = 0;
      $8 = 2058;
      $3 = $7;
     }
     HEAP8[$3 | 0] = 0;
     $4 = !$4;
     $3 = $8;
    }
    $6 = $3;
    $3 = HEAP32[$5 + 24 >> 2] - 1 | 0;
    HEAP32[$5 + 24 >> 2] = $3;
    if (!$3) {
     closePendingFds($0);
    }
    if (!$4) {
     break label$1;
    }
   }
   HEAP8[$7 | 0] = $1;
   $6 = 0;
   break label$1;
  }
  storeLastErrno($0, HEAP32[__errno_location() >> 2]);
  $6 = 2058;
 }
 __stack_pointer = $2 + 32 | 0;
 return $6;
}

function log10($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if (($1 | 0) > 0 | ($1 | 0) >= 0) {
      if ($1 >>> 0 > 1048575) {
       break label$4;
      }
     }
     $3 = $1 & 2147483647;
     if (!($3 | $4)) {
      return -1 / ($0 * $0);
     }
     if (($1 | 0) > 0 | ($1 | 0) >= 0) {
      break label$3;
     }
     return ($0 - $0) / 0;
    }
    if ($1 >>> 0 > 2146435071) {
     break label$1;
    }
    $3 = 1072693248;
    $8 = -1023;
    if (($1 | 0) != 1072693248) {
     $3 = $1;
     break label$2;
    }
    if ($4) {
     break label$2;
    }
    return 0;
   }
   wasm2js_scratch_store_f64(+($0 * 0x40000000000000));
   $1 = wasm2js_scratch_load_i32(1) | 0;
   $4 = wasm2js_scratch_load_i32(0) | 0;
   $3 = $1;
   $8 = -1077;
  }
  $1 = $3 + 614242 | 0;
  $9 = +(($1 >>> 20 | 0) + $8 | 0);
  $2 = $9 * .30102999566361177;
  $3 = ($1 & 1048575) + 1072079006 | 0;
  wasm2js_scratch_store_i32(0, $4 | 0);
  $1 = 0;
  $3 = $1 | $3;
  wasm2js_scratch_store_i32(1, $3 | 0);
  $0 = +wasm2js_scratch_load_f64() + -1;
  $6 = $0 * ($0 * .5);
  wasm2js_scratch_store_f64(+($0 - $6));
  $3 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $3 | 0);
  $7 = +wasm2js_scratch_load_f64();
  $5 = $7 * .4342944818781689;
  $10 = $2 + $5;
  $11 = $5 + ($2 - $10);
  $2 = $0 / ($0 + 2);
  $12 = $2;
  $5 = $2 * $2;
  $2 = $5 * $5;
  $0 = $12 * ($6 + ($2 * ($2 * ($2 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $5 * ($2 * ($2 * ($2 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) + ($0 - $7 - $6);
  $0 = $10 + ($11 + ($0 * .4342944818781689 + ($9 * 3694239077158931e-28 + ($0 + $7) * 25082946711645275e-27)));
 }
 return $0;
}

function sqlite3SelectDup($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = 0;
 $6 = $5 + 12 | 0;
 while (1) {
  label$2: {
   label$3: {
    if (!$1) {
     break label$3;
    }
    $3 = sqlite3DbMallocRawNN($0, 76, 0);
    if (!$3) {
     break label$3;
    }
    HEAP32[$3 + 28 >> 2] = sqlite3ExprListDup($0, HEAP32[$1 + 28 >> 2], $2);
    HEAP32[$3 + 32 >> 2] = sqlite3SrcListDup($0, HEAP32[$1 + 32 >> 2], $2);
    HEAP32[$3 + 36 >> 2] = sqlite3ExprDup($0, HEAP32[$1 + 36 >> 2], $2);
    HEAP32[$3 + 40 >> 2] = sqlite3ExprListDup($0, HEAP32[$1 + 40 >> 2], $2);
    HEAP32[$3 + 44 >> 2] = sqlite3ExprDup($0, HEAP32[$1 + 44 >> 2], $2);
    HEAP32[$3 + 48 >> 2] = sqlite3ExprListDup($0, HEAP32[$1 + 48 >> 2], $2);
    $7 = HEAPU8[$1 | 0];
    HEAP32[$3 + 56 >> 2] = $4;
    HEAP8[$3 | 0] = $7;
    HEAP32[$3 + 52 >> 2] = 0;
    $4 = sqlite3ExprDup($0, HEAP32[$1 + 60 >> 2], $2);
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = 0;
    HEAP32[$3 + 60 >> 2] = $4;
    $4 = HEAP32[$1 + 4 >> 2];
    HEAP32[$3 + 20 >> 2] = -1;
    HEAP32[$3 + 24 >> 2] = -1;
    HEAP32[$3 + 4 >> 2] = $4 & -33;
    HEAP16[$3 + 2 >> 1] = HEAPU16[$1 + 2 >> 1];
    $4 = sqlite3WithDup($0, HEAP32[$1 + 64 >> 2]);
    HEAP32[$3 + 68 >> 2] = 0;
    HEAP32[$3 + 64 >> 2] = $4;
    HEAP32[$3 + 72 >> 2] = sqlite3WindowListDup($0, HEAP32[$1 + 72 >> 2]);
    label$4: {
     if (HEAP32[$1 + 68 >> 2]) {
      if (HEAPU8[$0 + 87 | 0]) {
       HEAP32[$3 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
       break label$4;
      }
      gatherSelectWindows($3);
     }
     $4 = HEAPU8[$0 + 87 | 0];
     HEAP32[$3 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
     if (!$4) {
      break label$2;
     }
    }
    HEAP32[$3 + 56 >> 2] = 0;
    sqlite3SelectDelete($0, $3);
   }
   __stack_pointer = $5 + 16 | 0;
   $3 = HEAP32[$5 + 12 >> 2];
   return $3;
  }
  HEAP32[$6 >> 2] = $3;
  $1 = HEAP32[$1 + 52 >> 2];
  $6 = $3 + 52 | 0;
  $4 = $3;
  continue;
 }
}

function sqlite3PagerSetPagesize($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $6 = HEAP32[$1 >> 2];
 label$1: {
  label$2: {
   label$3: {
    if (HEAP32[$0 + 28 >> 2] ? HEAPU8[$0 + 15 | 0] : 0) {
     break label$3;
    }
    if (sqlite3PcacheRefCount(HEAP32[$0 + 228 >> 2]) | !$6 | HEAP32[$0 + 168 >> 2] == ($6 | 0)) {
     break label$3;
    }
    $3 = $8;
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = 0;
    label$5: {
     if (!HEAPU8[$0 + 17 | 0]) {
      break label$5;
     }
     $4 = HEAP32[$0 + 64 >> 2];
     if (!HEAP32[$4 >> 2]) {
      break label$5;
     }
     $4 = sqlite3OsFileSize($4, $8 + 8 | 0);
     if ($4) {
      break label$2;
     }
    }
    $5 = sqlite3PageMalloc($6 + 8 | 0);
    if (!$5) {
     $5 = 0;
     $4 = 7;
     break label$2;
    }
    $3 = $6 + $5 | 0;
    HEAP8[$3 | 0] = 0;
    HEAP8[$3 + 1 | 0] = 0;
    HEAP8[$3 + 2 | 0] = 0;
    HEAP8[$3 + 3 | 0] = 0;
    HEAP8[$3 + 4 | 0] = 0;
    HEAP8[$3 + 5 | 0] = 0;
    HEAP8[$3 + 6 | 0] = 0;
    HEAP8[$3 + 7 | 0] = 0;
    pager_reset($0);
    $4 = sqlite3PcacheSetPageSize(HEAP32[$0 + 228 >> 2], $6);
    if ($4) {
     break label$2;
    }
    sqlite3PageFree(HEAP32[$0 + 224 >> 2]);
    HEAP32[$0 + 224 >> 2] = $5;
    $4 = HEAP32[$8 + 8 >> 2];
    $3 = HEAP32[$8 + 12 >> 2];
    HEAP32[$0 + 168 >> 2] = $6;
    HEAP32[$0 + 172 >> 2] = 0;
    $5 = $3;
    $7 = $6 + $4 | 0;
    $5 = $4 >>> 0 > $7 >>> 0 ? $5 + 1 | 0 : $5;
    $3 = $7;
    $7 = !$3;
    $7 = $5 - $7 | 0;
    $3 = __wasm_i64_sdiv($3 - 1 | 0, $7, $6, 0);
    HEAP32[$0 + 28 >> 2] = $3;
    HEAP32[$0 + 164 >> 2] = (HEAPU32[16232] / ($6 >>> 0) | 0) + 1;
   }
   $7 = HEAP32[$0 + 168 >> 2];
   HEAP32[$1 >> 2] = $7;
   $2 = ($2 | 0) < 0 ? HEAPU16[$0 + 150 >> 1] : $2;
   HEAP16[$0 + 150 >> 1] = $2;
   $4 = 0;
   break label$1;
  }
  sqlite3PageFree($5);
  $3 = HEAP32[$0 + 168 >> 2];
  HEAP32[$1 >> 2] = $3;
 }
 __stack_pointer = $8 + 16 | 0;
 return $4;
}

function fts3ChecksumEntry($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $8 = $2;
 $9 = $8 >> 31;
 $12 = $4;
 $10 = $12 + $8 | 0;
 $8 = $5;
 $11 = $8 + $9 | 0;
 $2 = $10;
 $11 = $12 >>> 0 > $10 >>> 0 ? $11 + 1 | 0 : $11;
 $9 = $12;
 $12 = $9 << 3;
 $9 = $8 << 3 | $9 >>> 29;
 $10 = $11 + $9 | 0;
 $11 = $2;
 $8 = $12 + $11 | 0;
 $10 = $8 >>> 0 < $12 >>> 0 ? $10 + 1 | 0 : $10;
 $4 = $8;
 $5 = $10;
 $11 = $3;
 $10 = $11 >> 31;
 $11 = $10;
 $10 = $5;
 $8 = $10 + $11 | 0;
 $12 = $3;
 $9 = $12 + $4 | 0;
 $8 = $9 >>> 0 < $12 >>> 0 ? $8 + 1 | 0 : $8;
 $2 = $9;
 $10 = $4;
 $12 = $10 << 3;
 $3 = $8;
 $8 = $5;
 $10 = $8 << 3 | $10 >>> 29;
 $9 = $3 + $10 | 0;
 $8 = $2;
 $11 = $8 + $12 | 0;
 $4 = $11;
 $9 = $11 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
 $5 = $9;
 $8 = $6;
 $9 = $8 >> 31;
 $8 = $9;
 $9 = $5;
 $11 = $9 + $8 | 0;
 $12 = $6;
 $10 = $12 + $4 | 0;
 $2 = $10;
 $11 = $10 >>> 0 < $12 >>> 0 ? $11 + 1 | 0 : $11;
 $9 = $4;
 $12 = $9 << 3;
 $3 = $11;
 $11 = $5;
 $9 = $11 << 3 | $9 >>> 29;
 $10 = $3 + $9 | 0;
 $11 = $2;
 $8 = $12 + $11 | 0;
 $10 = $8 >>> 0 < $12 >>> 0 ? $10 + 1 | 0 : $10;
 $4 = $8;
 $5 = $10;
 $11 = $7;
 $10 = $11 >> 31;
 $11 = $10;
 $10 = $5;
 $8 = $10 + $11 | 0;
 $12 = $7;
 $9 = $12 + $4 | 0;
 $8 = $9 >>> 0 < $12 >>> 0 ? $8 + 1 | 0 : $8;
 $2 = $9;
 $10 = $4;
 $12 = $10 << 3;
 $3 = $8;
 $8 = $5;
 $10 = $8 << 3 | $10 >>> 29;
 $9 = $3 + $10 | 0;
 $8 = $2;
 $11 = $8 + $12 | 0;
 $4 = $11;
 $9 = $11 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
 $5 = $9;
 $2 = 0;
 $1 = ($1 | 0) > 0 ? $1 : 0;
 while (1) {
  if (($1 | 0) != ($2 | 0)) {
   $9 = HEAP8[$0 + $2 | 0];
   $8 = $9 >> 31;
   $6 = $9;
   $3 = $8;
   $8 = $5;
   $9 = __wasm_i64_mul($4, $8, 9, 0);
   $12 = $9;
   $10 = $9 + $6 | 0;
   $8 = i64toi32_i32$HIGH_BITS;
   $9 = $8;
   $8 = $3;
   $11 = $9 + $8 | 0;
   $4 = $10;
   $11 = $10 >>> 0 < $12 >>> 0 ? $11 + 1 | 0 : $11;
   $5 = $11;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 $11 = $5;
 i64toi32_i32$HIGH_BITS = $11;
 return $4;
}

function pagerWriteLargeSector($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP8[$3 + 21 | 0] = HEAPU8[$3 + 21 | 0] | 4;
 $5 = __wasm_i64_sdiv(HEAP32[$3 + 156 >> 2], 0, HEAP32[$3 + 168 >> 2], HEAP32[$3 + 172 >> 2]);
 $2 = HEAP32[$0 + 24 >> 2];
 $4 = $5 - 1 | 0 - $2;
 $1 = $2 - 1 & 0 - $5;
 $7 = HEAP32[$3 + 28 >> 2];
 label$1: {
  if ($7 >>> 0 < $2 >>> 0) {
   $5 = ($2 + $4 | 0) + 1 | 0;
   break label$1;
  }
  if ($1 + $5 >>> 0 <= $7 >>> 0) {
   break label$1;
  }
  $5 = ($4 + $7 | 0) + 1 | 0;
 }
 $7 = $1 + 1 | 0;
 $2 = 0;
 $4 = 0;
 while (1) {
  if (!(($2 | 0) >= ($5 | 0) | $4)) {
   label$5: {
    label$6: {
     $1 = $2 + $7 | 0;
     if (($1 | 0) != HEAP32[$0 + 24 >> 2]) {
      if (sqlite3BitvecTest(HEAP32[$3 + 60 >> 2], $1)) {
       break label$6;
      }
     }
     $4 = 0;
     if (HEAP32[$3 + 164 >> 2] == ($1 | 0)) {
      break label$5;
     }
     $4 = sqlite3PagerGet($3, $1, $6 + 12 | 0, 0);
     if ($4) {
      break label$5;
     }
     $4 = pager_write(HEAP32[$6 + 12 >> 2]);
     $1 = HEAP32[$6 + 12 >> 2];
     $9 = HEAPU16[$1 + 28 >> 1];
     sqlite3PagerUnrefNotNull($1);
     $8 = $9 & 8 ? 1 : $8;
     break label$5;
    }
    $1 = sqlite3PagerLookup($3, $1);
    HEAP32[$6 + 12 >> 2] = $1;
    $4 = 0;
    if (!$1) {
     break label$5;
    }
    $9 = HEAPU16[$1 + 28 >> 1];
    sqlite3PagerUnrefNotNull($1);
    $8 = $9 & 8 ? 1 : $8;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 label$8: {
  if (!$8 | $4) {
   break label$8;
  }
  $2 = 0;
  $5 = ($5 | 0) > 0 ? $5 : 0;
  while (1) {
   if (($2 | 0) == ($5 | 0)) {
    break label$8;
   }
   $1 = sqlite3PagerLookup($3, $2 + $7 | 0);
   if ($1) {
    HEAP16[$1 + 28 >> 1] = HEAPU16[$1 + 28 >> 1] | 8;
    sqlite3PagerUnrefNotNull($1);
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 HEAP8[$3 + 21 | 0] = HEAPU8[$3 + 21 | 0] & 251;
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function exprNodeIsConstant($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  $4 = HEAPU16[$0 + 20 >> 1];
  label$2: {
   label$3: {
    if (!(!(HEAP8[$1 + 4 | 0] & 1) | ($4 | 0) != 2)) {
     break label$3;
    }
    label$5: {
     label$6: {
      label$7: {
       label$8: {
        label$9: {
         $3 = HEAPU8[$1 | 0];
         switch ($3 - 167 | 0) {
         case 3:
         case 4:
         case 6:
         case 7:
         case 8:
         case 10:
         case 11:
          break label$2;

         case 9:
         case 12:
          break label$3;

         case 0:
         case 1:
         case 2:
          break label$6;

         case 5:
          break label$8;

         default:
          break label$9;
         }
        }
        if (($3 | 0) == 59) {
         break label$7;
        }
        if (($3 | 0) == 141) {
         break label$3;
        }
        if (($3 | 0) == 156) {
         break label$5;
        }
        break label$1;
       }
       $2 = HEAP32[$1 + 4 >> 2];
       if (!(($2 & 1048576 ? 0 : $4 >>> 0 <= 3) | $2 & 16777216)) {
        if (($4 | 0) != 5) {
         break label$1;
        }
        HEAP32[$1 + 4 >> 2] = $2 | 1073741824;
        break label$1;
       }
       break label$3;
      }
      $2 = 1;
      if (sqlite3ExprIdToTrueFalse($1)) {
       break label$2;
      }
     }
     $3 = HEAPU16[$0 + 20 >> 1];
     if (HEAPU8[$1 + 4 | 0] & 32) {
      $2 = 0;
      if (($3 | 0) == 2) {
       break label$3;
      }
      break label$2;
     }
     if (($3 | 0) != 3) {
      break label$3;
     }
     $2 = 0;
     if (HEAP32[$1 + 28 >> 2] == HEAP32[$0 + 24 >> 2]) {
      break label$2;
     }
     break label$3;
    }
    label$12: {
     switch ($4 - 4 | 0) {
     case 1:
      HEAP8[$1 | 0] = 121;
      break label$1;

     case 0:
      break label$12;

     default:
      break label$2;
     }
    }
   }
   HEAP16[$0 + 20 >> 1] = 0;
   $2 = 2;
  }
  return $2 | 0;
 }
 return 0;
}

function jsonRenderNode($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAPU8[$0 + 1 | 0];
 if ($3 & 24) {
  if (!(!$2 | !($3 & 8))) {
   jsonAppendValue($1, HEAP32[(HEAP32[$0 + 8 >> 2] << 2) + $2 >> 2]);
   return;
  }
  $0 = HEAP32[$0 + 8 >> 2];
 }
 label$3: {
  label$4: {
   label$5: {
    label$6: {
     switch (HEAPU8[$0 | 0] - 1 | 0) {
     default:
      jsonAppendRaw($1, 11103, 4);
      return;

     case 0:
      jsonAppendRaw($1, 12326, 4);
      return;

     case 1:
      jsonAppendRaw($1, 12859, 5);
      return;

     case 6:
      break label$3;

     case 5:
      break label$4;

     case 2:
     case 3:
      break label$5;

     case 4:
      break label$6;
     }
    }
    if (!(HEAP8[$0 + 1 | 0] & 1)) {
     break label$5;
    }
    jsonAppendString($1, HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
    return;
   }
   jsonAppendRaw($1, HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
   return;
  }
  jsonAppendChar($1, 91);
  while (1) {
   $3 = 1;
   while (1) {
    if (HEAPU32[$0 + 4 >> 2] >= $3 >>> 0) {
     $4 = Math_imul($3, 12) + $0 | 0;
     if (!(HEAPU8[$4 + 1 | 0] & 4)) {
      jsonAppendSeparator($1);
      jsonRenderNode($4, $1, $2);
     }
     $3 = jsonNodeSize($4) + $3 | 0;
     continue;
    }
    break;
   }
   if (HEAPU8[$0 + 1 | 0] & 32) {
    $0 = Math_imul(HEAP32[$0 + 8 >> 2], 12) + $0 | 0;
    continue;
   }
   break;
  }
  jsonAppendChar($1, 93);
  return;
 }
 jsonAppendChar($1, 123);
 while (1) {
  $3 = 1;
  while (1) {
   if (HEAPU32[$0 + 4 >> 2] >= $3 >>> 0) {
    $5 = $3 + 1 | 0;
    $4 = Math_imul($5, 12) + $0 | 0;
    if (!(HEAPU8[$4 + 1 | 0] & 4)) {
     jsonAppendSeparator($1);
     jsonRenderNode(Math_imul($3, 12) + $0 | 0, $1, $2);
     jsonAppendChar($1, 58);
     jsonRenderNode($4, $1, $2);
    }
    $3 = jsonNodeSize($4) + $5 | 0;
    continue;
   }
   break;
  }
  if (HEAPU8[$0 + 1 | 0] & 32) {
   $0 = Math_imul(HEAP32[$0 + 8 >> 2], 12) + $0 | 0;
   continue;
  }
  break;
 }
 jsonAppendChar($1, 125);
}

function sqlite3MulInt64($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = HEAP32[$0 >> 2];
 $7 = $5;
 $3 = HEAP32[$0 + 4 >> 2];
 $6 = $3;
 $3 = $2;
 label$1: {
  label$2: {
   if (!!$1 & ($3 | 0) >= 0 | ($3 | 0) > 0) {
    $9 = 1;
    $3 = __wasm_i64_udiv(-1, 2147483647, $1, $2);
    $5 = $3;
    $4 = $7;
    $3 = i64toi32_i32$HIGH_BITS;
    if ($5 >>> 0 < $4 >>> 0 & ($6 | 0) >= ($3 | 0) | ($3 | 0) < ($6 | 0)) {
     break label$1;
    }
    $3 = __wasm_i64_udiv(0, -2147483648, $1, $2);
    $8 = 0 - $3 | 0;
    $4 = i64toi32_i32$HIGH_BITS;
    $5 = 0 - ($4 + (($3 | 0) != 0) | 0) | 0;
    $3 = $8;
    $4 = $7;
    if (($6 | 0) >= ($5 | 0) & $3 >>> 0 <= $4 >>> 0 | ($6 | 0) > ($5 | 0)) {
     break label$2;
    }
    break label$1;
   }
   $4 = $2;
   if (($4 | 0) > 0 | ($4 | 0) >= 0) {
    break label$2;
   }
   $3 = $6;
   if (!!$7 & ($3 | 0) >= 0 | ($3 | 0) > 0) {
    $9 = 1;
    $3 = __wasm_i64_udiv(0, -2147483648, $7, $6);
    $4 = $3;
    $5 = i64toi32_i32$HIGH_BITS;
    $3 = $5;
    $8 = $3 + (($4 | 0) != 0) | 0;
    $8 = 0 - $8 | 0;
    $5 = 0 - $4 | 0;
    $4 = $1;
    if (($2 | 0) == ($8 | 0) & $5 >>> 0 <= $4 >>> 0 | $2 >>> 0 > $8 >>> 0) {
     break label$2;
    }
    break label$1;
   }
   if (($6 | 0) > 0 | ($6 | 0) >= 0) {
    break label$2;
   }
   $9 = 1;
   $4 = $2;
   $3 = !$1 & ($4 | 0) == -2147483648;
   if ($3 | !$7 & ($6 | 0) == -2147483648) {
    break label$1;
   }
   $4 = $7;
   $3 = 0 - $4 | 0;
   $5 = $3;
   $4 = $1;
   $3 = $2 + (($4 | 0) != 0) | 0;
   $3 = 0 - $3 | 0;
   $8 = __wasm_i64_udiv(-1, 2147483647, 0 - $4 | 0, $3);
   $4 = $8;
   $3 = i64toi32_i32$HIGH_BITS;
   $8 = $3;
   $3 = 0 - ((($7 | 0) != 0) + $6 | 0) | 0;
   if (($3 | 0) == ($8 | 0) & $4 >>> 0 < $5 >>> 0 | $3 >>> 0 > $8 >>> 0) {
    break label$1;
   }
  }
  $3 = $6;
  $3 = __wasm_i64_mul($1, $2, $7, $3);
  $1 = $3;
  $3 = $0;
  HEAP32[$3 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
  $9 = 0;
 }
 return $9;
}

function sqlite3Fts3SegReaderPending($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $0 = HEAP32[$0 + 260 >> 2];
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if ($4) {
      $0 = (Math_imul($1, 24) + $0 | 0) + 12 | 0;
      $1 = 0;
      while (1) {
       $0 = HEAP32[$0 >> 2];
       HEAP32[$7 + 12 >> 2] = $0;
       label$7: {
        if ($0) {
         if ($3) {
          if (HEAP32[$0 + 16 >> 2] < ($3 | 0)) {
           continue;
          }
          if (memcmp(HEAP32[$0 + 12 >> 2], $2, $3)) {
           continue;
          }
         }
         if (($1 | 0) != ($9 | 0)) {
          $6 = $8;
          break label$7;
         }
         $9 = $9 + 16 | 0;
         $6 = sqlite3_realloc($8, $9 << 2);
         if ($6) {
          break label$7;
         }
         break label$3;
        }
        if ($1 >>> 0 >= 2) {
         qsort($8, $1, 4, 101);
         $2 = $1;
         break label$4;
        }
        $2 = 1;
        $0 = 0;
        $3 = 0;
        if (($1 | 0) != 1) {
         break label$2;
        }
        break label$4;
       }
       HEAP32[($1 << 2) + $6 >> 2] = $0;
       $1 = $1 + 1 | 0;
       $0 = HEAP32[$7 + 12 >> 2];
       $8 = $6;
       continue;
      }
     }
     $0 = sqlite3Fts3HashFindElem((Math_imul($1, 24) + $0 | 0) + 4 | 0, $2, $3);
     HEAP32[$7 + 12 >> 2] = $0;
     if ($0) {
      $2 = 1;
      $8 = $7 + 12 | 0;
      break label$4;
     }
     $0 = 0;
     $3 = 0;
     break label$1;
    }
    $1 = $2 << 2;
    $2 = $1 + 100 | 0;
    $0 = sqlite3_malloc64($2, 0);
    if (!$0) {
     break label$3;
    }
    $2 = memset($0, 0, $2);
    $6 = $2 + 96 | 0;
    HEAP32[$2 + 56 >> 2] = $6;
    HEAP32[$2 >> 2] = 2147483647;
    __memcpy($6, $8, $1);
    $3 = 0;
    break label$2;
   }
   $0 = 0;
   $3 = 7;
  }
  if (!$4) {
   break label$1;
  }
  sqlite3_free($8);
 }
 HEAP32[$5 >> 2] = $0;
 __stack_pointer = $7 + 16 | 0;
 return $3;
}

function backupOnePage($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $6 = HEAP32[$0 + 4 >> 2];
 $16 = sqlite3BtreePager($6);
 $4 = sqlite3BtreeGetPageSize(HEAP32[$0 + 24 >> 2]);
 $6 = sqlite3BtreeGetPageSize($6);
 $10 = ($4 | 0) < ($6 | 0);
 $11 = $4;
 $12 = $4 >> 31;
 $5 = __wasm_i64_mul($4, $12, $1, 0);
 $13 = $5;
 $14 = i64toi32_i32$HIGH_BITS;
 $1 = 0;
 if (($4 | 0) != ($6 | 0)) {
  $1 = ((sqlite3PagerIsMemdb($16) | 0) != 0) << 3;
 }
 $10 = $10 ? $4 : $6;
 $8 = $13 - $11 | 0;
 $5 = $12;
 $4 = $5 + ($11 >>> 0 > $13 >>> 0) | 0;
 $4 = $14 - $4 | 0;
 $9 = $4;
 $4 = $6 >> 31;
 $15 = $4;
 while (1) {
  $4 = $9;
  if (!(($4 | 0) >= ($14 | 0) & $8 >>> 0 >= $13 >>> 0 | ($4 | 0) > ($14 | 0) | $1)) {
   $1 = 0;
   HEAP32[$7 + 12 >> 2] = 0;
   $4 = $15;
   $4 = __wasm_i64_sdiv($8, $9, $6, $4);
   $17 = $4;
   $5 = i64toi32_i32$HIGH_BITS;
   if (($4 | 0) != (HEAPU32[16232] / HEAPU32[HEAP32[HEAP32[$0 + 4 >> 2] + 4 >> 2] + 36 >> 2] | 0)) {
    $1 = sqlite3PagerGet($16, $4 + 1 | 0, $7 + 12 | 0, 0);
    label$5: {
     if ($1) {
      break label$5;
     }
     $1 = sqlite3PagerWrite(HEAP32[$7 + 12 >> 2]);
     if ($1) {
      break label$5;
     }
     $1 = sqlite3PagerGetData(HEAP32[$7 + 12 >> 2]);
     $4 = $5;
     $4 = __wasm_i64_mul($6, $15, $17, $4);
     $5 = $8 - $4 | 0;
     $4 = __memcpy($1 + $5 | 0, __wasm_i64_srem($8, $9, $11, $12) + $2 | 0, $10);
     $1 = 0;
     HEAP8[sqlite3PagerGetExtra(HEAP32[$7 + 12 >> 2]) | 0] = 0;
     if ($8 | $9 | $3) {
      break label$5;
     }
     sqlite3Put4byte($4 + 28 | 0, sqlite3BtreeLastPage(HEAP32[$0 + 24 >> 2]));
    }
    sqlite3PagerUnref(HEAP32[$7 + 12 >> 2]);
   }
   $5 = $9 + $15 | 0;
   $4 = $8 + $6 | 0;
   $8 = $4;
   $5 = $4 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $9 = $5;
   continue;
  }
  break;
 }
 __stack_pointer = $7 + 16 | 0;
 return $1;
}

function sqlite3BitvecSet($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  label$2: {
   if ($0) {
    $2 = $1 - 1 | 0;
    label$4: {
     while (1) {
      if (HEAPU32[$0 >> 2] >= 4001) {
       $1 = HEAP32[$0 + 8 >> 2];
       if (!$1) {
        break label$4;
       }
       $3 = ($2 >>> 0) / ($1 >>> 0) | 0;
       $2 = $2 - Math_imul($3, $1) | 0;
       $4 = ($3 << 2) + $0 | 0;
       $3 = $4 + 12 | 0;
       $0 = HEAP32[$3 >> 2];
       if ($0) {
        continue;
       }
       $0 = sqlite3BitvecCreate($1);
       HEAP32[$4 + 12 >> 2] = $0;
       if ($0) {
        continue;
       }
       break label$1;
      }
      break;
     }
     $1 = ($2 >>> 3 | 0) + $0 | 0;
     $0 = $1 + 12 | 0;
     HEAP8[$0 | 0] = HEAPU8[$1 + 12 | 0] | 1 << ($2 & 7);
     return 0;
    }
    $3 = $2 + 1 | 0;
    $4 = $0 + 12 | 0;
    $1 = ($2 >>> 0) % 125 | 0;
    $2 = HEAP32[$4 + ($1 << 2) >> 2];
    label$7: {
     if ($2) {
      while (1) {
       if (($2 | 0) == ($3 | 0)) {
        return 0;
       }
       $1 = $1 + 1 | 0;
       $1 = $1 >>> 0 > 124 ? 0 : $1;
       $2 = HEAP32[($1 << 2) + $4 >> 2];
       if ($2) {
        continue;
       }
       break;
      }
      $2 = HEAP32[$0 + 4 >> 2];
      if ($2 >>> 0 < 62) {
       break label$7;
      }
      break label$2;
     }
     $2 = HEAP32[$0 + 4 >> 2];
     if ($2 >>> 0 >= 124) {
      break label$2;
     }
    }
    HEAP32[$0 + 4 >> 2] = $2 + 1;
    HEAP32[($1 << 2) + $4 >> 2] = $3;
   }
   return 0;
  }
  $1 = 0;
  $2 = sqlite3DbMallocRaw(0, 500, 0);
  if (!$2) {
   break label$1;
  }
  $5 = __memcpy($2, $4, 500);
  memset($4, 0, 500);
  HEAP32[$0 + 8 >> 2] = (HEAP32[$0 >> 2] + 124 >>> 0) / 125;
  $3 = sqlite3BitvecSet($0, $3);
  while (1) {
   if (($1 | 0) != 125) {
    $2 = HEAP32[($1 << 2) + $5 >> 2];
    if ($2) {
     $3 = sqlite3BitvecSet($0, $2) | $3;
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFree(0, $5);
  return $3;
 }
 return 7;
}

function toLocaltime($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 memset($2 + 56 | 0, 0, 44);
 computeJD($0);
 $5 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 $6 = $3;
 $4 = ($5 >>> 0 < 947587585) + 49596 | 0;
 $4 = $3 - $4 | 0;
 $3 = $5 - 947587585 | 0;
 label$1: {
  if (($4 | 0) == -500 & $3 >>> 0 <= 98047998 | $4 >>> 0 < 4294966796) {
   __memcpy($2 + 8 | 0, $0, 48);
   computeYMD_HMS($2 + 8 | 0);
   HEAP8[$2 + 48 | 0] = 0;
   $6 = HEAP32[$2 + 16 >> 2];
   $7 = (($6 | 0) % 4 | 0) + 2e3 | 0;
   HEAP32[$2 + 16 >> 2] = $7;
   computeJD($2 + 8 | 0);
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $3 = __wasm_i64_sdiv($3, $4, 1e3, 0);
   $5 = $3 - 413362496 | 0;
   HEAP32[$2 + 104 >> 2] = $5;
   $4 = i64toi32_i32$HIGH_BITS;
   HEAP32[$2 + 108 >> 2] = $4 - (($3 >>> 0 < 413362496) + 49 | 0);
   $6 = ($6 - $7 | 0) + 1900 | 0;
   $3 = $2;
   break label$1;
  }
  $3 = __wasm_i64_udiv($5, $6, 1e3, 0);
  $4 = $3;
  $5 = ($4 >>> 0 < 413362496) + 49 | 0;
  $5 = i64toi32_i32$HIGH_BITS - $5 | 0;
  $3 = $4 - 413362496 | 0;
  HEAP32[$2 + 104 >> 2] = $3;
  HEAP32[$2 + 108 >> 2] = $5;
  $6 = 1900;
  $3 = 49;
 }
 label$3: {
  if (osLocaltime($2 + 104 | 0, $2 + 56 | 0)) {
   sqlite3_result_error($1, 13730, -1);
   $1 = 1;
   break label$3;
  }
  HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 76 >> 2] + $6;
  HEAP32[$0 + 12 >> 2] = HEAP32[$2 + 72 >> 2] + 1;
  HEAP32[$0 + 16 >> 2] = HEAP32[$2 + 68 >> 2];
  HEAP32[$0 + 20 >> 2] = HEAP32[$2 + 64 >> 2];
  HEAP32[$0 + 24 >> 2] = HEAP32[$2 + 60 >> 2];
  $6 = HEAP32[$2 + 56 >> 2];
  HEAP8[$0 + 46 | 0] = 0;
  HEAP8[$0 + 44 | 0] = 0;
  HEAP32[$0 + 40 >> 2] = 16842752;
  $5 = HEAP32[$0 >> 2];
  $4 = HEAP32[$0 + 4 >> 2];
  $5 = __wasm_i64_srem($5, $4, 1e3, 0);
  $4 = i64toi32_i32$HIGH_BITS;
  HEAPF64[$0 + 32 >> 3] = (+($5 >>> 0) + +($4 | 0) * 4294967296) * .001 + +($6 | 0);
  $1 = 0;
 }
 __stack_pointer = $2 + 112 | 0;
 return $1;
}

function memjrnlRead($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $7 = 522;
 $6 = ($2 >> 31) + $4 | 0;
 $5 = $2;
 $9 = $3;
 $8 = $5 + $9 | 0;
 $13 = $8;
 $6 = $8 >>> 0 < $9 >>> 0 ? $6 + 1 | 0 : $6;
 $11 = $6;
 $6 = HEAP32[$0 + 16 >> 2];
 $9 = $6;
 $5 = HEAP32[$0 + 20 >> 2];
 $6 = $5;
 $5 = $11;
 if (($5 | 0) <= ($6 | 0) & $9 >>> 0 >= $8 >>> 0 | ($5 | 0) < ($6 | 0)) {
  label$2: {
   label$3: {
    if ($3 | $4) {
     $9 = HEAP32[$0 + 32 >> 2];
     $6 = $3;
     $5 = HEAP32[$0 + 36 >> 2];
     if (($9 | 0) == ($6 | 0) & ($5 | 0) == ($4 | 0)) {
      break label$3;
     }
    }
    $7 = $0 + 12 | 0;
    while (1) {
     $7 = HEAP32[$7 >> 2];
     if (!$7) {
      $7 = 0;
      break label$2;
     }
     $9 = HEAP32[$0 + 4 >> 2];
     $5 = $9 >> 31;
     $12 = $9;
     $9 = $5;
     $5 = $14;
     $8 = $5 + $9 | 0;
     $6 = $10;
     $10 = $6 + $12 | 0;
     $8 = $10 >>> 0 < $12 >>> 0 ? $8 + 1 | 0 : $8;
     $14 = $8;
     $6 = $4;
     $5 = $10;
     if (($8 | 0) <= ($6 | 0) & $5 >>> 0 <= $3 >>> 0 | ($6 | 0) > ($8 | 0)) {
      continue;
     }
     break;
    }
    break label$2;
   }
   $7 = HEAP32[$0 + 40 >> 2];
  }
  $5 = HEAP32[$0 + 4 >> 2];
  $8 = $5 >> 31;
  $6 = $8;
  $8 = $4;
  $4 = $5;
  $5 = $6;
  $5 = __wasm_i64_srem($3, $8, $4, $5);
  while (1) {
   label$8: {
    $4 = ($7 + $5 | 0) + 4 | 0;
    $5 = HEAP32[$0 + 4 >> 2] - $5 | 0;
    $3 = ($2 | 0) < ($5 | 0) ? $2 : $5;
    $1 = __memcpy($1, $4, $3);
    $2 = $2 - $5 | 0;
    if (($2 | 0) < 0) {
     break label$8;
    }
    $7 = HEAP32[$7 >> 2];
    if (!$7) {
     break label$8;
    }
    $1 = $1 + $3 | 0;
    $5 = 0;
    if ($2) {
     continue;
    }
   }
   break;
  }
  HEAP32[$0 + 40 >> 2] = $7;
  $6 = $7 ? $13 : 0;
  HEAP32[$0 + 32 >> 2] = $6;
  $8 = $11;
  HEAP32[$0 + 36 >> 2] = $7 ? $8 : 0;
  $7 = 0;
 }
 return $7 | 0;
}

function modifyPagePointer($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 label$1: {
  label$2: {
   if (($3 | 0) == 4) {
    $0 = HEAP32[$0 + 56 >> 2];
    if ((sqlite3Get4byte($0) | 0) != ($1 | 0)) {
     $5 = sqlite3CorruptError(70575);
     break label$1;
    }
    sqlite3Put4byte($0, $2);
    break label$2;
   }
   if (!HEAPU8[$0 | 0]) {
    $5 = btreeInitPage($0);
    if ($5) {
     break label$1;
    }
   }
   $7 = HEAPU16[$0 + 24 >> 1];
   $5 = 0;
   $8 = ($3 | 0) != 3;
   label$6: {
    while (1) {
     if (($5 | 0) == ($7 | 0)) {
      break label$6;
     }
     $4 = HEAP32[$0 + 64 >> 2] + ($5 << 1) | 0;
     $4 = HEAP32[$0 + 56 >> 2] + (HEAPU16[$0 + 26 >> 1] & (HEAPU8[$4 | 0] << 8 | HEAPU8[$4 + 1 | 0])) | 0;
     label$8: {
      label$9: {
       if (!$8) {
        FUNCTION_TABLE[HEAP32[$0 + 80 >> 2]]($0, $4, $6 + 8 | 0);
        if (HEAPU32[$6 + 20 >> 2] <= HEAPU16[$6 + 24 >> 1]) {
         break label$9;
        }
        $4 = HEAPU16[$6 + 26 >> 1] + $4 | 0;
        if ($4 >>> 0 > HEAP32[$0 + 56 >> 2] + HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] >>> 0) {
         $5 = sqlite3CorruptError(70594);
         break label$1;
        }
        $4 = $4 - 4 | 0;
        if ((sqlite3Get4byte($4) | 0) != ($1 | 0)) {
         break label$9;
        }
        sqlite3Put4byte($4, $2);
        break label$2;
       }
       if ((sqlite3Get4byte($4) | 0) == ($1 | 0)) {
        break label$8;
       }
      }
      $5 = $5 + 1 | 0;
      continue;
     }
     break;
    }
    sqlite3Put4byte($4, $2);
    break label$2;
   }
   label$12: {
    if (($3 | 0) == 5) {
     $0 = (HEAPU8[$0 + 9 | 0] + HEAP32[$0 + 56 >> 2] | 0) + 8 | 0;
     if ((sqlite3Get4byte($0) | 0) == ($1 | 0)) {
      break label$12;
     }
    }
    $5 = sqlite3CorruptError(70612);
    break label$1;
   }
   sqlite3Put4byte($0, $2);
  }
  $5 = 0;
 }
 __stack_pointer = $6 + 32 | 0;
 return $5;
}

function sqlite3AffinityType($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = 67;
 while (1) {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $6 = HEAPU8[$0 | 0];
      if ($6) {
       $0 = $0 + 1 | 0;
       label$7: {
        $2 = HEAPU8[$6 + 29904 | 0] | $2 << 8;
        if (($2 | 0) != 1651273570) {
         if (($2 | 0) == 1667785074) {
          $3 = 66;
          $4 = $0;
          continue;
         }
         if (($2 | 0) != 1952807028 & ($2 | 0) != 1668050786) {
          break label$7;
         }
         $3 = 66;
         continue;
        }
        label$10: {
         switch (($3 & 7) - 3 | 0) {
         case 0:
         case 2:
          break label$10;

         default:
          break label$7;
         }
        }
        $4 = HEAPU8[$0 | 0] == 40 ? $0 : $4;
        $3 = 65;
        continue;
       }
       $6 = ($3 | 0) == 67;
       if ($6 & ($2 | 0) == 1685026146 | (($2 | 0) == 1919246700 | ($2 | 0) == 1718382433) & $6) {
        break label$2;
       }
       if (($2 & 16777215) != 6909556) {
        continue;
       }
       if ($1) {
        break label$5;
       }
       $3 = 68;
       break label$3;
      }
      if (!$1) {
       break label$3;
      }
      $0 = 0;
      HEAP32[$5 + 12 >> 2] = 0;
      if ($3 >>> 0 > 66) {
       break label$4;
      }
      if (!$4) {
       $0 = 4;
       break label$4;
      }
      while (1) {
       $2 = HEAPU8[$4 | 0];
       if (!$2) {
        break label$4;
       }
       if ($2 - 58 >>> 0 >= 4294967286) {
        sqlite3GetInt32($4, $5 + 12 | 0);
        $0 = HEAP32[$5 + 12 >> 2] / 4 | 0;
        break label$4;
       } else {
        $4 = $4 + 1 | 0;
        continue;
       }
      }
     }
     $3 = 68;
     $0 = 0;
    }
    HEAP8[$1 + 6 | 0] = (($0 | 0) < 254 ? $0 : 254) + 1;
   }
   __stack_pointer = $5 + 16 | 0;
   return $3;
  }
  $3 = 69;
  continue;
 }
}

function blobSeekToRow($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = __stack_pointer - 48 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 + 16 >> 2];
 $4 = HEAP32[$5 + 88 >> 2];
 HEAP32[$4 + 40 >> 2] = $1;
 HEAP32[$4 + 44 >> 2] = $2;
 HEAP16[$4 + 56 >> 1] = 4;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if (HEAP32[$5 + 32 >> 2] >= 5) {
      HEAP32[$5 + 32 >> 2] = 4;
      $4 = sqlite3VdbeExec($5);
      break label$4;
     }
     $4 = sqlite3_step(HEAP32[$0 + 16 >> 2]);
    }
    if (($4 | 0) == 100) {
     $4 = HEAP32[HEAP32[$5 + 96 >> 2] >> 2];
     $5 = HEAPU16[$0 + 8 >> 1];
     if ($5 >>> 0 >= HEAPU16[$4 + 54 >> 1]) {
      $5 = HEAP32[$0 + 20 >> 2];
      break label$3;
     }
     $1 = HEAP32[(($5 << 2) + $4 | 0) + 80 >> 2];
     if ($1 >>> 0 <= 11) {
      $5 = HEAP32[$0 + 20 >> 2];
      if (!$1) {
       break label$3;
      }
      $4 = ($1 | 0) == 7 ? 11325 : 9157;
      break label$2;
     }
     HEAP32[$0 + 4 >> 2] = HEAP32[((HEAP16[$4 + 52 >> 1] + $5 << 2) + $4 | 0) + 80 >> 2];
     HEAP32[$0 >> 2] = sqlite3VdbeSerialTypeLen($1);
     $4 = HEAP32[$4 + 36 >> 2];
     HEAP32[$0 + 12 >> 2] = $4;
     sqlite3BtreeIncrblobCursor($4);
     $5 = 0;
     $4 = 0;
     break label$1;
    }
    $5 = HEAP32[$0 + 16 >> 2];
    if (!$5) {
     $5 = 0;
     break label$1;
    }
    $4 = sqlite3_finalize($5);
    HEAP32[$0 + 16 >> 2] = 0;
    $0 = HEAP32[$0 + 20 >> 2];
    if (!$4) {
     HEAP32[$6 + 16 >> 2] = $1;
     HEAP32[$6 + 20 >> 2] = $2;
     $4 = 1;
     $5 = sqlite3MPrintf($0, 14310, $6 + 16 | 0);
     break label$1;
    }
    HEAP32[$6 + 32 >> 2] = sqlite3_errmsg($0);
    $5 = sqlite3MPrintf($0, 8342, $6 + 32 | 0);
    break label$1;
   }
   $4 = 11103;
  }
  HEAP32[$6 >> 2] = $4;
  $5 = sqlite3MPrintf($5, 6463, $6);
  sqlite3_finalize(HEAP32[$0 + 16 >> 2]);
  HEAP32[$0 + 16 >> 2] = 0;
  $4 = 1;
 }
 HEAP32[$3 >> 2] = $5;
 __stack_pointer = $6 + 48 | 0;
 return $4;
}

function fts3auxFilterMethod($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 32 | 0;
 __stack_pointer = $7;
 $5 = 1;
 $6 = HEAP32[$0 >> 2];
 $10 = HEAP32[$6 + 12 >> 2];
 $6 = $0 + 4 | 0;
 sqlite3Fts3SegReaderFinish($6);
 sqlite3_free(HEAP32[$0 + 60 >> 2]);
 sqlite3_free(HEAP32[$0 + 112 >> 2]);
 sqlite3_free(HEAP32[$0 + 76 >> 2]);
 $6 = memset($6, 0, 116);
 $11 = ($1 | 0) == 1;
 label$1: {
  if ($11) {
   $8 = 3;
   $2 = -1;
   break label$1;
  }
  $12 = 1;
  $5 = $1 & 2;
  $9 = $5 >>> 1 | 0;
  $1 = $1 & 4;
  $5 = $1 ? $5 ? 2 : 1 : $9;
  $8 = 19;
  $2 = $1 ? $9 : -1;
 }
 $1 = $8;
 HEAP32[$0 + 72 >> 2] = $1;
 $8 = $0 + 60 | 0;
 label$3: {
  label$4: {
   label$5: {
    if (!($9 | $11)) {
     break label$5;
    }
    $1 = sqlite3_value_text(HEAP32[$4 >> 2]);
    if (!$1) {
     break label$5;
    }
    HEAP32[$7 + 16 >> 2] = $1;
    $1 = sqlite3_mprintf(8342, $7 + 16 | 0);
    HEAP32[$8 >> 2] = $1;
    if (!$1) {
     break label$4;
    }
    HEAP32[$0 - -64 >> 2] = strlen($1);
   }
   $1 = 0;
   if (($2 | 0) >= 0) {
    HEAP32[$7 >> 2] = sqlite3_value_text(HEAP32[($2 << 2) + $4 >> 2]);
    $2 = sqlite3_mprintf(8342, $7);
    HEAP32[$0 + 76 >> 2] = $2;
    if (!$2) {
     break label$4;
    }
    HEAP32[$0 + 80 >> 2] = strlen($2);
   }
   if (($3 | 0) > ($5 | 0)) {
    $1 = sqlite3_value_int(HEAP32[((($3 | 0) > ($5 | 0) ? $5 : -1) << 2) + $4 >> 2]);
    $1 = ($1 | 0) > 0 ? $1 : 0;
   }
   HEAP32[$0 + 84 >> 2] = $1;
   $1 = sqlite3Fts3SegReaderCursor($10, $1, 0, -2, HEAP32[$0 + 60 >> 2], HEAP32[$0 - -64 >> 2], 0, $12, $6);
   if ($1) {
    break label$3;
   }
   $1 = sqlite3Fts3SegReaderStart($10, $6, $8);
   if ($1) {
    break label$3;
   }
   $1 = fts3auxNextMethod($0);
   break label$3;
  }
  $1 = 7;
 }
 __stack_pointer = $7 + 32 | 0;
 return $1 | 0;
}

function sqlite3GenerateRowDelete($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 $11 = HEAP32[$0 + 8 >> 2];
 $14 = sqlite3VdbeMakeLabel($0);
 $18 = HEAPU8[$1 + 28 | 0] & 128 ? 27 : 30;
 if (!$9) {
  sqlite3VdbeAddOp4Int($11, $18, $3, $14, $5, $6);
 }
 $12 = sqlite3FkRequired($0, $1, 0, 0);
 if ($12 ? 1 : $2) {
  $12 = 0;
  $17 = sqlite3TriggerColmask($0, $2, 0, 0, 3, $1, $8);
  $15 = sqlite3FkOldmask($0, $1);
  $16 = HEAP32[$0 + 44 >> 2];
  $13 = $16 + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $13 + HEAP16[$1 + 34 >> 1];
  sqlite3VdbeAddOp2($11, 80, $5, $13);
  $16 = $16 + 2 | 0;
  $15 = $17 | $15;
  $17 = ($15 | 0) == -1;
  while (1) {
   if (HEAP16[$1 + 34 >> 1] > ($12 | 0)) {
    if (!(!$17 & (!($15 >>> $12 & 1) | $12 >>> 0 > 31))) {
     sqlite3ExprCodeGetColumnOfTable($11, $1, $3, $12, sqlite3TableColumnToStorage($1, $12 << 16 >> 16) + $16 | 0);
    }
    $12 = $12 + 1 | 0;
    continue;
   }
   break;
  }
  $12 = sqlite3VdbeCurrentAddr($11);
  sqlite3CodeRowTrigger($0, $2, 128, 0, 1, $1, $13, $8, $14);
  if ((sqlite3VdbeCurrentAddr($11) | 0) > ($12 | 0)) {
   sqlite3VdbeAddOp4Int($11, $18, $3, $14, $5, $6);
   $10 = -1;
  }
  sqlite3FkCheck($0, $1, $13, 0, 0, 0);
 }
 if (HEAPU8[$1 + 43 | 0] != 2) {
  sqlite3GenerateRowIndexDelete($0, $1, $3, $4, 0, $10);
  sqlite3VdbeAddOp2($11, 130, $3, ($7 | 0) != 0);
  label$8: {
   if (HEAPU8[$0 + 18 | 0]) {
    if (sqlite3_stricmp(HEAP32[$1 >> 2], 23100)) {
     break label$8;
    }
   }
   sqlite3VdbeAppendP4($11, $1, -5);
  }
  if ($9) {
   sqlite3VdbeChangeP5($11, 4);
  }
  if (!(($3 | 0) == ($10 | 0) | ($10 | 0) < 0)) {
   sqlite3VdbeAddOp1($11, 130, $10);
  }
  sqlite3VdbeChangeP5($11, (($9 | 0) == 2) << 1);
 }
 sqlite3FkActions($0, $1, 0, $13, 0, 0);
 sqlite3CodeRowTrigger($0, $2, 128, 0, 2, $1, $13, $8, $14);
 sqlite3VdbeResolveLabel($11, $14);
}

function getPageNormal($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  if (!$1) {
   $4 = sqlite3CorruptError(59406);
   break label$1;
  }
  $4 = sqlite3PcacheFetch(HEAP32[$0 + 228 >> 2], $1, 3);
  HEAP32[$6 + 12 >> 2] = $4;
  label$3: {
   label$4: {
    if ($4) {
     break label$4;
    }
    $4 = sqlite3PcacheFetchStress(HEAP32[$0 + 228 >> 2], $1, $6 + 12 | 0);
    if ($4) {
     break label$3;
    }
    $4 = HEAP32[$6 + 12 >> 2];
    if ($4) {
     break label$4;
    }
    $4 = 7;
    break label$3;
   }
   $5 = sqlite3PcacheFetchFinish(HEAP32[$0 + 228 >> 2], $1, $4);
   HEAP32[$2 >> 2] = $5;
   label$5: {
    $3 = $3 & 1;
    label$6: {
     if (!($3 | !HEAP32[$5 + 20 >> 2])) {
      HEAP32[$0 + 200 >> 2] = HEAP32[$0 + 200 >> 2] + 1;
      break label$6;
     }
     if (HEAP32[$0 + 164 >> 2] == ($1 | 0)) {
      $4 = sqlite3CorruptError(59438);
      break label$5;
     }
     HEAP32[$5 + 20 >> 2] = $0;
     if (!(!(!HEAP32[HEAP32[$0 + 64 >> 2] >> 2] | $3) & HEAPU32[$0 + 28 >> 2] >= $1 >>> 0)) {
      $4 = 13;
      if (HEAPU32[$0 + 160 >> 2] < $1 >>> 0) {
       break label$5;
      }
      if ($3) {
       sqlite3BeginBenignMalloc();
       if (HEAPU32[$0 + 32 >> 2] >= $1 >>> 0) {
        sqlite3BitvecSet(HEAP32[$0 + 60 >> 2], $1);
       }
       addToSavepointBitvecs($0, $1);
       sqlite3EndBenignMalloc();
      }
      $4 = 0;
      memset(HEAP32[$5 + 4 >> 2], 0, HEAP32[$0 + 168 >> 2]);
      break label$1;
     }
     $1 = $0 + 204 | 0;
     HEAP32[$1 >> 2] = HEAP32[$0 + 204 >> 2] + 1;
     $4 = readDbPage($5);
     if ($4) {
      break label$5;
     }
    }
    $4 = 0;
    break label$1;
   }
   sqlite3PcacheDrop($5);
  }
  pagerUnlockIfUnused($0);
  HEAP32[$2 >> 2] = 0;
 }
 __stack_pointer = $6 + 16 | 0;
 return $4 | 0;
}

function updateFromSelect($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = __stack_pointer - 32 | 0;
 __stack_pointer = $8;
 $7 = HEAP32[$4 + 24 >> 2];
 $9 = HEAP32[$0 >> 2];
 $6 = sqlite3SrcListDup($9, $4, 0);
 $10 = sqlite3ExprDup($9, $5, 0);
 if ($6) {
  HEAP32[$6 + 48 >> 2] = -1;
  $4 = $6 + 45 | 0;
  $5 = HEAPU8[$6 + 45 | 0] | HEAPU8[$6 + 46 | 0] << 8 | 512;
  HEAP8[$4 | 0] = $5;
  HEAP8[$4 + 1 | 0] = $5 >>> 8;
  $4 = $6 + 24 | 0;
  $5 = HEAP32[$4 >> 2];
  HEAP32[$5 + 24 >> 2] = HEAP32[$5 + 24 >> 2] - 1;
  HEAP32[$6 + 24 >> 2] = 0;
 }
 label$2: {
  if ($2) {
   $4 = 0;
   $5 = 0;
   while (1) {
    if ($5 >>> 0 < HEAPU16[$2 + 50 >> 1]) {
     $4 = sqlite3ExprListAppend($0, $4, exprRowColumn($0, HEAP16[HEAP32[$2 + 4 >> 2] + ($5 << 1) >> 1]));
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   $7 = HEAPU8[$7 + 43 | 0] == 1 ? 14 : 15;
   break label$2;
  }
  $4 = HEAPU8[$7 + 43 | 0];
  if (($4 | 0) == 2) {
   $4 = 0;
   $5 = 0;
   while (1) if (HEAP16[$7 + 34 >> 1] <= ($5 | 0)) {
    $7 = 14;
    break label$2;
   } else {
    $4 = sqlite3ExprListAppend($0, $4, exprRowColumn($0, $5));
    $5 = $5 + 1 | 0;
    continue;
   }
  }
  $7 = ($4 | 0) == 1 ? 14 : 15;
  $4 = sqlite3ExprListAppend($0, 0, sqlite3PExpr($0, 75, 0, 0));
 }
 label$10: {
  if (!$3) {
   break label$10;
  }
  $5 = 0;
  while (1) {
   if (HEAP32[$3 >> 2] <= ($5 | 0)) {
    break label$10;
   }
   $4 = sqlite3ExprListAppend($0, $4, sqlite3ExprDup($9, HEAP32[(($5 << 4) + $3 | 0) + 8 >> 2], 0));
   $5 = $5 + 1 | 0;
   continue;
  }
 }
 $4 = sqlite3SelectNew($0, $4, $6, $10, 0, 0, 0, 8519680, 0);
 if ($4) {
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 134217728;
 }
 sqlite3SelectDestInit($8, $7, $1);
 $5 = $2 ? HEAPU16[$2 + 50 >> 1] : -1;
 HEAP32[$8 + 8 >> 2] = $5;
 sqlite3Select($0, $4, $8);
 sqlite3SelectDelete($9, $4);
 __stack_pointer = $8 + 32 | 0;
}

function impliesNotNullRow($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $3 = 1;
 label$1: {
  if (HEAP8[$1 + 4 | 0] & 1) {
   break label$1;
  }
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       $2 = HEAPU8[$1 | 0];
       switch ($2 - 43 | 0) {
       case 0:
       case 2:
       case 6:
       case 7:
       case 8:
        break label$1;

       case 3:
       case 4:
        break label$2;

       case 9:
       case 10:
       case 11:
       case 12:
       case 13:
       case 14:
        break label$3;

       case 5:
        break label$4;

       case 1:
        break label$5;

       default:
        break label$6;
       }
      }
      $2 = $2 - 157 | 0;
      if ($2 >>> 0 > 20) {
       break label$2;
      }
      if (1 << $2 & 1359873) {
       break label$1;
      }
      if (($2 | 0) != 10) {
       break label$2;
      }
      if (HEAP32[$0 + 24 >> 2] != HEAP32[$1 + 28 >> 2]) {
       break label$1;
      }
      HEAP16[$0 + 20 >> 1] = 1;
      return 2;
     }
     if (HEAPU16[$0 + 20 >> 1]) {
      break label$1;
     }
     sqlite3WalkExpr($0, HEAP32[$1 + 12 >> 2]);
     if (!HEAPU16[$0 + 20 >> 1]) {
      break label$1;
     }
     HEAP16[$0 + 20 >> 1] = 0;
     sqlite3WalkExpr($0, HEAP32[$1 + 16 >> 2]);
     return 1;
    }
    return ((sqlite3WalkExpr($0, HEAP32[$1 + 12 >> 2]) | 0) == 2 ? 2 : 1) | 0;
   }
   $0 = HEAP32[$1 + 16 >> 2];
   $1 = HEAP32[$1 + 12 >> 2];
   label$7: {
    if (HEAPU8[$1 | 0] != 167) {
     break label$7;
    }
    $1 = HEAP32[$1 + 44 >> 2];
    if (!$1) {
     break label$7;
    }
    if (HEAPU8[$1 + 43 | 0] == 1) {
     break label$1;
    }
   }
   if (HEAPU8[$0 | 0] != 167) {
    break label$2;
   }
   $1 = HEAP32[$0 + 44 >> 2];
   if (!$1) {
    break label$2;
   }
   if (HEAPU8[$1 + 43 | 0] == 1) {
    break label$1;
   }
  }
  $3 = 0;
 }
 return $3 | 0;
}

function btreeDropTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = 0;
 $5 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if (btreePagecount($5) >>> 0 < $1 >>> 0) {
   $4 = sqlite3CorruptError(76777);
   break label$1;
  }
  $4 = sqlite3BtreeClearTable($0, $1, 0);
  if ($4) {
   break label$1;
  }
  $4 = btreeGetPage($5, $1, $3 + 8 | 0, 0);
  HEAP32[$3 + 12 >> 2] = $4;
  if ($4) {
   releasePage(HEAP32[$3 + 8 >> 2]);
   break label$1;
  }
  HEAP32[$2 >> 2] = 0;
  if (HEAPU8[$5 + 17 | 0]) {
   sqlite3BtreeGetMeta($0, 4, $3 + 4 | 0);
   $6 = HEAP32[$3 + 4 >> 2];
   label$5: {
    if (($6 | 0) == ($1 | 0)) {
     $1 = HEAP32[$3 + 8 >> 2];
     freePage($1, $3 + 12 | 0);
     releasePage($1);
     $4 = HEAP32[$3 + 12 >> 2];
     if (!$4) {
      break label$5;
     }
     break label$1;
    }
    releasePage(HEAP32[$3 + 8 >> 2]);
    $4 = btreeGetPage($5, $6, $3, 0);
    if ($4) {
     break label$1;
    }
    $7 = HEAP32[$3 >> 2];
    $4 = relocatePage($5, $7, 1, 0, $1, 0);
    releasePage($7);
    if ($4) {
     break label$1;
    }
    HEAP32[$3 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = btreeGetPage($5, $6, $3, 0);
    $1 = HEAP32[$3 >> 2];
    freePage($1, $3 + 12 | 0);
    releasePage($1);
    $4 = HEAP32[$3 + 12 >> 2];
    if ($4) {
     break label$1;
    }
    HEAP32[$2 >> 2] = $6;
   }
   $2 = (HEAPU32[16232] / HEAPU32[$5 + 36 >> 2] | 0) + 2 | 0;
   while (1) {
    $4 = ($2 | 0) == ($6 | 0);
    $1 = $6 - 1 | 0;
    $6 = $1;
    if ($4) {
     continue;
    }
    $6 = $1;
    if ((ptrmapPageno($5, $1) | 0) == ($1 | 0)) {
     continue;
    }
    break;
   }
   $4 = sqlite3BtreeUpdateMeta($0, 4, $1);
   break label$1;
  }
  $1 = HEAP32[$3 + 8 >> 2];
  freePage($1, $3 + 12 | 0);
  releasePage($1);
  $4 = HEAP32[$3 + 12 >> 2];
 }
 __stack_pointer = $3 + 16 | 0;
 return $4;
}

function sqlite3SrcListAppendFromTerm($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 $8 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   label$3: {
    if (!$6 | $1) {
     break label$3;
    }
    $7 = 19433;
    if (!HEAP32[$6 >> 2]) {
     $7 = 19708;
     if (!HEAP32[$6 + 4 >> 2]) {
      break label$3;
     }
    }
    HEAP32[$9 >> 2] = $7;
    sqlite3ErrorMsg($0, 6427, $9);
    break label$2;
   }
   $1 = sqlite3SrcListAppend($0, $1, $2, $3);
   if (!$1) {
    break label$2;
   }
   $7 = HEAP32[$1 >> 2] - 1 | 0;
   label$5: {
    if (HEAPU8[$0 + 208 | 0] < 2) {
     break label$5;
    }
    $10 = HEAP32[(($7 << 6) + $1 | 0) + 16 >> 2];
    if (!$10) {
     break label$5;
    }
    $3 = (HEAP32[$3 >> 2] ? $3 : 0) ? $3 : $2;
    sqlite3RenameTokenMap($0, $10, $3);
   }
   if (HEAP32[$4 + 4 >> 2]) {
    HEAP32[(($7 << 6) + $1 | 0) + 20 >> 2] = sqlite3NameFromToken($8, $4);
   }
   label$9: {
    if (!$5) {
     break label$9;
    }
    $0 = ($7 << 6) + $1 | 0;
    HEAP32[$0 + 28 >> 2] = $5;
    if (!(HEAPU8[$5 + 5 | 0] & 8)) {
     break label$9;
    }
    $2 = $0;
    $0 = $0 + 45 | 0;
    $2 = HEAPU8[$2 + 45 | 0] | HEAPU8[$2 + 46 | 0] << 8 | 8192;
    HEAP8[$0 | 0] = $2;
    HEAP8[$0 + 1 | 0] = $2 >>> 8;
   }
   if (!$6) {
    HEAP32[(($7 << 6) + $1 | 0) + 52 >> 2] = 0;
    break label$1;
   }
   if (HEAP32[$6 + 4 >> 2]) {
    $0 = ($7 << 6) + $1 | 0;
    $8 = $0 + 45 | 0;
    $2 = HEAPU8[$0 + 45 | 0] | HEAPU8[$0 + 46 | 0] << 8 | 1024;
    HEAP8[$8 | 0] = $2;
    HEAP8[$8 + 1 | 0] = $2 >>> 8;
    HEAP32[$0 + 52 >> 2] = HEAP32[$6 + 4 >> 2];
    break label$1;
   }
   HEAP32[(($7 << 6) + $1 | 0) + 52 >> 2] = HEAP32[$6 >> 2];
   break label$1;
  }
  sqlite3ClearOnOrUsing($8, $6);
  sqlite3SelectDelete($8, $5);
  $1 = 0;
 }
 __stack_pointer = $9 + 16 | 0;
 return $1;
}

function sqlite3RowSetTest($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 if (HEAP32[$0 + 28 >> 2] != ($1 | 0)) {
  $5 = HEAP32[$0 + 8 >> 2];
  if ($5) {
   if (!(HEAP8[$0 + 26 | 0] & 1)) {
    $5 = rowSetEntrySort($5);
   }
   $6 = $0 + 20 | 0;
   label$4: {
    label$5: {
     while (1) {
      $4 = HEAP32[$6 >> 2];
      if (!$4) {
       break label$5;
      }
      $6 = HEAP32[$4 + 12 >> 2];
      if ($6) {
       rowSetTreeToList($6, $7 + 12 | 0, $7 + 8 | 0);
       HEAP32[$4 + 12 >> 2] = 0;
       $6 = $4 + 8 | 0;
       $5 = rowSetEntryMerge(HEAP32[$7 + 12 >> 2], $5);
       continue;
      }
      break;
     }
     HEAP32[$4 + 12 >> 2] = rowSetListToTree($5);
     break label$4;
    }
    $4 = rowSetEntryAlloc($0);
    HEAP32[$6 >> 2] = $4;
    if (!$4) {
     break label$4;
    }
    HEAP32[$4 + 8 >> 2] = 0;
    HEAP32[$4 >> 2] = 0;
    HEAP32[$4 + 4 >> 2] = 0;
    HEAP32[$4 + 12 >> 2] = rowSetListToTree($5);
   }
   HEAP32[$0 + 8 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = 0;
   HEAP16[$0 + 26 >> 1] = HEAPU16[$0 + 26 >> 1] | 1;
  }
  HEAP32[$0 + 28 >> 2] = $1;
 }
 $4 = $0 + 20 | 0;
 while (1) {
  label$9: {
   $5 = HEAP32[$4 >> 2];
   if (!$5) {
    $4 = 0;
    break label$9;
   }
   $4 = $5 + 12 | 0;
   while (1) {
    $4 = HEAP32[$4 >> 2];
    if ($4) {
     $0 = HEAP32[$4 >> 2];
     $1 = $0;
     $1 = $0;
     $6 = HEAP32[$4 + 4 >> 2];
     $0 = $6;
     if ($2 >>> 0 > $1 >>> 0 & ($3 | 0) >= ($0 | 0) | ($3 | 0) > ($0 | 0)) {
      $4 = $4 + 8 | 0;
      continue;
     }
     $0 = $1;
     if ($0 >>> 0 <= $2 >>> 0 & ($3 | 0) >= ($6 | 0) | ($3 | 0) > ($6 | 0)) {
      $4 = 1;
      break label$9;
     } else {
      $4 = $4 + 12 | 0;
      continue;
     }
    }
    break;
   }
   $4 = $5 + 8 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $7 + 16 | 0;
 return $4;
}

function datetimeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 label$1: {
  if (isDate($0, $1, $2, $3 + 32 | 0)) {
   break label$1;
  }
  computeYMD_HMS($3 + 32 | 0);
  HEAP8[$3 + 5 | 0] = 45;
  HEAP8[$3 + 8 | 0] = 45;
  HEAP8[$3 + 11 | 0] = 32;
  HEAP8[$3 + 14 | 0] = 58;
  $2 = HEAP32[$3 + 44 >> 2];
  $1 = ($2 | 0) / 10 | 0;
  HEAP8[$3 + 6 | 0] = (($1 | 0) % 10 | 0) + 48;
  $4 = HEAP32[$3 + 48 >> 2];
  $5 = ($4 | 0) / 10 | 0;
  HEAP8[$3 + 9 | 0] = (($5 | 0) % 10 | 0) + 48;
  $6 = HEAP32[$3 + 52 >> 2];
  $7 = ($6 | 0) / 10 | 0;
  HEAP8[$3 + 12 | 0] = (($7 | 0) % 10 | 0) + 48;
  HEAP8[$3 + 7 | 0] = ($2 - Math_imul($1, 10) | 0) + 48;
  HEAP8[$3 + 10 | 0] = ($4 - Math_imul($5, 10) | 0) + 48;
  HEAP8[$3 + 13 | 0] = ($6 - Math_imul($7, 10) | 0) + 48;
  $1 = HEAP32[$3 + 40 >> 2];
  $2 = $1 >> 31;
  $2 = ($1 ^ $2) - $2 | 0;
  HEAP8[$3 + 2 | 0] = (($2 >>> 0) / 100 >>> 0) % 10 | 48;
  HEAP8[$3 + 1 | 0] = (($2 >>> 0) / 1e3 >>> 0) % 10 | 48;
  $4 = ($2 >>> 0) / 10 | 0;
  HEAP8[$3 + 3 | 0] = ($4 >>> 0) % 10 | 48;
  HEAP8[$3 + 4 | 0] = $2 - Math_imul($4, 10) | 48;
  $2 = HEAP32[$3 + 56 >> 2];
  HEAP8[$3 + 17 | 0] = 58;
  $4 = ($2 | 0) / 10 | 0;
  HEAP8[$3 + 16 | 0] = ($2 - Math_imul($4, 10) | 0) + 48;
  HEAP8[$3 + 15 | 0] = (($4 | 0) % 10 | 0) + 48;
  HEAP8[$3 + 20 | 0] = 0;
  $8 = HEAPF64[$3 + 64 >> 3];
  label$2: {
   if (Math_abs($8) < 2147483648) {
    $2 = ~~$8;
    break label$2;
   }
   $2 = -2147483648;
  }
  $4 = ($2 | 0) / 10 | 0;
  HEAP8[$3 + 18 | 0] = (($4 | 0) % 10 | 0) + 48;
  HEAP8[$3 + 19 | 0] = ($2 - Math_imul($4, 10) | 0) + 48;
  if (($1 | 0) < 0) {
   HEAP8[$3 | 0] = 45;
   sqlite3_result_text($0, $3, 20, -1);
   break label$1;
  }
  sqlite3_result_text($0, $3 | 1, 19, -1);
 }
 __stack_pointer = $3 + 80 | 0;
}

function sqlite3QuoteValue($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 label$1: {
  label$2: {
   switch (sqlite3_value_type($1) - 1 | 0) {
   case 1:
    $5 = sqlite3_value_double($1);
    HEAPF64[$2 + 16 >> 3] = $5;
    sqlite3_str_appendf($0, 12016, $2 + 16 | 0);
    $1 = sqlite3_str_value($0);
    if (!$1) {
     break label$1;
    }
    sqlite3AtoF($1, $2 + 56 | 0, HEAP32[$0 + 16 >> 2], 1);
    if (HEAPF64[$2 + 56 >> 3] == $5) {
     break label$1;
    }
    sqlite3_str_reset($0);
    HEAPF64[$2 >> 3] = $5;
    sqlite3_str_appendf($0, 14207, $2);
    break label$1;

   case 0:
    HEAP32[$2 + 32 >> 2] = sqlite3_value_int64($1);
    HEAP32[$2 + 36 >> 2] = i64toi32_i32$HIGH_BITS;
    sqlite3_str_appendf($0, 14325, $2 + 32 | 0);
    break label$1;

   case 3:
    $8 = sqlite3_value_blob($1);
    $3 = sqlite3_value_bytes($1);
    $6 = $3 << 1;
    sqlite3StrAccumEnlarge($0, $6 + 4 | 0);
    if (HEAPU8[$0 + 20 | 0]) {
     break label$1;
    }
    $1 = 0;
    $9 = ($3 | 0) > 0 ? $3 : 0;
    $4 = HEAP32[$0 + 4 >> 2];
    while (1) {
     if (($1 | 0) != ($9 | 0)) {
      $3 = ($1 << 1) + $4 | 0;
      $7 = $1 + $8 | 0;
      HEAP8[$3 + 2 | 0] = HEAPU8[(HEAPU8[$7 | 0] >>> 4 | 0) + 50720 | 0];
      HEAP8[$3 + 3 | 0] = HEAPU8[(HEAPU8[$7 | 0] & 15) + 50720 | 0];
      $1 = $1 + 1 | 0;
      continue;
     }
     break;
    }
    ;
    $1 = $4 + $6 | 0;
    HEAP8[$1 + 2 | 0] = 39;
    HEAP8[$1 + 3 | 0] = 0;
    HEAP8[$4 | 0] = 88;
    HEAP8[$4 + 1 | 0] = 39;
    HEAP32[$0 + 16 >> 2] = $6 + 3;
    break label$1;

   case 2:
    HEAP32[$2 + 48 >> 2] = sqlite3_value_text($1);
    sqlite3_str_appendf($0, 19351, $2 + 48 | 0);
    break label$1;

   default:
    break label$2;
   }
  }
  sqlite3_str_append($0, 19646, 4);
 }
 __stack_pointer = $2 - -64 | 0;
}

function sqlite3PagerCommitPhaseOne($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 + 44 >> 2];
 label$1: {
  if ($3) {
   break label$1;
  }
  $3 = 10;
  if (sqlite3FaultSim(400)) {
   break label$1;
  }
  label$2: {
   if (HEAPU8[$0 + 17 | 0] < 3) {
    break label$2;
   }
   label$3: {
    if (!pagerFlushOnCommit($0, 1)) {
     sqlite3BackupRestart(HEAP32[$0 + 96 >> 2]);
     break label$3;
    }
    label$5: {
     if (HEAP32[$0 + 232 >> 2]) {
      HEAP32[$4 + 12 >> 2] = 0;
      $3 = sqlite3PcacheDirtyList(HEAP32[$0 + 228 >> 2]);
      if (!$3) {
       sqlite3PagerGet($0, 1, $4 + 12 | 0, 0);
       $3 = HEAP32[$4 + 12 >> 2];
       HEAP32[$3 + 16 >> 2] = 0;
      }
      $3 = pagerWalFrames($0, $3, HEAP32[$0 + 28 >> 2], 1);
      sqlite3PagerUnref(HEAP32[$4 + 12 >> 2]);
      if ($3) {
       break label$5;
      }
      sqlite3PcacheCleanAll(HEAP32[$0 + 228 >> 2]);
      break label$5;
     }
     $3 = pager_incr_changecounter($0);
     if ($3) {
      break label$1;
     }
     $3 = writeSuperJournal($0, $1);
     if ($3) {
      break label$1;
     }
     $3 = syncJournal($0, 0);
     if ($3) {
      break label$1;
     }
     $3 = pager_write_pagelist($0, sqlite3PcacheDirtyList(HEAP32[$0 + 228 >> 2]));
     if ($3) {
      break label$1;
     }
     sqlite3PcacheCleanAll(HEAP32[$0 + 228 >> 2]);
     $3 = HEAP32[$0 + 28 >> 2];
     if ($3 >>> 0 > HEAPU32[$0 + 36 >> 2]) {
      $3 = pager_truncate($0, $3 - (HEAP32[$0 + 164 >> 2] == ($3 | 0)) | 0);
      if ($3) {
       break label$1;
      }
     }
     if ($2) {
      break label$3;
     }
     $3 = sqlite3PagerSync($0, $1);
    }
    if ($3) {
     break label$1;
    }
   }
   if (HEAP32[$0 + 232 >> 2]) {
    break label$2;
   }
   HEAP8[$0 + 17 | 0] = 5;
  }
  $3 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function fts3EvalAverageDocsize($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 + 60 >> 2];
 label$1: {
  if (!$3) {
   $10 = HEAP32[$0 >> 2];
   HEAP32[$4 + 16 >> 2] = 0;
   HEAP32[$4 + 20 >> 2] = 0;
   HEAP32[$4 + 8 >> 2] = 0;
   HEAP32[$4 + 12 >> 2] = 0;
   $2 = sqlite3Fts3SelectDoctotal($10, $4 + 28 | 0);
   if ($2) {
    break label$1;
   }
   label$3: {
    $7 = HEAP32[$4 + 28 >> 2];
    $2 = sqlite3_column_blob($7, 0);
    label$4: {
     if (!$2) {
      break label$4;
     }
     $3 = sqlite3_column_bytes($7, 0) + $2 | 0;
     $2 = sqlite3Fts3GetVarintBounded($2, $3, $4 + 16 | 0) + $2 | 0;
     while (1) {
      if ($2 >>> 0 < $3 >>> 0) {
       $2 = sqlite3Fts3GetVarintBounded($2, $3, $4 + 8 | 0) + $2 | 0;
       continue;
      }
      break;
     }
     $3 = HEAP32[$4 + 20 >> 2];
     $5 = $3;
     $2 = HEAP32[$4 + 16 >> 2];
     $6 = $2;
     if (!($5 | $2)) {
      break label$4;
     }
     $3 = HEAP32[$4 + 8 >> 2];
     $8 = $3;
     $2 = HEAP32[$4 + 12 >> 2];
     $9 = $2;
     $3 = $8;
     if ($2 | $3) {
      break label$3;
     }
    }
    sqlite3_reset($7);
    $2 = 267;
    break label$1;
   }
   $2 = $0;
   HEAP32[$2 + 64 >> 2] = $6;
   $3 = $5;
   HEAP32[$2 + 68 >> 2] = $3;
   $3 = $9;
   $2 = $5;
   $2 = __wasm_i64_sdiv($8, $3, $6, $2);
   $8 = $2;
   $3 = i64toi32_i32$HIGH_BITS;
   $9 = $3;
   $2 = $10;
   $3 = HEAP32[$2 + 244 >> 2];
   $2 = $3 >> 31;
   $6 = $3;
   $5 = $2;
   $2 = $9;
   $3 = $5;
   $5 = $2 + $3 | 0;
   $2 = $8;
   $2 = $6 + $2 | 0;
   $5 = $6 >>> 0 > $2 >>> 0 ? $5 + 1 | 0 : $5;
   $2 = __wasm_i64_sdiv($2, $5, $6, $3);
   HEAP32[$0 + 60 >> 2] = $2;
   $2 = sqlite3_reset($7);
   $3 = HEAP32[$0 + 60 >> 2];
  }
  HEAP32[$1 >> 2] = $3;
 }
 __stack_pointer = $4 + 32 | 0;
 return $2;
}

function windowCodeRangeTest($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = HEAP32[$0 >> 2];
 $6 = sqlite3GetVdbe($7);
 $12 = HEAP32[HEAP32[$0 + 4 >> 2] + 12 >> 2];
 $8 = sqlite3GetTempReg($7);
 $9 = sqlite3GetTempReg($7);
 $10 = HEAP32[$7 + 44 >> 2] + 1 | 0;
 HEAP32[$7 + 44 >> 2] = $10;
 $11 = sqlite3VdbeMakeLabel($7);
 windowReadPeerValues($0, $2, $8);
 windowReadPeerValues($0, $4, $9);
 $4 = HEAPU8[$12 + 16 | 0];
 $2 = $4 & 1;
 $0 = $2 ? ($1 | 0) == 57 ? 55 : ($1 | 0) == 54 ? 56 : 57 : $1;
 label$1: {
  if (!($4 & 2)) {
   break label$1;
  }
  $1 = sqlite3VdbeAddOp1($6, 51, $8);
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $4 = $0 - 54 | 0;
      switch ($4 | 0) {
      case 1:
       break label$3;

      case 0:
       break label$4;

      case 3:
       break label$5;

      default:
       break label$2;
      }
     }
     sqlite3VdbeAddOp2($6, 8, 0, $5);
     break label$2;
    }
    sqlite3VdbeAddOp2($6, 51, $9, $5);
    break label$2;
   }
   sqlite3VdbeAddOp2($6, 50, $9, $5);
  }
  sqlite3VdbeAddOp2($6, 8, 0, $11);
  sqlite3VdbeJumpHere($6, $1);
  sqlite3VdbeAddOp2($6, 50, $9, $5);
  label$6: {
   switch ($4 | 0) {
   case 0:
   case 3:
    break label$6;

   default:
    break label$1;
   }
  }
  sqlite3VdbeChangeP2($6, -1, $11);
 }
 sqlite3VdbeAddOp4($6, 117, 0, $10, 0, 29623, -1);
 $1 = sqlite3VdbeAddOp3($6, 57, $10, 0, $8);
 if ((($2 ? ($0 | 0) == 55 : ($0 | 0) == 57) | 0) == 1) {
  sqlite3VdbeAddOp3($6, $0, $9, $5, $8);
 }
 sqlite3VdbeAddOp3($6, $2 ? 107 : 106, $3, $8, $8);
 sqlite3VdbeJumpHere($6, $1);
 sqlite3VdbeAddOp3($6, $0, $9, $5, $8);
 sqlite3VdbeAppendP4($6, sqlite3ExprNNCollSeq($7, HEAP32[$12 + 8 >> 2]), -2);
 sqlite3VdbeChangeP5($6, 128);
 sqlite3VdbeResolveLabel($6, $11);
 sqlite3ReleaseTempReg($7, $8);
 sqlite3ReleaseTempReg($7, $9);
}

function sqlite3Fts3Init($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 + 4 >> 2] = 0;
 sqlite3Fts3UnicodeTokenizer($3 + 4 | 0);
 $1 = sqlite3Fts3InitAux($0);
 label$1: {
  if ($1) {
   break label$1;
  }
  sqlite3Fts3SimpleTokenizerModule($3 + 12 | 0);
  sqlite3Fts3PorterTokenizerModule($3 + 8 | 0);
  $2 = sqlite3_malloc(24);
  if (!$2) {
   $1 = 7;
   break label$1;
  }
  sqlite3Fts3HashInit($2);
  HEAP32[$2 + 20 >> 2] = 0;
  $1 = 7;
  label$3: {
   if (sqlite3Fts3HashInsert($2, 13357, 7, HEAP32[$3 + 12 >> 2])) {
    break label$3;
   }
   if (sqlite3Fts3HashInsert($2, 8704, 7, HEAP32[$3 + 8 >> 2])) {
    break label$3;
   }
   if (sqlite3Fts3HashInsert($2, 23183, 10, HEAP32[$3 + 4 >> 2])) {
    break label$3;
   }
   $1 = sqlite3Fts3InitHashTable($0, $2);
   if ($1) {
    break label$3;
   }
   $1 = sqlite3_overload_function($0, 3164, -1);
   if ($1) {
    break label$3;
   }
   $1 = sqlite3_overload_function($0, 3889, 1);
   if ($1) {
    break label$3;
   }
   $1 = sqlite3_overload_function($0, 9629, 1);
   if ($1) {
    break label$3;
   }
   $1 = sqlite3_overload_function($0, 9629, 2);
   if ($1) {
    break label$3;
   }
   $1 = sqlite3_overload_function($0, 12206, 1);
   if ($1) {
    break label$3;
   }
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
   $1 = sqlite3_create_module_v2($0, 22880, 51408, $2, 94);
   if ($1) {
    break label$1;
   }
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
   $1 = sqlite3_create_module_v2($0, 22751, 51408, $2, 94);
   if ($1) {
    break label$1;
   }
   HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + 1;
   $1 = sqlite3Fts3InitTok($0, $2);
   break label$1;
  }
  sqlite3Fts3HashClear($2);
  sqlite3_free($2);
 }
 __stack_pointer = $3 + 16 | 0;
 return $1 | 0;
}

function vdbeMergeEngineStep($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[HEAP32[$0 + 8 >> 2] + 4 >> 2];
 $4 = vdbePmaReaderNext(HEAP32[$0 + 12 >> 2] + Math_imul($2, 56) | 0);
 if (!$4) {
  HEAP32[$6 + 12 >> 2] = 0;
  $4 = HEAP32[$0 >> 2] + $2 | 0;
  $3 = HEAP32[$0 + 12 >> 2];
  $5 = $3 + Math_imul($2 | 1, 56) | 0;
  $2 = Math_imul($2 & 65534, 56) + $3 | 0;
  while (1) {
   label$3: {
    $8 = $4;
    $4 = ($4 | 0) / 2 | 0;
    if (($8 | 0) < 2) {
     break label$3;
    }
    label$4: {
     if (!HEAP32[$2 + 24 >> 2]) {
      break label$4;
     }
     label$5: {
      label$6: {
       if (!HEAP32[$5 + 24 >> 2]) {
        break label$6;
       }
       $3 = FUNCTION_TABLE[HEAP32[$7 + 32 >> 2]]($7, $6 + 12 | 0, HEAP32[$2 + 32 >> 2], HEAP32[$2 + 20 >> 2], HEAP32[$5 + 32 >> 2], HEAP32[$5 + 20 >> 2]) | 0;
       if (($3 | 0) < 0) {
        break label$6;
       }
       if ($2 >>> 0 >= $5 >>> 0 | $3) {
        break label$5;
       }
      }
      $5 = HEAP32[$0 + 8 >> 2];
      $3 = HEAP32[$0 + 12 >> 2];
      HEAP32[$5 + ($4 << 2) >> 2] = ($2 - $3 | 0) / 56;
      $5 = HEAP32[(($4 ^ 1) << 2) + $5 >> 2];
      HEAP32[$6 + 12 >> 2] = 0;
      $5 = Math_imul($5, 56) + $3 | 0;
      continue;
     }
     if (!HEAP32[$2 + 24 >> 2]) {
      break label$4;
     }
     HEAP32[$6 + 12 >> 2] = 0;
    }
    $2 = HEAP32[$0 + 8 >> 2];
    $3 = HEAP32[$0 + 12 >> 2];
    HEAP32[$2 + ($4 << 2) >> 2] = ($5 - $3 | 0) / 56;
    $2 = Math_imul(HEAP32[(($4 ^ 1) << 2) + $2 >> 2], 56) + $3 | 0;
    continue;
   }
   break;
  }
  HEAP32[$1 >> 2] = !HEAP32[(Math_imul(HEAP32[HEAP32[$0 + 8 >> 2] + 4 >> 2], 56) + $3 | 0) + 24 >> 2];
  $4 = HEAPU8[HEAP32[$7 + 12 >> 2] + 23 | 0];
 }
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function sqlite3SelectAddColumnTypeAndCollation($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $8 = __stack_pointer - 32 | 0;
 __stack_pointer = $8;
 $9 = HEAP32[$0 >> 2];
 if (!HEAPU8[$9 + 87 | 0]) {
  $4 = $8;
  HEAP32[$4 + 24 >> 2] = 0;
  HEAP32[$4 + 28 >> 2] = 0;
  HEAP32[$4 + 16 >> 2] = 0;
  HEAP32[$4 + 20 >> 2] = 0;
  HEAP32[$4 + 8 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  HEAP32[$4 >> 2] = 0;
  HEAP32[$4 + 4 >> 2] = 0;
  HEAP32[$4 + 4 >> 2] = HEAP32[$2 + 32 >> 2];
  $14 = HEAP32[$2 + 28 >> 2] + 8 | 0;
  $2 = HEAP32[$1 + 4 >> 2];
  while (1) {
   if (HEAP16[$1 + 34 >> 1] > ($10 | 0)) {
    HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | HEAPU16[$2 + 10 >> 1] & 98;
    $11 = HEAP32[($10 << 4) + $14 >> 2];
    $6 = columnTypeImpl($8, $11);
    $5 = sqlite3ExprAffinity($11);
    HEAP8[$2 + 5 | 0] = $5;
    if ($6) {
     $5 = HEAP32[$2 >> 2];
     $13 = sqlite3Strlen30($6);
     $12 = sqlite3Strlen30($5);
     $7 = $13 + $12 | 0;
     $4 = 0;
     $4 = $7 >>> 0 < $12 >>> 0 ? 1 : $4;
     $15 = $7;
     $7 = $4;
     $4 = $15 + 2 | 0;
     $7 = $4 >>> 0 < 2 ? $7 + 1 | 0 : $7;
     $5 = sqlite3DbReallocOrFree($9, $5, $4, $7);
     HEAP32[$2 >> 2] = $5;
     label$5: {
      if ($5) {
       __memcpy(($5 + $12 | 0) + 1 | 0, $6, $13 + 1 | 0);
       $6 = HEAPU16[$2 + 10 >> 1] | 4;
       break label$5;
      }
      $6 = HEAPU16[$2 + 10 >> 1] & -517;
     }
     HEAP16[$2 + 10 >> 1] = $6;
     $5 = HEAPU8[$2 + 5 | 0];
    }
    if ($5 << 24 >> 24 <= 64) {
     HEAP8[$2 + 5 | 0] = $3;
    }
    $6 = sqlite3ExprCollSeq($0, $11);
    if ($6) {
     sqlite3ColumnSetColl($9, $2, HEAP32[$6 >> 2]);
    }
    $2 = $2 + 12 | 0;
    $10 = $10 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP16[$1 + 40 >> 1] = 1;
 }
 __stack_pointer = $8 + 32 | 0;
}

function walIndexReadHdr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = walIndexPage($0, 0, $3 + 12 | 0);
 label$1: {
  if ($2) {
   if (($2 | 0) != 1288) {
    break label$1;
   }
   HEAP8[$0 + 43 | 0] = 2;
   HEAP8[$0 + 50 | 0] = 1;
   HEAP32[$1 >> 2] = 1;
  }
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      if (HEAP32[$3 + 12 >> 2]) {
       if (!walIndexTryHdr($0, $1)) {
        break label$6;
       }
      }
      if (!(HEAPU8[$0 + 50 | 0] | !(HEAPU8[$0 + 46 | 0] & 2))) {
       $2 = walLockShared($0, 0);
       if ($2) {
        break label$5;
       }
       walUnlockShared($0, 0);
       $2 = 264;
       if (!HEAPU8[$0 + 50 | 0]) {
        break label$1;
       }
       break label$4;
      }
      $5 = HEAPU8[$0 + 44 | 0];
      if (!$5) {
       $2 = walLockExclusive($0, 0, 1);
       if ($2) {
        break label$5;
       }
      }
      HEAP8[$0 + 44 | 0] = 1;
      $2 = walIndexPage($0, 0, $3 + 12 | 0);
      $4 = 0;
      label$10: {
       if ($2) {
        break label$10;
       }
       if (!walIndexTryHdr($0, $1)) {
        $2 = 0;
        $4 = 1;
        break label$10;
       }
       $2 = walIndexRecover($0);
       HEAP32[$1 >> 2] = 1;
       $4 = 0;
      }
      if (!$5) {
       HEAP8[$0 + 44 | 0] = 0;
       walUnlockExclusive($0, 0, 1);
      }
      if (!$4) {
       break label$5;
      }
     }
     if (HEAP32[$0 + 52 >> 2] == 3007e3) {
      break label$5;
     }
     $2 = sqlite3CantopenError(64116);
    }
    if (!HEAPU8[$0 + 50 | 0]) {
     break label$1;
    }
    if ($2) {
     break label$4;
    }
    $2 = 0;
    break label$3;
   }
   walIndexClose($0, 0);
   HEAP8[$0 + 50 | 0] = 0;
   $2 = ($2 | 0) == 522 ? -1 : $2;
  }
  HEAP8[$0 + 43 | 0] = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function columnTypeImpl($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $3 = HEAPU8[$1 | 0];
 label$1: {
  if (($3 | 0) != 138) {
   if (($3 | 0) != 167) {
    break label$1;
   }
   $5 = HEAP16[$1 + 32 >> 1];
   while (1) {
    $2 = 0;
    label$4: {
     while (1) {
      if (!$0 | $2) {
       break label$4;
      }
      $2 = 0;
      $8 = HEAP32[$0 + 4 >> 2];
      $3 = HEAP32[$8 >> 2];
      $3 = ($3 | 0) > 0 ? $3 : 0;
      label$6: {
       while (1) {
        if (($2 | 0) == ($3 | 0)) {
         break label$6;
        }
        $6 = ($2 << 6) + $8 | 0;
        if (HEAP32[$6 + 48 >> 2] != HEAP32[$1 + 28 >> 2]) {
         $2 = $2 + 1 | 0;
         continue;
        }
        break;
       }
       $7 = HEAP32[$6 + 28 >> 2];
       $2 = HEAP32[$6 + 24 >> 2];
       continue;
      }
      break;
     }
     $0 = HEAP32[$0 + 12 >> 2];
     continue;
    }
    break;
   }
   if (!$2) {
    $2 = 0;
    break label$1;
   }
   if ($7) {
    $2 = 0;
    if (($5 | 0) < 0) {
     break label$1;
    }
    $3 = HEAP32[$7 + 28 >> 2];
    if (HEAP32[$3 >> 2] <= ($5 | 0)) {
     break label$1;
    }
    $2 = HEAP32[(($5 << 4) + $3 | 0) + 8 >> 2];
    HEAP32[$4 + 4 >> 2] = HEAP32[$7 + 32 >> 2];
    HEAP32[$4 + 12 >> 2] = $0;
    HEAP32[$4 >> 2] = HEAP32[$0 >> 2];
    $2 = columnTypeImpl($4, $2);
    break label$1;
   }
   if (($5 | 0) < 0) {
    $2 = 19010;
    break label$1;
   }
   $2 = sqlite3ColumnType(HEAP32[$2 + 4 >> 2] + Math_imul($5, 12) | 0, 0);
   break label$1;
  }
  $2 = HEAP32[$1 + 20 >> 2];
  $3 = HEAP32[HEAP32[$2 + 28 >> 2] + 8 >> 2];
  HEAP32[$4 + 4 >> 2] = HEAP32[$2 + 32 >> 2];
  HEAP32[$4 + 12 >> 2] = $0;
  HEAP32[$4 >> 2] = HEAP32[$0 >> 2];
  $2 = columnTypeImpl($4, $3);
 }
 __stack_pointer = $4 + 32 | 0;
 return $2;
}

function sqlite3Fts3MsrIncrNext($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 label$1: {
  label$2: {
   $9 = HEAP32[$1 + 8 >> 2];
   if (!$9) {
    break label$2;
   }
   $12 = HEAPU8[$0 + 239 | 0] ? 98 : 99;
   $8 = HEAP32[$1 >> 2];
   $6 = $8;
   while (1) {
    if (!HEAP32[HEAP32[$6 >> 2] + 80 >> 2]) {
     break label$2;
    }
    $5 = HEAP32[$8 >> 2];
    $10 = HEAP32[$5 + 88 >> 2];
    $11 = HEAP32[$5 + 92 >> 2];
    $6 = 1;
    $5 = fts3SegReaderNextDocid($0, $5, $7 + 12 | 0, $7 + 8 | 0);
    label$4: {
     while (1) {
      if (!(($6 | 0) >= ($9 | 0) | $5)) {
       $5 = HEAP32[($6 << 2) + $8 >> 2];
       if (!HEAP32[$5 + 80 >> 2] | (($10 | 0) != HEAP32[$5 + 88 >> 2] | HEAP32[$5 + 92 >> 2] != ($11 | 0))) {
        break label$4;
       }
       $6 = $6 + 1 | 0;
       $5 = fts3SegReaderNextDocid($0, $5, 0, 0);
       continue;
      }
      break;
     }
     if ($5) {
      break label$1;
     }
    }
    fts3SegReaderSort(HEAP32[$1 >> 2], $9, $6, $12);
    $6 = HEAP32[$7 + 8 >> 2];
    if (!(!HEAP32[HEAP32[$8 >> 2] + 56 >> 2] | ($6 | 0) <= 0)) {
     $5 = fts3MsrBufferData($1, HEAP32[$7 + 12 >> 2], $6 + 1 | 0);
     if ($5) {
      break label$1;
     }
     HEAP32[$7 + 12 >> 2] = HEAP32[$1 + 16 >> 2];
    }
    $5 = HEAP32[$1 + 24 >> 2];
    if (($5 | 0) >= 0) {
     fts3ColumnFilter($5, 1, $7 + 12 | 0, $7 + 8 | 0);
     $6 = HEAP32[$7 + 8 >> 2];
    }
    if (($6 | 0) > 0) {
     HEAP32[$3 >> 2] = HEAP32[$7 + 12 >> 2];
     HEAP32[$2 >> 2] = $10;
     HEAP32[$2 + 4 >> 2] = $11;
     HEAP32[$4 >> 2] = $6;
     $5 = 0;
     break label$1;
    } else {
     $6 = HEAP32[$1 >> 2];
     continue;
    }
   }
  }
  $5 = 0;
  HEAP32[$3 >> 2] = 0;
 }
 __stack_pointer = $7 + 16 | 0;
 return $5;
}

function fts3UpdateDocTotals($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 label$1: {
  if (HEAP32[$0 >> 2]) {
   break label$1;
  }
  $9 = HEAP32[$1 + 24 >> 2] + 2 | 0;
  $6 = $9 >> 31;
  $10 = __wasm_i64_mul($9, $6, 14, 0);
  $6 = i64toi32_i32$HIGH_BITS;
  $7 = sqlite3_malloc64($10, $6);
  if (!$7) {
   HEAP32[$0 >> 2] = 7;
   break label$1;
  }
  $5 = fts3SqlStmt($1, 22, $8 + 8 | 0, 0);
  if ($5) {
   sqlite3_free($7);
   HEAP32[$0 >> 2] = $5;
   break label$1;
  }
  $5 = HEAP32[$8 + 8 >> 2];
  sqlite3_bind_int($5, 1, 0);
  label$4: {
   if ((sqlite3_step($5) | 0) == 100) {
    fts3DecodeIntArray($9, $7, sqlite3_column_blob($5, 0), sqlite3_column_bytes($5, 0));
    break label$4;
   }
   memset($7, 0, $9 << 2);
  }
  $5 = sqlite3_reset($5);
  if ($5) {
   sqlite3_free($7);
   HEAP32[$0 >> 2] = $5;
   break label$1;
  }
  $11 = ($9 << 2) + $7 | 0;
  $5 = HEAP32[$7 >> 2];
  $6 = $5 + $4 | 0;
  HEAP32[$7 >> 2] = ($4 | 0) < 0 ? 0 - $4 >>> 0 > $5 >>> 0 ? 0 : $6 : $6;
  $4 = 0;
  while (1) {
   if (($4 | 0) <= HEAP32[$1 + 24 >> 2]) {
    $5 = $4 << 2;
    $4 = $4 + 1 | 0;
    $6 = ($4 << 2) + $7 | 0;
    $10 = $6;
    $6 = HEAP32[$2 + $5 >> 2] + HEAP32[$6 >> 2] | 0;
    $5 = $6 - HEAP32[$3 + $5 >> 2] | 0;
    HEAP32[$10 >> 2] = $5 >>> 0 > $6 >>> 0 ? 0 : $5;
    continue;
   }
   break;
  }
  fts3EncodeIntArray($9, $7, $11, $8 + 12 | 0);
  $4 = fts3SqlStmt($1, 23, $8 + 8 | 0, 0);
  if ($4) {
   sqlite3_free($7);
   HEAP32[$0 >> 2] = $4;
   break label$1;
  }
  $4 = HEAP32[$8 + 8 >> 2];
  sqlite3_bind_int($4, 1, 0);
  sqlite3_bind_blob($4, 2, $11, HEAP32[$8 + 12 >> 2], 0);
  sqlite3_step($4);
  HEAP32[$0 >> 2] = sqlite3_reset($4);
  sqlite3_bind_null($4, 2);
  sqlite3_free($7);
 }
 __stack_pointer = $8 + 16 | 0;
}

function pcache1FetchStage2($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   if (($2 | 0) != 1) {
    break label$2;
   }
   $5 = HEAP32[$0 + 48 >> 2] - HEAP32[$0 + 44 >> 2] | 0;
   if ($5 >>> 0 >= HEAPU32[$4 + 12 >> 2] | HEAPU32[$0 + 32 >> 2] <= $5 >>> 0) {
    break label$1;
   }
   if (!pcache1UnderMemoryPressure($0)) {
    break label$2;
   }
   if (HEAPU32[$0 + 44 >> 2] < $5 >>> 0) {
    break label$1;
   }
  }
  if (HEAPU32[$0 + 48 >> 2] >= HEAPU32[$0 + 52 >> 2]) {
   pcache1ResizeHash($0);
  }
  label$4: {
   label$5: {
    label$6: {
     if (!HEAP32[$0 + 20 >> 2]) {
      break label$6;
     }
     $3 = HEAP32[$4 + 48 >> 2];
     if (HEAPU16[$3 + 14 >> 1]) {
      break label$6;
     }
     if (HEAPU32[$0 + 28 >> 2] > HEAP32[$0 + 48 >> 2] + 1 >>> 0) {
      if (!pcache1UnderMemoryPressure($0)) {
       break label$6;
      }
      $3 = HEAP32[$4 + 48 >> 2];
     }
     pcache1RemoveFromHash($3, 0);
     $3 = pcache1PinPage($3);
     $5 = HEAP32[$3 + 20 >> 2];
     if (HEAP32[$5 + 16 >> 2] == HEAP32[$0 + 16 >> 2]) {
      break label$5;
     }
     pcache1FreePage($3);
    }
    $3 = pcache1AllocPage($0, ($2 | 0) == 1);
    if ($3) {
     break label$4;
    }
    return 0;
   }
   HEAP32[$4 + 16 >> 2] = HEAP32[$4 + 16 >> 2] + (HEAP32[$0 + 20 >> 2] - HEAP32[$5 + 20 >> 2] | 0);
  }
  HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] + 1;
  $2 = HEAP32[$0 + 52 >> 2];
  HEAP32[$3 + 8 >> 2] = $1;
  $2 = ($1 >>> 0) % ($2 >>> 0) << 2;
  $4 = HEAP32[$2 + HEAP32[$0 + 56 >> 2] >> 2];
  HEAP32[$3 + 24 >> 2] = 0;
  HEAP32[$3 + 20 >> 2] = $0;
  HEAP32[$3 + 16 >> 2] = $4;
  HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = 0;
  HEAP32[HEAP32[$0 + 56 >> 2] + $2 >> 2] = $3;
  if (HEAPU32[$0 + 36 >> 2] >= $1 >>> 0) {
   break label$1;
  }
  HEAP32[$0 + 36 >> 2] = $1;
 }
 return $3;
}

function sqlite3CreateFunc($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0;
 label$1: {
  if (!(!$1 | ($7 ? $5 : 0) | ((!$7 | 0) == (($6 | 0) != 0 | 0) | $2 - 128 >>> 0 < 4294967167 | !$8 ^ !$9))) {
   if ((sqlite3Strlen30($1) | 0) < 256) {
    break label$1;
   }
  }
  return sqlite3MisuseError(172505);
 }
 $12 = $3 & 3672064;
 label$3: {
  label$4: {
   label$5: {
    label$6: {
     label$7: {
      $3 = $3 & 7;
      switch ($3 - 1 | 0) {
      case 0:
      case 1:
      case 2:
       break label$4;

      case 4:
       break label$6;

      case 3:
       break label$7;

      default:
       break label$5;
      }
     }
     $3 = 2;
     break label$4;
    }
    $11 = sqlite3CreateFunc($0, $1, $2, $12 | 1, $4, $5, $6, $7, $8, $9, $10);
    if ($11) {
     break label$3;
    }
    $11 = sqlite3CreateFunc($0, $1, $2, $12 | 2, $4, $5, $6, $7, $8, $9, $10);
    if ($11) {
     break label$3;
    }
    $3 = 3;
    break label$4;
   }
   $3 = 1;
  }
  $11 = 0;
  $13 = sqlite3FindFunction($0, $1, $2, $3, 0);
  label$8: {
   if (!(!$13 | (HEAP32[$13 + 4 >> 2] & 3) != ($3 | 0) | HEAP8[$13 | 0] != ($2 | 0))) {
    if (HEAP32[$0 + 184 >> 2]) {
     sqlite3ErrorWithMsg($0, 5, 3758, 0);
     return 5;
    }
    sqlite3ExpirePreparedStatements($0, 0);
    break label$8;
   }
   if (!($5 | $7)) {
    break label$3;
   }
  }
  $1 = sqlite3FindFunction($0, $1, $2, $3, 1);
  if (!$1) {
   return 7;
  }
  functionDestroy($0, $1);
  if ($10) {
   HEAP32[$10 >> 2] = HEAP32[$10 >> 2] + 1;
  }
  HEAP32[$1 + 36 >> 2] = $10;
  HEAP32[$1 + 28 >> 2] = $9;
  HEAP32[$1 + 24 >> 2] = $8;
  HEAP32[$1 + 20 >> 2] = $7;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP8[$1 | 0] = $2;
  HEAP32[$1 + 16 >> 2] = $5 ? $5 : $6;
  HEAP32[$1 + 4 >> 2] = (HEAP32[$1 + 4 >> 2] & 3 | $12) ^ 2097152;
 }
 return $11;
}

function fts3auxBestIndexMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  if (HEAP32[$1 + 8 >> 2] != 1) {
   break label$1;
  }
  $0 = HEAP32[$1 + 12 >> 2];
  if (HEAP32[$0 >> 2] | HEAPU8[$0 + 4 | 0]) {
   break label$1;
  }
  HEAP32[$1 + 32 >> 2] = 1;
 }
 $0 = 0;
 $2 = HEAP32[$1 >> 2];
 $9 = ($2 | 0) > 0 ? $2 : 0;
 $6 = -1;
 $7 = -1;
 $5 = -1;
 $8 = -1;
 while (1) {
  if (($0 | 0) != ($9 | 0)) {
   $2 = HEAP32[$1 + 4 >> 2] + Math_imul($0, 12) | 0;
   if (HEAPU8[$2 + 5 | 0]) {
    $3 = HEAPU8[$2 + 4 | 0];
    $2 = HEAP32[$2 >> 2];
    if (!$2) {
     $6 = ($3 | 0) == 32 ? $0 : ($3 | 0) == 4 ? $0 : $6;
     $8 = ($3 | 0) == 2 ? $0 : $8;
     $7 = ($3 | 0) == 8 ? $0 : ($3 | 0) == 16 ? $0 : $7;
    }
    $5 = ($2 | 0) == 4 ? ($3 | 0) == 2 ? $0 : $5 : $5;
   }
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 label$6: {
  if (($8 | 0) >= 0) {
   HEAP32[$1 + 20 >> 2] = 1;
   HEAP32[HEAP32[$1 + 16 >> 2] + ($8 << 3) >> 2] = 1;
   HEAP32[$1 + 40 >> 2] = 0;
   HEAP32[$1 + 44 >> 2] = 1075052544;
   $4 = 5;
   $0 = 2;
   break label$6;
  }
  HEAP32[$1 + 40 >> 2] = 0;
  HEAP32[$1 + 44 >> 2] = 1087604736;
  HEAP32[$1 + 20 >> 2] = 0;
  label$8: {
   if (($6 | 0) < 0) {
    $4 = 2e4;
    $0 = 1;
    $2 = 4;
    break label$8;
   }
   HEAP32[$1 + 20 >> 2] = 2;
   HEAP32[HEAP32[$1 + 16 >> 2] + ($6 << 3) >> 2] = 1;
   HEAP32[$1 + 40 >> 2] = 0;
   HEAP32[$1 + 44 >> 2] = 1086556160;
   $4 = 1e4;
   $0 = 2;
   $2 = 6;
  }
  if (($7 | 0) < 0) {
   break label$6;
  }
  HEAP32[$1 + 20 >> 2] = $2;
  HEAP32[HEAP32[$1 + 16 >> 2] + ($7 << 3) >> 2] = $0;
  $4 = $4 * .5;
  HEAPF64[$1 + 40 >> 3] = $4;
  $0 = $0 + 1 | 0;
 }
 if (($5 | 0) >= 0) {
  HEAP32[HEAP32[$1 + 16 >> 2] + ($5 << 3) >> 2] = $0;
  HEAPF64[$1 + 40 >> 3] = $4 + -1;
 }
 return 0;
}

function sqlite3AlterBeginAddColumn($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $3 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$3 + 87 | 0]) {
   break label$1;
  }
  $4 = sqlite3LocateTableItem($0, 0, $1 + 8 | 0);
  if (!$4) {
   break label$1;
  }
  label$2: {
   switch (HEAPU8[$4 + 43 | 0] - 1 | 0) {
   case 0:
    sqlite3ErrorMsg($0, 15051, 0);
    break label$1;

   case 1:
    sqlite3ErrorMsg($0, 1780, 0);
    break label$1;

   default:
    break label$2;
   }
  }
  if (isAlterableTable($0, $4)) {
   break label$1;
  }
  sqlite3MayAbort($0);
  $8 = sqlite3SchemaToIndex($3, HEAP32[$4 + 60 >> 2]);
  $2 = sqlite3DbMallocZero($3, 64, 0);
  if (!$2) {
   break label$1;
  }
  HEAP32[$0 + 236 >> 2] = $2;
  HEAP32[$2 + 24 >> 2] = 1;
  $0 = HEAP16[$4 + 34 >> 1];
  HEAP16[$2 + 34 >> 1] = $0;
  HEAP32[$2 + 4 >> 2] = sqlite3DbMallocZero($3, Math_imul(($0 - 1 | 0) / 8 | 0, 96) + 96 | 0, 0);
  HEAP32[$6 >> 2] = HEAP32[$4 >> 2];
  $0 = sqlite3MPrintf($3, 5787, $6);
  HEAP32[$2 >> 2] = $0;
  $5 = HEAP32[$2 + 4 >> 2];
  if (!$5 | !$0) {
   break label$1;
  }
  __memcpy($5, HEAP32[$4 + 4 >> 2], Math_imul(HEAP16[$2 + 34 >> 1], 12));
  $0 = 0;
  while (1) {
   if (($0 | 0) < HEAP16[$2 + 34 >> 1]) {
    $5 = HEAP32[$2 + 4 >> 2] + Math_imul($0, 12) | 0;
    $7 = sqlite3DbStrDup($3, HEAP32[$5 >> 2]);
    HEAP32[$5 >> 2] = $7;
    HEAP8[$5 + 7 | 0] = sqlite3StrIHash($7);
    $0 = $0 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$2 + 52 >> 2] = sqlite3ExprListDup($3, HEAP32[$4 + 52 >> 2], 0);
  HEAP32[$2 + 60 >> 2] = HEAP32[(HEAP32[$3 + 16 >> 2] + ($8 << 4) | 0) + 12 >> 2];
  $0 = HEAP32[$4 + 44 >> 2];
  HEAP32[$2 + 24 >> 2] = 1;
  HEAP32[$2 + 44 >> 2] = $0;
 }
 sqlite3SrcListDelete($3, $1);
 __stack_pointer = $6 + 16 | 0;
}

function sqlite3FindFunction($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $9 = sqlite3Strlen30($1);
 $11 = $0 + 412 | 0;
 $5 = sqlite3HashFind($11, $1);
 while (1) {
  if ($5) {
   $7 = matchQuality($5, $2, $3);
   $10 = $7;
   $7 = ($8 | 0) < ($7 | 0);
   $8 = $7 ? $10 : $8;
   $6 = $7 ? $5 : $6;
   $5 = HEAP32[$5 + 12 >> 2];
   continue;
  }
  break;
 }
 label$3: {
  label$4: {
   label$5: {
    label$6: {
     if ($4) {
      break label$6;
     }
     if ($6) {
      $5 = 0;
      if (!(HEAPU8[$0 + 24 | 0] & 2)) {
       break label$5;
      }
     }
     $8 = 0;
     $5 = sqlite3FunctionSearch((HEAPU8[HEAPU8[$1 | 0] + 29904 | 0] + $9 | 0) % 23 | 0, $1);
     while (1) {
      if (!$5) {
       break label$6;
      }
      $7 = matchQuality($5, $2, $3);
      $10 = $7;
      $7 = ($8 | 0) < ($7 | 0);
      $8 = $7 ? $10 : $8;
      $6 = $7 ? $5 : $6;
      $5 = HEAP32[$5 + 12 >> 2];
      continue;
     }
    }
    if (!(!$4 | ($8 | 0) > 5)) {
     $6 = sqlite3DbMallocZero($0, $9 + 41 | 0, 0);
     if (!$6) {
      break label$4;
     }
     HEAP32[$6 + 4 >> 2] = $3;
     HEAP8[$6 | 0] = $2;
     $5 = $6 + 40 | 0;
     HEAP32[$6 + 32 >> 2] = $5;
     __memcpy($5, $1, $9 + 1 | 0);
     while (1) {
      $8 = HEAPU8[$5 | 0];
      if ($8) {
       HEAP8[$5 | 0] = HEAPU8[$8 + 29904 | 0];
       $5 = $5 + 1 | 0;
       continue;
      }
      break;
     }
     $5 = sqlite3HashInsert($11, HEAP32[$6 + 32 >> 2], $6);
     if (($6 | 0) == ($5 | 0)) {
      sqlite3DbFree($0, $6);
      sqlite3OomFault($0);
      break label$4;
     }
     HEAP32[$6 + 12 >> 2] = $5;
     return $6;
    }
    if (!$6) {
     break label$4;
    }
    $5 = ($4 | 0) != 0;
   }
   if ($5 | HEAP32[$6 + 16 >> 2]) {
    break label$3;
   }
  }
  $6 = 0;
 }
 return $6;
}

function insertCell($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 12 >> 2] = 0;
 label$1: {
  label$2: {
   if (!HEAPU8[$0 + 12 | 0]) {
    $7 = $3 + 2 | 0;
    if (($7 | 0) <= HEAP32[$0 + 20 >> 2]) {
     break label$2;
    }
   }
   label$4: {
    if (!$4) {
     $4 = $2;
     break label$4;
    }
    __memcpy($4, $2, $3);
   }
   if ($5) {
    sqlite3Put4byte($4, $5);
   }
   $5 = HEAPU8[$0 + 12 | 0];
   HEAP8[$0 + 12 | 0] = $5 + 1;
   HEAP32[(($5 << 2) + $0 | 0) + 36 >> 2] = $4;
   HEAP16[(($5 << 1) + $0 | 0) + 28 >> 1] = $1;
   break label$1;
  }
  $4 = sqlite3PagerWrite(HEAP32[$0 + 72 >> 2]);
  if ($4) {
   HEAP32[$6 >> 2] = $4;
   break label$1;
  }
  $4 = HEAP32[$0 + 56 >> 2];
  $9 = allocateSpace($0, $3, $8 + 12 | 0);
  if ($9) {
   HEAP32[$6 >> 2] = $9;
   break label$1;
  }
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] - ($7 & 65535);
  $7 = HEAP32[$8 + 12 >> 2];
  label$9: {
   if ($5) {
    $9 = $4 + $7 | 0;
    __memcpy($9 + 4 | 0, $2 + 4 | 0, $3 - 4 | 0);
    sqlite3Put4byte($9, $5);
    break label$9;
   }
   __memcpy($4 + $7 | 0, $2, $3);
  }
  $5 = HEAP32[$0 + 64 >> 2] + ($1 << 1) | 0;
  memmove($5 + 2 | 0, $5, HEAPU16[$0 + 24 >> 1] - $1 << 1);
  $1 = $7 << 8 | ($7 & 65280) >>> 8;
  HEAP8[$5 | 0] = $1;
  HEAP8[$5 + 1 | 0] = $1 >>> 8;
  HEAP16[$0 + 24 >> 1] = HEAPU16[$0 + 24 >> 1] + 1;
  $3 = HEAPU8[$0 + 9 | 0] + $4 | 0;
  $5 = $3 + 4 | 0;
  $1 = $5;
  $5 = HEAPU8[$3 + 4 | 0] + 1 | 0;
  HEAP8[$1 | 0] = $5;
  if (($5 & 255) != ($5 | 0)) {
   $1 = HEAPU8[$0 + 9 | 0] + $4 | 0;
   $4 = $1 + 3 | 0;
   HEAP8[$4 | 0] = HEAPU8[$1 + 3 | 0] + 1;
  }
  if (!HEAPU8[HEAP32[$0 + 52 >> 2] + 17 | 0]) {
   break label$1;
  }
  ptrmapPutOvflPtr($0, $0, $2, $6);
 }
 __stack_pointer = $8 + 16 | 0;
}

function dropColumnFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $1 = __stack_pointer - 288 | 0;
 __stack_pointer = $1;
 $4 = sqlite3_context_db_handle($0);
 $3 = sqlite3_value_int(HEAP32[$2 >> 2]);
 $6 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
 $5 = sqlite3_value_int(HEAP32[$2 + 8 >> 2]);
 $2 = HEAP32[HEAP32[$4 + 16 >> 2] + ($3 << 4) >> 2];
 $8 = HEAP32[$4 + 360 >> 2];
 HEAP32[$4 + 360 >> 2] = 0;
 $2 = renameParseSql($1 + 16 | 0, $2, $4, $6, ($3 | 0) == 1);
 label$1: {
  if ($2) {
   break label$1;
  }
  label$2: {
   $2 = HEAP32[$1 + 252 >> 2];
   label$3: {
    if (!$2) {
     break label$3;
    }
    $3 = HEAP16[$2 + 34 >> 1];
    if (($3 | 0) == 1) {
     break label$3;
    }
    if (($3 | 0) > ($5 | 0)) {
     break label$2;
    }
   }
   $2 = sqlite3CorruptError(112167);
   break label$1;
  }
  $3 = Math_imul($5, 12);
  $7 = renameTokenFind($1 + 16 | 0, 0, HEAP32[$3 + HEAP32[$2 + 4 >> 2] >> 2]);
  label$4: {
   if ((HEAP16[$2 + 34 >> 1] - 1 | 0) > ($5 | 0)) {
    $5 = HEAP32[renameTokenFind($1 + 16 | 0, 0, HEAP32[(HEAP32[$2 + 4 >> 2] + $3 | 0) + 12 >> 2]) + 4 >> 2];
    $2 = HEAP32[$7 + 4 >> 2];
    break label$4;
   }
   $5 = HEAP32[$2 + 44 >> 2] + $6 | 0;
   $2 = HEAP32[$7 + 4 >> 2];
   while (1) {
    $3 = HEAPU8[$2 | 0];
    if (!$3 | ($3 | 0) == 44) {
     break label$4;
    }
    $2 = $2 - 1 | 0;
    HEAP32[$7 + 4 >> 2] = $2;
    continue;
   }
  }
  HEAP32[$1 + 8 >> 2] = $5;
  HEAP32[$1 + 4 >> 2] = $6;
  HEAP32[$1 >> 2] = $2 - $6;
  $2 = sqlite3MPrintf($4, 5760, $1);
  sqlite3_result_text($0, $2, -1, -1);
  sqlite3_free($2);
  $2 = 0;
 }
 renameParseCleanup($1 + 16 | 0);
 HEAP32[$4 + 360 >> 2] = $8;
 if ($2) {
  sqlite3_result_error_code($0, $2);
 }
 __stack_pointer = $1 + 288 | 0;
}

function memdbOpen($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 $8 = sqlite3Strlen30($1);
 label$1: {
  label$2: {
   if (!(($8 | 0) < 2 | HEAPU8[$1 | 0] != 47)) {
    $6 = HEAP32[17717];
    $7 = ($6 | 0) > 0 ? $6 : 0;
    $0 = HEAP32[17718];
    label$4: {
     while (1) {
      if (($5 | 0) == ($7 | 0)) {
       break label$4;
      }
      $6 = $5 << 2;
      $5 = $5 + 1 | 0;
      $6 = HEAP32[$6 + $0 >> 2];
      if (strcmp(HEAP32[$6 + 52 >> 2], $1)) {
       continue;
      }
      break;
     }
     HEAP32[$6 + 48 >> 2] = HEAP32[$6 + 48 >> 2] + 1;
     break label$2;
    }
    $6 = sqlite3Malloc($8 + 59 | 0, 0);
    $5 = 7;
    if (!$6) {
     break label$1;
    }
    $5 = sqlite3Realloc(HEAP32[17718], (HEAP32[17717] << 2) + 4 | 0, 0);
    if (!$5) {
     sqlite3_free($6);
     return 7;
    }
    $7 = HEAP32[17717];
    HEAP32[17717] = $7 + 1;
    HEAP32[($7 << 2) + $5 >> 2] = $6;
    HEAP32[17718] = $5;
    $5 = memset($6, 0, 56);
    HEAP32[$5 + 36 >> 2] = 3;
    $0 = HEAP32[16131];
    $9 = HEAP32[16130];
    $7 = $5 + 56 | 0;
    HEAP32[$5 + 52 >> 2] = $7;
    HEAP32[$5 + 16 >> 2] = $9;
    HEAP32[$5 + 20 >> 2] = $0;
    __memcpy($7, $1, $8 + 1 | 0);
    HEAP32[$5 + 48 >> 2] = 1;
    HEAP32[$5 + 28 >> 2] = 8;
    break label$2;
   }
   $6 = sqlite3Malloc(56, 0);
   if (!$6) {
    return 7;
   }
   $5 = memset($6, 0, 56);
   HEAP32[$5 + 36 >> 2] = 3;
   $9 = HEAP32[16131];
   $0 = HEAP32[16130];
   HEAP32[$5 + 16 >> 2] = $0;
   HEAP32[$5 + 20 >> 2] = $9;
  }
  HEAP32[$2 + 4 >> 2] = $6;
  if ($4) {
   HEAP32[$4 >> 2] = $3 | 128;
  }
  HEAP32[$2 >> 2] = 32100;
  $5 = 0;
 }
 return $5 | 0;
}

function pushDownWhereTerms($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 label$1: {
  if (HEAPU8[$3 + 36 | 0] & 80 | (!$2 | HEAP32[$1 + 4 >> 2] & 33562624)) {
   break label$1;
  }
  label$2: {
   if (HEAP32[$1 + 52 >> 2]) {
    $4 = $1;
    while (1) {
     if (!$4) {
      break label$2;
     }
     if (HEAP32[$4 + 68 >> 2]) {
      break label$1;
     }
     $4 = HEAP32[$4 + 52 >> 2];
     continue;
    }
   }
   $4 = HEAP32[$1 + 68 >> 2];
   if (!$4) {
    break label$2;
   }
   if (!HEAP32[$4 + 8 >> 2]) {
    break label$1;
   }
  }
  if (HEAP32[$1 + 60 >> 2]) {
   break label$1;
  }
  while (1) {
   if (HEAPU8[$2 | 0] == 44) {
    $7 = pushDownWhereTerms($0, $1, HEAP32[$2 + 16 >> 2], $3) + $7 | 0;
    $2 = HEAP32[$2 + 12 >> 2];
    continue;
   }
   break;
  }
  if (!sqlite3ExprIsTableConstraint($2, $3)) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 16777216;
  $8 = $7 + 1 | 0;
  while (1) {
   if (!$1) {
    $7 = $8;
    break label$1;
   }
   $6 = sqlite3ExprDup(HEAP32[$0 >> 2], $2, 0);
   unsetJoinExpr($6, -1, 1);
   HEAP32[$5 + 8 >> 2] = $0;
   $4 = HEAP32[$3 + 40 >> 2];
   HEAP32[$5 + 20 >> 2] = 0;
   HEAP32[$5 + 16 >> 2] = $4;
   HEAP32[$5 + 12 >> 2] = $4;
   HEAP32[$5 + 24 >> 2] = HEAP32[$1 + 28 >> 2];
   $6 = substExpr($5 + 8 | 0, $6);
   label$9: {
    if (!HEAP32[$1 + 68 >> 2]) {
     break label$9;
    }
    if (pushDownWindowCheck($0, $1, $6)) {
     break label$9;
    }
    sqlite3ExprDelete(HEAP32[$0 >> 2], $6);
    break label$1;
   }
   $4 = (HEAP32[$1 + 4 >> 2] & 8 ? 44 : 36) + $1 | 0;
   HEAP32[$4 >> 2] = sqlite3ExprAnd($0, HEAP32[$4 >> 2], $6);
   $1 = HEAP32[$1 + 52 >> 2];
   continue;
  }
 }
 __stack_pointer = $5 + 32 | 0;
 return $7;
}

function triggersReallyExist($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  label$2: {
   $8 = sqlite3TriggerList($0, $1);
   if (!$8) {
    break label$2;
   }
   label$3: {
    if (HEAPU8[HEAP32[$0 >> 2] + 34 | 0] & 4) {
     break label$3;
    }
    $6 = HEAP32[$1 + 56 >> 2];
    if (!$6) {
     break label$3;
    }
    if (($6 | 0) == ($8 | 0)) {
     break label$2;
    }
    $5 = $8;
    while (1) {
     $7 = $5;
     $5 = HEAP32[$5 + 32 >> 2];
     if (($5 | 0) != ($6 | 0) ? $5 : 0) {
      continue;
     }
     break;
    }
    HEAP32[$7 + 32 >> 2] = 0;
   }
   $11 = ($2 | 0) == 128 ? 19739 : 19746;
   $7 = 0;
   $12 = ($2 | 0) == 127;
   $13 = ($2 | 0) != 129;
   $5 = $8;
   while (1) {
    label$7: {
     label$8: {
      $6 = HEAPU8[$5 + 8 | 0];
      if (($6 | 0) != ($2 | 0)) {
       break label$8;
      }
      if (!checkColumnOverlap(HEAP32[$5 + 16 >> 2], $3)) {
       break label$8;
      }
      $7 = HEAPU8[$5 + 9 | 0] | $7;
      break label$7;
     }
     if (($6 | 0) == 150) {
      HEAP8[$5 + 8 | 0] = $2;
      $10 = HEAPU8[$1 + 43 | 0] != 1;
      $6 = $10 ? 2 : 1;
      if (!($12 | $10)) {
       HEAP32[$9 >> 2] = $11;
       sqlite3ErrorMsg($0, 5289, $9);
       $6 = 1;
      }
      HEAP8[$5 + 9 | 0] = $6;
      $7 = $7 | $6;
      break label$7;
     }
     if (HEAP32[$0 + 116 >> 2] | (!HEAPU8[$5 + 10 | 0] | $13 | ($6 | 0) != 127)) {
      break label$7;
     }
     $7 = HEAPU8[$5 + 9 | 0] | $7;
    }
    $5 = HEAP32[$5 + 32 >> 2];
    if ($5) {
     continue;
    }
    break;
   }
   break label$1;
  }
  $8 = 0;
 }
 if ($4) {
  HEAP32[$4 >> 2] = $7;
 }
 __stack_pointer = $9 + 16 | 0;
 return $7 ? $8 : 0;
}

function fts3CreateTables($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 96 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 92 >> 2] = 0;
 $5 = HEAP32[$0 + 12 >> 2];
 if (!HEAP32[$0 + 40 >> 2]) {
  $3 = HEAP32[$0 + 44 >> 2];
  $4 = sqlite3_mprintf(18042, 0);
  label$2: {
   label$3: {
    while (1) {
     if (!$4) {
      break label$3;
     }
     if (HEAP32[$0 + 24 >> 2] > ($2 | 0)) {
      HEAP32[$1 + 72 >> 2] = HEAP32[HEAP32[$0 + 28 >> 2] + ($2 << 2) >> 2];
      HEAP32[$1 + 68 >> 2] = $2;
      HEAP32[$1 + 64 >> 2] = $4;
      $2 = $2 + 1 | 0;
      $4 = sqlite3_mprintf(27462, $1 - -64 | 0);
      continue;
     }
     break;
    }
    if (!$3) {
     break label$2;
    }
    HEAP32[$1 + 84 >> 2] = $3;
    HEAP32[$1 + 80 >> 2] = $4;
    $4 = sqlite3_mprintf(14517, $1 + 80 | 0);
    if ($4) {
     break label$2;
    }
   }
   HEAP32[$1 + 92 >> 2] = 7;
   $4 = 0;
  }
  $2 = HEAP32[$0 + 20 >> 2];
  $3 = HEAP32[$0 + 16 >> 2];
  HEAP32[$1 + 56 >> 2] = $4;
  HEAP32[$1 + 48 >> 2] = $3;
  HEAP32[$1 + 52 >> 2] = $2;
  fts3DbExec($1 + 92 | 0, $5, 24498, $1 + 48 | 0);
  sqlite3_free($4);
 }
 $3 = HEAP32[$0 + 20 >> 2];
 $2 = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 32 >> 2] = $2;
 HEAP32[$1 + 36 >> 2] = $3;
 fts3DbExec($1 + 92 | 0, $5, 21324, $1 + 32 | 0);
 $2 = HEAP32[$0 + 20 >> 2];
 $3 = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 16 >> 2] = $3;
 HEAP32[$1 + 20 >> 2] = $2;
 fts3DbExec($1 + 92 | 0, $5, 21541, $1 + 16 | 0);
 if (HEAPU8[$0 + 238 | 0]) {
  $3 = HEAP32[$0 + 20 >> 2];
  $2 = HEAP32[$0 + 16 >> 2];
  HEAP32[$1 >> 2] = $2;
  HEAP32[$1 + 4 >> 2] = $3;
  fts3DbExec($1 + 92 | 0, $5, 21396, $1);
 }
 if (HEAPU8[$0 + 237 | 0]) {
  sqlite3Fts3CreateStatTable($1 + 92 | 0, $0);
 }
 __stack_pointer = $1 + 96 | 0;
 $2 = HEAP32[$1 + 92 >> 2];
 return $2;
}

function sqlite3Fts3InitTokenizer($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 16 >> 2] = $1;
 HEAP32[$5 + 28 >> 2] = 0;
 $4 = 7;
 $6 = sqlite3_mprintf(8342, $5 + 16 | 0);
 label$1: {
  if (!$6) {
   break label$1;
  }
  $10 = strlen($6);
  $1 = sqlite3Fts3NextToken($6, $5 + 28 | 0);
  $1 = $1 ? $1 : $6;
  $7 = HEAP32[$5 + 28 >> 2];
  HEAP8[$1 + $7 | 0] = 0;
  sqlite3Fts3Dequote($1);
  $4 = 1;
  $11 = sqlite3Fts3HashFind($0, $1, strlen($1) + 1 | 0);
  label$2: {
   if ($11) {
    $10 = $6 + $10 | 0;
    label$4: {
     while (1) {
      label$6: {
       $0 = $8;
       $1 = ($1 + $7 | 0) + 1 | 0;
       if ($10 >>> 0 <= $1 >>> 0) {
        break label$6;
       }
       $1 = sqlite3Fts3NextToken($1, $5 + 28 | 0);
       if (!$1) {
        break label$6;
       }
       $4 = $12;
       $8 = $8 + 1 | 0;
       $4 = $8 ? $4 : $4 + 1 | 0;
       $12 = $4;
       $4 = $8 << 2;
       $4 = sqlite3_realloc64($9, $4 & -4, 0);
       if (!$4) {
        break label$4;
       }
       HEAP32[($0 << 2) + $4 >> 2] = $1;
       $7 = HEAP32[$5 + 28 >> 2];
       HEAP8[$7 + $1 | 0] = 0;
       sqlite3Fts3Dequote($1);
       $9 = $4;
       continue;
      }
      break;
     }
     $4 = FUNCTION_TABLE[HEAP32[$11 + 4 >> 2]]($0, $9, $2) | 0;
     label$7: {
      if ($4) {
       sqlite3Fts3ErrMsg($3, 8641, 0);
       break label$7;
      }
      HEAP32[HEAP32[$2 >> 2] >> 2] = $11;
     }
     sqlite3_free($9);
     break label$2;
    }
    sqlite3_free($6);
    sqlite3_free($9);
    $4 = 7;
    break label$1;
   }
   HEAP32[$5 >> 2] = $1;
   sqlite3Fts3ErrMsg($3, 7260, $5);
  }
  sqlite3_free($6);
 }
 __stack_pointer = $5 + 32 | 0;
 return $4;
}

function exprCodeInlineFunction($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer + -64 | 0;
 __stack_pointer = $5;
 $4 = HEAP32[$0 + 8 >> 2];
 label$1: {
  label$2: {
   switch ($2 | 0) {
   case 0:
    $2 = HEAP32[$1 >> 2];
    $6 = sqlite3VdbeMakeLabel($0);
    sqlite3ExprCode($0, HEAP32[$1 + 8 >> 2], $3);
    $7 = ($2 | 0) > 1 ? $2 : 1;
    $2 = 1;
    while (1) {
     if (($2 | 0) != ($7 | 0)) {
      sqlite3VdbeAddOp2($4, 51, $3, $6);
      sqlite3ExprCode($0, HEAP32[(($2 << 4) + $1 | 0) + 8 >> 2], $3);
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    ;
    setDoNotMergeFlagOnCopy($4);
    sqlite3VdbeResolveLabel($4, $6);
    break label$1;

   case 5:
    memset($5 + 8 | 0, 0, 52);
    HEAP32[$5 + 28 >> 2] = $1;
    HEAP8[$5 + 8 | 0] = 157;
    $3 = sqlite3ExprCodeTarget($0, $5 + 8 | 0, $3);
    break label$1;

   default:
    $3 = sqlite3ExprCodeTarget($0, HEAP32[$1 + 8 >> 2], $3);
    break label$1;

   case 3:
    sqlite3VdbeAddOp2($4, 71, sqlite3ExprCompare(0, HEAP32[$1 + 8 >> 2], HEAP32[$1 + 24 >> 2], -1), $3);
    break label$1;

   case 2:
    sqlite3VdbeAddOp2($4, 71, sqlite3ExprImpliesExpr($0, HEAP32[$1 + 8 >> 2], HEAP32[$1 + 24 >> 2], -1), $3);
    break label$1;

   case 1:
    $2 = HEAP32[$1 + 24 >> 2];
    if (HEAPU8[$2 | 0] == 167) {
     sqlite3VdbeAddOp2($4, 71, sqlite3ExprImpliesNonNullRow(HEAP32[$1 + 8 >> 2], HEAP32[$2 + 28 >> 2]), $3);
     break label$1;
    }
    sqlite3VdbeAddOp2($4, 75, 0, $3);
    break label$1;

   case 4:
    break label$2;
   }
  }
  $2 = 13166;
  $0 = sqlite3ExprAffinity(HEAP32[$1 + 8 >> 2]);
  if (($0 | 0) >= 65) {
   $2 = HEAP32[(($0 & 255) << 2) + 48380 >> 2];
  }
  sqlite3VdbeLoadString($4, $3, $2);
 }
 __stack_pointer = $5 - -64 | 0;
 return $3;
}

function fts3PendingTermsAdd($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 28 >> 2] = 0;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = 0;
 HEAP32[$5 + 12 >> 2] = 0;
 label$1: {
  if (!$2) {
   HEAP32[$4 >> 2] = 0;
   break label$1;
  }
  $6 = HEAP32[$0 + 36 >> 2];
  $9 = HEAP32[$6 >> 2];
  $6 = sqlite3Fts3OpenTokenizer($6, $1, $2, -1, $5 + 8 | 0);
  if ($6) {
   break label$1;
  }
  $12 = HEAP32[$9 + 20 >> 2];
  $10 = HEAP32[$5 + 8 >> 2];
  $2 = 0;
  label$3: while (1) {
   label$4: {
    if ($2) {
     break label$4;
    }
    $2 = FUNCTION_TABLE[$12 | 0]($10, $5 + 16 | 0, $5 + 12 | 0, $5 + 28 | 0, $5 + 24 | 0, $5 + 20 | 0) | 0;
    if ($2) {
     break label$4;
    }
    $2 = 1;
    $1 = HEAP32[$5 + 20 >> 2];
    $8 = ($1 | 0) < ($8 | 0) ? $8 : $1 + 1 | 0;
    if (($1 | 0) < 0) {
     break label$4;
    }
    $7 = HEAP32[$5 + 16 >> 2];
    if (!$7) {
     break label$4;
    }
    $11 = HEAP32[$5 + 12 >> 2];
    if (($11 | 0) <= 0) {
     break label$4;
    }
    $6 = 1;
    $2 = fts3PendingTermsAddOne($0, $3, $1, HEAP32[$0 + 260 >> 2] + 4 | 0, $7, $11);
    while (1) {
     if (HEAP32[$0 + 256 >> 2] <= ($6 | 0) | $2) {
      continue label$3;
     }
     $2 = 0;
     $1 = HEAP32[$0 + 260 >> 2] + Math_imul($6, 24) | 0;
     $7 = HEAP32[$1 >> 2];
     if (($7 | 0) <= HEAP32[$5 + 12 >> 2]) {
      $2 = fts3PendingTermsAddOne($0, $3, HEAP32[$5 + 20 >> 2], $1 + 4 | 0, HEAP32[$5 + 16 >> 2], $7);
     }
     $6 = $6 + 1 | 0;
     continue;
    }
   }
   break;
  }
  FUNCTION_TABLE[HEAP32[$9 + 16 >> 2]]($10) | 0;
  HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + $8;
  $6 = ($2 | 0) == 101 ? 0 : $2;
 }
 __stack_pointer = $5 + 32 | 0;
 return $6;
}

function pragmaVtabConnect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 272 | 0;
 __stack_pointer = $3;
 sqlite3StrAccumInit($3 + 248 | 0, 0, $3 + 48 | 0, 200, 0);
 sqlite3_str_appendall($3 + 248 | 0, 1605);
 $2 = HEAPU8[$1 + 6 | 0];
 $6 = 40;
 while (1) {
  if ($8 >>> 0 < HEAPU8[$1 + 7 | 0]) {
   HEAP32[$3 >> 2] = $6;
   HEAP32[$3 + 4 >> 2] = HEAP32[($2 << 2) + 35600 >> 2];
   sqlite3_str_appendf($3 + 248 | 0, 28491, $3);
   $2 = $2 + 1 | 0;
   $8 = $8 + 1 | 0;
   $6 = 44;
   continue;
  }
  break;
 }
 if (!$8) {
  HEAP32[$3 + 32 >> 2] = HEAP32[$1 >> 2];
  sqlite3_str_appendf($3 + 248 | 0, 28498, $3 + 32 | 0);
  $8 = 1;
 }
 $6 = 0;
 $2 = HEAPU8[$1 + 5 | 0];
 if ($2 & 32) {
  sqlite3_str_appendall($3 + 248 | 0, 19453);
  $6 = 1;
  $2 = HEAPU8[$1 + 5 | 0];
 }
 if (($2 & 255) >>> 0 >= 64) {
  sqlite3_str_appendall($3 + 248 | 0, 19465);
  $6 = $6 + 1 | 0;
 }
 sqlite3_str_append($3 + 248 | 0, 26910, 1);
 sqlite3StrAccumFinish($3 + 248 | 0);
 $7 = sqlite3_declare_vtab($0, $3 + 48 | 0);
 label$6: {
  label$7: {
   if (!$7) {
    $2 = sqlite3_malloc(24);
    if (!$2) {
     $7 = 7;
     break label$7;
    }
    $7 = $2 + 16 | 0;
    HEAP32[$7 >> 2] = 0;
    HEAP32[$7 + 4 >> 2] = 0;
    HEAP32[$2 + 8 >> 2] = 0;
    HEAP32[$2 + 12 >> 2] = 0;
    HEAP32[$2 >> 2] = 0;
    HEAP32[$2 + 4 >> 2] = 0;
    HEAP32[$2 + 16 >> 2] = $1;
    HEAP8[$2 + 21 | 0] = $8;
    HEAP32[$2 + 12 >> 2] = $0;
    HEAP8[$2 + 20 | 0] = $6;
    $7 = 0;
    break label$6;
   }
   HEAP32[$3 + 16 >> 2] = sqlite3_errmsg($0);
   HEAP32[$5 >> 2] = sqlite3_mprintf(8342, $3 + 16 | 0);
  }
  $2 = 0;
 }
 HEAP32[$4 >> 2] = $2;
 __stack_pointer = $3 + 272 | 0;
 return $7 | 0;
}

function btreeOverwriteCell($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$1 + 32 >> 2];
 $7 = HEAP32[$1 + 28 >> 2];
 $3 = HEAP32[$0 + 116 >> 2];
 HEAP32[$6 + 12 >> 2] = $3;
 $2 = HEAP32[$0 + 40 >> 2];
 $4 = HEAPU16[$0 + 48 >> 1];
 label$1: {
  if (!(HEAPU32[$3 + 60 >> 2] >= $2 + $4 >>> 0 & HEAP32[$3 + 56 >> 2] + HEAPU16[$3 + 18 >> 1] >>> 0 <= $2 >>> 0)) {
   $2 = sqlite3CorruptError(75789);
   break label$1;
  }
  $2 = btreeOverwriteContent($3, $2, $1, 0, $4);
  if ($2) {
   break label$1;
  }
  $2 = 0;
  $4 = HEAPU16[$0 + 48 >> 1];
  $5 = $5 + $7 | 0;
  if (($4 | 0) == ($5 | 0)) {
   break label$1;
  }
  $7 = sqlite3Get4byte(HEAP32[$0 + 40 >> 2] + $4 | 0);
  $8 = HEAP32[$3 + 52 >> 2];
  $3 = HEAP32[$8 + 40 >> 2] - 4 | 0;
  while (1) {
   $2 = btreeGetPage($8, $7, $6 + 12 | 0, 0);
   if ($2) {
    break label$1;
   }
   $0 = HEAP32[$6 + 12 >> 2];
   label$5: {
    if (!(wasm2js_i32$0 = 0, wasm2js_i32$1 = (sqlite3PagerPageRefcount(HEAP32[$0 + 72 >> 2]) | 0) == 1, 
    wasm2js_i32$2 = HEAPU8[$0 | 0], wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1)) {
     $2 = sqlite3CorruptError(75808);
     break label$5;
    }
    label$8: {
     if ($3 + $4 >>> 0 < $5 >>> 0) {
      $2 = HEAP32[$0 + 56 >> 2];
      $7 = sqlite3Get4byte($2);
      break label$8;
     }
     $3 = $5 - $4 | 0;
     $2 = HEAP32[$0 + 56 >> 2];
    }
    $2 = btreeOverwriteContent($0, $2 + 4 | 0, $1, $4, $3);
   }
   sqlite3PagerUnref(HEAP32[$0 + 72 >> 2]);
   if ($2) {
    break label$1;
   }
   $2 = 0;
   $4 = $3 + $4 | 0;
   if (($5 | 0) > ($4 | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $6 + 16 | 0;
 return $2;
}

function sqlite3BtreeCount($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  label$2: {
   $3 = moveToRoot($1);
   if (($3 | 0) != 16) {
    while (1) {
     if ($3) {
      break label$2;
     }
     if (HEAP32[$0 + 296 >> 2]) {
      break label$1;
     }
     $3 = HEAP32[$1 + 116 >> 2];
     label$5: {
      if (!HEAPU8[$3 + 8 | 0]) {
       $5 = HEAPU16[$3 + 24 >> 1];
       if (HEAPU8[$3 + 1 | 0]) {
        break label$5;
       }
       $4 = $6;
       $7 = $5 & 65535;
       $6 = $7 + $8 | 0;
       $8 = $6;
       $4 = $6 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
       $6 = $4;
       break label$5;
      }
      $4 = HEAPU16[$3 + 24 >> 1];
      $7 = $4;
      $4 = $7 + $8 | 0;
      $6 = $4 >>> 0 < $7 >>> 0 ? $6 + 1 | 0 : $6;
      $8 = $4;
      while (1) {
       if (!HEAPU8[$1 + 68 | 0]) {
        HEAP32[$2 >> 2] = $8;
        HEAP32[$2 + 4 >> 2] = $6;
        $3 = moveToRoot($1);
        break label$2;
       }
       moveToParent($1);
       $3 = HEAP32[$1 + 116 >> 2];
       $5 = HEAPU16[$3 + 24 >> 1];
       $4 = HEAPU16[$1 + 70 >> 1];
       if ($5 >>> 0 <= $4 >>> 0) {
        continue;
       }
       break;
      }
      HEAP16[$1 + 70 >> 1] = $4 + 1;
     }
     $4 = HEAPU16[$1 + 70 >> 1];
     label$9: {
      if (($4 | 0) == ($5 & 65535)) {
       $3 = sqlite3Get4byte((HEAPU8[$3 + 9 | 0] + HEAP32[$3 + 56 >> 2] | 0) + 8 | 0);
       break label$9;
      }
      $5 = HEAP32[$3 + 64 >> 2] + ($4 << 1) | 0;
      $3 = sqlite3Get4byte(HEAP32[$3 + 56 >> 2] + (HEAPU16[$3 + 26 >> 1] & (HEAPU8[$5 | 0] << 8 | HEAPU8[$5 + 1 | 0])) | 0);
     }
     $3 = moveToChild($1, $3);
     continue;
    }
   }
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   break label$1;
  }
  return $3;
 }
 return 0;
}

function sqlite3_db_config($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 $2 = 0;
 label$1: {
  label$2: {
   switch ($1 - 1e3 | 0) {
   case 1:
    $2 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $2 + 4;
    $1 = HEAP32[$2 + 4 >> 2];
    $5 = HEAP32[$2 >> 2];
    HEAP32[$3 + 12 >> 2] = $2 + 12;
    $1 = setupLookaside($0, $5, $1, HEAP32[$2 + 8 >> 2]);
    break label$1;

   default:
    while (1) {
     if (($2 | 0) == 16) {
      $1 = 1;
      break label$1;
     }
     if (HEAP32[($2 << 3) + 31696 >> 2] != ($1 | 0)) {
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    ;
    $1 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $1 + 4;
    $4 = HEAP32[$1 >> 2];
    HEAP32[$3 + 12 >> 2] = $1 + 8;
    $6 = HEAP32[$0 + 32 >> 2];
    $7 = HEAP32[$0 + 36 >> 2];
    $5 = HEAP32[$1 + 4 >> 2];
    label$8: {
     label$9: {
      if (($4 | 0) > 0) {
       $4 = HEAP32[($2 << 3) + 31700 >> 2] | $6;
       $1 = $7;
       break label$9;
      }
      if ($4) {
       break label$8;
      }
      $4 = (HEAP32[($2 << 3) + 31700 >> 2] ^ -1) & $6;
      $1 = $7;
     }
     HEAP32[$0 + 32 >> 2] = $4;
     HEAP32[$0 + 36 >> 2] = $1;
     if (($6 | 0) == ($4 | 0) & ($7 | 0) == ($1 | 0)) {
      break label$8;
     }
     sqlite3ExpirePreparedStatements($0, 0);
    }
    $1 = 0;
    if (!$5) {
     break label$1;
    }
    HEAP32[$5 >> 2] = (HEAP32[($2 << 3) + 31700 >> 2] & HEAP32[$0 + 32 >> 2]) != 0;
    break label$1;

   case 0:
    break label$2;
   }
  }
  $2 = HEAP32[$3 + 12 >> 2];
  HEAP32[$3 + 12 >> 2] = $2 + 4;
  HEAP32[HEAP32[$0 + 16 >> 2] >> 2] = HEAP32[$2 >> 2];
  $1 = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $1;
}

function sqlite3Fts3ReadBlock($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $5 = $0 + 252 | 0;
 $6 = HEAP32[$0 + 252 >> 2];
 label$1: {
  label$2: {
   if ($6) {
    $0 = sqlite3_blob_reopen($6, $1, $2);
    break label$2;
   }
   label$4: {
    $6 = HEAP32[$0 + 248 >> 2];
    if ($6) {
     break label$4;
    }
    HEAP32[$7 >> 2] = HEAP32[$0 + 20 >> 2];
    $6 = sqlite3_mprintf(3746, $7);
    HEAP32[$0 + 248 >> 2] = $6;
    if ($6) {
     break label$4;
    }
    $0 = 7;
    break label$1;
   }
   $0 = sqlite3_blob_open(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 16 >> 2], $6, 11401, $1, $2, 0, $5);
  }
  if (!$0) {
   $1 = sqlite3_blob_bytes(HEAP32[$5 >> 2]);
   HEAP32[$4 >> 2] = $1;
   if (!$3) {
    $0 = 0;
    break label$1;
   }
   $6 = sqlite3_malloc($1 + 20 | 0);
   label$7: {
    if (!$6) {
     $6 = 0;
     $0 = 7;
     break label$7;
    }
    $0 = sqlite3_blob_read(HEAP32[$5 >> 2], $6, $1, 0);
    $5 = $6 + $1 | 0;
    HEAP8[$5 + 16 | 0] = 0;
    HEAP8[$5 + 17 | 0] = 0;
    HEAP8[$5 + 18 | 0] = 0;
    HEAP8[$5 + 19 | 0] = 0;
    HEAP8[$5 + 8 | 0] = 0;
    HEAP8[$5 + 9 | 0] = 0;
    HEAP8[$5 + 10 | 0] = 0;
    HEAP8[$5 + 11 | 0] = 0;
    HEAP8[$5 + 12 | 0] = 0;
    HEAP8[$5 + 13 | 0] = 0;
    HEAP8[$5 + 14 | 0] = 0;
    HEAP8[$5 + 15 | 0] = 0;
    HEAP8[$5 | 0] = 0;
    HEAP8[$5 + 1 | 0] = 0;
    HEAP8[$5 + 2 | 0] = 0;
    HEAP8[$5 + 3 | 0] = 0;
    HEAP8[$5 + 4 | 0] = 0;
    HEAP8[$5 + 5 | 0] = 0;
    HEAP8[$5 + 6 | 0] = 0;
    HEAP8[$5 + 7 | 0] = 0;
    if (!$0) {
     $0 = 0;
     break label$7;
    }
    sqlite3_free($6);
    $6 = 0;
   }
   HEAP32[$3 >> 2] = $6;
   break label$1;
  }
  $0 = ($0 | 0) == 1 ? 267 : $0;
 }
 __stack_pointer = $7 + 16 | 0;
 return $0;
}

function pager_truncate($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $5 = HEAP32[$0 + 64 >> 2];
 label$1: {
  if (!HEAP32[$5 >> 2] | (HEAPU8[$0 + 17 | 0] - 4 & 255) >>> 0 > 252) {
   break label$1;
  }
  $2 = $0;
  $8 = HEAP32[$2 + 168 >> 2];
  $6 = sqlite3OsFileSize($5, $7 + 8 | 0);
  $2 = $8;
  $8 = $2;
  $2 = $2 >> 31;
  $11 = $2;
  $3 = __wasm_i64_mul($8, $2, $1, 0);
  $10 = $3;
  $2 = i64toi32_i32$HIGH_BITS;
  $5 = $2;
  $3 = $7;
  HEAP32[$3 >> 2] = $10;
  HEAP32[$3 + 4 >> 2] = $2;
  if ($6) {
   break label$1;
  }
  $6 = 0;
  $2 = HEAP32[$7 + 8 >> 2];
  $4 = $2;
  $3 = HEAP32[$7 + 12 >> 2];
  $12 = $3;
  $2 = $5;
  if (($10 | 0) == ($4 | 0) & ($3 | 0) == ($2 | 0)) {
   break label$1;
  }
  $2 = $4;
  $3 = $12;
  label$2: {
   label$3: {
    if ($10 >>> 0 < $2 >>> 0 & ($3 | 0) >= ($5 | 0) | ($3 | 0) > ($5 | 0)) {
     $6 = sqlite3OsTruncate(HEAP32[$0 + 64 >> 2], $10, $5);
     break label$3;
    }
    $3 = $4;
    $2 = $8;
    $9 = $3 + $2 | 0;
    $4 = $11 + $12 | 0;
    $4 = $3 >>> 0 > $9 >>> 0 ? $4 + 1 | 0 : $4;
    $3 = $10;
    $2 = $5;
    if ($9 >>> 0 > $3 >>> 0 & ($4 | 0) >= ($2 | 0) | ($2 | 0) < ($4 | 0)) {
     break label$2;
    }
    $6 = $8;
    $5 = memset(HEAP32[$0 + 224 >> 2], 0, $6);
    sqlite3OsFileControlHint(HEAP32[$0 + 64 >> 2], 5, $7);
    $3 = $7;
    $3 = HEAP32[$3 >> 2];
    $2 = $8;
    $4 = HEAP32[$7 + 4 >> 2];
    $9 = ($2 >>> 0 > $3 >>> 0) + $11 | 0;
    $9 = $4 - $9 | 0;
    $6 = sqlite3OsWrite(HEAP32[$0 + 64 >> 2], $5, $6, $3 - $2 | 0, $9);
   }
   if ($6) {
    break label$1;
   }
  }
  HEAP32[$0 + 36 >> 2] = $1;
  $6 = 0;
 }
 __stack_pointer = $7 + 16 | 0;
 return $6;
}

function walIteratorInit($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $9 = HEAP32[$0 + 68 >> 2];
 $11 = walFramePage($9);
 $6 = (Math_imul($11, 20) + ($9 << 1) | 0) + 28 | 0;
 $12 = sqlite3_malloc64($6, 0);
 label$1: {
  if (!$12) {
   $7 = 7;
   break label$1;
  }
  $10 = memset($12, 0, $6);
  HEAP32[$10 + 4 >> 2] = $11 + 1;
  $13 = sqlite3_malloc64(($9 >>> 0 < 4096 ? $9 : 4096) << 1, 0);
  $7 = $13 ? 0 : 7;
  $8 = walFramePage($1 + 1 | 0);
  while (1) {
   if (!(($8 | 0) > ($11 | 0) | $7)) {
    $7 = walHashGet($0, $8, $3 + 16 | 0);
    if (!$7) {
     label$6: {
      if (($8 | 0) == ($11 | 0)) {
       $5 = HEAP32[$3 + 24 >> 2];
       $4 = $9 - $5 | 0;
       break label$6;
      }
      $5 = HEAP32[$3 + 24 >> 2];
      $4 = HEAP32[$3 + 16 >> 2] - HEAP32[$3 + 20 >> 2] >> 2;
     }
     HEAP32[$3 + 12 >> 2] = $4;
     $6 = ((Math_imul(HEAP32[$10 + 4 >> 2], 20) + $10 | 0) + ($5 << 1) | 0) + 8 | 0;
     $1 = 0;
     $4 = ($4 | 0) > 0 ? $4 : 0;
     $5 = $5 + 1 | 0;
     while (1) {
      if (($1 | 0) != ($4 | 0)) {
       HEAP16[($1 << 1) + $6 >> 1] = $1;
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     $4 = HEAP32[$3 + 20 >> 2];
     walMergesort($4, $13, $6, $3 + 12 | 0);
     $1 = Math_imul($8, 20) + $10 | 0;
     HEAP32[$1 + 24 >> 2] = $5;
     $5 = HEAP32[$3 + 12 >> 2];
     HEAP32[$1 + 16 >> 2] = $4;
     HEAP32[$1 + 12 >> 2] = $6;
     HEAP32[$1 + 20 >> 2] = $5;
    }
    $8 = $8 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_free($13);
  if ($7) {
   walIteratorFree($10);
   $12 = 0;
  }
  HEAP32[$2 >> 2] = $12;
 }
 __stack_pointer = $3 + 32 | 0;
 return $7;
}

function moveToRoot($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  label$2: {
   label$3: {
    $2 = HEAP8[$0 + 68 | 0];
    label$4: {
     if (($2 | 0) >= 0) {
      $1 = HEAP32[$0 + 116 >> 2];
      if (!$2) {
       break label$4;
      }
      while (1) {
       releasePageNotNull($1);
       $1 = HEAPU8[$0 + 68 | 0] - 1 | 0;
       HEAP8[$0 + 68 | 0] = $1;
       if (!($1 & 255)) {
        break label$3;
       }
       $1 = HEAP32[(($1 << 24 >> 24 << 2) + $0 | 0) + 120 >> 2];
       continue;
      }
     }
     $1 = HEAP32[$0 + 64 >> 2];
     if (!$1) {
      break label$1;
     }
     $2 = HEAPU8[$0 | 0];
     if ($2 >>> 0 >= 3) {
      if (($2 | 0) == 4) {
       return HEAP32[$0 + 4 >> 2];
      }
      sqlite3BtreeClearCursor($0);
      $1 = HEAP32[$0 + 64 >> 2];
     }
     $1 = getAndInitPage(HEAP32[HEAP32[$0 + 8 >> 2] + 4 >> 2], $1, $0 + 116 | 0, 0, HEAPU8[$0 + 2 | 0]);
     if ($1) {
      HEAP8[$0 | 0] = 1;
      return $1;
     }
     HEAP8[$0 + 68 | 0] = 0;
     $1 = HEAP32[$0 + 116 >> 2];
     HEAP8[$0 + 69 | 0] = HEAPU8[$1 + 1 | 0];
    }
    if (HEAPU8[$1 + 1 | 0] == (!HEAP32[$0 + 112 >> 2] | 0) ? HEAPU8[$1 | 0] : 0) {
     break label$2;
    }
    return sqlite3CorruptError(72253);
   }
   $1 = HEAP32[$0 + 120 >> 2];
   HEAP32[$0 + 116 >> 2] = $1;
  }
  HEAP16[$0 + 70 >> 1] = 0;
  HEAP16[$0 + 50 >> 1] = 0;
  HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 241;
  if (HEAPU16[$1 + 24 >> 1]) {
   HEAP8[$0 | 0] = 0;
   return 0;
  }
  if (!HEAPU8[$1 + 8 | 0]) {
   if (HEAP32[$1 + 4 >> 2] == 1) {
    $1 = sqlite3Get4byte((HEAPU8[$1 + 9 | 0] + HEAP32[$1 + 56 >> 2] | 0) + 8 | 0);
    HEAP8[$0 | 0] = 0;
    return moveToChild($0, $1);
   }
   return sqlite3CorruptError(72265);
  }
 }
 HEAP8[$0 | 0] = 1;
 return 16;
}

function sqlite3MemCompare($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = HEAPU16[$1 + 16 >> 1];
 $5 = HEAPU16[$0 + 16 >> 1];
 $4 = $3 | $5;
 if ($4 & 1) {
  return ($3 & 1) - ($5 & 1) | 0;
 }
 label$2: {
  if ($4 & 44) {
   $4 = $3 & $5;
   if ($4 & 36) {
    $4 = -1;
    $5 = HEAP32[$0 >> 2];
    $6 = HEAP32[$1 >> 2];
    $2 = HEAP32[$0 + 4 >> 2];
    $3 = HEAP32[$1 + 4 >> 2];
    if ($5 >>> 0 < $6 >>> 0 & ($2 | 0) <= ($3 | 0) | ($2 | 0) < ($3 | 0)) {
     break label$2;
    }
    return $5 >>> 0 > $6 >>> 0 & ($2 | 0) >= ($3 | 0) | ($2 | 0) > ($3 | 0);
   }
   if ($4 & 8) {
    $4 = -1;
    $7 = HEAPF64[$0 >> 3];
    $8 = HEAPF64[$1 >> 3];
    if ($7 < $8) {
     break label$2;
    }
    return $7 > $8;
   }
   if ($5 & 36) {
    if ($3 & 8) {
     return sqlite3IntFloatCompare(HEAP32[$0 >> 2], HEAP32[$0 + 4 >> 2], HEAPF64[$1 >> 3]);
    }
    $4 = -1;
    if (!($3 & 36)) {
     break label$2;
    }
    $2 = HEAP32[$0 + 4 >> 2];
    $3 = HEAP32[$1 + 4 >> 2];
    $6 = HEAP32[$1 >> 2];
    $5 = HEAP32[$0 >> 2];
    if (($2 | 0) <= ($3 | 0) & $6 >>> 0 > $5 >>> 0 | ($2 | 0) < ($3 | 0)) {
     break label$2;
    }
    return $5 >>> 0 > $6 >>> 0 & ($2 | 0) >= ($3 | 0) | ($2 | 0) > ($3 | 0);
   }
   $4 = 1;
   if (!($5 & 8)) {
    break label$2;
   }
   if (!($3 & 36)) {
    return -1;
   }
   return 0 - sqlite3IntFloatCompare(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAPF64[$0 >> 3]) | 0;
  }
  label$9: {
   if (!($4 & 2)) {
    break label$9;
   }
   $4 = 1;
   if (!($5 & 2)) {
    break label$2;
   }
   $4 = -1;
   if (!($3 & 2)) {
    break label$2;
   }
   if (!$2) {
    break label$9;
   }
   return vdbeCompareMemString($0, $1, $2, 0);
  }
  $4 = sqlite3BlobCompare($0, $1);
 }
 return $4;
}

function resolveP2Values($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = HEAP32[$1 >> 2];
 $5 = HEAP32[$0 + 12 >> 2];
 $6 = HEAP32[$5 + 64 >> 2];
 HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 63 | 64;
 $7 = HEAP32[$0 + 104 >> 2];
 $2 = ($7 + Math_imul(HEAP32[$0 + 108 >> 2], 20) | 0) - 20 | 0;
 while (1) {
  $4 = $2;
  $2 = HEAPU8[$2 | 0];
  label$2: {
   if ($2 >>> 0 > 64) {
    break label$2;
   }
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        label$8: {
         switch ($2 | 0) {
         case 6:
          break label$4;

         case 7:
          break label$5;

         case 3:
         case 4:
         case 5:
          break label$6;

         case 0:
         case 1:
          break label$7;

         case 2:
          break label$8;

         default:
          break label$3;
         }
        }
        if (!HEAP32[$4 + 8 >> 2]) {
         break label$7;
        }
        HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 191;
       }
       HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] | 128;
       break label$2;
      }
      HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 63 | 128;
      break label$2;
     }
     $2 = HEAP32[$4 + 8 >> 2];
     $3 = ($2 | 0) > ($3 | 0) ? $2 : $3;
     break label$2;
    }
    $2 = HEAP32[$4 - 16 >> 2];
    $3 = ($2 | 0) > ($3 | 0) ? $2 : $3;
   }
   $2 = HEAP32[$4 + 8 >> 2];
   if (($2 | 0) >= 0) {
    break label$2;
   }
   HEAP32[$4 + 8 >> 2] = HEAP32[(($2 ^ -1) << 2) + $6 >> 2];
  }
  $2 = $4 - 20 | 0;
  if (($4 | 0) != ($7 | 0)) {
   continue;
  }
  break;
 }
 if ($6) {
  sqlite3DbFreeNN(HEAP32[$0 >> 2], HEAP32[$5 + 64 >> 2]);
  HEAP32[$5 + 64 >> 2] = 0;
 }
 HEAP32[$5 + 56 >> 2] = 0;
 HEAP32[$1 >> 2] = $3;
}

function allocateSpace($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $9 = HEAP32[$0 + 56 >> 2];
 $4 = HEAPU8[$0 + 9 | 0];
 HEAP32[$5 + 12 >> 2] = 0;
 $3 = $4 + $9 | 0;
 $8 = $3;
 label$1: {
  label$2: {
   $4 = HEAPU8[$3 + 6 | 0] | HEAPU8[$3 + 5 | 0] << 8;
   $6 = HEAPU16[$0 + 18 >> 1] + (HEAPU16[$0 + 24 >> 1] << 1) | 0;
   if ($4 >>> 0 >= $6 >>> 0) {
    break label$2;
   }
   if (!$4) {
    $4 = 65536;
    if (HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] == 65536) {
     break label$2;
    }
   }
   $3 = sqlite3CorruptError(68587);
   break label$1;
  }
  label$4: {
   label$5: {
    if (!HEAPU8[$3 + 2 | 0]) {
     $7 = $6 + 2 | 0;
     if (!HEAPU8[$3 + 1 | 0]) {
      break label$4;
     }
     if ($4 >>> 0 >= $7 >>> 0) {
      break label$5;
     }
     break label$4;
    }
    $7 = $6 + 2 | 0;
    if ($7 >>> 0 > $4 >>> 0) {
     break label$4;
    }
   }
   $3 = pageFindSlot($0, $1, $5 + 12 | 0);
   if ($3) {
    $0 = $3 - $9 | 0;
    HEAP32[$2 >> 2] = $0;
    $3 = 0;
    if (($0 | 0) > ($6 | 0)) {
     break label$1;
    }
    $3 = sqlite3CorruptError(68605);
    break label$1;
   }
   $3 = HEAP32[$5 + 12 >> 2];
   if ($3) {
    break label$1;
   }
   $7 = $6 + 2 | 0;
  }
  if (($1 + $7 | 0) > ($4 | 0)) {
   $4 = (HEAP32[$0 + 20 >> 2] - $1 | 0) - 2 | 0;
   $3 = defragmentPage($0, ($4 | 0) < 4 ? $4 : 4);
   if ($3) {
    break label$1;
   }
   $4 = ((HEAPU8[$8 + 6 | 0] | HEAPU8[$8 + 5 | 0] << 8) - 1 & 65535) + 1 | 0;
  }
  $0 = $4 - $1 | 0;
  $1 = $0 << 8 | ($0 & 65280) >>> 8;
  HEAP8[$8 + 5 | 0] = $1;
  HEAP8[$8 + 6 | 0] = $1 >>> 8;
  HEAP32[$2 >> 2] = $0;
  $3 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $3;
}

function simpleNext($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $10 = HEAP32[$0 + 4 >> 2];
 $11 = HEAP32[$0 >> 2];
 while (1) {
  $7 = HEAP32[$0 + 12 >> 2];
  $8 = HEAP32[$0 + 8 >> 2];
  if (($7 | 0) >= ($8 | 0)) {
   return 101;
  }
  while (1) {
   label$4: {
    if (($7 | 0) >= ($8 | 0)) {
     break label$4;
    }
    if (!simpleDelim($11, HEAPU8[$7 + $10 | 0])) {
     break label$4;
    }
    $7 = $7 + 1 | 0;
    HEAP32[$0 + 12 >> 2] = $7;
    continue;
   }
   break;
  }
  $6 = $7;
  while (1) {
   label$6: {
    if (($6 | 0) >= ($8 | 0)) {
     break label$6;
    }
    if (simpleDelim($11, HEAPU8[$6 + $10 | 0])) {
     break label$6;
    }
    $6 = $6 + 1 | 0;
    HEAP32[$0 + 12 >> 2] = $6;
    continue;
   }
   break;
  }
  $12 = ($6 | 0) <= ($7 | 0);
  if ($12) {
   continue;
  }
  $9 = $6 - $7 | 0;
  if (($9 | 0) > HEAP32[$0 + 24 >> 2]) {
   $6 = $9 + 20 | 0;
   HEAP32[$0 + 24 >> 2] = $6;
   $6 = sqlite3_realloc(HEAP32[$0 + 20 >> 2], $6);
   if (!$6) {
    return 7;
   }
   HEAP32[$0 + 20 >> 2] = $6;
  }
  $6 = 0;
  $13 = ($9 | 0) > 0 ? $9 : 0;
  while (1) {
   if (($6 | 0) != ($13 | 0)) {
    $8 = HEAPU8[($6 + $7 | 0) + $10 | 0];
    HEAP8[HEAP32[$0 + 20 >> 2] + $6 | 0] = ($8 - 65 & 255) >>> 0 < 26 ? $8 + 32 | 0 : $8;
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$1 >> 2] = HEAP32[$0 + 20 >> 2];
  HEAP32[$2 >> 2] = $9;
  HEAP32[$3 >> 2] = $7;
  HEAP32[$4 >> 2] = HEAP32[$0 + 12 >> 2];
  $7 = HEAP32[$0 + 16 >> 2];
  HEAP32[$0 + 16 >> 2] = $7 + 1;
  HEAP32[$5 >> 2] = $7;
  if ($12) {
   continue;
  }
  break;
 }
 return 0;
}

function convertCompoundSelectToSubquery($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (!HEAP32[$1 + 52 >> 2]) {
   break label$1;
  }
  $3 = HEAP32[$1 + 48 >> 2];
  if (!$3) {
   break label$1;
  }
  $2 = $1;
  while (1) {
   if (!$2) {
    break label$1;
   }
   label$3: {
    switch (HEAPU8[$2 | 0] - 135 | 0) {
    case 0:
    case 3:
     $2 = HEAP32[$2 + 52 >> 2];
     continue;

    default:
     break label$3;
    }
   }
   break;
  }
  if (HEAPU16[$3 + 20 >> 1]) {
   break label$1;
  }
  $5 = $3 + 8 | 0;
  $2 = HEAP32[$3 >> 2];
  while (1) {
   if (($2 | 0) <= 0) {
    break label$1;
   }
   $2 = $2 - 1 | 0;
   if (!(HEAPU8[HEAP32[($2 << 4) + $5 >> 2] + 5 | 0] & 2)) {
    continue;
   }
   break;
  }
  $6 = 2;
  $0 = HEAP32[$0 >> 2];
  $3 = HEAP32[$0 >> 2];
  $2 = sqlite3DbMallocZero($3, 76, 0);
  if (!$2) {
   break label$1;
  }
  HEAP32[$4 + 8 >> 2] = 0;
  HEAP32[$4 + 12 >> 2] = 0;
  $5 = sqlite3SrcListAppendFromTerm($0, 0, 0, 0, $4 + 8 | 0, $2, 0);
  if (!$5) {
   break label$1;
  }
  $2 = __memcpy($2, $1, 76);
  HEAP32[$1 + 32 >> 2] = $5;
  $6 = sqlite3ExprListAppend($0, 0, sqlite3Expr($3, 180, 0));
  HEAP32[$1 + 36 >> 2] = 0;
  HEAP8[$1 | 0] = 138;
  HEAP32[$1 + 28 >> 2] = $6;
  HEAP32[$2 + 48 >> 2] = 0;
  HEAP32[$2 + 40 >> 2] = 0;
  HEAP32[$2 + 44 >> 2] = 0;
  HEAP32[$1 + 72 >> 2] = 0;
  HEAP32[$1 + 64 >> 2] = 0;
  HEAP32[$1 + 52 >> 2] = 0;
  HEAP32[$1 + 56 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -65793 | 65536;
  HEAP32[HEAP32[$2 + 52 >> 2] + 56 >> 2] = $2;
  HEAP32[$2 + 60 >> 2] = 0;
  $6 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $6 | 0;
}

function sqlite3VdbeSorterInit($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = HEAPU16[HEAP32[$2 + 40 >> 2] + 6 >> 1] << 2;
 $3 = sqlite3DbMallocZero($0, $7 + 156 | 0, 0);
 HEAP32[$2 + 36 >> 2] = $3;
 if (!$3) {
  return 7;
 }
 $4 = HEAP32[HEAP32[$0 + 16 >> 2] + 4 >> 2];
 $8 = $3 + 136 | 0;
 HEAP32[$3 + 28 >> 2] = $8;
 __memcpy($8, HEAP32[$2 + 40 >> 2], $7 + 20 | 0);
 $7 = 0;
 HEAP32[$3 + 148 >> 2] = 0;
 if ($1) {
  HEAP16[$3 + 142 >> 1] = $1;
 }
 sqlite3BtreeEnter($4);
 $2 = sqlite3BtreeGetPageSize($4);
 HEAP8[$3 + 59 | 0] = 1;
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP8[$3 + 57 | 0] = 0;
 HEAP8[$3 + 58 | 0] = 255;
 HEAP32[$3 + 72 >> 2] = $3;
 HEAP32[$3 + 24 >> 2] = $0;
 label$3: {
  if (sqlite3TempInMemory($0)) {
   break label$3;
  }
  $1 = Math_imul(HEAP32[16119], $2);
  HEAP32[$3 >> 2] = $1;
  $4 = $2 >> 31;
  $9 = $4;
  $4 = HEAP32[HEAP32[HEAP32[$0 + 16 >> 2] + 12 >> 2] + 80 >> 2];
  $6 = $4 >> 31;
  $10 = $4;
  $8 = $6;
  $5 = ($6 | 0) < 0;
  $4 = $5 ? -1024 : $2;
  $11 = $4;
  $6 = $9;
  $5 = $5 ? -1 : $6;
  $4 = $8;
  $4 = __wasm_i64_mul($11, $5, $10, $4);
  $5 = i64toi32_i32$HIGH_BITS;
  $6 = $4 >>> 0 < 536870912 & ($5 | 0) <= 0 | ($5 | 0) < 0;
  $4 = $6 ? $4 : 536870912;
  HEAP32[$3 + 4 >> 2] = ($1 | 0) > ($4 | 0) ? $1 : $4;
  if (HEAPU8[64280]) {
   break label$3;
  }
  HEAP32[$3 + 52 >> 2] = $2;
  $2 = sqlite3Malloc($2, $9);
  HEAP32[$3 + 40 >> 2] = $2;
  $7 = $2 ? 0 : 7;
 }
 label$4: {
  if (HEAPU16[$3 + 144 >> 1] > 12) {
   break label$4;
  }
  $2 = HEAP32[$3 + 156 >> 2];
  if (HEAPU8[HEAP32[$3 + 152 >> 2]] & 2 | (HEAP32[$0 + 8 >> 2] != ($2 | 0) ? $2 : 0)) {
   break label$4;
  }
  HEAP8[$3 + 60 | 0] = 3;
 }
 return $7;
}

function jsonParseCached($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = sqlite3_value_text(HEAP32[$1 >> 2]);
 $6 = sqlite3_value_bytes(HEAP32[$1 >> 2]);
 if ($8) {
  $9 = -1;
  $1 = 0;
  while (1) {
   label$3: {
    label$4: {
     if (($1 | 0) != 4) {
      $4 = sqlite3_get_auxdata($0, $1 - 429938 | 0);
      if ($4) {
       break label$4;
      }
      $10 = $1;
     }
     if (!$5) {
      break label$3;
     }
     HEAP8[$5 + 21 | 0] = 0;
     HEAP32[$5 + 28 >> 2] = $7 + 1;
     return $5;
    }
    label$6: {
     label$7: {
      if (HEAP32[$4 + 24 >> 2] != ($6 | 0) | $5) {
       break label$7;
      }
      if (memcmp(HEAP32[$4 + 12 >> 2], $8, $6)) {
       break label$7;
      }
      HEAP8[$4 + 21 | 0] = 0;
      $3 = HEAP32[$4 + 28 >> 2];
      $5 = $4;
      break label$6;
     }
     $3 = HEAP32[$4 + 28 >> 2];
     $4 = $9 >>> 0 > $3 >>> 0;
     $9 = $4 ? $3 : $9;
     $10 = $4 ? $1 : $10;
    }
    $7 = $3 >>> 0 > $7 >>> 0 ? $3 : $7;
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  $1 = sqlite3_malloc64($6 + 33 | 0, 0);
  if (!$1) {
   sqlite3_result_error_nomem($0);
   return 0;
  }
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 + 24 >> 2] = 0;
  HEAP32[$1 + 28 >> 2] = 0;
  HEAP32[$1 + 16 >> 2] = 0;
  HEAP32[$1 + 20 >> 2] = 0;
  $3 = $1 + 32 | 0;
  HEAP32[$1 + 12 >> 2] = $3;
  if (jsonParse($1, $2, __memcpy($3, $8, $6 + 1 | 0))) {
   sqlite3_free($1);
   return 0;
  }
  HEAP32[$1 + 24 >> 2] = $6;
  HEAP32[$1 + 28 >> 2] = $7 + 1;
  $3 = $10 - 429938 | 0;
  sqlite3_set_auxdata($0, $3, $1, 93);
  $5 = sqlite3_get_auxdata($0, $3);
 }
 return $5;
}

function modeStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (($1 | 0) == 1) {
  $5 = sqlite3_value_numeric_type(HEAP32[$2 >> 2]);
  if (($5 | 0) != 5) {
   $1 = sqlite3_aggregate_context($0, 64);
   label$3: {
    if (HEAP32[$1 + 56 >> 2]) {
     break label$3;
    }
    $0 = dlcalloc(1, 12);
    HEAP32[$1 + 56 >> 2] = $0;
    if (($5 | 0) == 1) {
     map_make($3, 426);
     HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 8 >> 2];
     $4 = HEAP32[$3 + 4 >> 2];
     $5 = HEAP32[$3 >> 2];
     HEAP32[$0 >> 2] = $5;
     HEAP32[$0 + 4 >> 2] = $4;
     HEAP32[$1 + 48 >> 2] = 0;
     HEAP32[$1 + 52 >> 2] = 0;
     break label$3;
    }
    HEAP32[$1 + 48 >> 2] = 1;
    HEAP32[$1 + 52 >> 2] = 0;
    map_make($3, 427);
    HEAP32[$0 + 8 >> 2] = HEAP32[$3 + 8 >> 2];
    $5 = HEAP32[$3 + 4 >> 2];
    $4 = HEAP32[$3 >> 2];
    HEAP32[$0 >> 2] = $4;
    HEAP32[$0 + 4 >> 2] = $5;
   }
   $5 = HEAP32[$1 + 16 >> 2];
   $0 = $5;
   $4 = HEAP32[$1 + 20 >> 2];
   $0 = $0 + 1 | 0;
   $4 = $0 ? $4 : $4 + 1 | 0;
   HEAP32[$1 + 16 >> 2] = $0;
   HEAP32[$1 + 20 >> 2] = $4;
   $2 = HEAP32[$2 >> 2];
   $4 = HEAP32[$1 + 48 >> 2];
   $0 = HEAP32[$1 + 52 >> 2];
   label$5: {
    if (!($4 | $0)) {
     $0 = sqlite3_value_int64($2);
     $4 = i64toi32_i32$HIGH_BITS;
     $2 = dlcalloc(1, 8);
     HEAP32[$2 >> 2] = $0;
     HEAP32[$2 + 4 >> 2] = $4;
     break label$5;
    }
    $6 = sqlite3_value_double($2);
    $2 = dlcalloc(1, 8);
    HEAPF64[$2 >> 3] = $6;
   }
   map_insert(HEAP32[$1 + 56 >> 2], $2);
  }
  __stack_pointer = $3 + 16 | 0;
  return;
 }
 __assert_fail(23175, 17353, 1418, 9434);
 abort();
}

function whereIndexExprTrans($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 label$1: {
  $5 = HEAP32[$0 + 40 >> 2];
  if (!(HEAPU8[$0 + 56 | 0] & 4 ? 1 : $5)) {
   break label$1;
  }
  $8 = HEAP32[$0 + 12 >> 2];
  HEAP32[$4 + 48 >> 2] = 0;
  HEAP32[$4 + 52 >> 2] = 0;
  HEAP32[$4 + 40 >> 2] = 0;
  HEAP32[$4 + 44 >> 2] = 0;
  HEAP32[$4 + 32 >> 2] = 0;
  HEAP32[$4 + 36 >> 2] = 0;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 56 >> 2] = $4;
  HEAP32[$4 + 20 >> 2] = $3;
  HEAP32[$4 + 24 >> 2] = HEAP32[HEAP32[$3 >> 2] >> 2];
  $2 = 0;
  while (1) {
   if (HEAPU16[$0 + 52 >> 1] <= $2 >>> 0) {
    break label$1;
   }
   $1 = HEAP16[HEAP32[$0 + 4 >> 2] + ($2 << 1) >> 1];
   label$4: {
    label$5: {
     if (($1 | 0) == -2) {
      $1 = HEAP32[(($2 << 4) + $5 | 0) + 8 >> 2];
      HEAP32[$4 >> 2] = $1;
      if (sqlite3ExprIsConstant($1)) {
       break label$4;
      }
      $1 = 83;
      break label$5;
     }
     if (($1 | 0) < 0) {
      break label$4;
     }
     $6 = HEAP32[$8 + 4 >> 2] + Math_imul($1, 12) | 0;
     $7 = HEAPU16[$6 + 10 >> 1];
     if (!($7 & 32)) {
      break label$4;
     }
     if ($7 & 512) {
      if (sqlite3StrICmp(sqlite3ColumnColl($6), 32384)) {
       break label$4;
      }
     }
     HEAP32[$4 + 16 >> 2] = $1;
     $1 = 84;
    }
    HEAP32[$4 + 12 >> 2] = $2;
    HEAP32[$4 + 36 >> 2] = $1;
    sqlite3WalkExpr($4 + 32 | 0, HEAP32[$3 + 16 >> 2]);
    sqlite3WalkExprList($4 + 32 | 0, HEAP32[$3 + 8 >> 2]);
    sqlite3WalkExprList($4 + 32 | 0, HEAP32[$3 + 12 >> 2]);
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $4 - -64 | 0;
}

function sqlite3VtabFinishParse($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 $4 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$4) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  addArgumentToVtab($0);
  HEAP32[$0 + 252 >> 2] = 0;
  if (HEAP32[$4 + 44 >> 2] <= 0) {
   break label$1;
  }
  if (!HEAPU8[$3 + 177 | 0]) {
   sqlite3MayAbort($0);
   if ($1) {
    HEAP32[$0 + 192 >> 2] = HEAP32[$1 + 4 >> 2] + (HEAP32[$1 >> 2] - HEAP32[$0 + 188 >> 2] | 0);
   }
   HEAP32[$2 + 48 >> 2] = $0 + 188;
   $5 = sqlite3MPrintf($3, 18563, $2 + 48 | 0);
   $1 = HEAP32[$3 + 16 >> 2];
   $6 = sqlite3SchemaToIndex($3, HEAP32[$4 + 60 >> 2]);
   $7 = HEAP32[$1 + ($6 << 4) >> 2];
   $1 = HEAP32[$4 >> 2];
   HEAP32[$2 + 32 >> 2] = HEAP32[$0 + 88 >> 2];
   HEAP32[$2 + 28 >> 2] = $5;
   HEAP32[$2 + 24 >> 2] = $1;
   HEAP32[$2 + 20 >> 2] = $1;
   HEAP32[$2 + 16 >> 2] = $7;
   sqlite3NestedParse($0, 16249, $2 + 16 | 0);
   $1 = sqlite3GetVdbe($0);
   sqlite3ChangeCookie($0, $6);
   sqlite3VdbeAddOp0($1, 166);
   $7 = HEAP32[$4 >> 2];
   HEAP32[$2 + 4 >> 2] = $5;
   HEAP32[$2 >> 2] = $7;
   sqlite3VdbeAddParseSchemaOp($1, $6, sqlite3MPrintf($3, 19059, $2), 0);
   sqlite3DbFree($3, $5);
   $3 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $3;
   sqlite3VdbeLoadString($1, $3, HEAP32[$4 >> 2]);
   sqlite3VdbeAddOp2($1, 171, $6, $3);
   break label$1;
  }
  $1 = HEAP32[$4 >> 2];
  $5 = HEAP32[$4 + 60 >> 2];
  sqlite3MarkAllShadowTablesOf($3, $4);
  if (sqlite3HashInsert($5 + 8 | 0, $1, $4)) {
   sqlite3OomFault($3);
   break label$1;
  }
  HEAP32[$0 + 236 >> 2] = 0;
 }
 __stack_pointer = $2 - -64 | 0;
}

function pragmaVtabFilter($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0;
 $1 = __stack_pointer - 80 | 0;
 __stack_pointer = $1;
 $2 = HEAP32[$0 >> 2];
 pragmaVtabCursorClear($0);
 $7 = ($3 | 0) > 0 ? $3 : 0;
 $3 = (HEAPU8[HEAP32[$2 + 16 >> 2] + 5 | 0] ^ -1) >>> 5 & 1;
 label$1: {
  label$2: {
   while (1) {
    if (($5 | 0) != ($7 | 0)) {
     $6 = sqlite3_value_text(HEAP32[($5 << 2) + $4 >> 2]);
     if ($6) {
      HEAP32[$1 + 48 >> 2] = $6;
      $6 = sqlite3_mprintf(8342, $1 + 48 | 0);
      HEAP32[(($3 << 2) + $0 | 0) + 16 >> 2] = $6;
      if (!$6) {
       break label$2;
      }
     }
     $3 = $3 + 1 | 0;
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   sqlite3StrAccumInit($1 + 56 | 0, 0, 0, 0, HEAP32[HEAP32[$2 + 12 >> 2] + 124 >> 2]);
   sqlite3_str_appendall($1 + 56 | 0, 29486);
   $5 = HEAP32[$0 + 20 >> 2];
   if ($5) {
    HEAP32[$1 + 32 >> 2] = $5;
    sqlite3_str_appendf($1 + 56 | 0, 24258, $1 + 32 | 0);
   }
   sqlite3_str_appendall($1 + 56 | 0, HEAP32[HEAP32[$2 + 16 >> 2] >> 2]);
   $5 = HEAP32[$0 + 16 >> 2];
   if ($5) {
    HEAP32[$1 + 16 >> 2] = $5;
    sqlite3_str_appendf($1 + 56 | 0, 19119, $1 + 16 | 0);
   }
   $3 = sqlite3StrAccumFinish($1 + 56 | 0);
   if (!$3) {
    break label$2;
   }
   $5 = sqlite3_prepare_v2(HEAP32[$2 + 12 >> 2], $3, -1, $0 + 4 | 0, 0);
   sqlite3_free($3);
   if ($5) {
    HEAP32[$1 >> 2] = sqlite3_errmsg(HEAP32[$2 + 12 >> 2]);
    HEAP32[$2 + 8 >> 2] = sqlite3_mprintf(8342, $1);
    break label$1;
   }
   $5 = pragmaVtabNext($0);
   break label$1;
  }
  $5 = 7;
 }
 __stack_pointer = $1 + 80 | 0;
 return $5 | 0;
}

function clearCellOverflow($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  $1 = HEAPU16[$2 + 18 >> 1] + $1 | 0;
  if ($1 >>> 0 > HEAPU32[$0 + 60 >> 2]) {
   $2 = sqlite3CorruptError(73583);
   break label$1;
  }
  $1 = sqlite3Get4byte($1 - 4 | 0);
  $5 = HEAPU16[$2 + 16 >> 1] ^ -1;
  $6 = HEAP32[$2 + 12 >> 2];
  $4 = HEAP32[$0 + 52 >> 2];
  $2 = HEAP32[$4 + 40 >> 2] - 4 | 0;
  $0 = ($5 + ($6 + $2 | 0) >>> 0) / ($2 >>> 0) | 0;
  while (1) {
   if (!$0) {
    $2 = 0;
    break label$1;
   }
   HEAP32[$3 + 12 >> 2] = 0;
   HEAP32[$3 + 8 >> 2] = 0;
   label$5: {
    if ($1 >>> 0 >= 2) {
     if (btreePagecount($4) >>> 0 >= $1 >>> 0) {
      break label$5;
     }
    }
    $2 = sqlite3CorruptError(73600);
    break label$1;
   }
   label$7: {
    label$8: {
     label$9: {
      $0 = $0 - 1 | 0;
      if ($0) {
       $2 = getOverflowPage($4, $1, $3 + 8 | 0, $3 + 12 | 0);
       if ($2) {
        break label$1;
       }
       $2 = HEAP32[$3 + 8 >> 2];
       if ($2) {
        break label$9;
       }
      }
      $2 = btreePageLookup($4, $1);
      HEAP32[$3 + 8 >> 2] = $2;
      if ($2) {
       break label$9;
      }
      $2 = 0;
      break label$8;
     }
     if ((sqlite3PagerPageRefcount(HEAP32[$2 + 72 >> 2]) | 0) == 1) {
      break label$8;
     }
     $2 = sqlite3CorruptError(73620);
     break label$7;
    }
    $2 = freePage2($4, $2, $1);
   }
   $1 = HEAP32[$3 + 8 >> 2];
   if ($1) {
    sqlite3PagerUnref(HEAP32[$1 + 72 >> 2]);
   }
   if ($2) {
    break label$1;
   }
   $1 = HEAP32[$3 + 12 >> 2];
   continue;
  }
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function fts3RepackSegdirLevel($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = 0;
 HEAP32[$5 + 8 >> 2] = 0;
 label$1: {
  $3 = fts3SqlStmt($0, 35, $5 + 12 | 0, 0);
  if ($3) {
   break label$1;
  }
  $4 = HEAP32[$5 + 12 >> 2];
  sqlite3_bind_int64($4, 1, $1, $2);
  while (1) {
   label$3: {
    $10 = sqlite3_step($4);
    if (($10 | 0) == 100) {
     if (($8 | 0) < ($6 | 0)) {
      $3 = $9;
      break label$3;
     }
     $6 = $6 + 16 | 0;
     $3 = sqlite3_realloc($9, $6 << 2);
     if ($3) {
      break label$3;
     }
     $11 = 7;
    }
    $3 = (wasm2js_i32$0 = $11, wasm2js_i32$1 = sqlite3_reset($4), wasm2js_i32$2 = ($10 | 0) == 100, 
    wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
    if ($3) {
     break label$1;
    }
    $3 = 0;
    $4 = fts3SqlStmt($0, 31, $5 + 8 | 0, 0);
    if ($4) {
     $3 = $4;
     break label$1;
    }
    sqlite3_bind_int64(HEAP32[$5 + 8 >> 2], 2, $1, $2);
    break label$1;
   }
   HEAP32[($8 << 2) + $3 >> 2] = sqlite3_column_int($4, 0);
   $8 = $8 + 1 | 0;
   $9 = $3;
   continue;
  }
 }
 HEAP8[$0 + 240 | 0] = 1;
 $4 = HEAP32[$5 + 8 >> 2];
 while (1) {
  if (!($7 >>> 0 >= $8 >>> 0 | $3)) {
   $3 = 0;
   $6 = HEAP32[($7 << 2) + $9 >> 2];
   if (($6 | 0) != ($7 | 0)) {
    sqlite3_bind_int($4, 3, $6);
    sqlite3_bind_int($4, 1, $7);
    sqlite3_step($4);
    $3 = sqlite3_reset($4);
   }
   $7 = $7 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP8[$0 + 240 | 0] = 0;
 sqlite3_free($9);
 __stack_pointer = $5 + 16 | 0;
 return $3;
}

function log1p($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  $2 = $3;
  label$2: {
   label$3: {
    label$4: {
     if (!($2 >>> 0 > 1071284857 & (($2 | 0) > 0 | ($2 | 0) >= 0))) {
      if ($2 >>> 0 >= 3220176896) {
       $1 = -infinity;
       if ($0 == -1) {
        break label$2;
       }
       return ($0 - $0) / 0;
      }
      if ($2 << 1 >>> 0 < 2034237440) {
       break label$1;
      }
      if ($2 >>> 0 >= 3218259653) {
       break label$4;
      }
      $1 = 0;
      break label$3;
     }
     if ($2 >>> 0 > 2146435071) {
      break label$1;
     }
    }
    $1 = $0 + 1;
    wasm2js_scratch_store_f64(+$1);
    $3 = wasm2js_scratch_load_i32(1) | 0;
    $4 = wasm2js_scratch_load_i32(0) | 0;
    $2 = $3 + 614242 | 0;
    $8 = $2 >>> 0 <= 1129316351 ? ($2 >>> 0 > 1074790399 ? $0 - $1 + 1 : $0 - ($1 + -1)) / $1 : 0;
    $3 = ($2 & 1048575) + 1072079006 | 0;
    wasm2js_scratch_store_i32(0, $4 | 0);
    $4 = $3;
    $3 = 0;
    wasm2js_scratch_store_i32(1, $4 | $3);
    $0 = +wasm2js_scratch_load_f64() + -1;
    $1 = +(($2 >>> 20 | 0) - 1023 | 0);
   }
   $6 = $1;
   $1 = $0 / ($0 + 2);
   $9 = $1;
   $7 = $0 * ($0 * .5);
   $5 = $1 * $1;
   $1 = $5 * $5;
   $1 = $6 * .6931471803691238 + ($0 + ($9 * ($7 + ($1 * ($1 * ($1 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $5 * ($1 * ($1 * ($1 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) + ($6 * 1.9082149292705877e-10 + $8) - $7));
  }
  return $1;
 }
 return $0;
}

function sqlite3GetVarint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $2 = HEAPU8[$0 | 0];
 $3 = $2 << 24 >> 24;
 label$1: {
  if (($3 | 0) >= 0) {
   $5 = 1;
   break label$1;
  }
  $4 = HEAP8[$0 + 1 | 0];
  if (($4 | 0) >= 0) {
   $2 = $3 & 127;
   $0 = $2 << 7;
   $2 = $2 >>> 25 | 0;
   $7 = $2;
   $5 = 2;
   $2 = $0 | $4 & 255;
   break label$1;
  }
  $4 = $4 & 255;
  $3 = HEAP8[$0 + 2 | 0];
  $2 = ($3 & 127 | $2 << 14) & 2080895;
  if (($3 | 0) >= 0) {
   $5 = 3;
   $2 = $4 << 7 & 16256 | $2;
   break label$1;
  }
  $5 = $4 << 14;
  $4 = HEAP8[$0 + 3 | 0];
  $3 = ($5 | $4 & 127) & 2080895;
  if (($4 | 0) >= 0) {
   $5 = 4;
   $2 = $2 << 7 | $3;
   break label$1;
  }
  $4 = HEAPU8[$0 + 4 | 0];
  $6 = $4 | $2 << 14;
  $4 = $4 << 24 >> 24;
  if (($4 | 0) >= 0) {
   $7 = $2 >>> 18 | 0;
   $5 = 5;
   $2 = $3 << 7 | $6;
   break label$1;
  }
  $8 = HEAP8[$0 + 5 | 0];
  $9 = $8 & 255 | $3 << 14;
  $2 = $2 << 7 | $3;
  if (($8 | 0) >= 0) {
   $2 = $2 >>> 18 | 0;
   $7 = $2;
   $5 = 6;
   $2 = $9 | $6 << 7 & 266354560;
   break label$1;
  }
  $3 = HEAP8[$0 + 6 | 0];
  $6 = $3 & 255 | $6 << 14;
  if (($3 | 0) >= 0) {
   $2 = $2 >>> 11 | 0;
   $7 = $2;
   $5 = 7;
   $2 = $6 & -266354561 | $9 << 7 & 266354560;
   break label$1;
  }
  $3 = HEAP8[$0 + 7 | 0];
  $8 = $3 & 255 | $9 << 14;
  $6 = $6 & 2080895;
  if (($3 | 0) >= 0) {
   $7 = $2 >>> 4 | 0;
   $5 = 8;
   $2 = $8 & -266354561 | $6 << 7;
   break label$1;
  }
  $2 = $4 >>> 3 & 15 | $2 << 4;
  $7 = $2;
  $5 = 9;
  $2 = $8 << 8 & 532709120 | (HEAPU8[$0 + 8 | 0] | $6 << 15);
 }
 HEAP32[$1 >> 2] = $2;
 HEAP32[$1 + 4 >> 2] = $7;
 $0 = $5;
 return $0;
}

function sqlite3StrAccumEnlarge($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (!HEAPU8[$0 + 20 | 0]) {
   $3 = HEAP32[$0 + 12 >> 2];
   if (!$3) {
    sqlite3StrAccumSetError($0, 18);
    return HEAP32[$0 + 8 >> 2] + (HEAP32[$0 + 16 >> 2] ^ -1) | 0;
   }
   $8 = HEAPU8[$0 + 21 | 0] & 4 ? HEAP32[$0 + 4 >> 2] : $8;
   $2 = HEAP32[$0 + 16 >> 2];
   $5 = $2;
   $2 = $1;
   $4 = $2 >> 31;
   $7 = $4;
   $4 = $2;
   $6 = $5 + $2 | 0;
   $2 = $7;
   $7 = $6 >>> 0 < $4 >>> 0 ? $2 + 1 | 0 : $2;
   $4 = $6;
   $6 = $7;
   $2 = $4 + 1 | 0;
   $6 = $2 ? $6 : $6 + 1 | 0;
   $4 = $2;
   $7 = $2;
   $2 = $6;
   $5 = $4 + $5 | 0;
   $2 = $4 >>> 0 > $5 >>> 0 ? $2 + 1 | 0 : $2;
   $4 = $3 >>> 0 < $5 >>> 0 & ($2 | 0) >= 0 | ($2 | 0) > 0;
   $7 = $4 ? $7 : $5;
   $5 = $7;
   $4 = $4 ? $6 : $2;
   if ($5 >>> 0 > $3 >>> 0 & ($4 | 0) >= 0 | ($4 | 0) > 0) {
    sqlite3_str_reset($0);
    sqlite3StrAccumSetError($0, 18);
    return 0;
   }
   HEAP32[$0 + 8 >> 2] = $5;
   $4 = 0;
   $3 = HEAP32[$0 >> 2];
   label$6: {
    if ($3) {
     $3 = sqlite3DbRealloc($3, $8, $5, $4);
     break label$6;
    }
    $3 = sqlite3Realloc($8, $5, $4);
   }
   if (!$3) {
    break label$1;
   }
   label$8: {
    if (HEAPU8[$0 + 21 | 0] & 4) {
     break label$8;
    }
    $8 = HEAP32[$0 + 16 >> 2];
    if (!$8) {
     break label$8;
    }
    __memcpy($3, HEAP32[$0 + 4 >> 2], $8);
   }
   HEAP32[$0 + 4 >> 2] = $3;
   HEAP32[$0 + 8 >> 2] = sqlite3DbMallocSize(HEAP32[$0 >> 2], $3);
   HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] | 4;
   $3 = $1;
  }
  return $3;
 }
 sqlite3_str_reset($0);
 sqlite3StrAccumSetError($0, 7);
 return 0;
}

function sqlite3DropIndex($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 $5 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$5 + 87 | 0]) {
   break label$1;
  }
  if (sqlite3ReadSchema($0)) {
   break label$1;
  }
  $4 = sqlite3FindIndex($5, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]);
  if (!$4) {
   label$3: {
    if (!$2) {
     HEAP32[$3 >> 2] = $1 + 8;
     sqlite3ErrorMsg($0, 18745, $3);
     break label$3;
    }
    sqlite3CodeVerifyNamedSchema($0, HEAP32[$1 + 12 >> 2]);
    sqlite3ForceNotReadOnly($0);
   }
   HEAP8[$0 + 17 | 0] = 1;
   break label$1;
  }
  if (HEAPU8[$4 + 55 | 0] & 3) {
   HEAP32[$3 + 32 >> 2] = 0;
   sqlite3ErrorMsg($0, 15147, $3 + 32 | 0);
   break label$1;
  }
  $6 = HEAP32[$4 + 12 >> 2];
  $2 = sqlite3SchemaToIndex($5, HEAP32[$4 + 24 >> 2]);
  $7 = ($2 | 0) == 1;
  $8 = HEAP32[HEAP32[$5 + 16 >> 2] + ($2 << 4) >> 2];
  if (sqlite3AuthCheck($0, 9, $7 ? 8671 : 8690, 0, $8)) {
   break label$1;
  }
  if (sqlite3AuthCheck($0, $7 ? 12 : 10, HEAP32[$4 >> 2], HEAP32[$6 >> 2], $8)) {
   break label$1;
  }
  $6 = sqlite3GetVdbe($0);
  if (!$6) {
   break label$1;
  }
  sqlite3BeginWriteOperation($0, 1, $2);
  $7 = HEAP32[HEAP32[$5 + 16 >> 2] + ($2 << 4) >> 2];
  HEAP32[$3 + 20 >> 2] = HEAP32[$4 >> 2];
  HEAP32[$3 + 16 >> 2] = $7;
  sqlite3NestedParse($0, 26987, $3 + 16 | 0);
  sqlite3ClearStatTables($0, $2, 1545, HEAP32[$4 >> 2]);
  sqlite3ChangeCookie($0, $2);
  destroyRootPage($0, HEAP32[$4 + 44 >> 2], $2);
  sqlite3VdbeAddOp4($6, 152, $2, 0, 0, HEAP32[$4 >> 2], 0);
 }
 sqlite3SrcListDelete($5, $1);
 __stack_pointer = $3 + 48 | 0;
}

function strfilterFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (($1 | 0) == 2) {
   label$3: {
    if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
     if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
      break label$3;
     }
    }
    sqlite3_result_null($0);
    return;
   }
   $4 = sqlite3_value_text(HEAP32[$2 >> 2]);
   $8 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
   $6 = sqlite3_malloc(strlen($4) + 1 | 0);
   if (!$6) {
    break label$1;
   }
   $7 = $6;
   while (1) {
    $3 = $8;
    $5 = sqlite3ReadUtf8($4);
    if ($5) {
     while (1) {
      $2 = sqlite3ReadUtf8($3);
      if (!(!$2 | ($2 | 0) == ($5 | 0))) {
       $2 = $3;
       while (1) {
        $1 = HEAPU8[$2 + 1 | 0];
        $3 = $2 + 1 | 0;
        $2 = $3;
        if (($1 & 192) == 128) {
         continue;
        }
        break;
       }
       continue;
      }
      break;
     }
     $1 = $3;
     if ($2) {
      while (1) {
       $2 = HEAPU8[$1 + 1 | 0];
       $5 = $1 + 1 | 0;
       $1 = $5;
       if (($2 & 192) == 128) {
        continue;
       }
       break;
      }
      $2 = $5 - $3 | 0;
      $7 = $2 + strncpy($7, $3, $2) | 0;
     }
     while (1) {
      $2 = HEAPU8[$4 + 1 | 0];
      $1 = $4 + 1 | 0;
      $4 = $1;
      if (($2 & 192) == 128) {
       continue;
      }
      break;
     }
     $4 = $1;
     continue;
    }
    break;
   }
   HEAP8[$7 | 0] = 0;
   sqlite3_result_text($0, $6, -1, -1);
   sqlite3_free($6);
   return;
  }
  __assert_fail(23018, 17353, 939, 17075);
  abort();
 }
 sqlite3_result_error_nomem($0);
}

function sqlite3ExpandReturning($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $7 = HEAP32[$0 >> 2];
 while (1) {
  if (HEAP32[$1 >> 2] > ($8 | 0)) {
   $4 = ($8 << 4) + $1 | 0;
   $3 = HEAP32[$4 + 8 >> 2];
   label$3: {
    if (!$3) {
     break label$3;
    }
    $5 = 0;
    if (isAsteriskTerm($0, $3)) {
     while (1) {
      if (HEAP16[$2 + 34 >> 1] <= ($5 | 0)) {
       break label$3;
      }
      $4 = Math_imul($5, 12);
      $3 = $4 + HEAP32[$2 + 4 >> 2] | 0;
      label$6: {
       if (HEAPU8[$3 + 10 | 0] & 2) {
        break label$6;
       }
       $6 = sqlite3ExprListAppend($0, $6, sqlite3Expr($7, 59, HEAP32[$3 >> 2]));
       if (HEAPU8[$7 + 87 | 0]) {
        break label$6;
       }
       $3 = (HEAP32[$6 >> 2] << 4) + $6 | 0;
       HEAP32[$3 - 4 >> 2] = sqlite3DbStrDup($7, HEAP32[HEAP32[$2 + 4 >> 2] + $4 >> 2]);
       $4 = $3;
       $3 = $3 + 1 | 0;
       $4 = (HEAPU8[$4 + 1 | 0] | HEAPU8[$4 + 2 | 0] << 8) & 65532;
       HEAP8[$3 | 0] = $4;
       HEAP8[$3 + 1 | 0] = $4 >>> 8;
      }
      $5 = $5 + 1 | 0;
      continue;
     }
    }
    $6 = sqlite3ExprListAppend($0, $6, sqlite3ExprDup($7, $3, 0));
    if (HEAPU8[$7 + 87 | 0]) {
     break label$3;
    }
    $5 = HEAP32[$4 + 12 >> 2];
    if (!$5) {
     break label$3;
    }
    $3 = (HEAP32[$6 >> 2] << 4) + $6 | 0;
    HEAP32[$3 - 4 >> 2] = sqlite3DbStrDup($7, $5);
    $5 = $3 + 1 | 0;
    $4 = (HEAPU8[$3 + 1 | 0] | HEAPU8[$3 + 2 | 0] << 8) & 65532 | (HEAPU8[$4 + 17 | 0] | HEAPU8[$4 + 18 | 0] << 8) & 3;
    HEAP8[$5 | 0] = $4;
    HEAP8[$5 + 1 | 0] = $4 >>> 8;
   }
   $8 = $8 + 1 | 0;
   continue;
  }
  break;
 }
 return $6;
}

function padrFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (($1 | 0) == 2) {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
    sqlite3_result_null($0);
    return;
   }
   $1 = sqlite3_value_text(HEAP32[$2 >> 2]);
   $5 = sqlite3_value_int64(HEAP32[$2 + 4 >> 2]);
   $4 = i64toi32_i32$HIGH_BITS;
   $3 = $4;
   if (($4 | 0) < 0) {
    sqlite3_result_error($0, 8544, -1);
    return;
   }
   $2 = sqlite3Utf8CharLen_1($1);
   $4 = $2 >> 31;
   $7 = $2;
   $6 = $4;
   label$5: {
    if (($3 | 0) <= ($4 | 0) & $5 >>> 0 <= $2 >>> 0 | ($4 | 0) > ($3 | 0)) {
     $1 = sqlite3StrDup($1);
     if (!$1) {
      break label$1;
     }
     sqlite3_result_text($0, $1, -1, -1);
     break label$5;
    }
    $4 = $5 - $2 | 0;
    $2 = strlen($1);
    $8 = sqlite3_malloc(($4 + $2 | 0) + 1 | 0);
    if (!$8) {
     break label$1;
    }
    $6 = $6 + ($5 >>> 0 < $7 >>> 0) | 0;
    $6 = $3 - $6 | 0;
    $4 = $7;
    $3 = $5 - $4 | 0;
    $5 = $3;
    $3 = $6;
    $4 = $5 + 1 | 0;
    $3 = $4 ? $3 : $3 + 1 | 0;
    $7 = $4;
    $6 = $3;
    $1 = strcpy($8, $1);
    $2 = $2 + $1 | 0;
    $5 = 1;
    $3 = 0;
    while (1) {
     $4 = $7;
     if (!(($4 | 0) == ($5 | 0) & ($6 | 0) == ($3 | 0))) {
      HEAP8[$2 | 0] = 32;
      $5 = $5 + 1 | 0;
      $4 = $5 ? $3 : $3 + 1 | 0;
      $3 = $4;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP8[$2 | 0] = 0;
   }
   sqlite3_result_text($0, $1, -1, -1);
   sqlite3_free($1);
   return;
  }
  __assert_fail(23018, 17353, 825, 17100);
  abort();
 }
 sqlite3_result_error_nomem($0);
}

function fts3TruncateNode($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = __stack_pointer - 80 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 24 >> 2] = 0;
 HEAP32[$6 + 16 >> 2] = 0;
 HEAP32[$6 + 20 >> 2] = 0;
 HEAP32[$6 + 12 >> 2] = 0;
 label$1: {
  if (($1 | 0) <= 0) {
   $8 = 267;
   break label$1;
  }
  $7 = HEAPU8[$0 | 0];
  blobGrowBuffer($2, $1, $6 + 12 | 0);
  $8 = HEAP32[$6 + 12 >> 2];
  if ($8) {
   break label$1;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  $8 = nodeReaderInit($6 + 32 | 0, $0, $1);
  $11 = ($7 & 255) != 0;
  while (1) {
   label$4: {
    if (!HEAP32[$6 + 32 >> 2] | $8) {
     break label$4;
    }
    $8 = HEAP32[$6 + 60 >> 2];
    $1 = HEAP32[$6 + 56 >> 2];
    label$5: {
     if (!HEAP32[$2 + 4 >> 2]) {
      $7 = fts3TermCmp($1, $8, $3, $4);
      if (($7 | 0) < 0 | !$7 & $11) {
       break label$5;
      }
      $9 = HEAP32[$6 + 48 >> 2];
      $10 = $9;
      $7 = HEAP32[$6 + 52 >> 2];
      fts3StartNode($2, HEAP8[$0 | 0], $9, $7);
      $9 = $5;
      HEAP32[$9 >> 2] = $10;
      HEAP32[$9 + 4 >> 2] = $7;
     }
     $8 = fts3AppendToNode($2, $6 + 16 | 0, $1, $8, HEAP32[$6 + 68 >> 2], HEAP32[$6 + 72 >> 2]);
     if ($8) {
      break label$4;
     }
    }
    $8 = nodeReaderNext($6 + 32 | 0);
    continue;
   }
   break;
  }
  if (!HEAP32[$2 + 4 >> 2]) {
   $7 = HEAP32[$6 + 48 >> 2];
   $10 = $7;
   $9 = HEAP32[$6 + 52 >> 2];
   fts3StartNode($2, HEAP8[$0 | 0], $7, $9);
   $7 = $5;
   HEAP32[$7 >> 2] = $10;
   HEAP32[$7 + 4 >> 2] = $9;
  }
  nodeReaderRelease($6 + 32 | 0);
  sqlite3_free(HEAP32[$6 + 16 >> 2]);
 }
 __stack_pointer = $6 + 80 | 0;
 return $8;
}

function vdbePmaReaderSeek($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = 266;
 label$1: {
  if (sqlite3FaultSim(201)) {
   break label$1;
  }
  $7 = $1 + 44 | 0;
  if (HEAP32[$1 + 44 >> 2]) {
   HEAP32[$7 >> 2] = 0;
  }
  HEAP32[$1 >> 2] = $3;
  $5 = $4;
  HEAP32[$1 + 4 >> 2] = $5;
  $6 = HEAP32[$2 + 12 >> 2];
  $5 = HEAP32[$2 + 8 >> 2];
  HEAP32[$1 + 8 >> 2] = $5;
  HEAP32[$1 + 12 >> 2] = $6;
  HEAP32[$1 + 24 >> 2] = HEAP32[$2 >> 2];
  vdbeSorterMapFile($0, $2, $7);
  $7 = 0;
  if (HEAP32[$1 + 44 >> 2]) {
   break label$1;
  }
  $6 = HEAP32[$1 >> 2];
  $3 = $6;
  $5 = HEAP32[$1 + 4 >> 2];
  $2 = $5;
  $0 = HEAP32[HEAP32[$0 + 8 >> 2] + 12 >> 2];
  $6 = $0;
  $5 = $6 >> 31;
  $8 = $6;
  $9 = $5;
  $5 = $2;
  $6 = $9;
  $6 = __wasm_i64_srem($3, $5, $0, $6);
  $3 = $6;
  $5 = i64toi32_i32$HIGH_BITS;
  $4 = $5;
  $2 = HEAP32[$1 + 36 >> 2];
  if (!$2) {
   $5 = $9;
   $2 = sqlite3Malloc($8, $5);
   HEAP32[$1 + 40 >> 2] = $0;
   HEAP32[$1 + 36 >> 2] = $2;
   $7 = $2 ? 0 : 7;
  }
  if ($7) {
   break label$1;
  }
  $10 = $3;
  if (!$3) {
   break label$1;
  }
  $11 = HEAP32[$1 + 24 >> 2];
  $5 = HEAP32[$1 + 8 >> 2];
  $8 = $5;
  $6 = HEAP32[$1 + 12 >> 2];
  $9 = $6;
  $5 = HEAP32[$1 + 4 >> 2];
  $4 = $5;
  $6 = HEAP32[$1 >> 2];
  $3 = $6;
  $7 = $8 - $6 | 0;
  $5 = $9;
  $6 = $4;
  $12 = $7;
  $1 = $0 - $10 | 0;
  $7 = $6 + ($1 >> 31) | 0;
  $5 = $3;
  $6 = $5 + $1 | 0;
  $7 = $1 >>> 0 > $6 >>> 0 ? $7 + 1 | 0 : $7;
  $5 = $9;
  $7 = sqlite3OsRead($11, $2 + $10 | 0, $6 >>> 0 > $8 >>> 0 & ($7 | 0) >= ($5 | 0) | ($7 | 0) > ($5 | 0) ? $12 : $1, $3, $4);
 }
 return $7;
}

function sqlite3ExprCodeExprList($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $11 = $3 - 1 | 0;
 $3 = $1 + 8 | 0;
 $5 = HEAPU8[$0 + 23 | 0] ? $4 : $4 & 253;
 $12 = $5 & 2;
 $13 = $5 & 8;
 $14 = $5 & 4;
 $5 = HEAP32[$1 >> 2];
 $8 = HEAP32[$0 + 8 >> 2];
 $1 = 0;
 $9 = $4 & 1 ^ 81;
 $15 = ($9 | 0) != 80;
 while (1) {
  if (($1 | 0) < ($5 | 0)) {
   $4 = HEAP32[$3 >> 2];
   label$3: {
    label$4: {
     if (!$14) {
      break label$4;
     }
     $6 = HEAPU16[$3 + 12 >> 1];
     if (!$6) {
      break label$4;
     }
     if ($13) {
      $5 = $5 - 1 | 0;
      $1 = $1 - 1 | 0;
      break label$3;
     }
     sqlite3VdbeAddOp2($8, $9, $6 + $11 | 0, $1 + $2 | 0);
     break label$3;
    }
    label$6: {
     if (!$12) {
      break label$6;
     }
     if (!sqlite3ExprIsConstantNotJoin($4)) {
      break label$6;
     }
     sqlite3ExprCodeRunJustOnce($0, $4, $1 + $2 | 0);
     break label$3;
    }
    $6 = $1 + $2 | 0;
    $4 = sqlite3ExprCodeTarget($0, $4, $6);
    if (($4 | 0) == ($6 | 0)) {
     break label$3;
    }
    label$7: {
     if ($15) {
      break label$7;
     }
     $7 = sqlite3VdbeGetOp($8, -1);
     if (HEAPU8[$7 | 0] != 80) {
      break label$7;
     }
     $10 = HEAP32[$7 + 12 >> 2] + 1 | 0;
     if (HEAPU16[$7 + 2 >> 1] | (($10 + HEAP32[$7 + 4 >> 2] | 0) != ($4 | 0) | (HEAP32[$7 + 8 >> 2] + $10 | 0) != ($6 | 0))) {
      break label$7;
     }
     HEAP32[$7 + 12 >> 2] = $10;
     break label$3;
    }
    sqlite3VdbeAddOp2($8, $9, $4, $6);
   }
   $3 = $3 + 16 | 0;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
}

function createTableStmt($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $5 = HEAP16[$1 + 34 >> 1];
 $7 = ($5 | 0) > 0 ? $5 : 0;
 $4 = HEAP32[$1 + 4 >> 2];
 while (1) {
  if (($2 | 0) != ($7 | 0)) {
   $2 = $2 + 1 | 0;
   $6 = (identLength(HEAP32[$4 >> 2]) + $6 | 0) + 5 | 0;
   $4 = $4 + 12 | 0;
   continue;
  }
  break;
 }
 $2 = identLength(HEAP32[$1 >> 2]) + $6 | 0;
 $8 = ($2 + Math_imul($5, 6) | 0) + 35 | 0;
 $9 = sqlite3DbMallocRaw(0, $8, $8 >> 31);
 label$3: {
  if (!$9) {
   sqlite3OomFault($0);
   break label$3;
  }
  $2 = ($2 | 0) < 50;
  $11 = $2 ? 26910 : 26909;
  $12 = $2 ? 24271 : 29595;
  $6 = sqlite3_snprintf($8, $9, 29454, 0);
  HEAP32[$3 + 12 >> 2] = sqlite3Strlen30($6);
  identPut($6, $3 + 12 | 0, HEAP32[$1 >> 2]);
  $4 = HEAP32[$3 + 12 >> 2];
  HEAP8[$6 + $4 | 0] = 40;
  $10 = $2 ? 29623 : 29596;
  $2 = $4 + 1 | 0;
  $4 = HEAP32[$1 + 4 >> 2];
  $7 = 0;
  while (1) {
   $5 = $2 + $6 | 0;
   $0 = $8 - $2 | 0;
   if (($7 | 0) < HEAP16[$1 + 34 >> 1]) {
    HEAP32[$3 + 12 >> 2] = sqlite3Strlen30(sqlite3_snprintf($0, $5, $10, 0)) + $2;
    identPut($6, $3 + 12 | 0, HEAP32[$4 >> 2]);
    $5 = HEAP32[$3 + 12 >> 2];
    $2 = HEAP32[(HEAP8[$4 + 5 | 0] << 2) + 48636 >> 2];
    $0 = sqlite3Strlen30($2);
    __memcpy($5 + $6 | 0, $2, $0);
    $2 = $0 + $5 | 0;
    HEAP32[$3 + 12 >> 2] = $2;
    $4 = $4 + 12 | 0;
    $7 = $7 + 1 | 0;
    $10 = $12;
    continue;
   }
   break;
  }
  HEAP32[$3 >> 2] = $11;
  sqlite3_snprintf($0, $5, 8342, $3);
 }
 __stack_pointer = $3 + 16 | 0;
 return $9;
}

function resolveOrderGroupBy($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $6 = $2 + 8 | 0;
 $10 = HEAP32[$0 >> 2];
 $11 = HEAP32[HEAP32[$1 + 28 >> 2] >> 2];
 label$1: {
  while (1) {
   if (HEAP32[$2 >> 2] > ($9 | 0)) {
    $8 = HEAP32[$6 >> 2];
    $5 = sqlite3ExprSkipCollateAndLikely($8);
    label$4: {
     if (!$5) {
      break label$4;
     }
     label$5: {
      if (HEAPU8[$3 | 0] != 71) {
       $4 = resolveAsName(HEAP32[$1 + 28 >> 2], $5);
       HEAP32[$7 + 12 >> 2] = $4;
       if (($4 | 0) > 0) {
        break label$5;
       }
      }
      if (sqlite3ExprIsInteger($5, $7 + 12 | 0)) {
       $4 = HEAP32[$7 + 12 >> 2];
       if ($4 - 65536 >>> 0 > 4294901760) {
        break label$5;
       }
       resolveOutOfRangeError($10, $3, $9 + 1 | 0, $11, $5);
       $4 = 1;
       break label$1;
      }
      $5 = 0;
      HEAP16[$6 + 12 >> 1] = 0;
      $4 = 1;
      if (sqlite3ResolveExprNames($0, $8)) {
       break label$1;
      }
      while (1) {
       $4 = HEAP32[$1 + 28 >> 2];
       if (HEAP32[$4 >> 2] <= ($5 | 0)) {
        break label$4;
       }
       if (!sqlite3ExprCompare(0, $8, HEAP32[(($5 << 4) + $4 | 0) + 8 >> 2], -1)) {
        windowRemoveExprFromSelect($1, $8);
        HEAP16[$6 + 12 >> 1] = $5 + 1;
       }
       $5 = $5 + 1 | 0;
       continue;
      }
     }
     HEAP16[$6 + 12 >> 1] = $4;
    }
    $6 = $6 + 16 | 0;
    $9 = $9 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = sqlite3ResolveOrderGroupBy($10, $1, $2, $3);
 }
 __stack_pointer = $7 + 16 | 0;
 return $4;
}

function emscripten_builtin_memalign($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if ($0 >>> 0 <= 8) {
  return dlmalloc($1) | 0;
 }
 $2 = 16;
 $3 = $0 >>> 0 > 16 ? $0 : 16;
 label$2: {
  if (!($3 & $3 - 1)) {
   $0 = $3;
   break label$2;
  }
  while (1) {
   $0 = $2;
   $2 = $0 << 1;
   if ($0 >>> 0 < $3 >>> 0) {
    continue;
   }
   break;
  }
 }
 if (-64 - $0 >>> 0 <= $1 >>> 0) {
  HEAP32[17757] = 48;
  return 0;
 }
 $1 = $1 >>> 0 < 11 ? 16 : $1 + 11 & -8;
 $2 = dlmalloc(($1 + $0 | 0) + 12 | 0);
 if (!$2) {
  return 0;
 }
 $3 = $2 - 8 | 0;
 label$7: {
  if (!($0 - 1 & $2)) {
   $0 = $3;
   break label$7;
  }
  $5 = $2 - 4 | 0;
  $6 = HEAP32[$5 >> 2];
  $2 = (($0 + $2 | 0) - 1 & 0 - $0) - 8 | 0;
  $0 = $2 + ($2 - $3 >>> 0 > 15 ? 0 : $0) | 0;
  $2 = $0 - $3 | 0;
  $4 = ($6 & -8) - $2 | 0;
  if (!($6 & 3)) {
   $3 = HEAP32[$3 >> 2];
   HEAP32[$0 + 4 >> 2] = $4;
   HEAP32[$0 >> 2] = $2 + $3;
   break label$7;
  }
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] & 1 | $4 | 2;
  $4 = $0 + $4 | 0;
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 1;
  HEAP32[$5 >> 2] = HEAP32[$5 >> 2] & 1 | $2 | 2;
  $4 = $2 + $3 | 0;
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 1;
  dispose_chunk($3, $2);
 }
 $2 = HEAP32[$0 + 4 >> 2];
 label$10: {
  if (!($2 & 3)) {
   break label$10;
  }
  $3 = $2 & -8;
  if ($3 >>> 0 <= $1 + 16 >>> 0) {
   break label$10;
  }
  HEAP32[$0 + 4 >> 2] = $2 & 1 | $1 | 2;
  $2 = $0 + $1 | 0;
  $1 = $3 - $1 | 0;
  HEAP32[$2 + 4 >> 2] = $1 | 3;
  $3 = $0 + $3 | 0;
  HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] | 1;
  dispose_chunk($2, $1);
 }
 return $0 + 8 | 0;
}

function sqlite3ExprAffinity($0) {
 var $1 = 0;
 while (1) {
  label$2: {
   if (HEAP32[$0 + 4 >> 2] & 270336) {
    $0 = $0 + 12 | 0;
    break label$2;
   }
   $1 = HEAPU8[$0 | 0];
   if (($1 | 0) == 176) {
    $1 = HEAPU8[$0 + 2 | 0];
   }
   label$4: {
    label$6: {
     label$7: {
      label$8: {
       label$9: {
        label$10: {
         label$11: {
          $1 = $1 & 255;
          switch ($1 - 177 | 0) {
          case 1:
           break label$10;

          case 0:
           break label$9;

          default:
           break label$11;
          }
         }
         if (($1 | 0) != 138) {
          label$13: {
           switch ($1 - 167 | 0) {
           case 0:
           case 2:
            break label$13;

           case 1:
            break label$7;

           default:
            break label$8;
           }
          }
          $1 = HEAP32[$0 + 44 >> 2];
          if (!$1) {
           break label$7;
          }
          $0 = sqlite3TableColumnAffinity($1, HEAP16[$0 + 32 >> 1]);
          break label$4;
         }
         $0 = HEAP32[HEAP32[$0 + 20 >> 2] + 28 >> 2] + 8 | 0;
         break label$2;
        }
        $0 = (HEAP32[HEAP32[HEAP32[$0 + 12 >> 2] + 20 >> 2] + 28 >> 2] + (HEAP16[$0 + 32 >> 1] << 4) | 0) + 8 | 0;
        break label$2;
       }
       $0 = HEAP32[$0 + 20 >> 2] + 8 | 0;
       break label$2;
      }
      if (($1 | 0) == 36) {
       break label$6;
      }
     }
     $0 = HEAPU8[$0 + 1 | 0];
     break label$4;
    }
    $0 = sqlite3AffinityType(HEAP32[$0 + 8 >> 2], 0);
   }
   return $0 << 24 >> 24;
  }
  $0 = HEAP32[$0 >> 2];
  continue;
 }
}

function seriesFilter($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = 1;
 label$1: {
  if (!($1 & 1)) {
   $5 = 0;
   $2 = 0;
   break label$1;
  }
  $6 = sqlite3_value_int64(HEAP32[$4 >> 2]);
  $2 = i64toi32_i32$HIGH_BITS;
 }
 HEAP32[$0 + 8 >> 2] = $6;
 HEAP32[$0 + 12 >> 2] = $2;
 $6 = -1;
 $2 = 0;
 if ($1 & 2) {
  $2 = sqlite3_value_int64(HEAP32[($5 << 2) + $4 >> 2]);
  $6 = $2;
  $2 = i64toi32_i32$HIGH_BITS;
  $5 = $5 + 1 | 0;
 }
 $7 = $5;
 HEAP32[$0 + 16 >> 2] = $6;
 HEAP32[$0 + 20 >> 2] = $2;
 label$5: {
  if ($1 & 4) {
   $6 = sqlite3_value_int64(HEAP32[($7 << 2) + $4 >> 2]);
   $2 = i64toi32_i32$HIGH_BITS;
   HEAP32[$0 + 24 >> 2] = $6;
   HEAP32[$0 + 28 >> 2] = $2;
   if (!($2 | $6)) {
    HEAP32[$0 + 24 >> 2] = 1;
    HEAP32[$0 + 28 >> 2] = 0;
    break label$5;
   }
   $1 = $1 & 16 ? $1 : ($2 | 0) < 0 ? 8 : $1;
   break label$5;
  }
  HEAP32[$0 + 24 >> 2] = 1;
  HEAP32[$0 + 28 >> 2] = 0;
 }
 $8 = $0 + 8 | 0;
 $5 = 0;
 $7 = ($3 | 0) > 0 ? $3 : 0;
 label$8: {
  while (1) {
   if (($5 | 0) == ($7 | 0)) {
    break label$8;
   }
   $3 = $5 << 2;
   $5 = $5 + 1 | 0;
   if ((sqlite3_value_type(HEAP32[$3 + $4 >> 2]) | 0) != 5) {
    continue;
   }
   break;
  }
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 1;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = 1;
  HEAP32[$0 + 28 >> 2] = 0;
 }
 $2 = HEAP32[$0 + 28 >> 2];
 $6 = HEAP32[$0 + 24 >> 2];
 $3 = !!$6 & ($2 | 0) >= 0 | ($2 | 0) > 0;
 HEAP8[$0 + 57 | 0] = $1 & 8 ? $3 : $2 >>> 31 | 0;
 setupSequence($8);
 return 0;
}

function fts3SegWriterFlush($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 label$1: {
  if (HEAP32[$1 >> 2]) {
   $5 = $7;
   HEAP32[$5 + 8 >> 2] = 0;
   HEAP32[$5 + 12 >> 2] = 0;
   HEAP32[$5 + 4 >> 2] = 0;
   HEAP32[$5 >> 2] = 0;
   $5 = HEAP32[$1 + 20 >> 2];
   $9 = $5;
   $10 = HEAP32[$1 + 16 >> 2];
   $8 = $10 + 1 | 0;
   $6 = $8 ? $5 : $5 + 1 | 0;
   HEAP32[$1 + 16 >> 2] = $8;
   HEAP32[$1 + 20 >> 2] = $6;
   $6 = fts3WriteSegment($0, $10, $5, HEAP32[$1 + 48 >> 2], HEAP32[$1 + 44 >> 2]);
   if ($6) {
    break label$1;
   }
   $5 = $1;
   $6 = HEAP32[$5 + 8 >> 2];
   $11 = $6;
   $6 = HEAP32[$5 + 20 >> 2];
   $8 = $6;
   $6 = HEAP32[$5 + 12 >> 2];
   $6 = fts3NodeWrite($0, HEAP32[$5 >> 2], 1, $11, $6, HEAP32[$5 + 16 >> 2], $8, $7 + 8 | 0, $7 + 4 | 0, $7);
   if ($6) {
    break label$1;
   }
   $6 = HEAP32[$5 + 12 >> 2];
   $12 = $6;
   $5 = $7;
   $6 = HEAP32[$5 + 8 >> 2];
   $11 = $6;
   $13 = HEAP32[$5 + 12 >> 2];
   $5 = $1;
   $14 = HEAP32[$5 + 56 >> 2];
   $6 = HEAP32[$5 + 60 >> 2];
   $8 = $6;
   $6 = $3;
   $5 = $9;
   $6 = fts3WriteSegdir($0, $2, $6, $4, HEAP32[$1 + 8 >> 2], $12, $10, $5, $11, $13, $14, $8, HEAP32[$7 + 4 >> 2], HEAP32[$7 >> 2]);
   break label$1;
  }
  $5 = $1;
  $8 = HEAP32[$5 + 56 >> 2];
  $6 = HEAP32[$5 + 60 >> 2];
  $9 = HEAP32[$5 + 48 >> 2];
  $1 = HEAP32[$5 + 44 >> 2];
  $6 = fts3WriteSegdir($0, $2, $3, $4, 0, 0, 0, 0, 0, 0, $8, $6, $9, $1);
 }
 HEAP32[$0 + 52 >> 2] = HEAP32[$0 + 52 >> 2] + 1;
 __stack_pointer = $7 + 16 | 0;
 return $6;
}

function pageInsertArray($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  if (($5 | 0) <= 0) {
   break label$1;
  }
  $14 = $4 + $5 | 0;
  $8 = HEAP32[$2 >> 2];
  $10 = HEAP32[$0 + 56 >> 2];
  while (1) {
   $5 = $7;
   if (HEAP32[(($5 << 2) + $6 | 0) + 40 >> 2] <= ($4 | 0)) {
    $7 = $5 + 1 | 0;
    if ($5 >>> 0 < 6) {
     continue;
    }
   }
   break;
  }
  $11 = HEAP32[(($5 << 2) + $6 | 0) + 16 >> 2];
  while (1) {
   $7 = HEAPU16[HEAP32[$6 + 12 >> 2] + ($4 << 1) >> 1];
   label$5: {
    label$6: {
     label$7: {
      if (HEAPU8[$10 + 2 | 0] ? 1 : HEAPU8[$10 + 1 | 0]) {
       $12 = pageFindSlot($0, $7, $9 + 12 | 0);
       if ($12) {
        break label$7;
       }
      }
      if (($8 - $1 | 0) < ($7 | 0)) {
       break label$6;
      }
      $8 = $8 - $7 | 0;
      $12 = $8;
     }
     $13 = HEAP32[HEAP32[$6 + 8 >> 2] + ($4 << 2) >> 2];
     if ($13 >>> 0 >= $11 >>> 0 | $7 + $13 >>> 0 <= $11 >>> 0) {
      break label$5;
     }
     sqlite3CorruptError(74276);
    }
    $15 = 1;
    break label$1;
   }
   $7 = memmove($12, $13, $7) - $10 | 0;
   $7 = $7 << 8 | ($7 & 65280) >>> 8;
   HEAP8[$3 | 0] = $7;
   HEAP8[$3 + 1 | 0] = $7 >>> 8;
   $4 = $4 + 1 | 0;
   if (($14 | 0) > ($4 | 0)) {
    if (HEAP32[(($5 << 2) + $6 | 0) + 40 >> 2] <= ($4 | 0)) {
     $5 = $5 + 1 | 0;
     $11 = HEAP32[(($5 << 2) + $6 | 0) + 16 >> 2];
    }
    $3 = $3 + 2 | 0;
    continue;
   }
   break;
  }
  HEAP32[$2 >> 2] = $8;
 }
 __stack_pointer = $9 + 16 | 0;
 return $15;
}

function fts3ContentColumns($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $7 = __stack_pointer - 32 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 16 >> 2] = $1;
 HEAP32[$7 + 28 >> 2] = 0;
 HEAP32[$7 + 20 >> 2] = $2;
 $1 = sqlite3_mprintf(19130, $7 + 16 | 0);
 label$1: {
  if (!$1) {
   $8 = 7;
   break label$1;
  }
  $2 = sqlite3_prepare($0, $1, -1, $7 + 28 | 0, 0);
  if (!$2) {
   break label$1;
  }
  HEAP32[$7 >> 2] = sqlite3_errmsg($0);
  sqlite3Fts3ErrMsg($6, 8342, $7);
  $8 = $2;
 }
 sqlite3_free($1);
 if (!$8) {
  $1 = 0;
  $10 = sqlite3_column_count(HEAP32[$7 + 28 >> 2]);
  $2 = ($10 | 0) > 0 ? $10 : 0;
  while (1) {
   if (($1 | 0) != ($2 | 0)) {
    $6 = strlen(sqlite3_column_name(HEAP32[$7 + 28 >> 2], $1)) + 1 | 0;
    $0 = $6 + $12 | 0;
    $12 = $0;
    $9 = $0 >>> 0 < $6 >>> 0 ? $9 + 1 | 0 : $9;
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  $0 = $9;
  $1 = $10 << 2;
  $6 = $1 + $12 | 0;
  $0 = $6 >>> 0 < $1 >>> 0 ? $0 + 1 | 0 : $0;
  label$6: {
   $11 = sqlite3_malloc64($6, $0);
   if (!$11) {
    $8 = 7;
    break label$6;
   }
   $6 = $1 + $11 | 0;
   $8 = 0;
   $1 = 0;
   while (1) {
    if (($1 | 0) == ($2 | 0)) {
     break label$6;
    }
    $0 = sqlite3_column_name(HEAP32[$7 + 28 >> 2], $1);
    $13 = strlen($0) + 1 | 0;
    $0 = __memcpy($6, $0, $13);
    HEAP32[($1 << 2) + $11 >> 2] = $0;
    $1 = $1 + 1 | 0;
    $6 = $0 + $13 | 0;
    continue;
   }
  }
  sqlite3_finalize(HEAP32[$7 + 28 >> 2]);
  HEAP32[$4 >> 2] = $10;
  HEAP32[$5 >> 2] = $12;
  HEAP32[$3 >> 2] = $11;
 }
 __stack_pointer = $7 + 32 | 0;
 return $8;
}

function isDistinctRedundant($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if (HEAP32[$1 >> 2] != 1) {
   break label$1;
  }
  $4 = HEAP32[$3 >> 2];
  $5 = ($4 | 0) > 0 ? $4 : 0;
  $7 = HEAP32[$1 + 24 >> 2];
  $6 = HEAP32[$1 + 48 >> 2];
  $1 = 0;
  label$2: {
   while (1) {
    if (($1 | 0) != ($5 | 0)) {
     $4 = sqlite3ExprSkipCollateAndLikely(HEAP32[(($1 << 4) + $3 | 0) + 8 >> 2]);
     label$5: {
      if (!$4) {
       break label$5;
      }
      label$6: {
       switch (HEAPU8[$4 | 0] - 167 | 0) {
       case 0:
       case 2:
        break label$6;

       default:
        break label$5;
       }
      }
      if (HEAP32[$4 + 28 >> 2] != ($6 | 0)) {
       break label$5;
      }
      if (HEAP16[$4 + 32 >> 1] < 0) {
       break label$2;
      }
     }
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   $1 = $7 + 8 | 0;
   $5 = 0;
   while (1) {
    $4 = HEAP32[$1 >> 2];
    if (!$4) {
     break label$1;
    }
    if (!(HEAP32[$4 + 36 >> 2] | !HEAPU8[$4 + 54 | 0])) {
     $1 = 0;
     while (1) {
      label$10: {
       if (HEAPU16[$4 + 50 >> 1] <= $1 >>> 0) {
        break label$10;
       }
       if (!sqlite3WhereFindTerm($2, $6, $1, -1, -1, 2, $4)) {
        if ((findIndexCol($0, $3, $6, $4, $1) | 0) < 0) {
         break label$10;
        }
        if (!indexColumnNotNull($4, $1)) {
         break label$10;
        }
       }
       $1 = $1 + 1 | 0;
       continue;
      }
      break;
     }
     if (HEAPU16[$4 + 50 >> 1] == ($1 | 0)) {
      break label$2;
     }
    }
    $1 = $4 + 20 | 0;
    continue;
   }
  }
  $5 = 1;
 }
 return $5;
}

function medianIterate($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 if (HEAP32[$3 + 60 >> 2] <= 0) {
  $11 = HEAPF64[$3 + 24 >> 3];
  $4 = HEAP32[$3 + 32 >> 2];
  $12 = $4;
  $9 = $1;
  $8 = $4 + $9 | 0;
  $4 = $2;
  $7 = HEAP32[$3 + 36 >> 2];
  $10 = $7;
  $5 = $4 + $7 | 0;
  $1 = $8;
  $5 = $8 >>> 0 < $9 >>> 0 ? $5 + 1 | 0 : $5;
  $2 = $5;
  label$2: {
   if (!(+($8 | 0) >= $11)) {
    break label$2;
   }
   $5 = HEAP32[$3 + 16 >> 2];
   $6 = HEAP32[$3 + 20 >> 2];
   $7 = $5;
   $9 = $12;
   $4 = $5 - $9 | 0;
   $5 = $10;
   $8 = $5 + ($7 >>> 0 < $9 >>> 0) | 0;
   if (+($7 >>> 0) + +($6 | 0) * 4294967296 - $11 <= +($4 | 0)) {
    $8 = HEAP32[$3 + 40 >> 2];
    $6 = $8;
    $7 = HEAP32[$3 + 44 >> 2];
    $4 = $7;
    $5 = $6 + 1 | 0;
    $4 = $5 ? $4 : $4 + 1 | 0;
    HEAP32[$3 + 40 >> 2] = $5;
    HEAP32[$3 + 44 >> 2] = $4;
    $4 = HEAP32[$3 + 48 >> 2];
    $6 = HEAP32[$3 + 52 >> 2];
    if (!($4 | $6)) {
     $6 = HEAP32[$3 >> 2];
     $10 = $6;
     $4 = HEAP32[$3 + 4 >> 2];
     $5 = $4;
     $7 = $0;
     $4 = HEAP32[$7 >> 2];
     $6 = $4 >> 31;
     $9 = $4;
     $4 = $6;
     $6 = $5;
     $5 = $4 + $6 | 0;
     $7 = $10;
     $8 = $7 + $9 | 0;
     HEAP32[$3 >> 2] = $8;
     $5 = $8 >>> 0 < $9 >>> 0 ? $5 + 1 | 0 : $5;
     HEAP32[$3 + 4 >> 2] = $5;
     break label$2;
    }
    HEAPF64[$3 + 8 >> 3] = HEAPF64[$0 >> 3] + HEAPF64[$3 + 8 >> 3];
    break label$2;
   }
   HEAP32[$3 + 60 >> 2] = 1;
  }
  HEAP32[$3 + 32 >> 2] = $1;
  $5 = $2;
  HEAP32[$3 + 36 >> 2] = $5;
 }
}

function sqlite3CreateView($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0;
 $8 = __stack_pointer - 80 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 12 >> 2] = 0;
 $9 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP16[$0 + 204 >> 1] > 0) {
   sqlite3ErrorMsg($0, 3385, 0);
   break label$1;
  }
  sqlite3StartTable($0, $2, $3, $6, 1, 0, $7);
  $7 = HEAP32[$0 + 236 >> 2];
  if (HEAP32[$0 + 36 >> 2] | !$7) {
   break label$1;
  }
  HEAP32[$7 + 28 >> 2] = HEAP32[$7 + 28 >> 2] | 512;
  sqlite3TwoPartName($0, $2, $3, $8 + 12 | 0);
  sqlite3FixInit($8 + 16 | 0, $0, sqlite3SchemaToIndex($9, HEAP32[$7 + 60 >> 2]), 1826, HEAP32[$8 + 12 >> 2]);
  if (sqlite3FixSelect($8 + 16 | 0, $5)) {
   break label$1;
  }
  HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] | 2097152;
  label$3: {
   if (HEAPU8[$0 + 208 | 0] > 1) {
    $3 = $5;
    $5 = 0;
    break label$3;
   }
   $3 = sqlite3SelectDup($9, $5, 1);
  }
  HEAP32[$7 + 44 >> 2] = $3;
  $3 = sqlite3ExprListDup($9, $4, 1);
  HEAP8[$7 + 43 | 0] = 2;
  HEAP32[$7 + 16 >> 2] = $3;
  if (HEAPU8[$9 + 87 | 0]) {
   break label$1;
  }
  $3 = HEAP32[$0 + 196 >> 2];
  $2 = HEAP32[$1 >> 2];
  $3 = ($3 + (HEAPU8[$3 | 0] == 59 ? 0 : HEAP32[$0 + 200 >> 2]) | 0) - $2 | 0;
  while (1) {
   $3 = $3 - 1 | 0;
   $7 = $3 + $2 | 0;
   if (HEAP8[HEAPU8[$7 | 0] + 30288 | 0] & 1) {
    continue;
   }
   break;
  }
  HEAP32[$8 + 76 >> 2] = 1;
  HEAP32[$8 + 72 >> 2] = $7;
  sqlite3EndTable($0, 0, $8 + 72 | 0, 0, 0);
 }
 sqlite3SelectDelete($9, $5);
 if (HEAPU8[$0 + 208 | 0] >= 2) {
  sqlite3RenameExprlistUnmap($0, $4);
 }
 sqlite3ExprListDelete($9, $4);
 __stack_pointer = $8 + 80 | 0;
}

function fts3TermSelectMerge($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  label$2: {
   if (HEAP32[$1 >> 2]) {
    $5 = $2;
    while (1) {
     if (($4 | 0) == 16) {
      break label$2;
     }
     $7 = ($4 << 2) + $1 | 0;
     $8 = HEAP32[$7 >> 2];
     if (!$8) {
      HEAP32[$7 >> 2] = $5;
      HEAP32[(($4 << 2) + $1 | 0) - -64 >> 2] = $3;
      break label$2;
     }
     $9 = $7 - -64 | 0;
     $3 = fts3DoclistOrMerge(HEAPU8[$0 + 239 | 0], $5, $3, $8, HEAP32[$9 >> 2], $6 + 12 | 0, $6 + 8 | 0);
     if ($3) {
      if (($2 | 0) == ($5 | 0)) {
       break label$1;
      }
      sqlite3_free($5);
      break label$1;
     }
     if (($2 | 0) != ($5 | 0)) {
      sqlite3_free($5);
     }
     sqlite3_free(HEAP32[$7 >> 2]);
     HEAP32[$7 >> 2] = 0;
     $3 = HEAP32[$6 + 8 >> 2];
     $5 = HEAP32[$6 + 12 >> 2];
     if (($4 | 0) == 15) {
      HEAP32[$7 >> 2] = $5;
      HEAP32[$9 >> 2] = $3;
     }
     $4 = $4 + 1 | 0;
     continue;
    }
   }
   $4 = sqlite3_malloc($3 + 11 | 0);
   HEAP32[$1 + 64 >> 2] = $3;
   HEAP32[$1 >> 2] = $4;
   if (!$4) {
    $3 = 7;
    break label$1;
   }
   __memcpy($4, $2, $3);
   $4 = HEAP32[$1 >> 2] + $3 | 0;
   HEAP8[$4 | 0] = 0;
   HEAP8[$4 + 1 | 0] = 0;
   HEAP8[$4 + 2 | 0] = 0;
   HEAP8[$4 + 3 | 0] = 0;
   HEAP8[$4 + 4 | 0] = 0;
   HEAP8[$4 + 5 | 0] = 0;
   HEAP8[$4 + 6 | 0] = 0;
   HEAP8[$4 + 7 | 0] = 0;
   $3 = 0;
   HEAP8[$4 + 8 | 0] = 0;
   HEAP8[$4 + 9 | 0] = 0;
   break label$1;
  }
  $3 = 0;
 }
 __stack_pointer = $6 + 16 | 0;
 return $3;
}

function fts3SelectLeaf($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $8 = HEAP8[$3 | 0];
 label$1: {
  if (($8 | 0) < 0) {
   sqlite3Fts3GetVarint32($3, $7 + 12 | 0);
   $8 = HEAP32[$7 + 12 >> 2];
   break label$1;
  }
  $8 = $8 & 255;
 }
 $3 = fts3ScanInteriorNode($1, $2, $3, $4, $5, $6);
 if (!($3 | ($8 | 0) < 2)) {
  HEAP32[$7 + 8 >> 2] = 0;
  HEAP32[$7 + 4 >> 2] = 0;
  label$4: {
   label$5: {
    if (!$5 | !$6) {
     break label$5;
    }
    $4 = HEAP32[$5 >> 2];
    $3 = HEAP32[$6 >> 2];
    $9 = HEAP32[$5 + 4 >> 2];
    if (($4 | 0) == ($3 | 0) & ($9 | 0) == HEAP32[$6 + 4 >> 2]) {
     break label$5;
    }
    $3 = sqlite3Fts3ReadBlock($0, $4, $9, $7 + 8 | 0, $7 + 4 | 0);
    if (!$3) {
     $3 = fts3SelectLeaf($0, $1, $2, HEAP32[$7 + 8 >> 2], HEAP32[$7 + 4 >> 2], $5, 0);
    }
    sqlite3_free(HEAP32[$7 + 8 >> 2]);
    $5 = 0;
    HEAP32[$7 + 8 >> 2] = 0;
    if ($3) {
     break label$4;
    }
   }
   $3 = $5 ? $5 : $6;
   $3 = sqlite3Fts3ReadBlock($0, HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], $7 + 8 | 0, $7 + 4 | 0);
   if ($3) {
    break label$4;
   }
   HEAP32[$7 >> 2] = 0;
   $9 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP8[$9 | 0];
   label$7: {
    if (($3 | 0) < 0) {
     sqlite3Fts3GetVarint32($9, $7);
     $4 = HEAP32[$7 >> 2];
     break label$7;
    }
    $4 = $3 & 255;
   }
   $3 = 267;
   if (($8 | 0) <= ($4 | 0)) {
    break label$4;
   }
   $3 = fts3SelectLeaf($0, $1, $2, $9, HEAP32[$7 + 4 >> 2], $5, $6);
  }
  sqlite3_free(HEAP32[$7 + 8 >> 2]);
 }
 __stack_pointer = $7 + 16 | 0;
 return $3;
}

function sqlite3PagerMovepage($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1: {
  if (HEAPU8[$0 + 12 | 0]) {
   $4 = sqlite3PagerWrite($1);
   if ($4) {
    break label$1;
   }
  }
  $4 = HEAPU16[$1 + 28 >> 1];
  if ($4 & 2) {
   $4 = subjournalPageIfRequired($1);
   if ($4) {
    break label$1;
   }
   $4 = HEAPU16[$1 + 28 >> 1];
  }
  if (!(!($4 & 8) | $3)) {
   $6 = HEAP32[$1 + 24 >> 2];
  }
  HEAP16[$1 + 28 >> 1] = $4 & 65527;
  $4 = sqlite3PagerLookup($0, $2);
  label$5: {
   if (!$4) {
    break label$5;
   }
   if (HEAP16[$4 + 30 >> 1] >= 2) {
    sqlite3PagerUnrefNotNull($4);
    $4 = sqlite3CorruptError(61057);
    break label$1;
   }
   HEAP16[$1 + 28 >> 1] = HEAPU16[$1 + 28 >> 1] | HEAPU16[$4 + 28 >> 1] & 8;
   if (HEAPU8[$0 + 12 | 0]) {
    sqlite3PcacheMove($4, HEAP32[$0 + 28 >> 2] + 1 | 0);
    break label$5;
   }
   sqlite3PcacheDrop($4);
  }
  $3 = HEAP32[$1 + 24 >> 2];
  sqlite3PcacheMove($1, $2);
  sqlite3PcacheMakeDirty($1);
  if (!(!HEAPU8[$0 + 12 | 0] | !$4)) {
   sqlite3PcacheMove($4, $3);
   sqlite3PagerUnrefNotNull($4);
  }
  if ($6) {
   $4 = sqlite3PagerGet($0, $6, $5 + 12 | 0, 0);
   if ($4) {
    if (HEAPU32[$0 + 32 >> 2] < $6 >>> 0) {
     break label$1;
    }
    sqlite3BitvecClear(HEAP32[$0 + 60 >> 2], $6, HEAP32[$0 + 224 >> 2]);
    break label$1;
   }
   $1 = HEAP32[$5 + 12 >> 2];
   HEAP16[$1 + 28 >> 1] = HEAPU16[$1 + 28 >> 1] | 8;
   sqlite3PcacheMakeDirty($1);
   sqlite3PagerUnrefNotNull(HEAP32[$5 + 12 >> 2]);
  }
  $4 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function hasHotJournal($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $6 = HEAP32[$0 >> 2];
 $4 = 1;
 HEAP32[$2 + 12 >> 2] = 1;
 $5 = HEAP32[HEAP32[$0 + 68 >> 2] >> 2];
 HEAP32[$1 >> 2] = 0;
 if (!$5) {
  $3 = sqlite3OsAccess($6, HEAP32[$0 + 188 >> 2], 0, $2 + 12 | 0);
  $4 = HEAP32[$2 + 12 >> 2] != 0;
 }
 label$2: {
  if (!$4 | $3) {
   break label$2;
  }
  HEAP32[$2 + 8 >> 2] = 0;
  $3 = sqlite3OsCheckReservedLock(HEAP32[$0 + 64 >> 2], $2 + 8 | 0);
  if ($3 | HEAP32[$2 + 8 >> 2]) {
   break label$2;
  }
  $3 = pagerPagecount($0, $2 + 4 | 0);
  if ($3) {
   break label$2;
  }
  label$3: {
   if (!(HEAP32[$2 + 4 >> 2] | $5)) {
    sqlite3BeginBenignMalloc();
    label$5: {
     if (pagerLockDb($0, 2)) {
      break label$5;
     }
     sqlite3OsDelete($6, HEAP32[$0 + 188 >> 2], 0);
     if (HEAPU8[$0 + 4 | 0]) {
      break label$5;
     }
     pagerUnlockDb($0, 1);
    }
    sqlite3EndBenignMalloc();
    break label$3;
   }
   label$6: {
    if (!$5) {
     HEAP32[$2 >> 2] = 2049;
     $3 = sqlite3OsOpen($6, HEAP32[$0 + 188 >> 2], HEAP32[$0 + 68 >> 2], 2049, $2);
     if (($3 | 0) == 14) {
      break label$6;
     }
     if ($3) {
      break label$2;
     }
    }
    HEAP8[$2 | 0] = 0;
    $3 = sqlite3OsRead(HEAP32[$0 + 68 >> 2], $2, 1, 0, 0);
    $4 = ($3 | 0) == 522;
    if (!$5) {
     sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
    }
    $3 = $4 ? 0 : $3;
    HEAP32[$1 >> 2] = HEAPU8[$2 | 0] != 0;
    break label$2;
   }
   HEAP32[$1 >> 2] = 1;
  }
  $3 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function exp($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   $6 = $3;
   $1 = $3 >>> 20 & 2047;
   if ($1 - 969 >>> 0 < 63) {
    $8 = $1;
    break label$2;
   }
   if ($1 >>> 0 <= 968) {
    return $0 + 1;
   }
   if ($1 >>> 0 < 1033) {
    break label$2;
   }
   $3 = $4;
   $2 = 0;
   if (!$3 & ($6 | 0) == -1048576) {
    break label$1;
   }
   if (($1 | 0) == 2047) {
    return $0 + 1;
   }
   $3 = $6;
   if (($3 | 0) < 0) {
    return __math_uflow(0);
   }
   return __math_oflow(0);
  }
  $2 = HEAPF64[7059];
  $7 = HEAPF64[7058] * $0 + $2;
  $2 = $7 - $2;
  $0 = $2 * HEAPF64[7061] + ($2 * HEAPF64[7060] + $0);
  $2 = $0 * $0;
  $9 = $2 * $2 * ($0 * HEAPF64[7065] + HEAPF64[7064]);
  $2 = $2 * ($0 * HEAPF64[7063] + HEAPF64[7062]);
  wasm2js_scratch_store_f64(+$7);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $6 = $1;
  $1 = $4 << 4 & 2032;
  $0 = $9 + ($2 + (HEAPF64[$1 + 56576 >> 3] + $0));
  $5 = $1 + 56584 | 0;
  $1 = HEAP32[$5 >> 2];
  $10 = $1;
  $3 = HEAP32[$5 + 4 >> 2];
  $1 = $4 << 13;
  $5 = $1;
  $1 = $5 + $3 | 0;
  $3 = $10;
  $5 = $3 + 0 | 0;
  $1 = $11 >>> 0 > $5 >>> 0 ? $1 + 1 | 0 : $1;
  $3 = $1;
  if (!$8) {
   $1 = $3;
   $3 = $6;
   return specialcase($0, $5, $1, $4, $3);
  }
  wasm2js_scratch_store_i32(0, $5 | 0);
  wasm2js_scratch_store_i32(1, $3 | 0);
  $2 = +wasm2js_scratch_load_f64();
  $2 = $2 * $0 + $2;
 }
 return $2;
}

function unixFileControl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = 12;
 label$1: {
  label$2: {
   switch ($1 - 1 | 0) {
   case 0:
    HEAP32[$2 >> 2] = HEAPU8[$0 + 16 | 0];
    $3 = 0;
    break label$1;

   case 3:
    HEAP32[$2 >> 2] = HEAP32[$0 + 20 >> 2];
    $3 = 0;
    break label$1;

   case 5:
    HEAP32[$0 + 40 >> 2] = HEAP32[$2 >> 2];
    $3 = 0;
    break label$1;

   case 4:
    $5 = HEAP32[$2 >> 2];
    $1 = HEAP32[$2 + 4 >> 2];
    $3 = fcntlSizeHint($0, $5, $1);
    break label$1;

   case 9:
    unixModeBit($0, 4, $2);
    $3 = 0;
    break label$1;

   case 12:
    unixModeBit($0, 16, $2);
    $3 = 0;
    break label$1;

   case 11:
    HEAP32[$4 >> 2] = HEAP32[HEAP32[$0 + 4 >> 2] + 16 >> 2];
    HEAP32[$2 >> 2] = sqlite3_mprintf(8342, $4);
    $3 = 0;
    break label$1;

   case 15:
    $3 = 0;
    $1 = HEAP32[HEAP32[$0 + 4 >> 2] + 8 >> 2];
    $5 = $1 >> 31;
    $1 = sqlite3_malloc64($1, $5);
    if (!$1) {
     break label$1;
    }
    unixGetTempname(HEAP32[HEAP32[$0 + 4 >> 2] + 8 >> 2], $1);
    HEAP32[$2 >> 2] = $1;
    break label$1;

   case 19:
    HEAP32[$2 >> 2] = fileHasMoved($0);
    $3 = 0;
    break label$1;

   case 1:
   case 2:
   case 6:
   case 7:
   case 8:
   case 10:
   case 13:
   case 14:
   case 16:
   case 17:
   case 18:
    break label$1;

   default:
    break label$2;
   }
  }
  if (($1 | 0) != 40) {
   break label$1;
  }
  $3 = unixFcntlExternalReader($0, $2);
 }
 __stack_pointer = $4 + 16 | 0;
 return $3 | 0;
}

function removeUnindexableInClauseTerms($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = HEAP32[$0 >> 2];
 $5 = sqlite3ExprDup($7, $3, 0);
 label$1: {
  if (HEAPU8[$7 + 87 | 0]) {
   break label$1;
  }
  $9 = HEAP32[HEAP32[$5 + 12 >> 2] + 20 >> 2];
  $10 = HEAP32[HEAP32[$5 + 20 >> 2] + 28 >> 2];
  while (1) {
   if (($1 | 0) < HEAPU16[$2 + 44 >> 1]) {
    $4 = HEAP32[HEAP32[$2 + 52 >> 2] + ($1 << 2) >> 2];
    label$4: {
     if (HEAP32[$4 >> 2] != ($3 | 0)) {
      break label$4;
     }
     $4 = HEAP32[$4 + 28 >> 2] - 1 << 4;
     $8 = $10 + $4 | 0;
     $11 = HEAP32[$8 + 8 >> 2];
     if (!$11) {
      break label$4;
     }
     $12 = sqlite3ExprListAppend($0, $12, $11);
     HEAP32[$8 + 8 >> 2] = 0;
     $8 = $4 + $9 | 0;
     $4 = $8 + 8 | 0;
     $6 = sqlite3ExprListAppend($0, $6, HEAP32[$4 >> 2]);
     HEAP32[$8 + 8 >> 2] = 0;
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3ExprListDelete($7, $10);
  sqlite3ExprListDelete($7, $9);
  HEAP32[HEAP32[$5 + 12 >> 2] + 20 >> 2] = $6;
  HEAP32[HEAP32[$5 + 20 >> 2] + 28 >> 2] = $12;
  if (!(!$6 | HEAP32[$6 >> 2] != 1)) {
   $1 = HEAP32[$6 + 8 >> 2];
   HEAP32[$6 + 8 >> 2] = 0;
   sqlite3ExprDelete($7, HEAP32[$5 + 12 >> 2]);
   HEAP32[$5 + 12 >> 2] = $1;
  }
  $2 = HEAP32[HEAP32[$5 + 20 >> 2] + 48 >> 2];
  if (!$2) {
   break label$1;
  }
  $4 = HEAP32[$2 >> 2];
  $1 = 0;
  while (1) {
   if (($1 | 0) >= ($4 | 0)) {
    break label$1;
   }
   HEAP16[(($1 << 4) + $2 | 0) + 20 >> 1] = 0;
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 return $5;
}

function __extenddftf2($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 wasm2js_scratch_store_f64(+$1);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $10 = $2;
 $6 = $2 & 2147483647;
 $4 = 1048576;
 $4 = $6 - $4 | 0;
 label$1: {
  if (($4 | 0) == 2145386495 | $4 >>> 0 < 2145386495) {
   $2 = $5;
   $4 = $2 << 28;
   $8 = $4;
   $4 = $6;
   $2 = $4 >>> 4 | 0;
   $4 = ($4 & 15) << 28 | $5 >>> 4;
   $9 = $4;
   $3 = $2 + 1006632960 | 0;
   break label$1;
  }
  $3 = $6;
  if (($3 | 0) == 2146435072 | $3 >>> 0 > 2146435072) {
   $2 = $5;
   $3 = $2 << 28;
   $8 = $3;
   $3 = $10;
   $2 = $3 >>> 4 | 0;
   $3 = ($3 & 15) << 28 | $5 >>> 4;
   $9 = $3;
   $2 = $2 | 2147418112;
   $3 = $2;
   break label$1;
  }
  $2 = $6;
  if (!($2 | $5)) {
   $3 = 0;
   break label$1;
  }
  $11 = $6 ? Math_clz32($6) : Math_clz32($5) + 32 | 0;
  __ashlti3($7, $5, $6, 0, 0, $11 + 49 | 0);
  $4 = $7;
  $3 = HEAP32[$4 >> 2];
  $12 = $3;
  $2 = HEAP32[$4 + 4 >> 2];
  $8 = $2;
  $3 = HEAP32[$4 + 12 >> 2];
  $2 = HEAP32[$4 + 8 >> 2];
  $4 = $2;
  $2 = $3 ^ 65536;
  $9 = 0 | $4;
  $3 = 15372 - $11 | 0;
  $4 = $3 << 16;
  $3 = $4;
  $4 = $2;
  $3 = $3 | $4;
 }
 $6 = $3;
 $2 = $0;
 HEAP32[$2 >> 2] = $12;
 $3 = $8;
 HEAP32[$2 + 4 >> 2] = $3;
 $3 = $10;
 $2 = $3 & -2147483648;
 $4 = $2;
 $2 = 0;
 $5 = $9;
 $3 = $5;
 $2 = $2 | $3;
 $3 = $0;
 HEAP32[$3 + 8 >> 2] = $2;
 $2 = $6;
 $4 = $2 | $4;
 HEAP32[$3 + 12 >> 2] = $4;
 __stack_pointer = $7 + 16 | 0;
}

function padlFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (($1 | 0) == 2) {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
    sqlite3_result_null($0);
    return;
   }
   $1 = sqlite3_value_text(HEAP32[$2 >> 2]);
   $5 = sqlite3_value_int64(HEAP32[$2 + 4 >> 2]);
   $4 = i64toi32_i32$HIGH_BITS;
   $3 = $4;
   if (($4 | 0) < 0) {
    sqlite3_result_error($0, 8544, -1);
    return;
   }
   $2 = sqlite3Utf8CharLen_1($1);
   $4 = $2 >> 31;
   $8 = $2;
   $6 = $4;
   label$5: {
    if (($3 | 0) <= ($4 | 0) & $5 >>> 0 <= $2 >>> 0 | ($4 | 0) > ($3 | 0)) {
     $7 = sqlite3StrDup($1);
     if (!$7) {
      break label$1;
     }
     sqlite3_result_text($0, $7, -1, -1);
     break label$5;
    }
    $7 = sqlite3_malloc((strlen($1) + ($5 - $2 | 0) | 0) + 1 | 0);
    if (!$7) {
     break label$1;
    }
    $6 = $6 + ($5 >>> 0 < $8 >>> 0) | 0;
    $6 = $3 - $6 | 0;
    $4 = $8;
    $3 = $5 - $4 | 0;
    $2 = $3;
    $3 = $6;
    $4 = $2 + 1 | 0;
    $3 = $4 ? $3 : $3 + 1 | 0;
    $8 = $4;
    $6 = $3;
    $5 = 1;
    $3 = 0;
    $2 = $7;
    while (1) {
     $4 = $8;
     if (!(($4 | 0) == ($5 | 0) & ($6 | 0) == ($3 | 0))) {
      HEAP8[$2 | 0] = 32;
      $5 = $5 + 1 | 0;
      $4 = $5 ? $3 : $3 + 1 | 0;
      $3 = $4;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    strcpy($2, $1);
   }
   sqlite3_result_text($0, $7, -1, -1);
   sqlite3_free($7);
   return;
  }
  __assert_fail(23018, 17353, 771, 17153);
  abort();
 }
 sqlite3_result_error_nomem($0);
}

function codeTriggerProgram($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $6 = $2 & 255;
 $3 = HEAP32[$0 >> 2];
 $5 = HEAP32[$0 + 8 >> 2];
 $7 = ($2 | 0) != 11;
 while (1) {
  if ($1) {
   $2 = $6;
   $2 = $7 ? $2 : HEAPU8[$1 + 1 | 0];
   HEAP8[$0 + 150 | 0] = $2;
   $2 = HEAP32[$1 + 36 >> 2];
   if ($2) {
    HEAP32[$4 >> 2] = $2;
    sqlite3VdbeAddOp4($5, 181, 2147483647, 1, 0, sqlite3MPrintf($3, 8300, $4), -6);
   }
   label$5: {
    label$6: {
     switch (HEAPU8[$1 | 0] - 127 | 0) {
     case 2:
      sqlite3Update($0, sqlite3TriggerStepSrc($0, $1), sqlite3ExprListDup($3, HEAP32[$1 + 24 >> 2], 0), sqlite3ExprDup($3, HEAP32[$1 + 20 >> 2], 0), HEAPU8[$0 + 150 | 0], 0);
      sqlite3VdbeAddOp0($5, 131);
      break label$5;

     case 0:
      sqlite3Insert($0, sqlite3TriggerStepSrc($0, $1), sqlite3SelectDup($3, HEAP32[$1 + 8 >> 2], 0), sqlite3IdListDup($3, HEAP32[$1 + 28 >> 2]), HEAPU8[$0 + 150 | 0], sqlite3UpsertDup($3, HEAP32[$1 + 32 >> 2]));
      sqlite3VdbeAddOp0($5, 131);
      break label$5;

     case 1:
      sqlite3DeleteFrom($0, sqlite3TriggerStepSrc($0, $1), sqlite3ExprDup($3, HEAP32[$1 + 20 >> 2], 0));
      sqlite3VdbeAddOp0($5, 131);
      break label$5;

     default:
      break label$6;
     }
    }
    $2 = sqlite3SelectDup($3, HEAP32[$1 + 8 >> 2], 0);
    sqlite3SelectDestInit($4 + 16 | 0, 4, 0);
    sqlite3Select($0, $2, $4 + 16 | 0);
    sqlite3SelectDelete($3, $2);
   }
   $1 = HEAP32[$1 + 40 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 48 | 0;
}

function log($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if (($1 | 0) > 0 | ($1 | 0) >= 0) {
      if ($1 >>> 0 > 1048575) {
       break label$4;
      }
     }
     if (!($1 & 2147483647 | $3)) {
      return -1 / ($0 * $0);
     }
     if (($1 | 0) > 0 | ($1 | 0) >= 0) {
      break label$3;
     }
     return ($0 - $0) / 0;
    }
    if ($1 >>> 0 > 2146435071) {
     break label$1;
    }
    $4 = 1072693248;
    $5 = -1023;
    if (($1 | 0) != 1072693248) {
     $4 = $1;
     break label$2;
    }
    if ($3) {
     break label$2;
    }
    return 0;
   }
   wasm2js_scratch_store_f64(+($0 * 0x40000000000000));
   $1 = wasm2js_scratch_load_i32(1) | 0;
   $3 = wasm2js_scratch_load_i32(0) | 0;
   $4 = $1;
   $5 = -1077;
  }
  $1 = $4 + 614242 | 0;
  $6 = +(($1 >>> 20 | 0) + $5 | 0);
  $1 = ($1 & 1048575) + 1072079006 | 0;
  wasm2js_scratch_store_i32(0, $3 | 0);
  $4 = $1;
  $1 = 0;
  wasm2js_scratch_store_i32(1, $4 | $1);
  $0 = +wasm2js_scratch_load_f64() + -1;
  $8 = $0;
  $2 = $0 / ($0 + 2);
  $9 = $2;
  $7 = $0 * ($0 * .5);
  $2 = $2 * $2;
  $0 = $2 * $2;
  $0 = $6 * .6931471803691238 + ($8 + ($9 * ($7 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $2 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) + $6 * 1.9082149292705877e-10 - $7));
 }
 return $0;
}

function fts3ReadEndBlockField($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $0 = sqlite3_column_text($0, $1);
 if ($0) {
  $1 = 0;
  while (1) {
   $5 = HEAPU8[$0 + $1 | 0];
   if (($5 - 48 & 255) >>> 0 <= 9) {
    $6 = __wasm_i64_mul($7, $4, 10, 0);
    $8 = $6;
    $4 = i64toi32_i32$HIGH_BITS;
    $6 = $4;
    $4 = $5 - 48 | 0;
    $7 = $4;
    $4 = 0;
    $5 = $4;
    $4 = $6;
    $6 = $5;
    $4 = $4 + $6 | 0;
    $5 = $8 + $7 | 0;
    $4 = $5 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
    $7 = $5;
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$2 >> 2] = $7;
  HEAP32[$2 + 4 >> 2] = $4;
  $9 = 1;
  while (1) {
   $5 = HEAPU8[$0 + $1 | 0];
   if (($5 | 0) != 32) {
    if (($5 | 0) == 45) {
     $9 = -1;
     $10 = -1;
     $1 = $1 + 1 | 0;
    }
    $7 = 0;
    $4 = 0;
    while (1) {
     $5 = HEAPU8[$0 + $1 | 0];
     if (($5 - 48 & 255) >>> 0 <= 9) {
      $8 = __wasm_i64_mul($7, $4, 10, 0);
      $4 = i64toi32_i32$HIGH_BITS;
      $2 = $4;
      $4 = $5;
      $5 = 0;
      $6 = $4 - 48 | 0;
      $7 = $6;
      $4 = 0;
      $5 = $4;
      $4 = $2;
      $6 = $5 + $4 | 0;
      $5 = $8;
      $4 = $5 + $7 | 0;
      $6 = $4 >>> 0 < $7 >>> 0 ? $6 + 1 | 0 : $6;
      $7 = $4;
      $4 = $6;
      $1 = $1 + 1 | 0;
      continue;
     }
     break;
    }
    $6 = $4;
    $5 = $10;
    $5 = __wasm_i64_mul($7, $6, $9, $5);
    $0 = $5;
    $5 = $3;
    HEAP32[$5 >> 2] = $0;
    $6 = i64toi32_i32$HIGH_BITS;
    HEAP32[$5 + 4 >> 2] = $6;
   } else {
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
 }
}

function nth_valueStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  $4 = sqlite3_aggregate_context($0, 16);
  if (!$4) {
   break label$1;
  }
  label$2: {
   label$3: {
    label$4: {
     switch (sqlite3_value_numeric_type(HEAP32[$2 + 4 >> 2]) - 1 | 0) {
     case 0:
      $5 = sqlite3_value_int64(HEAP32[$2 + 4 >> 2]);
      $1 = i64toi32_i32$HIGH_BITS;
      $7 = $1;
      break label$3;

     case 1:
      break label$4;

     default:
      break label$2;
     }
    }
    $3 = sqlite3_value_double(HEAP32[$2 + 4 >> 2]);
    label$6: {
     if (Math_abs($3) < 0x8000000000000000) {
      $1 = Math_abs($3) >= 1 ? ~~($3 > 0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
      $5 = ~~$3 >>> 0;
      break label$6;
     }
     $1 = -2147483648;
    }
    $7 = $1;
    if (+($5 >>> 0) + +($1 | 0) * 4294967296 != $3) {
     break label$2;
    }
   }
   $1 = $7;
   if (!$5 & ($1 | 0) <= 0 | ($1 | 0) < 0) {
    break label$2;
   }
   $1 = HEAP32[$4 + 4 >> 2];
   $8 = HEAP32[$4 >> 2] + 1 | 0;
   $6 = $8 ? $1 : $1 + 1 | 0;
   HEAP32[$4 >> 2] = $8;
   HEAP32[$4 + 4 >> 2] = $6;
   $1 = $5;
   $5 = $6;
   $6 = $7;
   if (($1 | 0) != ($8 | 0) | ($5 | 0) != ($6 | 0)) {
    break label$1;
   }
   $2 = sqlite3_value_dup(HEAP32[$2 >> 2]);
   HEAP32[$4 + 8 >> 2] = $2;
   if ($2) {
    break label$1;
   }
   sqlite3_result_error_nomem($0);
   return;
  }
  sqlite3_result_error($0, 8960, -1);
 }
}

function findInodeInfo($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 128 | 0;
 __stack_pointer = $2;
 label$1: {
  if (FUNCTION_TABLE[HEAP32[16252]](HEAP32[$0 + 12 >> 2], $2) | 0) {
   storeLastErrno($0, HEAP32[__errno_location() >> 2]);
   $3 = HEAP32[$0 + 20 >> 2] == 61 ? 22 : 10;
   break label$1;
  }
  HEAP32[$2 + 112 >> 2] = 0;
  HEAP32[$2 + 116 >> 2] = 0;
  $4 = HEAP32[$2 + 108 >> 2];
  $3 = HEAP32[$2 + 104 >> 2];
  HEAP32[$2 + 120 >> 2] = $3;
  HEAP32[$2 + 124 >> 2] = $4;
  HEAP32[$2 + 112 >> 2] = HEAP32[$2 >> 2];
  $0 = 70860;
  label$3: {
   label$4: {
    while (1) {
     $0 = HEAP32[$0 >> 2];
     if ($0) {
      if (!memcmp($2 + 112 | 0, $0, 16)) {
       break label$4;
      }
      $0 = $0 + 44 | 0;
      continue;
     }
     break;
    }
    $0 = sqlite3_malloc64(56, 0);
    $3 = 7;
    if (!$0) {
     break label$1;
    }
    memset($0 + 16 | 0, 0, 40);
    $3 = HEAP32[$2 + 124 >> 2];
    $4 = HEAP32[$2 + 120 >> 2];
    HEAP32[$0 + 8 >> 2] = $4;
    HEAP32[$0 + 12 >> 2] = $3;
    $4 = HEAP32[$2 + 116 >> 2];
    $3 = HEAP32[$2 + 112 >> 2];
    HEAP32[$0 >> 2] = $3;
    HEAP32[$0 + 4 >> 2] = $4;
    if (HEAPU8[64276]) {
     HEAP32[$0 + 16 >> 2] = 8;
    }
    HEAP32[$0 + 36 >> 2] = 1;
    $3 = HEAP32[17715];
    HEAP32[$0 + 48 >> 2] = 0;
    HEAP32[$0 + 44 >> 2] = $3;
    if ($3) {
     HEAP32[$3 + 48 >> 2] = $0;
    }
    HEAP32[17715] = $0;
    break label$3;
   }
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
  }
  HEAP32[$1 >> 2] = $0;
  $3 = 0;
 }
 __stack_pointer = $2 + 128 | 0;
 $0 = $3;
 return $0;
}

function __tan($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 wasm2js_scratch_store_f64(+$0);
 $4 = wasm2js_scratch_load_i32(1) | 0;
 $9 = wasm2js_scratch_load_i32(0) | 0;
 $7 = $4;
 $8 = ($4 & 2147483640) >>> 0 < 1072010280;
 if (!$8) {
  $4 = ($4 | 0) > 0 | ($4 | 0) >= 0;
  $0 = .7853981633974483 - ($4 ? $0 : -$0) + (3061616997868383e-32 - ($4 ? $1 : -$1));
  $7 = $7 >>> 31 | 0;
  $1 = 0;
 }
 $5 = $0 * $0;
 $6 = $0 * $5;
 $3 = $5 * $5;
 $5 = $6 * .3333333333333341 + ($5 * ($6 * ($3 * ($3 * ($3 * ($3 * ($3 * -18558637485527546e-21 + 7817944429395571e-20) + .0005880412408202641) + .0035920791075913124) + .021869488294859542) + .13333333333320124 + $5 * ($3 * ($3 * ($3 * ($3 * ($3 * 2590730518636337e-20 + 7140724913826082e-20) + .0002464631348184699) + .0014562094543252903) + .0088632398235993) + .05396825397622605)) + $1) + $1);
 $3 = $0 + $5;
 if (!$8) {
  $1 = +(1 - ($2 << 1) | 0);
  $3 = $0 + ($5 - $3 * $3 / ($3 + $1));
  $3 = $1 - ($3 + $3);
  return $7 ? -$3 : $3;
 }
 if ($2) {
  $1 = -1 / $3;
  $6 = $1;
  wasm2js_scratch_store_f64(+$1);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $4 | 0);
  $1 = +wasm2js_scratch_load_f64();
  wasm2js_scratch_store_f64(+$3);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $4 | 0);
  $3 = +wasm2js_scratch_load_f64();
  $3 = $6 * ($1 * ($5 - ($3 - $0)) + ($1 * $3 + 1)) + $1;
 }
 return $3;
}

function sqlite3WalCheckpoint($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0;
 $12 = __stack_pointer - 16 | 0;
 __stack_pointer = $12;
 HEAP32[$12 + 12 >> 2] = 0;
 $10 = 8;
 if (!HEAPU8[$0 + 46 | 0]) {
  $11 = $2;
  $10 = walLockExclusive($0, 1, 1);
  label$2: {
   if ($10) {
    break label$2;
   }
   HEAP8[$0 + 45 | 0] = 1;
   label$3: {
    label$4: {
     if (!$2) {
      $11 = 0;
      break label$4;
     }
     $11 = 0;
     $10 = walBusyLock($0, $3, $4, 0, 1);
     if (($10 | 0) == 5) {
      $3 = 0;
      break label$4;
     }
     if ($10) {
      $11 = $2;
      break label$3;
     }
     HEAP8[$0 + 44 | 0] = 1;
     $11 = $2;
    }
    $10 = walIndexReadHdr($0, $12 + 12 | 0);
   }
   if ($10) {
    break label$2;
   }
   label$8: {
    label$9: {
     if (!HEAP32[$0 + 68 >> 2]) {
      break label$9;
     }
     if ((walPagesize($0) | 0) == ($6 | 0)) {
      break label$9;
     }
     $10 = sqlite3CorruptError(65572);
     break label$8;
    }
    $10 = walCheckpoint($0, $1, $11, $3, $4, $5, $7);
   }
   if ($10 ? ($10 | 0) != 5 : 0) {
    break label$2;
   }
   if ($8) {
    HEAP32[$8 >> 2] = HEAP32[$0 + 68 >> 2];
   }
   if (!$9) {
    break label$2;
   }
   HEAP32[$9 >> 2] = HEAP32[walCkptInfo($0) >> 2];
  }
  if (HEAP32[$12 + 12 >> 2]) {
   memset($0 + 52 | 0, 0, 48);
  }
  sqlite3WalEndWriteTransaction($0);
  if (HEAPU8[$0 + 45 | 0]) {
   walUnlockExclusive($0, 1, 1);
   HEAP8[$0 + 45 | 0] = 0;
  }
  $10 = ($2 | 0) == ($11 | 0) ? $10 : $10 ? $10 : 5;
 }
 __stack_pointer = $12 + 16 | 0;
 return $10;
}

function fts3EvalDlPhraseNext($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $7 = HEAP32[$1 >> 2];
 label$1: {
  label$2: {
   $3 = HEAP32[$1 + 8 >> 2];
   label$3: {
    if (!$3) {
     $3 = $7;
     if (!$3) {
      break label$3;
     }
    }
    $7 = HEAP32[$1 + 4 >> 2] + $7 | 0;
    if ($7 >>> 0 > $3 >>> 0) {
     break label$2;
    }
   }
   HEAP8[$2 | 0] = 1;
   break label$1;
  }
  $3 = sqlite3Fts3GetVarint($3, $5) + $3 | 0;
  HEAP32[$5 + 12 >> 2] = $3;
  label$5: {
   if (!(HEAP32[$1 + 8 >> 2] ? HEAPU8[$0 + 239 | 0] : 0)) {
    $0 = HEAP32[$1 + 20 >> 2];
    $4 = $0;
    $0 = HEAP32[$5 >> 2];
    $8 = $0;
    $6 = $0 + HEAP32[$1 + 16 >> 2] | 0;
    $0 = HEAP32[$5 + 4 >> 2];
    $4 = $0 + $4 | 0;
    HEAP32[$1 + 16 >> 2] = $6;
    $4 = $6 >>> 0 < $8 >>> 0 ? $4 + 1 | 0 : $4;
    HEAP32[$1 + 20 >> 2] = $4;
    break label$5;
   }
   $4 = HEAP32[$1 + 16 >> 2];
   $9 = $4;
   $4 = HEAP32[$5 + 4 >> 2];
   $6 = $4;
   $8 = HEAP32[$5 >> 2];
   $0 = $9 - $8 | 0;
   $4 = HEAP32[$1 + 20 >> 2];
   $6 = ($8 >>> 0 > $9 >>> 0) + $6 | 0;
   $6 = $4 - $6 | 0;
   HEAP32[$1 + 16 >> 2] = $0;
   HEAP32[$1 + 20 >> 2] = $6;
  }
  HEAP32[$1 + 28 >> 2] = $3;
  fts3PoslistCopy(0, $5 + 12 | 0);
  $3 = HEAP32[$5 + 12 >> 2];
  HEAP32[$1 + 32 >> 2] = $3 - HEAP32[$1 + 28 >> 2];
  while (1) {
   if (!(HEAPU8[$3 | 0] | $3 >>> 0 >= $7 >>> 0)) {
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP8[$2 | 0] = 0;
 }
 __stack_pointer = $5 + 16 | 0;
}

function sqlite3WhereTabFuncArgs($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1: {
  if (!(HEAPU8[$1 + 37 | 0] & 4)) {
   break label$1;
  }
  $8 = HEAP32[$1 + 56 >> 2];
  if (!$8) {
   break label$1;
  }
  $6 = HEAP32[$1 + 16 >> 2];
  while (1) {
   if (HEAP32[$8 >> 2] <= ($7 | 0)) {
    break label$1;
   }
   $3 = HEAP16[$6 + 34 >> 1];
   $3 = ($3 | 0) < ($4 | 0) ? $4 : $3;
   label$3: {
    while (1) {
     if (($3 | 0) == ($4 | 0)) {
      break label$3;
     }
     if (!(HEAPU8[(HEAP32[$6 + 4 >> 2] + Math_imul($4, 12) | 0) + 10 | 0] & 2)) {
      $4 = $4 + 1 | 0;
      continue;
     }
     break;
    }
    $3 = sqlite3ExprAlloc(HEAP32[$0 >> 2], 167, 0, 0);
    if (!$3) {
     break label$1;
    }
    $9 = HEAP32[$1 + 40 >> 2];
    HEAP32[$3 + 44 >> 2] = $6;
    HEAP16[$3 + 32 >> 1] = $4;
    HEAP32[$3 + 28 >> 2] = $9;
    $9 = HEAP32[$1 + 52 >> 2];
    HEAP32[$1 + 48 >> 2] = HEAP32[$1 + 48 >> 2] | sqlite3ExprColUsed($3);
    HEAP32[$1 + 52 >> 2] = i64toi32_i32$HIGH_BITS | $9;
    $3 = sqlite3PExpr($0, 53, $3, sqlite3PExpr($0, 174, sqlite3ExprDup(HEAP32[$0 >> 2], HEAP32[(($7 << 4) + $8 | 0) + 8 >> 2], 0), 0));
    sqlite3SetJoinExpr($3, HEAP32[$1 + 40 >> 2], HEAPU8[$1 + 36 | 0] & 72 ? 1 : 2);
    whereClauseInsert($2, $3, 1);
    $7 = $7 + 1 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = HEAP32[$6 >> 2];
  HEAP32[$5 + 4 >> 2] = $7;
  HEAP32[$5 >> 2] = $4;
  sqlite3ErrorMsg($0, 16385, $5);
 }
 __stack_pointer = $5 + 16 | 0;
}

function sqlite3Fts3NextToken($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 while (1) {
  $5 = HEAP8[$0 | 0];
  $2 = 0;
  label$2: {
   label$3: while (1) {
    if ($2) {
     break label$2;
    }
    label$4: {
     label$5: {
      label$6: {
       if (($5 | 0) == 34 | ($5 | 0) == 39) {
        break label$6;
       }
       $2 = $0;
       if (($5 | 0) == 91) {
        break label$5;
       }
       if (($5 | 0) == 96) {
        break label$6;
       }
       if ($5) {
        break label$4;
       }
       return 0;
      }
      $2 = $0;
      while (1) {
       $3 = $2;
       $2 = $3 + 1 | 0;
       $4 = HEAPU8[$3 + 1 | 0];
       if (!$4) {
        continue label$3;
       }
       $6 = $5 & 255;
       if (($6 | 0) != ($4 | 0)) {
        continue;
       }
       $2 = $3 + 2 | 0;
       if (HEAPU8[$3 + 2 | 0] == ($6 | 0)) {
        continue;
       }
       break;
      }
      continue;
     }
     while (1) {
      label$9: {
       $3 = $2;
       $2 = $3 + 1 | 0;
       $4 = HEAPU8[$3 + 1 | 0];
       if (($4 | 0) == 93) {
        break label$9;
       }
       if ($4) {
        continue;
       }
      }
      break;
     }
     $2 = $4 ? $3 + 2 | 0 : $2;
     continue;
    }
    $3 = $0;
    if (sqlite3Fts3IsIdChar($5)) {
     while (1) {
      $4 = HEAP8[$3 + 1 | 0];
      $2 = $3 + 1 | 0;
      $3 = $2;
      if (sqlite3Fts3IsIdChar($4)) {
       continue;
      }
      continue label$3;
     }
    }
    break;
   }
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$1 >> 2] = $2 - $0;
 return $0;
}

function whereLoopInsert($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 20 >> 2];
 label$1: {
  if (!$3) {
   $3 = 101;
   $0 = HEAP32[$0 + 12 >> 2];
   if (!$0) {
    break label$1;
   }
   HEAP16[$0 >> 1] = 0;
   return 101;
  }
  $2 = HEAP32[$0 >> 2];
  $4 = HEAP32[HEAP32[$2 >> 2] >> 2];
  HEAP32[$0 + 20 >> 2] = $3 - 1;
  whereLoopAdjustCost(HEAP32[$2 + 64 >> 2], $1);
  $0 = HEAP32[$0 + 12 >> 2];
  if ($0) {
   $3 = 0;
   if (!HEAPU16[$1 + 44 >> 1]) {
    break label$1;
   }
   whereOrInsert($0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAP16[$1 + 20 >> 1], HEAP16[$1 + 22 >> 1]);
   return 0;
  }
  $0 = whereLoopFindLesser($2 - -64 | 0, $1);
  if (!$0) {
   return 0;
  }
  label$5: {
   label$6: {
    $2 = HEAP32[$0 >> 2];
    if (!$2) {
     $2 = sqlite3DbMallocRawNN($4, 72, 0);
     HEAP32[$0 >> 2] = $2;
     if ($2) {
      break label$6;
     }
     return 7;
    }
    $0 = $2 + 56 | 0;
    while (1) {
     if (!HEAP32[$0 >> 2]) {
      break label$5;
     }
     $0 = whereLoopFindLesser($0, $1);
     if (!$0) {
      break label$5;
     }
     $3 = HEAP32[$0 >> 2];
     if (!$3) {
      break label$5;
     }
     HEAP32[$0 >> 2] = HEAP32[$3 + 56 >> 2];
     whereLoopDelete($4, $3);
     continue;
    }
   }
   whereLoopInit($2);
   HEAP32[$2 + 56 >> 2] = 0;
  }
  $3 = whereLoopXfer($4, $2, $1);
  if (HEAPU8[$2 + 41 | 0] & 4) {
   break label$1;
  }
  $0 = HEAP32[$2 + 32 >> 2];
  if (!$0 | ((HEAPU8[$0 + 55 | 0] | HEAPU8[$0 + 56 | 0] << 8) & 3) != 3) {
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = 0;
 }
 return $3;
}

function sqlite3_randomness($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 256 | 0;
 __stack_pointer = $5;
 label$1: {
  if (sqlite3_initialize()) {
   break label$1;
  }
  if (!($1 ? ($0 | 0) > 0 : 0)) {
   HEAP8[70496] = 0;
   break label$1;
  }
  if (!HEAPU8[70496]) {
   $2 = sqlite3_vfs_find(0);
   HEAP8[70497] = 0;
   HEAP8[70498] = 0;
   label$4: {
    if (!$2) {
     memset($5, 0, 256);
     break label$4;
    }
    sqlite3OsRandomness($2, $5);
   }
   $2 = 0;
   while (1) {
    if (($2 | 0) == 256) {
     $2 = 0;
     $3 = HEAPU8[70498];
     while (1) {
      if (($2 | 0) != 256) {
       $4 = $2 + 70499 | 0;
       $6 = HEAPU8[$4 | 0];
       $3 = ($6 + HEAPU8[$2 + $5 | 0] | 0) + $3 | 0;
       $7 = ($3 & 255) + 70499 | 0;
       $8 = HEAPU8[$7 | 0];
       HEAP8[$7 | 0] = $6;
       HEAP8[$4 | 0] = $8;
       $2 = $2 + 1 | 0;
       continue;
      }
      break;
     }
     HEAP8[70496] = 1;
     HEAP8[70498] = $3;
    } else {
     HEAP8[$2 + 70499 | 0] = $2;
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
  }
  while (1) {
   $2 = HEAPU8[70497] + 1 | 0;
   HEAP8[70497] = $2;
   $2 = ($2 & 255) + 70499 | 0;
   $3 = HEAPU8[$2 | 0];
   $4 = $3 + HEAPU8[70498] | 0;
   HEAP8[70498] = $4;
   $4 = ($4 & 255) + 70499 | 0;
   HEAP8[$2 | 0] = HEAPU8[$4 | 0];
   HEAP8[$4 | 0] = $3;
   HEAP8[$1 | 0] = HEAPU8[(HEAPU8[$2 | 0] + $3 & 255) + 70499 | 0];
   $1 = $1 + 1 | 0;
   $0 = $0 - 1 | 0;
   if ($0) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $5 + 256 | 0;
}

function sqlite3Fts3SegReaderNew($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0, $12 = 0, $13 = 0;
 $11 = $3;
 label$1: {
  if (!($11 | $2)) {
   $11 = $5;
   $12 = 267;
   if ($11 | $4) {
    break label$1;
   }
   $13 = $9 + 20 | 0;
  }
  $12 = sqlite3_malloc($13 + 96 | 0);
  if (!$12) {
   return 7;
  }
  $12 = memset($12, 0, 96);
  $11 = $12;
  HEAP32[$11 + 24 >> 2] = $6;
  HEAP32[$11 + 28 >> 2] = $7;
  HEAP32[$11 + 16 >> 2] = $4;
  HEAP32[$11 + 20 >> 2] = $5;
  HEAP32[$11 + 8 >> 2] = $2;
  HEAP32[$11 + 12 >> 2] = $3;
  HEAP8[$11 + 4 | 0] = ($1 | 0) != 0;
  HEAP32[$11 >> 2] = $0;
  label$4: {
   if ($13) {
    HEAP32[$12 + 44 >> 2] = $9;
    HEAP8[$12 + 5 | 0] = 1;
    $13 = $12 + 96 | 0;
    HEAP32[$12 + 40 >> 2] = $13;
    if ($9) {
     __memcpy($13, $8, $9);
    }
    $13 = $9 + $13 | 0;
    $11 = $13;
    HEAP8[$11 | 0] = 0;
    HEAP8[$11 + 1 | 0] = 0;
    HEAP8[$11 + 2 | 0] = 0;
    HEAP8[$11 + 3 | 0] = 0;
    HEAP8[$11 + 4 | 0] = 0;
    HEAP8[$11 + 5 | 0] = 0;
    HEAP8[$11 + 6 | 0] = 0;
    HEAP8[$11 + 7 | 0] = 0;
    HEAP8[$11 + 16 | 0] = 0;
    HEAP8[$11 + 17 | 0] = 0;
    HEAP8[$11 + 18 | 0] = 0;
    HEAP8[$11 + 19 | 0] = 0;
    HEAP8[$11 + 8 | 0] = 0;
    HEAP8[$11 + 9 | 0] = 0;
    HEAP8[$11 + 10 | 0] = 0;
    HEAP8[$11 + 11 | 0] = 0;
    HEAP8[$11 + 12 | 0] = 0;
    HEAP8[$11 + 13 | 0] = 0;
    HEAP8[$11 + 14 | 0] = 0;
    HEAP8[$11 + 15 | 0] = 0;
    break label$4;
   }
   HEAP32[$12 + 32 >> 2] = $2 - 1;
   HEAP32[$12 + 36 >> 2] = $3 - !$2;
  }
  HEAP32[$10 >> 2] = $12;
  $12 = 0;
 }
 return $12;
}

function decodeIntArray($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 while (1) {
  $4 = HEAPU8[$0 | 0];
  if (!(!$4 | ($1 | 0) <= ($6 | 0))) {
   $5 = 0;
   while (1) {
    if (($4 - 48 & 255) >>> 0 <= 9) {
     $5 = (Math_imul($5, 10) + ($4 & 255) | 0) - 48 | 0;
     $4 = HEAPU8[$0 + 1 | 0];
     $0 = $0 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP16[($6 << 1) + $2 >> 1] = sqlite3LogEst($5, 0);
   $6 = $6 + 1 | 0;
   $0 = (HEAPU8[$0 | 0] == 32) + $0 | 0;
   continue;
  }
  break;
 }
 $1 = (HEAPU8[$3 + 55 | 0] | HEAPU8[$3 + 56 | 0] << 8) & 65467;
 HEAP8[$3 + 55 | 0] = $1;
 HEAP8[$3 + 56 | 0] = $1 >>> 8;
 $5 = HEAPU8[$0 | 0];
 label$5: while (1) {
  if ($5 & 255) {
   label$7: {
    if (!sqlite3_strglob(24285, $0)) {
     $1 = HEAPU8[$3 + 55 | 0] | HEAPU8[$3 + 56 | 0] << 8 | 4;
     HEAP8[$3 + 55 | 0] = $1;
     HEAP8[$3 + 56 | 0] = $1 >>> 8;
     break label$7;
    }
    if (!sqlite3_strglob(24296, $0)) {
     $4 = sqlite3Atoi($0 + 3 | 0);
     HEAP16[$3 + 48 >> 1] = sqlite3LogEst(($4 | 0) > 2 ? $4 : 2, 0);
     break label$7;
    }
    if (sqlite3_strglob(24273, $0)) {
     break label$7;
    }
    $1 = HEAPU8[$3 + 55 | 0] | HEAPU8[$3 + 56 | 0] << 8 | 64;
    HEAP8[$3 + 55 | 0] = $1;
    HEAP8[$3 + 56 | 0] = $1 >>> 8;
   }
   while (1) if ((HEAPU8[$0 | 0] | 32) == 32) {
    $4 = $0;
    while (1) {
     $5 = HEAPU8[$4 | 0];
     $0 = $4;
     $4 = $0 + 1 | 0;
     if (($5 | 0) == 32) {
      continue;
     }
     break;
    }
    continue label$5;
   } else {
    $0 = $0 + 1 | 0;
    continue;
   }
  }
  break;
 }
}

function pcache1InitBulk($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (!(!HEAP32[17734] | HEAPU32[$0 + 28 >> 2] < 3)) {
  sqlite3BeginBenignMalloc();
  $1 = HEAP32[17734];
  label$2: {
   if (($1 | 0) > 0) {
    $2 = HEAP32[$0 + 16 >> 2];
    $3 = $2 >> 31;
    $4 = $2;
    $6 = $3;
    $2 = __wasm_i64_mul($2, $3, $1, 0);
    $7 = $2;
    $3 = i64toi32_i32$HIGH_BITS;
    break label$2;
   }
   $3 = HEAP32[$0 + 16 >> 2];
   $2 = $3 >> 31;
   $4 = $3;
   $6 = $2;
   $5 = $1 << 10;
   $2 = $1 >> 31;
   $3 = $2 << 10 | $1 >>> 22;
   $7 = 0 - $5 | 0;
   $1 = $3;
   $3 = 0 - ($1 + (($5 | 0) != 0) | 0) | 0;
  }
  $5 = $3;
  $2 = $6;
  $4 = __wasm_i64_mul($4, $2, HEAP32[$0 + 28 >> 2], 0);
  $2 = i64toi32_i32$HIGH_BITS;
  $3 = $4;
  $1 = $7 >>> 0 < $3 >>> 0 & ($5 | 0) <= ($2 | 0) | ($2 | 0) > ($5 | 0);
  $3 = $5;
  $2 = sqlite3Malloc($1 ? $7 : $4, $1 ? $3 : $2);
  HEAP32[$0 + 64 >> 2] = $2;
  sqlite3EndBenignMalloc();
  label$4: {
   if (!$2) {
    $1 = HEAP32[$0 + 60 >> 2];
    break label$4;
   }
   $3 = sqlite3MallocSize($2);
   $4 = HEAP32[$0 + 16 >> 2];
   $6 = ($3 | 0) / ($4 | 0) | 0;
   $3 = HEAP32[$0 + 60 >> 2];
   $5 = HEAP32[$0 + 8 >> 2];
   while (1) {
    $1 = $2 + $5 | 0;
    HEAP32[$1 + 28 >> 2] = 0;
    HEAP32[$1 + 16 >> 2] = $3;
    HEAP32[$1 + 12 >> 2] = 1;
    HEAP32[$1 >> 2] = $2;
    HEAP32[$1 + 4 >> 2] = $1 + 32;
    $2 = $2 + $4 | 0;
    $3 = $1;
    $6 = $6 - 1 | 0;
    if ($6) {
     continue;
    }
    break;
   }
   HEAP32[$0 + 60 >> 2] = $1;
  }
  $1 = ($1 | 0) != 0;
 }
 return $1;
}

function fts3SqlStmt($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $8 = ($1 << 2) + $0 | 0;
 $7 = $8 + 60 | 0;
 $5 = HEAP32[$7 >> 2];
 HEAP32[$4 + 44 >> 2] = $5;
 label$1: {
  if ($5) {
   break label$1;
  }
  label$2: {
   label$3: {
    if (($1 | 0) != 7) {
     if (($1 | 0) != 18) {
      break label$3;
     }
     $6 = HEAP32[$0 + 20 >> 2];
     $5 = HEAP32[$0 + 16 >> 2];
     HEAP32[$4 + 24 >> 2] = HEAP32[$0 + 228 >> 2];
     HEAP32[$4 + 16 >> 2] = $5;
     HEAP32[$4 + 20 >> 2] = $6;
     $1 = sqlite3_mprintf(24459, $4 + 16 | 0);
     $6 = 5;
     break label$2;
    }
    HEAP32[$4 + 32 >> 2] = HEAP32[$0 + 224 >> 2];
    $1 = sqlite3_mprintf(20446, $4 + 32 | 0);
    $6 = 1;
    break label$2;
   }
   $5 = HEAP32[$0 + 20 >> 2];
   $6 = HEAP32[$0 + 16 >> 2];
   HEAP32[$4 >> 2] = $6;
   HEAP32[$4 + 4 >> 2] = $5;
   $1 = sqlite3_mprintf(HEAP32[($1 << 2) + 54480 >> 2], $4);
   $6 = 5;
  }
  if (!$1) {
   $6 = 7;
   $5 = 0;
   break label$1;
  }
  $6 = sqlite3_prepare_v3(HEAP32[$0 + 12 >> 2], $1, -1, $6, $4 + 44 | 0, 0);
  sqlite3_free($1);
  $5 = HEAP32[$4 + 44 >> 2];
  HEAP32[$8 + 60 >> 2] = $5;
 }
 label$6: {
  if (!$3) {
   break label$6;
  }
  $1 = 0;
  $7 = sqlite3_bind_parameter_count($5);
  while (1) {
   if (($1 | 0) >= ($7 | 0) | $6) {
    break label$6;
   }
   $0 = $1 + 1 | 0;
   $6 = sqlite3_bind_value($5, $0, HEAP32[($1 << 2) + $3 >> 2]);
   $1 = $0;
   continue;
  }
 }
 HEAP32[$2 >> 2] = $5;
 __stack_pointer = $4 + 48 | 0;
 return $6;
}

function fts3EvalStart($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 $2 = HEAP32[$0 >> 2];
 HEAP32[$1 + 28 >> 2] = 0;
 HEAP32[$1 + 24 >> 2] = 0;
 HEAP32[$1 + 20 >> 2] = 0;
 fts3EvalAllocateReaders($0, HEAP32[$0 + 16 >> 2], $1 + 24 | 0, $1 + 20 | 0, $1 + 28 | 0);
 label$1: {
  if (HEAP32[$1 + 28 >> 2]) {
   break label$1;
  }
  $3 = HEAP32[$1 + 24 >> 2];
  if (!HEAPU8[$2 + 236 | 0] | ($3 | 0) < 2) {
   break label$1;
  }
  $4 = sqlite3_malloc64(Math_imul($3, 24) + (HEAP32[$1 + 20 >> 2] << 3) | 0, 0);
  if (!$4) {
   HEAP32[$1 + 28 >> 2] = 7;
   break label$1;
  }
  $2 = HEAP32[$1 + 24 >> 2];
  HEAP32[$1 + 16 >> 2] = $4;
  $5 = Math_imul($2, 24) + $4 | 0;
  HEAP32[$1 + 12 >> 2] = $5;
  $2 = 0;
  fts3EvalTokenCosts($0, 0, HEAP32[$0 + 16 >> 2], $1 + 16 | 0, $1 + 12 | 0, $1 + 28 | 0);
  $3 = (HEAP32[$1 + 16 >> 2] - $4 | 0) / 24 | 0;
  HEAP32[$1 + 24 >> 2] = $3;
  HEAP32[$1 + 20 >> 2] = HEAP32[$1 + 12 >> 2] - $5 >> 2;
  label$3: {
   if (HEAP32[$1 + 28 >> 2]) {
    break label$3;
   }
   $3 = fts3EvalSelectDeferred($0, 0, $4, $3);
   HEAP32[$1 + 28 >> 2] = $3;
   while (1) {
    if (HEAP32[$1 + 20 >> 2] <= ($2 | 0) | $3) {
     break label$3;
    }
    $3 = fts3EvalSelectDeferred($0, HEAP32[($2 << 2) + $5 >> 2], $4, HEAP32[$1 + 24 >> 2]);
    HEAP32[$1 + 28 >> 2] = $3;
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  sqlite3_free($4);
 }
 fts3EvalStartReaders($0, HEAP32[$0 + 16 >> 2], $1 + 28 | 0);
 __stack_pointer = $1 + 32 | 0;
 $2 = HEAP32[$1 + 28 >> 2];
 return $2;
}

function fts3ReadExprList($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 76 >> 2] = 0;
 label$1: {
  if (!HEAP32[$0 + 40 >> 2]) {
   if ($1) {
    $5 = fts3QuoteId($1);
    $1 = $5;
   } else {
    $1 = 29623;
   }
   fts3Appendf($2, $3 + 76 | 0, 14539, 0);
   while (1) {
    if (($4 | 0) < HEAP32[$0 + 24 >> 2]) {
     HEAP32[$3 + 8 >> 2] = HEAP32[HEAP32[$0 + 28 >> 2] + ($4 << 2) >> 2];
     HEAP32[$3 + 4 >> 2] = $4;
     HEAP32[$3 >> 2] = $1;
     fts3Appendf($2, $3 + 76 | 0, 26677, $3);
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   if (HEAP32[$0 + 44 >> 2]) {
    HEAP32[$3 + 32 >> 2] = 14521;
    fts3Appendf($2, $3 + 76 | 0, 19123, $3 + 32 | 0);
   }
   sqlite3_free($5);
   break label$1;
  }
  fts3Appendf($2, $3 + 76 | 0, 14442, 0);
  while (1) {
   if (($4 | 0) < HEAP32[$0 + 24 >> 2]) {
    HEAP32[$3 + 48 >> 2] = HEAP32[HEAP32[$0 + 28 >> 2] + ($4 << 2) >> 2];
    fts3Appendf($2, $3 + 76 | 0, 27503, $3 + 48 | 0);
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = HEAP32[$0 + 44 >> 2];
  if (!$4) {
   break label$1;
  }
  HEAP32[$3 + 64 >> 2] = $4;
  fts3Appendf($2, $3 + 76 | 0, 19123, $3 - -64 | 0);
 }
 $5 = HEAP32[$0 + 16 >> 2];
 $4 = 29623;
 $1 = HEAP32[$0 + 40 >> 2];
 if (!$1) {
  $4 = 2589;
  $1 = HEAP32[$0 + 20 >> 2];
 }
 HEAP32[$3 + 24 >> 2] = $4;
 HEAP32[$3 + 20 >> 2] = $1;
 HEAP32[$3 + 16 >> 2] = $5;
 fts3Appendf($2, $3 + 76 | 0, 1582, $3 + 16 | 0);
 __stack_pointer = $3 + 80 | 0;
 $4 = HEAP32[$3 + 76 >> 2];
 return $4;
}

function analysisLoader($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $3 = __stack_pointer - 80 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $1 = HEAP32[$2 >> 2];
  if (!$1 | !HEAP32[$2 + 8 >> 2]) {
   break label$1;
  }
  $1 = sqlite3FindTable(HEAP32[$0 >> 2], $1, HEAP32[$0 + 4 >> 2]);
  if (!$1) {
   break label$1;
  }
  label$2: {
   $4 = HEAP32[$2 + 4 >> 2];
   if (!$4) {
    $2 = HEAP32[$2 + 8 >> 2];
    break label$2;
   }
   label$4: {
    if (!sqlite3_stricmp(HEAP32[$2 >> 2], $4)) {
     $0 = sqlite3PrimaryKeyIndex($1);
     break label$4;
    }
    $0 = sqlite3FindIndex(HEAP32[$0 >> 2], $4, HEAP32[$0 + 4 >> 2]);
   }
   $2 = HEAP32[$2 + 8 >> 2];
   if (!$0) {
    break label$2;
   }
   $4 = (HEAPU8[$0 + 55 | 0] | HEAPU8[$0 + 56 | 0] << 8) & 65531;
   HEAP8[$0 + 55 | 0] = $4;
   HEAP8[$0 + 56 | 0] = $4 >>> 8;
   decodeIntArray($2, HEAPU16[$0 + 50 >> 1] + 1 | 0, HEAP32[$0 + 8 >> 2], $0);
   $2 = HEAPU8[$0 + 55 | 0] | HEAPU8[$0 + 56 | 0] << 8 | 128;
   HEAP8[$0 + 55 | 0] = $2;
   HEAP8[$0 + 56 | 0] = $2 >>> 8;
   if (HEAP32[$0 + 36 >> 2]) {
    break label$1;
   }
   HEAP16[$1 + 38 >> 1] = HEAPU16[HEAP32[$0 + 8 >> 2] >> 1];
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | 16;
   break label$1;
  }
  HEAP16[$3 + 56 >> 1] = HEAPU16[$1 + 40 >> 1];
  decodeIntArray($2, 1, $1 + 38 | 0, $3 + 8 | 0);
  HEAP16[$1 + 40 >> 1] = HEAPU16[$3 + 56 >> 1];
  HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] | 16;
 }
 __stack_pointer = $3 + 80 | 0;
 return 0;
}

function fts3InsertData($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  label$2: {
   if (HEAP32[$0 + 40 >> 2]) {
    $3 = 19;
    $0 = HEAP32[((HEAP32[$0 + 24 >> 2] << 2) + $1 | 0) + 12 >> 2];
    if ((sqlite3_value_type($0) | 0) == 5) {
     $0 = HEAP32[$1 + 4 >> 2];
    }
    if ((sqlite3_value_type($0) | 0) != 1) {
     break label$1;
    }
    $3 = 0;
    $0 = sqlite3_value_int64($0);
    $1 = i64toi32_i32$HIGH_BITS;
    break label$2;
   }
   $3 = fts3SqlStmt($0, 18, $4 + 12 | 0, $1 + 4 | 0);
   if ($3) {
    break label$1;
   }
   if (HEAP32[$0 + 44 >> 2]) {
    $3 = HEAP32[$0 + 24 >> 2];
    $3 = sqlite3_bind_int(HEAP32[$4 + 12 >> 2], $3 + 2 | 0, sqlite3_value_int(HEAP32[(($3 << 2) + $1 | 0) + 16 >> 2]));
    if ($3) {
     break label$1;
    }
   }
   $5 = HEAP32[((HEAP32[$0 + 24 >> 2] << 2) + $1 | 0) + 12 >> 2];
   label$6: {
    if ((sqlite3_value_type($5) | 0) == 5) {
     $1 = HEAP32[$4 + 12 >> 2];
     break label$6;
    }
    if ((sqlite3_value_type(HEAP32[$1 >> 2]) | 0) == 5) {
     $3 = 1;
     if ((sqlite3_value_type(HEAP32[$1 + 4 >> 2]) | 0) != 5) {
      break label$1;
     }
    }
    $1 = HEAP32[$4 + 12 >> 2];
    $3 = sqlite3_bind_value($1, 1, $5);
    if ($3) {
     break label$1;
    }
   }
   sqlite3_step($1);
   $3 = sqlite3_reset($1);
   $0 = sqlite3_last_insert_rowid(HEAP32[$0 + 12 >> 2]);
   $1 = i64toi32_i32$HIGH_BITS;
  }
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function sqlite3CreateColumnExpr($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $0 = sqlite3ExprAlloc($0, 167, 0, 0);
 if ($0) {
  $6 = ($2 << 6) + $1 | 0;
  $4 = HEAP32[$6 + 24 >> 2];
  HEAP32[$0 + 44 >> 2] = $4;
  HEAP32[$0 + 28 >> 2] = HEAP32[$6 + 48 >> 2];
  if (HEAP16[$4 + 32 >> 1] == ($3 | 0)) {
   HEAP16[$0 + 32 >> 1] = 65535;
   return $0;
  }
  HEAP16[$0 + 32 >> 1] = $3;
  if (!(!(HEAPU8[$4 + 28 | 0] & 96) | !(HEAPU8[(HEAP32[$4 + 4 >> 2] + Math_imul($3, 12) | 0) + 10 | 0] & 96))) {
   $8 = ($2 << 6) + $1 | 0;
   $2 = $4;
   $3 = HEAP16[$2 + 34 >> 1];
   $1 = $3 >> 31;
   $4 = $3;
   $6 = $1;
   $5 = $4 & 31;
   if (($4 & 63) >>> 0 >= 32) {
    $3 = -1 << $5;
    $1 = 0;
   } else {
    $3 = (1 << $5) - 1 & -1 >>> 32 - $5 | -1 << $5;
    $1 = -1 << $5;
   }
   $2 = $3 ^ -1;
   $7 = $2;
   $3 = $4;
   $2 = $6;
   $5 = $3 >>> 0 > 63 & ($2 | 0) >= 0 | ($2 | 0) > 0;
   $1 = $5 ? -1 : $1 ^ -1;
   $2 = $1;
   $1 = $8;
   HEAP32[$1 + 56 >> 2] = $2;
   $2 = $7;
   $4 = $5 ? -1 : $2;
   HEAP32[$1 + 60 >> 2] = $4;
   return $0;
  }
  $5 = ($2 << 6) + $1 | 0;
  $2 = $5 + 56 | 0;
  $6 = $2;
  $4 = HEAP32[$5 + 56 >> 2];
  $7 = $4;
  $1 = HEAP32[$5 + 60 >> 2];
  $5 = $1;
  $3 = ($3 | 0) < 63 ? $3 : 63;
  $2 = $3 & 31;
  if (($3 & 63) >>> 0 >= 32) {
   $4 = 1 << $2;
   $3 = 0;
  } else {
   $4 = (1 << $2) - 1 & 1 >>> 32 - $2;
   $3 = 1 << $2;
  }
  $2 = $4;
  $1 = $7;
  $3 = $3 | $1;
  $1 = $6;
  HEAP32[$1 >> 2] = $3;
  $4 = $5;
  $5 = $2;
  $5 = $4 | $5;
  HEAP32[$1 + 4 >> 2] = $5;
 }
 return $0;
}

function walRewriteChecksums($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $8 = __stack_pointer - 32 | 0;
 __stack_pointer = $8;
 $5 = HEAP32[$0 + 36 >> 2] + 24 | 0;
 $6 = sqlite3_malloc($5);
 label$1: {
  if (!$6) {
   $2 = 7;
   break label$1;
  }
  $9 = HEAP32[$0 + 8 >> 2];
  $7 = HEAP32[$0 + 104 >> 2];
  label$3: {
   if (($7 | 0) == 1) {
    $3 = $5 >> 31;
    $10 = $3;
    $2 = 24;
    $4 = 0;
    break label$3;
   }
   $3 = $5 >> 31;
   $10 = $3;
   $3 = __wasm_i64_mul($5, $3, $7 - 2 | 0, 0);
   $2 = $3;
   $3 = i64toi32_i32$HIGH_BITS;
   $4 = $3;
   $2 = $2 + 48 | 0;
   $4 = $2 >>> 0 < 48 ? $4 + 1 | 0 : $4;
  }
  $3 = $2;
  $2 = sqlite3OsRead($9, $6, 8, $3, $4);
  HEAP32[$0 + 76 >> 2] = sqlite3Get4byte($6);
  $11 = $6 + 4 | 0;
  HEAP32[$0 + 80 >> 2] = sqlite3Get4byte($11);
  $7 = HEAP32[$0 + 104 >> 2];
  HEAP32[$0 + 104 >> 2] = 0;
  $12 = $6 + 24 | 0;
  while (1) {
   if (!($1 >>> 0 < $7 >>> 0 | $2)) {
    $9 = HEAP32[$0 + 8 >> 2];
    $4 = $10;
    $2 = __wasm_i64_mul($5, $4, $7 - 1 | 0, 0);
    $3 = $2;
    $4 = i64toi32_i32$HIGH_BITS;
    $3 = $3 + 32 | 0;
    $2 = $3 >>> 0 < 32 ? $4 + 1 | 0 : $4;
    $4 = $2;
    $2 = sqlite3OsRead($9, $6, $5, $3, $2);
    if (!$2) {
     walEncodeFrame($0, sqlite3Get4byte($6), sqlite3Get4byte($11), $12, $8);
     $2 = sqlite3OsWrite(HEAP32[$0 + 8 >> 2], $8, 24, $3, $4);
    }
    $7 = $7 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_free($6);
 }
 __stack_pointer = $8 + 32 | 0;
 return $2;
}

function sqlite3Fts3GetVarintU($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $3 = HEAP8[$0 | 0];
 if (($3 | 0) >= 0) {
  HEAP32[$1 >> 2] = $3 & 255;
  HEAP32[$1 + 4 >> 2] = 0;
  return 1;
 }
 $6 = HEAP8[$0 + 1 | 0];
 $3 = $3 & 127 | ($6 & 255) << 7;
 if (($6 | 0) >= 0) {
  HEAP32[$1 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = 0;
  return 2;
 }
 $6 = HEAP8[$0 + 2 | 0];
 $3 = $3 & 16383 | ($6 & 255) << 14;
 if (($6 | 0) >= 0) {
  HEAP32[$1 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = 0;
  return 3;
 }
 $6 = HEAP8[$0 + 3 | 0];
 $5 = $3 & 2097151 | ($6 & 255) << 21;
 if (($6 | 0) >= 0) {
  HEAP32[$1 >> 2] = $5;
  HEAP32[$1 + 4 >> 2] = 0;
  return 4;
 }
 $12 = $0 + 10 | 0;
 $3 = $0 + 4 | 0;
 $9 = $5 & 268435455;
 $8 = 28;
 while (1) {
  label$6: {
   $4 = $10;
   if (!$4 & $8 >>> 0 > 63 | $4) {
    $5 = $12;
    break label$6;
   }
   $6 = HEAP8[$3 | 0];
   $7 = $6 & 127;
   $5 = $8;
   $2 = $5 & 31;
   if (($5 & 63) >>> 0 >= 32) {
    $4 = $7 << $2;
    $2 = 0;
   } else {
    $4 = (1 << $2) - 1 & $7 >>> 32 - $2;
    $2 = $7 << $2;
   }
   $5 = $9;
   $2 = $2 + $5 | 0;
   $7 = $11;
   $4 = $7 + $4 | 0;
   $9 = $2;
   $4 = $2 >>> 0 < $5 >>> 0 ? $4 + 1 | 0 : $4;
   $11 = $4;
   $4 = $10;
   $2 = $4;
   $4 = $8;
   $7 = $4 + 7 | 0;
   $2 = $7 >>> 0 < 7 ? $2 + 1 | 0 : $2;
   $8 = $7;
   $10 = $2;
   $5 = $3 + 1 | 0;
   $3 = $5;
   if (($6 | 0) < 0) {
    continue;
   }
  }
  break;
 }
 HEAP32[$1 >> 2] = $9;
 $2 = $11;
 HEAP32[$1 + 4 >> 2] = $2;
 return $5 - $0 | 0;
}

function sqlite3SrcListEnlarge($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 label$1: {
  $4 = HEAP32[$1 >> 2];
  $5 = $4 + $2 | 0;
  if ($5 >>> 0 > HEAPU32[$1 + 4 >> 2]) {
   label$3: {
    label$4: {
     if (($5 | 0) >= 200) {
      HEAP32[$9 >> 2] = 200;
      sqlite3ErrorMsg($0, 16911, $9);
      break label$4;
     }
     $5 = $2 >> 31;
     $6 = $5;
     $5 = $4 >> 31;
     $8 = $5 << 1 | $4 >>> 31;
     $7 = $6 + $8 | 0;
     $6 = $4 << 1;
     $4 = $2 + $6 | 0;
     $7 = $6 >>> 0 > $4 >>> 0 ? $7 + 1 | 0 : $7;
     $8 = $4 >>> 0 < 200 & ($7 | 0) <= 0 | ($7 | 0) < 0;
     $5 = $8 ? $4 : 200;
     $4 = $5;
     $6 = $8 ? $7 : 0;
     $8 = $6;
     $5 = $6 << 6 | $4 >>> 26;
     $6 = $4 << 6;
     $1 = sqlite3DbRealloc(HEAP32[$0 >> 2], $1, $6 | 8, $5);
     if ($1) {
      break label$3;
     }
    }
    $1 = 0;
    break label$1;
   }
   HEAP32[$1 + 4 >> 2] = $4;
   $4 = HEAP32[$1 >> 2];
  }
  $5 = $1 + 8 | 0;
  while (1) {
   if (($3 | 0) < ($4 | 0)) {
    $4 = $4 - 1 | 0;
    __memcpy(($4 + $2 << 6) + $5 | 0, ($4 << 6) + $5 | 0, 64);
    continue;
   }
   break;
  }
  HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + $2;
  memset((($3 << 6) + $1 | 0) + 8 | 0, 0, $2 << 6);
  $4 = $2 + $3 | 0;
  $4 = ($3 | 0) > ($4 | 0) ? $3 : $4;
  while (1) {
   if (($3 | 0) == ($4 | 0)) {
    break label$1;
   }
   HEAP32[(($3 << 6) + $1 | 0) + 48 >> 2] = -1;
   $3 = $3 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $9 + 16 | 0;
 return $1;
}

function detachFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 $4 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $2 = 0;
 $6 = sqlite3_context_db_handle($0);
 $3 = HEAP32[$6 + 20 >> 2];
 $3 = ($3 | 0) > 0 ? $3 : 0;
 $8 = $4 ? $4 : 29623;
 label$1: {
  label$2: {
   while (1) {
    if (($2 | 0) == ($3 | 0)) {
     $3 = 7680;
     break label$2;
    }
    label$5: {
     $7 = HEAP32[$6 + 16 >> 2];
     $1 = $7 + ($2 << 4) | 0;
     $4 = HEAP32[$1 + 4 >> 2];
     if ($4) {
      if (sqlite3DbIsNamed($6, $2, $8)) {
       break label$5;
      }
     }
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   $3 = 6401;
   if ($2 >>> 0 < 2) {
    break label$2;
   }
   $3 = 15424;
   if (sqlite3BtreeTxnState($4)) {
    break label$2;
   }
   if (sqlite3BtreeIsInBackup($4)) {
    break label$2;
   }
   $0 = ($2 << 4) + $7 | 0;
   $2 = HEAP32[$7 + 28 >> 2] + 48 | 0;
   while (1) {
    $2 = HEAP32[$2 >> 2];
    if ($2) {
     $3 = HEAP32[$2 + 8 >> 2];
     if (HEAP32[$3 + 24 >> 2] != HEAP32[$0 + 12 >> 2]) {
      continue;
     }
     HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 20 >> 2];
     continue;
    }
    break;
   }
   sqlite3BtreeClose($4);
   HEAP32[$1 + 4 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = 0;
   sqlite3CollapseDatabaseArray($6);
   break label$1;
  }
  HEAP32[$5 >> 2] = $8;
  sqlite3_result_error($0, sqlite3_snprintf(128, $5 + 16 | 0, $3, $5), -1);
 }
 __stack_pointer = $5 + 144 | 0;
}

function vdbeSorterMergeTreeBuild($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 while (1) {
  label$2: {
   label$3: {
    if (!$2) {
     if (HEAPU8[$0 + 59 | 0] <= $5 >>> 0) {
      break label$3;
     }
     HEAP32[$3 + 28 >> 2] = 0;
     $2 = Math_imul($5, 72) + $0 | 0;
     $11 = $2;
     $4 = HEAP32[$2 + 92 >> 2];
     $12 = vdbeSorterTreeDepth($4);
     HEAP32[$3 + 16 >> 2] = 0;
     HEAP32[$3 + 20 >> 2] = 0;
     $6 = $2 - -64 | 0;
     if (($4 | 0) <= 16) {
      $2 = vdbeMergeEngineLevel0($6, $4, $3 + 16 | 0, $3 + 28 | 0);
      break label$2;
     }
     $7 = vdbeMergeEngineNew(16);
     HEAP32[$3 + 28 >> 2] = $7;
     $4 = 0;
     $2 = $7 ? 0 : 7;
     $8 = 0;
     while (1) {
      $10 = HEAP32[$11 + 92 >> 2];
      if (($10 | 0) <= ($4 | 0) | $2) {
       break label$2;
      }
      HEAP32[$3 + 12 >> 2] = 0;
      $2 = $10 - $4 | 0;
      $2 = vdbeMergeEngineLevel0($6, ($2 | 0) < 16 ? $2 : 16, $3 + 16 | 0, $3 + 12 | 0);
      if (!$2) {
       $2 = vdbeSorterAddToTree($6, $12, $8, $7, HEAP32[$3 + 12 >> 2]);
       $8 = $8 + 1 | 0;
      }
      $4 = $4 + 16 | 0;
      continue;
     }
    }
    vdbeMergeEngineFree($9);
    $9 = 0;
   }
   HEAP32[$1 >> 2] = $9;
   __stack_pointer = $3 + 32 | 0;
   return $2;
  }
  $4 = HEAP32[$3 + 28 >> 2];
  label$8: {
   if (!$2) {
    $9 = $4;
    break label$8;
   }
   vdbeMergeEngineFree($4);
  }
  $5 = $5 + 1 | 0;
  continue;
 }
}

function pageFindSlot($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = HEAP32[$0 + 56 >> 2];
 $7 = HEAPU8[$0 + 9 | 0];
 $6 = $7 + 1 | 0;
 $3 = $5 + $6 | 0;
 $3 = HEAPU8[$3 | 0] << 8 | HEAPU8[$3 + 1 | 0];
 $8 = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2];
 $9 = $8 - $1 | 0;
 label$1: {
  label$2: {
   while (1) {
    $0 = $3;
    if (($9 | 0) < ($3 | 0)) {
     break label$2;
    }
    $3 = $0 + $5 | 0;
    $10 = HEAPU8[$3 + 3 | 0] | HEAPU8[$3 + 2 | 0] << 8;
    $4 = $10 - $1 | 0;
    if (($4 | 0) >= 0) {
     if ($4 >>> 0 <= 3) {
      $1 = $5 + $7 | 0;
      $0 = $1 + 7 | 0;
      if (HEAPU8[$0 | 0] > 57) {
       break label$1;
      }
      $0 = $5 + $6 | 0;
      $2 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8;
      HEAP8[$0 | 0] = $2;
      HEAP8[$0 + 1 | 0] = $2 >>> 8;
      HEAP8[$1 + 7 | 0] = HEAPU8[$1 + 7 | 0] + $4;
      return $3;
     }
     $0 = $0 + $4 | 0;
     if (($9 | 0) < ($0 | 0)) {
      HEAP32[$2 >> 2] = sqlite3CorruptError(68516);
      return 0;
     }
     $1 = $4 << 8 | ($4 & 65280) >>> 8;
     HEAP8[$3 + 2 | 0] = $1;
     HEAP8[$3 + 3 | 0] = $1 >>> 8;
     return $0 + $5 | 0;
    }
    $6 = $0;
    $3 = HEAPU8[$3 + 1 | 0] | HEAPU8[$3 | 0] << 8;
    if ($3 >>> 0 > $0 + $10 >>> 0) {
     continue;
    }
    break;
   }
   if (!$3) {
    break label$1;
   }
   HEAP32[$2 >> 2] = sqlite3CorruptError(68531);
   return 0;
  }
  if (($8 - 4 | 0) >= ($0 | 0)) {
   break label$1;
  }
  HEAP32[$2 >> 2] = sqlite3CorruptError(68538);
 }
 return 0;
}

function porterNext($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = HEAP32[$0 + 12 >> 2];
 $9 = HEAP32[$0 + 8 >> 2];
 $10 = HEAP32[$0 + 4 >> 2];
 while (1) {
  $8 = $6;
  if (($6 | 0) >= ($9 | 0)) {
   return 101;
  }
  while (1) {
   label$4: {
    if (($8 | 0) >= ($9 | 0)) {
     break label$4;
    }
    $6 = HEAP8[$8 + $10 | 0];
    if ($6 & 128 | (HEAPU8[$6 + 54656 | 0] ? ($6 | 0) >= 48 : 0)) {
     break label$4;
    }
    $8 = $8 + 1 | 0;
    HEAP32[$0 + 12 >> 2] = $8;
    continue;
   }
   break;
  }
  $6 = $8;
  while (1) {
   label$7: {
    if (($6 | 0) >= ($9 | 0)) {
     break label$7;
    }
    $7 = HEAP8[$6 + $10 | 0];
    if (!($7 & 128) & (!HEAPU8[$7 + 54656 | 0] | ($7 | 0) < 48)) {
     break label$7;
    }
    $6 = $6 + 1 | 0;
    HEAP32[$0 + 12 >> 2] = $6;
    continue;
   }
   break;
  }
  if (($6 | 0) <= ($8 | 0)) {
   continue;
  }
  break;
 }
 $6 = $6 - $8 | 0;
 label$9: {
  if (($6 | 0) <= HEAP32[$0 + 24 >> 2]) {
   $7 = HEAP32[$0 + 20 >> 2];
   break label$9;
  }
  $7 = $6 + 20 | 0;
  HEAP32[$0 + 24 >> 2] = $7;
  $7 = sqlite3_realloc(HEAP32[$0 + 20 >> 2], $7);
  if (!$7) {
   return 7;
  }
  HEAP32[$0 + 20 >> 2] = $7;
 }
 porter_stemmer($8 + $10 | 0, $6, $7, $2);
 HEAP32[$1 >> 2] = HEAP32[$0 + 20 >> 2];
 HEAP32[$3 >> 2] = $8;
 HEAP32[$4 >> 2] = HEAP32[$0 + 12 >> 2];
 $6 = HEAP32[$0 + 16 >> 2];
 HEAP32[$0 + 16 >> 2] = $6 + 1;
 HEAP32[$5 >> 2] = $6;
 return 0;
}

function sqlite3CollapseDatabaseArray($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = 2;
 $5 = 2;
 while (1) {
  if (($5 | 0) < HEAP32[$0 + 20 >> 2]) {
   $2 = HEAP32[$0 + 16 >> 2];
   $1 = $2 + ($5 << 4) | 0;
   label$3: {
    if (!HEAP32[$1 + 4 >> 2]) {
     sqlite3DbFree($0, HEAP32[$1 >> 2]);
     HEAP32[$1 >> 2] = 0;
     break label$3;
    }
    if (($5 | 0) > ($6 | 0)) {
     $3 = HEAP32[$1 + 4 >> 2];
     $4 = HEAP32[$1 >> 2];
     $7 = $4;
     $2 = ($6 << 4) + $2 | 0;
     $4 = $2;
     HEAP32[$4 >> 2] = $7;
     HEAP32[$4 + 4 >> 2] = $3;
     $4 = HEAP32[$1 + 12 >> 2];
     $3 = HEAP32[$1 + 8 >> 2];
     $1 = $3;
     $3 = $2;
     HEAP32[$3 + 8 >> 2] = $1;
     HEAP32[$3 + 12 >> 2] = $4;
    }
    $6 = $6 + 1 | 0;
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 + 20 >> 2] = $6;
 label$6: {
  if (($6 | 0) > 2) {
   break label$6;
  }
  $5 = HEAP32[$0 + 16 >> 2];
  $1 = $0 + 456 | 0;
  if (($5 | 0) == ($1 | 0)) {
   break label$6;
  }
  $2 = $5;
  $4 = HEAP32[$2 >> 2];
  $3 = HEAP32[$2 + 4 >> 2];
  HEAP32[$1 >> 2] = $4;
  HEAP32[$1 + 4 >> 2] = $3;
  $4 = HEAP32[$2 + 28 >> 2];
  $3 = HEAP32[$2 + 24 >> 2];
  HEAP32[$1 + 24 >> 2] = $3;
  HEAP32[$1 + 28 >> 2] = $4;
  $3 = HEAP32[$2 + 20 >> 2];
  $4 = HEAP32[$2 + 16 >> 2];
  HEAP32[$1 + 16 >> 2] = $4;
  HEAP32[$1 + 20 >> 2] = $3;
  $4 = HEAP32[$2 + 12 >> 2];
  $3 = HEAP32[$2 + 8 >> 2];
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $4;
  sqlite3DbFree($0, $2);
  HEAP32[$0 + 16 >> 2] = $1;
 }
}

function fts3NodeWrite($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
 while (1) {
  label$2: {
   if (!HEAP32[$1 >> 2]) {
    $10 = fts3TreeFinishNode($1, $2, $3, $4);
    $12 = $5;
    $13 = $12 - 1 | 0;
    $11 = !$12;
    $11 = $6 - $11 | 0;
    $12 = $7;
    HEAP32[$12 >> 2] = $13;
    HEAP32[$12 + 4 >> 2] = $11;
    HEAP32[$9 >> 2] = HEAP32[$1 + 32 >> 2] - $10;
    HEAP32[$8 >> 2] = HEAP32[$1 + 36 >> 2] + $10;
    $14 = 0;
    break label$2;
   }
   $17 = $1 + 8 | 0;
   $14 = 0;
   $15 = $5;
   $11 = $6;
   $16 = $11;
   while (1) {
    $10 = HEAP32[$17 >> 2];
    if (!(!$10 | $14)) {
     $17 = $10 + 4 | 0;
     $11 = $4;
     $14 = fts3TreeFinishNode($10, $2, $3, $11);
     $11 = $16;
     $14 = fts3WriteSegment($0, $15, $11, HEAP32[$10 + 36 >> 2] + $14 | 0, HEAP32[$10 + 32 >> 2] - $14 | 0);
     $12 = HEAP32[$10 + 12 >> 2] + 1 | 0;
     $11 = $12 >> 31;
     $18 = $12;
     $12 = $11;
     $11 = $4;
     $13 = $12 + $11 | 0;
     $10 = $3 + $18 | 0;
     $13 = $18 >>> 0 > $10 >>> 0 ? $13 + 1 | 0 : $13;
     $3 = $10;
     $4 = $13;
     $13 = $16;
     $10 = $13;
     $11 = $15;
     $12 = $11 + 1 | 0;
     $10 = $12 ? $10 : $10 + 1 | 0;
     $15 = $12;
     $16 = $10;
     continue;
    }
    break;
   }
   if ($14) {
    break label$2;
   }
   $2 = $2 + 1 | 0;
   $1 = HEAP32[$1 >> 2];
   $3 = $5;
   $10 = $6;
   $4 = $10;
   $5 = $15;
   $10 = $16;
   $6 = $10;
   continue;
  }
  break;
 }
 return $14;
}

function fts3EvalNext($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 $2 = HEAP32[$0 + 16 >> 2];
 label$1: {
  label$2: {
   if ($2) {
    while (1) {
     if (!HEAPU8[$0 + 7 | 0]) {
      sqlite3_reset(HEAP32[$0 + 12 >> 2]);
     }
     fts3EvalNextRow($0, $2, $4 + 12 | 0);
     $5 = HEAPU8[$2 + 32 | 0];
     HEAP32[$0 + 88 >> 2] = 1;
     HEAP8[$0 + 7 | 0] = 1;
     HEAP8[$0 + 6 | 0] = $5;
     $1 = HEAP32[$2 + 28 >> 2];
     $3 = HEAP32[$2 + 24 >> 2];
     HEAP32[$0 + 32 >> 2] = $3;
     HEAP32[$0 + 36 >> 2] = $1;
     if (!$5) {
      if (sqlite3Fts3EvalTestDeferred($0, $4 + 12 | 0)) {
       continue;
      }
     }
     break;
    }
    $2 = HEAP32[$4 + 12 >> 2];
    if ($2) {
     break label$1;
    }
    break label$2;
   }
   HEAP8[$0 + 6 | 0] = 1;
  }
  $1 = HEAP32[$0 + 32 >> 2];
  $7 = $1;
  $3 = HEAP32[$0 + 36 >> 2];
  $5 = $3;
  label$7: {
   if (!HEAPU8[$0 + 52 | 0]) {
    $2 = 0;
    $3 = HEAP32[$0 + 80 >> 2];
    $6 = $3;
    $1 = HEAP32[$0 + 84 >> 2];
    $3 = $1;
    $1 = $5;
    if (($3 | 0) <= ($1 | 0) & $7 >>> 0 > $6 >>> 0 | ($3 | 0) < ($1 | 0)) {
     break label$7;
    }
    break label$1;
   }
   $2 = 0;
   $1 = HEAP32[$0 + 76 >> 2];
   $6 = $1;
   $1 = $5;
   $3 = HEAP32[$0 + 72 >> 2];
   if (($6 | 0) <= ($1 | 0) & $3 >>> 0 <= $7 >>> 0 | ($1 | 0) > ($6 | 0)) {
    break label$1;
   }
  }
  HEAP8[$0 + 6 | 0] = 1;
 }
 __stack_pointer = $4 + 16 | 0;
 return $2;
}

function btreeNext($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAPU8[$0 | 0];
 label$1: {
  label$2: {
   if (!$1) {
    break label$2;
   }
   if ($1 >>> 0 >= 3) {
    $2 = btreeRestoreCursorPosition($0);
    if ($2) {
     break label$1;
    }
    $1 = HEAPU8[$0 | 0];
   }
   $2 = 101;
   label$4: {
    switch (($1 & 255) - 1 | 0) {
    case 0:
     break label$1;

    case 1:
     break label$4;

    default:
     break label$2;
    }
   }
   $2 = 0;
   HEAP8[$0 | 0] = 0;
   if (HEAP32[$0 + 4 >> 2] > 0) {
    break label$1;
   }
  }
  $2 = HEAPU16[$0 + 70 >> 1] + 1 | 0;
  HEAP16[$0 + 70 >> 1] = $2;
  label$5: {
   $1 = HEAP32[$0 + 116 >> 2];
   if (HEAPU8[$1 | 0]) {
    if (!sqlite3FaultSim(412)) {
     break label$5;
    }
   }
   return sqlite3CorruptError(72945);
  }
  $3 = HEAPU8[$1 + 8 | 0];
  label$7: {
   if (HEAPU16[$1 + 24 >> 1] <= ($2 & 65535) >>> 0) {
    if (!$3) {
     $2 = moveToChild($0, sqlite3Get4byte((HEAPU8[$1 + 9 | 0] + HEAP32[$1 + 56 >> 2] | 0) + 8 | 0));
     if (!$2) {
      break label$7;
     }
     break label$1;
    }
    while (1) {
     if (!HEAPU8[$0 + 68 | 0]) {
      HEAP8[$0 | 0] = 1;
      return 101;
     }
     moveToParent($0);
     $1 = HEAP32[$0 + 116 >> 2];
     if (HEAPU16[$0 + 70 >> 1] >= HEAPU16[$1 + 24 >> 1]) {
      continue;
     }
     break;
    }
    if (!HEAPU8[$1 + 1 | 0]) {
     return 0;
    }
    return sqlite3BtreeNext($0);
   }
   $2 = 0;
   if ($3) {
    break label$1;
   }
  }
  $2 = moveToLeftmost($0);
 }
 return $2;
}

function sqlite3UpsertDoUpdate($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = HEAP32[$1 + 40 >> 2];
 $8 = HEAP32[$0 >> 2];
 $6 = HEAP32[$0 + 8 >> 2];
 $9 = sqlite3UpsertOfIndex($1, $3);
 label$1: {
  if (!$3 | ($4 | 0) == ($7 | 0)) {
   break label$1;
  }
  if (!(HEAPU8[$2 + 28 | 0] & 128)) {
   $5 = sqlite3GetTempReg($0);
   sqlite3VdbeAddOp2($6, 142, $4, $5);
   sqlite3VdbeAddOp3($6, 29, $7, 0, $5);
   sqlite3ReleaseTempReg($0, $5);
   break label$1;
  }
  $5 = HEAP32[$0 + 44 >> 2];
  $11 = sqlite3PrimaryKeyIndex($2);
  $10 = HEAPU16[$11 + 50 >> 1];
  HEAP32[$0 + 44 >> 2] = $5 + $10;
  $12 = $5 + 1 | 0;
  $5 = 0;
  while (1) {
   if (($5 | 0) != ($10 | 0)) {
    sqlite3VdbeAddOp3($6, 94, $4, sqlite3TableColumnToIndex($3, HEAP16[HEAP32[$11 + 4 >> 2] + ($5 << 1) >> 1]), $5 + $12 | 0);
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  $5 = sqlite3VdbeAddOp4Int($6, 28, $7, 0, $12, $10);
  sqlite3VdbeAddOp4($6, 70, 11, 2, 0, 12902, -1);
  sqlite3MayAbort($0);
  sqlite3VdbeJumpHere($6, $5);
 }
 $5 = 0;
 $3 = sqlite3SrcListDup($8, HEAP32[$1 + 32 >> 2], 0);
 while (1) {
  if (HEAP16[$2 + 34 >> 1] > ($5 | 0)) {
   if (HEAPU8[(HEAP32[$2 + 4 >> 2] + Math_imul($5, 12) | 0) + 5 | 0] == 69) {
    sqlite3VdbeAddOp1($6, 87, HEAP32[$1 + 36 >> 2] + $5 | 0);
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3Update($0, $3, sqlite3ExprListDup($8, HEAP32[$9 + 8 >> 2], 0), sqlite3ExprDup($8, HEAP32[$9 + 12 >> 2], 0), 2, $9);
}

function fts3ExprLHits($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $7 = HEAP32[HEAP32[$1 >> 2] >> 2];
 $6 = HEAP32[$0 + 20 >> 2];
 $5 = HEAP32[$6 + 28 >> 2];
 HEAP32[$3 + 12 >> 2] = $5;
 HEAP32[$3 + 8 >> 2] = 0;
 $0 = HEAP32[$0 + 36 >> 2];
 $4 = HEAP32[$1 + 4 >> 2];
 $4 = HEAPU8[$1 + 24 | 0] != 121 ? ($4 + 31 | 0) / 32 | 0 : $4;
 label$1: {
  if (!$5) {
   break label$1;
  }
  $5 = Math_imul($0, $4);
  $0 = 0;
  while (1) {
   $4 = fts3ColumnlistCount($3 + 12 | 0);
   $2 = HEAP32[$6 + 68 >> 2];
   label$3: {
    if (($2 | 0) < HEAP32[$7 + 24 >> 2] & ($0 | 0) != ($2 | 0)) {
     break label$3;
    }
    if (HEAPU8[$1 + 24 | 0] == 121) {
     HEAP32[HEAP32[$1 + 28 >> 2] + ($0 + $5 << 2) >> 2] = $4;
     break label$3;
    }
    if (!$4) {
     break label$3;
    }
    $2 = HEAP32[$1 + 28 >> 2] + ((($0 + 1 | 0) / 32 | 0) + $5 << 2) | 0;
    HEAP32[$2 >> 2] = HEAP32[$2 >> 2] | 1 << $0;
   }
   $0 = HEAP32[$3 + 12 >> 2];
   if (HEAPU8[$0 | 0] != 1) {
    $2 = 0;
    break label$1;
   }
   $2 = $0 + 1 | 0;
   $0 = HEAP8[$0 + 1 | 0];
   label$6: {
    if (($0 | 0) < 0) {
     $4 = sqlite3Fts3GetVarint32($2, $3 + 8 | 0);
     $0 = HEAP32[$3 + 8 >> 2];
     break label$6;
    }
    $0 = $0 & 255;
    HEAP32[$3 + 8 >> 2] = $0;
    $4 = 1;
   }
   HEAP32[$3 + 12 >> 2] = $4 + $2;
   if (HEAP32[$1 + 4 >> 2] > ($0 | 0)) {
    continue;
   }
   break;
  }
  $2 = 267;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function fts3TermSegReaderCursor($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = sqlite3_malloc(56);
 label$1: {
  if (!$6) {
   $8 = 7;
   break label$1;
  }
  $7 = HEAP32[$0 >> 2];
  label$3: {
   if (!$3) {
    break label$3;
   }
   $8 = 7;
   $9 = 1;
   $5 = 1;
   while (1) {
    label$5: {
     if (!$10) {
      if (HEAP32[$7 + 256 >> 2] > ($5 | 0)) {
       break label$5;
      }
      $9 = 0;
     }
     $10 = $2 + 1 | 0;
     $5 = 1;
     while (1) {
      if ($9) {
       break label$1;
      }
      if (HEAP32[$7 + 256 >> 2] <= ($5 | 0)) {
       break label$3;
      }
      $9 = 0;
      label$8: {
       if (HEAP32[HEAP32[$7 + 260 >> 2] + Math_imul($5, 24) >> 2] != ($10 | 0)) {
        break label$8;
       }
       $9 = 1;
       $8 = sqlite3Fts3SegReaderCursor($7, HEAP32[$0 + 20 >> 2], $5, -2, $1, $2, 1, 0, $6);
       if ($8) {
        break label$8;
       }
       $8 = fts3SegReaderCursorAddZero($7, HEAP32[$0 + 20 >> 2], $1, $2, $6);
      }
      $5 = $5 + 1 | 0;
      continue;
     }
    }
    $10 = 0;
    if (HEAP32[HEAP32[$7 + 260 >> 2] + Math_imul($5, 24) >> 2] == ($2 | 0)) {
     $8 = sqlite3Fts3SegReaderCursor($7, HEAP32[$0 + 20 >> 2], $5, -2, $1, $2, 0, 0, $6);
     HEAP32[$6 + 36 >> 2] = 1;
     $10 = 1;
    }
    $5 = $5 + 1 | 0;
    continue;
   }
  }
  $8 = sqlite3Fts3SegReaderCursor($7, HEAP32[$0 + 20 >> 2], 0, -2, $1, $2, $3, 0, $6);
  HEAP32[$6 + 36 >> 2] = !$3;
 }
 HEAP32[$4 >> 2] = $6;
 return $8;
}

function whereRangeVectorLen($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $5 = sqlite3ExprVectorSize(HEAP32[HEAP32[$4 >> 2] + 12 >> 2]);
 $6 = HEAPU16[$2 + 52 >> 1] - $3 | 0;
 $5 = ($5 | 0) < ($6 | 0) ? $5 : $6;
 $9 = ($5 | 0) > 1 ? $5 : 1;
 $6 = 1;
 label$1: {
  while (1) {
   if (($6 | 0) == ($9 | 0)) {
    break label$1;
   }
   $5 = HEAP32[$4 >> 2];
   $7 = HEAP32[$5 + 16 >> 2];
   $8 = $7 + 20 | 0;
   $10 = $6 << 4;
   $5 = HEAP32[($10 + HEAP32[HEAP32[$5 + 12 >> 2] + 20 >> 2] | 0) + 8 >> 2];
   $8 = HEAPU8[$7 + 5 | 0] & 16 ? HEAP32[$7 + 20 >> 2] + 28 | 0 : $8;
   label$4: {
    if (HEAPU8[$5 | 0] != 167 | HEAP32[$5 + 28 >> 2] != ($1 | 0)) {
     break label$4;
    }
    $7 = $3 + $6 | 0;
    if (HEAPU16[$5 + 32 >> 1] != HEAPU16[HEAP32[$2 + 4 >> 2] + ($7 << 1) >> 1]) {
     break label$4;
    }
    $11 = HEAP32[$2 + 28 >> 2];
    if (HEAPU8[$11 + $7 | 0] != HEAPU8[$3 + $11 | 0]) {
     break label$4;
    }
    $8 = HEAP32[(HEAP32[$8 >> 2] + $10 | 0) + 8 >> 2];
    if ((sqlite3CompareAffinity($8, sqlite3ExprAffinity($5)) | 0) != (sqlite3TableColumnAffinity(HEAP32[$2 + 12 >> 2], HEAP16[$5 + 32 >> 1]) | 0)) {
     break label$4;
    }
    $5 = sqlite3BinaryCompareCollSeq($0, $5, $8);
    if (!$5) {
     break label$4;
    }
    if (sqlite3StrICmp(HEAP32[$5 >> 2], HEAP32[HEAP32[$2 + 32 >> 2] + ($7 << 2) >> 2])) {
     break label$4;
    }
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  $9 = $6;
 }
 return $9;
}

function filterHash($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = HEAP32[$1 + 12 >> 2];
 $1 = $8 + HEAP32[$1 + 16 >> 2] | 0;
 $10 = ($1 | 0) < ($8 | 0) ? $8 : $1;
 while (1) {
  if (($8 | 0) != ($10 | 0)) {
   $1 = Math_imul($8, 40) + $0 | 0;
   $9 = HEAPU16[$1 + 16 >> 1];
   label$3: {
    if ($9 & 36) {
     $3 = HEAP32[$1 >> 2];
     $6 = $5;
     $4 = $3 + $6 | 0;
     $3 = $7;
     $2 = HEAP32[$1 + 4 >> 2];
     $2 = $3 + $2 | 0;
     $5 = $4;
     $2 = $4 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
     $7 = $2;
     break label$3;
    }
    if ($9 & 8) {
     $2 = sqlite3VdbeIntValue($1);
     $3 = $2;
     $1 = i64toi32_i32$HIGH_BITS;
     $2 = $7;
     $4 = $1 + $2 | 0;
     $2 = $3;
     $6 = $5;
     $3 = $2 + $6 | 0;
     $4 = $6 >>> 0 > $3 >>> 0 ? $4 + 1 | 0 : $4;
     $5 = $3;
     $7 = $4;
     break label$3;
    }
    if (!($9 & 18)) {
     break label$3;
    }
    $4 = HEAP32[$1 + 12 >> 2];
    $2 = $4 >> 31;
    $6 = $4;
    $4 = $2;
    $2 = $7;
    $3 = $2 + $4 | 0;
    $2 = $5 + $6 | 0;
    $5 = $2;
    $3 = $2 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
    $7 = $3;
    if (!($9 & 1024)) {
     break label$3;
    }
    $3 = HEAP32[$1 >> 2];
    $1 = $3 >> 31;
    $6 = $3;
    $4 = $5 + $3 | 0;
    $3 = $1;
    $2 = $3 + $7 | 0;
    $5 = $4;
    $2 = $4 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
    $7 = $2;
   }
   $8 = $8 + 1 | 0;
   continue;
  }
  break;
 }
 $2 = $7;
 i64toi32_i32$HIGH_BITS = $2;
 return $5;
}

function vdbeRecordCompareString($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP8[$1 + 1 | 0];
 HEAP32[$5 + 12 >> 2] = $3;
 $4 = $1 + 1 | 0;
 label$1: {
  label$2: {
   while (1) {
    if (($3 | 0) <= 11) {
     if (($3 | 0) >= 0) {
      break label$2;
     }
     sqlite3GetVarint32($4, $5 + 12 | 0);
     $3 = HEAP32[$5 + 12 >> 2];
     if (($3 | 0) > 11) {
      continue;
     }
     break label$2;
    }
    break;
   }
   label$5: {
    if (!($3 & 1)) {
     break label$5;
    }
    $3 = $3 - 12 >>> 1 | 0;
    $4 = HEAPU8[$1 | 0];
    if (($3 + $4 | 0) <= ($0 | 0)) {
     $6 = $1 + $4 | 0;
     $4 = HEAP32[$2 + 16 >> 2];
     $6 = memcmp($6, HEAP32[$2 + 8 >> 2], ($3 | 0) > ($4 | 0) ? $4 : $3);
     if (($6 | 0) > 0) {
      break label$5;
     }
     if (($6 | 0) < 0) {
      break label$2;
     }
     if (($3 | 0) == ($4 | 0)) {
      if (HEAPU16[$2 + 20 >> 1] >= 2) {
       $3 = sqlite3VdbeRecordCompareWithSkip($0, $1, $2, 1);
       break label$1;
      }
      HEAP8[$2 + 26 | 0] = 1;
      $3 = HEAP8[$2 + 22 | 0];
      break label$1;
     }
     if (($3 | 0) <= ($4 | 0)) {
      break label$2;
     }
     break label$5;
    }
    HEAP8[$2 + 23 | 0] = sqlite3CorruptError(85553);
    $3 = 0;
    break label$1;
   }
   $3 = HEAP8[$2 + 25 | 0];
   break label$1;
  }
  $3 = HEAP8[$2 + 24 | 0];
 }
 __stack_pointer = $5 + 16 | 0;
 return $3 | 0;
}

function indexMightHelpWithOrderBy($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  label$2: {
   if (HEAPU8[$1 + 55 | 0] & 4) {
    break label$2;
   }
   $5 = HEAP32[HEAP32[$0 >> 2] + 8 >> 2];
   if (!$5) {
    break label$2;
   }
   while (1) {
    if (HEAP32[$5 >> 2] <= ($6 | 0)) {
     return 0;
    }
    label$5: {
     $3 = sqlite3ExprSkipCollateAndLikely(HEAP32[(($6 << 4) + $5 | 0) + 8 >> 2]);
     if (!$3) {
      break label$5;
     }
     if (!(HEAPU8[$3 | 0] != 167 | HEAP32[$3 + 28 >> 2] != ($2 | 0))) {
      $7 = HEAP16[$3 + 32 >> 1];
      if (($7 | 0) < 0) {
       break label$1;
      }
      $8 = HEAPU16[$1 + 50 >> 1];
      $0 = 0;
      while (1) {
       if (($0 | 0) == ($8 | 0)) {
        break label$5;
       }
       $4 = 1;
       $3 = $0 << 1;
       $0 = $0 + 1 | 0;
       if (HEAPU16[HEAP32[$1 + 4 >> 2] + $3 >> 1] != ($7 & 65535)) {
        continue;
       }
       break;
      }
      break label$2;
     }
     $0 = 0;
     $4 = HEAP32[$1 + 40 >> 2];
     if (!$4) {
      break label$5;
     }
     while (1) {
      if (HEAPU16[$1 + 50 >> 1] <= $0 >>> 0) {
       break label$5;
      }
      if (HEAPU16[HEAP32[$1 + 4 >> 2] + ($0 << 1) >> 1] == 65534) {
       if (!sqlite3ExprCompareSkip($3, HEAP32[(($0 << 4) + $4 | 0) + 8 >> 2], $2)) {
        break label$1;
       }
      }
      $0 = $0 + 1 | 0;
      continue;
     }
    }
    $6 = $6 + 1 | 0;
    continue;
   }
  }
  return $4;
 }
 return 1;
}

function vdbeSorterCompareInt($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $10 = HEAPU8[$4 | 0] + $4 | 0;
 $11 = HEAPU8[$2 | 0] + $2 | 0;
 label$1: {
  $6 = HEAPU8[$2 + 1 | 0];
  $8 = HEAPU8[$4 + 1 | 0];
  label$2: {
   label$3: {
    if (($6 | 0) == ($8 | 0)) {
     $9 = HEAPU8[$6 + 33380 | 0];
     $6 = 0;
     while (1) {
      if (($6 | 0) == ($9 | 0)) {
       break label$2;
      }
      $7 = $6 + $10 | 0;
      $8 = $6 + $11 | 0;
      $6 = $6 + 1 | 0;
      $7 = HEAPU8[$8 | 0] - HEAPU8[$7 | 0] | 0;
      if (!$7) {
       continue;
      }
      break;
     }
     $6 = HEAP8[$11 | 0];
     if (($6 ^ HEAPU8[$10 | 0]) << 24 >> 24 >= 0) {
      break label$3;
     }
     $9 = $6 >> 31 | 1;
     break label$1;
    }
    $7 = $6 - $8 | 0;
    if ($8 >>> 0 > 7 & $6 >>> 0 >= 8) {
     break label$3;
    }
    $9 = 1;
    $7 = $6 >>> 0 > 7 ? -1 : $7;
    $6 = $8 >>> 0 > 7 ? 1 : $7;
    if (($6 | 0) > 0) {
     $7 = HEAP8[$11 | 0] >= 0 ? $6 : -1;
     break label$3;
    }
    if (HEAP8[$10 | 0] < 0) {
     break label$1;
    }
   }
   $9 = $7;
   if ($7) {
    break label$1;
   }
  }
  $6 = 0;
  if (HEAPU16[HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2] + 6 >> 1] >= 2) {
   $6 = vdbeSorterCompareTail($0, $1, $2, $3, $4, $5);
  }
  return $6 | 0;
 }
 return (HEAPU8[HEAP32[HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2] + 16 >> 2]] ? 0 - $9 | 0 : $9) | 0;
}

function pagerAddPageToRollbackJournal($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = HEAP32[$0 + 20 >> 2];
 $5 = HEAP32[$2 + 80 >> 2];
 $3 = $5;
 $1 = HEAP32[$2 + 84 >> 2];
 $7 = $1;
 $6 = HEAP32[$0 + 4 >> 2];
 $8 = pager_cksum($2, $6);
 HEAP16[$0 + 28 >> 1] = HEAPU16[$0 + 28 >> 1] | 8;
 $1 = write32bits(HEAP32[$2 + 68 >> 2], $5, $1, HEAP32[$0 + 24 >> 2]);
 label$1: {
  if ($1) {
   break label$1;
  }
  $1 = $7;
  $4 = $1;
  $3 = $3 + 4 | 0;
  $4 = $3 >>> 0 < 4 ? $4 + 1 | 0 : $4;
  $7 = $4;
  $1 = sqlite3OsWrite(HEAP32[$2 + 68 >> 2], $6, HEAP32[$2 + 168 >> 2], $3, $4);
  if ($1) {
   break label$1;
  }
  $1 = $3;
  $4 = HEAP32[$2 + 168 >> 2];
  $6 = $4;
  $5 = $1 + $4 | 0;
  $4 = HEAP32[$2 + 172 >> 2];
  $3 = $4 + $7 | 0;
  $3 = $5 >>> 0 < $6 >>> 0 ? $3 + 1 | 0 : $3;
  $1 = write32bits(HEAP32[$2 + 68 >> 2], $5, $3, $8);
  if ($1) {
   break label$1;
  }
  HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] + 1;
  $1 = HEAP32[$2 + 172 >> 2];
  $7 = $1;
  $3 = HEAP32[$2 + 168 >> 2];
  $1 = HEAP32[$2 + 80 >> 2];
  $6 = $1;
  $4 = $3 + $1 | 0;
  $3 = HEAP32[$2 + 84 >> 2];
  $1 = $3;
  $3 = $7;
  $5 = $1 + $3 | 0;
  $5 = $4 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
  $3 = $4;
  $4 = $5;
  $1 = $3 + 8 | 0;
  $4 = $1 >>> 0 < 8 ? $4 + 1 | 0 : $4;
  HEAP32[$2 + 80 >> 2] = $1;
  HEAP32[$2 + 84 >> 2] = $4;
  $1 = sqlite3BitvecSet(HEAP32[$2 + 60 >> 2], HEAP32[$0 + 24 >> 2]) | addToSavepointBitvecs($2, HEAP32[$0 + 24 >> 2]);
 }
 return $1;
}

function exprSelectUsage($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 while (1) {
  if ($1) {
   $7 = HEAP32[$1 + 32 >> 2];
   $3 = sqlite3WhereExprListUsage($0, HEAP32[$1 + 28 >> 2]);
   $2 = i64toi32_i32$HIGH_BITS;
   $6 = sqlite3WhereExprListUsage($0, HEAP32[$1 + 40 >> 2]);
   $2 = i64toi32_i32$HIGH_BITS | $2;
   $3 = sqlite3WhereExprListUsage($0, HEAP32[$1 + 48 >> 2]) | ($3 | $6);
   $2 = $2 | i64toi32_i32$HIGH_BITS;
   $6 = sqlite3WhereExprUsage($0, HEAP32[$1 + 36 >> 2]);
   $2 = i64toi32_i32$HIGH_BITS | $2;
   $4 = $4 | (sqlite3WhereExprUsage($0, HEAP32[$1 + 44 >> 2]) | ($3 | $6));
   $5 = $2 | i64toi32_i32$HIGH_BITS | $5;
   $2 = 0;
   label$3: {
    if (!$7) {
     break label$3;
    }
    while (1) {
     if (HEAP32[$7 >> 2] <= ($2 | 0)) {
      break label$3;
     }
     $3 = ($2 << 6) + $7 | 0;
     $4 = exprSelectUsage($0, HEAP32[$3 + 28 >> 2]) | $4;
     $5 = i64toi32_i32$HIGH_BITS | $5;
     $6 = HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8;
     if (!($6 & 1024)) {
      $4 = sqlite3WhereExprUsage($0, HEAP32[$3 + 52 >> 2]) | $4;
      $6 = HEAPU8[$3 + 45 | 0] | HEAPU8[$3 + 46 | 0] << 8;
      $5 = i64toi32_i32$HIGH_BITS | $5;
     }
     if ($6 & 4) {
      $4 = sqlite3WhereExprListUsage($0, HEAP32[$3 - -64 >> 2]) | $4;
      $5 = i64toi32_i32$HIGH_BITS | $5;
     }
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   $1 = HEAP32[$1 + 52 >> 2];
   continue;
  }
  break;
 }
 i64toi32_i32$HIGH_BITS = $5;
 return $4;
}

function modeIterate($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  label$2: {
   if (!(HEAP32[$3 + 48 >> 2] | HEAP32[$3 + 52 >> 2])) {
    $6 = HEAP32[$3 + 32 >> 2];
    $4 = $1;
    $5 = $6;
    $7 = HEAP32[$3 + 36 >> 2];
    if (($4 | 0) == ($5 | 0) & ($7 | 0) == ($2 | 0)) {
     break label$1;
    }
    $4 = $2;
    $5 = $1;
    if (($4 | 0) <= ($7 | 0) & $5 >>> 0 <= $6 >>> 0 | ($4 | 0) < ($7 | 0)) {
     break label$2;
    }
    $5 = HEAP32[$0 >> 2];
    $4 = $5 >> 31;
    $6 = $5;
    $7 = $4;
    HEAP32[$3 + 40 >> 2] = 1;
    HEAP32[$3 + 44 >> 2] = 0;
    HEAP32[$3 + 32 >> 2] = $1;
    $4 = $2;
    HEAP32[$3 + 36 >> 2] = $4;
    HEAP32[$3 >> 2] = $6;
    $4 = $7;
    HEAP32[$3 + 4 >> 2] = $4;
    return;
   }
   $4 = HEAP32[$3 + 32 >> 2];
   $6 = $4;
   $5 = HEAP32[$3 + 36 >> 2];
   $7 = $5;
   $4 = $5;
   $5 = $2;
   if (($1 | 0) == ($6 | 0) & ($4 | 0) == ($5 | 0)) {
    break label$1;
   }
   $5 = $7;
   $4 = $6;
   if (($5 | 0) >= ($2 | 0) & $4 >>> 0 >= $1 >>> 0 | ($2 | 0) < ($5 | 0)) {
    break label$2;
   }
   $8 = HEAPF64[$0 >> 3];
   HEAP32[$3 + 40 >> 2] = 1;
   HEAP32[$3 + 44 >> 2] = 0;
   HEAP32[$3 + 32 >> 2] = $1;
   HEAP32[$3 + 36 >> 2] = $2;
   HEAPF64[$3 + 8 >> 3] = $8;
  }
  return;
 }
 $0 = HEAP32[$3 + 44 >> 2];
 $4 = HEAP32[$3 + 40 >> 2];
 $1 = $4 + 1 | 0;
 $0 = $1 ? $0 : $0 + 1 | 0;
 HEAP32[$3 + 40 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = $0;
}

function genSeqMember($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = $3;
 $9 = __wasm_i64_mul($2, $7, -1, 2147483647);
 $7 = i64toi32_i32$HIGH_BITS;
 $6 = $7;
 $7 = $5;
 $10 = $4;
 $12 = ($7 | 0) == 2147483647 & $10 >>> 0 > 4294967294 | $7 >>> 0 > 2147483647;
 $8 = $12;
 $9 = $8 ? $9 : 0;
 $7 = $9;
 $9 = $1;
 $10 = $6;
 $11 = $8 ? $10 : 0;
 $6 = $9 + $11 | 0;
 $10 = $0;
 $8 = $7;
 $7 = $10 + $8 | 0;
 $6 = $7 >>> 0 < $10 >>> 0 ? $6 + 1 | 0 : $6;
 $0 = $7;
 $1 = $6;
 $6 = $5;
 $7 = (($4 | 0) != -1) + 2147483647 | 0;
 $7 = $6 - $7 | 0;
 $11 = $4;
 $9 = $11 + 1 | 0;
 $8 = $12;
 $10 = $8 ? $9 : $4;
 $4 = $10;
 $6 = $8 ? $7 : $6;
 $5 = $6;
 $8 = $4;
 if (!$6 & $8 >>> 0 >= 2 | $6) {
  $8 = $5;
  $6 = __wasm_i64_sdiv($4, $8, 2, 0);
  $12 = $6;
  $8 = i64toi32_i32$HIGH_BITS;
  $9 = $8;
  $7 = $4;
  $10 = $6;
  $11 = $7 - $6 | 0;
  $4 = $11;
  $8 = $5;
  $6 = $9;
  $9 = $6 + ($7 >>> 0 < $10 >>> 0) | 0;
  $9 = $8 - $9 | 0;
  $5 = $9;
  $10 = $0;
  $9 = $3;
  $7 = __wasm_i64_mul($2, $9, $12, $6);
  $6 = $10 + $7 | 0;
  $7 = $1;
  $9 = i64toi32_i32$HIGH_BITS;
  $11 = $7 + $9 | 0;
  $0 = $6;
  $11 = $6 >>> 0 < $10 >>> 0 ? $11 + 1 | 0 : $11;
  $1 = $11;
 }
 $11 = $3;
 $8 = $5;
 $8 = __wasm_i64_mul($2, $11, $4, $8);
 $10 = $8;
 $11 = i64toi32_i32$HIGH_BITS;
 $8 = $11;
 $11 = $1;
 $6 = $11 + $8 | 0;
 $9 = $0;
 $7 = $9 + $10 | 0;
 $6 = $7 >>> 0 < $10 >>> 0 ? $6 + 1 | 0 : $6;
 i64toi32_i32$HIGH_BITS = $6;
 return $7;
}

function sqlite3VdbeMemGrow($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  label$2: {
   $3 = HEAP32[$0 + 24 >> 2];
   if (!$2 | ($3 | 0) <= 0) {
    break label$2;
   }
   $4 = HEAP32[$0 + 8 >> 2];
   if (($4 | 0) != HEAP32[$0 + 32 >> 2]) {
    break label$2;
   }
   $2 = $1 >> 31;
   $3 = HEAP32[$0 + 20 >> 2];
   label$3: {
    if ($3) {
     $3 = sqlite3DbReallocOrFree($3, $4, $1, $2);
     HEAP32[$0 + 32 >> 2] = $3;
     break label$3;
    }
    $3 = sqlite3Realloc($4, $1, $2);
    HEAP32[$0 + 32 >> 2] = $3;
    if ($3) {
     break label$3;
    }
    sqlite3_free(HEAP32[$0 + 8 >> 2]);
    $3 = HEAP32[$0 + 32 >> 2];
   }
   HEAP32[$0 + 8 >> 2] = $3;
   $2 = 0;
   break label$1;
  }
  if (($3 | 0) > 0) {
   sqlite3DbFreeNN(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 32 >> 2]);
  }
  $3 = sqlite3DbMallocRaw(HEAP32[$0 + 20 >> 2], $1, $1 >> 31);
  HEAP32[$0 + 32 >> 2] = $3;
 }
 if (!$3) {
  sqlite3VdbeMemSetNull($0);
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  return 7;
 }
 HEAP32[$0 + 24 >> 2] = sqlite3DbMallocSize(HEAP32[$0 + 20 >> 2], $3);
 label$7: {
  if (!$2) {
   break label$7;
  }
  $3 = HEAP32[$0 + 8 >> 2];
  if (!$3) {
   break label$7;
  }
  __memcpy(HEAP32[$0 + 32 >> 2], $3, HEAP32[$0 + 12 >> 2]);
 }
 $3 = HEAPU16[$0 + 16 >> 1];
 if ($3 & 4096) {
  FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]](HEAP32[$0 + 8 >> 2]);
  $3 = HEAPU16[$0 + 16 >> 1];
 }
 HEAP16[$0 + 16 >> 1] = $3 & 36863;
 HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 32 >> 2];
 return 0;
}

function yy_destructor($0, $1, $2) {
 $0 = HEAP32[$0 + 4 >> 2];
 label$1: {
  switch ($1 - 204 | 0) {
  case 0:
  case 35:
  case 36:
  case 48:
   sqlite3SelectDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 12:
  case 13:
  case 42:
  case 44:
  case 63:
  case 74:
  case 76:
  case 79:
  case 86:
  case 91:
  case 107:
   sqlite3ExprDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 17:
  case 27:
  case 28:
  case 40:
  case 43:
  case 45:
  case 49:
  case 50:
  case 57:
  case 64:
  case 73:
  case 75:
  case 106:
   sqlite3ExprListDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 34:
  case 41:
  case 52:
  case 53:
  case 58:
   sqlite3SrcListDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 37:
   sqlite3WithDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 47:
  case 102:
   sqlite3WindowListDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 59:
  case 66:
   sqlite3IdListDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 69:
  case 103:
  case 104:
  case 105:
  case 108:
   sqlite3WindowDelete(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 82:
  case 87:
   sqlite3DeleteTriggerStep(HEAP32[$0 >> 2], HEAP32[$2 >> 2]);
   return;

  case 84:
   sqlite3IdListDelete(HEAP32[$0 >> 2], HEAP32[$2 + 4 >> 2]);
   return;

  case 110:
  case 111:
  case 112:
   sqlite3ExprDelete(HEAP32[$0 >> 2], HEAP32[$2 + 4 >> 2]);
   break;

  default:
   break label$1;
  }
 }
}

function sqlite3Realloc($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 if (!$0) {
  return sqlite3Malloc($1, $2);
 }
 if (!($1 | $2)) {
  sqlite3_free($0);
  return 0;
 }
 $3 = $1;
 label$3: {
  if (!$2 & $3 >>> 0 > 2147483391 | $2) {
   break label$3;
  }
  $9 = sqlite3MallocSize($0);
  $7 = $1;
  $8 = FUNCTION_TABLE[HEAP32[16080]]($1) | 0;
  if (($9 | 0) == ($8 | 0)) {
   return $0;
  }
  if (HEAP32[16068]) {
   sqlite3StatusHighwater(5, $7);
   $6 = $8 - $9 | 0;
   label$6: {
    if (($6 | 0) <= 0) {
     break label$6;
    }
    $7 = 0;
    $3 = sqlite3StatusValue();
    $1 = $3;
    $4 = HEAP32[17618];
    $3 = HEAP32[17619];
    $5 = $4 >>> 0 < $6 >>> 0;
    $5 = $3 - $5 | 0;
    $3 = $1;
    $3 = $3 >>> 0 < $4 - $6 >>> 0;
    $4 = $5;
    $2 = i64toi32_i32$HIGH_BITS;
    if ($3 & ($4 | 0) >= ($2 | 0) | ($2 | 0) < ($4 | 0)) {
     break label$6;
    }
    $3 = HEAP32[17620];
    $5 = HEAP32[17621];
    if (!$3 & ($5 | 0) <= 0 | ($5 | 0) < 0) {
     break label$6;
    }
    $4 = $3;
    $3 = $6;
    $6 = $4 - $3 | 0;
    $4 = $5 - ($4 >>> 0 < $3 >>> 0) | 0;
    $3 = $6;
    if (($2 | 0) >= ($4 | 0) & $3 >>> 0 <= $1 >>> 0 | ($2 | 0) > ($4 | 0)) {
     break label$3;
    }
   }
   $7 = 0;
   $0 = FUNCTION_TABLE[HEAP32[16078]]($0, $8) | 0;
   if (!$0) {
    break label$3;
   }
   sqlite3StatusUp(0, sqlite3MallocSize($0) - $9 | 0);
   return $0;
  }
  $7 = FUNCTION_TABLE[HEAP32[16078]]($0, $8) | 0;
 }
 return $7;
}

function pragmaVtabBestIndex($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 $2 = $1;
 HEAP32[$2 + 40 >> 2] = 0;
 HEAP32[$2 + 44 >> 2] = 1072693248;
 label$1: {
  if (!HEAPU8[$0 + 20 | 0]) {
   break label$1;
  }
  $3 = HEAP32[$1 + 4 >> 2];
  $2 = $5;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  $2 = HEAP32[$1 >> 2];
  $2 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   if (($4 | 0) != ($2 | 0)) {
    label$4: {
     if (!HEAPU8[$3 + 5 | 0] | HEAPU8[$3 + 4 | 0] != 2) {
      break label$4;
     }
     $6 = HEAP32[$3 >> 2];
     $7 = HEAPU8[$0 + 21 | 0];
     if (($6 | 0) < ($7 | 0)) {
      break label$4;
     }
     HEAP32[($5 + 8 | 0) + ($6 - $7 << 2) >> 2] = $4 + 1;
    }
    $3 = $3 + 12 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  $3 = HEAP32[$5 + 8 >> 2];
  if (!$3) {
   $2 = $1;
   HEAP32[$2 + 48 >> 2] = 2147483647;
   HEAP32[$2 + 52 >> 2] = 0;
   HEAP32[$2 + 40 >> 2] = -4194304;
   HEAP32[$2 + 44 >> 2] = 1105199103;
   break label$1;
  }
  $4 = HEAP32[$1 + 16 >> 2];
  $3 = ($4 + ($3 << 3) | 0) - 8 | 0;
  HEAP8[$3 + 4 | 0] = 1;
  HEAP32[$3 >> 2] = 1;
  $3 = HEAP32[$5 + 12 >> 2];
  if (!$3) {
   break label$1;
  }
  $2 = $1;
  HEAP32[$2 + 48 >> 2] = 20;
  HEAP32[$2 + 52 >> 2] = 0;
  HEAP32[$2 + 40 >> 2] = 0;
  HEAP32[$2 + 44 >> 2] = 1077149696;
  $3 = (($3 << 3) + $4 | 0) - 8 | 0;
  HEAP8[$3 + 4 | 0] = 1;
  HEAP32[$3 >> 2] = 2;
 }
 return 0;
}

function fts3TokenizerFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $5 = sqlite3_user_data($0);
 $4 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $6 = sqlite3_value_bytes(HEAP32[$2 >> 2]) + 1 | 0;
 label$1: {
  label$2: {
   if (($1 | 0) == 2) {
    $7 = fts3TokenizerEnabled($0);
    $1 = HEAP32[$2 + 4 >> 2];
    label$4: {
     if (!$7) {
      if (!sqlite3_value_frombind($1)) {
       break label$4;
      }
     }
     $1 = sqlite3_value_bytes($1);
     if (!(!$4 | ($1 | 0) != 4)) {
      $1 = HEAP32[sqlite3_value_blob(HEAP32[$2 + 4 >> 2]) >> 2];
      HEAP32[$3 + 12 >> 2] = $1;
      if ((sqlite3Fts3HashInsert($5, $4, $6, $1) | 0) != ($1 | 0)) {
       break label$2;
      }
      sqlite3_result_error($0, 1141, -1);
      break label$2;
     }
     sqlite3_result_error($0, 11754, -1);
     break label$1;
    }
    sqlite3_result_error($0, 15402, -1);
    break label$1;
   }
   if ($4) {
    $1 = sqlite3Fts3HashFind($5, $4, $6);
    HEAP32[$3 + 12 >> 2] = $1;
    if ($1) {
     break label$2;
    }
   }
   HEAP32[$3 >> 2] = $4;
   $2 = sqlite3_mprintf(7260, $3);
   sqlite3_result_error($0, $2, -1);
   sqlite3_free($2);
   break label$1;
  }
  if (!fts3TokenizerEnabled($0)) {
   if (!sqlite3_value_frombind(HEAP32[$2 >> 2])) {
    break label$1;
   }
  }
  sqlite3_result_blob($0, $3 + 12 | 0, 4, -1);
 }
 __stack_pointer = $3 + 16 | 0;
}

function newDatabase($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (HEAP32[$0 + 48 >> 2]) {
   break label$1;
  }
  $4 = HEAP32[$0 + 12 >> 2];
  $1 = HEAP32[$4 + 56 >> 2];
  $5 = sqlite3PagerWrite(HEAP32[$4 + 72 >> 2]);
  if ($5) {
   break label$1;
  }
  $5 = 0;
  $2 = HEAP32[8079];
  $3 = HEAP32[8078];
  HEAP8[$1 + 8 | 0] = $3;
  HEAP8[$1 + 9 | 0] = $3 >>> 8;
  HEAP8[$1 + 10 | 0] = $3 >>> 16;
  HEAP8[$1 + 11 | 0] = $3 >>> 24;
  HEAP8[$1 + 12 | 0] = $2;
  HEAP8[$1 + 13 | 0] = $2 >>> 8;
  HEAP8[$1 + 14 | 0] = $2 >>> 16;
  HEAP8[$1 + 15 | 0] = $2 >>> 24;
  $3 = HEAP32[8077];
  $2 = HEAP32[8076];
  HEAP8[$1 | 0] = $2;
  HEAP8[$1 + 1 | 0] = $2 >>> 8;
  HEAP8[$1 + 2 | 0] = $2 >>> 16;
  HEAP8[$1 + 3 | 0] = $2 >>> 24;
  HEAP8[$1 + 4 | 0] = $3;
  HEAP8[$1 + 5 | 0] = $3 >>> 8;
  HEAP8[$1 + 6 | 0] = $3 >>> 16;
  HEAP8[$1 + 7 | 0] = $3 >>> 24;
  HEAP8[$1 + 16 | 0] = HEAP32[$0 + 36 >> 2] >>> 8;
  HEAP8[$1 + 17 | 0] = HEAPU16[$0 + 38 >> 1];
  HEAP8[$1 + 18 | 0] = 1;
  HEAP8[$1 + 19 | 0] = 1;
  $2 = HEAP32[$0 + 40 >> 2];
  $3 = HEAP32[$0 + 36 >> 2];
  HEAP8[$1 + 21 | 0] = 64;
  HEAP8[$1 + 22 | 0] = 32;
  HEAP8[$1 + 23 | 0] = 32;
  HEAP8[$1 + 20 | 0] = $3 - $2;
  memset($1 + 24 | 0, 0, 76);
  zeroPage($4, 13);
  HEAP16[$0 + 24 >> 1] = HEAPU16[$0 + 24 >> 1] | 2;
  sqlite3Put4byte($1 + 52 | 0, HEAPU8[$0 + 17 | 0]);
  sqlite3Put4byte($1 - -64 | 0, HEAPU8[$0 + 18 | 0]);
  HEAP32[$0 + 48 >> 2] = 1;
  HEAP8[$1 + 31 | 0] = 1;
 }
 return $5;
}

function sqlite3WhereExplainBloomFilter($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 176 | 0;
 __stack_pointer = $3;
 $5 = HEAP32[$0 + 8 >> 2];
 $1 = HEAP32[$1 + 4 >> 2];
 $4 = HEAPU8[$2 + 60 | 0];
 sqlite3StrAccumInit($3 + 152 | 0, HEAP32[$0 >> 2], $3 + 48 | 0, 100, 1e9);
 $4 = ($4 << 6) + $1 | 0;
 HEAP32[$3 + 32 >> 2] = $4 + 8;
 HEAP8[$3 + 173 | 0] = 1;
 sqlite3_str_appendf($3 + 152 | 0, 26912, $3 + 32 | 0);
 label$1: {
  label$2: {
   $1 = HEAP32[$2 + 80 >> 2];
   if (HEAP8[$1 + 41 | 0] & 1) {
    $2 = HEAP32[$4 + 24 >> 2];
    $1 = HEAP16[$2 + 32 >> 1];
    if (($1 | 0) < 0) {
     break label$2;
    }
    HEAP32[$3 + 16 >> 2] = HEAP32[HEAP32[$2 + 4 >> 2] + Math_imul($1 & 65535, 12) >> 2];
    sqlite3_str_appendf($3 + 152 | 0, 20441, $3 + 16 | 0);
    break label$1;
   }
   $2 = HEAPU16[$1 + 46 >> 1];
   while (1) {
    if (HEAPU16[$1 + 24 >> 1] <= $2 >>> 0) {
     break label$1;
    }
    $4 = explainIndexColumnName(HEAP32[$1 + 32 >> 2], $2);
    if (HEAPU16[$1 + 46 >> 1] < $2 >>> 0) {
     sqlite3_str_append($3 + 152 | 0, 29468, 5);
    }
    HEAP32[$3 >> 2] = $4;
    sqlite3_str_appendf($3 + 152 | 0, 20441, $3);
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  sqlite3_str_appendf($3 + 152 | 0, 20462, 0);
 }
 sqlite3_str_append($3 + 152 | 0, 26910, 1);
 $2 = sqlite3StrAccumFinish($3 + 152 | 0);
 sqlite3VdbeAddOp4($5, 185, sqlite3VdbeCurrentAddr($5), HEAP32[$0 + 220 >> 2], 0, $2, -6);
 __stack_pointer = $3 + 176 | 0;
}

function sqlite3AddGenerated($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$3) {
   break label$1;
  }
  if (HEAPU8[$0 + 208 | 0] == 1) {
   sqlite3ErrorMsg($0, 4814, 0);
   break label$1;
  }
  label$3: {
   label$4: {
    $4 = HEAP32[$3 + 4 >> 2];
    $6 = HEAP16[$3 + 34 >> 1] - 1 | 0;
    $7 = $4 + Math_imul($6, 12) | 0;
    label$5: {
     if (HEAPU16[$7 + 8 >> 1]) {
      break label$5;
     }
     if (!$2) {
      break label$4;
     }
     label$6: {
      switch (HEAP32[$2 + 4 >> 2] - 6 | 0) {
      case 0:
       if (sqlite3_strnicmp(15044, HEAP32[$2 >> 2], 6)) {
        break label$5;
       }
       $2 = 64;
       break label$3;

      case 1:
       break label$6;

      default:
       break label$5;
      }
     }
     if (!sqlite3_strnicmp(11239, HEAP32[$2 >> 2], 7)) {
      break label$4;
     }
    }
    HEAP32[$5 >> 2] = HEAP32[$7 >> 2];
    sqlite3ErrorMsg($0, 28593, $5);
    break label$1;
   }
   HEAP16[$3 + 36 >> 1] = HEAPU16[$3 + 36 >> 1] - 1;
   $2 = 32;
  }
  $4 = Math_imul($6, 12) + $4 | 0;
  $6 = $4;
  $4 = HEAPU16[$4 + 10 >> 1];
  HEAP16[$6 + 10 >> 1] = $2 | $4;
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 28 >> 2] | $2;
  if ($4 & 1) {
   makeColumnPartOfPrimaryKey($0, $7);
  }
  sqlite3ColumnSetExpr($0, $3, $7, $1);
  $1 = 0;
 }
 sqlite3ExprDelete(HEAP32[$0 >> 2], $1);
 __stack_pointer = $5 + 16 | 0;
}

function cellSizePtrTableLeaf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = HEAP8[$1 | 0];
 $4 = $2 & 255;
 label$1: {
  if (($2 | 0) >= 0) {
   $3 = $1;
   break label$1;
  }
  $4 = $4 & 127;
  $2 = 0;
  while (1) {
   $6 = $2 + 1 | 0;
   $3 = $6 + $1 | 0;
   $5 = HEAP8[$3 | 0];
   $4 = $5 & 127 | $4 << 7;
   if (($5 | 0) >= 0) {
    break label$1;
   }
   $5 = $2 >>> 0 < 7;
   $2 = $6;
   if ($5) {
    continue;
   }
   break;
  }
 }
 $2 = $3 + 2 | 0;
 label$4: {
  if (HEAP8[$3 + 1 | 0] >= 0) {
   break label$4;
  }
  $2 = $3 + 3 | 0;
  if (HEAP8[$3 + 2 | 0] >= 0) {
   break label$4;
  }
  $2 = $3 + 4 | 0;
  if (HEAP8[$3 + 3 | 0] >= 0) {
   break label$4;
  }
  $2 = $3 + 5 | 0;
  if (HEAP8[$3 + 4 | 0] >= 0) {
   break label$4;
  }
  $2 = $3 + 6 | 0;
  if (HEAP8[$3 + 5 | 0] >= 0) {
   break label$4;
  }
  $2 = $3 + 7 | 0;
  if (HEAP8[$3 + 6 | 0] >= 0) {
   break label$4;
  }
  $2 = $3 + 8 | 0;
  if (HEAP8[$3 + 7 | 0] >= 0) {
   break label$4;
  }
  $2 = (HEAP8[$3 + 8 | 0] < 0 ? 10 : 9) + $3 | 0;
 }
 $5 = HEAPU16[$0 + 14 >> 1];
 label$5: {
  if ($5 >>> 0 >= $4 >>> 0) {
   $2 = ($4 - $1 | 0) + $2 | 0;
   $2 = $2 >>> 0 > 4 ? $2 : 4;
   break label$5;
  }
  $3 = $2 - $1 & 65535;
  $2 = HEAPU16[$0 + 16 >> 1];
  $1 = $2;
  $2 = (($4 - $2 >>> 0) % (HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] - 4 >>> 0) | 0) + $2 | 0;
  $2 = ($3 + ($2 >>> 0 > $5 >>> 0 ? $1 : $2) | 0) + 4 | 0;
 }
 return $2 & 65535;
}

function fts3EvalPhraseStart($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = HEAP32[$0 >> 2];
 $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $3 = 0;
  if (HEAPU8[$0 + 52 | 0] != HEAPU8[$6 + 239 | 0]) {
   break label$1;
  }
  $1 = HEAP32[$2 + 64 >> 2];
  $3 = 0;
  if (($1 | 0) > 4) {
   break label$1;
  }
  $3 = ($1 | 0) > 0;
 }
 $1 = 0;
 label$2: {
  label$3: {
   while (1) {
    if (($3 | 0) != 1) {
     break label$3;
    }
    if (HEAP32[$2 + 64 >> 2] > ($1 | 0)) {
     $3 = Math_imul($1, 24) + $2 | 0;
     $4 = HEAP32[$3 + 92 >> 2];
     label$6: {
      if (!HEAP32[$3 + 84 >> 2]) {
       $3 = 1;
       if (!$4) {
        $4 = 0;
        break label$6;
       }
       if (HEAP32[$4 + 36 >> 2]) {
        break label$6;
       }
      }
      $3 = 0;
     }
     $5 = $4 ? 1 : $5;
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   if (!$5) {
    break label$3;
   }
   $1 = HEAP32[$2 + 68 >> 2];
   $5 = HEAP32[$6 + 24 >> 2] > ($1 | 0) ? $1 : -1;
   $1 = 0;
   $7 = 1;
   $4 = 0;
   while (1) {
    if (HEAP32[$2 + 64 >> 2] <= ($1 | 0) | $4) {
     break label$2;
    }
    $4 = Math_imul($1, 24) + $2 | 0;
    $3 = HEAP32[$4 + 92 >> 2];
    if ($3) {
     $4 = sqlite3Fts3MsrIncrStart($6, $3, $5, HEAP32[$4 + 72 >> 2], HEAP32[$4 + 76 >> 2]);
    } else {
     $4 = 0;
    }
    $1 = $1 + 1 | 0;
    continue;
   }
  }
  $4 = fts3EvalPhraseLoad($0, $2);
 }
 HEAP32[$2 + 40 >> 2] = $7;
 return $4;
}

function openStatTable($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 $11 = HEAP32[$0 >> 2];
 $8 = sqlite3GetVdbe($0);
 if ($8) {
  $10 = HEAP32[$11 + 16 >> 2] + ($1 << 4) | 0;
  while (1) {
   if (($7 | 0) != 3) {
    $12 = ($5 + 33 | 0) + $7 | 0;
    HEAP8[$12 | 0] = 0;
    $9 = HEAP32[($7 << 3) + 49712 >> 2];
    $6 = sqlite3FindTable($11, $9, HEAP32[$10 >> 2]);
    label$4: {
     if (!$6) {
      if ($7) {
       break label$4;
      }
      $6 = HEAP32[$10 >> 2];
      HEAP32[$5 + 8 >> 2] = 3296;
      HEAP32[$5 + 4 >> 2] = $9;
      HEAP32[$5 >> 2] = $6;
      sqlite3NestedParse($0, 24402, $5);
      HEAP32[$5 + 36 >> 2] = HEAP32[$0 + 92 >> 2];
      HEAP8[$12 | 0] = 16;
      break label$4;
     }
     $6 = HEAP32[$6 + 20 >> 2];
     HEAP32[($5 + 36 | 0) + ($7 << 2) >> 2] = $6;
     sqlite3TableLock($0, $1, $6, 1, $9);
     if ($3) {
      $6 = HEAP32[$10 >> 2];
      HEAP32[$5 + 28 >> 2] = $3;
      HEAP32[$5 + 24 >> 2] = $4;
      HEAP32[$5 + 20 >> 2] = $9;
      HEAP32[$5 + 16 >> 2] = $6;
      sqlite3NestedParse($0, 19029, $5 + 16 | 0);
      break label$4;
     }
     sqlite3VdbeAddOp2($8, 145, $6, $1);
    }
    $7 = $7 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3VdbeAddOp4Int($8, 113, $2, HEAP32[$5 + 36 >> 2], $1, 3);
  sqlite3VdbeChangeP5($8, HEAPU8[$5 + 33 | 0]);
 }
 __stack_pointer = $5 + 48 | 0;
}

function sqlite3ExprCodeRunJustOnce($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  $5 = HEAP32[$0 + 68 >> 2];
  if (!$5 | ($2 | 0) >= 0) {
   break label$1;
  }
  $3 = $5 + 8 | 0;
  $4 = HEAP32[$5 >> 2];
  while (1) {
   if (($4 | 0) <= 0) {
    break label$1;
   }
   label$3: {
    if (!(HEAPU8[$3 + 9 | 0] & 8)) {
     break label$3;
    }
    if (sqlite3ExprCompare(0, HEAP32[$3 >> 2], $1, -1)) {
     break label$3;
    }
    return HEAP32[$3 + 12 >> 2];
   }
   $4 = $4 - 1 | 0;
   $3 = $3 + 16 | 0;
   continue;
  }
 }
 $3 = sqlite3ExprDup(HEAP32[$0 >> 2], $1, 0);
 if (!(!$3 | !(HEAPU8[$3 + 4 | 0] & 8))) {
  $1 = HEAP32[$0 + 8 >> 2];
  $5 = sqlite3VdbeAddOp0($1, 14);
  HEAP8[$0 + 23 | 0] = 0;
  $4 = HEAP32[$0 >> 2];
  if (!HEAPU8[$4 + 87 | 0]) {
   if (($2 | 0) < 0) {
    $2 = HEAP32[$0 + 44 >> 2] + 1 | 0;
    HEAP32[$0 + 44 >> 2] = $2;
   }
   sqlite3ExprCode($0, $3, $2);
   $4 = HEAP32[$0 >> 2];
  }
  HEAP8[$0 + 23 | 0] = 1;
  sqlite3ExprDelete($4, $3);
  sqlite3VdbeJumpHere($1, $5);
  return $2;
 }
 $3 = sqlite3ExprListAppend($0, $5, $3);
 if ($3) {
  $4 = (HEAP32[$3 >> 2] - 1 << 4) + $3 | 0;
  $1 = $4 + 17 | 0;
  $5 = (HEAPU8[$4 + 17 | 0] | HEAPU8[$4 + 18 | 0] << 8) & 65527 | $2 >>> 28 & 8;
  HEAP8[$1 | 0] = $5;
  HEAP8[$1 + 1 | 0] = $5 >>> 8;
  if (($2 | 0) < 0) {
   $2 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $2;
  }
  HEAP32[$4 + 20 >> 2] = $2;
 }
 HEAP32[$0 + 68 >> 2] = $3;
 return $2;
}

function computeYMD($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 if (!HEAPU8[$0 + 42 | 0]) {
  label$2: {
   if (!HEAPU8[$0 + 40 | 0]) {
    HEAP32[$0 + 16 >> 2] = 1;
    HEAP32[$0 + 8 >> 2] = 2e3;
    HEAP32[$0 + 12 >> 2] = 1;
    break label$2;
   }
   $1 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$0 >> 2];
   if (!validJulianDay($2, $1)) {
    datetimeError($0);
    return;
   }
   $2 = $2 + 432e5 | 0;
   $2 = __wasm_i64_sdiv($2, $2 >>> 0 < 432e5 ? $1 + 1 | 0 : $1, 864e5, 0);
   $3 = (+($2 | 0) + -1867216.25) / 36524.25;
   label$5: {
    if (Math_abs($3) < 2147483648) {
     $1 = ~~$3;
     break label$5;
    }
    $1 = -2147483648;
   }
   $1 = (($1 + $2 | 0) + (($1 | 0) / -4 | 0) | 0) + 1525 | 0;
   $3 = (+($1 | 0) + -122.1) / 365.25;
   label$7: {
    if (Math_abs($3) < 2147483648) {
     $2 = ~~$3;
     break label$7;
    }
    $2 = -2147483648;
   }
   $4 = $1 - ((Math_imul($2 & 32767, 36525) >>> 0) / 100 | 0) | 0;
   $3 = +($4 | 0) / 30.6001;
   label$9: {
    if (Math_abs($3) < 2147483648) {
     $1 = ~~$3;
     break label$9;
    }
    $1 = -2147483648;
   }
   $5 = $1 + (($1 | 0) < 14 ? -1 : -13) | 0;
   HEAP32[$0 + 12 >> 2] = $5;
   $3 = +($1 | 0) * 30.6001;
   label$11: {
    if (Math_abs($3) < 2147483648) {
     $1 = ~~$3;
     break label$11;
    }
    $1 = -2147483648;
   }
   HEAP32[$0 + 16 >> 2] = $4 - $1;
   HEAP32[$0 + 8 >> 2] = (($5 | 0) > 2 ? -4716 : -4715) + $2;
  }
  HEAP8[$0 + 42 | 0] = 1;
 }
}

function sqlite3WhereExprUsageFull($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 if (HEAPU8[$1 | 0] == 179) {
  $3 = sqlite3WhereGetMask($0, HEAP32[$1 + 28 >> 2]);
  $4 = i64toi32_i32$HIGH_BITS;
 }
 $2 = HEAP32[$1 + 12 >> 2];
 if ($2) {
  $3 = sqlite3WhereExprUsageNN($0, $2) | $3;
  $4 = $4 | i64toi32_i32$HIGH_BITS;
 }
 $2 = HEAP32[$1 + 16 >> 2];
 label$3: {
  if ($2) {
   $3 = sqlite3WhereExprUsageNN($0, $2) | $3;
   $4 = i64toi32_i32$HIGH_BITS | $4;
   break label$3;
  }
  $2 = HEAP32[$1 + 4 >> 2];
  if ($2 & 4096) {
   if ($2 & 64) {
    HEAP32[$0 >> 2] = 1;
   }
   $3 = exprSelectUsage($0, HEAP32[$1 + 20 >> 2]) | $3;
   $4 = $4 | i64toi32_i32$HIGH_BITS;
   break label$3;
  }
  $2 = HEAP32[$1 + 20 >> 2];
  if (!$2) {
   break label$3;
  }
  $3 = sqlite3WhereExprListUsage($0, $2) | $3;
  $4 = i64toi32_i32$HIGH_BITS | $4;
 }
 label$7: {
  label$8: {
   switch (HEAPU8[$1 | 0] - 168 | 0) {
   case 0:
   case 4:
    break label$8;

   default:
    break label$7;
   }
  }
  if (!(HEAP8[$1 + 7 | 0] & 1)) {
   break label$7;
  }
  $2 = sqlite3WhereExprListUsage($0, HEAP32[HEAP32[$1 + 44 >> 2] + 8 >> 2]);
  $5 = i64toi32_i32$HIGH_BITS;
  $2 = sqlite3WhereExprListUsage($0, HEAP32[HEAP32[$1 + 44 >> 2] + 12 >> 2]) | $2;
  $5 = $5 | i64toi32_i32$HIGH_BITS;
  $3 = $3 | (sqlite3WhereExprUsage($0, HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2]) | $2);
  $4 = $4 | ($5 | i64toi32_i32$HIGH_BITS);
 }
 i64toi32_i32$HIGH_BITS = $4;
 return $3;
}

function selectRefEnter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 label$1: {
  $1 = HEAP32[$1 + 32 >> 2];
  $6 = HEAP32[$1 >> 2];
  if (!$6) {
   break label$1;
  }
  $7 = HEAP32[$0 + 24 >> 2];
  $2 = HEAP32[$7 + 12 >> 2];
  $10 = $2;
  $5 = $7;
  $3 = HEAP32[$5 + 8 >> 2];
  $11 = $3;
  $5 = $3;
  $3 = $6;
  $2 = $3 >> 31;
  $8 = $3;
  $6 = $5 + $3 | 0;
  $3 = $2;
  $2 = $10;
  $4 = $3 + $2 | 0;
  $5 = $7;
  HEAP32[$5 + 8 >> 2] = $6;
  $4 = $6 >>> 0 < $8 >>> 0 ? $4 + 1 | 0 : $4;
  HEAP32[$5 + 12 >> 2] = $4;
  $2 = $6;
  $5 = $4 << 2 | $2 >>> 30;
  $0 = sqlite3DbRealloc(HEAP32[$7 >> 2], HEAP32[$7 + 16 >> 2], $2 << 2, $5);
  if (!$0) {
   $2 = $7;
   HEAP32[$2 + 8 >> 2] = 0;
   HEAP32[$2 + 12 >> 2] = 0;
   $12 = 2;
   break label$1;
  }
  HEAP32[$7 + 16 >> 2] = $0;
  $9 = 0;
  $7 = 0;
  while (1) {
   $4 = $1;
   $5 = HEAP32[$4 >> 2];
   $2 = $5 >> 31;
   $3 = $2;
   $8 = $5;
   $4 = $9;
   $2 = $7;
   $5 = $3;
   if ($8 >>> 0 <= $4 >>> 0 & ($2 | 0) >= ($5 | 0) | ($2 | 0) > ($5 | 0)) {
    break label$1;
   }
   HEAP32[($11 << 2) + $0 >> 2] = HEAP32[(($9 << 6) + $1 | 0) + 48 >> 2];
   $4 = $10;
   $8 = $11;
   $3 = $8 + 1 | 0;
   $6 = $3 ? $4 : $4 + 1 | 0;
   $11 = $3;
   $10 = $6;
   $6 = $7;
   $3 = $6;
   $4 = $9;
   $2 = $4 + 1 | 0;
   $3 = $2 ? $3 : $3 + 1 | 0;
   $9 = $2;
   $7 = $3;
   continue;
  }
 }
 return $12 | 0;
}

function roundFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 label$1: {
  if (($1 | 0) == 2) {
   $1 = HEAP32[$2 + 4 >> 2];
   if ((sqlite3_value_type($1) | 0) == 5) {
    break label$1;
   }
   $1 = sqlite3_value_int($1);
   $1 = ($1 | 0) < 30 ? $1 : 30;
   $5 = ($1 | 0) > 0 ? $1 : 0;
  }
  $2 = HEAP32[$2 >> 2];
  if ((sqlite3_value_type($2) | 0) == 5) {
   break label$1;
  }
  $3 = sqlite3_value_double($2);
  HEAPF64[$4 + 24 >> 3] = $3;
  label$3: {
   if ($3 < -4503599627370496 | $3 > 4503599627370496) {
    break label$3;
   }
   if (!$5) {
    $3 = $3 + ($3 < 0 ? -.5 : .5);
    label$5: {
     if (Math_abs($3) < 0x8000000000000000) {
      $1 = Math_abs($3) >= 1 ? ~~($3 > 0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
      $2 = ~~$3 >>> 0;
      break label$5;
     }
     $1 = -2147483648;
     $2 = 0;
    }
    $3 = +($2 >>> 0) + +($1 | 0) * 4294967296;
    break label$3;
   }
   HEAPF64[$4 + 8 >> 3] = $3;
   HEAP32[$4 >> 2] = $5;
   $2 = sqlite3_mprintf(12119, $4);
   if (!$2) {
    sqlite3_result_error_nomem($0);
    break label$1;
   }
   sqlite3AtoF($2, $4 + 24 | 0, sqlite3Strlen30($2), 1);
   sqlite3_free($2);
   $3 = HEAPF64[$4 + 24 >> 3];
  }
  sqlite3_result_double($0, $3);
 }
 __stack_pointer = $4 + 32 | 0;
}

function fts3RenameMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 $5 = HEAP32[$0 + 12 >> 2];
 $3 = fts3SetHasStat($0);
 HEAP32[$2 + 76 >> 2] = $3;
 if (!$3) {
  HEAP32[$2 + 76 >> 2] = sqlite3Fts3PendingTermsFlush($0);
 }
 if (!HEAP32[$0 + 40 >> 2]) {
  $4 = HEAP32[$0 + 20 >> 2];
  $3 = HEAP32[$0 + 16 >> 2];
  HEAP32[$2 + 72 >> 2] = $1;
  HEAP32[$2 + 64 >> 2] = $3;
  HEAP32[$2 + 68 >> 2] = $4;
  fts3DbExec($2 + 76 | 0, $5, 22185, $2 - -64 | 0);
 }
 if (HEAPU8[$0 + 238 | 0]) {
  $3 = HEAP32[$0 + 20 >> 2];
  $4 = HEAP32[$0 + 16 >> 2];
  HEAP32[$2 + 56 >> 2] = $1;
  HEAP32[$2 + 48 >> 2] = $4;
  HEAP32[$2 + 52 >> 2] = $3;
  fts3DbExec($2 + 76 | 0, $5, 22391, $2 + 48 | 0);
 }
 if (HEAPU8[$0 + 237 | 0]) {
  $4 = HEAP32[$0 + 20 >> 2];
  $3 = HEAP32[$0 + 16 >> 2];
  HEAP32[$2 + 40 >> 2] = $1;
  HEAP32[$2 + 32 >> 2] = $3;
  HEAP32[$2 + 36 >> 2] = $4;
  fts3DbExec($2 + 76 | 0, $5, 22238, $2 + 32 | 0);
 }
 $3 = HEAP32[$0 + 20 >> 2];
 $4 = HEAP32[$0 + 16 >> 2];
 HEAP32[$2 + 24 >> 2] = $1;
 HEAP32[$2 + 16 >> 2] = $4;
 HEAP32[$2 + 20 >> 2] = $3;
 fts3DbExec($2 + 76 | 0, $5, 22285, $2 + 16 | 0);
 $4 = HEAP32[$0 + 20 >> 2];
 $3 = HEAP32[$0 + 16 >> 2];
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 >> 2] = $3;
 HEAP32[$2 + 4 >> 2] = $4;
 fts3DbExec($2 + 76 | 0, $5, 22339, $2);
 __stack_pointer = $2 + 80 | 0;
 $0 = HEAP32[$2 + 76 >> 2];
 return $0 | 0;
}

function sqlite3TableAffinity($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (HEAP8[$1 + 30 | 0] & 1) {
  if (!$2) {
   sqlite3VdbeAppendP4($0, $1, -5);
   $3 = sqlite3VdbeGetOp($0, -1);
   HEAP8[$3 | 0] = 95;
   sqlite3VdbeAddOp3($0, 97, HEAP32[$3 + 4 >> 2], HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2]);
   return;
  }
  sqlite3VdbeAddOp2($0, 95, $2, HEAP16[$1 + 36 >> 1]);
  sqlite3VdbeAppendP4($0, $1, -5);
  return;
 }
 label$3: {
  $4 = HEAP32[$1 + 12 >> 2];
  if ($4) {
   break label$3;
  }
  $3 = sqlite3VdbeDb($0);
  $5 = HEAP16[$1 + 34 >> 1];
  $4 = $5 >> 31;
  $5 = $5 + 1 | 0;
  $4 = $5 ? $4 : $4 + 1 | 0;
  $4 = sqlite3DbMallocRaw(0, $5, $4);
  if ($4) {
   $3 = 0;
   while (1) if (HEAP16[$1 + 34 >> 1] <= ($3 | 0)) {
    while (1) {
     label$8: {
      HEAP8[$4 + $6 | 0] = 0;
      if (($6 | 0) <= 0) {
       break label$8;
      }
      $6 = $6 - 1 | 0;
      if (HEAP8[$6 + $4 | 0] < 66) {
       continue;
      }
     }
     break;
    }
    HEAP32[$1 + 12 >> 2] = $4;
    break label$3;
   } else {
    $5 = HEAP32[$1 + 4 >> 2] + Math_imul($3, 12) | 0;
    if (!(HEAPU8[$5 + 10 | 0] & 32)) {
     HEAP8[$4 + $6 | 0] = HEAPU8[$5 + 5 | 0];
     $6 = $6 + 1 | 0;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
  }
  sqlite3OomFault($3);
  return;
 }
 $3 = strlen($4) & 1073741823;
 if ($3) {
  if ($2) {
   sqlite3VdbeAddOp4($0, 96, $2, $3, 0, $4, $3);
   return;
  }
  sqlite3VdbeChangeP4($0, -1, $4, $3);
 }
}

function fts3tokConnectMethod($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = 0;
 HEAP32[$6 + 8 >> 2] = 0;
 HEAP32[$6 + 4 >> 2] = 0;
 $0 = sqlite3_declare_vtab($0, 24615);
 if (!$0) {
  label$2: {
   label$3: {
    $0 = fts3tokDequoteArray($2 - 3 | 0, $3 + 12 | 0, $6 + 4 | 0);
    label$4: {
     if ($0) {
      break label$4;
     }
     $0 = 13357;
     $0 = ($2 | 0) >= 4 ? HEAP32[HEAP32[$6 + 4 >> 2] >> 2] : $0;
     $0 = fts3tokQueryTokenizer($1, $0, $6 + 12 | 0, $5);
     if ($0) {
      break label$4;
     }
     $0 = ($2 | 0) > 4;
     $3 = HEAP32[$6 + 12 >> 2];
     $0 = FUNCTION_TABLE[HEAP32[$3 + 4 >> 2]]($0 ? $2 - 4 | 0 : 0, $0 ? HEAP32[$6 + 4 >> 2] + 4 | 0 : 0, $6 + 8 | 0) | 0;
     if ($0) {
      break label$4;
     }
     $2 = sqlite3_malloc(20);
     if ($2) {
      break label$3;
     }
     $0 = 7;
    }
    $2 = HEAP32[$6 + 8 >> 2];
    if (!$2) {
     break label$2;
    }
    FUNCTION_TABLE[HEAP32[HEAP32[$6 + 12 >> 2] + 8 >> 2]]($2) | 0;
    break label$2;
   }
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   HEAP32[$2 + 12 >> 2] = $3;
   $0 = 0;
   HEAP32[$2 + 8 >> 2] = 0;
   HEAP32[$2 + 16 >> 2] = HEAP32[$6 + 8 >> 2];
   HEAP32[$4 >> 2] = $2;
  }
  sqlite3_free(HEAP32[$6 + 4 >> 2]);
 }
 __stack_pointer = $6 + 16 | 0;
 return $0 | 0;
}

function fts3TermSelect($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 144 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$1 + 20 >> 2];
 memset($5 + 16 | 0, 0, 128);
 $7 = HEAP32[$1 + 8 >> 2];
 $8 = HEAP32[$1 + 12 >> 2];
 $9 = HEAP32[$0 + 24 >> 2];
 HEAP32[$5 + 8 >> 2] = $2;
 HEAP32[$5 + 12 >> 2] = (($8 | 0) != 0) << 5 | ($7 ? 11 : 3) | (($2 | 0) < ($9 | 0)) << 2;
 HEAP32[$5 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$5 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
 $2 = sqlite3Fts3SegReaderStart($0, $6, $5);
 while (1) {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      if ($2) {
       break label$5;
      }
      $2 = sqlite3Fts3SegReaderStep($0, $6);
      if (($2 | 0) == 100) {
       break label$2;
      }
      if ($2) {
       break label$5;
      }
      $2 = fts3TermSelectFinishMerge($0, $5 + 16 | 0);
      if (!$2) {
       break label$4;
      }
     }
     $0 = 0;
     while (1) {
      if (($0 | 0) == 16) {
       break label$3;
      }
      sqlite3_free(HEAP32[($5 + 16 | 0) + ($0 << 2) >> 2]);
      $0 = $0 + 1 | 0;
      continue;
     }
    }
    HEAP32[$4 >> 2] = HEAP32[$5 + 16 >> 2];
    HEAP32[$3 >> 2] = HEAP32[$5 + 80 >> 2];
    $2 = 0;
   }
   fts3SegReaderCursorFree($6);
   HEAP32[$1 + 20 >> 2] = 0;
   __stack_pointer = $5 + 144 | 0;
   return $2;
  }
  $2 = fts3TermSelectMerge($0, $5 + 16 | 0, HEAP32[$6 + 48 >> 2], HEAP32[$6 + 52 >> 2]);
  continue;
 }
}

function sqlite3GenerateIndexKey($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $10 = HEAP32[$0 + 8 >> 2];
 if ($5) {
  if (HEAP32[$1 + 36 >> 2]) {
   HEAP32[$5 >> 2] = sqlite3VdbeMakeLabel($0);
   HEAP32[$0 + 52 >> 2] = $2 + 1;
   sqlite3ExprIfFalseDup($0, HEAP32[$1 + 36 >> 2], HEAP32[$5 >> 2]);
   $6 = 0;
   $5 = $0 + 52 | 0;
  }
  HEAP32[$5 >> 2] = 0;
 }
 if (!$4 | !(HEAPU8[$1 + 55 | 0] & 8)) {
  $5 = $1 + 52 | 0;
 } else {
  $5 = $1 + 50 | 0;
 }
 $9 = HEAPU16[$5 >> 1];
 $8 = sqlite3GetTempRange($0, $9);
 label$5: {
  if (!$6) {
   break label$5;
  }
  if (($7 | 0) == ($8 | 0)) {
   $4 = $6;
   $11 = $4;
   if (!HEAP32[$4 + 36 >> 2]) {
    break label$5;
   }
  }
  $11 = 0;
 }
 $4 = $11;
 $5 = 0;
 while (1) {
  if (($5 | 0) != ($9 | 0)) {
   label$9: {
    label$10: {
     if (!$4) {
      break label$10;
     }
     $6 = $5 << 1;
     $7 = HEAPU16[$6 + HEAP32[$4 + 4 >> 2] >> 1];
     if (($7 | 0) == 65534) {
      break label$10;
     }
     if (HEAPU16[HEAP32[$1 + 4 >> 2] + $6 >> 1] == ($7 | 0)) {
      break label$9;
     }
    }
    sqlite3ExprCodeLoadIndexColumn($0, $1, $2, $5, $5 + $8 | 0);
    if (HEAP16[HEAP32[$1 + 4 >> 2] + ($5 << 1) >> 1] < 0) {
     break label$9;
    }
    sqlite3VdbeDeletePriorOpcode($10);
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 if ($3) {
  sqlite3VdbeAddOp3($10, 97, $8, $9, $3);
 }
 sqlite3ReleaseTempRange($0, $8, $9);
 return $8;
}

function fts3SnippetNextCandidate($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  label$2: {
   if (HEAP32[$0 + 20 >> 2] >= 0) {
    $5 = HEAP32[$0 + 12 >> 2];
    $6 = ($5 | 0) > 0 ? $5 : 0;
    $1 = 2147483647;
    while (1) {
     if (($2 | 0) == ($6 | 0)) {
      break label$2;
     }
     $3 = HEAP32[$0 + 16 >> 2] + Math_imul($2, 40) | 0;
     if (HEAP32[$3 + 16 >> 2]) {
      $4 = HEAP32[$3 + 8 >> 2];
      $7 = $4;
      $4 = $1 >> 31;
      $3 = HEAP32[$3 + 12 >> 2];
      $1 = $1 >>> 0 > $7 >>> 0 & ($4 | 0) >= ($3 | 0) | ($4 | 0) > ($3 | 0) ? $7 : $1;
     }
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   HEAP32[$0 + 20 >> 2] = 0;
   while (1) {
    if (HEAP32[$0 + 12 >> 2] <= ($2 | 0)) {
     break label$1;
    }
    $1 = HEAP32[$0 + 16 >> 2] + Math_imul($2, 40) | 0;
    fts3SnippetAdvance($1 + 16 | 0, $1 + 8 | 0, HEAP32[$0 + 8 >> 2]);
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  $4 = 1;
  if (($1 | 0) == 2147483647) {
   break label$1;
  }
  $3 = ($1 - HEAP32[$0 + 8 >> 2] | 0) + 1 | 0;
  HEAP32[$0 + 20 >> 2] = $3;
  $6 = $1 + 1 | 0;
  $4 = 0;
  $2 = 0;
  while (1) {
   if (($2 | 0) >= ($5 | 0)) {
    break label$1;
   }
   $1 = HEAP32[$0 + 16 >> 2] + Math_imul($2, 40) | 0;
   fts3SnippetAdvance($1 + 16 | 0, $1 + 8 | 0, $6);
   fts3SnippetAdvance($1 + 32 | 0, $1 + 24 | 0, $3);
   $2 = $2 + 1 | 0;
   $5 = HEAP32[$0 + 12 >> 2];
   continue;
  }
 }
 return $4;
}

function sqlite3WhereAddLimit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $7 = HEAP32[$1 + 60 >> 2];
  if (!$7 | HEAPU8[$1 + 4 | 0] & 9) {
   break label$1;
  }
  $2 = HEAP32[$1 + 32 >> 2];
  if (HEAP32[$2 >> 2] != 1 | HEAPU8[HEAP32[$2 + 24 >> 2] + 43 | 0] != 1) {
   break label$1;
  }
  $4 = HEAP32[$0 + 12 >> 2];
  $4 = ($4 | 0) > 0 ? $4 : 0;
  $5 = HEAP32[$2 + 48 >> 2];
  $6 = HEAP32[$1 + 48 >> 2];
  while (1) {
   if (($3 | 0) != ($4 | 0)) {
    $2 = HEAP32[$0 + 24 >> 2] + Math_imul($3, 48) | 0;
    if (!(HEAPU8[$2 + 10 | 0] & 4) & HEAP32[$2 + 20 >> 2] != ($5 | 0)) {
     break label$1;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  label$5: {
   if (!$6) {
    break label$5;
   }
   $3 = 0;
   $2 = HEAP32[$6 >> 2];
   $8 = ($2 | 0) > 0 ? $2 : 0;
   while (1) {
    if (($3 | 0) == ($8 | 0)) {
     break label$5;
    }
    $4 = ($3 << 4) + $6 | 0;
    $2 = HEAP32[$4 + 8 >> 2];
    if (HEAPU8[$2 | 0] != 167 | HEAP32[$2 + 28 >> 2] != ($5 | 0)) {
     break label$1;
    }
    $3 = $3 + 1 | 0;
    if (!(HEAPU8[$4 + 16 | 0] & 2)) {
     continue;
    }
    break;
   }
   break label$1;
  }
  whereAddLimitExpr($0, HEAP32[$1 + 8 >> 2], HEAP32[$7 + 12 >> 2], $5, 73);
  $3 = HEAP32[$1 + 12 >> 2];
  if (($3 | 0) <= 0) {
   break label$1;
  }
  whereAddLimitExpr($0, $3, HEAP32[HEAP32[$1 + 60 >> 2] + 16 >> 2], $5, 74);
 }
}

function sqlite3Analyze($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$0 >> 2];
 label$1: {
  if (sqlite3ReadSchema($0)) {
   break label$1;
  }
  label$2: {
   if (!$1) {
    $1 = 0;
    while (1) {
     if (HEAP32[$3 + 20 >> 2] <= ($1 | 0)) {
      break label$2;
     }
     if (($1 | 0) != 1) {
      analyzeDatabase($0, $1);
     }
     $1 = $1 + 1 | 0;
     continue;
    }
   }
   label$6: {
    if (HEAP32[$2 + 4 >> 2]) {
     break label$6;
    }
    $4 = sqlite3FindDb($3, $1);
    if (($4 | 0) < 0) {
     break label$6;
    }
    analyzeDatabase($0, $4);
    break label$2;
   }
   $4 = 0;
   $1 = sqlite3TwoPartName($0, $1, $2, $5 + 12 | 0);
   if (($1 | 0) < 0) {
    break label$2;
   }
   $4 = HEAP32[$2 + 4 >> 2] ? HEAP32[HEAP32[$3 + 16 >> 2] + ($1 << 4) >> 2] : $4;
   $1 = sqlite3NameFromToken($3, HEAP32[$5 + 12 >> 2]);
   if (!$1) {
    break label$2;
   }
   $2 = sqlite3FindIndex($3, $1, $4);
   label$8: {
    if ($2) {
     analyzeTable($0, HEAP32[$2 + 12 >> 2], $2);
     break label$8;
    }
    $2 = sqlite3LocateTable($0, 0, $1, $4);
    if (!$2) {
     break label$8;
    }
    analyzeTable($0, $2, 0);
   }
   sqlite3DbFree($3, $1);
  }
  if (HEAPU8[$3 + 96 | 0]) {
   break label$1;
  }
  $1 = sqlite3GetVdbe($0);
  if (!$1) {
   break label$1;
  }
  sqlite3VdbeAddOp0($1, 166);
 }
 __stack_pointer = $5 + 16 | 0;
}

function fts3EvalUpdateCounts($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 while (1) {
  if ($0) {
   $2 = HEAP32[$0 + 20 >> 2];
   label$3: {
    if (!$2) {
     break label$3;
    }
    $2 = HEAP32[$2 + 28 >> 2];
    if (!$2) {
     break label$3;
    }
    $4 = 0;
    HEAP32[$5 + 12 >> 2] = 0;
    while (1) {
     $3 = 0;
     $6 = 0;
     while (1) {
      $7 = HEAPU8[$2 | 0];
      if ($7 & 254 | $3) {
       $2 = $2 + 1 | 0;
       $6 = !$3 + $6 | 0;
       $3 = $7 & 128;
       continue;
      }
      break;
     }
     $3 = HEAP32[$0 + 40 >> 2] + Math_imul($4, 12) | 0;
     $7 = $3 + 4 | 0;
     HEAP32[$7 >> 2] = HEAP32[$3 + 4 >> 2] + $6;
     $4 = $3;
     $3 = $3 + 8 | 0;
     HEAP32[$3 >> 2] = HEAP32[$4 + 8 >> 2] + (($6 | 0) != 0);
     if (!HEAPU8[$2 | 0]) {
      break label$3;
     }
     $3 = $2 + 1 | 0;
     $2 = HEAP8[$2 + 1 | 0];
     label$7: {
      if (($2 | 0) < 0) {
       $2 = sqlite3Fts3GetVarint32($3, $5 + 12 | 0);
       $4 = HEAP32[$5 + 12 >> 2];
       break label$7;
      }
      $4 = $2 & 255;
      HEAP32[$5 + 12 >> 2] = $4;
      $2 = 1;
     }
     $2 = $2 + $3 | 0;
     if (($1 | 0) > ($4 | 0)) {
      continue;
     }
     break;
    }
   }
   fts3EvalUpdateCounts(HEAP32[$0 + 12 >> 2], $1);
   $0 = HEAP32[$0 + 16 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $5 + 16 | 0;
}

function btreeComputeFreeSpace($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $9 = HEAPU16[$0 + 24 >> 1];
 $10 = HEAPU8[$0 + 10 | 0];
 $5 = HEAPU8[$0 + 9 | 0];
 $6 = HEAP32[$0 + 56 >> 2];
 $1 = $5 + $6 | 0;
 $2 = (HEAPU8[$1 + 5 | 0] << 8 | HEAPU8[$1 + 6 | 0]) - 1 & 65535;
 $3 = ($2 + HEAPU8[$1 + 7 | 0] | 0) + 1 | 0;
 $4 = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2];
 label$1: {
  label$2: {
   $1 = HEAPU8[$1 + 2 | 0] | HEAPU8[$1 + 1 | 0] << 8;
   if (!$1) {
    break label$2;
   }
   if ($1 >>> 0 <= $2 >>> 0) {
    break label$1;
   }
   $11 = $4 - 4 | 0;
   while (1) {
    if (($1 | 0) > ($11 | 0)) {
     return sqlite3CorruptError(68867);
    }
    $2 = $1 + $6 | 0;
    $7 = HEAPU8[$2 + 2 | 0] << 8 | HEAPU8[$2 + 3 | 0];
    $8 = $7 + $1 | 0;
    $3 = $3 + $7 | 0;
    $2 = HEAPU8[$2 + 1 | 0] | HEAPU8[$2 | 0] << 8;
    $1 = $2;
    if ($1 >>> 0 > $8 + 3 >>> 0) {
     continue;
    }
    break;
   }
   if ($2) {
    return sqlite3CorruptError(68877);
   }
   if ($4 >>> 0 >= $8 >>> 0) {
    break label$2;
   }
   return sqlite3CorruptError(68881);
  }
  label$6: {
   if (($3 | 0) <= ($4 | 0)) {
    $1 = (($10 + $5 | 0) + ($9 << 1) | 0) + 8 | 0;
    if (($3 | 0) >= ($1 | 0)) {
     break label$6;
    }
   }
   return sqlite3CorruptError(68893);
  }
  HEAP32[$0 + 20 >> 2] = $3 - $1 & 65535;
  return 0;
 }
 return sqlite3CorruptError(68862);
}

function sqlite3PagerSavepoint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$0 + 44 >> 2];
 label$1: {
  if ($4) {
   break label$1;
  }
  $4 = 0;
  $3 = HEAP32[$0 + 104 >> 2];
  if (($3 | 0) <= ($2 | 0)) {
   break label$1;
  }
  $5 = (($1 | 0) != 1) + $2 | 0;
  $2 = $5;
  while (1) {
   if (($2 | 0) < ($3 | 0)) {
    sqlite3BitvecDestroy(HEAP32[(HEAP32[$0 + 100 >> 2] + Math_imul($2, 48) | 0) + 16 >> 2]);
    $2 = $2 + 1 | 0;
    $3 = HEAP32[$0 + 104 >> 2];
    continue;
   }
   break;
  }
  HEAP32[$0 + 104 >> 2] = $5;
  if (($1 | 0) == 1) {
   $2 = HEAP32[$0 + 100 >> 2];
   if (!HEAP32[($2 + Math_imul($5, 48) | 0) + 28 >> 2]) {
    break label$1;
   }
   $3 = HEAP32[$0 + 72 >> 2];
   if (!HEAP32[$3 >> 2]) {
    break label$1;
   }
   if (sqlite3JournalIsInMemory($3)) {
    $1 = HEAP32[$0 + 172 >> 2];
    $4 = HEAP32[$0 + 168 >> 2] + 4 | 0;
    $1 = $4 >>> 0 < 4 ? $1 + 1 | 0 : $1;
    $4 = __wasm_i64_mul(HEAP32[(Math_imul($5, 48) + $2 | 0) + 24 >> 2], 0, $4, $1);
    $1 = i64toi32_i32$HIGH_BITS;
    $3 = sqlite3OsTruncate($3, $4, $1);
   } else {
    $3 = 0;
   }
   HEAP32[$0 + 56 >> 2] = HEAP32[(Math_imul($5, 48) + $2 | 0) + 24 >> 2];
   return $3;
  }
  if (!(HEAP32[HEAP32[$0 + 68 >> 2] >> 2] ? 1 : HEAP32[$0 + 232 >> 2])) {
   break label$1;
  }
  $2 = $5 ? (HEAP32[$0 + 100 >> 2] + Math_imul($5, 48) | 0) - 48 | 0 : 0;
  $4 = pagerPlaybackSavepoint($0, $2);
 }
 return $4;
}

function trinkle($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $8 = __stack_pointer - 240 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 236 >> 2] = $4;
 HEAP32[$8 + 232 >> 2] = $3;
 HEAP32[$8 >> 2] = $0;
 $12 = 1;
 label$1: {
  label$2: {
   label$3: {
    if (!(($3 | 0) != 1 | $4)) {
     $9 = $0;
     break label$3;
    }
    $13 = 0 - $1 | 0;
    $10 = $0;
    while (1) {
     $11 = ($5 << 2) + $7 | 0;
     $9 = $10 - HEAP32[$11 >> 2] | 0;
     if ((FUNCTION_TABLE[$2 | 0]($9, $0) | 0) <= 0) {
      $9 = $10;
      break label$3;
     }
     label$7: {
      if (!(($5 | 0) < 2 | $6)) {
       $6 = HEAP32[$11 - 8 >> 2];
       $11 = $10 + $13 | 0;
       if ((FUNCTION_TABLE[$2 | 0]($11, $9) | 0) >= 0) {
        break label$7;
       }
       if ((FUNCTION_TABLE[$2 | 0]($11 - $6 | 0, $9) | 0) >= 0) {
        break label$7;
       }
      }
      HEAP32[($12 << 2) + $8 >> 2] = $9;
      $10 = pntz($3, $4);
      shr($8 + 232 | 0, $10);
      $12 = $12 + 1 | 0;
      $5 = $5 + $10 | 0;
      $6 = 0;
      $10 = $9;
      $4 = HEAP32[$8 + 236 >> 2];
      $3 = HEAP32[$8 + 232 >> 2];
      if ($4 | ($3 | 0) != 1) {
       continue;
      }
      break label$2;
     }
     break;
    }
    $9 = $10;
    break label$2;
   }
   if ($6) {
    break label$1;
   }
  }
  cycle($1, $8, $12);
  sift($9, $1, $2, $5, $7);
 }
 __stack_pointer = $8 + 240 | 0;
}

function vdbeSorterSort($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 256 | 0;
 __stack_pointer = $5;
 $2 = vdbeSortAllocUnpacked($0);
 if (!$2) {
  $3 = HEAP32[$1 >> 2];
  HEAP32[$0 + 32 >> 2] = vdbeSorterGetCompare(HEAP32[$0 + 8 >> 2]);
  $8 = memset($5, 0, 256);
  while (1) {
   if ($3) {
    $2 = HEAP32[$1 + 4 >> 2];
    label$4: {
     if ($2) {
      $4 = 0;
      if (($2 | 0) == ($3 | 0)) {
       break label$4;
      }
      $4 = HEAP32[$3 + 4 >> 2] + $2 | 0;
      break label$4;
     }
     $4 = HEAP32[$3 + 4 >> 2];
    }
    $2 = 0;
    HEAP32[$3 + 4 >> 2] = 0;
    while (1) {
     $6 = ($2 << 2) + $8 | 0;
     $9 = HEAP32[$6 >> 2];
     if ($9) {
      $3 = vdbeSorterMerge($0, $3, $9);
      HEAP32[$6 >> 2] = 0;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP32[$6 >> 2] = $3;
    $3 = $4;
    continue;
   } else {
    $2 = 0;
    while (1) {
     if (($7 | 0) != 64) {
      $3 = HEAP32[($7 << 2) + $8 >> 2];
      label$11: {
       if (!$3) {
        break label$11;
       }
       if (!$2) {
        $2 = $3;
        break label$11;
       }
       $2 = vdbeSorterMerge($0, $2, $3);
      }
      $7 = $7 + 1 | 0;
      continue;
     }
     break;
    }
    HEAP32[$1 >> 2] = $2;
    $2 = HEAPU8[HEAP32[$0 + 12 >> 2] + 23 | 0];
   }
   break;
  }
 }
 __stack_pointer = $5 + 256 | 0;
 return $2;
}

function sqlite3VdbeIdxRowid($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 96 | 0;
 __stack_pointer = $3;
 $4 = sqlite3BtreePayloadSize($1);
 sqlite3VdbeMemInit($3 + 48 | 0, $0, 0);
 $1 = sqlite3VdbeMemFromBtreeZeroOffset($1, $4, $3 + 48 | 0);
 label$1: {
  if ($1) {
   break label$1;
  }
  $4 = HEAP32[$3 + 56 >> 2];
  $0 = HEAP8[$4 | 0];
  $1 = $0 & 255;
  HEAP32[$3 + 92 >> 2] = $1;
  if (($0 | 0) < 0) {
   sqlite3GetVarint32($4, $3 + 92 | 0);
   $1 = HEAP32[$3 + 92 >> 2];
  }
  label$3: {
   if ($1 >>> 0 < 3) {
    break label$3;
   }
   $6 = HEAP32[$3 + 60 >> 2];
   if ($6 >>> 0 < $1 >>> 0) {
    break label$3;
   }
   $7 = ($1 + $4 | 0) - 1 | 0;
   $5 = HEAP8[$7 | 0];
   $0 = $5 & 255;
   HEAP32[$3 + 88 >> 2] = $0;
   if (($5 | 0) < 0) {
    sqlite3GetVarint32($7, $3 + 88 | 0);
    $0 = HEAP32[$3 + 88 >> 2];
   }
   if (($0 | 0) == 7 | $0 - 10 >>> 0 < 4294967287) {
    break label$3;
   }
   $5 = HEAPU8[$0 + 33216 | 0];
   if ($5 + $1 >>> 0 > $6 >>> 0) {
    break label$3;
   }
   sqlite3VdbeSerialGet(($6 - $5 | 0) + $4 | 0, $0, $3 + 8 | 0);
   $0 = HEAP32[$3 + 12 >> 2];
   HEAP32[$2 >> 2] = HEAP32[$3 + 8 >> 2];
   HEAP32[$2 + 4 >> 2] = $0;
   sqlite3VdbeMemReleaseMalloc($3 + 48 | 0);
   $1 = 0;
   break label$1;
  }
  sqlite3VdbeMemReleaseMalloc($3 + 48 | 0);
  $1 = sqlite3CorruptError(85711);
 }
 __stack_pointer = $3 + 96 | 0;
 return $1;
}

function jsonEachNext($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (HEAPU8[$0 + 21 | 0]) {
   $3 = HEAP32[$0 + 40 >> 2];
   $1 = HEAP32[$0 + 12 >> 2];
   $2 = HEAPU8[($3 + Math_imul($1, 12) | 0) + 1 | 0];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
   $2 = ($2 >>> 6 & 1) + $1 | 0;
   $1 = $2 + 1 | 0;
   HEAP32[$0 + 12 >> 2] = $1;
   if (HEAPU32[$0 + 16 >> 2] <= $1 >>> 0) {
    break label$1;
   }
   $4 = HEAP32[HEAP32[$0 + 48 >> 2] + ($1 << 2) >> 2];
   $1 = HEAPU8[Math_imul($4, 12) + $3 | 0];
   HEAP8[$0 + 20 | 0] = $1;
   if (($1 | 0) != 6) {
    break label$1;
   }
   if (($2 | 0) == ($4 | 0)) {
    HEAP32[(Math_imul($2, 12) + $3 | 0) + 8 >> 2] = 0;
    break label$1;
   }
   $0 = Math_imul($4, 12) + $3 | 0;
   HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] + 1;
   break label$1;
  }
  label$4: {
   switch (HEAPU8[$0 + 20 | 0] - 6 | 0) {
   case 0:
    $1 = HEAP32[$0 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = $1 + jsonNodeSize(HEAP32[$0 + 40 >> 2] + Math_imul($1, 12) | 0);
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
    break label$1;

   case 1:
    $1 = HEAP32[$0 + 12 >> 2] + 1 | 0;
    HEAP32[$0 + 12 >> 2] = $1 + jsonNodeSize(HEAP32[$0 + 40 >> 2] + Math_imul($1, 12) | 0);
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
    break label$1;

   default:
    break label$4;
   }
  }
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 16 >> 2];
 }
 return 0;
}

function et_getdigit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$1 >> 2];
 if (($6 | 0) <= 0) {
  $0 = 48;
 } else {
  HEAP32[$1 >> 2] = $6 - 1;
  $2 = $0;
  $1 = HEAP32[$2 >> 2];
  $7 = $1;
  $3 = HEAP32[$2 + 4 >> 2];
  $4 = $3;
  $1 = $2 + 8 | 0;
  $2 = $1;
  $3 = HEAP32[$2 >> 2];
  $8 = $3;
  $1 = HEAP32[$2 + 4 >> 2];
  $9 = $1;
  $1 = $4;
  $3 = $9;
  $6 = __fixtfsi($7, $1, $8, $3);
  __floatsitf($5 + 32 | 0, $6);
  $2 = $5;
  $3 = HEAP32[$2 + 32 >> 2];
  $10 = $3;
  $1 = HEAP32[$2 + 36 >> 2];
  $11 = $1;
  $1 = HEAP32[$2 + 40 >> 2];
  $12 = $1;
  $3 = HEAP32[$2 + 44 >> 2];
  $13 = $3;
  $14 = $2 + 16 | 0;
  $3 = $4;
  $1 = $9;
  $2 = $11;
  __subtf3($14, $7, $3, $8, $1, $10, $2, $12, $13);
  $1 = $5;
  $2 = HEAP32[$1 + 20 >> 2];
  $3 = $2;
  $2 = HEAP32[$1 + 24 >> 2];
  $4 = $2;
  $2 = HEAP32[$1 + 28 >> 2];
  __multf3($1, HEAP32[$1 + 16 >> 2], $3, $4, $2, 0, 0, 0, 1073889280);
  $2 = $1;
  $3 = HEAP32[$2 >> 2];
  $1 = HEAP32[$2 + 4 >> 2];
  $4 = $3;
  $3 = $0;
  HEAP32[$3 >> 2] = $4;
  HEAP32[$3 + 4 >> 2] = $1;
  $3 = HEAP32[$2 + 12 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  $2 = $1;
  $1 = $0;
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $3;
  $0 = $6 + 48 | 0;
 }
 __stack_pointer = $5 + 48 | 0;
 return $0 << 24 >> 24;
}

function parseHhMmSs($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = $2 + 44;
 HEAP32[$2 + 20 >> 2] = $2 + 40;
 $3 = 1;
 label$1: {
  if ((getDigits($0, 14191, $2 + 16 | 0) | 0) != 2) {
   break label$1;
  }
  label$2: {
   if (HEAPU8[$0 + 5 | 0] == 58) {
    HEAP32[$2 >> 2] = $2 + 36;
    $3 = 1;
    if ((getDigits($0 + 6 | 0, 14210, $2) | 0) != 1) {
     break label$1;
    }
    $5 = $0 + 8 | 0;
    $4 = 0;
    if (HEAPU8[$0 + 8 | 0] != 46) {
     break label$2;
    }
    $3 = HEAPU8[$0 + 9 | 0];
    $4 = 0;
    if ($3 - 58 >>> 0 < 4294967286) {
     break label$2;
    }
    $5 = $0 + 9 | 0;
    $4 = 1;
    while (1) {
     if ($3 - 58 >>> 0 >= 4294967286) {
      $6 = $6 * 10 + +($3 << 24 >> 24) + -48;
      $4 = $4 * 10;
      $3 = HEAPU8[$5 + 1 | 0];
      $5 = $5 + 1 | 0;
      continue;
     }
     break;
    }
    $4 = $6 / $4;
    break label$2;
   }
   $5 = $0 + 5 | 0;
   HEAP32[$2 + 36 >> 2] = 0;
   $4 = 0;
  }
  HEAP8[$1 + 43 | 0] = 1;
  HEAP16[$1 + 40 >> 1] = 0;
  HEAP32[$1 + 20 >> 2] = HEAP32[$2 + 44 >> 2];
  HEAP32[$1 + 24 >> 2] = HEAP32[$2 + 40 >> 2];
  HEAPF64[$1 + 32 >> 3] = $4 + +HEAP32[$2 + 36 >> 2];
  $3 = 1;
  if (parseTimezone($5, $1)) {
   break label$1;
  }
  HEAP8[$1 + 44 | 0] = HEAP32[$1 + 28 >> 2] != 0;
  $3 = 0;
 }
 __stack_pointer = $2 + 48 | 0;
 return $3;
}

function sqlite3ExprListDup($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $5 = sqlite3DbMallocSize($0, $1);
  $7 = sqlite3DbMallocRawNN($0, $5, $5 >> 31);
  if (!$7) {
   break label$1;
  }
  HEAP32[$7 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$7 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
  $6 = $1 + 8 | 0;
  $4 = $7 + 8 | 0;
  while (1) {
   if (HEAP32[$1 >> 2] <= ($10 | 0)) {
    $0 = $7;
   } else {
    $3 = HEAP32[$6 >> 2];
    $8 = sqlite3ExprDup($0, $3, $2);
    HEAP32[$4 >> 2] = $8;
    if (!(!$3 | (!$8 | HEAPU8[$3 | 0] != 178))) {
     $5 = HEAP32[$8 + 16 >> 2];
     label$6: {
      if ($5) {
       $11 = HEAP32[$3 + 16 >> 2];
       $9 = $5;
       break label$6;
      }
      $3 = HEAP32[$3 + 12 >> 2];
      if (($11 | 0) == ($3 | 0)) {
       break label$6;
      }
      $9 = sqlite3ExprDup($0, $3, $2);
      HEAP32[$8 + 16 >> 2] = $9;
      $11 = $3;
     }
     HEAP32[$8 + 12 >> 2] = $9;
    }
    HEAP32[$4 + 4 >> 2] = sqlite3DbStrDup($0, HEAP32[$6 + 4 >> 2]);
    $3 = HEAP32[$6 + 8 >> 2];
    HEAP32[$4 + 8 >> 2] = $3;
    $5 = $3 >>> 8 & 65531;
    HEAP8[$4 + 9 | 0] = $5;
    HEAP8[$4 + 10 | 0] = $5 >>> 8;
    HEAP32[$4 + 12 >> 2] = HEAP32[$6 + 12 >> 2];
    $6 = $6 + 16 | 0;
    $4 = $4 + 16 | 0;
    $10 = $10 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = $0;
 }
 return $4;
}

function sqlite3ExprListAppendVector($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $9 = $1 ? HEAP32[$1 >> 2] : 0;
 $7 = HEAP32[$0 >> 2];
 label$3: {
  if (!$2 | !$3) {
   break label$3;
  }
  label$4: {
   if (HEAPU8[$3 | 0] == 138) {
    break label$4;
   }
   $4 = HEAP32[$2 >> 2];
   $5 = sqlite3ExprVectorSize($3);
   if (($4 | 0) == ($5 | 0)) {
    break label$4;
   }
   HEAP32[$6 + 4 >> 2] = $5;
   HEAP32[$6 >> 2] = $4;
   sqlite3ErrorMsg($0, 5018, $6);
   break label$3;
  }
  $4 = 0;
  while (1) {
   $5 = HEAP32[$2 >> 2];
   if (($4 | 0) < ($5 | 0)) {
    $5 = sqlite3ExprForVectorField($0, $3, $4, $5);
    label$7: {
     if (!$5) {
      break label$7;
     }
     $1 = sqlite3ExprListAppend($0, $1, $5);
     if (!$1) {
      $1 = 0;
      break label$7;
     }
     $8 = ($4 << 3) + $2 | 0;
     $5 = $8 + 8 | 0;
     HEAP32[((HEAP32[$1 >> 2] << 4) + $1 | 0) - 4 >> 2] = HEAP32[$5 >> 2];
     HEAP32[$8 + 8 >> 2] = 0;
    }
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  if (HEAPU8[$7 + 87 | 0] | (!$1 | HEAPU8[$3 | 0] != 138)) {
   break label$3;
  }
  $4 = HEAP32[(($9 << 4) + $1 | 0) + 8 >> 2];
  HEAP32[$4 + 28 >> 2] = $5;
  HEAP32[$4 + 16 >> 2] = $3;
  $3 = 0;
 }
 sqlite3ExprUnmapAndDelete($0, $3);
 sqlite3IdListDelete($7, $2);
 __stack_pointer = $6 + 16 | 0;
 return $1;
}

function likeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = sqlite3_context_db_handle($0);
 $4 = sqlite3_user_data($0);
 label$1: {
  if ((sqlite3_value_bytes(HEAP32[$2 >> 2]) | 0) > HEAP32[$3 + 152 >> 2]) {
   sqlite3_result_error($0, 1418, -1);
   break label$1;
  }
  label$3: {
   if (($1 | 0) == 3) {
    $3 = sqlite3_value_text(HEAP32[$2 + 8 >> 2]);
    HEAP32[$5 + 4 >> 2] = $3;
    if (!$3) {
     break label$1;
    }
    if ((sqlite3Utf8CharLen($3, -1) | 0) != 1) {
     sqlite3_result_error($0, 8796, -1);
     break label$1;
    }
    $1 = sqlite3Utf8Read($5 + 4 | 0);
    if (($1 | 0) != HEAPU8[$4 | 0] & HEAPU8[$4 + 1 | 0] != ($1 | 0)) {
     break label$3;
    }
    $3 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8 | (HEAPU8[$4 + 2 | 0] << 16 | HEAPU8[$4 + 3 | 0] << 24);
    HEAP32[$5 + 8 >> 2] = $3;
    if (($3 & 255) == ($1 | 0)) {
     HEAP8[$5 + 8 | 0] = 0;
    }
    $4 = $5 + 8 | 0;
    if (($3 >>> 8 & 255) != ($1 | 0)) {
     break label$3;
    }
    HEAP8[$5 + 9 | 0] = 0;
    break label$3;
   }
   $1 = HEAPU8[$4 + 2 | 0];
  }
  $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
  $2 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
  if (!$2 | !$3) {
   break label$1;
  }
  sqlite3_result_int($0, !patternCompare($3, $2, $4, $1));
 }
 __stack_pointer = $5 + 16 | 0;
}

function fts3PrefixParameter($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = 1;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $4 = HEAPU8[$0 | 0];
  if (!$4) {
   break label$1;
  }
  $6 = 2;
  $3 = $0;
  while (1) {
   $4 = $4 & 255;
   label$3: {
    if (($4 | 0) != 44) {
     if ($4) {
      break label$3;
     }
     break label$1;
    }
    $6 = $6 + 1 | 0;
   }
   $4 = HEAPU8[$3 + 1 | 0];
   $3 = $3 + 1 | 0;
   continue;
  }
 }
 $4 = Math_imul($6, 24);
 $3 = sqlite3_malloc64($4, 0);
 HEAP32[$2 >> 2] = $3;
 label$5: {
  if (!$3) {
   $7 = 7;
   break label$5;
  }
  $2 = memset($3, 0, $4);
  label$7: {
   if (!$0) {
    break label$7;
   }
   HEAP32[$5 + 12 >> 2] = $0;
   $3 = 1;
   while (1) {
    if (($3 | 0) >= ($6 | 0)) {
     break label$7;
    }
    HEAP32[$5 + 8 >> 2] = 0;
    label$9: {
     label$10: {
      if (!fts3GobbleInt($5 + 12 | 0, $5 + 8 | 0)) {
       $4 = HEAP32[$5 + 8 >> 2];
       if ($4) {
        break label$10;
       }
       $3 = $3 - 1 | 0;
       $6 = $6 - 1 | 0;
       break label$9;
      }
      $7 = 1;
      break label$5;
     }
     HEAP32[Math_imul($3, 24) + $2 >> 2] = $4;
    }
    HEAP32[$5 + 12 >> 2] = HEAP32[$5 + 12 >> 2] + 1;
    $3 = $3 + 1 | 0;
    continue;
   }
  }
  HEAP32[$1 >> 2] = $6;
 }
 __stack_pointer = $5 + 16 | 0;
 return $7;
}

function sqlite3ResolveExprListNames($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 label$1: {
  if ($1) {
   $4 = HEAP32[$0 >> 2];
   HEAP32[$3 + 24 >> 2] = $0;
   HEAP32[$3 + 12 >> 2] = 0;
   HEAP32[$3 + 8 >> 2] = 56;
   HEAP32[$3 + 4 >> 2] = 55;
   HEAP32[$3 >> 2] = $4;
   $5 = HEAP32[$0 + 24 >> 2];
   $2 = $5 & -134254609;
   HEAP32[$0 + 24 >> 2] = $2;
   $7 = $5 & 134254608;
   $5 = 0;
   while (1) {
    if (HEAP32[$1 >> 2] > ($5 | 0)) {
     $6 = HEAP32[(($5 << 4) + $1 | 0) + 8 >> 2];
     if ($6) {
      $2 = HEAP32[$4 + 216 >> 2] + HEAP32[$6 + 24 >> 2] | 0;
      HEAP32[$4 + 216 >> 2] = $2;
      $8 = 2;
      if (sqlite3ExprCheckHeight($4, $2)) {
       break label$1;
      }
      sqlite3WalkExpr($3, $6);
      $4 = HEAP32[$3 >> 2];
      HEAP32[$4 + 216 >> 2] = HEAP32[$4 + 216 >> 2] - HEAP32[$6 + 24 >> 2];
      $2 = HEAP32[$0 + 24 >> 2];
      $9 = $2 & 134254608;
      if ($9) {
       HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] | $2 & 32784;
       $2 = $2 & -134254609;
       HEAP32[$0 + 24 >> 2] = $2;
       $7 = $7 | $9;
      }
      if (HEAP32[$4 + 36 >> 2] > 0) {
       break label$1;
      }
     }
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$0 + 24 >> 2] = $2 | $7;
  }
  $8 = 0;
 }
 __stack_pointer = $3 + 32 | 0;
 return $8;
}

function sqlite3OpenTableAndIndices($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 if (HEAPU8[$1 + 43 | 0] == 1) {
  HEAP32[$7 >> 2] = -999;
  HEAP32[$6 >> 2] = -999;
  return 0;
 }
 $9 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$1 + 60 >> 2]);
 $4 = ($4 | 0) < 0 ? HEAP32[$0 + 40 >> 2] : $4;
 $10 = HEAP32[$0 + 8 >> 2];
 if ($6) {
  HEAP32[$6 >> 2] = $4;
 }
 label$4: {
  if (!(HEAPU8[$1 + 28 | 0] & 128 | (HEAPU8[$5 | 0] ? 0 : $5))) {
   sqlite3OpenTable($0, $4, $9, $1, $2);
   break label$4;
  }
  sqlite3TableLock($0, $9, HEAP32[$1 + 20 >> 2], ($2 | 0) == 113, HEAP32[$1 >> 2]);
 }
 $8 = $4 + 1 | 0;
 if ($7) {
  HEAP32[$7 >> 2] = $8;
 }
 $4 = $1 + 8 | 0;
 $7 = 0;
 while (1) {
  $4 = HEAP32[$4 >> 2];
  if ($4) {
   label$10: {
    if (((HEAPU8[$4 + 55 | 0] | HEAPU8[$4 + 56 | 0] << 8) & 3) != 2) {
     break label$10;
    }
    $11 = HEAP32[$1 + 28 >> 2] & 128;
    $3 = $11 ? 0 : $3;
    if (!$6 | !$11) {
     break label$10;
    }
    HEAP32[$6 >> 2] = $8;
    $3 = 0;
   }
   $7 = $7 + 1 | 0;
   if (!(HEAPU8[$7 + $5 | 0] ? 0 : $5)) {
    sqlite3VdbeAddOp3($10, $2, $8, HEAP32[$4 + 44 >> 2], $9);
    sqlite3VdbeSetP4KeyInfo($0, $4);
    sqlite3VdbeChangeP5($10, $3 & 255);
   }
   $8 = $8 + 1 | 0;
   $4 = $4 + 20 | 0;
   continue;
  }
  break;
 }
 if (HEAP32[$0 + 40 >> 2] < ($8 | 0)) {
  HEAP32[$0 + 40 >> 2] = $8;
 }
 return $7;
}

function sqlite3WithAdd($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $5 = HEAP32[$0 >> 2];
  label$2: {
   if (!$1) {
    break label$2;
   }
   $3 = HEAP32[$2 >> 2];
   if (!$3) {
    break label$2;
   }
   while (1) {
    if (HEAP32[$1 >> 2] <= ($4 | 0)) {
     break label$2;
    }
    if (!sqlite3StrICmp($3, HEAP32[(Math_imul($4, 24) + $1 | 0) + 12 >> 2])) {
     HEAP32[$6 >> 2] = $3;
     sqlite3ErrorMsg($0, 7786, $6);
    }
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  label$5: {
   if ($1) {
    $4 = sqlite3DbRealloc($5, $1, Math_imul(HEAP32[$1 >> 2], 24) + 36 | 0, 0);
    $0 = 0;
    break label$5;
   }
   $4 = sqlite3DbMallocZero($5, 36, 0);
   $0 = 0;
  }
  if (HEAPU8[$5 + 87 | 0]) {
   sqlite3CteDelete($5, $2);
   break label$1;
  }
  $1 = HEAP32[$4 >> 2];
  HEAP32[$4 >> 2] = $1 + 1;
  $3 = HEAP32[$2 + 20 >> 2];
  $0 = HEAP32[$2 + 16 >> 2];
  $1 = Math_imul($1, 24) + $4 | 0;
  HEAP32[$1 + 28 >> 2] = $0;
  HEAP32[$1 + 32 >> 2] = $3;
  $0 = HEAP32[$2 + 12 >> 2];
  $3 = HEAP32[$2 + 8 >> 2];
  HEAP32[$1 + 20 >> 2] = $3;
  HEAP32[$1 + 24 >> 2] = $0;
  $3 = HEAP32[$2 + 4 >> 2];
  $0 = HEAP32[$2 >> 2];
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$1 + 16 >> 2] = $3;
  sqlite3DbFree($5, $2);
  $1 = $4;
 }
 __stack_pointer = $6 + 16 | 0;
 return $1;
}

function fillInUnixFile($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$2 + 32 >> 2] = $3;
 HEAP32[$2 + 4 >> 2] = $0;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAP16[$2 + 18 >> 1] = $4 & 255;
 if (sqlite3_uri_boolean($4 << 25 >> 31 & $3, 1623, 1)) {
  HEAP16[$2 + 18 >> 1] = HEAPU16[$2 + 18 >> 1] | 16;
 }
 if (!strcmp(HEAP32[$0 + 16 >> 2], 11221)) {
  HEAP16[$2 + 18 >> 1] = HEAPU16[$2 + 18 >> 1] | 1;
 }
 $6 = 31948;
 label$3: {
  label$4: {
   if ($4 & 128) {
    break label$4;
   }
   $6 = 31872;
   $4 = FUNCTION_TABLE[HEAP32[HEAP32[$0 + 20 >> 2] >> 2]]($3, $2) | 0;
   if (($4 | 0) == 31872) {
    $4 = findInodeInfo($2, $2 + 8 | 0);
    if (!$4) {
     break label$4;
    }
    robust_close($2, $1, 41188);
    $1 = -1;
    break label$3;
   }
   if (($4 | 0) != 32024) {
    $6 = $4;
    break label$4;
   }
   $4 = strlen($3) + 6 | 0;
   $0 = sqlite3_malloc64($4, $4 >> 31);
   if ($0) {
    HEAP32[$5 >> 2] = $3;
    sqlite3_snprintf($4, $0, 11407, $5);
    $4 = 0;
   } else {
    $4 = 7;
   }
   HEAP32[$2 + 24 >> 2] = $0;
   $6 = 32024;
   break label$3;
  }
  $4 = 0;
 }
 storeLastErrno($2, 0);
 label$9: {
  if ($4) {
   if (($1 | 0) < 0) {
    break label$9;
   }
   robust_close($2, $1, 41273);
   break label$9;
  }
  HEAP32[$2 >> 2] = $6;
  verifyDbFile($2);
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function sqlite3WalFindFrame($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  $7 = HEAP32[$0 + 68 >> 2];
  if (!(HEAPU16[$0 + 40 >> 1] | HEAPU8[$0 + 50 | 0] ? $7 : 0)) {
   HEAP32[$2 >> 2] = 0;
   break label$1;
  }
  $11 = walFramePage(HEAP32[$0 + 100 >> 2]);
  $5 = walFramePage($7);
  while (1) {
   $6 = 0;
   label$5: {
    if (($5 | 0) >= ($11 | 0)) {
     $3 = walHashGet($0, $5, $4);
     if ($3) {
      break label$1;
     }
     $8 = 8192;
     $3 = walHash($1);
     $12 = HEAP32[$4 + 4 >> 2];
     $13 = HEAP32[$4 + 8 >> 2];
     $14 = HEAP32[$4 >> 2];
     while (1) {
      $9 = HEAPU16[($3 << 1) + $14 >> 1];
      if ($9) {
       $10 = $9 + $13 | 0;
       if (!($10 >>> 0 > $7 >>> 0 | HEAPU32[$0 + 100 >> 2] > $10 >>> 0)) {
        $6 = HEAP32[(($9 << 2) + $12 | 0) - 4 >> 2] == ($1 | 0) ? $10 : $6;
       }
       if ($8) {
        $8 = $8 - 1 | 0;
        $3 = walNextHash($3);
        continue;
       } else {
        $3 = sqlite3CorruptError(64853);
        break label$1;
       }
      }
      break;
     }
     if (!$6) {
      break label$5;
     }
    }
    HEAP32[$2 >> 2] = $6;
    $3 = 0;
    break label$1;
   }
   $5 = $5 - 1 | 0;
   continue;
  }
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function sqlite3DbMallocRawNN($0, $1, $2) {
 var $3 = 0;
 label$1: {
  label$2: {
   if (!$2 & HEAPU16[$0 + 308 >> 1] < $1 >>> 0 | $2) {
    if (!HEAP32[$0 + 304 >> 2]) {
     $3 = $0 + 324 | 0;
     HEAP32[$3 >> 2] = HEAP32[$0 + 324 >> 2] + 1;
     break label$2;
    }
    if (!HEAPU8[$0 + 87 | 0]) {
     break label$2;
    }
    break label$1;
   }
   label$5: {
    if (!$2 & $1 >>> 0 > 128 | $2) {
     break label$5;
    }
    $3 = HEAP32[$0 + 344 >> 2];
    if ($3) {
     HEAP32[$0 + 344 >> 2] = HEAP32[$3 >> 2];
     $1 = $0;
     $0 = $0 + 320 | 0;
     HEAP32[$0 >> 2] = HEAP32[$1 + 320 >> 2] + 1;
     return $3;
    }
    $3 = HEAP32[$0 + 340 >> 2];
    if (!$3) {
     break label$5;
    }
    HEAP32[$0 + 340 >> 2] = HEAP32[$3 >> 2];
    $1 = $0;
    $0 = $0 + 320 | 0;
    HEAP32[$0 >> 2] = HEAP32[$1 + 320 >> 2] + 1;
    return $3;
   }
   $3 = HEAP32[$0 + 336 >> 2];
   if ($3) {
    HEAP32[$0 + 336 >> 2] = HEAP32[$3 >> 2];
    $1 = $0;
    $0 = $0 + 320 | 0;
    HEAP32[$0 >> 2] = HEAP32[$1 + 320 >> 2] + 1;
    return $3;
   }
   $3 = HEAP32[$0 + 332 >> 2];
   if ($3) {
    HEAP32[$0 + 332 >> 2] = HEAP32[$3 >> 2];
    $1 = $0;
    $0 = $0 + 320 | 0;
    HEAP32[$0 >> 2] = HEAP32[$1 + 320 >> 2] + 1;
    return $3;
   }
   $3 = $0 + 328 | 0;
   HEAP32[$3 >> 2] = HEAP32[$0 + 328 >> 2] + 1;
  }
  $3 = dbMallocRawFinish($0, $1, $2);
 }
 return $3;
}

function _substr($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = -1;
 label$1: {
  if (!HEAPU8[$0 | 0]) {
   break label$1;
  }
  $6 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   if (!(!sqlite3ReadUtf8($1) | ($5 | 0) == ($6 | 0))) {
    $5 = $5 + 1 | 0;
    while (1) {
     $3 = HEAPU8[$1 + 1 | 0];
     $4 = $1 + 1 | 0;
     $1 = $4;
     if (($3 & 192) == 128) {
      continue;
     }
     break;
    }
    $1 = $4;
    continue;
   }
   break;
  }
  while (1) {
   $3 = $0;
   $5 = $1;
   if (!sqlite3ReadUtf8($1)) {
    break label$1;
   }
   while (1) {
    $7 = sqlite3ReadUtf8($3);
    $9 = sqlite3ReadUtf8($5);
    while (1) {
     $4 = HEAPU8[$3 + 1 | 0];
     $6 = $3 + 1 | 0;
     $3 = $6;
     if (($4 & 192) == 128) {
      continue;
     }
     break;
    }
    $3 = $5;
    while (1) {
     $4 = HEAPU8[$3 + 1 | 0];
     $5 = $3 + 1 | 0;
     $3 = $5;
     if (($4 & 192) == 128) {
      continue;
     }
     break;
    }
    if (!(!$9 | !$7)) {
     $3 = $6;
     if (($7 | 0) == ($9 | 0)) {
      continue;
     }
    }
    break;
   }
   if ($7) {
    while (1) {
     $3 = HEAPU8[$1 + 1 | 0];
     $4 = $1 + 1 | 0;
     $1 = $4;
     if (($3 & 192) == 128) {
      continue;
     }
     break;
    }
    $10 = $10 + 1 | 0;
    $1 = $4;
    continue;
   }
   break;
  }
  $8 = $2 + $10 | 0;
 }
 return $8;
}

function sqlite3Fts3HashInsert($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = FUNCTION_TABLE[ftsHashFunction(HEAP8[$0 | 0]) | 0]($1, $2) | 0;
 $5 = $6 & HEAP32[$0 + 12 >> 2] - 1;
 $4 = fts3FindElementByHash($0, $1, $2, $5);
 if ($4) {
  $1 = HEAP32[$4 + 8 >> 2];
  if (!$3) {
   fts3RemoveElementByHash($0, $4, $5);
   return $1;
  }
  HEAP32[$4 + 8 >> 2] = $3;
  return $1;
 }
 label$3: {
  if ($3) {
   label$5: {
    $4 = HEAP32[$0 + 12 >> 2];
    label$6: {
     if (!$4) {
      if (fts3Rehash($0, 8)) {
       break label$6;
      }
      $4 = HEAP32[$0 + 12 >> 2];
     }
     if (HEAP32[$0 + 4 >> 2] < ($4 | 0)) {
      break label$5;
     }
     if (!fts3Rehash($0, $4 << 1)) {
      break label$5;
     }
    }
    HEAP32[$0 + 4 >> 2] = 0;
    return $3;
   }
   $4 = fts3HashMalloc(20, 0);
   if (!$4) {
    break label$3;
   }
   label$8: {
    if (!(!$1 | !HEAPU8[$0 + 1 | 0])) {
     $5 = fts3HashMalloc($2, $2 >> 31);
     HEAP32[$4 + 12 >> 2] = $5;
     if (!$5) {
      fts3HashFree($4);
      return $3;
     }
     __memcpy($5, $1, $2);
     break label$8;
    }
    HEAP32[$4 + 12 >> 2] = $1;
   }
   HEAP32[$4 + 16 >> 2] = $2;
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
   fts3HashInsertElement($0, HEAP32[$0 + 16 >> 2] + ((HEAP32[$0 + 12 >> 2] - 1 & $6) << 3) | 0, $4);
   HEAP32[$4 + 8 >> 2] = $3;
  }
  $3 = 0;
 }
 return $3;
}

function __stpncpy($0, $1, $2) {
 var $3 = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     if (($0 ^ $1) & 3) {
      break label$4;
     }
     $3 = ($2 | 0) != 0;
     label$5: {
      if (!($1 & 3) | !$2) {
       break label$5;
      }
      while (1) {
       $3 = HEAPU8[$1 | 0];
       HEAP8[$0 | 0] = $3;
       if (!$3) {
        break label$1;
       }
       $0 = $0 + 1 | 0;
       $2 = $2 - 1 | 0;
       $3 = ($2 | 0) != 0;
       $1 = $1 + 1 | 0;
       if (!($1 & 3)) {
        break label$5;
       }
       if ($2) {
        continue;
       }
       break;
      }
     }
     if (!$3) {
      break label$2;
     }
     if (!HEAPU8[$1 | 0]) {
      break label$1;
     }
     if ($2 >>> 0 < 4) {
      break label$4;
     }
     while (1) {
      $3 = HEAP32[$1 >> 2];
      if (($3 ^ -1) & $3 - 16843009 & -2139062144) {
       break label$3;
      }
      HEAP32[$0 >> 2] = $3;
      $0 = $0 + 4 | 0;
      $1 = $1 + 4 | 0;
      $2 = $2 - 4 | 0;
      if ($2 >>> 0 > 3) {
       continue;
      }
      break;
     }
    }
    if (!$2) {
     break label$2;
    }
   }
   while (1) {
    $3 = HEAPU8[$1 | 0];
    HEAP8[$0 | 0] = $3;
    if (!$3) {
     break label$1;
    }
    $0 = $0 + 1 | 0;
    $1 = $1 + 1 | 0;
    $2 = $2 - 1 | 0;
    if ($2) {
     continue;
    }
    break;
   }
  }
  $2 = 0;
 }
 memset($0, 0, $2);
}

function progressSequence($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (HEAPU8[$0 + 48 | 0]) {
  $2 = HEAP32[$0 + 32 >> 2];
  $5 = $2;
  $3 = HEAP32[$0 + 36 >> 2];
  $2 = $3;
  if (HEAPU8[$0 + 49 | 0]) {
   $3 = $2;
   if ($3 | $5) {
    $1 = $5;
    $4 = $1 - 1 | 0;
    HEAP32[$0 + 32 >> 2] = $4;
    HEAP32[$0 + 36 >> 2] = $2 - !$1;
    $1 = HEAP32[$0 + 44 >> 2];
    $6 = $1;
    $3 = HEAP32[$0 + 40 >> 2];
    $1 = HEAP32[$0 + 16 >> 2];
    $5 = $1;
    $2 = $3 - $1 | 0;
    $1 = HEAP32[$0 + 20 >> 2];
    $4 = $1 + ($3 >>> 0 < $5 >>> 0) | 0;
    $4 = $6 - $4 | 0;
    HEAP32[$0 + 40 >> 2] = $2;
    HEAP32[$0 + 44 >> 2] = $4;
    return;
   }
   HEAP8[$0 + 48 | 0] = 0;
   return;
  }
  $4 = HEAP32[$0 + 24 >> 2];
  $1 = $4;
  $3 = HEAP32[$0 + 28 >> 2];
  $4 = $2;
  if (($3 | 0) == ($4 | 0) & $1 >>> 0 > $5 >>> 0 | $3 >>> 0 > $4 >>> 0) {
   $1 = $5 + 1 | 0;
   $2 = $1 ? $2 : $2 + 1 | 0;
   HEAP32[$0 + 32 >> 2] = $1;
   HEAP32[$0 + 36 >> 2] = $2;
   $2 = HEAP32[$0 + 40 >> 2];
   $3 = $2;
   $5 = HEAP32[$0 + 44 >> 2];
   $1 = $5;
   $2 = HEAP32[$0 + 20 >> 2];
   $6 = $2;
   $5 = HEAP32[$0 + 16 >> 2];
   $4 = $5;
   $3 = $3 + $4 | 0;
   $2 = $1;
   $5 = $6;
   $1 = $2 + $5 | 0;
   HEAP32[$0 + 40 >> 2] = $3;
   $1 = $3 >>> 0 < $4 >>> 0 ? $1 + 1 | 0 : $1;
   HEAP32[$0 + 44 >> 2] = $1;
   return;
  }
  HEAP8[$0 + 48 | 0] = 0;
 }
}

function sqlite3VtabEponymousTableInit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$1 >> 2];
 HEAP32[$4 + 12 >> 2] = 0;
 $6 = 1;
 label$1: {
  if (HEAP32[$1 + 20 >> 2]) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  $2 = HEAP32[$5 + 4 >> 2];
  if ($2) {
   $6 = 0;
   if (HEAP32[$5 + 8 >> 2] != ($2 | 0)) {
    break label$1;
   }
  }
  $6 = 0;
  $2 = sqlite3DbMallocZero($3, 64, 0);
  if (!$2) {
   break label$1;
  }
  $7 = sqlite3DbStrDup($3, HEAP32[$1 + 4 >> 2]);
  HEAP32[$2 >> 2] = $7;
  if (!$7) {
   sqlite3DbFree($3, $2);
   break label$1;
  }
  HEAP32[$1 + 20 >> 2] = $2;
  $6 = 1;
  HEAP8[$2 + 43 | 0] = 1;
  HEAP32[$2 + 24 >> 2] = 1;
  $8 = HEAP32[HEAP32[$3 + 16 >> 2] + 12 >> 2];
  HEAP16[$2 + 32 >> 1] = 65535;
  HEAP32[$2 + 60 >> 2] = $8;
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] | 32768;
  addModuleArgument($0, $2, sqlite3DbStrDup($3, $7));
  addModuleArgument($0, $2, 0);
  addModuleArgument($0, $2, sqlite3DbStrDup($3, HEAP32[$2 >> 2]));
  if (!vtabCallConstructor($3, $2, $1, HEAP32[$5 + 8 >> 2], $4 + 12 | 0)) {
   break label$1;
  }
  $5 = HEAP32[$4 + 12 >> 2];
  HEAP32[$4 >> 2] = $5;
  sqlite3ErrorMsg($0, 8342, $4);
  sqlite3DbFree($3, $5);
  sqlite3VtabEponymousTableClear($3, $1);
 }
 __stack_pointer = $4 + 16 | 0;
 return $6;
}

function sqlite3LocateTable($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$0 >> 2];
 label$1: {
  if (!(HEAPU8[$6 + 24 | 0] & 16)) {
   if (sqlite3ReadSchema($0)) {
    break label$1;
   }
  }
  $4 = sqlite3FindTable($6, $2, $3);
  label$3: {
   if (!$4) {
    label$5: {
     if (HEAPU8[$0 + 25 | 0] | HEAPU8[$6 + 177 | 0]) {
      break label$5;
     }
     $4 = sqlite3HashFind($6 + 384 | 0, $2);
     if (!$4) {
      if (sqlite3_strnicmp($2, 17759, 7)) {
       break label$5;
      }
      $4 = sqlite3PragmaVtabRegister($6, $2);
      if (!$4) {
       break label$5;
      }
     }
     if (!sqlite3VtabEponymousTableInit($0, $4)) {
      break label$5;
     }
     $4 = HEAP32[$4 + 20 >> 2];
     break label$1;
    }
    $4 = 0;
    if ($1 & 2) {
     break label$1;
    }
    HEAP8[$0 + 17 | 0] = 1;
    break label$3;
   }
   if (!HEAPU8[$0 + 25 | 0] | HEAPU8[$4 + 43 | 0] != 1) {
    break label$1;
   }
  }
  $4 = $1 & 1 ? 1729 : 13564;
  label$7: {
   if ($3) {
    HEAP32[$5 + 24 >> 2] = $2;
    HEAP32[$5 + 20 >> 2] = $3;
    HEAP32[$5 + 16 >> 2] = $4;
    sqlite3ErrorMsg($0, 5984, $5 + 16 | 0);
    break label$7;
   }
   HEAP32[$5 + 4 >> 2] = $2;
   HEAP32[$5 >> 2] = $4;
   sqlite3ErrorMsg($0, 7253, $5);
  }
  $4 = 0;
 }
 __stack_pointer = $5 + 32 | 0;
 return $4;
}

function mallocWithAlarm($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = FUNCTION_TABLE[HEAP32[16080]]($0) | 0;
 sqlite3StatusHighwater(5, $0);
 $2 = HEAP32[17619];
 $7 = $2;
 $5 = HEAP32[17618];
 label$1: {
  label$2: {
   if (!$5 & ($2 | 0) <= 0 | ($2 | 0) < 0) {
    break label$2;
   }
   $8 = sqlite3StatusValue();
   $2 = i64toi32_i32$HIGH_BITS;
   $0 = $2;
   $2 = $4 >> 31;
   $9 = $2;
   $2 = $7;
   $3 = ($4 >>> 0 > $5 >>> 0) + $9 | 0;
   $3 = $2 - $3 | 0;
   $6 = $3;
   $3 = $0;
   $2 = $8;
   if (($6 | 0) <= ($3 | 0) & $2 >>> 0 >= $5 - $4 >>> 0 | ($3 | 0) > ($6 | 0)) {
    $0 = 0;
    HEAP32[17622] = 1;
    $3 = HEAP32[17621];
    $7 = $3;
    $2 = HEAP32[17620];
    $5 = $2;
    if (!($3 | $2)) {
     break label$2;
    }
    $3 = sqlite3StatusValue();
    $8 = $3;
    $2 = i64toi32_i32$HIGH_BITS;
    $10 = $2;
    $6 = $4;
    $2 = $7;
    $3 = $9;
    $3 = $2 - ($3 + ($6 >>> 0 > $5 >>> 0) | 0) | 0;
    $2 = $8;
    $6 = $5 - $6 | 0;
    if ($2 >>> 0 < $6 >>> 0 & ($10 | 0) <= ($3 | 0) | ($10 | 0) < ($3 | 0)) {
     break label$2;
    }
    break label$1;
   }
   HEAP32[17622] = 0;
  }
  $0 = 0;
  $4 = FUNCTION_TABLE[HEAP32[16076]]($4) | 0;
  if (!$4) {
   break label$1;
  }
  sqlite3StatusUp(0, sqlite3MallocSize($4));
  sqlite3StatusUp(9, 1);
  $0 = $4;
 }
 HEAP32[$1 >> 2] = $0;
}

function fts3AppendToNode($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 12 >> 2] = 0;
 $10 = HEAP32[$1 + 4 >> 2];
 blobGrowBuffer($1, $3, $8 + 12 | 0);
 $6 = HEAP32[$8 + 12 >> 2];
 label$1: {
  if ($6) {
   break label$1;
  }
  $7 = HEAP32[$1 >> 2];
  $9 = fts3PrefixCompress($7, HEAP32[$1 + 4 >> 2], $2, $3);
  $6 = $3 - $9 | 0;
  if (($6 | 0) <= 0) {
   $6 = 267;
   break label$1;
  }
  __memcpy($7, $2, $3);
  HEAP32[$1 + 4 >> 2] = $3;
  label$3: {
   if (!$10) {
    $1 = HEAP32[$0 + 4 >> 2];
    break label$3;
   }
   $3 = $9;
   $7 = $3 >> 31;
   $1 = sqlite3Fts3PutVarint(HEAP32[$0 >> 2] + HEAP32[$0 + 4 >> 2] | 0, $3, $7) + HEAP32[$0 + 4 >> 2] | 0;
   HEAP32[$0 + 4 >> 2] = $1;
  }
  $1 = sqlite3Fts3PutVarint(HEAP32[$0 >> 2] + $1 | 0, $6, 0) + HEAP32[$0 + 4 >> 2] | 0;
  HEAP32[$0 + 4 >> 2] = $1;
  __memcpy(HEAP32[$0 >> 2] + $1 | 0, $2 + $9 | 0, $6);
  $1 = HEAP32[$0 + 4 >> 2] + $6 | 0;
  HEAP32[$0 + 4 >> 2] = $1;
  $6 = 0;
  if (!$4) {
   break label$1;
  }
  $3 = $5;
  $7 = $3 >> 31;
  $1 = sqlite3Fts3PutVarint(HEAP32[$0 >> 2] + $1 | 0, $3, $7) + HEAP32[$0 + 4 >> 2] | 0;
  HEAP32[$0 + 4 >> 2] = $1;
  __memcpy(HEAP32[$0 >> 2] + $1 | 0, $4, $3);
  HEAP32[$0 + 4 >> 2] = $3 + HEAP32[$0 + 4 >> 2];
 }
 __stack_pointer = $8 + 16 | 0;
 return $6;
}

function computeLimitRegisters($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 label$1: {
  if (HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  $4 = HEAP32[$1 + 60 >> 2];
  if (!$4) {
   break label$1;
  }
  $5 = HEAP32[$0 + 44 >> 2] + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $5;
  HEAP32[$1 + 8 >> 2] = $5;
  $6 = sqlite3GetVdbe($0);
  $3 = HEAP32[$4 + 12 >> 2];
  label$2: {
   if (sqlite3ExprIsInteger($3, $7 + 12 | 0)) {
    $3 = HEAP32[$7 + 12 >> 2];
    sqlite3VdbeAddOp2($6, 71, $3, $5);
    if (!$3) {
     sqlite3VdbeGoto($6, $2);
     break label$2;
    }
    if (($3 | 0) < 0) {
     break label$2;
    }
    $8 = HEAP16[$1 + 2 >> 1];
    $2 = sqlite3LogEst($3, 0);
    if (($8 | 0) <= ($2 | 0)) {
     break label$2;
    }
    HEAP16[$1 + 2 >> 1] = $2;
    HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 16384;
    break label$2;
   }
   sqlite3ExprCode($0, $3, $5);
   sqlite3VdbeAddOp1($6, 12, $5);
   sqlite3VdbeAddOp2($6, 16, $5, $2);
  }
  $2 = HEAP32[$4 + 16 >> 2];
  if (!$2) {
   break label$1;
  }
  $3 = HEAP32[$0 + 44 >> 2];
  $4 = $3 + 1 | 0;
  HEAP32[$1 + 12 >> 2] = $4;
  $1 = $3 + 2 | 0;
  HEAP32[$0 + 44 >> 2] = $1;
  sqlite3ExprCode($0, $2, $4);
  sqlite3VdbeAddOp1($6, 12, $4);
  sqlite3VdbeAddOp3($6, 160, $5, $1, $4);
 }
 __stack_pointer = $7 + 16 | 0;
}

function sqlite3ExprCodeGetColumnOfTable($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 label$1: {
  if (!$1) {
   sqlite3VdbeAddOp3($0, 94, $2, $3, $4);
   break label$1;
  }
  if (!(HEAP16[$1 + 32 >> 1] != ($3 | 0) & ($3 | 0) >= 0)) {
   sqlite3VdbeAddOp2($0, 135, $2, $4);
   break label$1;
  }
  $5 = 175;
  $6 = $3;
  label$5: {
   if (HEAPU8[$1 + 43 | 0] == 1) {
    break label$5;
   }
   $5 = HEAP32[$1 + 4 >> 2] + Math_imul($3, 12) | 0;
   $6 = HEAPU16[$5 + 10 >> 1];
   if ($6 & 32) {
    $3 = sqlite3VdbeParser($0);
    if ($6 & 256) {
     HEAP32[$7 >> 2] = HEAP32[$5 >> 2];
     sqlite3ErrorMsg($3, 28522, $7);
     break label$1;
    }
    $8 = HEAP32[$3 + 52 >> 2];
    $0 = $5 + 10 | 0;
    HEAP16[$0 >> 1] = $6 | 256;
    HEAP32[$3 + 52 >> 2] = $2 + 1;
    sqlite3ExprCodeGeneratedColumn($3, $1, $5, $4);
    HEAP32[$3 + 52 >> 2] = $8;
    HEAP16[$5 + 10 >> 1] = HEAPU16[$5 + 10 >> 1] & 65279;
    break label$1;
   }
   if (HEAPU8[$1 + 28 | 0] & 128) {
    $5 = 94;
    $6 = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex($1), $3 << 16 >> 16);
    break label$5;
   }
   $5 = 94;
   $6 = sqlite3TableColumnToStorage($1, $3 << 16 >> 16);
  }
  sqlite3VdbeAddOp3($0, $5, $2, $6, $4);
  sqlite3ColumnDefault($0, $1, $3, $4);
 }
 __stack_pointer = $7 + 16 | 0;
}

function sqlite3AnalysisLoad($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
 $4 = $3 + 16 | 0;
 while (1) {
  $4 = HEAP32[$4 >> 2];
  if ($4) {
   $2 = HEAP32[$4 + 8 >> 2];
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] & -17;
   continue;
  }
  break;
 }
 $4 = $3 + 32 | 0;
 $2 = $4;
 while (1) {
  $2 = HEAP32[$2 >> 2];
  if ($2) {
   $3 = HEAP32[$2 + 8 >> 2];
   $6 = (HEAPU8[$3 + 55 | 0] | HEAPU8[$3 + 56 | 0] << 8) & 65407;
   HEAP8[$3 + 55 | 0] = $6;
   HEAP8[$3 + 56 | 0] = $6 >>> 8;
   continue;
  }
  break;
 }
 HEAP32[$5 + 8 >> 2] = $0;
 $2 = HEAP32[HEAP32[$0 + 16 >> 2] + ($1 << 4) >> 2];
 HEAP32[$5 + 12 >> 2] = $2;
 $3 = 0;
 $1 = sqlite3FindTable($0, 23100, $2);
 label$5: {
  if (!$1 | HEAPU8[$1 + 43 | 0]) {
   break label$5;
  }
  HEAP32[$5 >> 2] = $2;
  $2 = sqlite3MPrintf($0, 23072, $5);
  if (!$2) {
   $3 = 7;
   break label$5;
  }
  $3 = sqlite3_exec($0, $2, 26, $5 + 8 | 0, 0);
  sqlite3DbFree($0, $2);
 }
 while (1) {
  $4 = HEAP32[$4 >> 2];
  if ($4) {
   $2 = HEAP32[$4 + 8 >> 2];
   if (HEAPU8[$2 + 55 | 0] & 128) {
    continue;
   }
   sqlite3DefaultRowEst($2);
   continue;
  }
  break;
 }
 if (($3 | 0) == 7) {
  sqlite3OomFault($0);
 }
 __stack_pointer = $5 + 16 | 0;
 return $3;
}
function vdbePmaReadVarint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 32 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP32[$0 + 44 >> 2];
 label$1: {
  label$2: {
   if ($2) {
    $2 = sqlite3GetVarint($2 + $7 | 0, $1);
    $5 = HEAP32[$0 + 4 >> 2];
    $3 = HEAP32[$0 >> 2];
    $1 = $3 + $2 | 0;
    HEAP32[$0 >> 2] = $1;
    $5 = $1 >>> 0 < $2 >>> 0 ? $5 + 1 | 0 : $5;
    HEAP32[$0 + 4 >> 2] = $5;
    break label$2;
   }
   $4 = HEAP32[$0 + 40 >> 2];
   $5 = $4 >> 31;
   $2 = $5;
   $5 = $3;
   $3 = $2;
   $3 = __wasm_i64_srem($7, $5, $4, $3);
   $2 = $3;
   if (!(!$2 | ($4 - $2 | 0) < 9)) {
    $2 = sqlite3GetVarint(HEAP32[$0 + 36 >> 2] + $2 | 0, $1);
    $3 = HEAP32[$0 + 4 >> 2];
    $1 = $3;
    $5 = HEAP32[$0 >> 2];
    $3 = $5 + $2 | 0;
    $1 = $3 >>> 0 < $2 >>> 0 ? $1 + 1 | 0 : $1;
    HEAP32[$0 >> 2] = $3;
    HEAP32[$0 + 4 >> 2] = $1;
    break label$2;
   }
   $2 = 0;
   while (1) {
    $4 = vdbePmaReadBlob($0, 1, $6 + 12 | 0);
    if ($4) {
     break label$1;
    }
    $4 = HEAP8[HEAP32[$6 + 12 >> 2]];
    HEAP8[$6 + 16 | $2 & 15] = $4;
    $2 = $2 + 1 | 0;
    if (($4 | 0) < 0) {
     continue;
    }
    break;
   }
   sqlite3GetVarint($6 + 16 | 0, $1);
  }
  $4 = 0;
 }
 __stack_pointer = $6 + 32 | 0;
 return $4;
}

function filterPullDown($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $10 = __stack_pointer - 16 | 0;
 __stack_pointer = $10;
 while (1) {
  $2 = $2 + 1 | 0;
  if (($2 | 0) < HEAPU8[$1 + 48 | 0]) {
   $6 = Math_imul($2, 96) + $1 | 0;
   if (!HEAP32[$6 + 820 >> 2]) {
    continue;
   }
   $7 = HEAP32[$6 + 848 >> 2];
   if (HEAPU16[$7 + 46 >> 1]) {
    continue;
   }
   $8 = HEAP32[$7 >> 2];
   $9 = $8;
   $8 = $5;
   $11 = HEAP32[$7 + 4 >> 2];
   $8 = $8 & $11;
   $11 = $4 & $9;
   if ($8 | $11) {
    continue;
   }
   $8 = $6;
   $9 = $6 + 768 | 0;
   $8 = $6;
   $6 = $6 + 780 | 0;
   HEAP32[$6 >> 2] = $3;
   label$3: {
    if (HEAP8[$7 + 41 | 0] & 1) {
     $7 = codeEqualityTerm($0, HEAP32[HEAP32[$7 + 52 >> 2] >> 2], $9, 0, 0, sqlite3GetTempReg($0));
     sqlite3VdbeAddOp4Int(HEAP32[$0 + 8 >> 2], 63, HEAP32[$8 + 820 >> 2], $3, $7, 1);
     break label$3;
    }
    $7 = HEAPU16[$7 + 24 >> 1];
    $9 = codeAllEqualityTerms($0, $9, 0, 0, $10 + 12 | 0);
    $6 = HEAP32[$10 + 12 >> 2];
    codeApplyAffinity($0, $9, $7, $6);
    sqlite3DbFree(HEAP32[$0 >> 2], $6);
    sqlite3VdbeAddOp4Int(HEAP32[$0 + 8 >> 2], 63, HEAP32[$8 + 820 >> 2], $3, $9, $7);
   }
   HEAP32[$8 + 820 >> 2] = 0;
   HEAP32[$8 + 780 >> 2] = 0;
   continue;
  }
  break;
 }
 __stack_pointer = $10 + 16 | 0;
}

function whereOrInsert($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = HEAPU16[$0 >> 1];
 $6 = $8;
 $10 = $0 + 8 | 0;
 $5 = $10;
 label$1: {
  label$2: {
   while (1) {
    if ($6 & 65535) {
     $7 = HEAP16[$5 + 8 >> 1];
     if (($1 | 0) == ($1 & HEAP32[$5 >> 2]) & (HEAP32[$5 + 4 >> 2] & $2) == ($2 | 0) & ($7 | 0) >= ($3 | 0)) {
      break label$2;
     }
     if (($3 | 0) >= ($7 | 0)) {
      $7 = HEAP32[$5 >> 2];
      $9 = HEAP32[$5 + 4 >> 2];
      if (($7 & $1) == ($7 | 0) & ($2 & $9) == ($9 | 0)) {
       break label$1;
      }
     }
     $5 = $5 + 16 | 0;
     $6 = $6 - 1 | 0;
     continue;
    }
    break;
   }
   if ($8 >>> 0 > 2) {
    $6 = 1;
    $5 = $10;
    while (1) {
     $7 = HEAP16[$5 + 8 >> 1];
     if (($6 | 0) != ($8 | 0)) {
      $9 = $6 << 4;
      $5 = HEAP16[($0 + $9 | 0) + 16 >> 1] < ($7 | 0) ? $9 + $10 | 0 : $5;
      $6 = $6 + 1 | 0;
      continue;
     }
     break;
    }
    if (($3 | 0) >= ($7 | 0)) {
     break label$1;
    }
    break label$2;
   }
   HEAP16[$0 >> 1] = $8 + 1;
   $5 = ($8 << 4) + $0 | 0;
   HEAP16[$5 + 18 >> 1] = $4;
   $5 = $5 + 8 | 0;
  }
  HEAP16[$5 + 8 >> 1] = $3;
  HEAP32[$5 >> 2] = $1;
  HEAP32[$5 + 4 >> 2] = $2;
  if (HEAP16[$5 + 10 >> 1] <= ($4 | 0)) {
   break label$1;
  }
  HEAP16[$5 + 10 >> 1] = $4;
 }
}

function memdbWrite($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $5 = 778;
 $0 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if (HEAPU8[$0 + 36 | 0] & 4) {
   break label$1;
  }
  $5 = ($2 >> 31) + $4 | 0;
  $6 = $2;
  $7 = $3;
  $6 = $6 + $7 | 0;
  $9 = $6;
  $5 = $7 >>> 0 > $9 >>> 0 ? $5 + 1 | 0 : $5;
  $8 = $5;
  $6 = HEAP32[$0 + 4 >> 2];
  $10 = $6;
  $5 = HEAP32[$0 >> 2];
  $11 = $5;
  $7 = $5;
  $6 = $8;
  $5 = $10;
  if ($7 >>> 0 < $9 >>> 0 & ($6 | 0) >= ($5 | 0) | ($5 | 0) < ($6 | 0)) {
   $7 = HEAP32[$0 + 8 >> 2];
   $5 = $9;
   $6 = HEAP32[$0 + 12 >> 2];
   if ($7 >>> 0 < $5 >>> 0 & ($6 | 0) <= ($8 | 0) | ($6 | 0) < ($8 | 0)) {
    $7 = $8;
    $5 = memdbEnlarge($0, $9, $7);
    if ($5) {
     break label$1;
    }
    $7 = HEAP32[$0 >> 2];
    $11 = $7;
    $6 = HEAP32[$0 + 4 >> 2];
    $10 = $6;
   }
   $5 = $3;
   $6 = $4;
   $7 = $10;
   if ($5 >>> 0 > $11 >>> 0 & ($6 | 0) >= ($7 | 0) | ($6 | 0) > ($7 | 0)) {
    $7 = $11;
    memset($7 + HEAP32[$0 + 24 >> 2] | 0, 0, $3 - $7 | 0);
    $5 = $4;
    $6 = $10;
    $6 = $6 + ($3 >>> 0 < $7 >>> 0) | 0;
   }
   HEAP32[$0 >> 2] = $9;
   HEAP32[$0 + 4 >> 2] = $8;
  }
  __memcpy($3 + HEAP32[$0 + 24 >> 2] | 0, $1, $2);
  $5 = 0;
 }
 return $5 | 0;
}

function pager_open_journal($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAP32[$0 + 44 >> 2];
 if (!$1) {
  label$2: {
   if (HEAP32[$0 + 232 >> 2] | HEAPU8[$0 + 5 | 0] == 2) {
    break label$2;
   }
   $2 = HEAP32[$0 >> 2];
   $1 = sqlite3BitvecCreate(HEAP32[$0 + 28 >> 2]);
   HEAP32[$0 + 60 >> 2] = $1;
   if (!$1) {
    return 7;
   }
   $1 = HEAP32[$0 + 68 >> 2];
   label$4: {
    label$5: {
     if (HEAP32[$1 >> 2]) {
      break label$5;
     }
     if (HEAPU8[$0 + 5 | 0] == 4) {
      sqlite3MemJournalOpen($1);
      break label$5;
     }
     $3 = HEAP32[16075];
     $4 = HEAPU8[$0 + 12 | 0];
     $1 = databaseIsUnmoved($0);
     if ($1) {
      break label$4;
     }
     $1 = $4;
     $1 = sqlite3JournalOpen($2, HEAP32[$0 + 188 >> 2], HEAP32[$0 + 68 >> 2], $1 ? 4110 : 2054, $1 ? $3 : 0);
     if ($1) {
      break label$4;
     }
    }
    HEAP32[$0 + 80 >> 2] = 0;
    HEAP32[$0 + 84 >> 2] = 0;
    HEAP8[$0 + 20 | 0] = 0;
    HEAP32[$0 + 48 >> 2] = 0;
    HEAP32[$0 + 88 >> 2] = 0;
    HEAP32[$0 + 92 >> 2] = 0;
    $1 = writeJournalHdr($0);
    if (!$1) {
     break label$2;
    }
   }
   sqlite3BitvecDestroy(HEAP32[$0 + 60 >> 2]);
   HEAP32[$0 + 80 >> 2] = 0;
   HEAP32[$0 + 84 >> 2] = 0;
   HEAP32[$0 + 60 >> 2] = 0;
   return $1;
  }
  HEAP8[$0 + 17 | 0] = 3;
  $1 = 0;
 }
 return $1;
}

function sqlite3VdbeRecordUnpack($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP8[$3 + 22 | 0] = 0;
 $4 = HEAP32[$3 + 4 >> 2];
 $5 = HEAP8[$2 | 0];
 label$1: {
  if (($5 | 0) >= 0) {
   $9 = $5 & 255;
   HEAP32[$6 + 12 >> 2] = $9;
   $8 = 1;
   break label$1;
  }
  $8 = sqlite3GetVarint32($2, $6 + 12 | 0);
  $9 = HEAP32[$6 + 12 >> 2];
 }
 $5 = $9;
 while (1) {
  if (!($1 >>> 0 < $5 >>> 0 | $8 >>> 0 >= $9 >>> 0)) {
   $10 = $2 + $8 | 0;
   $7 = HEAP8[$10 | 0];
   label$5: {
    if (($7 | 0) >= 0) {
     $12 = 1;
     $7 = $7 & 255;
     break label$5;
    }
    $12 = sqlite3GetVarint32($10, $6 + 8 | 0);
    $7 = HEAP32[$6 + 8 >> 2];
   }
   HEAP8[$4 + 18 | 0] = HEAPU8[$0 + 4 | 0];
   $10 = HEAP32[$0 + 12 >> 2];
   HEAP32[$4 + 24 >> 2] = 0;
   HEAP32[$4 + 20 >> 2] = $10;
   HEAP32[$4 + 8 >> 2] = 0;
   sqlite3VdbeSerialGet($2 + $5 | 0, $7, $4);
   $4 = $4 + 40 | 0;
   $8 = $8 + $12 | 0;
   $5 = sqlite3VdbeSerialTypeLen($7) + $5 | 0;
   $11 = $11 + 1 | 0;
   if (HEAPU16[$3 + 20 >> 1] > ($11 & 65535) >>> 0) {
    continue;
   }
  }
  break;
 }
 if (!(!($11 & 65535) | $1 >>> 0 >= $5 >>> 0)) {
  sqlite3VdbeMemSetNull($4 - 40 | 0);
 }
 HEAP16[$3 + 20 >> 1] = $11;
 __stack_pointer = $6 + 16 | 0;
}

function allocateCursor($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = HEAP32[$0 + 88 >> 2];
 $5 = ($1 | 0) > 0 ? Math_imul(HEAP32[$0 + 20 >> 2] - $1 | 0, 40) + $5 | 0 : $5;
 $7 = ($2 << 3) + 88 | 0;
 $6 = $7 + ($3 ? 0 : 200) | 0;
 $4 = $1 << 2;
 $8 = HEAP32[$4 + HEAP32[$0 + 96 >> 2] >> 2];
 if ($8) {
  sqlite3VdbeFreeCursorNN($0, $8);
  HEAP32[HEAP32[$0 + 96 >> 2] + $4 >> 2] = 0;
 }
 $4 = HEAP32[$5 + 24 >> 2];
 label$3: {
  if (($6 | 0) <= ($4 | 0)) {
   $4 = HEAP32[$5 + 32 >> 2];
   break label$3;
  }
  if (($4 | 0) > 0) {
   sqlite3DbFreeNN(HEAP32[$5 + 20 >> 2], HEAP32[$5 + 32 >> 2]);
  }
  $4 = sqlite3DbMallocRaw(HEAP32[$5 + 20 >> 2], $6, $6 >> 31);
  HEAP32[$5 + 8 >> 2] = $4;
  HEAP32[$5 + 32 >> 2] = $4;
  if (!$4) {
   HEAP32[$5 + 24 >> 2] = 0;
   return 0;
  }
  HEAP32[$5 + 24 >> 2] = $6;
 }
 HEAP32[HEAP32[$0 + 96 >> 2] + ($1 << 2) >> 2] = $4;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = 0;
 HEAP32[$4 + 28 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 HEAP32[$4 + 12 >> 2] = 0;
 HEAP32[$4 + 64 >> 2] = (($2 << 2) + $4 | 0) + 80;
 HEAP16[$4 + 52 >> 1] = $2;
 HEAP8[$4 | 0] = $3;
 if (!$3) {
  $5 = HEAP32[$5 + 8 >> 2] + $7 | 0;
  HEAP32[$4 + 36 >> 2] = $5;
  sqlite3BtreeCursorZero($5);
 }
 return $4;
}

function statGet($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 $2 = sqlite3_value_blob(HEAP32[$2 >> 2]);
 sqlite3StrAccumInit($3 + 24 | 0, 0, 0, 0, Math_imul(HEAP32[$2 + 20 >> 2], 100) + 100 | 0);
 $6 = (HEAPU8[$2 + 24 | 0] ? 4 : 8) + $2 | 0;
 HEAP32[$3 + 16 >> 2] = HEAP32[$6 >> 2];
 HEAP32[$3 + 20 >> 2] = 0;
 sqlite3_str_appendf($3 + 24 | 0, 1843, $3 + 16 | 0);
 while (1) {
  if (($8 | 0) < HEAP32[$2 + 20 >> 2]) {
   $4 = 0;
   $6 = HEAP32[HEAP32[$2 + 32 >> 2] + ($8 << 2) >> 2] + 1 | 0;
   $7 = HEAP32[$2 + 8 >> 2];
   $1 = $6 + $7 | 0;
   $5 = $1;
   $4 = $1 >>> 0 < $7 >>> 0 ? 1 : $4;
   $1 = !$1;
   $1 = $4 - $1 | 0;
   $5 = __wasm_i64_udiv($5 - 1 | 0, $1, $6, 0);
   $4 = $5;
   $1 = i64toi32_i32$HIGH_BITS;
   $5 = $1;
   if (!$1 & ($4 | 0) == 2) {
    $1 = __wasm_i64_mul($6, 0, 11, 0);
    $5 = $1;
    $4 = i64toi32_i32$HIGH_BITS;
    $1 = $4;
    $7 = Math_imul($7, 10);
    $6 = !$1 & $5 >>> 0 < $7 >>> 0;
    $1 = $6 ? 2 : 1;
    $4 = $1;
    $5 = 0;
   }
   HEAP32[$3 >> 2] = $4;
   HEAP32[$3 + 4 >> 2] = $5;
   sqlite3_str_appendf($3 + 24 | 0, 1842, $3);
   $8 = $8 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3ResultStrAccum($0, $3 + 24 | 0);
 __stack_pointer = $3 + 48 | 0;
}

function charFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = $1 << 2 | 1;
 $3 = $4 >> 31;
 $5 = sqlite3_malloc64($4, $3);
 if ($5) {
  $7 = ($1 | 0) > 0 ? $1 : 0;
  $1 = $5;
  while (1) {
   if (($6 | 0) != ($7 | 0)) {
    $3 = sqlite3_value_int64(HEAP32[($6 << 2) + $2 >> 2]);
    $4 = i64toi32_i32$HIGH_BITS;
    $3 = !$4 & $3 >>> 0 > 1114111 | $4 ? 65533 : $3 & 2097151;
    label$4: {
     if ($3 >>> 0 <= 127) {
      HEAP8[$1 | 0] = $3;
      $1 = $1 + 1 | 0;
      break label$4;
     }
     if ($3 >>> 0 <= 2047) {
      HEAP8[$1 + 1 | 0] = $3 & 63 | 128;
      HEAP8[$1 | 0] = $3 >>> 6 | 192;
      $1 = $1 + 2 | 0;
      break label$4;
     }
     if ($3 >>> 0 <= 65535) {
      HEAP8[$1 + 2 | 0] = $3 & 63 | 128;
      HEAP8[$1 | 0] = $3 >>> 12 | 224;
      HEAP8[$1 + 1 | 0] = $3 >>> 6 & 63 | 128;
      $1 = $1 + 3 | 0;
      break label$4;
     }
     HEAP8[$1 + 3 | 0] = $3 & 63 | 128;
     HEAP8[$1 | 0] = $3 >>> 18 | 240;
     HEAP8[$1 + 2 | 0] = $3 >>> 6 & 63 | 128;
     HEAP8[$1 + 1 | 0] = $3 >>> 12 & 63 | 128;
     $1 = $1 + 4 | 0;
    }
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = $1 - $5 | 0;
  $3 = $4 >> 31;
  sqlite3_result_text64($0, $5, $4, $3, 3, 1);
  return;
 }
 sqlite3_result_error_nomem($0);
}

function __lshrti3($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 label$1: {
  if ($5 & 64) {
   $7 = $4;
   $8 = $3;
   $9 = $5 + -64 | 0;
   $6 = $9 & 31;
   if (($9 & 63) >>> 0 >= 32) {
    $1 = $7 >>> $6 | 0;
   } else {
    $10 = $7 >>> $6 | 0;
    $1 = ((1 << $6) - 1 & $7) << 32 - $6 | $8 >>> $6;
   }
   $2 = $10;
   $3 = 0;
   $4 = 0;
   break label$1;
  }
  if (!$5) {
   break label$1;
  }
  $10 = $4;
  $7 = $3;
  $9 = 64 - $5 | 0;
  $6 = $9 & 31;
  if (($9 & 63) >>> 0 >= 32) {
   $8 = $7 << $6;
   $11 = 0;
  } else {
   $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $10 << $6;
   $11 = $7 << $6;
  }
  $12 = $8;
  $8 = $2;
  $10 = $1;
  $7 = 0;
  $9 = $5;
  $6 = $9 & 31;
  if (($9 & 63) >>> 0 >= 32) {
   $9 = $8 >>> $6 | 0;
  } else {
   $7 = $8 >>> $6 | 0;
   $9 = ((1 << $6) - 1 & $8) << 32 - $6 | $10 >>> $6;
  }
  $10 = $7;
  $8 = $11;
  $1 = $8 | $9;
  $7 = $12;
  $10 = $7 | $10;
  $2 = $10;
  $10 = $4;
  $7 = $3;
  $8 = 0;
  $9 = $5;
  $6 = $9 & 31;
  if (($9 & 63) >>> 0 >= 32) {
   $3 = $10 >>> $6 | 0;
  } else {
   $8 = $10 >>> $6 | 0;
   $3 = ((1 << $6) - 1 & $10) << 32 - $6 | $7 >>> $6;
  }
  $4 = $8;
 }
 $7 = $0;
 HEAP32[$7 >> 2] = $1;
 $8 = $2;
 HEAP32[$7 + 4 >> 2] = $8;
 HEAP32[$7 + 8 >> 2] = $3;
 $8 = $4;
 HEAP32[$7 + 12 >> 2] = $8;
}

function unicodeCreate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = sqlite3_malloc(16);
 if (!$3) {
  return 7;
 }
 HEAP32[$3 >> 2] = 0;
 HEAP32[$3 + 4 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 4 >> 2] = 1;
 while (1) {
  if (!(($0 | 0) <= ($7 | 0) | $4)) {
   $5 = HEAP32[($7 << 2) + $1 >> 2];
   $6 = strlen($5);
   label$4: {
    label$5: {
     if (($6 | 0) == 19) {
      if (!memcmp(23122, $5, 19)) {
       HEAP32[$3 + 4 >> 2] = 1;
       $4 = 0;
       break label$4;
      }
      if (!memcmp(23731, $5, 19)) {
       HEAP32[$3 + 4 >> 2] = 0;
       $4 = 0;
       break label$4;
      }
      if (memcmp(22940, $5, 19)) {
       break label$5;
      }
      HEAP32[$3 + 4 >> 2] = 2;
      $4 = 0;
      break label$4;
     }
     $4 = 1;
     if (($6 | 0) < 11) {
      break label$4;
     }
    }
    if (!memcmp(21240, $5, 11)) {
     $4 = unicodeAddExceptions($3, 1, $5 + 11 | 0, $6 - 11 | 0);
     break label$4;
    }
    $4 = 1;
    if (memcmp(21228, $5, 11)) {
     break label$4;
    }
    $4 = unicodeAddExceptions($3, 0, $5 + 11 | 0, $6 - 11 | 0);
   }
   $7 = $7 + 1 | 0;
   continue;
  }
  break;
 }
 if ($4) {
  unicodeDestroy($3);
  $3 = 0;
 }
 HEAP32[$2 >> 2] = $3;
 return $4 | 0;
}

function sqlite3_file_control($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $1 = sqlite3DbNameToBtree($0, $1);
 if (!$1) {
  return 1;
 }
 sqlite3BtreeEnter($1);
 $4 = sqlite3BtreePager($1);
 $5 = sqlite3PagerFile($4);
 label$2: {
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      switch ($2 - 27 | 0) {
      default:
       label$9: {
        switch ($2 - 35 | 0) {
        case 1:
        case 2:
         break label$3;

        case 3:
         break label$4;

        case 0:
         break label$5;

        default:
         break label$9;
        }
       }
       if (($2 | 0) != 7) {
        break label$3;
       }
       HEAP32[$3 >> 2] = $5;
       return 0;

      case 0:
       HEAP32[$3 >> 2] = sqlite3PagerVfs($4);
       return 0;

      case 1:
       break label$6;
      }
     }
     HEAP32[$3 >> 2] = sqlite3PagerJrnlFile($4);
     return 0;
    }
    HEAP32[$3 >> 2] = sqlite3PagerDataVersion($4);
    return 0;
   }
   $2 = HEAP32[$3 >> 2];
   HEAP32[$3 >> 2] = sqlite3BtreeGetRequestedReserve($1);
   $0 = 0;
   if ($2 >>> 0 > 255) {
    break label$2;
   }
   sqlite3BtreeSetPageSize($1, 0, $2, 0);
   return 0;
  }
  $6 = $0;
  $1 = $0 + 452 | 0;
  $4 = HEAP32[$1 >> 2];
  $0 = sqlite3OsFileControl($5, $2, $3);
  HEAP32[$6 + 452 >> 2] = $4;
 }
 return $0;
}

function sqlite3FkOldmask($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1: {
  if (HEAPU8[$1 + 43 | 0] | !(HEAPU8[HEAP32[$0 >> 2] + 33 | 0] & 64)) {
   break label$1;
  }
  $2 = $1 + 48 | 0;
  while (1) {
   $3 = HEAP32[$2 >> 2];
   if ($3) {
    $2 = 0;
    $4 = HEAP32[$3 + 20 >> 2];
    $8 = ($4 | 0) > 0 ? $4 : 0;
    while (1) {
     if (($2 | 0) != ($8 | 0)) {
      $4 = HEAP32[(($2 << 3) + $3 | 0) + 36 >> 2];
      $6 = (($4 | 0) > 31 ? -1 : 1 << $4) | $6;
      $2 = $2 + 1 | 0;
      continue;
     }
     break;
    }
    $2 = $3 + 4 | 0;
    continue;
   }
   break;
  }
  $7 = sqlite3FkReferences($1);
  while (1) {
   if (!$7) {
    break label$1;
   }
   HEAP32[$5 + 12 >> 2] = 0;
   sqlite3FkLocateIndex($0, $1, $7, $5 + 12 | 0, 0);
   label$7: {
    $3 = HEAP32[$5 + 12 >> 2];
    if (!$3) {
     break label$7;
    }
    $8 = HEAPU16[$3 + 50 >> 1];
    $2 = 0;
    while (1) {
     if (($2 | 0) == ($8 | 0)) {
      break label$7;
     }
     $4 = HEAPU16[HEAP32[$3 + 4 >> 2] + ($2 << 1) >> 1];
     $6 = ($4 << 16 >> 16 > 31 ? -1 : 1 << $4) | $6;
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   $7 = HEAP32[$7 + 12 >> 2];
   continue;
  }
 }
 __stack_pointer = $5 + 16 | 0;
 return $6;
}

function fts3EvalTokenCosts($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0;
 while (1) {
  label$2: {
   if (HEAP32[$5 >> 2]) {
    break label$2;
   }
   label$3: {
    switch (HEAP32[$2 >> 2] - 2 | 0) {
    case 3:
     $6 = HEAP32[$2 + 20 >> 2];
     $2 = 0;
     $4 = 0;
     while (1) {
      if (HEAP32[$6 + 64 >> 2] <= ($4 | 0) | $2) {
       break label$2;
      }
      $2 = HEAP32[$3 >> 2];
      HEAP32[$3 >> 2] = $2 + 24;
      HEAP32[$2 + 12 >> 2] = $1;
      HEAP32[$2 + 4 >> 2] = $4;
      HEAP32[$2 >> 2] = $6;
      $7 = Math_imul($4, 24) + $6 | 0;
      HEAP32[$2 + 8 >> 2] = $7 + 72;
      HEAP32[$2 + 20 >> 2] = HEAP32[$6 + 68 >> 2];
      $2 = sqlite3Fts3MsrOvfl($0, HEAP32[$7 + 92 >> 2], $2 + 16 | 0);
      HEAP32[$5 >> 2] = $2;
      $4 = $4 + 1 | 0;
      continue;
     }
     ;

    case 2:
     $1 = HEAP32[$2 + 12 >> 2];
     HEAP32[HEAP32[$4 >> 2] >> 2] = $1;
     HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + 4;
     break;

    case 0:
     break label$2;

    default:
     break label$3;
    }
   }
   fts3EvalTokenCosts($0, $1, HEAP32[$2 + 12 >> 2], $3, $4, $5);
   if (HEAP32[$2 >> 2] == 4) {
    $1 = HEAP32[$2 + 16 >> 2];
    HEAP32[HEAP32[$4 >> 2] >> 2] = $1;
    HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + 4;
   }
   $2 = HEAP32[$2 + 16 >> 2];
   continue;
  }
  break;
 }
}

function btreePrevious($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAPU8[$0 | 0];
 label$1: {
  label$2: {
   if (!$1) {
    break label$2;
   }
   if ($1 >>> 0 >= 3) {
    $2 = btreeRestoreCursorPosition($0);
    if ($2) {
     break label$1;
    }
    $1 = HEAPU8[$0 | 0];
   }
   $2 = 101;
   label$4: {
    switch (($1 & 255) - 1 | 0) {
    case 0:
     break label$1;

    case 1:
     break label$4;

    default:
     break label$2;
    }
   }
   $2 = 0;
   HEAP8[$0 | 0] = 0;
   if (HEAP32[$0 + 4 >> 2] < 0) {
    break label$1;
   }
  }
  $1 = HEAP32[$0 + 116 >> 2];
  if (!HEAPU8[$1 + 8 | 0]) {
   $2 = HEAP32[$1 + 64 >> 2] + (HEAPU16[$0 + 70 >> 1] << 1) | 0;
   $2 = moveToChild($0, sqlite3Get4byte(HEAP32[$1 + 56 >> 2] + (HEAPU16[$1 + 26 >> 1] & (HEAPU8[$2 | 0] << 8 | HEAPU8[$2 + 1 | 0])) | 0));
   if ($2) {
    break label$1;
   }
   return moveToRightmost($0);
  }
  label$6: {
   while (1) {
    $1 = HEAPU16[$0 + 70 >> 1];
    if ($1) {
     break label$6;
    }
    if (HEAPU8[$0 + 68 | 0]) {
     moveToParent($0);
     continue;
    }
    break;
   }
   HEAP8[$0 | 0] = 1;
   return 101;
  }
  HEAP16[$0 + 70 >> 1] = $1 - 1;
  $2 = 0;
  $1 = HEAP32[$0 + 116 >> 2];
  if (!HEAPU8[$1 + 1 | 0] | HEAPU8[$1 + 8 | 0]) {
   break label$1;
  }
  $2 = sqlite3BtreePrevious($0);
 }
 return $2;
}

function differenceFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (($1 | 0) == 2) {
  label$2: {
   label$3: {
    if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
     if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
      break label$3;
     }
    }
    sqlite3_result_null($0);
    break label$2;
   }
   $1 = sqlite3_value_text(HEAP32[$2 >> 2]);
   $2 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
   soundex($1, $3 + 8 | 0);
   soundex($2, $3);
   $2 = $3 + 8 | 0;
   $4 = $3;
   while (1) {
    if (($5 | 0) != 4) {
     $8 = (sqlite3ReadUtf8($2) | 0) == (sqlite3ReadUtf8($4) | 0);
     while (1) {
      $1 = HEAPU8[$2 + 1 | 0];
      $6 = $2 + 1 | 0;
      $2 = $6;
      if (($1 & 192) == 128) {
       continue;
      }
      break;
     }
     $2 = $4;
     while (1) {
      $1 = HEAPU8[$2 + 1 | 0];
      $4 = $2 + 1 | 0;
      $2 = $4;
      if (($1 & 192) == 128) {
       continue;
      }
      break;
     }
     $5 = $5 + 1 | 0;
     $7 = $7 + $8 | 0;
     $2 = $6;
     continue;
    }
    break;
   }
   sqlite3_result_int($0, $7);
  }
  __stack_pointer = $3 + 16 | 0;
  return;
 }
 __assert_fail(23018, 17353, 1680, 17253);
 abort();
}

function jsonEachBestIndex($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 8 >> 2] = -1;
 HEAP32[$4 + 12 >> 2] = -1;
 $3 = HEAP32[$1 >> 2];
 $5 = ($3 | 0) > 0 ? $3 : 0;
 $3 = HEAP32[$1 + 4 >> 2];
 while (1) {
  if (($2 | 0) != ($5 | 0)) {
   $0 = HEAP32[$3 >> 2];
   label$3: {
    if (($0 | 0) < 8) {
     break label$3;
    }
    $6 = $0 - 8 | 0;
    $0 = 1 << $6;
    if (!HEAPU8[$3 + 5 | 0]) {
     $7 = $0 | $7;
     break label$3;
    }
    if (HEAPU8[$3 + 4 | 0] != 2) {
     break label$3;
    }
    HEAP32[($4 + 8 | 0) + ($6 << 2) >> 2] = $2;
    $8 = $0 | $8;
   }
   $3 = $3 + 12 | 0;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 $3 = 19;
 if (!(($8 ^ -1) & $7)) {
  $3 = 0;
  $0 = HEAP32[$4 + 8 >> 2];
  $2 = 0;
  label$6: {
   if (($0 | 0) < 0) {
    break label$6;
   }
   HEAP32[$1 + 40 >> 2] = 0;
   HEAP32[$1 + 44 >> 2] = 1072693248;
   $5 = HEAP32[$1 + 16 >> 2];
   $0 = $5 + ($0 << 3) | 0;
   HEAP8[$0 + 4 | 0] = 1;
   HEAP32[$0 >> 2] = 1;
   $0 = HEAP32[$4 + 12 >> 2];
   $2 = 1;
   if (($0 | 0) < 0) {
    break label$6;
   }
   $2 = ($0 << 3) + $5 | 0;
   HEAP8[$2 + 4 | 0] = 1;
   HEAP32[$2 >> 2] = 2;
   $2 = 3;
  }
  HEAP32[$1 + 20 >> 2] = $2;
 }
 return $3 | 0;
}

function fts3IncrmergeCsr($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = 0;
 $7 = memset($4, 0, 56);
 $5 = $3 << 2;
 $4 = sqlite3_malloc64($5, 0);
 HEAP32[$7 >> 2] = $4;
 label$1: {
  if (!$4) {
   $4 = 7;
   break label$1;
  }
  memset($4, 0, $5);
  $4 = fts3SqlStmt($0, 12, $6 + 12 | 0, 0);
  if ($4) {
   break label$1;
  }
  $4 = HEAP32[$6 + 12 >> 2];
  sqlite3_bind_int64($4, 1, $1, $2);
  $0 = 0;
  $5 = 0;
  while (1) {
   label$4: {
    if ($5) {
     break label$4;
    }
    if ((sqlite3_step($4) | 0) != 100 | ($0 | 0) >= ($3 | 0)) {
     break label$4;
    }
    $5 = sqlite3Fts3SegReaderNew($0, 0, sqlite3_column_int64($4, 1), i64toi32_i32$HIGH_BITS, sqlite3_column_int64($4, 2), i64toi32_i32$HIGH_BITS, sqlite3_column_int64($4, 3), i64toi32_i32$HIGH_BITS, sqlite3_column_blob($4, 4), sqlite3_column_bytes($4, 4), HEAP32[$7 >> 2] + ($0 << 2) | 0);
    HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] + 1;
    $0 = $0 + 1 | 0;
    continue;
   }
   break;
  }
  $4 = (wasm2js_i32$0 = $5, wasm2js_i32$1 = sqlite3_reset($4), wasm2js_i32$2 = $5, 
  wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
 }
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function fts3DeleteTerms($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 12 >> 2] = $2;
 if (!HEAP32[$0 >> 2]) {
  $6 = fts3SqlStmt($1, 7, $7 + 8 | 0, $7 + 12 | 0);
  $5 = HEAP32[$7 + 8 >> 2];
  label$2: {
   if (!$6) {
    if ((sqlite3_step($5) | 0) == 100) {
     $9 = langidFromSelect($1, $5);
     $6 = fts3PendingTermsDocid($1, 1, $9, sqlite3_column_int64($5, 0), i64toi32_i32$HIGH_BITS);
     $2 = 1;
     label$5: {
      while (1) {
       if (!$6) {
        if (HEAP32[$1 + 24 >> 2] < ($2 | 0)) {
         break label$5;
        }
        $6 = 0;
        $8 = $2 - 1 | 0;
        if (!HEAPU8[$8 + HEAP32[$1 + 32 >> 2] | 0]) {
         $6 = fts3PendingTermsAdd($1, $9, sqlite3_column_text($5, $2), -1, ($8 << 2) + $3 | 0);
         $8 = sqlite3_column_bytes($5, $2);
         $10 = (HEAP32[$1 + 24 >> 2] << 2) + $3 | 0;
         HEAP32[$10 >> 2] = HEAP32[$10 >> 2] + $8;
        }
        $2 = $2 + 1 | 0;
        continue;
       }
       break;
      }
      sqlite3_reset($5);
      break label$2;
     }
     HEAP32[$4 >> 2] = 1;
    }
    $6 = sqlite3_reset($5);
    break label$2;
   }
   sqlite3_reset($5);
  }
  HEAP32[$0 >> 2] = $6;
 }
 __stack_pointer = $7 + 16 | 0;
}

function createCollation($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = 2;
 label$1: {
  label$2: {
   $6 = $2 - 4 | 0;
   switch ($6 | 0) {
   case 0:
   case 4:
    break label$1;

   default:
    break label$2;
   }
  }
  $7 = $2;
  if ($6 >>> 0 > 4294967292) {
   break label$1;
  }
  return sqlite3MisuseError(173386);
 }
 label$3: {
  $8 = sqlite3FindCollSeq($0, $7, $1, 0);
  if (!$8 | !HEAP32[$8 + 12 >> 2]) {
   break label$3;
  }
  if (HEAP32[$0 + 184 >> 2]) {
   sqlite3ErrorWithMsg($0, 5, 3821, 0);
   return 5;
  }
  sqlite3ExpirePreparedStatements($0, 0);
  if ((HEAPU8[$8 + 4 | 0] & 247) != ($7 | 0)) {
   break label$3;
  }
  $11 = sqlite3HashFind($0 + 428 | 0, $1);
  $6 = 0;
  while (1) {
   if (($6 | 0) == 3) {
    break label$3;
   }
   $9 = Math_imul($6, 20) + $11 | 0;
   if (HEAPU8[$9 + 4 | 0] == HEAPU8[$8 + 4 | 0]) {
    $10 = HEAP32[$9 + 16 >> 2];
    if ($10) {
     FUNCTION_TABLE[$10 | 0](HEAP32[$9 + 8 >> 2]);
    }
    HEAP32[$9 + 12 >> 2] = 0;
   }
   $6 = $6 + 1 | 0;
   continue;
  }
 }
 $6 = sqlite3FindCollSeq($0, $7, $1, 1);
 if (!$6) {
  return 7;
 }
 HEAP32[$6 + 16 >> 2] = $5;
 HEAP32[$6 + 8 >> 2] = $3;
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP8[$6 + 4 | 0] = $2 & 8 | $7;
 sqlite3Error($0, 0);
 return 0;
}

function jsonSetFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 $6 = sqlite3_user_data($0);
 label$1: {
  if (($1 | 0) <= 0) {
   break label$1;
  }
  if (!($1 & 1)) {
   jsonWrongNumArgs($0, $6 ? 3160 : 2325);
   break label$1;
  }
  if (jsonParse($3 + 16 | 0, $0, sqlite3_value_text(HEAP32[$2 >> 2]))) {
   break label$1;
  }
  $4 = 1;
  label$3: {
   while (1) {
    if ($1 >>> 0 > $4 >>> 0) {
     $5 = sqlite3_value_text(HEAP32[($4 << 2) + $2 >> 2]);
     HEAP32[$3 + 12 >> 2] = 0;
     $5 = jsonLookup($3 + 16 | 0, $5, $3 + 12 | 0, $0);
     if (HEAPU8[$3 + 36 | 0]) {
      sqlite3_result_error_nomem($0);
      break label$3;
     }
     if (HEAPU8[$3 + 37 | 0]) {
      break label$3;
     }
     if (!(!$5 | !($6 ? 1 : HEAP32[$3 + 12 >> 2]))) {
      HEAP32[$5 + 8 >> 2] = $4 + 1;
      HEAP8[$5 + 1 | 0] = HEAPU8[$5 + 1 | 0] | 8;
     }
     $4 = $4 + 2 | 0;
     continue;
    }
    break;
   }
   $4 = HEAP32[$3 + 24 >> 2];
   if (HEAPU8[$4 + 1 | 0] & 8) {
    sqlite3_result_value($0, HEAP32[(HEAP32[$4 + 8 >> 2] << 2) + $2 >> 2]);
    break label$3;
   }
   jsonReturnJson($4, $0, $2);
  }
  jsonParseReset($3 + 16 | 0);
 }
 __stack_pointer = $3 + 48 | 0;
}

function whereLoopFindLesser($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 while (1) {
  label$2: {
   $2 = HEAP32[$0 >> 2];
   if (!$2) {
    break label$2;
   }
   label$3: {
    if (HEAPU8[$2 + 16 | 0] != HEAPU8[$1 + 16 | 0] | HEAPU8[$2 + 17 | 0] != HEAPU8[$1 + 17 | 0]) {
     break label$3;
    }
    if (!(HEAPU16[$1 + 46 >> 1] | !(HEAPU8[$2 + 41 | 0] & 64) | (HEAP32[$1 + 40 >> 2] & 513) != 513)) {
     $3 = HEAP32[$1 >> 2];
     $4 = HEAP32[$1 + 4 >> 2];
     if (($3 & HEAP32[$2 >> 2]) == ($3 | 0) & ($4 & HEAP32[$2 + 4 >> 2]) == ($4 | 0)) {
      break label$2;
     }
    }
    $5 = HEAP32[$1 + 4 >> 2];
    $4 = HEAP32[$2 + 4 >> 2];
    $6 = $5 & $4;
    $3 = HEAP32[$2 >> 2];
    $7 = HEAP32[$1 >> 2];
    $8 = $3 & $7;
    if (!(($8 | 0) != ($3 | 0) | ($4 | 0) != ($6 | 0) | HEAP16[$2 + 18 >> 1] > HEAP16[$1 + 18 >> 1] | (HEAP16[$2 + 20 >> 1] > HEAP16[$1 + 20 >> 1] | HEAP16[$2 + 22 >> 1] > HEAP16[$1 + 22 >> 1]))) {
     $0 = 0;
     break label$2;
    }
    if (($7 | 0) != ($8 | 0) | ($6 | 0) != ($5 | 0) | HEAP16[$2 + 20 >> 1] < HEAP16[$1 + 20 >> 1]) {
     break label$3;
    }
    if (HEAP16[$2 + 22 >> 1] >= HEAP16[$1 + 22 >> 1]) {
     break label$2;
    }
   }
   $0 = $2 + 56 | 0;
   continue;
  }
  break;
 }
 return $0;
}

function sqlite3LogEstToInt($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = ($0 | 0) / 10 | 0;
 $2 = -1;
 $3 = 2147483647;
 if (($0 | 0) <= 609) {
  $7 = $5 << 16 >> 16;
  $5 = $0 - Math_imul($5, 10) | 0;
  $3 = $5;
  $1 = $3 << 16;
  $2 = $1 >> 16;
  $3 = $1 >> 31;
  $1 = $2;
  $4 = $1 - 2 | 0;
  $8 = $4;
  $2 = $1 >>> 0 < 2;
  $2 = $3 - $2 | 0;
  $9 = $2;
  $2 = $3;
  $3 = $1;
  $6 = $1 - 1 | 0;
  $5 = $5 & 65535;
  $1 = $5;
  $5 = $1 ? $6 : 0;
  $4 = !$3;
  $4 = $2 - $4 | 0;
  $2 = $1 ? $4 : 0;
  $6 = $2;
  $3 = $1 >>> 0 > 4;
  $4 = $3 ? $8 : $5;
  $2 = $9;
  $5 = $6;
  $1 = $3 ? $2 : $5;
  $3 = $4;
  $5 = $3 + 8 | 0;
  $6 = $5 >>> 0 < 8 ? $1 + 1 | 0 : $1;
  $2 = $5;
  $3 = $6;
  if (($0 | 0) >= 30) {
   $1 = $2;
   $2 = $7 - 3 | 0;
   $4 = $2 & 31;
   if (($2 & 63) >>> 0 >= 32) {
    $3 = $1 << $4;
    $1 = 0;
   } else {
    $3 = (1 << $4) - 1 & $1 >>> 32 - $4 | $6 << $4;
    $1 = $1 << $4;
   }
   i64toi32_i32$HIGH_BITS = $3;
   return $1;
  }
  $1 = $3;
  $6 = $2;
  $3 = 0;
  $2 = 3 - $7 | 0;
  $4 = $2 & 31;
  if (($2 & 63) >>> 0 >= 32) {
   $2 = $1 >>> $4 | 0;
  } else {
   $3 = $1 >>> $4 | 0;
   $2 = ((1 << $4) - 1 & $1) << 32 - $4 | $6 >>> $4;
  }
 }
 i64toi32_i32$HIGH_BITS = $3;
 $6 = $2;
 return $6;
}

function serialGet($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $5 = $0;
 $3 = HEAPU8[$5 + 7 | 0];
 $9 = $3;
 $4 = HEAPU8[$5 + 5 | 0];
 $5 = $4;
 $4 = $4 >>> 16 | 0;
 $7 = $4;
 $5 = $5 << 16;
 $3 = $0;
 $4 = HEAPU8[$3 + 4 | 0];
 $3 = $4;
 $6 = $3 << 24;
 $10 = $5 | $6;
 $4 = $3 >>> 8 | 0;
 $3 = $4;
 $4 = $7;
 $3 = $3 | $4;
 $11 = $3;
 $4 = $0;
 $3 = HEAPU8[$4 + 1 | 0];
 $4 = $3;
 $3 = $3 >>> 16 | 0;
 $8 = $3;
 $5 = $0;
 $3 = HEAPU8[$5 | 0];
 $5 = $3;
 $3 = $3 >>> 8 | 0;
 $12 = $3;
 $4 = $4 << 16;
 $6 = $5 << 24;
 $7 = $4 | $6;
 $3 = $8;
 $5 = $12;
 $5 = $3 | $5;
 $8 = $5;
 $3 = $0;
 $5 = HEAPU8[$3 + 3 | 0];
 $4 = HEAPU8[$3 + 2 | 0];
 $3 = $4;
 $4 = $3 >>> 24 | 0;
 $6 = $3 << 8;
 $6 = $5 | $6;
 $3 = $8;
 $4 = $7;
 $3 = $6 | $4;
 $4 = $11;
 $3 = $3 | $4;
 $5 = $3;
 $4 = $0;
 $3 = HEAPU8[$4 + 6 | 0];
 $0 = $3 << 8;
 $3 = $3 >>> 24 | 0;
 $4 = $3;
 $3 = $5;
 $4 = $3 | $4;
 $3 = $9;
 $5 = $10;
 $6 = 0;
 $5 = $5 | $6;
 $6 = $0;
 $6 = $5 | $6;
 $0 = $3 | $6;
 $3 = $2;
 HEAP32[$3 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $4;
 $3 = $4 & 1048575;
 $4 = $0;
 $0 = $3 | $4 ? 1 : 8;
 $6 = $7;
 $5 = $6 & 2146435072;
 $3 = 0;
 $0 = ($1 | 0) != 6 ? !$3 & ($5 | 0) == 2146435072 ? $0 : 8 : 4;
 HEAP16[$2 + 16 >> 1] = $0;
}

function rightFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (($1 | 0) == 2) {
  label$2: {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
    if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
     break label$2;
    }
   }
   sqlite3_result_null($0);
   return;
  }
  $1 = sqlite3_value_text(HEAP32[$2 >> 2]);
  $6 = sqlite3_value_int(HEAP32[$2 + 4 >> 2]);
  $4 = $1;
  while (1) {
   if (sqlite3ReadUtf8($4)) {
    $2 = $4;
    while (1) {
     $5 = HEAPU8[$2 + 1 | 0];
     $4 = $2 + 1 | 0;
     $2 = $4;
     if (($5 & 192) == 128) {
      continue;
     }
     break;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  $2 = $3 - $6 | 0;
  $3 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   if (($3 | 0) > 0) {
    $3 = $3 - 1 | 0;
    while (1) {
     $2 = HEAPU8[$1 + 1 | 0];
     $5 = $1 + 1 | 0;
     $1 = $5;
     if (($2 & 192) == 128) {
      continue;
     }
     break;
    }
    $1 = $5;
    continue;
   }
   break;
  }
  $2 = sqlite3_malloc(($4 - $1 | 0) + 1 | 0);
  if (!$2) {
   sqlite3_result_error_nomem($0);
   return;
  }
  $1 = strcpy($2, $1);
  sqlite3_result_text($0, $1, -1, -1);
  sqlite3_free($1);
  return;
 }
 __assert_fail(23018, 17353, 1113, 17027);
 abort();
}

function sqlite3Parser($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $7 = HEAP32[$0 + 4 >> 2];
 $4 = HEAPU16[HEAP32[$0 >> 2] >> 1];
 label$1: {
  while (1) {
   $4 = yy_find_shift_action($1 & 65535, $4 & 65535);
   if ($4 >>> 0 >= 1243) {
    if (!(HEAPU8[$4 + 34981 | 0] | HEAPU32[$0 >> 2] < HEAPU32[$0 + 1208 >> 2])) {
     yyStackOverflow($0);
     break label$1;
    }
    $5 = HEAP32[$2 >> 2];
    $6 = HEAP32[$2 + 4 >> 2];
    HEAP32[$3 >> 2] = $5;
    HEAP32[$3 + 4 >> 2] = $6;
    $4 = yy_reduce($0, $4 - 1243 | 0, $3, $7);
    continue;
   }
   break;
  }
  if ($4 >>> 0 <= 1239) {
   $6 = HEAP32[$2 >> 2];
   $5 = HEAP32[$2 + 4 >> 2];
   HEAP32[$3 + 8 >> 2] = $6;
   HEAP32[$3 + 12 >> 2] = $5;
   yy_shift($0, $4, $1 & 65535, $3 + 8 | 0);
   break label$1;
  }
  if (($4 | 0) == 1241) {
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - 12;
   break label$1;
  }
  $5 = HEAP32[$2 >> 2];
  $6 = HEAP32[$2 + 4 >> 2];
  HEAP32[$3 + 24 >> 2] = $5;
  HEAP32[$3 + 28 >> 2] = $6;
  $5 = HEAP32[$2 + 4 >> 2];
  $6 = HEAP32[$2 >> 2];
  HEAP32[$3 + 16 >> 2] = $6;
  HEAP32[$3 + 20 >> 2] = $5;
  yy_syntax_error($0, $3 + 16 | 0);
  yy_destructor($0, $1 & 65535, $3 + 24 | 0);
 }
 __stack_pointer = $3 + 32 | 0;
}

function codeDistinct($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = HEAP32[$0 + 8 >> 2];
 $6 = HEAP32[$4 >> 2];
 label$1: {
  switch ($1 - 1 | 0) {
  case 1:
   $8 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 44 >> 2] = $8 + $6;
   $1 = 0;
   $11 = ($6 | 0) > 0 ? $6 : 0;
   $10 = $6 - 1 | 0;
   $9 = $8 + 1 | 0;
   $12 = sqlite3VdbeCurrentAddr($7) + $6 | 0;
   while (1) {
    if (($1 | 0) != ($11 | 0)) {
     $6 = $1 + $9 | 0;
     $8 = $1 + $5 | 0;
     $2 = sqlite3ExprCollSeq($0, HEAP32[(($1 << 4) + $4 | 0) + 8 >> 2]);
     label$6: {
      if (($1 | 0) < ($10 | 0)) {
       sqlite3VdbeAddOp3($7, 52, $8, $12, $6);
       break label$6;
      }
      sqlite3VdbeAddOp3($7, 53, $8, $3, $6);
     }
     sqlite3VdbeChangeP4($7, -1, $2, -2);
     sqlite3VdbeChangeP5($7, 128);
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   ;
   sqlite3VdbeAddOp3($7, 80, $5, $9, $10);
   return $9;

  default:
   $1 = sqlite3GetTempReg($0);
   sqlite3VdbeAddOp4Int($7, 28, $2, $3, $5, $6);
   sqlite3VdbeAddOp3($7, 97, $5, $6, $1);
   sqlite3VdbeAddOp4Int($7, 138, $2, $1, $5, $6);
   sqlite3VdbeChangeP5($7, 16);
   sqlite3ReleaseTempReg($0, $1);
   $8 = $2;
   break;

  case 0:
   break label$1;
  }
 }
 return $8;
}

function __ashlti3($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 label$1: {
  if ($5 & 64) {
   $7 = $2;
   $8 = $1;
   $5 = $5 + -64 | 0;
   $6 = $5 & 31;
   if (($5 & 63) >>> 0 >= 32) {
    $9 = $8 << $6;
    $3 = 0;
   } else {
    $9 = (1 << $6) - 1 & $8 >>> 32 - $6 | $7 << $6;
    $3 = $8 << $6;
   }
   $4 = $9;
   $1 = 0;
   $2 = 0;
   break label$1;
  }
  if (!$5) {
   break label$1;
  }
  $9 = $4;
  $7 = $3;
  $10 = $5;
  $6 = $5 & 31;
  if (($5 & 63) >>> 0 >= 32) {
   $8 = $7 << $6;
   $3 = 0;
  } else {
   $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $9 << $6;
   $3 = $7 << $6;
  }
  $4 = $8;
  $8 = $2;
  $9 = $1;
  $7 = 0;
  $5 = 64 - $5 | 0;
  $6 = $5 & 31;
  if (($5 & 63) >>> 0 >= 32) {
   $5 = $8 >>> $6 | 0;
  } else {
   $7 = $8 >>> $6 | 0;
   $5 = ((1 << $6) - 1 & $8) << 32 - $6 | $9 >>> $6;
  }
  $9 = $7;
  $8 = $3;
  $3 = $8 | $5;
  $7 = $4;
  $9 = $7 | $9;
  $4 = $9;
  $9 = $2;
  $7 = $1;
  $5 = $10;
  $6 = $5 & 31;
  if (($5 & 63) >>> 0 >= 32) {
   $8 = $7 << $6;
   $1 = 0;
  } else {
   $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $9 << $6;
   $1 = $7 << $6;
  }
  $2 = $8;
 }
 $7 = $0;
 HEAP32[$7 >> 2] = $1;
 $8 = $2;
 HEAP32[$7 + 4 >> 2] = $8;
 HEAP32[$7 + 8 >> 2] = $3;
 $8 = $4;
 HEAP32[$7 + 12 >> 2] = $8;
}

function statPush($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $1 = sqlite3_value_blob(HEAP32[$2 >> 2]);
 $2 = sqlite3_value_int(HEAP32[$2 + 4 >> 2]);
 label$1: {
  if (HEAP32[$1 + 8 >> 2]) {
   $5 = ($2 | 0) > 0 ? $2 : 0;
   while (1) if (($3 | 0) == ($5 | 0)) {
    while (1) {
     if (HEAP32[$1 + 16 >> 2] <= ($2 | 0)) {
      break label$1;
     }
     $3 = $2 << 2;
     $4 = $3 + HEAP32[$1 + 32 >> 2] | 0;
     HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + 1;
     HEAP32[HEAP32[$1 + 28 >> 2] + $3 >> 2] = 1;
     $2 = $2 + 1 | 0;
     continue;
    }
   } else {
    $4 = HEAP32[$1 + 28 >> 2] + ($3 << 2) | 0;
    HEAP32[$4 >> 2] = HEAP32[$4 >> 2] + 1;
    $3 = $3 + 1 | 0;
    continue;
   }
  }
  $2 = 0;
  while (1) {
   if (HEAP32[$1 + 16 >> 2] <= ($2 | 0)) {
    break label$1;
   }
   HEAP32[HEAP32[$1 + 28 >> 2] + ($2 << 2) >> 2] = 1;
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 $2 = HEAP32[$1 + 8 >> 2] + 1 | 0;
 HEAP32[$1 + 8 >> 2] = $2;
 $3 = HEAP32[$1 + 12 >> 2];
 label$8: {
  if (!$3) {
   break label$8;
  }
  $4 = HEAPU8[$1 + 24 | 0];
  if (Math_imul($4 + 1 | 0, $3) >>> 0 >= $2 >>> 0) {
   break label$8;
  }
  HEAP8[$1 + 24 | 0] = $4 + 1;
  sqlite3_result_int($0, HEAP32[HEAP32[$1 + 32 >> 2] >> 2] != 0);
 }
}

function exprRefToSrcList($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 label$1: {
  label$2: {
   switch (HEAPU8[$1 | 0] - 167 | 0) {
   case 0:
   case 2:
    break label$2;

   default:
    break label$1;
   }
  }
  $5 = HEAP32[$0 + 24 >> 2];
  $3 = HEAP32[$5 + 4 >> 2];
  if ($3) {
   $2 = HEAP32[$3 >> 2];
  }
  $6 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   label$5: {
    if (($4 | 0) == ($6 | 0)) {
     $3 = HEAP32[$5 + 12 >> 2];
     $6 = $3;
     $7 = HEAP32[$5 + 8 >> 2];
     $2 = !!$7 & ($3 | 0) >= 0 | ($3 | 0) > 0;
     $7 = $2 ? $7 : 0;
     $6 = $2 ? $6 : 0;
     $8 = 2;
     while (1) {
      $2 = $9;
      if (($7 | 0) == ($2 | 0) & ($6 | 0) == ($10 | 0)) {
       break label$5;
      }
      $2 = $10;
      $4 = $9;
      $3 = $4 + 1 | 0;
      $9 = $3;
      $10 = $3 ? $2 : $2 + 1 | 0;
      if (HEAP32[HEAP32[$5 + 16 >> 2] + ($4 << 2) >> 2] != HEAP32[$1 + 28 >> 2]) {
       continue;
      }
      break;
     }
     break label$1;
    }
    $8 = 1;
    $2 = $4 << 6;
    $4 = $4 + 1 | 0;
    if (HEAP32[$1 + 28 >> 2] != HEAP32[($2 + $3 | 0) + 48 >> 2]) {
     continue;
    }
   }
   break;
  }
  HEAP16[$0 + 20 >> 1] = HEAPU16[$0 + 20 >> 1] | $8;
 }
 return 0;
}

function vdbeSorterAddToTree($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $8 = 1;
 $9 = ($1 | 0) > 1 ? $1 : 1;
 $5 = vdbeIncrMergerNew($0, $4, $7 + 12 | 0);
 $6 = 1;
 $4 = 1;
 while (1) {
  if (($6 | 0) == ($9 | 0)) {
   while (1) {
    if (!(($1 | 0) <= ($8 | 0) | $5)) {
     $5 = HEAP32[$3 + 12 >> 2] + Math_imul((($2 | 0) / ($4 | 0) | 0) % 16 | 0, 56) | 0;
     $6 = HEAP32[$5 + 48 >> 2];
     label$5: {
      if (!$6) {
       $6 = vdbeMergeEngineNew(16);
       if (!$6) {
        $5 = 7;
        break label$5;
       }
       $10 = $5;
       $9 = $5 + 48 | 0;
       $5 = vdbeIncrMergerNew($0, $6, $9);
       if ($5) {
        break label$5;
       }
       $6 = HEAP32[$10 + 48 >> 2];
      }
      $4 = ($4 | 0) / 16 | 0;
      $3 = HEAP32[$6 + 4 >> 2];
      $5 = 0;
     }
     $8 = $8 + 1 | 0;
     continue;
    }
    break;
   }
   $4 = HEAP32[$7 + 12 >> 2];
   label$8: {
    if (!$5) {
     HEAP32[(HEAP32[$3 + 12 >> 2] + Math_imul(($2 | 0) % 16 | 0, 56) | 0) + 48 >> 2] = $4;
     break label$8;
    }
    vdbeIncrFree($4);
   }
   __stack_pointer = $7 + 16 | 0;
  } else {
   $6 = $6 + 1 | 0;
   $4 = $4 << 4;
   continue;
  }
  break;
 }
 return $5;
}

function sqlite3JoinType($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 28 >> 2] = $3;
 HEAP32[$4 + 24 >> 2] = $2;
 HEAP32[$4 + 20 >> 2] = $1;
 label$1: {
  while (1) {
   if (($7 | 0) == 3) {
    break label$1;
   }
   $8 = HEAP32[($4 + 20 | 0) + ($7 << 2) >> 2];
   if (!$8) {
    break label$1;
   }
   $10 = HEAP32[$8 + 4 >> 2];
   $6 = 0;
   label$3: {
    while (1) {
     if (($6 | 0) == 7) {
      break label$3;
     }
     label$5: {
      $9 = Math_imul($6, 3);
      if (HEAPU8[$9 + 49169 | 0] == ($10 | 0)) {
       if (!sqlite3_strnicmp(HEAP32[$8 >> 2], HEAPU8[$9 + 49168 | 0] + 49120 | 0, $10)) {
        break label$5;
       }
      }
      $6 = $6 + 1 | 0;
      continue;
     }
     break;
    }
    $7 = $7 + 1 | 0;
    $5 = HEAPU8[$9 + 49170 | 0] | $5;
    continue;
   }
   break;
  }
  $5 = $5 | 128;
 }
 if (!(!($5 & 128 | ($5 & 33) == 33) & ($5 & 56) != 32)) {
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[$4 >> 2] = $1;
  HEAP32[$4 + 12 >> 2] = $3 ? 29598 : 29599;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 4 >> 2] = $2 ? 29598 : 29599;
  sqlite3ErrorMsg($0, 18412, $4);
  $5 = 1;
 }
 __stack_pointer = $4 + 32 | 0;
 return $5;
}

function sqlite3CodeDropTable($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $8 = HEAP32[$0 >> 2];
 $4 = HEAP32[$8 + 16 >> 2];
 $7 = sqlite3GetVdbe($0);
 sqlite3BeginWriteOperation($0, 1, $2);
 $6 = $2 << 4;
 if (HEAPU8[$1 + 43 | 0] == 1) {
  sqlite3VdbeAddOp0($7, 170);
 }
 $6 = $4 + $6 | 0;
 $4 = sqlite3TriggerList($0, $1);
 while (1) {
  if ($4) {
   sqlite3DropTriggerPtr($0, $4);
   $4 = HEAP32[$4 + 32 >> 2];
   continue;
  }
  break;
 }
 if (HEAPU8[$1 + 28 | 0] & 8) {
  $4 = HEAP32[$6 >> 2];
  HEAP32[$5 + 20 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$5 + 16 >> 2] = $4;
  sqlite3NestedParse($0, 19078, $5 + 16 | 0);
 }
 $4 = HEAP32[$6 >> 2];
 HEAP32[$5 + 4 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$5 >> 2] = $4;
 sqlite3NestedParse($0, 27354, $5);
 label$5: {
  label$6: {
   if (!$3) {
    if (HEAPU8[$1 + 43 | 0] == 1) {
     break label$6;
    }
    destroyTable($0, $1);
   }
   if (HEAPU8[$1 + 43 | 0] != 1) {
    break label$5;
   }
  }
  sqlite3VdbeAddOp4($7, 172, $2, 0, 0, HEAP32[$1 >> 2], 0);
  sqlite3MayAbort($0);
 }
 sqlite3VdbeAddOp4($7, 151, $2, 0, 0, HEAP32[$1 >> 2], 0);
 sqlite3ChangeCookie($0, $2);
 sqliteViewResetAll($8, $2);
 __stack_pointer = $5 + 32 | 0;
}

function fts3ColumnFilter($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $9 = __stack_pointer - 16 | 0;
 __stack_pointer = $9;
 $7 = HEAP32[$3 >> 2];
 $5 = HEAP32[$2 >> 2];
 HEAP32[$9 + 12 >> 2] = 0;
 $10 = $5 + $7 | 0;
 $4 = $5;
 while (1) {
  $6 = 0;
  while (1) {
   label$3: {
    if ($4 >>> 0 >= $10 >>> 0) {
     break label$3;
    }
    $8 = HEAPU8[$4 | 0];
    if (!($8 & 254 | $6)) {
     break label$3;
    }
    $6 = $8 & 128;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  label$4: {
   if (HEAP32[$9 + 12 >> 2] == ($0 | 0)) {
    $7 = $4 - $5 | 0;
    break label$4;
   }
   $7 = ($5 - $4 | 0) + $7 | 0;
   if (($7 | 0) <= 0) {
    $5 = $4;
    break label$4;
   }
   $5 = $4;
   $6 = $4 + 1 | 0;
   $8 = HEAP8[$4 + 1 | 0];
   label$7: {
    if (($8 | 0) < 0) {
     $4 = sqlite3Fts3GetVarint32($6, $9 + 12 | 0);
     break label$7;
    }
    HEAP32[$9 + 12 >> 2] = $8 & 255;
    $4 = 1;
   }
   $8 = $4;
   $4 = $6 + $8 | 0;
   continue;
  }
  break;
 }
 label$9: {
  if (!$1) {
   break label$9;
  }
  $4 = $5 + $7 | 0;
  $6 = $10 - $4 | 0;
  if (($6 | 0) <= 0) {
   break label$9;
  }
  memset($4, 0, $6);
 }
 HEAP32[$2 >> 2] = $5;
 HEAP32[$3 >> 2] = $7;
 __stack_pointer = $9 + 16 | 0;
}

function sqlite3SchemaClear($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 $3 = HEAP32[$0 + 20 >> 2];
 $4 = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 24 >> 2] = $4;
 HEAP32[$1 + 28 >> 2] = $3;
 $4 = HEAP32[$0 + 12 >> 2];
 $3 = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 16 >> 2] = $3;
 HEAP32[$1 + 20 >> 2] = $4;
 $3 = HEAP32[$0 + 52 >> 2];
 $4 = HEAP32[$0 + 48 >> 2];
 $2 = $1 + 8 | 0;
 HEAP32[$2 >> 2] = $4;
 HEAP32[$2 + 4 >> 2] = $3;
 $4 = HEAP32[$0 + 44 >> 2];
 $3 = HEAP32[$0 + 40 >> 2];
 HEAP32[$1 >> 2] = $3;
 HEAP32[$1 + 4 >> 2] = $4;
 sqlite3HashInit($0 + 40 | 0);
 sqlite3HashClear($0 + 24 | 0);
 $3 = $0 + 8 | 0;
 while (1) {
  $2 = HEAP32[$2 >> 2];
  if ($2) {
   sqlite3DeleteTrigger(0, HEAP32[$2 + 8 >> 2]);
   continue;
  }
  break;
 }
 sqlite3HashClear($1);
 sqlite3HashInit($3);
 $2 = $1 + 24 | 0;
 while (1) {
  $2 = HEAP32[$2 >> 2];
  if ($2) {
   sqlite3DeleteTable(0, HEAP32[$2 + 8 >> 2]);
   continue;
  }
  break;
 }
 sqlite3HashClear($1 + 16 | 0);
 sqlite3HashClear($0 + 56 | 0);
 HEAP32[$0 + 72 >> 2] = 0;
 $2 = HEAPU16[$0 + 78 >> 1];
 if ($2 & 1) {
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
 }
 HEAP16[$0 + 78 >> 1] = $2 & 65526;
 __stack_pointer = $1 + 32 | 0;
}

function renameWalkWith($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$1 + 64 >> 2];
 label$1: {
  if (!$5) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  if (!(HEAPU8[HEAP32[$5 + 20 >> 2] + 4 | 0] & 64)) {
   $6 = sqlite3WithPush($3, sqlite3WithDup(HEAP32[$3 >> 2], $5), 1);
  }
  $7 = $4 | 4;
  $1 = 0;
  while (1) {
   if (HEAP32[$5 >> 2] > ($1 | 0)) {
    $8 = Math_imul($1, 24) + $5 | 0;
    $9 = HEAP32[$8 + 20 >> 2];
    HEAP32[$7 + 24 >> 2] = 0;
    $2 = $7;
    HEAP32[$2 + 16 >> 2] = 0;
    HEAP32[$2 + 20 >> 2] = 0;
    $2 = $7;
    HEAP32[$2 + 8 >> 2] = 0;
    HEAP32[$2 + 12 >> 2] = 0;
    HEAP32[$2 >> 2] = 0;
    HEAP32[$2 + 4 >> 2] = 0;
    HEAP32[$4 >> 2] = $3;
    $2 = $3;
    if ($6) {
     sqlite3SelectPrep($3, $9, $4);
     $2 = HEAP32[$4 >> 2];
    }
    if (HEAPU8[HEAP32[$2 >> 2] + 87 | 0]) {
     break label$1;
    }
    sqlite3WalkSelect($0, $9);
    sqlite3RenameExprlistUnmap($3, HEAP32[$8 + 16 >> 2]);
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  if (!$6 | HEAP32[$3 + 264 >> 2] != ($6 | 0)) {
   break label$1;
  }
  HEAP32[$3 + 264 >> 2] = HEAP32[$6 + 8 >> 2];
 }
 __stack_pointer = $4 + 32 | 0;
}

function relocatePage($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if ($7 >>> 0 <= 2) {
   $5 = sqlite3CorruptError(70647);
   break label$1;
  }
  $5 = sqlite3PagerMovepage(HEAP32[$0 >> 2], HEAP32[$1 + 72 >> 2], $4, $5);
  HEAP32[$6 + 8 >> 2] = $5;
  if ($5) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = $4;
  label$3: {
   if (($2 & 251) == 1) {
    $5 = setChildPtrmaps($1);
    if (!$5) {
     break label$3;
    }
    break label$1;
   }
   $1 = sqlite3Get4byte(HEAP32[$1 + 56 >> 2]);
   if (!$1) {
    break label$3;
   }
   ptrmapPut($0, $1, 4, $4, $6 + 8 | 0);
   $5 = HEAP32[$6 + 8 >> 2];
   if ($5) {
    break label$1;
   }
  }
  $5 = 0;
  if (($2 | 0) == 1) {
   break label$1;
  }
  $5 = btreeGetPage($0, $3, $6 + 12 | 0, 0);
  if ($5) {
   break label$1;
  }
  $1 = HEAP32[$6 + 12 >> 2];
  $5 = sqlite3PagerWrite(HEAP32[$1 + 72 >> 2]);
  if ($5) {
   releasePage($1);
   break label$1;
  }
  $5 = modifyPagePointer($1, $7, $4, $2);
  HEAP32[$6 + 8 >> 2] = $5;
  releasePage($1);
  if ($5) {
   break label$1;
  }
  ptrmapPut($0, $4, $2, $3, $6 + 8 | 0);
  $5 = HEAP32[$6 + 8 >> 2];
 }
 __stack_pointer = $6 + 16 | 0;
 return $5;
}

function codeAttach($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = __stack_pointer - 32 | 0;
 __stack_pointer = $7;
 $9 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  HEAP32[$7 + 28 >> 2] = 0;
  HEAP32[$7 + 20 >> 2] = 0;
  HEAP32[$7 + 24 >> 2] = 0;
  HEAP32[$7 + 12 >> 2] = 0;
  HEAP32[$7 + 16 >> 2] = 0;
  HEAP32[$7 + 4 >> 2] = 0;
  HEAP32[$7 + 8 >> 2] = 0;
  HEAP32[$7 >> 2] = $0;
  if (resolveAttachExpr($7, $4)) {
   break label$1;
  }
  if (resolveAttachExpr($7, $5)) {
   break label$1;
  }
  if (resolveAttachExpr($7, $6)) {
   break label$1;
  }
  if ($3) {
   $8 = HEAPU8[$3 | 0] == 117 ? HEAP32[$3 + 8 >> 2] : $8;
   if (sqlite3AuthCheck($0, $1, $8, 0, 0)) {
    break label$1;
   }
  }
  $8 = sqlite3GetVdbe($0);
  $3 = sqlite3GetTempRange($0, 4);
  sqlite3ExprCode($0, $4, $3);
  sqlite3ExprCode($0, $5, $3 + 1 | 0);
  sqlite3ExprCode($0, $6, $3 + 2 | 0);
  if (!$8) {
   break label$1;
  }
  $3 = $3 + 3 | 0;
  $10 = HEAP8[$2 | 0];
  sqlite3VdbeAddFunctionCall($0, 0, $3 - $10 | 0, $3, $10, $2, 0);
  sqlite3VdbeAddOp1($8, 166, ($1 | 0) == 24);
 }
 sqlite3ExprDelete($9, $4);
 sqlite3ExprDelete($9, $5);
 sqlite3ExprDelete($9, $6);
 __stack_pointer = $7 + 32 | 0;
}

function vdbePmaWriteBlob($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = $2;
 while (1) {
  if (!(HEAP32[$0 >> 2] | ($8 | 0) <= 0)) {
   $5 = HEAP32[$0 + 16 >> 2];
   $3 = $5 + HEAP32[$0 + 4 >> 2] | 0;
   $5 = HEAP32[$0 + 8 >> 2] - $5 | 0;
   $5 = ($8 | 0) < ($5 | 0) ? $8 : $5;
   __memcpy($3, ($2 - $8 | 0) + $1 | 0, $5);
   $9 = HEAP32[$0 + 16 >> 2] + $5 | 0;
   HEAP32[$0 + 16 >> 2] = $9;
   if (HEAP32[$0 + 8 >> 2] == ($9 | 0)) {
    $6 = HEAP32[$0 + 12 >> 2];
    $3 = HEAP32[$0 + 24 >> 2];
    $7 = $6 + $3 | 0;
    $3 = $6;
    $3 = $3 >> 31;
    $4 = $3 + HEAP32[$0 + 28 >> 2] | 0;
    $4 = $7 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
    HEAP32[$0 >> 2] = sqlite3OsWrite(HEAP32[$0 + 32 >> 2], $6 + HEAP32[$0 + 4 >> 2] | 0, $9 - $6 | 0, $7, $4);
    HEAP32[$0 + 12 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    $4 = HEAP32[$0 + 24 >> 2];
    $10 = $4;
    $3 = HEAP32[$0 + 28 >> 2];
    $6 = $3;
    $3 = HEAP32[$0 + 8 >> 2];
    $4 = $3 >> 31;
    $9 = $3;
    $3 = $4;
    $4 = $6;
    $7 = $3 + $4 | 0;
    $3 = $9 + $10 | 0;
    $7 = $9 >>> 0 > $3 >>> 0 ? $7 + 1 | 0 : $7;
    HEAP32[$0 + 24 >> 2] = $3;
    HEAP32[$0 + 28 >> 2] = $7;
   }
   $8 = $8 - $5 | 0;
   continue;
  }
  break;
 }
}

function autoIncBegin($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (!(HEAPU8[$2 + 28 | 0] & 8)) {
   break label$1;
  }
  $5 = HEAP32[$0 >> 2];
  if (HEAPU8[$5 + 24 | 0] & 4) {
   break label$1;
  }
  label$2: {
   $3 = HEAP32[HEAP32[(HEAP32[$5 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 72 >> 2];
   if (!(!$3 | HEAPU8[$3 + 28 | 0] & 128 | HEAPU8[$3 + 43 | 0] == 1)) {
    if (HEAPU16[$3 + 34 >> 1] == 2) {
     break label$2;
    }
   }
   HEAP32[$0 + 12 >> 2] = 523;
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   return 0;
  }
  $3 = HEAP32[$0 + 116 >> 2];
  $4 = $3 ? $3 : $0;
  $3 = $4 + 112 | 0;
  label$4: {
   while (1) {
    $3 = HEAP32[$3 >> 2];
    if (!$3) {
     break label$4;
    }
    if (HEAP32[$3 + 4 >> 2] != ($2 | 0)) {
     continue;
    }
    break;
   }
   return HEAP32[$3 + 12 >> 2];
  }
  $3 = sqlite3DbMallocRawNN($5, 16, 0);
  sqlite3ParserAddCleanup($4, 46, $3);
  if (HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
   break label$1;
  }
  HEAP32[$3 >> 2] = HEAP32[$4 + 112 >> 2];
  HEAP32[$4 + 112 >> 2] = $3;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $2 = HEAP32[$4 + 44 >> 2];
  $6 = $2 + 2 | 0;
  HEAP32[$3 + 12 >> 2] = $6;
  HEAP32[$4 + 44 >> 2] = $2 + 4;
 }
 return $6;
}

function sqlite3WindowDup($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $3 = sqlite3DbMallocZero($0, 100, 0);
  if (!$3) {
   break label$1;
  }
  HEAP32[$3 >> 2] = sqlite3DbStrDup($0, HEAP32[$2 >> 2]);
  HEAP32[$3 + 4 >> 2] = sqlite3DbStrDup($0, HEAP32[$2 + 4 >> 2]);
  HEAP32[$3 + 40 >> 2] = sqlite3ExprDup($0, HEAP32[$2 + 40 >> 2], 0);
  HEAP32[$3 + 44 >> 2] = HEAP32[$2 + 44 >> 2];
  HEAP32[$3 + 8 >> 2] = sqlite3ExprListDup($0, HEAP32[$2 + 8 >> 2], 0);
  HEAP32[$3 + 12 >> 2] = sqlite3ExprListDup($0, HEAP32[$2 + 12 >> 2], 0);
  HEAP8[$3 + 16 | 0] = HEAPU8[$2 + 16 | 0];
  HEAP8[$3 + 18 | 0] = HEAPU8[$2 + 18 | 0];
  HEAP8[$3 + 17 | 0] = HEAPU8[$2 + 17 | 0];
  HEAP8[$3 + 20 | 0] = HEAPU8[$2 + 20 | 0];
  HEAP32[$3 + 56 >> 2] = HEAP32[$2 + 56 >> 2];
  HEAP32[$3 + 52 >> 2] = HEAP32[$2 + 52 >> 2];
  HEAP32[$3 + 80 >> 2] = HEAP32[$2 + 80 >> 2];
  HEAP32[$3 + 48 >> 2] = HEAP32[$2 + 48 >> 2];
  HEAP8[$3 + 96 | 0] = HEAPU8[$2 + 96 | 0];
  HEAP32[$3 + 24 >> 2] = sqlite3ExprDup($0, HEAP32[$2 + 24 >> 2], 0);
  $0 = sqlite3ExprDup($0, HEAP32[$2 + 28 >> 2], 0);
  HEAP32[$3 + 72 >> 2] = $1;
  HEAP32[$3 + 28 >> 2] = $0;
  HEAP8[$3 + 19 | 0] = HEAPU8[$2 + 19 | 0];
  $4 = $3;
 }
 return $4;
}

function pagerOpenSavepoint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $2 = HEAP32[$0 + 104 >> 2];
 $7 = 7;
 label$1: {
  $4 = sqlite3Realloc(HEAP32[$0 + 100 >> 2], Math_imul($1, 48), 0);
  if (!$4) {
   break label$1;
  }
  memset(Math_imul($2, 48) + $4 | 0, 0, Math_imul($1 - $2 | 0, 48));
  HEAP32[$0 + 100 >> 2] = $4;
  $8 = ($1 | 0) < ($2 | 0) ? $2 : $1;
  while (1) {
   if (($2 | 0) == ($8 | 0)) {
    $7 = 0;
    break label$1;
   }
   $1 = Math_imul($2, 48) + $4 | 0;
   $3 = HEAP32[$0 + 28 >> 2];
   HEAP32[$1 + 20 >> 2] = $3;
   label$4: {
    if (HEAP32[HEAP32[$0 + 68 >> 2] >> 2]) {
     $5 = HEAP32[$0 + 84 >> 2];
     $6 = HEAP32[$0 + 80 >> 2];
     if (!!$6 & ($5 | 0) >= 0 | ($5 | 0) > 0) {
      break label$4;
     }
    }
    $6 = HEAP32[$0 + 156 >> 2];
    $5 = 0;
   }
   HEAP32[$1 >> 2] = $6;
   HEAP32[$1 + 4 >> 2] = $5;
   HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 56 >> 2];
   $3 = sqlite3BitvecCreate($3);
   HEAP32[$1 + 28 >> 2] = 1;
   HEAP32[$1 + 16 >> 2] = $3;
   if (!$3) {
    break label$1;
   }
   $3 = HEAP32[$0 + 232 >> 2];
   if ($3) {
    sqlite3WalSavepoint($3, $1 + 32 | 0);
   }
   $2 = $2 + 1 | 0;
   HEAP32[$0 + 104 >> 2] = $2;
   continue;
  }
 }
 return $7;
}

function sqlite3AddInt64($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = $0;
 $3 = HEAP32[$5 >> 2];
 $7 = $3;
 $6 = HEAP32[$5 + 4 >> 2];
 $8 = $6;
 $6 = $2;
 label$1: {
  label$2: {
   if (($6 | 0) > 0 | ($6 | 0) >= 0) {
    $4 = $7;
    $5 = $8;
    if (!$4 & ($5 | 0) <= 0 | ($5 | 0) < 0) {
     break label$2;
    }
    $9 = 1;
    $4 = $8;
    $5 = $4 ^ 2147483647;
    $3 = $7;
    $4 = $3 ^ -1;
    $3 = $2;
    $6 = $1;
    if (($3 | 0) == ($5 | 0) & $4 >>> 0 >= $6 >>> 0 | $3 >>> 0 < $5 >>> 0) {
     break label$2;
    }
    break label$1;
   }
   $4 = $8;
   if (($4 | 0) > 0 | ($4 | 0) >= 0) {
    break label$2;
   }
   $9 = 1;
   $6 = $2;
   $3 = $1;
   $3 = $3 + 1 | 0;
   $4 = $3 ? $6 : $6 + 1 | 0;
   $10 = $4;
   $5 = $7;
   $4 = 1 - $5 | 0;
   $5 = $4;
   $4 = $3;
   $3 = $8;
   $3 = $3 + ($7 >>> 0 > 1) | 0;
   $3 = -2147483648 - $3 | 0;
   $6 = $3;
   $3 = $10;
   if ($5 >>> 0 > $4 >>> 0 & ($6 | 0) >= ($3 | 0) | ($6 | 0) > ($3 | 0)) {
    break label$1;
   }
  }
  $4 = $2 + $8 | 0;
  $6 = $7;
  $5 = $1;
  $3 = $6 + $5 | 0;
  $4 = $3 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
  $5 = $0;
  HEAP32[$5 >> 2] = $3;
  HEAP32[$5 + 4 >> 2] = $4;
  $9 = 0;
 }
 return $9;
}

function sqlite3VdbeMemNumerify($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $1 = HEAPU16[$0 + 16 >> 1];
 if (!($1 & 45)) {
  label$2: {
   label$3: {
    label$4: {
     if (sqlite3AtoF(HEAP32[$0 + 8 >> 2], $0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]) >>> 0 > 1) {
      break label$4;
     }
     if ((sqlite3Atoi64(HEAP32[$0 + 8 >> 2], $3 + 8 | 0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]) | 0) > 1) {
      break label$4;
     }
     $4 = HEAP32[$3 + 8 >> 2];
     $1 = HEAP32[$3 + 12 >> 2];
     break label$3;
    }
    $2 = HEAPF64[$0 >> 3];
    label$5: {
     if (Math_abs($2) < 0x8000000000000000) {
      $1 = Math_abs($2) >= 1 ? ~~($2 > 0 ? Math_min(Math_floor($2 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($2 - +(~~$2 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
      $4 = ~~$2 >>> 0;
      break label$5;
     }
     $1 = -2147483648;
    }
    if (sqlite3RealSameAsInt($2, $4, $1)) {
     break label$3;
    }
    $1 = 8;
    break label$2;
   }
   HEAP32[$0 >> 2] = $4;
   HEAP32[$0 + 4 >> 2] = $1;
   $1 = 4;
  }
  $1 = $1 | HEAPU16[$0 + 16 >> 1] & -3520;
 }
 HEAP16[$0 + 16 >> 1] = $1 & 64493;
 __stack_pointer = $3 + 16 | 0;
}

function jsonGroupInverse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = sqlite3_aggregate_context($0, 0);
 if ($3) {
  $4 = HEAP32[$3 + 16 >> 2];
  $1 = HEAP32[$3 + 20 >> 2];
  $6 = HEAP32[$3 + 4 >> 2];
  $0 = 1;
  label$2: {
   while (1) {
    if (!$1 & $0 >>> 0 >= $4 >>> 0) {
     break label$2;
    }
    $2 = HEAPU8[$0 + $6 | 0];
    if ($7 ? 1 : ($2 | 0) != 44 | $5) {
     label$5: {
      label$6: {
       if (($2 | 0) != 92) {
        if (($2 | 0) != 34) {
         break label$6;
        }
        $5 = !$5;
        break label$5;
       }
       $0 = $0 + 1 | 0;
       break label$5;
      }
      if ($5) {
       $5 = 1;
       break label$5;
      }
      $2 = $2 & 223;
      $7 = ((($2 | 0) == 91) + $7 | 0) - (($2 | 0) == 93) | 0;
      $5 = 0;
     }
     $0 = $0 + 1 | 0;
     continue;
    }
    break;
   }
   $2 = $4 >>> 0 < $0 >>> 0;
   $2 = $1 - $2 | 0;
   $4 = $4 - $0 | 0;
   HEAP32[$3 + 16 >> 2] = $4;
   $1 = $2;
   HEAP32[$3 + 20 >> 2] = $1;
   $2 = $6 + 1 | 0;
   memmove($2, $0 + $2 | 0, $4 - 1 | 0);
   HEAP8[HEAP32[$3 + 16 >> 2] + $6 | 0] = 0;
   return;
  }
  HEAP32[$3 + 16 >> 2] = 1;
  HEAP32[$3 + 20 >> 2] = 0;
 }
}

function sqlite3BitvecClear($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = $1 - 1 | 0;
  while (1) {
   $3 = HEAP32[$0 + 8 >> 2];
   if ($3) {
    $4 = ($1 >>> 0) / ($3 >>> 0) | 0;
    $1 = $1 - Math_imul($4, $3) | 0;
    $0 = HEAP32[(($4 << 2) + $0 | 0) + 12 >> 2];
    if ($0) {
     continue;
    }
    break label$1;
   }
   break;
  }
  if (HEAPU32[$0 >> 2] <= 4e3) {
   $0 = ($1 >>> 3 | 0) + $0 | 0;
   $3 = $0 + 12 | 0;
   HEAP8[$3 | 0] = HEAPU8[$0 + 12 | 0] & __wasm_rotl_i32(-2, $1 & 7);
   return;
  }
  $3 = $0 + 12 | 0;
  $6 = __memcpy($2, $3, 500);
  $4 = memset($3, 0, 500);
  HEAP32[$0 + 4 >> 2] = 0;
  $7 = $1 + 1 | 0;
  $2 = 0;
  while (1) {
   if (($2 | 0) == 125) {
    break label$1;
   }
   $5 = ($2 << 2) + $6 | 0;
   $1 = HEAP32[$5 >> 2];
   if (!(!$1 | ($1 | 0) == ($7 | 0))) {
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + 1;
    $1 = ($1 - 1 >>> 0) % 125 | 0;
    while (1) {
     $3 = ($1 << 2) + $4 | 0;
     if (HEAP32[$3 >> 2]) {
      $1 = $1 + 1 | 0;
      $1 = $1 >>> 0 > 124 ? 0 : $1;
      continue;
     }
     break;
    }
    HEAP32[$3 >> 2] = HEAP32[$5 >> 2];
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
}

function memdbFileControl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $0 = HEAP32[$0 + 4 >> 2];
 label$1: {
  label$2: {
   if (($1 | 0) != 36) {
    $3 = 12;
    if (($1 | 0) != 12) {
     break label$1;
    }
    $1 = HEAP32[$0 + 24 >> 2];
    $4 = HEAP32[$0 + 4 >> 2];
    $3 = HEAP32[$0 >> 2];
    $0 = $3;
    $3 = $6;
    HEAP32[$3 + 8 >> 2] = $0;
    HEAP32[$3 + 12 >> 2] = $4;
    HEAP32[$3 >> 2] = $1;
    HEAP32[$2 >> 2] = sqlite3_mprintf(24846, $3);
    break label$2;
   }
   $4 = HEAP32[$2 >> 2];
   $7 = $4;
   $3 = HEAP32[$2 + 4 >> 2];
   $1 = $3;
   $3 = HEAP32[$0 >> 2];
   $5 = $3;
   $4 = HEAP32[$0 + 4 >> 2];
   $3 = $4;
   label$4: {
    if (($3 | 0) <= ($1 | 0) & $5 >>> 0 <= $7 >>> 0 | ($3 | 0) < ($1 | 0)) {
     $5 = $7;
     $4 = $1;
     break label$4;
    }
    if (($1 | 0) > 0 | ($1 | 0) >= 0) {
     break label$4;
    }
    $5 = HEAP32[$0 + 16 >> 2];
    $4 = HEAP32[$0 + 20 >> 2];
   }
   HEAP32[$0 + 16 >> 2] = $5;
   HEAP32[$0 + 20 >> 2] = $4;
   HEAP32[$2 >> 2] = $5;
   HEAP32[$2 + 4 >> 2] = $4;
  }
  $3 = 0;
 }
 __stack_pointer = $6 + 16 | 0;
 return $3 | 0;
}

function pager_unlock($0) {
 var $1 = 0;
 sqlite3BitvecDestroy(HEAP32[$0 + 60 >> 2]);
 HEAP32[$0 + 60 >> 2] = 0;
 releaseAllSavepoints($0);
 $1 = HEAP32[$0 + 232 >> 2];
 label$1: {
  label$2: {
   if ($1) {
    sqlite3WalEndReadTransaction($1);
    break label$2;
   }
   if (HEAPU8[$0 + 4 | 0]) {
    break label$1;
   }
   $1 = HEAP32[$0 + 64 >> 2];
   label$4: {
    label$5: {
     if (!HEAP32[$1 >> 2]) {
      break label$5;
     }
     if (!(sqlite3OsDeviceCharacteristics($1) & 2048)) {
      break label$5;
     }
     if ((HEAPU8[$0 + 5 | 0] & 5) == 1) {
      break label$4;
     }
    }
    sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
   }
   if (!pagerUnlockDb($0, 0) | HEAPU8[$0 + 17 | 0] != 6) {
    break label$2;
   }
   HEAP8[$0 + 18 | 0] = 5;
  }
  HEAP8[$0 + 17 | 0] = 0;
 }
 if (HEAP32[$0 + 44 >> 2]) {
  label$7: {
   if (!HEAPU8[$0 + 12 | 0]) {
    pager_reset($0);
    HEAP8[$0 + 19 | 0] = 0;
    $1 = 0;
    break label$7;
   }
   $1 = !HEAP32[HEAP32[$0 + 68 >> 2] >> 2];
  }
  HEAP32[$0 + 44 >> 2] = 0;
  HEAP8[$0 + 17 | 0] = $1;
  setGetterMethod($0);
 }
 HEAP32[$0 + 80 >> 2] = 0;
 HEAP32[$0 + 84 >> 2] = 0;
 HEAP8[$0 + 20 | 0] = 0;
 HEAP32[$0 + 88 >> 2] = 0;
 HEAP32[$0 + 92 >> 2] = 0;
}

function whereScanInit($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 HEAP8[$0 + 24 | 0] = 0;
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 20 >> 2] = $4;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = $2;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP8[$0 + 25 | 0] = 1;
 HEAP8[$0 + 26 | 0] = 1;
 label$1: {
  label$2: {
   if ($5) {
    $1 = -1;
    $6 = HEAPU16[HEAP32[$5 + 4 >> 2] + ($3 << 1) >> 1];
    $4 = HEAP32[$5 + 12 >> 2];
    if (($6 | 0) == HEAPU16[$4 + 32 >> 1]) {
     break label$2;
    }
    $1 = $6 << 16 >> 16;
    if (($1 | 0) >= 0) {
     HEAP8[$0 + 24 | 0] = HEAPU8[(HEAP32[$4 + 4 >> 2] + Math_imul($1, 12) | 0) + 5 | 0];
     HEAP32[$0 + 8 >> 2] = HEAP32[HEAP32[$5 + 32 >> 2] + ($3 << 2) >> 2];
     break label$2;
    }
    if (($1 | 0) != -2) {
     break label$2;
    }
    HEAP32[$0 + 12 >> 2] = HEAP32[(HEAP32[$5 + 40 >> 2] + ($3 << 4) | 0) + 8 >> 2];
    $5 = HEAP32[HEAP32[$5 + 32 >> 2] + ($3 << 2) >> 2];
    HEAP16[$0 + 72 >> 1] = 65534;
    HEAP32[$0 + 8 >> 2] = $5;
    return whereScanInitIndexExpr($0);
   }
   $1 = $3;
   if (($1 | 0) == -2) {
    break label$1;
   }
  }
  HEAP16[$0 + 72 >> 1] = $1;
  $6 = whereScanNext($0);
 }
 return $6;
}

function sqlite3CompleteInsertion($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $14 = (($8 | 0) != 0) << 4;
 $16 = $14 | $6 & 2 | 1;
 $9 = $1 + 8 | 0;
 $10 = HEAP32[$0 + 8 >> 2];
 while (1) {
  $9 = HEAP32[$9 >> 2];
  if ($9) {
   $12 = ($13 << 2) + $5 | 0;
   $11 = HEAP32[$12 >> 2];
   if ($11) {
    if (HEAP32[$9 + 36 >> 2]) {
     sqlite3VdbeAddOp2($10, 50, $11, sqlite3VdbeCurrentAddr($10) + 2 | 0);
    }
    $11 = $14;
    $15 = HEAPU8[$9 + 55 | 0] | HEAPU8[$9 + 56 | 0] << 8;
    $11 = ($15 & 3) == 2 ? HEAPU8[$1 + 28 | 0] & 128 ? $16 : $11 : $11;
    $12 = HEAP32[$12 >> 2];
    sqlite3VdbeAddOp4Int($10, 138, $3 + $13 | 0, $12, $12 + 1 | 0, HEAPU16[($15 & 8 ? 50 : 52) + $9 >> 1]);
    sqlite3VdbeChangeP5($10, $11);
   }
   $13 = $13 + 1 | 0;
   $9 = $9 + 20 | 0;
   continue;
  }
  break;
 }
 if (!(HEAPU8[$1 + 28 | 0] & 128)) {
  $9 = HEAPU8[$0 + 18 | 0];
  sqlite3VdbeAddOp3($10, 128, $2, HEAP32[($13 << 2) + $5 >> 2], $4);
  $9 = $9 ? 0 : $6 ? $6 | 1 : 33;
  $9 = $7 ? $9 | 8 : $9;
  $9 = $8 ? $9 | 16 : $9;
  if (!HEAPU8[$0 + 18 | 0]) {
   sqlite3VdbeAppendP4($10, $1, -5);
  }
  sqlite3VdbeChangeP5($10, $9 & 255);
 }
}

function fts3auxConnectMethod($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0;
 label$1: {
  label$2: {
   if ($2 - 6 >>> 0 < 4294967294) {
    break label$2;
   }
   $1 = 3;
   $6 = HEAP32[$3 + 4 >> 2];
   $7 = strlen($6);
   if (($2 | 0) == 5) {
    if (($7 | 0) != 4) {
     break label$2;
    }
    if (sqlite3_strnicmp(9403, $6, 4)) {
     break label$2;
    }
    $6 = HEAP32[$3 + 12 >> 2];
    $7 = strlen($6);
    $1 = 4;
   }
   $5 = HEAP32[($1 << 2) + $3 >> 2];
   $3 = strlen($5);
   $2 = sqlite3_declare_vtab($0, 25385);
   if ($2) {
    break label$1;
   }
   $2 = ($3 + $7 | 0) + 306 | 0;
   $1 = sqlite3_malloc64($2, 0);
   if (!$1) {
    return 7;
   }
   $2 = memset($1, 0, $2);
   $1 = $2 + 304 | 0;
   HEAP32[$2 + 32 >> 2] = $1;
   HEAP32[$2 + 12 >> 2] = $2 + 16;
   HEAP32[$2 + 272 >> 2] = 1;
   HEAP32[$2 + 28 >> 2] = $0;
   $0 = ($1 + $7 | 0) + 1 | 0;
   HEAP32[$2 + 36 >> 2] = $0;
   __memcpy($1, $6, $7);
   __memcpy($0, $5, $3);
   sqlite3Fts3Dequote(HEAP32[HEAP32[$2 + 12 >> 2] + 20 >> 2]);
   HEAP32[$4 >> 2] = $2;
   return 0;
  }
  sqlite3Fts3ErrMsg($5, 8396, 0);
  $2 = 1;
 }
 return $2 | 0;
}

function fts3ColumnMethod($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       $3 = HEAP32[$0 >> 2];
       $4 = HEAP32[$3 + 24 >> 2];
       switch ($2 - $4 | 0) {
       case 2:
        break label$4;

       case 1:
        break label$5;

       case 0:
        break label$6;

       default:
        break label$3;
       }
      }
      sqlite3_result_pointer($1, $0, 8495, 0);
      return 0;
     }
     $2 = HEAP32[$0 + 32 >> 2];
     $0 = HEAP32[$0 + 36 >> 2];
     sqlite3_result_int64($1, $2, $0);
     break label$2;
    }
    if (HEAP32[$0 + 16 >> 2]) {
     $0 = HEAP32[$0 + 20 >> 2];
     $2 = $0 >> 31;
     sqlite3_result_int64($1, $0, $2);
     break label$2;
    }
    $2 = $4;
    if (HEAP32[$3 + 44 >> 2]) {
     break label$3;
    }
    sqlite3_result_int($1, 0);
    return 0;
   }
   $3 = fts3CursorSeek(0, $0);
   if ($3) {
    break label$1;
   }
   $0 = HEAP32[$0 + 12 >> 2];
   if ((sqlite3_data_count($0) - 1 | 0) <= ($2 | 0)) {
    break label$2;
   }
   sqlite3_result_value($1, sqlite3_column_value($0, $2 + 1 | 0));
  }
  $3 = 0;
 }
 return $3 | 0;
}

function fts3ExprTermOffsetInit($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 >> 2] = 0;
 HEAP32[$3 + 4 >> 2] = 0;
 $8 = sqlite3Fts3EvalPhrasePoslist(HEAP32[$2 >> 2], $0, HEAP32[$2 + 4 >> 2], $3 + 12 | 0);
 $6 = HEAP32[HEAP32[$0 + 20 >> 2] + 64 >> 2];
 if (HEAP32[$3 + 12 >> 2]) {
  fts3GetDeltaPosition($3 + 12 | 0, $3);
  $9 = HEAP32[$3 >> 2];
  $1 = HEAP32[$3 + 4 >> 2];
  $10 = $1;
  $11 = HEAP32[$3 + 12 >> 2];
 }
 $12 = ($6 | 0) > 0 ? $6 : 0;
 while (1) {
  $1 = $7;
  $4 = $5;
  if (!(!$1 & ($12 | 0) == ($4 | 0))) {
   $0 = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 8 >> 2] = $0 + 1;
   $0 = HEAP32[$2 + 24 >> 2] + Math_imul($0, 24) | 0;
   $1 = $0;
   HEAP32[$1 + 8 >> 2] = $9;
   $4 = $10;
   HEAP32[$1 + 12 >> 2] = $4;
   HEAP32[$1 >> 2] = $11;
   $1 = ($5 ^ -1) + $6 | 0;
   $4 = $1 >> 31;
   $13 = $1;
   $1 = $0;
   HEAP32[$1 + 16 >> 2] = $13;
   HEAP32[$1 + 20 >> 2] = $4;
   $4 = $7;
   $5 = $5 + 1 | 0;
   $7 = $5 ? $4 : $4 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 16 | 0;
 return $8 | 0;
}

function sqlite3PagerSetJournalMode($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU8[$0 + 5 | 0];
 label$1: {
  label$2: {
   if (!HEAPU8[$0 + 15 | 0]) {
    break label$2;
   }
   switch ($1 - 2 | 0) {
   case 0:
   case 2:
    break label$2;

   default:
    break label$1;
   }
  }
  if (($1 | 0) == ($2 | 0)) {
   break label$1;
  }
  HEAP8[$0 + 5 | 0] = $1;
  if (!($1 & 1 | (HEAPU8[$0 + 4 | 0] | ($2 & 5) != 1))) {
   sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
   if (HEAPU8[$0 + 18 | 0] >= 2) {
    sqlite3OsDelete(HEAP32[$0 >> 2], HEAP32[$0 + 188 >> 2], 0);
    break label$1;
   }
   $2 = 0;
   $1 = HEAPU8[$0 + 17 | 0];
   $3 = $1;
   if (!$1) {
    $2 = sqlite3PagerSharedLock($0);
    $3 = HEAPU8[$0 + 17 | 0];
   }
   if (($3 | 0) == 1) {
    $2 = pagerLockDb($0, 2);
   }
   label$7: {
    if ($2) {
     break label$7;
    }
    sqlite3OsDelete(HEAP32[$0 >> 2], HEAP32[$0 + 188 >> 2], 0);
    if (($1 | 0) != 1) {
     break label$7;
    }
    pagerUnlockDb($0, 1);
    break label$1;
   }
   if ($1) {
    break label$1;
   }
   pager_unlock($0);
   break label$1;
  }
  if (($1 | 0) != 2) {
   break label$1;
  }
  sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
 }
 return HEAPU8[$0 + 5 | 0];
}

function sqlite3ExprAlloc($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  label$2: {
   if (($1 | 0) != 155) {
    break label$2;
   }
   $4 = HEAP32[$2 >> 2];
   if (!$4) {
    break label$2;
   }
   if (sqlite3GetInt32($4, $6 + 12 | 0)) {
    break label$1;
   }
  }
  $5 = HEAP32[$2 + 4 >> 2] + 1 | 0;
 }
 $4 = sqlite3DbMallocRawNN($0, $5 + 52 | 0, 0);
 if ($4) {
  $0 = memset($4, 0, 52);
  HEAP16[$0 + 34 >> 1] = 65535;
  HEAP8[$0 | 0] = $1;
  label$4: {
   if (!$2) {
    break label$4;
   }
   if (!$5) {
    $2 = HEAP32[$6 + 12 >> 2];
    HEAP32[$0 + 8 >> 2] = $2;
    HEAP32[$0 + 4 >> 2] = $2 ? 276826112 : 545261568;
    break label$4;
   }
   $5 = $0 + 52 | 0;
   HEAP32[$0 + 8 >> 2] = $5;
   $1 = 0;
   $7 = HEAP32[$2 + 4 >> 2];
   if ($7) {
    __memcpy($5, HEAP32[$2 >> 2], $7);
    $1 = HEAP32[$2 + 4 >> 2];
   }
   HEAP8[$1 + $5 | 0] = 0;
   if (!$3 | HEAP8[HEAPU8[HEAP32[$0 + 8 >> 2]] + 30288 | 0] >= 0) {
    break label$4;
   }
   sqlite3DequoteExpr($0);
  }
  HEAP32[$0 + 24 >> 2] = 1;
 }
 __stack_pointer = $6 + 16 | 0;
 return $4;
}

function dropCell($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (!HEAP32[$3 >> 2]) {
  $4 = HEAP32[$0 + 64 >> 2] + ($1 << 1) | 0;
  $5 = HEAPU8[$4 | 0] << 8 | HEAPU8[$4 + 1 | 0];
  if (HEAPU32[HEAP32[$0 + 52 >> 2] + 40 >> 2] < $5 + $2 >>> 0) {
   HEAP32[$3 >> 2] = sqlite3CorruptError(73879);
   return;
  }
  $6 = HEAPU8[$0 + 9 | 0];
  $7 = HEAP32[$0 + 56 >> 2];
  $2 = freeSpace($0, $5, $2 & 65535);
  if ($2) {
   HEAP32[$3 >> 2] = $2;
   return;
  }
  $3 = HEAPU16[$0 + 24 >> 1] - 1 | 0;
  HEAP16[$0 + 24 >> 1] = $3;
  if (!($3 & 65535)) {
   $3 = $6 + $7 | 0;
   HEAP8[$3 + 7 | 0] = 0;
   HEAP8[$3 + 1 | 0] = 0;
   HEAP8[$3 + 2 | 0] = 0;
   HEAP8[$3 + 3 | 0] = 0;
   HEAP8[$3 + 4 | 0] = 0;
   HEAP8[$3 + 5 | 0] = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] >>> 8;
   HEAP8[$3 + 6 | 0] = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2];
   HEAP32[$0 + 20 >> 2] = (HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] - (HEAPU8[$0 + 9 | 0] + HEAPU8[$0 + 10 | 0] | 0) | 0) - 8;
   return;
  }
  memmove($4, $4 + 2 | 0, ($3 & 65535) - $1 << 1);
  $3 = $6 + $7 | 0;
  HEAP8[$3 + 3 | 0] = HEAPU8[$0 + 25 | 0];
  HEAP8[$3 + 4 | 0] = HEAPU8[$0 + 24 | 0];
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 2;
 }
}

function renameUnmapSelectCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $6 = HEAP32[$0 >> 2];
 $2 = 2;
 label$1: {
  if (HEAP32[$6 + 36 >> 2]) {
   break label$1;
  }
  $2 = 1;
  if (HEAPU16[$1 + 6 >> 1] & 1056) {
   break label$1;
  }
  label$2: {
   $3 = HEAP32[$1 + 28 >> 2];
   if (!$3) {
    break label$2;
   }
   $2 = 0;
   while (1) {
    if (HEAP32[$3 >> 2] <= ($2 | 0)) {
     break label$2;
    }
    $4 = ($2 << 4) + $3 | 0;
    $5 = HEAP32[$4 + 12 >> 2];
    if (!(!$5 | HEAPU8[$4 + 17 | 0] & 3)) {
     sqlite3RenameTokenRemap($6, 0, $5);
    }
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  label$5: {
   $4 = HEAP32[$1 + 32 >> 2];
   if (!$4) {
    break label$5;
   }
   $2 = 0;
   while (1) {
    if (HEAP32[$4 >> 2] <= ($2 | 0)) {
     break label$5;
    }
    $3 = ($2 << 6) + $4 | 0;
    sqlite3RenameTokenRemap($6, 0, HEAP32[$3 + 16 >> 2]);
    $5 = HEAP32[$3 + 52 >> 2];
    label$7: {
     if (!(HEAPU8[$3 + 46 | 0] & 4)) {
      sqlite3WalkExpr($0, $5);
      break label$7;
     }
     unmapColumnIdlistNames($6, $5);
    }
    $2 = $2 + 1 | 0;
    continue;
   }
  }
  renameWalkWith($0, $1);
  $2 = 0;
 }
 return $2 | 0;
}

function vdbeSorterListToPMA($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 $2 = HEAP32[HEAP32[$0 + 8 >> 2] + 24 >> 2];
 memset($3 + 8 | 0, 0, 40);
 label$1: {
  if (!HEAP32[$0 + 40 >> 2]) {
   $2 = vdbeSorterOpenTempFile($2, $0 + 40 | 0);
   if ($2) {
    break label$1;
   }
  }
  $2 = vdbeSorterSort($0, $1);
  if ($2) {
   break label$1;
  }
  $6 = $0 + 48 | 0;
  $4 = HEAP32[$6 >> 2];
  $5 = HEAP32[$6 + 4 >> 2];
  vdbePmaWriterInit(HEAP32[$0 + 40 >> 2], $3 + 8 | 0, HEAP32[HEAP32[$0 + 8 >> 2] + 12 >> 2], $4, $5);
  HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1;
  $5 = HEAP32[$1 + 8 >> 2];
  $4 = $5 >> 31;
  vdbePmaWriteVarint($3 + 8 | 0, $5, $4);
  $2 = HEAP32[$1 >> 2];
  while (1) {
   $0 = $2;
   if ($0) {
    $2 = HEAP32[$0 + 4 >> 2];
    $4 = HEAP32[$0 >> 2];
    $5 = $4 >> 31;
    vdbePmaWriteVarint($3 + 8 | 0, $4, $5);
    vdbePmaWriteBlob($3 + 8 | 0, $0 + 8 | 0, HEAP32[$0 >> 2]);
    if (HEAP32[$1 + 4 >> 2]) {
     continue;
    }
    sqlite3_free($0);
    continue;
   }
   break;
  }
  HEAP32[$1 >> 2] = 0;
  $2 = vdbePmaWriterFinish($3 + 8 | 0, $6);
 }
 __stack_pointer = $3 + 48 | 0;
 return $2;
}

function corruptSchema($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 $3 = 7;
 label$1: {
  label$2: {
   if (HEAPU8[$5 + 87 | 0]) {
    break label$2;
   }
   if (HEAP32[HEAP32[$0 + 4 >> 2] >> 2]) {
    break label$1;
   }
   $3 = HEAP32[$0 + 16 >> 2] & 3;
   if ($3) {
    $6 = HEAP32[$1 + 4 >> 2];
    $1 = HEAP32[$1 >> 2];
    HEAP32[$4 + 44 >> 2] = $2;
    HEAP32[$4 + 32 >> 2] = $1;
    HEAP32[$4 + 36 >> 2] = $6;
    HEAP32[$4 + 40 >> 2] = HEAP32[($3 << 2) + 33388 >> 2];
    $3 = sqlite3MPrintf($5, 7232, $4 + 32 | 0);
    HEAP32[HEAP32[$0 + 4 >> 2] >> 2] = $3;
    $3 = 1;
    break label$2;
   }
   if (HEAP8[$5 + 32 | 0] & 1) {
    $3 = sqlite3CorruptError(134567);
    break label$2;
   }
   $3 = HEAP32[$1 + 4 >> 2];
   HEAP32[$4 + 16 >> 2] = $3 ? $3 : 21197;
   $3 = sqlite3MPrintf($5, 24531, $4 + 16 | 0);
   if (!(!$2 | !HEAPU8[$2 | 0])) {
    HEAP32[$4 + 4 >> 2] = $2;
    HEAP32[$4 >> 2] = $3;
    $3 = sqlite3MPrintf($5, 8306, $4);
   }
   HEAP32[HEAP32[$0 + 4 >> 2] >> 2] = $3;
   $3 = sqlite3CorruptError(134574);
  }
  HEAP32[$0 + 12 >> 2] = $3;
 }
 __stack_pointer = $4 + 48 | 0;
}

function xferCompatibleIndex($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  label$2: {
   if (HEAPU16[$0 + 50 >> 1] != HEAPU16[$1 + 50 >> 1] | HEAPU16[$0 + 52 >> 1] != HEAPU16[$1 + 52 >> 1] | HEAPU8[$0 + 54 | 0] != HEAPU8[$1 + 54 | 0]) {
    break label$2;
   }
   while (1) {
    if (HEAPU16[$1 + 50 >> 1] > $3 >>> 0) {
     $4 = $3 << 1;
     $2 = HEAPU16[$4 + HEAP32[$1 + 4 >> 2] >> 1];
     if (($2 | 0) != HEAPU16[HEAP32[$0 + 4 >> 2] + $4 >> 1]) {
      break label$1;
     }
     if (($2 | 0) == 65534) {
      $4 = 0;
      $2 = $3 << 4;
      if (sqlite3ExprCompare(0, HEAP32[($2 + HEAP32[$1 + 40 >> 2] | 0) + 8 >> 2], HEAP32[(HEAP32[$0 + 40 >> 2] + $2 | 0) + 8 >> 2], -1)) {
       break label$2;
      }
     }
     if (HEAPU8[HEAP32[$1 + 28 >> 2] + $3 | 0] != HEAPU8[HEAP32[$0 + 28 >> 2] + $3 | 0]) {
      break label$1;
     }
     $2 = $3 << 2;
     $3 = $3 + 1 | 0;
     $4 = 0;
     if (!sqlite3_stricmp(HEAP32[HEAP32[$1 + 32 >> 2] + $2 >> 2], HEAP32[HEAP32[$0 + 32 >> 2] + $2 >> 2])) {
      continue;
     }
     break label$2;
    }
    break;
   }
   $4 = !sqlite3ExprCompare(0, HEAP32[$1 + 36 >> 2], HEAP32[$0 + 36 >> 2], -1);
  }
  return $4;
 }
 return 0;
}

function sqlite3Reindex($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  if (sqlite3ReadSchema($0)) {
   break label$1;
  }
  if (!$1) {
   reindexDatabases($0, 0);
   break label$1;
  }
  if (!(HEAP32[$2 >> 2] ? $2 : 0)) {
   $3 = sqlite3NameFromToken(HEAP32[$0 >> 2], $1);
   if (!$3) {
    break label$1;
   }
   if (sqlite3FindCollSeq($4, HEAPU8[$4 + 84 | 0], $3, 0)) {
    reindexDatabases($0, $3);
    sqlite3DbFree($4, $3);
    break label$1;
   }
   sqlite3DbFree($4, $3);
  }
  $2 = sqlite3TwoPartName($0, $1, $2, $5 + 12 | 0);
  if (($2 | 0) < 0) {
   break label$1;
  }
  $1 = sqlite3NameFromToken($4, HEAP32[$5 + 12 >> 2]);
  if (!$1) {
   break label$1;
  }
  $6 = HEAP32[HEAP32[$4 + 16 >> 2] + ($2 << 4) >> 2];
  $3 = sqlite3FindTable($4, $1, $6);
  if ($3) {
   reindexTable($0, $3, 0);
   sqlite3DbFree($4, $1);
   break label$1;
  }
  $3 = sqlite3FindIndex($4, $1, $6);
  sqlite3DbFree($4, $1);
  if ($3) {
   sqlite3BeginWriteOperation($0, 0, $2);
   sqlite3RefillIndex($0, $3, -1);
   break label$1;
  }
  sqlite3ErrorMsg($0, 14619, 0);
 }
 __stack_pointer = $5 + 16 | 0;
}

function memjrnlTruncate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = HEAP32[$0 + 16 >> 2];
 $3 = $1;
 $3 = $4 >>> 0 > $3 >>> 0;
 $6 = HEAP32[$0 + 20 >> 2];
 $4 = $6;
 if ($3 & ($4 | 0) >= ($2 | 0) | ($2 | 0) < ($4 | 0)) {
  label$2: {
   label$3: {
    if (!($2 | $1)) {
     $5 = $0 + 12 | 0;
     break label$3;
    }
    $5 = $0 + 12 | 0;
    $3 = HEAP32[$0 + 4 >> 2];
    $6 = $3 >> 31;
    $9 = $3;
    $4 = $3;
    $3 = $6;
    while (1) {
     $5 = HEAP32[$5 >> 2];
     if ($5) {
      $7 = $1 >>> 0 > $4 >>> 0 & ($2 | 0) >= ($3 | 0) | ($2 | 0) > ($3 | 0);
      $8 = $3 + $6 | 0;
      $3 = $9;
      $4 = $3 + $4 | 0;
      $8 = $3 >>> 0 > $4 >>> 0 ? $8 + 1 | 0 : $8;
      $3 = $8;
      if ($7) {
       continue;
      }
     }
     break;
    }
    $7 = $5;
    if ($5) {
     break label$3;
    }
    $7 = 0;
    break label$2;
   }
   memjrnlFreeChunks(HEAP32[$5 >> 2]);
   HEAP32[$5 >> 2] = 0;
  }
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $2;
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 36 >> 2] = 0;
  HEAP32[$0 + 40 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = $7;
 }
 return 0;
}

function sqlite3Fts3DoclistNext($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $7 = HEAP32[$3 >> 2];
 HEAP32[$6 + 12 >> 2] = $7;
 label$1: {
  if (!$7) {
   $1 = sqlite3Fts3GetVarint($1, $4) + $1 | 0;
   break label$1;
  }
  fts3PoslistCopy(0, $6 + 12 | 0);
  $7 = $1 + $2 | 0;
  $1 = HEAP32[$6 + 12 >> 2];
  label$3: {
   while (1) {
    if ($1 >>> 0 < $7 >>> 0) {
     if (HEAPU8[$1 | 0]) {
      break label$3;
     }
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP8[$5 | 0] = 1;
   break label$1;
  }
  $7 = sqlite3Fts3GetVarint($1, $6);
  $5 = $4;
  $10 = HEAP32[$5 >> 2];
  $2 = HEAP32[$5 + 4 >> 2];
  $11 = $2;
  $2 = HEAP32[$6 >> 2];
  $8 = $2;
  $9 = 0 - $2 | 0;
  $5 = HEAP32[$6 + 4 >> 2];
  $2 = $5;
  $12 = 0 - ($2 + (($8 | 0) != 0) | 0) | 0;
  $2 = $0;
  $8 = $2 ? $9 : $8;
  $0 = $8;
  $8 = $2 ? $12 : $5;
  $9 = $8 + $11 | 0;
  $2 = $10;
  $5 = $0 + $2 | 0;
  $9 = $0 >>> 0 > $5 >>> 0 ? $9 + 1 | 0 : $9;
  $2 = $4;
  HEAP32[$2 >> 2] = $5;
  HEAP32[$2 + 4 >> 2] = $9;
  $1 = $1 + $7 | 0;
 }
 HEAP32[$3 >> 2] = $1;
 __stack_pointer = $6 + 16 | 0;
}

function RegisterExtensionFunctions($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 while (1) {
  if (($2 | 0) == 40) {
   while (1) {
    if (($4 | 0) != 6) {
     $1 = $4 << 4;
     $3 = $1 + 55904 | 0;
     $2 = 0;
     label$5: {
      label$6: {
       switch (HEAPU8[$1 + 55909 | 0] - 1 | 0) {
       case 0:
        $2 = $0;
        break label$5;

       case 1:
        break label$6;

       default:
        break label$5;
       }
      }
      $2 = -1;
     }
     sqlite3_create_function($0, HEAP32[$3 >> 2], HEAP8[$1 + 55908 | 0], 1, $2, 0, HEAP32[$1 + 55912 >> 2], HEAP32[$1 + 55916 >> 2]);
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
  } else {
   $1 = Math_imul($2, 12);
   $5 = $1 + 55424 | 0;
   $3 = 0;
   label$9: {
    label$10: {
     switch (HEAPU8[$1 + 55429 | 0] - 1 | 0) {
     case 0:
      $3 = $0;
      break label$9;

     case 1:
      break label$10;

     default:
      break label$9;
     }
    }
    $3 = -1;
   }
   sqlite3_create_function($0, HEAP32[$5 >> 2], HEAP8[$1 + 55428 | 0], HEAPU8[$1 + 55430 | 0], $3, HEAP32[$1 + 55432 >> 2], 0, 0);
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 return 0;
}

function getOverflowPage($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = 0;
 label$1: {
  label$2: {
   if (!HEAPU8[$0 + 17 | 0]) {
    break label$2;
   }
   $7 = HEAP32[16232];
   $4 = $1;
   while (1) {
    $6 = $4;
    $4 = $4 + 1 | 0;
    if (($4 | 0) == (ptrmapPageno($0, $4) | 0) | (($7 >>> 0) / HEAPU32[$0 + 36 >> 2] | 0) == ($6 | 0)) {
     continue;
    }
    break;
   }
   if (btreePagecount($0) >>> 0 < $4 >>> 0) {
    break label$2;
   }
   $6 = ptrmapGet($0, $4, $5 + 7 | 0, $5 + 8 | 0);
   if (!($6 | HEAPU8[$5 + 7 | 0] != 4)) {
    if (HEAP32[$5 + 8 >> 2] != ($1 | 0)) {
     break label$2;
    }
    $6 = 101;
    break label$1;
   }
   $4 = 0;
   if ($6) {
    break label$1;
   }
  }
  $4 = 0;
  $6 = btreeGetPage($0, $1, $5 + 12 | 0, !$2 << 1);
  if ($6) {
   break label$1;
  }
  $6 = 0;
  $4 = sqlite3Get4byte(HEAP32[HEAP32[$5 + 12 >> 2] + 56 >> 2]);
 }
 HEAP32[$3 >> 2] = $4;
 $4 = HEAP32[$5 + 12 >> 2];
 label$5: {
  if ($2) {
   HEAP32[$2 >> 2] = $4;
   break label$5;
  }
  releasePage($4);
 }
 __stack_pointer = $5 + 16 | 0;
 return ($6 | 0) == 101 ? 0 : $6;
}

function fts3SnippetFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (($1 | 0) >= 7) {
   sqlite3_result_error($0, 25979, -1);
   break label$1;
  }
  if (fts3FunctionArg($0, 3164, HEAP32[$2 >> 2], $3 + 12 | 0)) {
   break label$1;
  }
  $4 = 15;
  $8 = -1;
  $5 = 21210;
  $6 = 21216;
  $7 = 21206;
  label$3: {
   switch ($1 - 2 | 0) {
   case 4:
    $4 = sqlite3_value_int(HEAP32[$2 + 20 >> 2]);

   case 3:
    $8 = sqlite3_value_int(HEAP32[$2 + 16 >> 2]);

   case 2:
    $5 = sqlite3_value_text(HEAP32[$2 + 12 >> 2]);

   case 1:
    $6 = sqlite3_value_text(HEAP32[$2 + 8 >> 2]);

   case 0:
    $7 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
    break;

   default:
    break label$3;
   }
  }
  if ($7 ? !$5 | !$6 : 1) {
   sqlite3_result_error_nomem($0);
   break label$1;
  }
  if (!$4) {
   sqlite3_result_text($0, 29623, -1, 0);
   break label$1;
  }
  $1 = HEAP32[$3 + 12 >> 2];
  if (fts3CursorSeek($0, $1)) {
   break label$1;
  }
  sqlite3Fts3Snippet($0, $1, $7, $6, $5, $8, $4);
 }
 __stack_pointer = $3 + 16 | 0;
}

function asin($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 $5 = wasm2js_scratch_load_i32(0) | 0;
 $2 = $3 & 2147483647;
 if ($2 >>> 0 >= 1072693248) {
  if (!($2 - 1072693248 | $5)) {
   return $0 * 1.5707963267948966 + 752316384526264e-51;
  }
  return 0 / ($0 - $0);
 }
 label$3: {
  if ($2 >>> 0 <= 1071644671) {
   if ($2 + -1048576 >>> 0 < 1044381696) {
    break label$3;
   }
   return $0 * R_1($0 * $0) + $0;
  }
  $4 = (1 - fabs($0)) * .5;
  $0 = sqrt($4);
  $1 = R_1($4);
  label$5: {
   if ($2 >>> 0 >= 1072640819) {
    $0 = $0 * $1 + $0;
    $0 = 1.5707963267948966 - ($0 + $0 + -6123233995736766e-32);
    break label$5;
   }
   $6 = ($0 + $0) * $1;
   wasm2js_scratch_store_f64(+$0);
   $2 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   wasm2js_scratch_store_i32(0, 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $1 = +wasm2js_scratch_load_f64();
   $0 = ($4 - $1 * $1) / ($0 + $1);
   $0 = .7853981633974483 - ($1 + $1) - ($6 - (6123233995736766e-32 - ($0 + $0))) + .7853981633974483;
  }
  $0 = ($3 | 0) < 0 ? -$0 : $0;
 }
 return $0;
}

function __floatditf($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 label$1: {
  if (!($2 | $1)) {
   $1 = 0;
   break label$1;
  }
  $3 = $2 >> 31;
  $6 = $3;
  $3 = $2;
  $9 = $6 ^ $3;
  $7 = $1;
  $5 = $3 >> 31;
  $3 = $7 ^ $5;
  $1 = $3 - $5 | 0;
  $7 = $6;
  $4 = $7 + ($3 >>> 0 < $5 >>> 0) | 0;
  $4 = $9 - $4 | 0;
  $3 = $1;
  $5 = Math_clz32($4);
  $1 = ($5 | 0) == 32 ? Math_clz32($3) + 32 | 0 : $5;
  __ashlti3($8, $3, $4, 0, 0, $1 + 49 | 0);
  $3 = $8;
  $4 = HEAP32[$3 + 8 >> 2];
  $3 = $4;
  $6 = $3;
  $3 = 16446 - $1 << 16;
  $1 = $3;
  $4 = HEAP32[$8 + 12 >> 2] ^ 65536;
  $3 = $4;
  $1 = $1 + $3 | 0;
  $5 = 0;
  $4 = $6;
  $7 = $5 + $4 | 0;
  $1 = $7 >>> 0 < $5 >>> 0 ? $1 + 1 | 0 : $1;
  $6 = $1;
  $1 = $2;
  $4 = $1 & -2147483648;
  $1 = $7;
  $5 = 0 | $1;
  $3 = $4;
  $4 = $6;
  $3 = $3 | $4;
  $6 = $3;
  $1 = HEAP32[$8 + 4 >> 2];
  $7 = $1;
  $4 = $8;
  $3 = HEAP32[$4 >> 2];
  $1 = $3;
 }
 $3 = $0;
 HEAP32[$3 >> 2] = $1;
 $1 = $7;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$0 + 8 >> 2] = $5;
 $1 = $6;
 HEAP32[$3 + 12 >> 2] = $1;
 __stack_pointer = $8 + 16 | 0;
}

function pcacheManageDirtyList($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$0 + 12 >> 2];
 label$1: {
  if (!($1 & 1)) {
   break label$1;
  }
  if (HEAP32[$2 + 8 >> 2] == ($0 | 0)) {
   HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 36 >> 2];
  }
  $3 = HEAP32[$0 + 36 >> 2];
  label$3: {
   label$4: {
    $4 = HEAP32[$0 + 32 >> 2];
    if (!$4) {
     HEAP32[$2 + 4 >> 2] = $3;
     if (!$3) {
      break label$4;
     }
     break label$3;
    }
    HEAP32[$4 + 36 >> 2] = $3;
    $3 = HEAP32[$0 + 36 >> 2];
    if ($3) {
     break label$3;
    }
    HEAP32[$2 >> 2] = $4;
    break label$1;
   }
   HEAP8[$2 + 33 | 0] = 2;
   HEAP32[$2 >> 2] = 0;
   break label$1;
  }
  HEAP32[$3 + 32 >> 2] = $4;
 }
 label$6: {
  if (!($1 & 2)) {
   break label$6;
  }
  HEAP32[$0 + 36 >> 2] = 0;
  $1 = HEAP32[$2 >> 2];
  HEAP32[$0 + 32 >> 2] = $1;
  label$7: {
   if ($1) {
    HEAP32[$1 + 36 >> 2] = $0;
    break label$7;
   }
   HEAP32[$2 + 4 >> 2] = $0;
   if (!HEAPU8[$2 + 32 | 0]) {
    break label$7;
   }
   HEAP8[$2 + 33 | 0] = 1;
  }
  HEAP32[$2 >> 2] = $0;
  if (HEAP32[$2 + 8 >> 2] | HEAPU8[$0 + 28 | 0] & 8) {
   break label$6;
  }
  HEAP32[$2 + 8 >> 2] = $0;
 }
}

function walWriteToLog($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = $0;
 $7 = HEAP32[$6 + 8 >> 2];
 $8 = $7;
 $6 = $7;
 $5 = HEAP32[$0 + 12 >> 2];
 $11 = $5;
 $12 = $6 >>> 0 <= $3 >>> 0 & ($4 | 0) >= ($5 | 0) | ($4 | 0) > ($5 | 0);
 $5 = $2;
 $6 = $5 >> 31;
 $10 = $3 + $5 | 0;
 $5 = $4;
 $9 = $6 + $5 | 0;
 $7 = $8;
 $6 = $10;
 $9 = $3 >>> 0 > $6 >>> 0 ? $9 + 1 | 0 : $9;
 label$1: {
  if (!($7 >>> 0 > $6 >>> 0 & ($11 | 0) >= ($9 | 0) | ($9 | 0) < ($11 | 0) | $12)) {
   $12 = $3;
   $5 = $8 - $3 | 0;
   $8 = $5;
   $6 = $11;
   $10 = $4 + ($3 >>> 0 > $7 >>> 0) | 0;
   $10 = $6 - $10 | 0;
   $8 = $5;
   $5 = sqlite3OsWrite(HEAP32[$0 + 4 >> 2], $1, $5, $3, $4);
   if ($5) {
    break label$1;
   }
   $5 = sqlite3OsSync(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 16 >> 2] & 3);
   $2 = $2 - $8 | 0;
   if ($5 | !$2) {
    break label$1;
   }
   $6 = $8;
   $7 = $6;
   $6 = $6 >> 31;
   $9 = $7 + $3 | 0;
   $5 = $4 + $6 | 0;
   $3 = $9;
   $5 = $3 >>> 0 < $12 >>> 0 ? $5 + 1 | 0 : $5;
   $4 = $5;
   $1 = $1 + $8 | 0;
  }
  $5 = $4;
  $5 = sqlite3OsWrite(HEAP32[$0 + 4 >> 2], $1, $2, $3, $5);
 }
 return $5;
}

function parseTimezone($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 while (1) {
  $3 = $0;
  $0 = $3 + 1 | 0;
  if (HEAP8[HEAPU8[$3 | 0] + 30288 | 0] & 1) {
   continue;
  }
  break;
 }
 HEAP32[$1 + 28 >> 2] = 0;
 $5 = -1;
 label$2: {
  label$3: {
   label$4: {
    label$5: {
     label$6: {
      $4 = HEAPU8[$3 | 0];
      switch ($4 - 43 | 0) {
      case 2:
       break label$4;

      case 0:
       break label$5;

      default:
       break label$6;
      }
     }
     if (($4 & 223) == 90) {
      break label$3;
     }
     $4 = ($4 | 0) != 0;
     break label$2;
    }
    $5 = 1;
   }
   HEAP32[$2 + 4 >> 2] = $2 + 8;
   HEAP32[$2 >> 2] = $2 + 12;
   $4 = 1;
   if ((getDigits($0, 14199, $2) | 0) != 2) {
    break label$2;
   }
   HEAP32[$1 + 28 >> 2] = Math_imul(HEAP32[$2 + 8 >> 2] + Math_imul(HEAP32[$2 + 12 >> 2], 60) | 0, $5);
   $0 = $3 + 6 | 0;
  }
  while (1) {
   $3 = $0;
   $0 = $3 + 1 | 0;
   if (HEAP8[HEAPU8[$3 | 0] + 30288 | 0] & 1) {
    continue;
   }
   break;
  }
  HEAP8[$1 + 45 | 0] = 1;
  $4 = HEAPU8[$3 | 0] != 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $4;
}

function dateFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 label$1: {
  if (isDate($0, $1, $2, $3 + 16 | 0)) {
   break label$1;
  }
  computeYMD($3 + 16 | 0);
  HEAP8[$3 + 5 | 0] = 45;
  HEAP8[$3 + 8 | 0] = 45;
  HEAP8[$3 + 11 | 0] = 0;
  $2 = HEAP32[$3 + 28 >> 2];
  $1 = ($2 | 0) / 10 | 0;
  HEAP8[$3 + 6 | 0] = (($1 | 0) % 10 | 0) + 48;
  $4 = HEAP32[$3 + 32 >> 2];
  $5 = ($4 | 0) / 10 | 0;
  HEAP8[$3 + 9 | 0] = (($5 | 0) % 10 | 0) + 48;
  HEAP8[$3 + 7 | 0] = ($2 - Math_imul($1, 10) | 0) + 48;
  HEAP8[$3 + 10 | 0] = ($4 - Math_imul($5, 10) | 0) + 48;
  $1 = HEAP32[$3 + 24 >> 2];
  $2 = $1 >> 31;
  $2 = ($1 ^ $2) - $2 | 0;
  HEAP8[$3 + 2 | 0] = (($2 >>> 0) / 100 >>> 0) % 10 | 48;
  HEAP8[$3 + 1 | 0] = (($2 >>> 0) / 1e3 >>> 0) % 10 | 48;
  $4 = ($2 >>> 0) / 10 | 0;
  HEAP8[$3 + 3 | 0] = ($4 >>> 0) % 10 | 48;
  HEAP8[$3 + 4 | 0] = $2 - Math_imul($4, 10) | 48;
  if (($1 | 0) < 0) {
   HEAP8[$3 | 0] = 45;
   sqlite3_result_text($0, $3, 11, -1);
   break label$1;
  }
  sqlite3_result_text($0, $3 | 1, 10, -1);
 }
 __stack_pointer = $3 - -64 | 0;
}

function sqlite3VtabSavepoint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  label$2: {
   if (!HEAP32[$0 + 404 >> 2]) {
    break label$2;
   }
   $7 = $2 + 1 | 0;
   while (1) {
    if ($5) {
     break label$1;
    }
    if (HEAP32[$0 + 380 >> 2] <= ($6 | 0)) {
     break label$2;
    }
    $5 = 0;
    $4 = HEAP32[HEAP32[$0 + 404 >> 2] + ($6 << 2) >> 2];
    label$4: {
     if (!HEAP32[$4 + 8 >> 2]) {
      break label$4;
     }
     $3 = HEAP32[HEAP32[$4 + 4 >> 2] >> 2];
     if (HEAP32[$3 >> 2] < 2) {
      break label$4;
     }
     sqlite3VtabLock($4);
     label$5: {
      label$6: {
       switch ($1 | 0) {
       case 0:
        $3 = HEAP32[$3 + 80 >> 2];
        HEAP32[$4 + 20 >> 2] = $7;
        break label$5;

       case 2:
        $3 = HEAP32[$3 + 88 >> 2];
        break label$5;

       default:
        break label$6;
       }
      }
      $3 = HEAP32[$3 + 84 >> 2];
     }
     if (!(!$3 | HEAP32[$4 + 20 >> 2] <= ($2 | 0))) {
      $5 = FUNCTION_TABLE[$3 | 0](HEAP32[$4 + 8 >> 2], $2) | 0;
     }
     sqlite3VtabUnlock($4);
    }
    $6 = $6 + 1 | 0;
    continue;
   }
  }
  $5 = 0;
 }
 return $5;
}

function fts3DoOptimize($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 $2 = sqlite3Fts3PendingTermsFlush($0);
 label$1: {
  if ($2) {
   break label$1;
  }
  $2 = fts3SqlStmt($0, 27, $3 + 12 | 0, 0);
  if ($2) {
   break label$1;
  }
  $4 = HEAP32[$3 + 12 >> 2];
  sqlite3_bind_int($4, 1, HEAP32[$0 + 280 >> 2]);
  sqlite3_bind_int($4, 2, HEAP32[$0 + 256 >> 2]);
  label$2: while (1) {
   if ((sqlite3_step($4) | 0) == 100) {
    $2 = 0;
    $6 = sqlite3_column_int($4, 0);
    while (1) {
     if (HEAP32[$0 + 256 >> 2] <= ($2 | 0) | $5) {
      continue label$2;
     }
     $5 = fts3SegmentMerge($0, $6, $2, -2);
     $2 = $2 + 1 | 0;
     if (($5 | 0) != 101) {
      continue;
     }
     $5 = 0;
     $7 = 1;
     continue;
    }
   }
   break;
  }
  $2 = (wasm2js_i32$0 = $5, wasm2js_i32$1 = sqlite3_reset($4), wasm2js_i32$2 = $5, 
  wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
 }
 sqlite3Fts3SegmentsClose($0);
 __stack_pointer = $3 + 16 | 0;
 return $1 ? $2 ? $2 : $7 ? 101 : $2 : $2;
}

function walMergesort($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 $8 = HEAP32[$3 >> 2];
 HEAP32[$4 + 108 >> 2] = 0;
 HEAP32[$4 + 104 >> 2] = 0;
 $4 = memset($4, 0, 104);
 $9 = ($8 | 0) > 0 ? $8 : 0;
 while (1) {
  if (($7 | 0) == ($9 | 0)) {
   while (1) {
    $5 = $5 + 1 | 0;
    if ($5 >>> 0 <= 12) {
     if (!($8 >>> $5 & 1)) {
      continue;
     }
     $6 = ($5 << 3) + $4 | 0;
     walMerge($0, HEAP32[$6 + 4 >> 2], HEAP32[$6 >> 2], $4 + 104 | 0, $4 + 108 | 0, $1);
     continue;
    }
    break;
   }
  } else {
   HEAP32[$4 + 108 >> 2] = 1;
   HEAP32[$4 + 104 >> 2] = ($7 << 1) + $2;
   $5 = 0;
   while (1) {
    if ($7 >>> $5 & 1) {
     $6 = ($5 << 3) + $4 | 0;
     walMerge($0, HEAP32[$6 + 4 >> 2], HEAP32[$6 >> 2], $4 + 104 | 0, $4 + 108 | 0, $1);
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   $6 = ($5 << 3) + $4 | 0;
   HEAP32[$6 + 4 >> 2] = HEAP32[$4 + 104 >> 2];
   HEAP32[$6 >> 2] = HEAP32[$4 + 108 >> 2];
   $7 = $7 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$3 >> 2] = HEAP32[$4 + 108 >> 2];
 __stack_pointer = $4 + 112 | 0;
}

function vdbeCloseStatement($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = HEAP32[$0 + 48 >> 2] - 1 | 0;
 $2 = HEAP32[$0 >> 2];
 $8 = ($1 | 0) != 2;
 while (1) {
  if (($5 | 0) < HEAP32[$2 + 20 >> 2]) {
   $6 = HEAP32[(HEAP32[$2 + 16 >> 2] + ($5 << 4) | 0) + 4 >> 2];
   if ($6) {
    label$4: {
     if (!$8) {
      $7 = sqlite3BtreeSavepoint($6, 2, $3);
      if ($7) {
       break label$4;
      }
     }
     $7 = sqlite3BtreeSavepoint($6, 1, $3);
    }
    $4 = $4 ? $4 : $7;
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$2 + 504 >> 2] = HEAP32[$2 + 504 >> 2] - 1;
 HEAP32[$0 + 48 >> 2] = 0;
 label$6: {
  label$7: {
   if (!$4) {
    if (($1 | 0) == 2) {
     $4 = sqlite3VtabSavepoint($2, 2, $3);
     if ($4) {
      break label$7;
     }
    }
    $4 = sqlite3VtabSavepoint($2, 1, $3);
   }
   if (($1 | 0) != 2) {
    break label$6;
   }
  }
  $1 = HEAP32[$0 + 76 >> 2];
  $3 = HEAP32[$0 + 72 >> 2];
  HEAP32[$2 + 512 >> 2] = $3;
  HEAP32[$2 + 516 >> 2] = $1;
  $3 = HEAP32[$0 + 84 >> 2];
  $1 = HEAP32[$0 + 80 >> 2];
  HEAP32[$2 + 520 >> 2] = $1;
  HEAP32[$2 + 524 >> 2] = $3;
 }
 return $4;
}

function sqlite3SelectNew($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0;
 $10 = __stack_pointer - 80 | 0;
 __stack_pointer = $10;
 $11 = sqlite3DbMallocRawNN(HEAP32[$0 >> 2], 76, 0);
 $9 = $11 ? $11 : $10;
 if (!$1) {
  $1 = sqlite3ExprListAppend($0, 0, sqlite3Expr(HEAP32[$0 >> 2], 180, 0));
 }
 HEAP32[$9 + 28 >> 2] = $1;
 HEAP8[$9 | 0] = 138;
 HEAP32[$9 + 8 >> 2] = 0;
 HEAP32[$9 + 12 >> 2] = 0;
 HEAP32[$9 + 4 >> 2] = $7;
 $1 = HEAP32[$0 + 100 >> 2] + 1 | 0;
 HEAP32[$0 + 100 >> 2] = $1;
 HEAP32[$9 + 20 >> 2] = -1;
 HEAP32[$9 + 24 >> 2] = -1;
 HEAP32[$9 + 16 >> 2] = $1;
 HEAP16[$9 + 2 >> 1] = 0;
 if (!$2) {
  $2 = sqlite3DbMallocZero(HEAP32[$0 >> 2], 72, 0);
 }
 HEAP32[$9 + 72 >> 2] = 0;
 HEAP32[$9 + 64 >> 2] = 0;
 HEAP32[$9 + 68 >> 2] = 0;
 HEAP32[$9 + 60 >> 2] = $8;
 HEAP32[$9 + 52 >> 2] = 0;
 HEAP32[$9 + 56 >> 2] = 0;
 HEAP32[$9 + 48 >> 2] = $6;
 HEAP32[$9 + 44 >> 2] = $5;
 HEAP32[$9 + 40 >> 2] = $4;
 HEAP32[$9 + 36 >> 2] = $3;
 HEAP32[$9 + 32 >> 2] = $2;
 $0 = HEAP32[$0 >> 2];
 if (HEAPU8[$0 + 87 | 0]) {
  clearSelect($0, $9, ($9 | 0) != ($10 | 0));
  $11 = 0;
 }
 __stack_pointer = $10 + 80 | 0;
 return $11;
}

function sqlite3_soft_heap_limit64($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $7 = -1;
 $8 = -1;
 $2 = -1;
 label$1: {
  if (sqlite3_initialize()) {
   break label$1;
  }
  $2 = HEAP32[17618];
  $7 = $2;
  $3 = HEAP32[17619];
  $8 = $3;
  $2 = 0;
  $3 = $1;
  if (($3 | 0) < 0) {
   break label$1;
  }
  $3 = HEAP32[17621];
  $6 = $3;
  $4 = HEAP32[17620];
  $9 = $4;
  $2 = $4;
  $3 = $1;
  $4 = $6;
  $5 = $0 >>> 0 > $2 >>> 0 & ($3 | 0) >= ($4 | 0) | ($3 | 0) > ($4 | 0);
  $4 = $5 ? $2 : $0;
  $2 = $5 ? $6 : $3;
  $5 = $2;
  $3 = !($3 | $0);
  $10 = $3 ? $9 : $4;
  $2 = $6;
  $4 = $5;
  $5 = $3 ? $2 : $4;
  $3 = $9;
  $4 = !!$3 & ($2 | 0) >= 0 | ($2 | 0) > 0;
  $0 = $4 ? $10 : $0;
  $3 = $5;
  $2 = $4 ? $3 : $1;
  $1 = $2;
  HEAP32[17618] = $0;
  HEAP32[17619] = $2;
  $4 = $0;
  $5 = ($2 | $4) != 0;
  $4 = sqlite3StatusValue();
  $3 = $4;
  $2 = i64toi32_i32$HIGH_BITS;
  $4 = $1;
  HEAP32[17622] = ($0 >>> 0 <= $3 >>> 0 & ($2 | 0) >= ($4 | 0) | ($4 | 0) < ($2 | 0)) & $5;
  sqlite3_memory_used();
  $2 = i64toi32_i32$HIGH_BITS;
 }
 $2 = $8;
 i64toi32_i32$HIGH_BITS = $2;
 $3 = $7;
 return $3;
}

function windowAggFinal($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$0 + 4 >> 2];
 $2 = sqlite3GetVdbe(HEAP32[$0 >> 2]);
 $0 = $3;
 while (1) {
  if ($0) {
   label$3: {
    if (!(HEAP32[$3 + 88 >> 2] | !(HEAPU8[HEAP32[$0 + 44 >> 2] + 5 | 0] & 16) | HEAPU8[$0 + 17 | 0] == 90)) {
     sqlite3VdbeAddOp2($2, 75, 0, HEAP32[$0 + 56 >> 2]);
     sqlite3VdbeAddOp1($2, 31, HEAP32[$0 + 60 >> 2]);
     sqlite3VdbeAddOp3($2, 94, HEAP32[$0 + 60 >> 2], 0, HEAP32[$0 + 56 >> 2]);
     sqlite3VdbeJumpHere($2, sqlite3VdbeCurrentAddr($2) - 2 | 0);
     break label$3;
    }
    if (HEAP32[$0 + 64 >> 2]) {
     break label$3;
    }
    $4 = windowArgCount($0);
    $5 = HEAP32[$0 + 52 >> 2];
    if ($1) {
     sqlite3VdbeAddOp2($2, 165, $5, $4);
     sqlite3VdbeAppendP4($2, HEAP32[$0 + 44 >> 2], -7);
     sqlite3VdbeAddOp2($2, 80, HEAP32[$0 + 52 >> 2], HEAP32[$0 + 56 >> 2]);
     sqlite3VdbeAddOp2($2, 75, 0, HEAP32[$0 + 52 >> 2]);
     break label$3;
    }
    sqlite3VdbeAddOp3($2, 164, $5, $4, HEAP32[$0 + 56 >> 2]);
    sqlite3VdbeAppendP4($2, HEAP32[$0 + 44 >> 2], -7);
   }
   $0 = HEAP32[$0 + 36 >> 2];
   continue;
  }
  break;
 }
}

function sqlite3TriggerStepSrc($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $5 = HEAP32[$0 >> 2];
 $6 = sqlite3DbStrDup($5, HEAP32[$1 + 12 >> 2]);
 label$1: {
  label$2: {
   label$3: {
    $4 = sqlite3SrcListAppend($0, 0, 0, 0);
    if ($4) {
     $2 = HEAP32[HEAP32[$1 + 4 >> 2] + 20 >> 2];
     HEAP32[$4 + 16 >> 2] = $6;
     if (HEAP32[HEAP32[$5 + 16 >> 2] + 28 >> 2] != ($2 | 0)) {
      HEAP32[$4 + 8 >> 2] = $2;
     }
     $2 = HEAP32[$1 + 16 >> 2];
     if (!$2) {
      $2 = $4;
      break label$1;
     }
     $2 = sqlite3SrcListDup($5, $2, 0);
     $1 = 0;
     if (!$2) {
      break label$2;
     }
     if (HEAP32[$2 >> 2] < 2 | HEAPU8[$0 + 208 | 0] > 1) {
      break label$3;
     }
     $1 = sqlite3SelectNew($0, 0, $2, 0, 0, 0, 0, 2048, 0);
     HEAP32[$3 + 8 >> 2] = 0;
     HEAP32[$3 + 12 >> 2] = 0;
     $1 = sqlite3SrcListAppendFromTerm($0, 0, 0, 0, $3 + 8 | 0, $1, 0);
     break label$2;
    }
    sqlite3DbFree($5, $6);
    break label$1;
   }
   $1 = $2;
  }
  $2 = sqlite3SrcListAppendList($0, $4, $1);
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3Fts3MsrOvfl($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $8 = HEAP32[$0 >> 2];
 $9 = HEAP32[$8 + 244 >> 2];
 $0 = 0;
 while (1) {
  label$2: {
   label$3: {
    if (!(HEAP32[$1 + 4 >> 2] <= ($7 | 0) | $0)) {
     $4 = HEAP32[HEAP32[$1 >> 2] + ($7 << 2) >> 2];
     if (HEAP32[$4 + 56 >> 2] | HEAPU8[$4 + 5 | 0]) {
      break label$3;
     }
     $5 = HEAP32[$4 + 8 >> 2];
     $3 = HEAP32[$4 + 12 >> 2];
     while (1) {
      $0 = HEAP32[$4 + 20 >> 2];
      if (HEAPU32[$4 + 16 >> 2] < $5 >>> 0 & ($0 | 0) <= ($3 | 0) | ($3 | 0) > ($0 | 0)) {
       break label$3;
      }
      $0 = sqlite3Fts3ReadBlock($8, $5, $3, 0, $6 + 12 | 0);
      if ($0) {
       break label$2;
      }
      $0 = HEAP32[$6 + 12 >> 2];
      if (($0 + 35 | 0) > ($9 | 0)) {
       $10 = (($0 + 34 | 0) / ($9 | 0) | 0) + $10 | 0;
      }
      $5 = $5 + 1 | 0;
      $3 = $5 ? $3 : $3 + 1 | 0;
      continue;
     }
    }
    HEAP32[$2 >> 2] = $10;
    __stack_pointer = $6 + 16 | 0;
    return $0;
   }
   $0 = 0;
  }
  $7 = $7 + 1 | 0;
  continue;
 }
}

function fts3EvalPhraseMergeToken($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1: {
  if (!$3) {
   sqlite3_free(HEAP32[$1 >> 2]);
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $3 = 0;
   break label$1;
  }
  $6 = HEAP32[$1 + 44 >> 2];
  if (($6 | 0) < 0) {
   HEAP32[$1 + 4 >> 2] = $4;
   HEAP32[$1 >> 2] = $3;
   $3 = 0;
   break label$1;
  }
  $7 = HEAP32[$1 >> 2];
  if (!$7) {
   sqlite3_free($3);
   $3 = 0;
   break label$1;
  }
  label$5: {
   if (($2 | 0) > ($6 | 0)) {
    $8 = HEAP32[$1 + 4 >> 2];
    HEAP32[$5 + 8 >> 2] = $4;
    HEAP32[$5 + 12 >> 2] = $3;
    $6 = $2 - $6 | 0;
    break label$5;
   }
   HEAP32[$5 + 12 >> 2] = $7;
   HEAP32[$5 + 8 >> 2] = HEAP32[$1 + 4 >> 2];
   $7 = $3;
   $8 = $4;
   $6 = $6 - $2 | 0;
  }
  $3 = fts3DoclistPhraseMerge(HEAPU8[$0 + 239 | 0], $6, $7, $8, $5 + 12 | 0, $5 + 8 | 0);
  sqlite3_free($7);
  HEAP32[$1 >> 2] = HEAP32[$5 + 12 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAP32[$5 + 8 >> 2];
 }
 if (HEAP32[$1 + 44 >> 2] < ($2 | 0)) {
  HEAP32[$1 + 44 >> 2] = $2;
 }
 __stack_pointer = $5 + 16 | 0;
 return $3;
}

function propagateConstantExprRewriteOne($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = 1;
 label$1: {
  if (HEAPU8[HEAP32[$0 + 4 >> 2]]) {
   break label$1;
  }
  $5 = 0;
  if (HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $6 = HEAP32[$1 + 4 >> 2];
  if ($6 & (HEAP32[$0 + 20 >> 2] | 32)) {
   break label$1;
  }
  $3 = HEAP32[$0 + 8 >> 2];
  $8 = ($3 | 0) > 0 ? $3 : 0;
  $5 = 1;
  while (1) {
   if (($4 | 0) == ($8 | 0)) {
    break label$1;
   }
   $7 = HEAP32[$0 + 24 >> 2];
   $3 = HEAP32[$7 + ($4 << 3) >> 2];
   if (!(($3 | 0) == ($1 | 0) | HEAP32[$3 + 28 >> 2] != HEAP32[$1 + 28 >> 2] | HEAPU16[$3 + 32 >> 1] != HEAPU16[$1 + 32 >> 1])) {
    if ($2) {
     if ((sqlite3ExprAffinity($3) | 0) == 65) {
      break label$1;
     }
     $7 = HEAP32[$0 + 24 >> 2];
     $6 = HEAP32[$1 + 4 >> 2];
    }
    HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
    HEAP32[$1 + 4 >> 2] = $6 & -8388641 | 32;
    $4 = $4 << 1;
    HEAP32[$1 + 12 >> 2] = sqlite3ExprDup(HEAP32[HEAP32[$0 >> 2] >> 2], HEAP32[($4 << 2 | 4) + $7 >> 2], 0);
    break label$1;
   }
   $4 = $4 + 1 | 0;
   continue;
  }
 }
 return $5;
}

function sqlite3Pow10($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $6 = 1073889280;
 $7 = 1073676288;
 while (1) {
  $3 = $1 & 1;
  $14 = $3 ? $8 : 0;
  $2 = $10;
  $5 = $3 ? $2 : 0;
  $2 = $3 ? $9 : 0;
  $15 = $2;
  $3 = $3 ? $6 : 1073676288;
  $16 = $3;
  $3 = $11;
  $2 = $7;
  __multf3($4 + 16 | 0, $12, $3, $13, $2, $14, $5, $15, $16);
  $2 = $4;
  $13 = HEAP32[$2 + 24 >> 2];
  $5 = HEAP32[$2 + 28 >> 2];
  $7 = $5;
  $5 = HEAP32[$2 + 16 >> 2];
  $12 = $5;
  $11 = HEAP32[$2 + 20 >> 2];
  if ($1 >>> 0 >= 2) {
   $5 = $6;
   $2 = $10;
   $3 = $5;
   __multf3($4, $8, $2, $9, $3, $8, $2, $9, $3);
   $1 = $1 >> 1;
   $3 = HEAP32[$4 + 8 >> 2];
   $9 = $3;
   $2 = HEAP32[$4 + 12 >> 2];
   $6 = $2;
   $2 = HEAP32[$4 >> 2];
   $8 = $2;
   $3 = HEAP32[$4 + 4 >> 2];
   $10 = $3;
   continue;
  }
  break;
 }
 $2 = $0;
 HEAP32[$2 >> 2] = $12;
 $3 = $11;
 HEAP32[$2 + 4 >> 2] = $3;
 HEAP32[$2 + 8 >> 2] = $13;
 $3 = $7;
 HEAP32[$2 + 12 >> 2] = $3;
 __stack_pointer = $4 + 32 | 0;
}

function sqlite3GenerateRowIndexDelete($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $9 = HEAP32[$0 + 8 >> 2];
 if (HEAPU8[$1 + 28 | 0] & 128) {
  $10 = sqlite3PrimaryKeyIndex($1);
 }
 $1 = $1 + 8 | 0;
 $7 = -1;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if ($1) {
   label$4: {
    label$5: {
     if ($4) {
      if (!HEAP32[($8 << 2) + $4 >> 2]) {
       break label$4;
      }
      if (($1 | 0) != ($10 | 0)) {
       break label$5;
      }
      break label$4;
     }
     if (($1 | 0) == ($10 | 0)) {
      break label$4;
     }
    }
    $11 = $3 + $8 | 0;
    if (($11 | 0) == ($5 | 0)) {
     break label$4;
    }
    $7 = sqlite3GenerateIndexKey($0, $1, $2, 0, 1, $6 + 12 | 0, $12, $7);
    sqlite3VdbeAddOp3($9, 140, $11, $7, HEAPU16[((HEAPU8[$1 + 55 | 0] | HEAPU8[$1 + 56 | 0] << 8) & 8 ? 50 : 52) + $1 >> 1]);
    sqlite3VdbeChangeP5($9, 1);
    sqlite3ResolvePartIdxLabel($0, HEAP32[$6 + 12 >> 2]);
    $12 = $1;
   }
   $1 = $1 + 20 | 0;
   $8 = $8 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 16 | 0;
}

function ptrmapPut($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1: {
  if (HEAP32[$4 >> 2]) {
   break label$1;
  }
  if (!$1) {
   HEAP32[$4 >> 2] = sqlite3CorruptError(67862);
   break label$1;
  }
  $7 = HEAP32[$0 >> 2];
  $6 = ptrmapPageno($0, $1);
  $0 = sqlite3PagerGet($7, $6, $5 + 12 | 0, 0);
  if ($0) {
   HEAP32[$4 >> 2] = $0;
   break label$1;
  }
  $0 = HEAP32[$5 + 12 >> 2];
  label$4: {
   if (HEAPU8[sqlite3PagerGetExtra($0) | 0]) {
    HEAP32[$4 >> 2] = sqlite3CorruptError(67875);
    break label$4;
   }
   $1 = Math_imul(($6 ^ -1) + $1 | 0, 5);
   if (($1 | 0) < 0) {
    HEAP32[$4 >> 2] = sqlite3CorruptError(67880);
    break label$4;
   }
   $1 = sqlite3PagerGetData($0) + $1 | 0;
   if (HEAPU8[$1 | 0] == ($2 | 0)) {
    if ((sqlite3Get4byte($1 + 1 | 0) | 0) == ($3 | 0)) {
     break label$4;
    }
   }
   $0 = sqlite3PagerWrite($0);
   HEAP32[$4 >> 2] = $0;
   if ($0) {
    break label$4;
   }
   HEAP8[$1 | 0] = $2;
   sqlite3Put4byte($1 + 1 | 0, $3);
  }
  sqlite3PagerUnref(HEAP32[$5 + 12 >> 2]);
 }
 __stack_pointer = $5 + 16 | 0;
}

function fts3IncrmergeHintPop($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = 267;
 $7 = HEAP32[$0 + 4 >> 2];
 $3 = $7 - 1 | 0;
 $6 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP8[$3 + $6 | 0] < 0) {
   break label$1;
  }
  $8 = $3 >> 31 & $3;
  label$2: {
   while (1) {
    $4 = $3;
    if (($4 | 0) > 0) {
     $3 = $4 - 1 | 0;
     if (HEAP8[$6 + $3 | 0] < 0) {
      continue;
     }
     break label$2;
    }
    break;
   }
   $4 = $8;
   if (($7 | 0) > 0) {
    break label$1;
   }
  }
  $8 = (($4 | 0) <= 0 ? $4 : 1) - 1 | 0;
  while (1) {
   label$6: {
    if (($4 | 0) < 2) {
     $5 = $8;
     break label$6;
    }
    $3 = $4 + $6 | 0;
    $5 = $4 - 1 | 0;
    $4 = $5;
    if (HEAP8[$3 - 2 | 0] < 0) {
     continue;
    }
   }
   break;
  }
  HEAP32[$0 + 4 >> 2] = $5;
  $4 = sqlite3Fts3GetVarint($5 + $6 | 0, $1);
  $4 = $5 + $4 | 0;
  $6 = $4 + HEAP32[$0 >> 2] | 0;
  $3 = HEAP8[$6 | 0];
  label$8: {
   if (($3 | 0) < 0) {
    $3 = sqlite3Fts3GetVarint32($6, $2);
    break label$8;
   }
   HEAP32[$2 >> 2] = $3 & 255;
   $3 = 1;
  }
  $5 = ($3 + $4 | 0) == ($7 | 0) ? 0 : 267;
 }
 return $5;
}

function __wasm_rotl_i64($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = $2;
 $10 = $4 & 63;
 $5 = $10;
 $6 = $5 & 31;
 if (($5 & 63) >>> 0 >= 32) {
  $4 = 0;
  $7 = -1 >>> $6 | 0;
 } else {
  $4 = -1 >>> $6 | 0;
  $7 = (1 << $6) - 1 << 32 - $6 | -1 >>> $6;
 }
 $8 = $1;
 $8 = $4 & $8;
 $5 = $0;
 $4 = $7 & $5;
 $5 = $10;
 $6 = $5 & 31;
 if (($5 & 63) >>> 0 >= 32) {
  $7 = $4 << $6;
  $10 = 0;
 } else {
  $7 = (1 << $6) - 1 & $4 >>> 32 - $6 | $8 << $6;
  $10 = $4 << $6;
 }
 $11 = $7;
 $5 = $2;
 $6 = 0 - $5 | 0;
 $4 = $3;
 $9 = $4 + (($5 | 0) != 0) | 0;
 $2 = $6 & 63;
 $8 = 0;
 $3 = $8;
 $5 = $2;
 $4 = $5 & 31;
 if (($5 & 63) >>> 0 >= 32) {
  $7 = -1 << $4;
  $8 = 0;
 } else {
  $7 = (1 << $4) - 1 & -1 >>> 32 - $4 | -1 << $4;
  $8 = -1 << $4;
 }
 $9 = $1;
 $9 = $9 & $7;
 $5 = $0;
 $7 = $8 & $5;
 $5 = $2;
 $4 = $5 & 31;
 if (($5 & 63) >>> 0 >= 32) {
  $8 = 0;
  $5 = $9 >>> $4 | 0;
 } else {
  $8 = $9 >>> $4 | 0;
  $5 = ((1 << $4) - 1 & $9) << 32 - $4 | $7 >>> $4;
 }
 $7 = $8;
 $8 = $11;
 $7 = $8 | $7;
 i64toi32_i32$HIGH_BITS = $7;
 $9 = $10;
 $9 = $5 | $9;
 return $9;
}

function sqlite3Fts3PendingTermsFlush($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  label$2: {
   while (1) {
    if ($1) {
     break label$2;
    }
    if (HEAP32[$0 + 256 >> 2] > ($2 | 0)) {
     $1 = fts3SegmentMerge($0, HEAP32[$0 + 280 >> 2], $2, -1);
     $1 = ($1 | 0) == 101 ? 0 : $1;
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   sqlite3Fts3PendingTermsClear($0);
   $1 = 0;
   if (!HEAP32[$0 + 52 >> 2] | (!HEAPU8[$0 + 237 | 0] | HEAP32[$0 + 48 >> 2] != 255)) {
    break label$1;
   }
   $2 = 0;
   HEAP32[$3 + 12 >> 2] = 0;
   $1 = fts3SqlStmt($0, 22, $3 + 12 | 0, 0);
   if ($1) {
    break label$1;
   }
   $1 = HEAP32[$3 + 12 >> 2];
   sqlite3_bind_int($1, 1, 2);
   label$5: {
    switch (sqlite3_step($1) - 100 | 0) {
    case 0:
     $2 = sqlite3_column_int($1, 0);
     $2 = ($2 | 0) == 1 ? 8 : $2;

    case 1:
     HEAP32[$0 + 48 >> 2] = $2;
     break;

    default:
     break label$5;
    }
   }
   $1 = sqlite3_reset($1);
   break label$1;
  }
  sqlite3Fts3PendingTermsClear($0);
 }
 __stack_pointer = $3 + 16 | 0;
 return $1;
}

function sqlite3VtabOverloadFunction($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 0;
 label$1: {
  label$2: {
   if (!$3 | HEAPU8[$3 | 0] != 167) {
    break label$2;
   }
   $3 = HEAP32[$3 + 44 >> 2];
   if (!$3 | HEAPU8[$3 + 43 | 0] != 1) {
    break label$2;
   }
   $3 = HEAP32[sqlite3GetVTable($0, $3) + 8 >> 2];
   $5 = HEAP32[HEAP32[$3 >> 2] + 72 >> 2];
   if (!$5) {
    break label$2;
   }
   if (!(FUNCTION_TABLE[$5 | 0]($3, $2, HEAP32[$1 + 32 >> 2], $4 + 12 | 0, $4 + 8 | 0) | 0)) {
    break label$2;
   }
   $3 = sqlite3DbMallocZero($0, sqlite3Strlen30(HEAP32[$1 + 32 >> 2]) + 41 | 0, 0);
   if (!$3) {
    break label$2;
   }
   $0 = __memcpy($3, $1, 40);
   $2 = $0 + 40 | 0;
   HEAP32[$0 + 32 >> 2] = $2;
   $1 = HEAP32[$1 + 32 >> 2];
   __memcpy($2, $1, sqlite3Strlen30($1) + 1 | 0);
   HEAP32[$0 + 16 >> 2] = HEAP32[$4 + 12 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[$4 + 8 >> 2];
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 16;
   break label$1;
  }
  $3 = $1;
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function keywordCode($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (($1 | 0) < 2) {
   break label$1;
  }
  $4 = HEAPU8[$0 | 0];
  $3 = (((Math_imul(HEAPU8[HEAPU8[($0 + $1 | 0) - 1 | 0] + 29904 | 0], 3) ^ HEAPU8[$4 + 29904 | 0] << 2 ^ $1) >>> 0) % 127 | 0) + 33760 | 0;
  $7 = $4 & 223;
  while (1) {
   $3 = HEAPU8[$3 | 0];
   if (!$3) {
    break label$1;
   }
   label$3: {
    $5 = $3 - 1 | 0;
    label$4: {
     if (HEAPU8[$5 + 31536 | 0] != ($1 | 0)) {
      break label$4;
     }
     $6 = HEAPU16[($5 << 1) + 31232 >> 1] + 30560 | 0;
     if (HEAPU8[$6 | 0] != ($7 | 0)) {
      break label$4;
     }
     $3 = 2;
     if (HEAPU8[$6 + 1 | 0] != (HEAPU8[$0 + 1 | 0] & 223)) {
      break label$4;
     }
     while (1) {
      if (($1 | 0) == ($3 | 0)) {
       break label$3;
      }
      $4 = $0 + $3 | 0;
      $8 = $3 + $6 | 0;
      $3 = $3 + 1 | 0;
      if (HEAPU8[$8 | 0] == (HEAPU8[$4 | 0] & 223)) {
       continue;
      }
      break;
     }
    }
    $3 = $5 + 34048 | 0;
    continue;
   }
   break;
  }
  HEAP32[$2 >> 2] = HEAPU8[$5 + 33888 | 0];
 }
 return $1;
}

function isDate($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = memset($3, 0, 48);
 label$1: {
  if (!$1) {
   if (!sqlite3NotPureFunc($0)) {
    break label$1;
   }
   return setDateTimeToCurrent($0, $4);
  }
  $5 = 1;
  $3 = HEAP32[$2 >> 2];
  label$3: {
   label$4: {
    if (sqlite3_value_type($3) - 1 >>> 0 <= 1) {
     setRawDateNumber($4, sqlite3_value_double($3));
     break label$4;
    }
    $3 = sqlite3_value_text($3);
    if (!$3) {
     break label$3;
    }
    if (parseDateOrTime($0, $3, $4)) {
     break label$3;
    }
   }
   $3 = 1;
   $6 = ($1 | 0) > 1 ? $1 : 1;
   while (1) {
    if (($3 | 0) != ($6 | 0)) {
     $5 = ($3 << 2) + $2 | 0;
     $1 = sqlite3_value_text(HEAP32[$5 >> 2]);
     sqlite3_value_bytes(HEAP32[$5 >> 2]);
     if (!$1) {
      break label$1;
     }
     $5 = 1;
     $1 = parseModifier($0, $1, $4, $3);
     $3 = $3 + 1 | 0;
     if (!$1) {
      continue;
     }
     break label$3;
    }
    break;
   }
   computeJD($4);
   if (HEAPU8[$4 + 46 | 0]) {
    break label$3;
   }
   $5 = !validJulianDay(HEAP32[$4 >> 2], HEAP32[$4 + 4 >> 2]);
  }
  return $5;
 }
 return 1;
}

function balance_deeper($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 $5 = HEAP32[$0 + 52 >> 2];
 label$1: {
  label$2: {
   $4 = sqlite3PagerWrite(HEAP32[$0 + 72 >> 2]);
   if (!$4) {
    HEAP32[$2 + 12 >> 2] = allocateBtreePage($5, $2 + 8 | 0, $2 + 4 | 0, HEAP32[$0 + 4 >> 2], 0);
    $3 = HEAP32[$2 + 8 >> 2];
    copyNodeContent($0, $3, $2 + 12 | 0);
    if (HEAPU8[$5 + 17 | 0]) {
     ptrmapPut($5, HEAP32[$2 + 4 >> 2], 5, HEAP32[$0 + 4 >> 2], $2 + 12 | 0);
    }
    $4 = HEAP32[$2 + 12 >> 2];
    if (!$4) {
     break label$2;
    }
   }
   HEAP32[$1 >> 2] = 0;
   releasePage($3);
   break label$1;
  }
  __memcpy($3 + 28 | 0, $0 + 28 | 0, HEAPU8[$0 + 12 | 0] << 1);
  __memcpy($3 + 36 | 0, $0 + 36 | 0, HEAPU8[$0 + 12 | 0] << 2);
  HEAP8[$3 + 12 | 0] = HEAPU8[$0 + 12 | 0];
  zeroPage($0, HEAPU8[HEAP32[$3 + 56 >> 2]] & 247);
  sqlite3Put4byte((HEAPU8[$0 + 9 | 0] + HEAP32[$0 + 56 >> 2] | 0) + 8 | 0, HEAP32[$2 + 4 >> 2]);
  HEAP32[$1 >> 2] = $3;
  $4 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $4;
}

function walIndexPageRealloc($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (HEAP32[$0 + 24 >> 2] <= ($1 | 0)) {
   $3 = $1 + 1 | 0;
   $4 = sqlite3Realloc(HEAP32[$0 + 32 >> 2], $3 << 2, 0);
   if (!$4) {
    $3 = 7;
    $0 = 0;
    break label$1;
   }
   $5 = HEAP32[$0 + 24 >> 2];
   memset(($5 << 2) + $4 | 0, 0, $3 - $5 << 2);
   HEAP32[$0 + 24 >> 2] = $3;
   HEAP32[$0 + 32 >> 2] = $4;
  }
  label$4: {
   if (HEAPU8[$0 + 43 | 0] == 2) {
    $3 = sqlite3MallocZero(32768, 0);
    $4 = $1 << 2;
    HEAP32[$4 + HEAP32[$0 + 32 >> 2] >> 2] = $3;
    $3 = HEAP32[HEAP32[$0 + 32 >> 2] + $4 >> 2] ? 0 : 7;
    break label$4;
   }
   $3 = sqlite3OsShmMap(HEAP32[$0 + 4 >> 2], $1, HEAPU8[$0 + 44 | 0], HEAP32[$0 + 32 >> 2] + ($1 << 2) | 0);
   if (!$3) {
    if (($1 | 0) <= 0) {
     $3 = 0;
     break label$4;
    }
    $3 = sqlite3FaultSim(600) ? 7 : 0;
    break label$4;
   }
   if (($3 & 255) != 8) {
    break label$4;
   }
   HEAP8[$0 + 46 | 0] = HEAPU8[$0 + 46 | 0] | 2;
   $3 = ($3 | 0) == 8 ? 0 : $3;
  }
  $0 = HEAP32[HEAP32[$0 + 32 >> 2] + ($1 << 2) >> 2];
 }
 HEAP32[$2 >> 2] = $0;
 return $3;
}

function codeInteger($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $7 = HEAP32[$0 + 8 >> 2];
 label$1: {
  if (HEAPU8[$1 + 5 | 0] & 8) {
   $1 = HEAP32[$1 + 8 >> 2];
   sqlite3VdbeAddOp2($7, 71, $2 ? 0 - $1 | 0 : $1, $3);
   break label$1;
  }
  label$3: {
   $8 = HEAP32[$1 + 8 >> 2];
   $9 = sqlite3DecOrHexToI64($8, $4 + 8 | 0);
   if (!(!(($2 | 0) != 0 | ($9 | 0) != 3) | ($9 | 0) == 2)) {
    $5 = HEAP32[$4 + 8 >> 2];
    $6 = HEAP32[$4 + 12 >> 2];
    if (!$2 | ($5 | ($6 | 0) != -2147483648)) {
     break label$3;
    }
   }
   if (!sqlite3_strnicmp($8, 1579, 2)) {
    HEAP32[$4 + 4 >> 2] = $1;
    HEAP32[$4 >> 2] = $2 ? 24269 : 29623;
    sqlite3ErrorMsg($0, 18587, $4);
    break label$1;
   }
   codeReal($7, $8, $2, $3);
   break label$1;
  }
  if ($2) {
   $0 = 0 - ($6 + (($5 | 0) != 0) | 0) | 0;
   $6 = ($9 | 0) == 3;
   $5 = $6 ? 0 : 0 - $5 | 0;
   HEAP32[$4 + 8 >> 2] = $5;
   HEAP32[$4 + 12 >> 2] = $6 ? -2147483648 : $0;
  }
  sqlite3VdbeAddOp4Dup8($7, 72, $3, $4 + 8 | 0, -13);
 }
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3DropTrigger($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $3 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$3 + 87 | 0]) {
   break label$1;
  }
  if (sqlite3ReadSchema($0)) {
   break label$1;
  }
  $8 = $1 + 8 | 0;
  $9 = HEAP32[$1 + 16 >> 2];
  $7 = HEAP32[$1 + 12 >> 2];
  label$2: {
   while (1) {
    if (HEAP32[$3 + 20 >> 2] > ($6 | 0)) {
     $4 = $6 >>> 0 < 2 ^ $6;
     label$5: {
      if ($7) {
       if (!sqlite3DbIsNamed($3, $4, $7)) {
        break label$5;
       }
      }
      $4 = sqlite3HashFind(HEAP32[(HEAP32[$3 + 16 >> 2] + ($4 << 4) | 0) + 12 >> 2] + 40 | 0, $9);
      if ($4) {
       break label$2;
      }
     }
     $6 = $6 + 1 | 0;
     continue;
    }
    break;
   }
   label$7: {
    if (!$2) {
     HEAP32[$5 >> 2] = $8;
     sqlite3ErrorMsg($0, 18800, $5);
     break label$7;
    }
    sqlite3CodeVerifyNamedSchema($0, $7);
   }
   HEAP8[$0 + 17 | 0] = 1;
   break label$1;
  }
  sqlite3DropTriggerPtr($0, $4);
 }
 sqlite3SrcListDelete($3, $1);
 __stack_pointer = $5 + 16 | 0;
}

function sqlite3ExprListToValues($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 while (1) {
  label$2: {
   label$3: {
    if (HEAP32[$2 >> 2] > ($7 | 0)) {
     $3 = 1;
     $6 = HEAP32[(($7 << 4) + $2 | 0) + 8 >> 2];
     if (HEAPU8[$6 | 0] == 177) {
      $3 = HEAP32[HEAP32[$6 + 20 >> 2] >> 2];
     }
     if (($1 | 0) == ($3 | 0)) {
      $3 = sqlite3SelectNew($0, HEAP32[$6 + 20 >> 2], 0, 0, 0, 0, 0, 512, 0);
      HEAP32[$6 + 20 >> 2] = 0;
      if (!$3) {
       break label$2;
      }
      if (!$4) {
       break label$3;
      }
      HEAP32[$3 + 52 >> 2] = $4;
      HEAP8[$3 | 0] = 135;
      break label$3;
     }
     HEAP32[$5 + 8 >> 2] = $1;
     HEAP32[$5 >> 2] = $3;
     HEAP32[$5 + 4 >> 2] = ($3 | 0) > 1 ? 8343 : 29623;
     sqlite3ErrorMsg($0, 16777, $5);
    }
    if (!(!$4 | !HEAP32[$4 + 52 >> 2])) {
     HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 1024;
    }
    sqlite3ExprListDelete(HEAP32[$0 >> 2], $2);
    __stack_pointer = $5 + 16 | 0;
    return $4;
   }
   $4 = $3;
  }
  $7 = $7 + 1 | 0;
  continue;
 }
}

function sqlite3IndexAffinityStr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  $2 = HEAP32[$1 + 16 >> 2];
  if (!$2) {
   $4 = HEAP32[$1 + 12 >> 2];
   $2 = HEAPU16[$1 + 52 >> 1] + 1 | 0;
   $3 = $2 ? $3 : 1;
   $2 = sqlite3DbMallocRaw(0, $2, $3);
   HEAP32[$1 + 16 >> 2] = $2;
   if (!$2) {
    break label$1;
   }
   $2 = 0;
   while (1) {
    if ($2 >>> 0 < HEAPU16[$1 + 52 >> 1]) {
     $0 = HEAPU16[HEAP32[$1 + 4 >> 2] + ($2 << 1) >> 1];
     $3 = $0 << 16 >> 16;
     label$5: {
      if (($3 | 0) >= 0) {
       $0 = HEAPU8[(HEAP32[$4 + 4 >> 2] + Math_imul($0, 12) | 0) + 5 | 0];
       break label$5;
      }
      $0 = 68;
      if (($3 | 0) == -1) {
       break label$5;
      }
      $0 = sqlite3ExprAffinity(HEAP32[(HEAP32[$1 + 40 >> 2] + ($2 << 4) | 0) + 8 >> 2]);
     }
     $0 = $0 << 24 >> 24;
     $0 = ($0 | 0) > 65 ? $0 : 65;
     HEAP8[HEAP32[$1 + 16 >> 2] + $2 | 0] = $0 >>> 0 < 67 ? $0 : 67;
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP8[HEAP32[$1 + 16 >> 2] + $2 | 0] = 0;
   $2 = HEAP32[$1 + 16 >> 2];
  }
  return $2;
 }
 sqlite3OomFault($0);
 return 0;
}

function walEncodeFrame($0, $1, $2, $3, $4) {
 sqlite3Put4byte($4, $1);
 sqlite3Put4byte($4 + 4 | 0, $2);
 if (!HEAP32[$0 + 104 >> 2]) {
  $1 = HEAP32[$0 + 88 >> 2];
  $2 = HEAP32[$0 + 84 >> 2];
  HEAP8[$4 + 8 | 0] = $2;
  HEAP8[$4 + 9 | 0] = $2 >>> 8;
  HEAP8[$4 + 10 | 0] = $2 >>> 16;
  HEAP8[$4 + 11 | 0] = $2 >>> 24;
  HEAP8[$4 + 12 | 0] = $1;
  HEAP8[$4 + 13 | 0] = $1 >>> 8;
  HEAP8[$4 + 14 | 0] = $1 >>> 16;
  HEAP8[$4 + 15 | 0] = $1 >>> 24;
  $2 = !HEAPU8[$0 + 65 | 0];
  $1 = $0 + 76 | 0;
  walChecksumBytes($2, $4, 8, $1, $1);
  walChecksumBytes($2, $3, HEAP32[$0 + 36 >> 2], $1, $1);
  sqlite3Put4byte($4 + 16 | 0, HEAP32[$1 >> 2]);
  sqlite3Put4byte($4 + 20 | 0, HEAP32[$0 + 80 >> 2]);
  return;
 }
 HEAP8[$4 + 8 | 0] = 0;
 HEAP8[$4 + 9 | 0] = 0;
 HEAP8[$4 + 10 | 0] = 0;
 HEAP8[$4 + 11 | 0] = 0;
 HEAP8[$4 + 12 | 0] = 0;
 HEAP8[$4 + 13 | 0] = 0;
 HEAP8[$4 + 14 | 0] = 0;
 HEAP8[$4 + 15 | 0] = 0;
 HEAP8[$4 + 16 | 0] = 0;
 HEAP8[$4 + 17 | 0] = 0;
 HEAP8[$4 + 18 | 0] = 0;
 HEAP8[$4 + 19 | 0] = 0;
 HEAP8[$4 + 20 | 0] = 0;
 HEAP8[$4 + 21 | 0] = 0;
 HEAP8[$4 + 22 | 0] = 0;
 HEAP8[$4 + 23 | 0] = 0;
}

function sqlite3KeyInfoOfIndex($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $6 = HEAPU16[$1 + 52 >> 1];
  $2 = HEAP32[$0 >> 2];
  label$2: {
   if (HEAPU8[$1 + 55 | 0] & 8) {
    $5 = HEAPU16[$1 + 50 >> 1];
    $2 = sqlite3KeyInfoAlloc($2, $5, $6 - $5 | 0);
    break label$2;
   }
   $2 = sqlite3KeyInfoAlloc($2, $6, 0);
  }
  if (!$2) {
   break label$1;
  }
  while (1) {
   if (($3 | 0) != ($6 | 0)) {
    $5 = $3 << 2;
    $4 = HEAP32[$5 + HEAP32[$1 + 32 >> 2] >> 2];
    if (($4 | 0) == 32384) {
     $4 = 0;
    } else {
     $4 = sqlite3LocateCollSeq($0, $4);
    }
    HEAP32[($2 + $5 | 0) + 20 >> 2] = $4;
    HEAP8[HEAP32[$2 + 16 >> 2] + $3 | 0] = HEAPU8[HEAP32[$1 + 28 >> 2] + $3 | 0];
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  if (!HEAP32[$0 + 36 >> 2]) {
   return $2;
  }
  $3 = HEAPU8[$1 + 55 | 0] | HEAPU8[$1 + 56 | 0] << 8;
  if (!($3 & 256)) {
   $4 = $3 | 256;
   HEAP8[$1 + 55 | 0] = $4;
   HEAP8[$1 + 56 | 0] = $4 >>> 8;
   HEAP32[$0 + 12 >> 2] = 513;
  }
  sqlite3KeyInfoUnref($2);
 }
 return 0;
}

function whereClauseInsert($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = HEAP32[$0 + 12 >> 2];
 $4 = HEAP32[$0 + 16 >> 2];
 if (($3 | 0) >= ($4 | 0)) {
  $5 = HEAP32[$0 + 24 >> 2];
  $3 = HEAP32[$0 >> 2];
  $6 = HEAP32[HEAP32[$3 >> 2] >> 2];
  $3 = sqlite3WhereMalloc($3, Math_imul($4, 96), 0);
  HEAP32[$0 + 24 >> 2] = $3;
  if (!$3) {
   if ($2 & 1) {
    sqlite3ExprDelete($6, $1);
   }
   HEAP32[$0 + 24 >> 2] = $5;
   return 0;
  }
  __memcpy($3, $5, Math_imul(HEAP32[$0 + 12 >> 2], 48));
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] << 1;
  $3 = HEAP32[$0 + 12 >> 2];
 }
 $5 = 1;
 $7 = $3 + 1 | 0;
 HEAP32[$0 + 12 >> 2] = $7;
 $6 = Math_imul($3, 48);
 $4 = HEAP32[$0 + 24 >> 2];
 if (!($2 & 2)) {
  HEAP32[$0 + 20 >> 2] = $7;
 }
 $6 = $4 + $6 | 0;
 if (!(!$1 | !(HEAPU8[$1 + 6 | 0] & 8))) {
  $5 = HEAP32[$1 + 28 >> 2];
  $5 = sqlite3LogEst($5, $5 >> 31) - 270 | 0;
 }
 $4 = Math_imul($3, 48) + $4 | 0;
 HEAP16[$4 + 8 >> 1] = $5;
 HEAP32[$6 >> 2] = sqlite3ExprSkipCollateAndLikely($1);
 HEAP32[$4 + 4 >> 2] = $0;
 HEAP16[$4 + 10 >> 1] = $2;
 memset($4 + 12 | 0, 0, 36);
 return $3;
}

function sqlite3AddCheckConstraint($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   $6 = HEAP32[$0 + 236 >> 2];
   if (!$6 | HEAPU8[$0 + 208 | 0] == 1) {
    break label$2;
   }
   if (sqlite3BtreeIsReadonly(HEAP32[(HEAP32[$5 + 16 >> 2] + (HEAPU8[$5 + 176 | 0] << 4) | 0) + 4 >> 2])) {
    break label$2;
   }
   $7 = sqlite3ExprListAppend($0, HEAP32[$6 + 16 >> 2], $1);
   HEAP32[$6 + 16 >> 2] = $7;
   if (HEAP32[$0 + 76 >> 2]) {
    sqlite3ExprListSetName($0, $7, $0 + 72 | 0, 1);
    break label$1;
   }
   while (1) {
    $5 = HEAPU8[$2 + 1 | 0];
    $1 = $2 + 1 | 0;
    $2 = $1;
    if (HEAP8[$5 + 30288 | 0] & 1) {
     continue;
    }
    break;
   }
   while (1) {
    $2 = $3;
    $3 = $2 - 1 | 0;
    if (HEAP8[HEAPU8[$3 | 0] + 30288 | 0] & 1) {
     continue;
    }
    break;
   }
   HEAP32[$4 + 8 >> 2] = $1;
   HEAP32[$4 + 12 >> 2] = $2 - $1;
   sqlite3ExprListSetName($0, $7, $4 + 8 | 0, 1);
   break label$1;
  }
  sqlite3ExprDelete($5, $1);
 }
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3PcacheFetchStress($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (HEAPU8[$0 + 33 | 0] == 2) {
   break label$1;
  }
  label$2: {
   if ((sqlite3PcachePagecount($0) | 0) <= HEAP32[$0 + 20 >> 2]) {
    break label$2;
   }
   $3 = $0 + 8 | 0;
   label$3: {
    label$4: {
     while (1) {
      $3 = HEAP32[$3 >> 2];
      if ($3) {
       if (!(HEAPU8[$3 + 28 | 0] & 8 ? 1 : HEAPU16[$3 + 30 >> 1])) {
        break label$4;
       }
       $3 = $3 + 36 | 0;
       continue;
      }
      break;
     }
     HEAP32[$0 + 8 >> 2] = 0;
     $3 = $0 + 4 | 0;
     while (1) {
      $3 = HEAP32[$3 >> 2];
      if (!$3) {
       break label$2;
      }
      if (!HEAPU16[$3 + 30 >> 1]) {
       break label$3;
      }
      $3 = $3 + 36 | 0;
      continue;
     }
    }
    HEAP32[$0 + 8 >> 2] = $3;
   }
   $3 = FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]](HEAP32[$0 + 40 >> 2], $3) | 0;
   if (($3 | 0) == 5) {
    break label$2;
   }
   if ($3) {
    break label$1;
   }
  }
  $3 = FUNCTION_TABLE[HEAP32[16100]](HEAP32[$0 + 44 >> 2], $1, 2) | 0;
  HEAP32[$2 >> 2] = $3;
  $3 = $3 ? 0 : 7;
 }
 return $3;
}

function getAndInitPage($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 label$1: {
  label$2: {
   if (btreePagecount($0) >>> 0 < $1 >>> 0) {
    $4 = sqlite3CorruptError(69130);
    break label$2;
   }
   $4 = sqlite3PagerGet(HEAP32[$0 >> 2], $1, $5 + 12 | 0, $4);
   if ($4) {
    break label$2;
   }
   $6 = HEAP32[$5 + 12 >> 2];
   $4 = sqlite3PagerGetExtra($6);
   HEAP32[$2 >> 2] = $4;
   label$4: {
    if (!HEAPU8[$4 | 0]) {
     btreePageFromDbPage($6, $1, $0);
     $4 = btreeInitPage(HEAP32[$2 >> 2]);
     if ($4) {
      break label$4;
     }
    }
    $4 = 0;
    if (!$3) {
     break label$1;
    }
    $1 = HEAP32[$2 >> 2];
    if (HEAPU8[$1 + 1 | 0] == HEAPU8[$3 + 69 | 0] ? HEAPU16[$1 + 24 >> 1] : 0) {
     break label$1;
    }
    $4 = sqlite3CorruptError(69151);
   }
   releasePage(HEAP32[$2 >> 2]);
  }
  if (!$3) {
   break label$1;
  }
  $1 = HEAPU8[$3 + 68 | 0] - 1 | 0;
  HEAP8[$3 + 68 | 0] = $1;
  HEAP32[$3 + 116 >> 2] = HEAP32[(($1 << 24 >> 24 << 2) + $3 | 0) + 120 >> 2];
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function sqlite3Fts3FirstFilter($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = $2;
 label$1: {
  switch (HEAPU8[$2 | 0] - 1 | 0) {
  case 1:
   $5 = sqlite3Fts3PutVarint($4, $0, $1);
   HEAP8[$5 + $4 | 0] = 2;
   $7 = 1;
   $5 = $5 + 1 | 0;

  default:
   fts3ColumnlistCopy(0, $6 + 12 | 0);
   break;

  case 0:
   break label$1;
  }
 }
 $3 = $2 + $3 | 0;
 while (1) {
  $2 = HEAP32[$6 + 12 >> 2];
  if ($2 >>> 0 < $3 >>> 0) {
   $2 = $2 + 1 | 0;
   $2 = $2 + sqlite3Fts3GetVarint($2, $6) | 0;
   HEAP32[$6 + 12 >> 2] = $2;
   if (HEAPU8[$2 | 0] == 2) {
    if (!$7) {
     $5 = sqlite3Fts3PutVarint($4 + $5 | 0, $0, $1) + $5 | 0;
    }
    $7 = 1;
    HEAP8[$4 + $5 | 0] = 1;
    $2 = $5 + 1 | 0;
    $2 = $2 + sqlite3Fts3PutVarint($2 + $4 | 0, HEAP32[$6 >> 2], HEAP32[$6 + 4 >> 2]) | 0;
    HEAP8[$4 + $2 | 0] = 2;
    $5 = $2 + 1 | 0;
   }
   fts3ColumnlistCopy(0, $6 + 12 | 0);
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 16 | 0;
 if ($7) {
  HEAP8[$4 + $5 | 0] = 0;
  $5 = $5 + 1 | 0;
 }
 return $5;
}

function sqlite3AutoincrementBegin($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = $0 + 112 | 0;
 $5 = HEAP32[$0 + 8 >> 2];
 $6 = HEAP32[$0 >> 2];
 while (1) {
  label$2: {
   $3 = HEAP32[$3 >> 2];
   if (!$3) {
    break label$2;
   }
   $2 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 8 >> 2];
   sqlite3OpenTable($0, 0, $1, HEAP32[HEAP32[(HEAP32[$6 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 72 >> 2], 112);
   $4 = $2 - 1 | 0;
   sqlite3VdbeLoadString($5, $4, HEAP32[HEAP32[$3 + 4 >> 2] >> 2]);
   $1 = sqlite3VdbeAddOpList($5, 12, 48576);
   if (!$1) {
    break label$2;
   }
   HEAP32[$1 + 8 >> 2] = $2;
   HEAP32[$1 + 72 >> 2] = $2;
   HEAP32[$1 - -64 >> 2] = $4;
   HEAP32[$1 + 52 >> 2] = $2;
   $4 = $2 + 2 | 0;
   HEAP32[$1 + 12 >> 2] = $4;
   HEAP32[$1 + 148 >> 2] = $4;
   HEAP32[$1 + 124 >> 2] = $2;
   HEAP32[$1 + 112 >> 2] = $2;
   HEAP32[$1 + 88 >> 2] = $2 + 1;
   HEAP16[$1 + 62 >> 1] = 16;
   HEAP32[$1 + 208 >> 2] = $2;
   HEAP32[$1 + 144 >> 2] = $2;
   if (HEAP32[$0 + 40 >> 2]) {
    continue;
   }
   HEAP32[$0 + 40 >> 2] = 1;
   continue;
  }
  break;
 }
}

function fts3SegReaderIncrRead($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAP32[$0 + 48 >> 2];
 $1 = HEAP32[$0 + 44 >> 2] - $2 | 0;
 $1 = ($1 | 0) < 4096 ? $1 : 4096;
 $2 = sqlite3_blob_read(HEAP32[$0 + 52 >> 2], HEAP32[$0 + 40 >> 2] + $2 | 0, $1, $2);
 label$1: {
  if ($2) {
   break label$1;
  }
  $1 = HEAP32[$0 + 48 >> 2] + $1 | 0;
  HEAP32[$0 + 48 >> 2] = $1;
  $1 = HEAP32[$0 + 40 >> 2] + $1 | 0;
  HEAP8[$1 | 0] = 0;
  HEAP8[$1 + 1 | 0] = 0;
  HEAP8[$1 + 2 | 0] = 0;
  HEAP8[$1 + 3 | 0] = 0;
  HEAP8[$1 + 4 | 0] = 0;
  HEAP8[$1 + 5 | 0] = 0;
  HEAP8[$1 + 6 | 0] = 0;
  HEAP8[$1 + 7 | 0] = 0;
  HEAP8[$1 + 16 | 0] = 0;
  HEAP8[$1 + 17 | 0] = 0;
  HEAP8[$1 + 18 | 0] = 0;
  HEAP8[$1 + 19 | 0] = 0;
  HEAP8[$1 + 8 | 0] = 0;
  HEAP8[$1 + 9 | 0] = 0;
  HEAP8[$1 + 10 | 0] = 0;
  HEAP8[$1 + 11 | 0] = 0;
  HEAP8[$1 + 12 | 0] = 0;
  HEAP8[$1 + 13 | 0] = 0;
  HEAP8[$1 + 14 | 0] = 0;
  HEAP8[$1 + 15 | 0] = 0;
  if (HEAP32[$0 + 48 >> 2] != HEAP32[$0 + 44 >> 2]) {
   break label$1;
  }
  sqlite3_blob_close(HEAP32[$0 + 52 >> 2]);
  HEAP32[$0 + 48 >> 2] = 0;
  HEAP32[$0 + 52 >> 2] = 0;
 }
 return $2;
}

function sqlite3Fts3MsrIncrStart($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = HEAPU8[$0 + 239 | 0];
 $7 = HEAP32[$1 + 4 >> 2];
 $6 = fts3SegReaderStart($0, $1, $3, $4);
 label$1: {
  if ($6) {
   break label$1;
  }
  $8 = $5 ? 98 : 99;
  $5 = 0;
  $6 = ($7 | 0) > 0 ? $7 : 0;
  label$2: {
   while (1) {
    if (($5 | 0) == ($6 | 0)) {
     break label$2;
    }
    label$4: {
     $7 = HEAP32[HEAP32[$1 >> 2] + ($5 << 2) >> 2];
     if (!HEAP32[$7 + 40 >> 2]) {
      break label$4;
     }
     if (fts3SegReaderTermCmp($7, $3, $4)) {
      break label$4;
     }
     $5 = $5 + 1 | 0;
     continue;
    }
    break;
   }
   $6 = $5;
  }
  HEAP32[$1 + 8 >> 2] = $6;
  $5 = 0;
  while (1) {
   label$6: {
    $7 = HEAP32[$1 >> 2];
    if (($5 | 0) >= ($6 | 0)) {
     break label$6;
    }
    $6 = fts3SegReaderFirstDocid($0, HEAP32[($5 << 2) + $7 >> 2]);
    if ($6) {
     break label$1;
    }
    $5 = $5 + 1 | 0;
    $6 = HEAP32[$1 + 8 >> 2];
    continue;
   }
   break;
  }
  fts3SegReaderSort($7, $5, $5, $8);
  HEAP32[$1 + 24 >> 2] = $2;
  $6 = 0;
 }
 return $6;
}

function vdbeSorterCompareText($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $6 = HEAPU8[$2 | 0];
 $8 = HEAPU8[$4 | 0];
 $9 = HEAP8[$2 + 1 | 0];
 HEAP32[$7 + 12 >> 2] = $9 & 255;
 if (($9 | 0) < 0) {
  sqlite3GetVarint32($2 + 1 | 0, $7 + 12 | 0);
 }
 $9 = $4 + $8 | 0;
 $11 = $2 + $6 | 0;
 $8 = HEAP8[$4 + 1 | 0];
 $6 = $8 & 255;
 HEAP32[$7 + 8 >> 2] = $6;
 if (($8 | 0) < 0) {
  sqlite3GetVarint32($4 + 1 | 0, $7 + 8 | 0);
  $6 = HEAP32[$7 + 8 >> 2];
 }
 $10 = HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2];
 $8 = HEAP32[$7 + 12 >> 2];
 $9 = memcmp($11, $9, ((($6 | 0) > ($8 | 0) ? $8 : $6) - 13 | 0) / 2 | 0);
 $6 = $9 ? $9 : $8 - $6 | 0;
 label$3: {
  if (!$6) {
   $6 = 0;
   if (HEAPU16[$10 + 6 >> 1] < 2) {
    break label$3;
   }
   $6 = vdbeSorterCompareTail($0, $1, $2, $3, $4, $5);
   break label$3;
  }
  $6 = HEAPU8[HEAP32[$10 + 16 >> 2]] ? 0 - $6 | 0 : $6;
 }
 __stack_pointer = $7 + 16 | 0;
 return $6 | 0;
}

function schemaIsValid($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $1 = HEAP32[$0 >> 2];
 while (1) {
  label$2: {
   label$3: {
    label$4: {
     if (HEAP32[$1 + 20 >> 2] <= ($4 | 0)) {
      break label$4;
     }
     $6 = $4 << 4;
     $2 = HEAP32[($6 + HEAP32[$1 + 16 >> 2] | 0) + 4 >> 2];
     if (!$2) {
      break label$2;
     }
     $7 = sqlite3BtreeTxnState($2);
     if ($7) {
      break label$3;
     }
     $5 = sqlite3BtreeBeginTrans($2, 0, 0);
     if (!$5) {
      break label$3;
     }
     if (($5 | 0) != 3082 & ($5 | 0) != 7) {
      break label$4;
     }
     sqlite3OomFault($1);
     HEAP32[$0 + 12 >> 2] = 7;
    }
    __stack_pointer = $3 + 16 | 0;
    return;
   }
   sqlite3BtreeGetMeta($2, 1, $3 + 12 | 0);
   if (HEAP32[$3 + 12 >> 2] != HEAP32[HEAP32[(HEAP32[$1 + 16 >> 2] + $6 | 0) + 12 >> 2] >> 2]) {
    sqlite3ResetOneSchema($1, $4);
    HEAP32[$0 + 12 >> 2] = 17;
   }
   if ($7) {
    break label$2;
   }
   sqlite3BtreeCommit($2);
  }
  $4 = $4 + 1 | 0;
  continue;
 }
}

function acos($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $4 = wasm2js_scratch_load_i32(0) | 0;
 $3 = $2 & 2147483647;
 if ($3 >>> 0 >= 1072693248) {
  if (!($3 - 1072693248 | $4)) {
   return ($2 | 0) > 0 | ($2 | 0) >= 0 ? 0 : 3.141592653589793;
  }
  return 0 / ($0 - $0);
 }
 label$3: {
  if ($3 >>> 0 <= 1071644671) {
   $1 = 1.5707963267948966;
   if ($3 >>> 0 < 1012924417) {
    break label$3;
   }
   return 6123233995736766e-32 - $0 * R($0 * $0) - $0 + 1.5707963267948966;
  }
  if (($2 | 0) < 0) {
   $0 = ($0 + 1) * .5;
   $1 = sqrt($0);
   $0 = 1.5707963267948966 - ($1 + ($1 * R($0) + -6123233995736766e-32));
   return $0 + $0;
  }
  $1 = (1 - $0) * .5;
  $5 = sqrt($1);
  $6 = $5 * R($1);
  wasm2js_scratch_store_f64(+$5);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $2 | 0);
  $0 = +wasm2js_scratch_load_f64();
  $0 = $6 + ($1 - $0 * $0) / ($5 + $0) + $0;
  $1 = $0 + $0;
 }
 return $1;
}

function sqlite3SrcListDelete($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if ($1) {
  $3 = $1 + 8 | 0;
  while (1) {
   if (HEAP32[$1 >> 2] > ($4 | 0)) {
    $2 = HEAP32[$3 + 4 >> 2];
    if ($2) {
     sqlite3DbFreeNN($0, $2);
    }
    sqlite3DbFree($0, HEAP32[$3 + 8 >> 2]);
    $2 = HEAP32[$3 + 12 >> 2];
    if ($2) {
     sqlite3DbFreeNN($0, $2);
    }
    $2 = HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8;
    if ($2 & 2) {
     sqlite3DbFree($0, HEAP32[$3 + 56 >> 2]);
     $2 = HEAPU8[$3 + 37 | 0] | HEAPU8[$3 + 38 | 0] << 8;
    }
    if ($2 & 4) {
     sqlite3ExprListDelete($0, HEAP32[$3 + 56 >> 2]);
    }
    sqlite3DeleteTable($0, HEAP32[$3 + 16 >> 2]);
    $2 = HEAP32[$3 + 20 >> 2];
    if ($2) {
     sqlite3SelectDelete($0, $2);
    }
    $2 = HEAP32[$3 + 44 >> 2];
    label$9: {
     if (HEAPU8[$3 + 38 | 0] & 4) {
      sqlite3IdListDelete($0, $2);
      break label$9;
     }
     if (!$2) {
      break label$9;
     }
     sqlite3ExprDelete($0, $2);
    }
    $3 = $3 - -64 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFreeNN($0, $1);
 }
}

function constInsert($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  if (HEAPU8[$1 + 4 | 0] & 32) {
   break label$1;
  }
  if (sqlite3ExprAffinity($2)) {
   break label$1;
  }
  if (!sqlite3IsBinary(sqlite3ExprCompareCollSeq(HEAP32[$0 >> 2], $3))) {
   break label$1;
  }
  $3 = 0;
  $4 = HEAP32[$0 + 8 >> 2];
  $5 = ($4 | 0) > 0 ? $4 : 0;
  while (1) {
   if (($3 | 0) != ($5 | 0)) {
    $4 = HEAP32[HEAP32[$0 + 24 >> 2] + ($3 << 3) >> 2];
    if (HEAP32[$4 + 28 >> 2] == HEAP32[$1 + 28 >> 2] & HEAPU16[$4 + 32 >> 1] == HEAPU16[$1 + 32 >> 1]) {
     break label$1;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  if ((sqlite3ExprAffinity($1) | 0) == 65) {
   HEAP32[$0 + 16 >> 2] = 1;
  }
  $3 = HEAP32[$0 + 8 >> 2] + 1 | 0;
  HEAP32[$0 + 8 >> 2] = $3;
  $3 = sqlite3DbReallocOrFree(HEAP32[HEAP32[$0 >> 2] >> 2], HEAP32[$0 + 24 >> 2], $3 << 3, 0);
  HEAP32[$0 + 24 >> 2] = $3;
  if (!$3) {
   HEAP32[$0 + 8 >> 2] = 0;
   return;
  }
  $4 = HEAP32[$0 + 8 >> 2] << 3;
  HEAP32[($4 + $3 | 0) - 8 >> 2] = $1;
  HEAP32[(HEAP32[$0 + 24 >> 2] + $4 | 0) - 4 >> 2] = $2;
 }
}

function fts3PendingTermsAddOne($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 HEAP32[$7 + 8 >> 2] = 0;
 $6 = sqlite3Fts3HashFind($3, $4, $5);
 HEAP32[$7 + 12 >> 2] = $6;
 if ($6) {
  HEAP32[$0 + 268 >> 2] = (HEAP32[$0 + 268 >> 2] - (HEAP32[$6 >> 2] + $5 | 0) | 0) - 20;
 }
 $8 = HEAP32[$0 + 272 >> 2];
 $9 = $8;
 $6 = HEAP32[$0 + 276 >> 2];
 $10 = $6;
 $8 = $1;
 $6 = $8 >> 31;
 $11 = $6;
 $8 = $2;
 $6 = $8 >> 31;
 $12 = $6;
 label$2: {
  label$3: {
   $6 = $10;
   $8 = $11;
   if (!fts3PendingListAppend($7 + 12 | 0, $9, $6, $1, $8, $2, $12, $7 + 8 | 0)) {
    break label$3;
   }
   $6 = HEAP32[$7 + 12 >> 2];
   if (($6 | 0) != (sqlite3Fts3HashInsert($3, $4, $5, $6) | 0)) {
    break label$3;
   }
   sqlite3_free($6);
   $4 = 7;
   break label$2;
  }
  $4 = HEAP32[$7 + 8 >> 2];
  if ($4) {
   break label$2;
  }
  HEAP32[$0 + 268 >> 2] = (HEAP32[$0 + 268 >> 2] + (HEAP32[HEAP32[$7 + 12 >> 2] >> 2] + $5 | 0) | 0) + 20;
  $4 = 0;
 }
 __stack_pointer = $7 + 16 | 0;
 return $4;
}

function whereLoopCheaperProperSubset($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAPU16[$0 + 44 >> 1];
 $2 = HEAPU16[$0 + 46 >> 1];
 $5 = HEAPU16[$1 + 44 >> 1];
 $3 = HEAPU16[$1 + 46 >> 1];
 label$1: {
  if (($4 - $2 | 0) >= ($5 - $3 | 0)) {
   break label$1;
  }
  label$2: {
   if (HEAP16[$0 + 20 >> 1] > HEAP16[$1 + 20 >> 1]) {
    if (HEAP16[$0 + 22 >> 1] > HEAP16[$1 + 22 >> 1]) {
     break label$1;
    }
    if ($2 >>> 0 >= $3 >>> 0) {
     break label$2;
    }
    break label$1;
   }
   if ($2 >>> 0 < $3 >>> 0) {
    break label$1;
   }
  }
  while (1) {
   if (($4 | 0) > 0) {
    $2 = $5;
    $4 = $4 - 1 | 0;
    $3 = HEAP32[HEAP32[$0 + 52 >> 2] + ($4 << 2) >> 2];
    if (!$3) {
     continue;
    }
    while (1) {
     if (($2 | 0) <= 0) {
      break label$1;
     }
     $2 = $2 - 1 | 0;
     if (HEAP32[HEAP32[$1 + 52 >> 2] + ($2 << 2) >> 2] != ($3 | 0)) {
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  if (HEAPU8[$1 + 40 | 0] & 64 ? 0 : HEAPU8[$0 + 40 | 0] & 64) {
   break label$1;
  }
  $6 = 1;
 }
 return $6;
}

function groupConcatInverse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 label$1: {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   break label$1;
  }
  $0 = sqlite3_aggregate_context($0, 36);
  if (!$0) {
   break label$1;
  }
  sqlite3_value_text(HEAP32[$2 >> 2]);
  $2 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
  $1 = HEAP32[$0 + 24 >> 2];
  HEAP32[$0 + 24 >> 2] = $1 - 1;
  $3 = HEAP32[$0 + 32 >> 2];
  label$2: {
   if ($3) {
    if (($1 | 0) < 2) {
     break label$2;
    }
    $4 = HEAP32[$3 >> 2];
    memmove($3, $3 + 4 | 0, ($1 << 2) - 8 | 0);
    $2 = $2 + $4 | 0;
    break label$2;
   }
   $2 = HEAP32[$0 + 28 >> 2] + $2 | 0;
  }
  $1 = HEAP32[$0 + 16 >> 2];
  label$4: {
   if (($1 | 0) <= ($2 | 0)) {
    HEAP32[$0 + 16 >> 2] = 0;
    break label$4;
   }
   $1 = $1 - $2 | 0;
   HEAP32[$0 + 16 >> 2] = $1;
   $3 = HEAP32[$0 + 4 >> 2];
   memmove($3, $2 + $3 | 0, $1);
   if (HEAP32[$0 + 16 >> 2]) {
    break label$1;
   }
  }
  HEAP32[$0 + 12 >> 2] = 0;
  sqlite3_free(HEAP32[$0 + 32 >> 2]);
  HEAP32[$0 + 32 >> 2] = 0;
 }
}

function codeDeferredSeek($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = HEAP32[$0 >> 2];
 $6 = HEAP32[$4 + 8 >> 2];
 HEAP8[$0 + 52 | 0] = HEAPU8[$0 + 52 | 0] | 1;
 sqlite3VdbeAddOp3($6, 141, $3, 0, $2);
 label$1: {
  if (!(HEAPU16[$0 + 44 >> 1] & 4128)) {
   break label$1;
  }
  $0 = HEAP32[$4 + 116 >> 2];
  if (HEAP32[($0 ? $0 : $4) + 80 >> 2]) {
   break label$1;
  }
  $3 = HEAP32[$1 + 12 >> 2];
  $0 = HEAP16[$3 + 34 >> 1];
  $2 = $0 >> 31;
  $2 = $0 << 2;
  $0 = $2 + 4 | 0;
  $2 = 0;
  $5 = sqlite3DbMallocZero(HEAP32[$4 >> 2], $0 & -4, $2);
  if (!$5) {
   break label$1;
  }
  HEAP32[$5 >> 2] = HEAP16[$3 + 34 >> 1];
  $0 = HEAPU16[$1 + 52 >> 1];
  $7 = (($0 | 0) > 1 ? $0 : 1) - 1 | 0;
  $0 = 0;
  while (1) {
   if (($0 | 0) != ($7 | 0)) {
    $4 = HEAP16[HEAP32[$1 + 4 >> 2] + ($0 << 1) >> 1];
    $2 = sqlite3TableColumnToStorage($3, $4);
    if (($4 | 0) < 0) {
     $0 = $0 + 1 | 0;
    } else {
     $0 = $0 + 1 | 0;
     HEAP32[(($2 << 2) + $5 | 0) + 4 >> 2] = $0;
    }
    continue;
   }
   break;
  }
  sqlite3VdbeChangeP4($6, -1, $5, -14);
 }
}

function exprCodeBetween($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 176 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 4 >> 2] = 0;
 $7 = HEAP32[$0 >> 2];
 memset($5 - -64 | 0, 0, 52);
 memset($5 + 8 | 0, 0, 52);
 memset($5 + 120 | 0, 0, 52);
 $6 = sqlite3ExprDup($7, HEAP32[$1 + 12 >> 2], 0);
 if (!HEAPU8[$7 + 87 | 0]) {
  HEAP8[$5 + 120 | 0] = 44;
  HEAP32[$5 + 76 >> 2] = $6;
  HEAP8[$5 + 64 | 0] = 57;
  HEAP32[$5 + 136 >> 2] = $5 + 8;
  HEAP32[$5 + 132 >> 2] = $5 - -64;
  $1 = HEAP32[$1 + 20 >> 2];
  $8 = HEAP32[$1 + 8 >> 2];
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP8[$5 + 8 | 0] = 55;
  HEAP32[$5 + 80 >> 2] = $8;
  HEAP32[$5 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
  exprToRegister($6, exprCodeVector($0, $6, $5 + 4 | 0));
  label$2: {
   if ($3) {
    FUNCTION_TABLE[$3 | 0]($0, $5 + 120 | 0, $2, $4);
    break label$2;
   }
   HEAP32[$6 + 4 >> 2] = HEAP32[$6 + 4 >> 2] | 1;
   sqlite3ExprCodeTarget($0, $5 + 120 | 0, $2);
  }
  sqlite3ReleaseTempReg($0, HEAP32[$5 + 4 >> 2]);
 }
 sqlite3ExprDelete($7, $6);
 __stack_pointer = $5 + 176 | 0;
}

function reverseFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
  $2 = strlen($3);
  $4 = sqlite3_malloc($2 + 1 | 0);
  if (!$4) {
   sqlite3_result_error_nomem($0);
   return;
  }
  $2 = $2 + $4 | 0;
  HEAP8[$2 | 0] = 0;
  $5 = $2 - 1 | 0;
  label$4: while (1) {
   $1 = $3;
   if (sqlite3ReadUtf8($1)) {
    while (1) {
     $2 = 1;
     $7 = HEAPU8[$1 + 1 | 0];
     $6 = $1 + 1 | 0;
     $1 = $6;
     if (($7 & 192) == 128) {
      continue;
     }
     break;
    }
    while (1) {
     $1 = $6 - $2 | 0;
     if ($3 >>> 0 > $1 >>> 0) {
      $3 = $6;
      continue label$4;
     } else {
      HEAP8[$5 | 0] = HEAPU8[$1 | 0];
      $2 = $2 + 1 | 0;
      $5 = $5 - 1 | 0;
      continue;
     }
    }
   }
   break;
  }
  sqlite3_result_text($0, $4, -1, -1);
  sqlite3_free($4);
  return;
 }
 __assert_fail(17320, 17353, 1323, 17221);
 abort();
}

function sqlite3WalClose($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 if ($0) {
  label$3: {
   label$4: {
    if (!$4) {
     break label$4;
    }
    $6 = sqlite3OsLock(HEAP32[$0 + 4 >> 2], 4);
    if ($6) {
     break label$3;
    }
    if (!HEAPU8[$0 + 43 | 0]) {
     HEAP8[$0 + 43 | 0] = 1;
    }
    $6 = sqlite3WalCheckpoint($0, $1, 0, 0, 0, $2, $3, $4, 0, 0);
    if ($6) {
     break label$3;
    }
    HEAP32[$5 + 12 >> 2] = -1;
    sqlite3OsFileControlHint(HEAP32[$0 + 4 >> 2], 10, $5 + 12 | 0);
    $7 = 1;
    if (HEAP32[$5 + 12 >> 2] != 1) {
     break label$4;
    }
    $7 = 0;
    if (HEAP32[$0 + 20 >> 2] < 0) {
     break label$4;
    }
    walLimitSize($0, 0, 0);
   }
   $6 = 0;
  }
  walIndexClose($0, $7);
  sqlite3OsClose(HEAP32[$0 + 8 >> 2]);
  if ($7) {
   sqlite3BeginBenignMalloc();
   sqlite3OsDelete(HEAP32[$0 >> 2], HEAP32[$0 + 108 >> 2], 0);
   sqlite3EndBenignMalloc();
  }
  sqlite3_free(HEAP32[$0 + 32 >> 2]);
  sqlite3_free($0);
 }
 __stack_pointer = $5 + 16 | 0;
 return $6;
}

function sqlite3BtreeCopyFile($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 sqlite3BtreeEnter($0);
 sqlite3BtreeEnter($1);
 $2 = sqlite3PagerFile(sqlite3BtreePager($0));
 label$1: {
  if (HEAP32[$2 >> 2]) {
   $3 = sqlite3BtreeGetPageSize($1);
   $5 = $3 >> 31;
   $3 = __wasm_i64_mul($3, $5, sqlite3BtreeLastPage($1), 0);
   HEAP32[$4 >> 2] = $3;
   $5 = i64toi32_i32$HIGH_BITS;
   HEAP32[$4 + 4 >> 2] = $5;
   $2 = sqlite3OsFileControl($2, 11, $4);
   $3 = ($2 | 0) == 12 ? 0 : $2;
   if ($3) {
    break label$1;
   }
  }
  $3 = 0;
  $2 = memset($4, 0, 48);
  $5 = HEAP32[$1 >> 2];
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 20 >> 2] = $5;
  HEAP32[$2 + 16 >> 2] = 1;
  HEAP32[$2 + 4 >> 2] = $0;
  sqlite3_backup_step($2, 2147483647);
  $1 = sqlite3_backup_finish($2);
  if (!$1) {
   $2 = HEAP32[$0 + 4 >> 2];
   HEAP16[$2 + 24 >> 1] = HEAPU16[$2 + 24 >> 1] & 65533;
   break label$1;
  }
  sqlite3PagerClearCache(sqlite3BtreePager(HEAP32[$2 + 4 >> 2]));
  $3 = $1;
 }
 __stack_pointer = $4 + 48 | 0;
 return $3;
}

function jsonPrintf($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $5 = HEAP32[$1 + 8 >> 2];
 $9 = $5;
 $4 = HEAP32[$1 + 12 >> 2];
 $10 = $4;
 $4 = HEAP32[$1 + 16 >> 2];
 $6 = $4;
 $5 = HEAP32[$1 + 20 >> 2];
 $7 = $5;
 $4 = $0;
 $5 = $4 >> 31;
 $4 = $5;
 $5 = $7;
 $4 = $5 + $4 | 0;
 $7 = $6;
 $6 = $0 + $7 | 0;
 $4 = $0 >>> 0 > $6 >>> 0 ? $4 + 1 | 0 : $4;
 $7 = $4;
 $4 = $10;
 $5 = $9;
 label$1: {
  if (($7 | 0) == ($4 | 0) & $6 >>> 0 >= $5 >>> 0 | $4 >>> 0 < $7 >>> 0) {
   if (jsonGrow($1, $0)) {
    break label$1;
   }
  }
  HEAP32[$8 + 12 >> 2] = $3;
  sqlite3_vsnprintf($0, HEAP32[$1 + 4 >> 2] + HEAP32[$1 + 16 >> 2] | 0, $2, $3);
  $4 = HEAP32[$1 + 20 >> 2];
  $0 = $4;
  $5 = HEAP32[$1 + 16 >> 2];
  $7 = $5;
  $5 = strlen($5 + HEAP32[$1 + 4 >> 2] | 0);
  $4 = $5 >> 31;
  $2 = $5;
  $5 = $0;
  $6 = $4 + $5 | 0;
  $4 = $2 + $7 | 0;
  $6 = $4 >>> 0 < $7 >>> 0 ? $6 + 1 | 0 : $6;
  HEAP32[$1 + 16 >> 2] = $4;
  HEAP32[$1 + 20 >> 2] = $6;
 }
 __stack_pointer = $8 + 16 | 0;
}

function zeroJournalHdr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $2 = HEAP32[$0 + 80 >> 2];
 label$1: {
  if (!($2 | HEAP32[$0 + 84 >> 2])) {
   $1 = 0;
   break label$1;
  }
  $3 = HEAP32[$0 + 68 >> 2];
  $2 = HEAP32[$0 + 180 >> 2];
  $4 = HEAP32[$0 + 176 >> 2];
  label$3: {
   if (!(!$1 & ($2 | $4) != 0)) {
    $1 = sqlite3OsTruncate($3, 0, 0);
    $3 = 0;
    break label$3;
   }
   $1 = sqlite3OsWrite($3, 32272, 28, 0, 0);
   $3 = 0;
  }
  if ($1) {
   break label$1;
  }
  $1 = 0;
  if (!HEAPU8[$0 + 7 | 0]) {
   $1 = sqlite3OsSync(HEAP32[$0 + 68 >> 2], HEAPU8[$0 + 10 | 0] | 16);
  }
  if (!$4 & ($2 | 0) <= 0 | ($2 | 0) < 0 | $1) {
   break label$1;
  }
  $1 = sqlite3OsFileSize(HEAP32[$0 + 68 >> 2], $5 + 8 | 0);
  if ($1) {
   break label$1;
  }
  $1 = 0;
  $3 = HEAP32[$5 + 12 >> 2];
  if (($2 | 0) >= ($3 | 0) & $4 >>> 0 >= HEAPU32[$5 + 8 >> 2] | ($3 | 0) < ($2 | 0)) {
   break label$1;
  }
  $1 = sqlite3OsTruncate(HEAP32[$0 + 68 >> 2], $4, $2);
 }
 __stack_pointer = $5 + 16 | 0;
 return $1;
}

function resetAccumulator($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$0 + 36 >> 2] | HEAP32[$1 + 44 >> 2] == (0 - HEAP32[$1 + 32 >> 2] | 0)) {
   break label$1;
  }
  $5 = HEAP32[$0 + 8 >> 2];
  sqlite3VdbeAddOp3($5, 75, 0, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2]);
  $2 = HEAP32[$1 + 40 >> 2];
  while (1) {
   if (HEAP32[$1 + 44 >> 2] <= ($6 | 0)) {
    break label$1;
   }
   label$3: {
    if (HEAP32[$2 + 12 >> 2] < 0) {
     break label$3;
    }
    $3 = HEAP32[HEAP32[$2 >> 2] + 20 >> 2];
    if (!(HEAP32[$3 >> 2] == 1 ? $3 : 0)) {
     sqlite3ErrorMsg($0, 2605, 0);
     HEAP32[$2 + 12 >> 2] = -1;
     break label$3;
    }
    $3 = sqlite3KeyInfoFromExprList($0, $3, 0, 0);
    HEAP32[$2 + 16 >> 2] = sqlite3VdbeAddOp4($5, 118, HEAP32[$2 + 12 >> 2], 0, 0, $3, -8);
    HEAP32[$4 >> 2] = HEAP32[HEAP32[$2 + 4 >> 2] + 32 >> 2];
    sqlite3VdbeExplain($0, 0, 25087, $4);
   }
   $2 = $2 + 20 | 0;
   $6 = $6 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3WalOpen($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 HEAP32[$6 >> 2] = 0;
 $7 = sqlite3MallocZero(HEAP32[$0 + 4 >> 2] + 120 | 0, 0);
 label$1: {
  if (!$7) {
   $0 = 7;
   break label$1;
  }
  HEAP32[$7 >> 2] = $0;
  HEAP16[$7 + 40 >> 1] = 65535;
  HEAP32[$7 + 4 >> 2] = $1;
  HEAP32[$7 + 108 >> 2] = $2;
  HEAP32[$7 + 16 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $5;
  HEAP16[$7 + 48 >> 1] = 257;
  $4 = $7 + 120 | 0;
  HEAP32[$7 + 8 >> 2] = $4;
  HEAP8[$7 + 43 | 0] = (($3 | 0) != 0) << 1;
  HEAP32[$8 + 12 >> 2] = 524294;
  $0 = sqlite3OsOpen($0, $2, $4, 524294, $8 + 12 | 0);
  if (!$0) {
   if (HEAP8[$8 + 12 | 0] & 1) {
    HEAP8[$7 + 46 | 0] = 1;
   }
   $0 = sqlite3OsDeviceCharacteristics($1);
   if ($0 & 1024) {
    HEAP8[$7 + 48 | 0] = 0;
   }
   if ($0 & 4096) {
    HEAP8[$7 + 49 | 0] = 0;
   }
   HEAP32[$6 >> 2] = $7;
   $0 = 0;
   break label$1;
  }
  walIndexClose($7, 0);
  sqlite3OsClose(HEAP32[$7 + 8 >> 2]);
  sqlite3_free($7);
 }
 __stack_pointer = $8 + 16 | 0;
 return $0;
}

function pcacheSortDirtyList($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 $3 = memset($1, 0, 128);
 label$1: while (1) {
  if ($0) {
   $4 = HEAP32[$0 + 16 >> 2];
   $1 = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   while (1) {
    if (($1 | 0) != 31) {
     $2 = ($1 << 2) + $3 | 0;
     $5 = HEAP32[$2 >> 2];
     if ($5) {
      $0 = pcacheMergeDirtyList($5, $0);
      HEAP32[$2 >> 2] = 0;
      $1 = $1 + 1 | 0;
      continue;
     } else {
      HEAP32[$2 >> 2] = $0;
      $0 = $4;
      continue label$1;
     }
    }
    break;
   }
   HEAP32[$3 + 124 >> 2] = pcacheMergeDirtyList(HEAP32[$3 + 124 >> 2], $0);
   $0 = $4;
   continue;
  }
  break;
 }
 $0 = HEAP32[$3 >> 2];
 $1 = 1;
 while (1) {
  if (($1 | 0) != 32) {
   $2 = HEAP32[($1 << 2) + $3 >> 2];
   label$9: {
    if (!$2) {
     break label$9;
    }
    if (!$0) {
     $0 = $2;
     break label$9;
    }
    $0 = pcacheMergeDirtyList($0, $2);
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 128 | 0;
 return $0;
}

function sqlite3AddDefaultValue($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 $7 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$7) {
   break label$1;
  }
  $8 = HEAP32[$7 + 4 >> 2] + Math_imul(HEAP16[$7 + 34 >> 1] - 1 | 0, 12) | 0;
  $6 = HEAPU8[$5 + 177 | 0] ? HEAPU8[$5 + 176 | 0] != 1 : 0;
  if (!sqlite3ExprIsConstantOrFunction($1, $6)) {
   HEAP32[$4 >> 2] = HEAP32[$8 >> 2];
   sqlite3ErrorMsg($0, 2758, $4);
   break label$1;
  }
  if (HEAPU8[$8 + 10 | 0] & 96) {
   sqlite3ErrorMsg($0, 10560, 0);
   break label$1;
  }
  memset($4 + 8 | 0, 0, 52);
  HEAP8[$4 + 8 | 0] = 181;
  $6 = sqlite3DbSpanDup($5, $2, $3);
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 16 >> 2] = $6;
  HEAP32[$4 + 12 >> 2] = 8192;
  $6 = sqlite3ExprDup($5, $4 + 8 | 0, 1);
  sqlite3DbFree($5, HEAP32[$4 + 16 >> 2]);
  sqlite3ColumnSetExpr($0, $7, $8, $6);
 }
 if (HEAPU8[$0 + 208 | 0] >= 2) {
  sqlite3RenameExprUnmap($0, $1);
 }
 sqlite3ExprDelete($5, $1);
 __stack_pointer = $4 - -64 | 0;
}

function vdbeCompareMemString($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAPU8[$0 + 18 | 0] == HEAPU8[$2 + 4 | 0]) {
   $0 = FUNCTION_TABLE[HEAP32[$2 + 12 >> 2]](HEAP32[$2 + 8 >> 2], HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2], HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2]) | 0;
   break label$1;
  }
  sqlite3VdbeMemInit($4 + 40 | 0, HEAP32[$0 + 20 >> 2], 1);
  sqlite3VdbeMemInit($4, HEAP32[$0 + 20 >> 2], 1);
  sqlite3VdbeMemShallowCopy($4 + 40 | 0, $0, 16384);
  sqlite3VdbeMemShallowCopy($4, $1, 16384);
  $0 = sqlite3ValueText($4 + 40 | 0, HEAPU8[$2 + 4 | 0]);
  $1 = sqlite3ValueText($4, HEAPU8[$2 + 4 | 0]);
  label$3: {
   if (!($1 ? $0 : 0)) {
    $0 = 0;
    if (!$3) {
     break label$3;
    }
    HEAP8[$3 | 0] = 7;
    break label$3;
   }
   $0 = FUNCTION_TABLE[HEAP32[$2 + 12 >> 2]](HEAP32[$2 + 8 >> 2], HEAP32[$4 + 52 >> 2], $0, HEAP32[$4 + 12 >> 2], $1) | 0;
  }
  sqlite3VdbeMemReleaseMalloc($4 + 40 | 0);
  sqlite3VdbeMemReleaseMalloc($4);
 }
 __stack_pointer = $4 + 80 | 0;
 return $0;
}

function sqlite3VtabBegin($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$0 + 380 >> 2];
 if (!(HEAP32[$0 + 404 >> 2] | ($2 | 0) <= 0)) {
  return 6;
 }
 label$2: {
  if (!$1) {
   break label$2;
  }
  $4 = HEAP32[HEAP32[$1 + 8 >> 2] >> 2];
  if (!HEAP32[$4 + 56 >> 2]) {
   break label$2;
  }
  $5 = ($2 | 0) > 0 ? $2 : 0;
  label$3: {
   while (1) {
    if (($3 | 0) == ($5 | 0)) {
     break label$3;
    }
    $2 = $3 << 2;
    $3 = $3 + 1 | 0;
    if (HEAP32[HEAP32[$0 + 404 >> 2] + $2 >> 2] != ($1 | 0)) {
     continue;
    }
    break;
   }
   return 0;
  }
  $3 = growVTrans($0);
  if ($3) {
   break label$2;
  }
  $3 = FUNCTION_TABLE[HEAP32[$4 + 56 >> 2]](HEAP32[$1 + 8 >> 2]) | 0;
  if ($3) {
   break label$2;
  }
  $2 = HEAP32[$0 + 500 >> 2];
  $5 = HEAP32[$0 + 504 >> 2];
  addToVTrans($0, $1);
  $3 = 0;
  $2 = $2 + $5 | 0;
  if (!$2) {
   break label$2;
  }
  $0 = HEAP32[$4 + 80 >> 2];
  if (!$0) {
   break label$2;
  }
  HEAP32[$1 + 20 >> 2] = $2;
  $3 = FUNCTION_TABLE[$0 | 0](HEAP32[$1 + 8 >> 2], $2 - 1 | 0) | 0;
 }
 return $3;
}

function replicateFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (($1 | 0) != 2) {
   break label$1;
  }
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   break label$1;
  }
  $7 = sqlite3_value_int64(HEAP32[$2 + 4 >> 2]);
  $8 = i64toi32_i32$HIGH_BITS;
  if (($8 | 0) < 0) {
   sqlite3_result_error($0, 8544, -1);
   return;
  }
  $5 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
  $1 = sqlite3_malloc(Math_imul($7, $5) + 1 | 0);
  $3 = sqlite3_malloc($5 + 1 | 0);
  if (!($3 ? $1 : 0)) {
   sqlite3_result_error_nomem($0);
   if ($1) {
    sqlite3_free($1);
   }
   if (!$3) {
    break label$1;
   }
   sqlite3_free($3);
   return;
  }
  $2 = strcpy($3, sqlite3_value_text(HEAP32[$2 >> 2]));
  while (1) {
   if (!(($4 | 0) == ($7 | 0) & ($6 | 0) == ($8 | 0))) {
    strcpy(Math_imul($4, $5) + $1 | 0, $2);
    $4 = $4 + 1 | 0;
    $6 = $4 ? $6 : $6 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_result_text($0, $1, -1, -1);
  sqlite3_free($1);
  sqlite3_free($2);
 }
}

function pagerWalFrames($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = $1;
 label$1: {
  if (!$3) {
   $6 = 1;
   break label$1;
  }
  $4 = $5 + 12 | 0;
  while (1) {
   HEAP32[$4 >> 2] = $1;
   if ($1) {
    $7 = HEAP32[$1 + 24 >> 2];
    $4 = $7 >>> 0 > $2 >>> 0 ? $4 : $1 + 16 | 0;
    $6 = ($2 >>> 0 >= $7 >>> 0) + $6 | 0;
    $1 = HEAP32[$1 + 16 >> 2];
    continue;
   }
   break;
  }
  $1 = HEAP32[$5 + 12 >> 2];
 }
 $4 = $0 + 208 | 0;
 HEAP32[$4 >> 2] = HEAP32[$0 + 208 >> 2] + $6;
 if (HEAP32[$1 + 24 >> 2] == 1) {
  pager_write_changecounter($1);
 }
 label$6: {
  $4 = sqlite3WalFrames(HEAP32[$0 + 232 >> 2], HEAP32[$0 + 168 >> 2], $1, $2, $3, HEAPU8[$0 + 11 | 0]);
  if ($4 | !HEAP32[$0 + 96 >> 2]) {
   break label$6;
  }
  while (1) {
   if (!$1) {
    break label$6;
   }
   sqlite3BackupUpdate(HEAP32[$0 + 96 >> 2], HEAP32[$1 + 24 >> 2], HEAP32[$1 + 4 >> 2]);
   $1 = HEAP32[$1 + 16 >> 2];
   continue;
  }
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function sqlite3CheckObjectName($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  if (sqlite3WritableSchema($4) | HEAPU8[$4 + 178 | 0] & 2 | !HEAPU8[64281]) {
   break label$1;
  }
  label$2: {
   if (HEAPU8[$4 + 177 | 0]) {
    $4 = HEAP32[$4 + 180 >> 2];
    label$4: {
     if (sqlite3_stricmp($2, HEAP32[$4 >> 2])) {
      break label$4;
     }
     if (sqlite3_stricmp($1, HEAP32[$4 + 4 >> 2])) {
      break label$4;
     }
     if (!sqlite3_stricmp($3, HEAP32[$4 + 8 >> 2])) {
      break label$1;
     }
    }
    sqlite3ErrorMsg($0, 29623, 0);
    break label$2;
   }
   label$5: {
    if (!HEAPU8[$0 + 18 | 0]) {
     if (!sqlite3_strnicmp($1, 17751, 7)) {
      break label$5;
     }
    }
    if (!sqlite3ReadOnlyShadowTables($4)) {
     break label$1;
    }
    if (!sqlite3ShadowTableName($4, $1)) {
     break label$1;
    }
   }
   HEAP32[$5 >> 2] = $1;
   sqlite3ErrorMsg($0, 7589, $5);
  }
  $6 = 1;
 }
 __stack_pointer = $5 + 16 | 0;
 return $6;
}

function setChildPtrmaps($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $4 = HEAP32[$0 + 4 >> 2];
 $5 = HEAP32[$0 + 52 >> 2];
 label$1: {
  label$2: {
   if (HEAPU8[$0 | 0]) {
    HEAP32[$2 + 12 >> 2] = 0;
    break label$2;
   }
   $1 = btreeInitPage($0);
   HEAP32[$2 + 12 >> 2] = $1;
   if ($1) {
    break label$1;
   }
  }
  $6 = HEAPU16[$0 + 24 >> 1];
  $1 = 0;
  while (1) {
   if (($1 | 0) != ($6 | 0)) {
    $3 = HEAP32[$0 + 64 >> 2] + ($1 << 1) | 0;
    $3 = HEAP32[$0 + 56 >> 2] + (HEAPU16[$0 + 26 >> 1] & (HEAPU8[$3 | 0] << 8 | HEAPU8[$3 + 1 | 0])) | 0;
    ptrmapPutOvflPtr($0, $0, $3, $2 + 12 | 0);
    if (!HEAPU8[$0 + 8 | 0]) {
     ptrmapPut($5, sqlite3Get4byte($3), 5, $4, $2 + 12 | 0);
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  if (!HEAPU8[$0 + 8 | 0]) {
   ptrmapPut($5, sqlite3Get4byte((HEAPU8[$0 + 9 | 0] + HEAP32[$0 + 56 >> 2] | 0) + 8 | 0), 5, $4, $2 + 12 | 0);
  }
  $1 = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function unixLockSharedMemory($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 32 >> 2] = 1;
 HEAP32[$2 + 36 >> 2] = 0;
 HEAP32[$2 + 24 >> 2] = 128;
 HEAP32[$2 + 28 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 1;
 $4 = HEAP32[$1 + 12 >> 2];
 HEAP32[$2 >> 2] = $2 + 16;
 $3 = 3850;
 label$1: {
  if (FUNCTION_TABLE[HEAP32[16258]]($4, 5, $2) | 0) {
   break label$1;
  }
  $3 = 5;
  label$2: {
   label$3: {
    switch (HEAPU16[$2 + 16 >> 1] - 1 | 0) {
    case 0:
     break label$1;

    case 1:
     break label$3;

    default:
     break label$2;
    }
   }
   if (HEAPU8[$1 + 22 | 0]) {
    HEAP8[$1 + 23 | 0] = 1;
    $3 = 1288;
    break label$1;
   }
   $3 = unixShmSystemLock($0, 1, 128, 1);
   if ($3) {
    break label$1;
   }
   if (!robust_ftruncate(HEAP32[$1 + 12 >> 2], 3, 0)) {
    break label$2;
   }
   $3 = 4618;
   unixLogErrorAtLine(4618, 12553, HEAP32[$1 + 8 >> 2], 40015);
   break label$1;
  }
  $3 = unixShmSystemLock($0, 0, 128, 1);
 }
 __stack_pointer = $2 + 48 | 0;
 return $3;
}

function sqlite3Int64ToText($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
 $9 = __stack_pointer - 32 | 0;
 __stack_pointer = $9;
 HEAP8[$9 + 21 | 0] = 0;
 $8 = $1;
 $5 = $8 >> 31;
 $4 = $8 >> 31;
 $6 = $4;
 $4 = $8;
 $10 = $6 ^ $4;
 $8 = $0;
 $11 = $5;
 $4 = $8 ^ $5;
 $5 = $4 - $5 | 0;
 $3 = $6 + ($4 >>> 0 < $11 >>> 0) | 0;
 $3 = $10 - $3 | 0;
 $6 = $3;
 $7 = 20;
 while (1) {
  $12 = $7;
  $3 = $6;
  $4 = __wasm_i64_udiv($5, $3, 10, 0);
  $10 = $4;
  $3 = i64toi32_i32$HIGH_BITS;
  $13 = $3;
  $4 = __wasm_i64_mul($4, $3, 10, 0);
  $3 = i64toi32_i32$HIGH_BITS;
  $14 = $3;
  $11 = $4;
  $8 = $5 - $4 | 0;
  $3 = $6;
  $4 = $14;
  HEAP8[$7 + $9 | 0] = $8 | 48;
  $7 = $7 - 1 | 0;
  $3 = $5;
  $4 = !$6 & $3 >>> 0 > 9 | ($6 | 0) != 0;
  $5 = $10;
  $3 = $13;
  $6 = $3;
  if ($4) {
   continue;
  }
  break;
 }
 $3 = $1;
 if (($3 | 0) < 0) {
  HEAP8[$7 + $9 | 0] = 45;
  $7 = $12 - 2 | 0;
 }
 __memcpy($2, ($7 + $9 | 0) + 1 | 0, 21 - $7 | 0);
 __stack_pointer = $9 + 32 | 0;
}

function sqlite3ExprNeedsNoAffinityChange($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = 1;
 label$1: {
  if (($1 | 0) == 65) {
   break label$1;
  }
  label$2: {
   while (1) {
    label$4: {
     label$5: {
      $2 = HEAPU8[$0 | 0];
      switch ($2 - 173 | 0) {
      case 3:
       break label$4;

      case 0:
      case 1:
       break label$5;

      default:
       break label$2;
      }
     }
     $3 = ($2 | 0) == 173 ? 1 : $3;
     $0 = HEAP32[$0 + 12 >> 2];
     continue;
    }
    break;
   }
   $2 = HEAPU8[$0 + 2 | 0];
  }
  $4 = $2;
  label$6: {
   label$7: {
    label$8: {
     switch ($2 - 153 | 0) {
     default:
      if (($4 | 0) == 117) {
       break label$7;
      }
      $2 = 0;
      if (($4 | 0) != 167 | ($1 | 0) < 67) {
       break label$1;
      }
      return HEAPU16[$0 + 32 >> 1] >>> 15 | 0;

     case 2:
      return ($1 | 0) > 66;

     case 1:
      break label$6;

     case 0:
      break label$8;
     }
    }
    return ($1 | 0) > 66;
   }
   return !$3 & ($1 | 0) == 66;
  }
  $2 = !$3;
 }
 return $2;
}

function vdbePmaReaderIncrMergeInit($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $5 = HEAP32[$0 + 48 >> 2];
 $1 = HEAP32[$5 >> 2];
 $9 = HEAP32[HEAP32[$1 + 8 >> 2] + 24 >> 2];
 $3 = vdbeMergeEngineInit($1, HEAP32[$5 + 4 >> 2]);
 label$1: {
  if ($3) {
   break label$1;
  }
  $2 = HEAP32[$5 + 16 >> 2];
  $4 = $2 >> 31;
  $7 = $2;
  $10 = $4;
  $3 = HEAP32[$1 + 56 >> 2];
  label$2: {
   if ($3) {
    $4 = HEAP32[$1 + 64 >> 2];
    $8 = $4;
    $2 = HEAP32[$1 + 68 >> 2];
    $6 = $2;
    break label$2;
   }
   $3 = vdbeSorterOpenTempFile($9, $1 + 56 | 0);
   HEAP32[$1 + 64 >> 2] = 0;
   HEAP32[$1 + 68 >> 2] = 0;
   if ($3) {
    break label$1;
   }
   $3 = HEAP32[$1 + 56 >> 2];
  }
  HEAP32[$5 + 8 >> 2] = $8;
  $2 = $6;
  HEAP32[$5 + 12 >> 2] = $2;
  HEAP32[$5 + 48 >> 2] = $3;
  $4 = $10;
  $6 = $4 + $2 | 0;
  $2 = $1 - -64 | 0;
  $4 = $7 + $8 | 0;
  HEAP32[$2 >> 2] = $4;
  $6 = $7 >>> 0 > $4 >>> 0 ? $6 + 1 | 0 : $6;
  HEAP32[$2 + 4 >> 2] = $6;
  $3 = vdbePmaReaderNext($0);
 }
 return $3;
}

function sqlite3RollbackAll($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 sqlite3BeginBenignMalloc();
 sqlite3BtreeEnterAll($0);
 $3 = HEAP8[$0 + 24 | 0] & 1 ? !HEAPU8[$0 + 177 | 0] : $3;
 $6 = !$3;
 while (1) {
  if (($2 | 0) < HEAP32[$0 + 20 >> 2]) {
   $4 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($2 << 4) | 0) + 4 >> 2];
   if ($4) {
    $7 = sqlite3BtreeTxnState($4);
    sqlite3BtreeRollback($4, $1, $6);
    $5 = ($7 | 0) == 2 ? 1 : $5;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3VtabRollback($0);
 sqlite3EndBenignMalloc();
 if ($3) {
  sqlite3ExpirePreparedStatements($0, 0);
  sqlite3ResetAllSchemasOfConnection($0);
 }
 HEAP32[$0 + 512 >> 2] = 0;
 HEAP32[$0 + 516 >> 2] = 0;
 HEAP32[$0 + 520 >> 2] = 0;
 HEAP32[$0 + 524 >> 2] = 0;
 $2 = HEAP32[$0 + 32 >> 2];
 $1 = $2;
 $2 = HEAP32[$0 + 36 >> 2] & -3;
 $1 = $1 & -524289;
 HEAP32[$0 + 32 >> 2] = $1;
 HEAP32[$0 + 36 >> 2] = $2;
 $2 = HEAP32[$0 + 240 >> 2];
 if (!(!$2 | !(HEAPU8[$0 + 85 | 0] ? $5 : 1))) {
  FUNCTION_TABLE[$2 | 0](HEAP32[$0 + 236 >> 2]);
 }
}

function sqlite3AuthRead($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $6 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], $2);
  if (($6 | 0) < 0) {
   break label$1;
  }
  label$2: {
   if (HEAPU8[$1 | 0] != 77) {
    $2 = 0;
    $5 = HEAP32[$3 >> 2];
    $5 = ($5 | 0) > 0 ? $5 : 0;
    while (1) {
     if (($2 | 0) == ($5 | 0)) {
      break label$1;
     }
     $4 = (($2 << 6) + $3 | 0) + 24 | 0;
     if (HEAP32[$1 + 28 >> 2] == HEAP32[(($2 << 6) + $3 | 0) + 48 >> 2]) {
      break label$2;
     }
     $2 = $2 + 1 | 0;
     continue;
    }
   }
   $4 = $0 + 120 | 0;
  }
  $2 = $4;
  $2 = HEAP32[$2 >> 2];
  if (!$2) {
   break label$1;
  }
  $5 = HEAP32[$2 >> 2];
  $3 = HEAP16[$1 + 32 >> 1];
  label$5: {
   if (($3 | 0) < 0) {
    $3 = HEAP16[$2 + 32 >> 1];
    $4 = 19859;
    if (($3 | 0) < 0) {
     break label$5;
    }
    $3 = $3 & 65535;
   }
   $4 = HEAP32[HEAP32[$2 + 4 >> 2] + Math_imul($3, 12) >> 2];
  }
  $3 = $4;
  if ((sqlite3AuthReadCol($0, $5, $3, $6) | 0) != 2) {
   break label$1;
  }
  HEAP8[$1 | 0] = 121;
 }
}

function sqlite3ArrayAllocate($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = HEAP32[$2 >> 2];
 HEAP32[$3 >> 2] = $4;
 $6 = $4 >> 31;
 $5 = !$4;
 $5 = $6 - $5 | 0;
 $7 = $5;
 $5 = $6;
 label$1: {
  if ($4 & $4 - 1 | $5 & $7) {
   $0 = $1;
   break label$1;
  }
  $6 = __wasm_i64_mul($4, $6, 40, 0);
  $5 = $4 ? i64toi32_i32$HIGH_BITS : 0;
  $0 = sqlite3DbRealloc($0, $1, $4 ? $6 : 20, $5);
  if ($0) {
   break label$1;
  }
  HEAP32[$3 >> 2] = -1;
  return $1;
 }
 $4 = Math_imul($4, 20) + $0 | 0;
 HEAP8[$4 | 0] = 0;
 HEAP8[$4 + 1 | 0] = 0;
 HEAP8[$4 + 2 | 0] = 0;
 HEAP8[$4 + 3 | 0] = 0;
 HEAP8[$4 + 4 | 0] = 0;
 HEAP8[$4 + 5 | 0] = 0;
 HEAP8[$4 + 6 | 0] = 0;
 HEAP8[$4 + 7 | 0] = 0;
 HEAP8[$4 + 16 | 0] = 0;
 HEAP8[$4 + 17 | 0] = 0;
 HEAP8[$4 + 18 | 0] = 0;
 HEAP8[$4 + 19 | 0] = 0;
 HEAP8[$4 + 8 | 0] = 0;
 HEAP8[$4 + 9 | 0] = 0;
 HEAP8[$4 + 10 | 0] = 0;
 HEAP8[$4 + 11 | 0] = 0;
 HEAP8[$4 + 12 | 0] = 0;
 HEAP8[$4 + 13 | 0] = 0;
 HEAP8[$4 + 14 | 0] = 0;
 HEAP8[$4 + 15 | 0] = 0;
 HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
 return $0;
}

function unsetJoinExpr($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $5 = ($1 | 0) < 0;
 while (1) {
  label$2: {
   if ($0) {
    $3 = HEAP32[$0 + 4 >> 2];
    label$4: {
     if (!$5 & (!($3 & 1) | HEAP32[$0 + 36 >> 2] != ($1 | 0))) {
      break label$4;
     }
     $3 = $3 & -4;
     HEAP32[$0 + 4 >> 2] = $3;
     if ($5) {
      break label$4;
     }
     $3 = $3 | 2;
     HEAP32[$0 + 4 >> 2] = $3;
    }
    $4 = HEAPU8[$0 | 0];
    if (($4 | 0) != 172) {
     if (($4 | 0) != 167 | $2 | HEAP32[$0 + 28 >> 2] != ($1 | 0)) {
      break label$2;
     }
     HEAP32[$0 + 4 >> 2] = $3 & -2097153;
     break label$2;
    }
    $3 = 0;
    $4 = HEAP32[$0 + 20 >> 2];
    if (!$4) {
     break label$2;
    }
    while (1) {
     if (HEAP32[$4 >> 2] <= ($3 | 0)) {
      break label$2;
     }
     unsetJoinExpr(HEAP32[(($3 << 4) + $4 | 0) + 8 >> 2], $1, $2);
     $3 = $3 + 1 | 0;
     $4 = HEAP32[$0 + 20 >> 2];
     continue;
    }
   }
   return;
  }
  unsetJoinExpr(HEAP32[$0 + 12 >> 2], $1, $2);
  $0 = HEAP32[$0 + 16 >> 2];
  continue;
 }
}

function pagerPagecount($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = sqlite3WalDbsize(HEAP32[$0 + 232 >> 2]);
 label$1: {
  label$2: {
   if (!$2) {
    $2 = HEAP32[$0 + 64 >> 2];
    if (!HEAP32[$2 >> 2]) {
     $2 = 0;
     break label$2;
    }
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = 0;
    $2 = sqlite3OsFileSize($2, $3 + 8 | 0);
    if ($2) {
     break label$1;
    }
    $2 = HEAP32[$0 + 168 >> 2];
    $7 = $2;
    $2 = HEAP32[$3 + 12 >> 2];
    $6 = HEAP32[$3 + 8 >> 2];
    $4 = $6 + $7 | 0;
    $5 = $2;
    $8 = HEAP32[$0 + 172 >> 2];
    $2 = $8;
    $5 = $5 + $2 | 0;
    $5 = $4 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
    $2 = $4;
    $6 = $2 - 1 | 0;
    $4 = !$2;
    $4 = $5 - $4 | 0;
    $2 = $8;
    $2 = __wasm_i64_sdiv($6, $4, $7, $2);
   }
   if (HEAPU32[$0 + 160 >> 2] >= $2 >>> 0) {
    break label$2;
   }
   HEAP32[$0 + 160 >> 2] = $2;
  }
  HEAP32[$1 >> 2] = $2;
  $2 = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function walDecodeFrame($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if ((HEAPU8[$0 + 84 | 0] | HEAPU8[$0 + 85 | 0] << 8 | (HEAPU8[$0 + 86 | 0] << 16 | HEAPU8[$0 + 87 | 0] << 24)) != (HEAPU8[$4 + 8 | 0] | HEAPU8[$4 + 9 | 0] << 8 | (HEAPU8[$4 + 10 | 0] << 16 | HEAPU8[$4 + 11 | 0] << 24)) | (HEAPU8[$0 + 88 | 0] | HEAPU8[$0 + 89 | 0] << 8 | (HEAPU8[$0 + 90 | 0] << 16 | HEAPU8[$0 + 91 | 0] << 24)) != (HEAPU8[$4 + 12 | 0] | HEAPU8[$4 + 13 | 0] << 8 | (HEAPU8[$4 + 14 | 0] << 16 | HEAPU8[$4 + 15 | 0] << 24))) {
   break label$1;
  }
  $6 = sqlite3Get4byte($4);
  if (!$6) {
   break label$1;
  }
  $7 = !HEAPU8[$0 + 65 | 0];
  $5 = $0 + 76 | 0;
  walChecksumBytes($7, $4, 8, $5, $5);
  walChecksumBytes($7, $3, HEAP32[$0 + 36 >> 2], $5, $5);
  if (HEAP32[$0 + 76 >> 2] != (sqlite3Get4byte($4 + 16 | 0) | 0)) {
   break label$1;
  }
  if (HEAP32[$0 + 80 >> 2] != (sqlite3Get4byte($4 + 20 | 0) | 0)) {
   break label$1;
  }
  HEAP32[$1 >> 2] = $6;
  HEAP32[$2 >> 2] = sqlite3Get4byte($4 + 4 | 0);
  $8 = 1;
 }
 return $8;
}

function sqlite3_set_auxdata($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = ($1 | 0) < 0;
 $5 = HEAP32[$0 + 12 >> 2];
 $4 = $5 + 232 | 0;
 label$1: {
  label$2: {
   label$3: {
    while (1) {
     $4 = HEAP32[$4 >> 2];
     if ($4) {
      if (HEAP32[$4 >> 2] == HEAP32[$0 + 16 >> 2] | $6 ? HEAP32[$4 + 4 >> 2] == ($1 | 0) : 0) {
       break label$3;
      }
      $4 = $4 + 16 | 0;
      continue;
     }
     break;
    }
    $4 = sqlite3DbMallocZero(HEAP32[$5 >> 2], 20, 0);
    if (!$4) {
     break label$1;
    }
    $6 = HEAP32[$0 + 16 >> 2];
    HEAP32[$4 + 4 >> 2] = $1;
    HEAP32[$4 >> 2] = $6;
    HEAP32[$4 + 16 >> 2] = HEAP32[$5 + 232 >> 2];
    HEAP32[$5 + 232 >> 2] = $4;
    if (HEAP32[$0 + 20 >> 2]) {
     break label$2;
    }
    HEAP32[$0 + 20 >> 2] = -1;
    break label$2;
   }
   $1 = HEAP32[$4 + 12 >> 2];
   if (!$1) {
    break label$2;
   }
   FUNCTION_TABLE[$1 | 0](HEAP32[$4 + 8 >> 2]);
  }
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 8 >> 2] = $2;
  return;
 }
 if ($3) {
  FUNCTION_TABLE[$3 | 0]($2);
 }
}

function sinh($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 wasm2js_scratch_store_f64(.5);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 $1 = $1 & 2147483647;
 $5 = $1;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $6 = $1 & -2147483648;
 $1 = $3;
 wasm2js_scratch_store_i32(0, $7 | $1);
 $1 = $6;
 $1 = $5 | $1;
 wasm2js_scratch_store_i32(1, $1 | 0);
 $4 = +wasm2js_scratch_load_f64();
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 wasm2js_scratch_store_i32(0, $3 | 0);
 $1 = $1 & 2147483647;
 wasm2js_scratch_store_i32(1, $1 | 0);
 $2 = +wasm2js_scratch_load_f64();
 label$1: {
  if ($1 >>> 0 <= 1082535489) {
   $2 = expm1($2);
   if ($1 >>> 0 <= 1072693247) {
    if ($1 >>> 0 < 1045430272) {
     break label$1;
    }
    return $4 * ($2 + $2 - $2 * $2 / ($2 + 1));
   }
   return $4 * ($2 + $2 / ($2 + 1));
  }
  $0 = __expo2($2, $4 + $4);
 }
 return $0;
}

function sqlite3_initialize() {
 var $0 = 0, $1 = 0;
 label$1: {
  if (HEAP32[16120]) {
   break label$1;
  }
  HEAP32[16122] = 1;
  if (!HEAP32[16123]) {
   $0 = sqlite3MallocInit();
   if ($0) {
    break label$1;
   }
  }
  HEAP32[16123] = 1;
  if (!HEAP32[16126]) {
   HEAP32[16126] = 8;
  }
  $1 = HEAP32[16125] + 1 | 0;
  HEAP32[16125] = $1;
  $0 = 0;
  if (!(HEAP32[16120] | HEAP32[16121])) {
   HEAP32[16121] = 1;
   memset(70768, 0, 92);
   sqlite3RegisterBuiltinFunctions();
   label$5: {
    if (!HEAP32[16124]) {
     $0 = sqlite3PcacheInitialize();
     if ($0) {
      break label$5;
     }
    }
    HEAP32[16124] = 1;
    $0 = sqlite3OsInit();
    if ($0) {
     break label$5;
    }
    $0 = sqlite3MemdbInit();
    if ($0) {
     break label$5;
    }
    $0 = 0;
    sqlite3PCacheBufferSetup(HEAP32[16114], HEAP32[16115], HEAP32[16116]);
    HEAP32[16120] = 1;
   }
   HEAP32[16121] = 0;
   $1 = HEAP32[16125];
  }
  HEAP32[16125] = $1 - 1;
  if (($1 | 0) > 1) {
   break label$1;
  }
  HEAP32[16126] = 0;
 }
 return $0;
}

function whereLoopAdjustCost($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if (!(!$0 | !(HEAP32[$1 + 40 >> 2] & 512))) {
  $4 = HEAPU8[$1 + 16 | 0];
  while (1) {
   label$3: {
    if (!(HEAPU8[$0 + 41 | 0] & 2) | HEAPU8[$0 + 16 | 0] != ($4 | 0)) {
     break label$3;
    }
    label$4: {
     if (whereLoopCheaperProperSubset($0, $1)) {
      $2 = HEAP16[$0 + 20 >> 1];
      $3 = HEAP16[$1 + 20 >> 1];
      HEAP16[$1 + 20 >> 1] = ($2 | 0) < ($3 | 0) ? $2 : $3;
      $2 = HEAP16[$1 + 22 >> 1];
      $3 = HEAP16[$0 + 22 >> 1];
      $2 = ($2 | 0) < ($3 | 0) ? $2 : $3 - 1 | 0;
      break label$4;
     }
     if (!whereLoopCheaperProperSubset($1, $0)) {
      break label$3;
     }
     $2 = HEAP16[$0 + 20 >> 1];
     $3 = HEAP16[$1 + 20 >> 1];
     HEAP16[$1 + 20 >> 1] = ($2 | 0) > ($3 | 0) ? $2 : $3;
     $2 = HEAP16[$1 + 22 >> 1];
     $3 = HEAP16[$0 + 22 >> 1];
     $2 = ($2 | 0) > ($3 | 0) ? $2 : $3 + 1 | 0;
    }
    HEAP16[$1 + 22 >> 1] = $2;
   }
   $0 = HEAP32[$0 + 56 >> 2];
   if ($0) {
    continue;
   }
   break;
  }
 }
}

function sqlite3FkRequired($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  if (!(HEAPU8[$1 + 43 | 0] | !(HEAPU8[HEAP32[$0 >> 2] + 33 | 0] & 64))) {
   label$3: {
    if (!$2) {
     $4 = 1;
     if (sqlite3FkReferences($1)) {
      break label$1;
     }
     $5 = HEAP32[$1 + 48 >> 2] != 0;
     break label$3;
    }
    $0 = $1 + 48 | 0;
    $4 = 1;
    while (1) {
     $0 = HEAP32[$0 >> 2];
     if ($0) {
      if (fkChildIsModified($1, $0, $2, $3)) {
       $5 = 1;
       $4 = sqlite3_stricmp(HEAP32[$1 >> 2], HEAP32[$0 + 8 >> 2]) ? $4 : 2;
      }
      $0 = $0 + 4 | 0;
      continue;
     }
     break;
    }
    $0 = sqlite3FkReferences($1);
    while (1) {
     if (!$0) {
      break label$3;
     }
     label$9: {
      if (!fkParentIsModified($1, $0, $2, $3)) {
       break label$9;
      }
      $5 = 1;
      if (!HEAPU8[$0 + 26 | 0]) {
       break label$9;
      }
      return 2;
     }
     $0 = HEAP32[$0 + 12 >> 2];
     continue;
    }
   }
   if ($5) {
    break label$1;
   }
  }
  $4 = 0;
 }
 return $4;
}

function whereUsablePartialIndex($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if ($1 & 64) {
   break label$1;
  }
  $4 = HEAP32[HEAP32[$2 >> 2] >> 2];
  while (1) {
   if (HEAPU8[$3 | 0] == 44) {
    if (!whereUsablePartialIndex($0, $1, $2, HEAP32[$3 + 12 >> 2])) {
     break label$1;
    }
    $3 = HEAP32[$3 + 16 >> 2];
    continue;
   }
   break;
  }
  $6 = HEAPU8[HEAP32[$4 >> 2] + 34 | 0] & 128 ? 0 : $4;
  $7 = $1 & 32;
  $1 = HEAP32[$2 + 24 >> 2];
  $4 = 0;
  while (1) {
   if (HEAP32[$2 + 12 >> 2] <= ($4 | 0)) {
    break label$1;
   }
   label$5: {
    $5 = HEAP32[$1 >> 2];
    label$6: {
     if (HEAP8[$5 + 4 | 0] & 1) {
      if (HEAP32[$5 + 36 >> 2] == ($0 | 0)) {
       break label$6;
      }
      break label$5;
     }
     if ($7) {
      break label$5;
     }
    }
    if (!sqlite3ExprImpliesExpr($6, $5, $3, $0) | HEAPU8[$1 + 10 | 0] & 128) {
     break label$5;
    }
    $8 = 1;
    break label$1;
   }
   $1 = $1 + 48 | 0;
   $4 = $4 + 1 | 0;
   continue;
  }
 }
 return $8;
}

function getDigits($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = __stack_pointer - 16 | 0;
 HEAP32[$4 + 12 >> 2] = $2;
 while (1) {
  $8 = HEAPU8[$1 + 1 | 0] - 48 | 0;
  $2 = HEAPU8[$1 | 0] - 48 | 0;
  $5 = ($2 & 255) + $0 | 0;
  $9 = HEAPU16[(HEAP8[$1 + 2 | 0] << 1) + 50554 >> 1];
  $10 = HEAPU8[$1 + 3 | 0];
  $3 = 0;
  label$2: {
   while (1) {
    if ($2 & 255) {
     $6 = HEAPU8[$0 | 0];
     if ($6 - 58 >>> 0 < 4294967286) {
      break label$2;
     }
     $2 = $2 - 1 | 0;
     $0 = $0 + 1 | 0;
     $3 = (Math_imul($3, 10) + ($6 << 24 >> 24) | 0) - 48 | 0;
     continue;
    }
    break;
   }
   if ($8 << 24 >> 24 > ($3 | 0) | ($3 | 0) > ($9 | 0)) {
    break label$2;
   }
   $2 = $10;
   if (HEAPU8[$5 | 0] != ($2 | 0) ? $2 : 0) {
    break label$2;
   }
   $0 = HEAP32[$4 + 12 >> 2];
   HEAP32[$4 + 12 >> 2] = $0 + 4;
   HEAP32[HEAP32[$0 >> 2] >> 2] = $3;
   $1 = $1 + 4 | 0;
   $7 = $7 + 1 | 0;
   $0 = $5 + 1 | 0;
   if ($2) {
    continue;
   }
  }
  break;
 }
 return $7;
}
function propagateConstants($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 32 >> 2] = $0;
 HEAP32[$2 + 36 >> 2] = HEAP32[$0 >> 2] + 87;
 while (1) {
  HEAP32[$2 + 56 >> 2] = 0;
  HEAP32[$2 + 40 >> 2] = 0;
  HEAP32[$2 + 44 >> 2] = 0;
  HEAP32[$2 + 48 >> 2] = 0;
  $3 = HEAP32[$1 + 32 >> 2];
  label$2: {
   if (!(!$3 | HEAP32[$3 >> 2] <= 0)) {
    $4 = 3;
    if (HEAPU8[$3 + 44 | 0] & 64) {
     break label$2;
    }
   }
   $4 = 1;
  }
  HEAP32[$2 + 52 >> 2] = $4;
  findConstInWhere($2 + 32 | 0, HEAP32[$1 + 36 >> 2]);
  if (HEAP32[$2 + 40 >> 2]) {
   HEAP32[$2 + 12 >> 2] = 0;
   HEAP32[$2 + 16 >> 2] = 0;
   HEAP32[$2 + 8 >> 2] = 50;
   HEAP32[$2 + 4 >> 2] = 51;
   HEAP32[$2 >> 2] = $0;
   HEAP32[$2 + 20 >> 2] = 0;
   HEAP32[$2 + 24 >> 2] = $2 + 32;
   sqlite3WalkExpr($2, HEAP32[$1 + 36 >> 2]);
   sqlite3DbFree(HEAP32[HEAP32[$2 + 32 >> 2] >> 2], HEAP32[$2 + 56 >> 2]);
  }
  if (HEAP32[$2 + 44 >> 2]) {
   continue;
  }
  break;
 }
 __stack_pointer = $2 - -64 | 0;
}

function readsTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $5 = sqlite3GetVdbe($0);
 $3 = sqlite3VdbeCurrentAddr($5);
 if (HEAPU8[$2 + 43 | 0] == 1) {
  $7 = sqlite3GetVTable(HEAP32[$0 >> 2], $2);
 }
 $8 = ($3 | 0) > 1 ? $3 : 1;
 $9 = $2 + 8 | 0;
 $4 = 1;
 while (1) {
  if (($4 | 0) == ($8 | 0)) {
   return 0;
  }
  label$4: {
   $3 = sqlite3VdbeGetOp($5, $4);
   $0 = HEAPU8[$3 | 0];
   label$5: {
    if (($0 | 0) != 173) {
     if (($0 | 0) != 112 | HEAP32[$3 + 12 >> 2] != ($1 | 0)) {
      break label$4;
     }
     $0 = $9;
     $6 = HEAP32[$3 + 8 >> 2];
     if (($6 | 0) == HEAP32[$2 + 20 >> 2]) {
      break label$5;
     }
     while (1) {
      $3 = HEAP32[$0 >> 2];
      if (!$3) {
       break label$4;
      }
      $0 = $3 + 20 | 0;
      if (HEAP32[$3 + 44 >> 2] != ($6 | 0)) {
       continue;
      }
      break;
     }
     break label$5;
    }
    if (HEAP32[$3 + 16 >> 2] != ($7 | 0)) {
     break label$4;
    }
   }
   return 1;
  }
  $4 = $4 + 1 | 0;
  continue;
 }
}

function jsonGrow($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = HEAP32[$0 + 12 >> 2];
 $4 = HEAP32[$0 + 8 >> 2];
 $3 = $4;
 $4 = $2 << 1 | $3 >>> 31;
 $7 = $4;
 $5 = $1 + $3 | 0;
 $6 = $5 >>> 0 < $3 >>> 0 ? $2 + 1 | 0 : $2;
 $4 = $5;
 $5 = $6;
 $4 = $4 + 10 | 0;
 $5 = $4 >>> 0 < 10 ? $5 + 1 | 0 : $5;
 $2 = !$2 & $1 >>> 0 < $3 >>> 0 | ($2 | 0) != 0;
 $4 = $2 ? $3 << 1 : $4;
 $3 = $4;
 $6 = $7;
 $2 = $2 ? $6 : $5;
 label$1: {
  label$2: {
   label$3: {
    if (HEAPU8[$0 + 24 | 0]) {
     $1 = 1;
     if (HEAPU8[$0 + 25 | 0]) {
      break label$2;
     }
     $1 = sqlite3_malloc64($3, $2);
     if (!$1) {
      break label$1;
     }
     $1 = __memcpy($1, HEAP32[$0 + 4 >> 2], HEAP32[$0 + 16 >> 2]);
     HEAP8[$0 + 24 | 0] = 0;
     break label$3;
    }
    $1 = sqlite3_realloc64(HEAP32[$0 + 4 >> 2], $3, $2);
    if (!$1) {
     break label$1;
    }
   }
   HEAP32[$0 + 4 >> 2] = $1;
   HEAP32[$0 + 8 >> 2] = $3;
   HEAP32[$0 + 12 >> 2] = $2;
   $1 = 0;
  }
  return $1;
 }
 jsonOom($0);
 return 7;
}

function fts3IncrmergeChomp($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $7 = HEAP32[$3 + 4 >> 2];
 while (1) {
  if (!(($7 | 0) <= 0 | $5)) {
   $7 = $7 - 1 | 0;
   $6 = 0;
   $5 = HEAP32[$3 + 4 >> 2];
   $9 = ($5 | 0) > 0 ? $5 : 0;
   $5 = 0;
   while (1) {
    if (($5 | 0) != ($9 | 0)) {
     $6 = $5 << 2;
     $5 = $5 + 1 | 0;
     $6 = HEAP32[HEAP32[$3 >> 2] + $6 >> 2];
     if (HEAP32[$6 >> 2] != ($7 | 0)) {
      continue;
     }
    }
    break;
   }
   if (HEAP32[$6 + 40 >> 2]) {
    $8 = $8 + 1 | 0;
    $5 = fts3TruncateSegment($0, $1, $2, HEAP32[$6 >> 2], HEAP32[$6 + 64 >> 2], HEAP32[$6 + 60 >> 2]);
   } else {
    $5 = fts3DeleteSegment($0, $6);
    if (!$5) {
     $5 = fts3RemoveSegdirEntry($0, $1, $2, HEAP32[$6 >> 2]);
    }
    HEAP32[$4 >> 2] = 0;
   }
   continue;
  }
  break;
 }
 label$8: {
  if ($5) {
   break label$8;
  }
  $5 = 0;
  if (HEAP32[$3 + 4 >> 2] == ($8 | 0)) {
   break label$8;
  }
  $5 = fts3RepackSegdirLevel($0, $1, $2);
 }
 HEAP32[$4 >> 2] = $8;
 return $5;
}

function sqlite3HashInsert($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = findElementWithHash($0, $1, $4 + 12 | 0);
 $5 = HEAP32[$3 + 8 >> 2];
 label$1: {
  if ($5) {
   if (!$2) {
    removeElementGivenHash($0, $3, HEAP32[$4 + 12 >> 2]);
    break label$1;
   }
   HEAP32[$3 + 12 >> 2] = $1;
   HEAP32[$3 + 8 >> 2] = $2;
   break label$1;
  }
  if (!$2) {
   $5 = 0;
   break label$1;
  }
  $3 = sqlite3Malloc(16, 0);
  if (!$3) {
   $5 = $2;
   break label$1;
  }
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $1;
  $2 = HEAP32[$0 + 4 >> 2] + 1 | 0;
  HEAP32[$0 + 4 >> 2] = $2;
  label$6: {
   if ($2 >>> 0 < 10 | HEAP32[$0 >> 2] << 1 >>> 0 >= $2 >>> 0) {
    break label$6;
   }
   if (!rehash($0, $2 << 1)) {
    break label$6;
   }
   HEAP32[$4 + 12 >> 2] = (strHash($1) >>> 0) % HEAPU32[$0 >> 2];
  }
  $5 = 0;
  $2 = HEAP32[$0 + 12 >> 2];
  insertElement($0, $2 ? $2 + (HEAP32[$4 + 12 >> 2] << 3) | 0 : 0, $3);
 }
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function sqlite3VdbeSorterCompare($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$0 + 40 >> 2];
 $0 = HEAP32[$0 + 36 >> 2];
 $4 = HEAP32[$0 + 32 >> 2];
 label$1: {
  if (!$4) {
   $4 = sqlite3VdbeAllocUnpackedRecord($6);
   HEAP32[$0 + 32 >> 2] = $4;
   $7 = 7;
   if (!$4) {
    break label$1;
   }
   HEAP16[$4 + 20 >> 1] = $2;
  }
  $0 = vdbeSorterRowkey($0, $5 + 12 | 0);
  sqlite3VdbeRecordUnpack($6, HEAP32[$5 + 12 >> 2], $0, $4);
  $0 = 0;
  $6 = ($2 | 0) > 0 ? $2 : 0;
  label$3: {
   label$4: {
    while (1) {
     if (($0 | 0) == ($6 | 0)) {
      break label$4;
     }
     $2 = Math_imul($0, 40);
     $0 = $0 + 1 | 0;
     if (!(HEAP8[(HEAP32[$4 + 4 >> 2] + $2 | 0) + 16 | 0] & 1)) {
      continue;
     }
     break;
    }
    $0 = -1;
    break label$3;
   }
   $0 = sqlite3VdbeRecordCompare(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 8 >> 2], $4);
  }
  HEAP32[$3 >> 2] = $0;
  $7 = 0;
 }
 __stack_pointer = $5 + 16 | 0;
 $0 = $7;
 return $0;
}

function parserDoubleLinkSelect($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (!HEAP32[$1 + 52 >> 2]) {
   break label$1;
  }
  $6 = 1;
  $3 = $1;
  label$2: {
   label$3: {
    while (1) {
     $2 = $3;
     HEAP32[$2 + 56 >> 2] = $5;
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 256;
     $3 = HEAP32[$2 + 52 >> 2];
     if (!$3) {
      break label$2;
     }
     $6 = $6 + 1 | 0;
     $5 = 18094;
     if (HEAP32[$3 + 48 >> 2]) {
      break label$3;
     }
     $5 = $2;
     if (!HEAP32[$3 + 60 >> 2]) {
      continue;
     }
     break;
    }
    $5 = 18320;
   }
   HEAP32[$4 + 4 >> 2] = sqlite3SelectOpName(HEAPU8[$2 | 0]);
   $3 = $5;
   HEAP32[$4 >> 2] = $3;
   sqlite3ErrorMsg($0, 13021, $4);
  }
  if (HEAPU8[$1 + 5 | 0] & 4) {
   break label$1;
  }
  $2 = HEAP32[HEAP32[$0 >> 2] + 136 >> 2];
  if (($2 | 0) <= 0 | ($2 | 0) >= ($6 | 0)) {
   break label$1;
  }
  sqlite3ErrorMsg($0, 18378, 0);
 }
 __stack_pointer = $4 + 16 | 0;
}

function fts3DeclareVtab($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 if (!HEAP32[$0 >> 2]) {
  $3 = HEAP32[$1 + 44 >> 2];
  $4 = HEAP32[$1 + 12 >> 2];
  HEAP32[$2 + 48 >> 2] = 1;
  sqlite3_vtab_config($4, 1, $2 + 48 | 0);
  HEAP32[$2 + 32 >> 2] = HEAP32[HEAP32[$1 + 28 >> 2] >> 2];
  $5 = $3 ? $3 : 14508;
  $4 = sqlite3_mprintf(29580, $2 + 32 | 0);
  $3 = 1;
  while (1) {
   if (!(!$4 | HEAP32[$1 + 24 >> 2] <= ($3 | 0))) {
    HEAP32[$2 + 20 >> 2] = HEAP32[HEAP32[$1 + 28 >> 2] + ($3 << 2) >> 2];
    HEAP32[$2 + 16 >> 2] = $4;
    $3 = $3 + 1 | 0;
    $4 = sqlite3_mprintf(29578, $2 + 16 | 0);
    continue;
   }
   break;
  }
  $3 = HEAP32[$1 + 20 >> 2];
  HEAP32[$2 + 8 >> 2] = $5;
  HEAP32[$2 + 4 >> 2] = $3;
  HEAP32[$2 >> 2] = $4;
  $5 = 7;
  $3 = sqlite3_mprintf(25454, $2);
  if (!(!$4 | !$3)) {
   $5 = sqlite3_declare_vtab(HEAP32[$1 + 12 >> 2], $3);
  }
  sqlite3_free($3);
  sqlite3_free($4);
  HEAP32[$0 >> 2] = $5;
 }
 __stack_pointer = $2 - -64 | 0;
}

function whereCombineDisjuncts($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  if ((HEAPU16[$3 + 10 >> 1] | HEAPU16[$2 + 10 >> 1]) & 128) {
   break label$1;
  }
  $4 = HEAPU16[$2 + 12 >> 1];
  if (!($4 & 62)) {
   break label$1;
  }
  $5 = HEAPU16[$3 + 12 >> 1];
  if (!($5 & 62)) {
   break label$1;
  }
  $4 = $4 | $5;
  if (($4 | 0) != ($4 & 26) & ($4 & 38) != ($4 | 0)) {
   break label$1;
  }
  if (sqlite3ExprCompare(0, HEAP32[HEAP32[$2 >> 2] + 12 >> 2], HEAP32[HEAP32[$3 >> 2] + 12 >> 2], -1)) {
   break label$1;
  }
  if (sqlite3ExprCompare(0, HEAP32[HEAP32[$2 >> 2] + 16 >> 2], HEAP32[HEAP32[$3 >> 2] + 16 >> 2], -1)) {
   break label$1;
  }
  $5 = sqlite3ExprDup(HEAP32[HEAP32[HEAP32[$1 >> 2] >> 2] >> 2], HEAP32[$2 >> 2], 0);
  if (!$5) {
   break label$1;
  }
  $4 = $4 - 1 & $4 ? $4 & 24 ? 8 : 32 : $4;
  $2 = 53;
  while (1) {
   $3 = $2;
   $2 = $3 + 1 | 0;
   if (2 << $3 - 53 != ($4 | 0)) {
    continue;
   }
   break;
  }
  HEAP8[$5 | 0] = $3;
  exprAnalyze($0, $1, whereClauseInsert($1, $5, 3));
 }
}

function unixRandomness($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = memset($2, 0, $1);
 HEAP32[17716] = getpid();
 $0 = robust_open(10919, 0, 0);
 label$1: {
  if (($0 | 0) >= 0) {
   while (1) {
    if ((FUNCTION_TABLE[HEAP32[16261]]($0, $2, $1) | 0) < 0) {
     if (HEAP32[__errno_location() >> 2] == 27) {
      continue;
     }
    }
    break;
   }
   robust_close(0, $0, 42137);
   break label$1;
  }
  __time($3 + 8 | 0);
  $0 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$3 + 8 >> 2];
  HEAP8[$2 | 0] = $1;
  HEAP8[$2 + 1 | 0] = $1 >>> 8;
  HEAP8[$2 + 2 | 0] = $1 >>> 16;
  HEAP8[$2 + 3 | 0] = $1 >>> 24;
  HEAP8[$2 + 4 | 0] = $0;
  HEAP8[$2 + 5 | 0] = $0 >>> 8;
  HEAP8[$2 + 6 | 0] = $0 >>> 16;
  HEAP8[$2 + 7 | 0] = $0 >>> 24;
  $0 = HEAP32[17716];
  HEAP8[$2 + 8 | 0] = $0;
  HEAP8[$2 + 9 | 0] = $0 >>> 8;
  HEAP8[$2 + 10 | 0] = $0 >>> 16;
  HEAP8[$2 + 11 | 0] = $0 >>> 24;
  $1 = 12;
 }
 __stack_pointer = $3 + 16 | 0;
 return $1 | 0;
}

function fts3SnippetFindPositions($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $6 = HEAP32[$2 + 16 >> 2];
 $5 = $6 + Math_imul($1, 40) | 0;
 HEAP32[$5 >> 2] = HEAP32[HEAP32[$0 + 20 >> 2] + 64 >> 2];
 $2 = sqlite3Fts3EvalPhrasePoslist(HEAP32[$2 >> 2], $0, HEAP32[$2 + 4 >> 2], $4 + 12 | 0);
 $0 = HEAP32[$4 + 12 >> 2];
 label$1: {
  if (!$0) {
   break label$1;
  }
  $3 = $4;
  HEAP32[$3 >> 2] = 0;
  HEAP32[$3 + 4 >> 2] = 0;
  HEAP32[$5 + 4 >> 2] = $0;
  fts3GetDeltaPosition($3 + 12 | 0, $3);
  $7 = HEAP32[$3 >> 2];
  $3 = HEAP32[$3 + 4 >> 2];
  $5 = $3;
  if (($3 | 0) < 0) {
   $2 = 267;
   break label$1;
  }
  $0 = Math_imul($1, 40) + $6 | 0;
  $1 = HEAP32[$4 + 12 >> 2];
  HEAP32[$0 + 32 >> 2] = $1;
  HEAP32[$0 + 16 >> 2] = $1;
  $3 = $0;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[$3 + 28 >> 2] = $5;
  HEAP32[$3 + 8 >> 2] = $7;
  HEAP32[$3 + 12 >> 2] = $5;
 }
 __stack_pointer = $4 + 16 | 0;
 return $2 | 0;
}

function sqlite3UniqueConstraint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $6 = HEAP32[$2 + 12 >> 2];
 $5 = HEAP32[$0 >> 2];
 sqlite3StrAccumInit($3 + 8 | 0, $5, 0, 0, HEAP32[$5 + 120 >> 2]);
 label$1: {
  if (!HEAP32[$2 + 40 >> 2]) {
   while (1) {
    if (HEAPU16[$2 + 50 >> 1] <= $4 >>> 0) {
     break label$1;
    }
    $5 = HEAP32[HEAP32[$6 + 4 >> 2] + Math_imul(HEAP16[HEAP32[$2 + 4 >> 2] + ($4 << 1) >> 1], 12) >> 2];
    if ($4) {
     sqlite3_str_append($3 + 8 | 0, 29582, 2);
    }
    sqlite3_str_appendall($3 + 8 | 0, HEAP32[$6 >> 2]);
    sqlite3_str_append($3 + 8 | 0, 24266, 1);
    sqlite3_str_appendall($3 + 8 | 0, $5);
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  HEAP32[$3 >> 2] = HEAP32[$2 >> 2];
  sqlite3_str_appendf($3 + 8 | 0, 27512, $3);
 }
 $4 = sqlite3StrAccumFinish($3 + 8 | 0);
 sqlite3HaltConstraint($0, ((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) & 3) == 2 ? 1555 : 2067, $1, $4, -6, 2);
 __stack_pointer = $3 + 32 | 0;
}

function soundex($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  while (1) {
   $2 = HEAPU8[$0 + $3 | 0];
   if (!$2) {
    break label$1;
   }
   if (!isalpha($2)) {
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$1 | 0] = toupper($2);
  $2 = 1;
  while (1) {
   label$5: {
    if (($2 | 0) > 3) {
     break label$5;
    }
    $4 = HEAPU8[$0 + $3 | 0];
    if (!$4) {
     break label$5;
    }
    $4 = HEAPU8[($4 & 127) + 56e3 | 0];
    if ($4) {
     HEAP8[$1 + $2 | 0] = $4 + 48;
     $2 = $2 + 1 | 0;
    }
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  $3 = ($2 | 0) > 4 ? $2 : 4;
  while (1) {
   if (($2 | 0) != ($3 | 0)) {
    HEAP8[$1 + $2 | 0] = 48;
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$1 + $3 | 0] = 0;
  return;
 }
 HEAP8[$1 + 4 | 0] = HEAPU8[23940];
 $0 = HEAPU8[23936] | HEAPU8[23937] << 8 | (HEAPU8[23938] << 16 | HEAPU8[23939] << 24);
 HEAP8[$1 | 0] = $0;
 HEAP8[$1 + 1 | 0] = $0 >>> 8;
 HEAP8[$1 + 2 | 0] = $0 >>> 16;
 HEAP8[$1 + 3 | 0] = $0 >>> 24;
}

function leftFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 if (($1 | 0) == 2) {
  label$2: {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
    if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
     break label$2;
    }
   }
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
  $2 = sqlite3_value_int(HEAP32[$2 + 4 >> 2]);
  $5 = ($2 | 0) > 0 ? $2 : 0;
  $2 = $3;
  while (1) {
   if (!(!sqlite3ReadUtf8($2) | ($4 | 0) == ($5 | 0))) {
    $4 = $4 + 1 | 0;
    while (1) {
     $1 = HEAPU8[$2 + 1 | 0];
     $2 = $2 + 1 | 0;
     if (($1 & 192) == 128) {
      continue;
     }
     break;
    }
    continue;
   }
   break;
  }
  $2 = $2 - $3 | 0;
  $1 = sqlite3_malloc($2 + 1 | 0);
  if (!$1) {
   sqlite3_result_error_nomem($0);
   return;
  }
  $1 = strncpy($1, $3, $2);
  HEAP8[$2 + $1 | 0] = 0;
  sqlite3_result_text($0, $1, -1, -1);
  sqlite3_free($1);
  return;
 }
 __assert_fail(23018, 17353, 1073, 17037);
 abort();
}

function fts3DeleteSegdir($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 12 >> 2] = 0;
 while (1) {
  if (!(($5 | 0) <= ($6 | 0) | $7)) {
   $7 = fts3DeleteSegment($0, HEAP32[($6 << 2) + $4 >> 2]);
   $6 = $6 + 1 | 0;
   continue;
  }
  break;
 }
 label$3: {
  if ($7) {
   break label$3;
  }
  label$4: {
   if (($3 | 0) == -2) {
    $7 = fts3SqlStmt($0, 26, $8 + 12 | 0, 0);
    if ($7) {
     break label$3;
    }
    $6 = HEAP32[$8 + 12 >> 2];
    sqlite3_bind_int64($6, 1, getAbsoluteLevel($0, $1, $2, 0), i64toi32_i32$HIGH_BITS);
    sqlite3_bind_int64($6, 2, getAbsoluteLevel($0, $1, $2, 1023), i64toi32_i32$HIGH_BITS);
    break label$4;
   }
   $7 = fts3SqlStmt($0, 16, $8 + 12 | 0, 0);
   if ($7) {
    break label$3;
   }
   $6 = HEAP32[$8 + 12 >> 2];
   sqlite3_bind_int64($6, 1, getAbsoluteLevel($0, $1, $2, $3), i64toi32_i32$HIGH_BITS);
  }
  sqlite3_step($6);
  $7 = sqlite3_reset($6);
 }
 __stack_pointer = $8 + 16 | 0;
 return $7;
}

function sqlite3FixTriggerStep($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = $0 + 4 | 0;
 while (1) {
  if (!$1) {
   return 0;
  }
  label$3: {
   label$4: {
    if (sqlite3WalkSelect($2, HEAP32[$1 + 8 >> 2])) {
     break label$4;
    }
    if (sqlite3WalkExpr($2, HEAP32[$1 + 20 >> 2])) {
     break label$4;
    }
    if (sqlite3WalkExprList($2, HEAP32[$1 + 24 >> 2])) {
     break label$4;
    }
    if (sqlite3FixSrcList($0, HEAP32[$1 + 16 >> 2])) {
     break label$4;
    }
    $4 = $1 + 32 | 0;
    while (1) {
     $3 = HEAP32[$4 >> 2];
     if (!$3) {
      break label$3;
     }
     if (sqlite3WalkExprList($2, HEAP32[$3 >> 2])) {
      break label$4;
     }
     if (sqlite3WalkExpr($2, HEAP32[$3 + 4 >> 2])) {
      break label$4;
     }
     if (sqlite3WalkExprList($2, HEAP32[$3 + 8 >> 2])) {
      break label$4;
     }
     $4 = $3 + 16 | 0;
     if (!sqlite3WalkExpr($2, HEAP32[$3 + 12 >> 2])) {
      continue;
     }
     break;
    }
   }
   return 1;
  }
  $1 = HEAP32[$1 + 40 >> 2];
  continue;
 }
}

function putVarint64($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 16 | 0;
 label$1: {
  if ($2 >>> 0 < 16777216) {
   $4 = 1;
   while (1) {
    $3 = $6;
    HEAP8[$3 + ($5 + 6 | 0) | 0] = $1 | 128;
    $7 = $4;
    $4 = $4 + 1 | 0;
    $6 = $3 + 1 | 0;
    $8 = !$2 & $1 >>> 0 > 127 | ($2 | 0) != 0;
    $1 = ($2 & 127) << 25 | $1 >>> 7;
    $2 = $2 >>> 7 | 0;
    if ($8) {
     continue;
    }
    break;
   }
   HEAP8[$5 + 6 | 0] = HEAPU8[$5 + 6 | 0] & 127;
   $4 = 0;
   while (1) {
    if (($4 | 0) == ($7 | 0)) {
     break label$1;
    }
    HEAP8[$0 + $4 | 0] = HEAPU8[($5 + 6 | 0) + $3 | 0];
    $4 = $4 + 1 | 0;
    $3 = $3 - 1 | 0;
    continue;
   }
  }
  HEAP8[$0 + 8 | 0] = $1;
  $1 = ($2 & 255) << 24 | $1 >>> 8;
  $2 = $2 >>> 8 | 0;
  $3 = 7;
  while (1) {
   if (($3 | 0) >= 0) {
    HEAP8[$0 + $3 | 0] = $1 | 128;
    $3 = $3 - 1 | 0;
    $1 = ($2 & 127) << 25 | $1 >>> 7;
    $2 = $2 >>> 7 | 0;
    continue;
   }
   break;
  }
  $6 = 9;
 }
 return $6;
}

function exprListAppendList($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $8 = $1 ? HEAP32[$1 >> 2] : $8;
  while (1) {
   if (HEAP32[$2 >> 2] <= ($5 | 0)) {
    break label$1;
   }
   $4 = HEAP32[$0 >> 2];
   $9 = ($5 << 4) + $2 | 0;
   $7 = sqlite3ExprDup($4, HEAP32[$9 + 8 >> 2], 0);
   if (!HEAPU8[$4 + 87 | 0]) {
    label$5: {
     if (!$3) {
      break label$5;
     }
     $4 = sqlite3ExprSkipCollateAndLikely($7);
     if (!sqlite3ExprIsInteger($4, $6 + 12 | 0)) {
      break label$5;
     }
     HEAP8[$4 | 0] = 121;
     HEAP32[$4 + 8 >> 2] = 0;
     HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] & -805308417;
    }
    $1 = sqlite3ExprListAppend($0, $1, $7);
    if ($1) {
     HEAP8[(($5 + $8 << 4) + $1 | 0) + 16 | 0] = HEAPU8[$9 + 16 | 0];
    }
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3ExprDelete($4, $7);
 }
 __stack_pointer = $6 + 16 | 0;
 return $1;
}

function vdbePmaReaderNext($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 $4 = HEAP32[$0 + 12 >> 2];
 label$1: {
  if (($2 | 0) >= ($4 | 0) & HEAPU32[$0 >> 2] >= HEAPU32[$0 + 8 >> 2] | ($2 | 0) > ($4 | 0)) {
   label$3: {
    $2 = HEAP32[$0 + 48 >> 2];
    label$4: {
     if (!$2) {
      break label$4;
     }
     $1 = vdbeIncrSwap($2);
     if ($1) {
      break label$4;
     }
     $1 = 0;
     if (!HEAP32[$2 + 20 >> 2]) {
      break label$3;
     }
    }
    vdbePmaReaderClear($0);
    break label$1;
   }
   $1 = vdbePmaReaderSeek(HEAP32[$2 >> 2], $0, $2 + 32 | 0, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
   if ($1) {
    break label$1;
   }
  }
  $1 = vdbePmaReadVarint($0, $3 + 8 | 0);
  if ($1) {
   break label$1;
  }
  $1 = HEAP32[$3 + 8 >> 2];
  HEAP32[$0 + 20 >> 2] = $1;
  $1 = vdbePmaReadBlob($0, $1, $0 + 32 | 0);
 }
 __stack_pointer = $3 + 16 | 0;
 return $1;
}

function sqlite3PagerBegin($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 44 >> 2];
 label$1: {
  if ($3) {
   break label$1;
  }
  HEAP8[$0 + 22 | 0] = $2;
  $3 = 0;
  if (HEAPU8[$0 + 17 | 0] != 1) {
   break label$1;
  }
  $3 = HEAP32[$0 + 232 >> 2];
  label$2: {
   if ($3) {
    label$4: {
     if (!HEAPU8[$0 + 4 | 0]) {
      break label$4;
     }
     if (!sqlite3WalExclusiveMode($3, -1)) {
      break label$4;
     }
     $3 = pagerLockDb($0, 4);
     if ($3) {
      break label$1;
     }
     sqlite3WalExclusiveMode(HEAP32[$0 + 232 >> 2], 1);
    }
    $3 = sqlite3WalBeginWriteTransaction(HEAP32[$0 + 232 >> 2]);
    break label$2;
   }
   $3 = pagerLockDb($0, 2);
   if ($3 | !$1) {
    break label$2;
   }
   $3 = pager_wait_on_lock($0, 4);
  }
  if ($3) {
   break label$1;
  }
  HEAP8[$0 + 17 | 0] = 2;
  HEAP32[$0 + 80 >> 2] = 0;
  HEAP32[$0 + 84 >> 2] = 0;
  $3 = HEAP32[$0 + 28 >> 2];
  HEAP32[$0 + 40 >> 2] = $3;
  HEAP32[$0 + 36 >> 2] = $3;
  HEAP32[$0 + 32 >> 2] = $3;
  $3 = 0;
 }
 return $3;
}

function sqlite3VdbeClearObject($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$1 + 116 >> 2];
 if ($2) {
  releaseMemArray($2, HEAPU16[$1 + 144 >> 1] << 1);
  sqlite3DbFreeNN($0, HEAP32[$1 + 116 >> 2]);
 }
 $2 = HEAP32[$1 + 228 >> 2];
 while (1) {
  if ($2) {
   $3 = HEAP32[$2 + 24 >> 2];
   vdbeFreeOpArray($0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
   sqlite3DbFree($0, $2);
   $2 = $3;
   continue;
  }
  break;
 }
 label$4: {
  if (!HEAPU8[$1 + 149 | 0]) {
   break label$4;
  }
  releaseMemArray(HEAP32[$1 + 100 >> 2], HEAP16[$1 + 16 >> 1]);
  $2 = HEAP32[$1 + 128 >> 2];
  if ($2) {
   sqlite3DbFreeNN($0, $2);
  }
  $2 = HEAP32[$1 + 208 >> 2];
  if (!$2) {
   break label$4;
  }
  sqlite3DbFreeNN($0, $2);
 }
 vdbeFreeOpArray($0, HEAP32[$1 + 104 >> 2], HEAP32[$1 + 108 >> 2]);
 sqlite3DbFree($0, HEAP32[$1 + 196 >> 2]);
 sqlite3DbFree($0, HEAP32[$1 + 200 >> 2]);
 $2 = HEAP32[$1 + 204 >> 2];
 while (1) {
  if ($2) {
   $3 = HEAP32[$2 >> 2];
   sqlite3DbFree($0, $2);
   $2 = $3;
   continue;
  }
  break;
 }
}

function parseYyyyMmDd($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $4 = HEAPU8[$0 | 0];
 HEAP32[$2 + 8 >> 2] = $2 + 20;
 HEAP32[$2 + 4 >> 2] = $2 + 24;
 HEAP32[$2 >> 2] = $2 + 28;
 $3 = 1;
 $0 = (($4 | 0) == 45) + $0 | 0;
 label$1: {
  if ((getDigits($0, 15881, $2) | 0) != 3) {
   break label$1;
  }
  $3 = $0 + 10 | 0;
  while (1) {
   $0 = $3;
   $3 = $0 + 1 | 0;
   $5 = HEAPU8[$0 | 0];
   if (HEAP8[$5 + 30288 | 0] & 1 | ($5 | 0) == 84) {
    continue;
   }
   break;
  }
  if (parseHhMmSs($0, $1)) {
   $3 = 1;
   if (HEAPU8[$0 | 0]) {
    break label$1;
   }
   HEAP8[$1 + 43 | 0] = 0;
  }
  HEAP8[$1 + 42 | 0] = 1;
  $3 = 0;
  HEAP8[$1 + 40 | 0] = 0;
  $0 = HEAP32[$2 + 28 >> 2];
  HEAP32[$1 + 8 >> 2] = ($4 | 0) == 45 ? 0 - $0 | 0 : $0;
  HEAP32[$1 + 12 >> 2] = HEAP32[$2 + 24 >> 2];
  HEAP32[$1 + 16 >> 2] = HEAP32[$2 + 20 >> 2];
  if (!HEAPU8[$1 + 44 | 0]) {
   break label$1;
  }
  computeJD($1);
 }
 __stack_pointer = $2 + 32 | 0;
 return $3;
}

function jsonReplaceFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 label$1: {
  if (($1 | 0) <= 0) {
   break label$1;
  }
  if (!($1 & 1)) {
   jsonWrongNumArgs($0, 14149);
   break label$1;
  }
  if (jsonParse($4, $0, sqlite3_value_text(HEAP32[$2 >> 2]))) {
   break label$1;
  }
  $3 = 1;
  label$3: {
   while (1) {
    if ($1 >>> 0 > $3 >>> 0) {
     $5 = jsonLookup($4, sqlite3_value_text(HEAP32[($3 << 2) + $2 >> 2]), 0, $0);
     if (HEAPU8[$4 + 21 | 0]) {
      break label$3;
     }
     if ($5) {
      HEAP32[$5 + 8 >> 2] = $3 + 1;
      HEAP8[$5 + 1 | 0] = HEAPU8[$5 + 1 | 0] | 8;
     }
     $3 = $3 + 2 | 0;
     continue;
    }
    break;
   }
   $3 = HEAP32[$4 + 8 >> 2];
   if (HEAPU8[$3 + 1 | 0] & 8) {
    sqlite3_result_value($0, HEAP32[(HEAP32[$3 + 8 >> 2] << 2) + $2 >> 2]);
    break label$3;
   }
   jsonReturnJson($3, $0, $2);
  }
  jsonParseReset($4);
 }
 __stack_pointer = $4 + 32 | 0;
}

function fts3MatchinfoSize($0, $1) {
 var $2 = 0;
 $2 = 1;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      label$6: {
       label$7: {
        switch ($1 - 108 | 0) {
        case 2:
        case 4:
         break label$2;

        case 1:
        case 3:
        case 5:
        case 6:
         break label$3;

        case 0:
        case 7:
         break label$6;

        default:
         break label$7;
        }
       }
       switch ($1 - 97 | 0) {
       case 2:
        break label$2;

       case 1:
        break label$5;

       case 0:
        break label$6;

       default:
        break label$4;
       }
      }
      return HEAP32[$0 + 4 >> 2];
     }
     return Math_imul(HEAP32[$0 + 8 >> 2], (HEAP32[$0 + 4 >> 2] + 31 | 0) / 32 | 0);
    }
    if (($1 | 0) == 121) {
     break label$1;
    }
   }
   $2 = Math_imul(Math_imul(HEAP32[$0 + 4 >> 2], HEAP32[$0 + 8 >> 2]), 3);
  }
  return $2;
 }
 return Math_imul(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 4 >> 2]);
}

function pcache1Create($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = Math_imul(HEAP32[17733], 52) + 68 | 0;
 $4 = sqlite3MallocZero($3, $3 >> 31);
 if ($4) {
  if (HEAP32[17733]) {
   HEAP32[$4 + 80 >> 2] = 10;
   $3 = $4 + 68 | 0;
  } else {
   $3 = 70876;
  }
  if (!HEAPU16[$3 + 34 >> 1]) {
   HEAP16[$3 + 34 >> 1] = 1;
   $5 = $3 + 20 | 0;
   HEAP32[$3 + 48 >> 2] = $5;
   HEAP32[$3 + 44 >> 2] = $5;
  }
  HEAP32[$4 + 12 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $0;
  HEAP32[$4 >> 2] = $3;
  HEAP32[$4 + 20 >> 2] = ($2 | 0) != 0;
  HEAP32[$4 + 16 >> 2] = ($0 + $1 | 0) + 32;
  pcache1ResizeHash($4);
  label$5: {
   if ($2) {
    HEAP32[$4 + 24 >> 2] = 10;
    $2 = HEAP32[$3 + 8 >> 2];
    HEAP32[$3 + 8 >> 2] = $2 + 10;
    HEAP32[$3 + 12 >> 2] = HEAP32[$3 + 4 >> 2] - $2;
    $3 = $3 + 16 | 0;
    break label$5;
   }
   $3 = $4 + 40 | 0;
  }
  HEAP32[$4 + 4 >> 2] = $3;
  if (HEAP32[$4 + 52 >> 2]) {
   return $4 | 0;
  }
  pcache1Destroy($4);
 }
 return 0;
}

function saveCursorKey($0) {
 var $1 = 0, $2 = 0;
 if (HEAPU8[$0 + 69 | 0]) {
  HEAP32[$0 + 56 >> 2] = sqlite3BtreeIntegerKey($0);
  HEAP32[$0 + 60 >> 2] = i64toi32_i32$HIGH_BITS;
  return 0;
 }
 $2 = sqlite3BtreePayloadSize($0);
 HEAP32[$0 + 56 >> 2] = $2;
 HEAP32[$0 + 60 >> 2] = 0;
 $2 = $2 + 17 | 0;
 $1 = $2 >>> 0 < 17 ? 1 : $1;
 $2 = sqlite3Malloc($2, $1);
 if (!$2) {
  return 7;
 }
 $1 = sqlite3BtreePayload($0, 0, HEAP32[$0 + 56 >> 2], $2);
 if (!$1) {
  $1 = HEAP32[$0 + 56 >> 2] + $2 | 0;
  HEAP8[$1 | 0] = 0;
  HEAP8[$1 + 1 | 0] = 0;
  HEAP8[$1 + 2 | 0] = 0;
  HEAP8[$1 + 3 | 0] = 0;
  HEAP8[$1 + 4 | 0] = 0;
  HEAP8[$1 + 5 | 0] = 0;
  HEAP8[$1 + 6 | 0] = 0;
  HEAP8[$1 + 7 | 0] = 0;
  HEAP8[$1 + 16 | 0] = 0;
  HEAP8[$1 + 8 | 0] = 0;
  HEAP8[$1 + 9 | 0] = 0;
  HEAP8[$1 + 10 | 0] = 0;
  HEAP8[$1 + 11 | 0] = 0;
  HEAP8[$1 + 12 | 0] = 0;
  HEAP8[$1 + 13 | 0] = 0;
  HEAP8[$1 + 14 | 0] = 0;
  HEAP8[$1 + 15 | 0] = 0;
  HEAP32[$0 + 16 >> 2] = $2;
  return 0;
 }
 sqlite3_free($2);
 return $1;
}

function fts3EvalAllocateReaders($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 label$1: {
  while (1) {
   if (HEAP32[$4 >> 2] | !$1) {
    break label$1;
   }
   label$3: {
    $5 = HEAP32[$1 >> 2];
    if (($5 | 0) == 5) {
     $5 = HEAP32[HEAP32[$1 + 20 >> 2] + 64 >> 2];
     HEAP32[$2 >> 2] = $5 + HEAP32[$2 >> 2];
     $3 = 0;
     $6 = ($5 | 0) > 0 ? $5 : 0;
     while (1) {
      $5 = HEAP32[$1 + 20 >> 2];
      if (($3 | 0) == ($6 | 0)) {
       break label$3;
      }
      $2 = Math_imul($3, 24);
      $3 = $3 + 1 | 0;
      $5 = $2 + $5 | 0;
      $5 = fts3TermSegReaderCursor($0, HEAP32[$5 + 72 >> 2], HEAP32[$5 + 76 >> 2], HEAP32[$5 + 80 >> 2], $5 + 92 | 0);
      if (!$5) {
       continue;
      }
      break;
     }
     HEAP32[$4 >> 2] = $5;
     return;
    }
    HEAP32[$3 >> 2] = HEAP32[$3 >> 2] + (($5 | 0) == 4);
    fts3EvalAllocateReaders($0, HEAP32[$1 + 12 >> 2], $2, $3, $4);
    $1 = HEAP32[$1 + 16 >> 2];
    continue;
   }
   break;
  }
  HEAP32[$5 + 44 >> 2] = -1;
 }
}

function btreeOverwriteContent($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = HEAP32[$2 + 28 >> 2];
 $6 = $5 - $3 | 0;
 label$1: {
  label$2: {
   if (($6 | 0) <= 0) {
    $6 = ($4 | 0) > 0 ? $4 : 0;
    while (1) {
     if (($6 | 0) == ($7 | 0)) {
      break label$2;
     }
     $2 = $1 + $7 | 0;
     if (!HEAPU8[$2 | 0]) {
      $7 = $7 + 1 | 0;
      continue;
     }
     break;
    }
    $5 = sqlite3PagerWrite(HEAP32[$0 + 72 >> 2]);
    if ($5) {
     break label$1;
    }
    memset($2, 0, $4 - $7 | 0);
    return 0;
   }
   label$6: {
    if (($4 | 0) <= ($6 | 0)) {
     $6 = $4;
     break label$6;
    }
    $5 = btreeOverwriteContent($0, $1 + $6 | 0, $2, $5, $4 - $6 | 0);
    if ($5) {
     break label$1;
    }
   }
   $5 = 0;
   if (!memcmp($1, HEAP32[$2 + 16 >> 2] + $3 | 0, $6)) {
    break label$1;
   }
   $5 = sqlite3PagerWrite(HEAP32[$0 + 72 >> 2]);
   if ($5) {
    break label$1;
   }
   memmove($1, HEAP32[$2 + 16 >> 2] + $3 | 0, $6);
  }
  $5 = 0;
 }
 return $5;
}

function fts3TermSelectFinishMerge($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  label$2: {
   while (1) {
    if (($6 | 0) != 16) {
     $4 = ($6 << 2) + $1 | 0;
     $2 = HEAP32[$4 >> 2];
     label$5: {
      if (!$2) {
       break label$5;
      }
      if (!$5) {
       $7 = HEAP32[$4 - -64 >> 2];
       HEAP32[$4 >> 2] = 0;
       $5 = $2;
       break label$5;
      }
      $2 = fts3DoclistOrMerge(HEAPU8[$0 + 239 | 0], $2, HEAP32[$4 - -64 >> 2], $5, $7, $3 + 8 | 0, $3 + 12 | 0);
      if ($2) {
       break label$2;
      }
      sqlite3_free(HEAP32[$4 >> 2]);
      sqlite3_free($5);
      HEAP32[$4 >> 2] = 0;
      $7 = HEAP32[$3 + 12 >> 2];
      $5 = HEAP32[$3 + 8 >> 2];
     }
     $6 = $6 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$1 + 64 >> 2] = $7;
   HEAP32[$1 >> 2] = $5;
   $2 = 0;
   break label$1;
  }
  sqlite3_free($5);
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3Fts3GetVarintBounded($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
 $13 = $0 + 10 | 0;
 $6 = $0;
 while (1) {
  label$2: {
   $5 = $9;
   if (!$5 & $8 >>> 0 > 63 | $5) {
    $6 = $13;
    break label$2;
   }
   $10 = 0;
   if ($1 >>> 0 > $6 >>> 0) {
    $10 = HEAPU8[$6 | 0];
   }
   $6 = $6 + 1 | 0;
   $4 = $10;
   $5 = $4 & 127;
   $7 = $8;
   $3 = $7 & 31;
   if (($7 & 63) >>> 0 >= 32) {
    $4 = $5 << $3;
    $3 = 0;
   } else {
    $4 = (1 << $3) - 1 & $5 >>> 32 - $3;
    $3 = $5 << $3;
   }
   $5 = $11;
   $4 = $4 + $5 | 0;
   $7 = $12;
   $3 = $3 + $7 | 0;
   $12 = $3;
   $4 = $3 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
   $11 = $4;
   $4 = $9;
   $3 = $4;
   $5 = $8 + 7 | 0;
   $3 = $5 >>> 0 < 7 ? $3 + 1 | 0 : $3;
   $8 = $5;
   $9 = $3;
   $4 = $10;
   if ($4 >>> 0 > 127) {
    continue;
   }
  }
  break;
 }
 $3 = $2;
 HEAP32[$3 >> 2] = $12;
 $4 = $11;
 HEAP32[$3 + 4 >> 2] = $4;
 return $6 - $0 | 0;
}

function robust_open($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 $4 = $1 | 524288;
 $5 = $2 ? $2 : 420;
 label$1: {
  label$2: {
   while (1) {
    $1 = FUNCTION_TABLE[HEAP32[16237]]($0, $4, $5) | 0;
    if (($1 | 0) < 0) {
     if (HEAP32[__errno_location() >> 2] == 27) {
      continue;
     }
     break label$1;
    }
    if ($1 >>> 0 > 2) {
     break label$2;
    }
    FUNCTION_TABLE[HEAP32[16240]]($1) | 0;
    HEAP32[$3 + 4 >> 2] = $1;
    HEAP32[$3 >> 2] = $0;
    sqlite3_log(28, 16461, $3);
    if ((FUNCTION_TABLE[HEAP32[16237]](11098, 0, $2) | 0) >= 0) {
     continue;
    }
    break;
   }
   $1 = -1;
   break label$1;
  }
  if (!$2) {
   break label$1;
  }
  if (FUNCTION_TABLE[HEAP32[16252]]($1, $3 + 16 | 0) | (HEAP32[$3 + 56 >> 2] | HEAP32[$3 + 60 >> 2]) | (HEAP32[$3 + 28 >> 2] & 511) == ($2 | 0)) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[16279]]($1, $2) | 0;
 }
 __stack_pointer = $3 + 128 | 0;
 return $1;
}

function sqlite3VdbeAddOpList($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = HEAP32[$0 + 108 >> 2];
 label$1: {
  if (HEAP32[$0 + 112 >> 2] < ($3 + $1 | 0)) {
   if (growOpArray($0)) {
    break label$1;
   }
   $3 = HEAP32[$0 + 108 >> 2];
  }
  $8 = ($1 | 0) > 0 ? $1 : 0;
  $5 = HEAP32[$0 + 104 >> 2] + Math_imul($3, 20) | 0;
  $3 = $5;
  while (1) {
   if (($6 | 0) != ($8 | 0)) {
    $7 = HEAPU8[$2 | 0];
    HEAP8[$3 | 0] = $7;
    HEAP32[$3 + 4 >> 2] = HEAP8[$2 + 1 | 0];
    $4 = HEAP8[$2 + 2 | 0];
    HEAP32[$3 + 8 >> 2] = $4;
    if (!(!(HEAP8[$7 + 34208 | 0] & 1) | ($4 | 0) <= 0)) {
     HEAP32[$3 + 8 >> 2] = HEAP32[$0 + 108 >> 2] + $4;
    }
    $4 = HEAP8[$2 + 3 | 0];
    HEAP32[$3 + 16 >> 2] = 0;
    HEAP8[$3 + 1 | 0] = 0;
    HEAP32[$3 + 12 >> 2] = $4;
    HEAP16[$3 + 2 >> 1] = 0;
    $3 = $3 + 20 | 0;
    $2 = $2 + 4 | 0;
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 108 >> 2] + $1;
 }
 return $5;
}

function whereAddLimitExpr($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[HEAP32[$0 >> 2] >> 2];
 $7 = HEAP32[$6 >> 2];
 HEAP32[$5 + 12 >> 2] = 0;
 label$1: {
  label$2: {
   label$3: {
    if (!sqlite3ExprIsInteger($2, $5 + 12 | 0)) {
     break label$3;
    }
    $8 = HEAP32[$5 + 12 >> 2];
    if (($8 | 0) < 0) {
     break label$3;
    }
    $2 = sqlite3Expr($7, 155, 0);
    if (!$2) {
     break label$1;
    }
    HEAP32[$2 + 8 >> 2] = $8;
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 2048;
    break label$2;
   }
   $2 = sqlite3Expr($7, 176, 0);
   if (!$2) {
    break label$1;
   }
   HEAP32[$2 + 28 >> 2] = $1;
  }
  $2 = sqlite3PExpr($6, 46, 0, $2);
  if (!$2) {
   break label$1;
  }
  $2 = whereClauseInsert($0, $2, 3);
  $2 = HEAP32[$0 + 24 >> 2] + Math_imul($2, 48) | 0;
  HEAP8[$2 + 15 | 0] = $4;
  HEAP16[$2 + 12 >> 1] = 64;
  HEAP32[$2 + 20 >> 2] = $3;
 }
 __stack_pointer = $5 + 16 | 0;
}

function sqlite3ResolveExprNames($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $5 = HEAP32[$0 + 24 >> 2];
  HEAP32[$0 + 24 >> 2] = $5 & -134254609;
  $3 = HEAP32[$0 >> 2];
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = 55;
  HEAP32[$2 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = $5 & 524288 ? 0 : 56;
  $4 = HEAP32[$3 + 216 >> 2] + HEAP32[$1 + 24 >> 2] | 0;
  HEAP32[$3 + 216 >> 2] = $4;
  $6 = 1;
  if (sqlite3ExprCheckHeight($3, $4)) {
   break label$1;
  }
  sqlite3WalkExpr($2, $1);
  $3 = HEAP32[$2 >> 2];
  HEAP32[$3 + 216 >> 2] = HEAP32[$3 + 216 >> 2] - HEAP32[$1 + 24 >> 2];
  $4 = HEAP32[$0 + 24 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | $4 & 32784;
  HEAP32[$0 + 24 >> 2] = $5 & 134254608 | $4;
  if (HEAP32[$0 + 20 >> 2] > 0) {
   break label$1;
  }
  $6 = HEAP32[$3 + 36 >> 2] > 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return $6;
}

function sqlite3WindowChain($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if (!$3) {
   break label$1;
  }
  $5 = HEAP32[$0 >> 2];
  $2 = windowFind($0, $2, $3);
  if (!$2) {
   break label$1;
  }
  label$2: {
   $3 = 12731;
   label$3: {
    if (HEAP32[$1 + 8 >> 2]) {
     break label$3;
    }
    if (HEAP32[$2 + 12 >> 2]) {
     $3 = 12656;
     if (HEAP32[$1 + 12 >> 2]) {
      break label$3;
     }
    }
    if (HEAPU8[$2 + 19 | 0]) {
     break label$2;
    }
    $3 = 10259;
   }
   HEAP32[$4 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
   HEAP32[$4 >> 2] = $3;
   sqlite3ErrorMsg($0, 7083, $4);
   break label$1;
  }
  HEAP32[$1 + 8 >> 2] = sqlite3ExprListDup($5, HEAP32[$2 + 8 >> 2], 0);
  $0 = HEAP32[$2 + 12 >> 2];
  if ($0) {
   HEAP32[$1 + 12 >> 2] = sqlite3ExprListDup($5, $0, 0);
  }
  sqlite3DbFree($5, HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 + 4 >> 2] = 0;
 }
 __stack_pointer = $4 + 16 | 0;
}

function walkExpr($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  label$2: {
   while (1) {
    $2 = $1;
    $1 = FUNCTION_TABLE[HEAP32[$0 + 4 >> 2]]($0, $1) | 0;
    if ($1) {
     return $1 & 2;
    }
    if (HEAPU8[$2 + 6 | 0] & 129) {
     break label$2;
    }
    label$5: {
     $1 = HEAP32[$2 + 12 >> 2];
     if (!$1) {
      break label$5;
     }
     if (!walkExpr($0, $1)) {
      break label$5;
     }
     return 2;
    }
    $1 = HEAP32[$2 + 16 >> 2];
    if ($1) {
     continue;
    }
    break;
   }
   $3 = HEAP32[$2 + 20 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   if ($1 & 4096) {
    $1 = 2;
    if (!sqlite3WalkSelect($0, $3)) {
     break label$2;
    }
    break label$1;
   }
   if ($3) {
    $1 = 2;
    if (sqlite3WalkExprList($0, $3)) {
     break label$1;
    }
    $1 = HEAP32[$2 + 4 >> 2];
   }
   if (!($1 & 16777216)) {
    break label$2;
   }
   $1 = 2;
   if (walkWindowList($0, HEAP32[$2 + 44 >> 2], 1)) {
    break label$1;
   }
  }
  $1 = 0;
 }
 return $1;
}

function sqlite3ResolveOrderGroupBy($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $4 = HEAP32[$0 >> 2];
  if (HEAPU8[$4 + 87 | 0] | HEAPU8[$0 + 208 | 0] > 1) {
   break label$1;
  }
  $5 = HEAP32[$2 >> 2];
  if (($5 | 0) > HEAP32[$4 + 128 >> 2]) {
   HEAP32[$6 >> 2] = $3;
   sqlite3ErrorMsg($0, 12607, $6);
   $8 = 1;
   break label$1;
  }
  $4 = $2 + 8 | 0;
  $9 = HEAP32[$1 + 28 >> 2];
  $1 = 0;
  while (1) {
   if (($1 | 0) >= ($5 | 0)) {
    break label$1;
   }
   $7 = HEAPU16[$4 + 12 >> 1];
   if ($7) {
    $5 = HEAP32[$9 >> 2];
    if (($7 | 0) > ($5 | 0)) {
     $8 = 1;
     resolveOutOfRangeError($0, $3, $1 + 1 | 0, $5, 0);
     break label$1;
    }
    resolveAlias($0, $9, $7 - 1 | 0, HEAP32[$4 >> 2], 0);
    $5 = HEAP32[$2 >> 2];
   }
   $4 = $4 + 16 | 0;
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $6 + 16 | 0;
 return $8;
}

function windowInitAccum($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $3 = sqlite3GetVdbe($0);
 $2 = $1;
 while (1) {
  if ($2) {
   $4 = HEAP32[$2 + 44 >> 2];
   sqlite3VdbeAddOp2($3, 75, 0, HEAP32[$2 + 52 >> 2]);
   $6 = windowArgCount($2);
   $8 = ($6 | 0) < ($5 | 0);
   label$3: {
    if (HEAP32[$1 + 88 >> 2]) {
     break label$3;
    }
    $7 = HEAP32[$4 + 32 >> 2];
    if (!(($7 | 0) != 48960 & ($7 | 0) != 48970)) {
     sqlite3VdbeAddOp2($3, 71, 0, HEAP32[$2 + 64 >> 2]);
     sqlite3VdbeAddOp2($3, 71, 0, HEAP32[$2 + 64 >> 2] + 1 | 0);
    }
    if (!(HEAPU8[$4 + 5 | 0] & 16)) {
     break label$3;
    }
    $4 = HEAP32[$2 + 60 >> 2];
    if (!$4) {
     break label$3;
    }
    sqlite3VdbeAddOp1($3, 146, $4);
    sqlite3VdbeAddOp2($3, 71, 0, HEAP32[$2 + 64 >> 2] + 1 | 0);
   }
   $5 = $8 ? $5 : $6;
   $2 = HEAP32[$2 + 36 >> 2];
   continue;
  }
  break;
 }
 $2 = HEAP32[$0 + 44 >> 2];
 HEAP32[$0 + 44 >> 2] = $5 + $2;
 return $2 + 1 | 0;
}

function sumInverse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $0 = sqlite3_aggregate_context($0, 32);
 $4 = sqlite3_value_numeric_type(HEAP32[$2 >> 2]);
 if (!(!$0 | ($4 | 0) == 5)) {
  $5 = HEAP32[$0 + 16 >> 2];
  $1 = $5;
  $6 = HEAP32[$0 + 20 >> 2];
  $3 = !$1;
  $3 = $6 - $3 | 0;
  $1 = $1 - 1 | 0;
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $3;
  if (!(HEAPU8[$0 + 25 | 0] | ($4 | 0) != 1)) {
   $3 = sqlite3_value_int64(HEAP32[$2 >> 2]);
   $4 = $3;
   $1 = i64toi32_i32$HIGH_BITS;
   $2 = $1;
   HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] - (+($3 >>> 0) + +($1 | 0) * 4294967296);
   $1 = HEAP32[$0 + 8 >> 2];
   $6 = $1;
   $5 = $1 - $3 | 0;
   $3 = HEAP32[$0 + 12 >> 2];
   $1 = $2;
   $1 = $1 + ($6 >>> 0 < $4 >>> 0) | 0;
   $1 = $3 - $1 | 0;
   HEAP32[$0 + 8 >> 2] = $5;
   HEAP32[$0 + 12 >> 2] = $1;
   return;
  }
  $7 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] - $7;
 }
}

function pageFreeArray($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $2 = $1 + $2 | 0;
 $11 = ($1 | 0) > ($2 | 0) ? $1 : $2;
 $5 = HEAP32[$0 + 56 >> 2];
 $8 = $5 + HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] | 0;
 $12 = ((HEAPU8[$0 + 9 | 0] + HEAPU8[$0 + 10 | 0] | 0) + $5 | 0) + 8 | 0;
 while (1) {
  if (($1 | 0) != ($11 | 0)) {
   $2 = HEAP32[HEAP32[$3 + 8 >> 2] + ($1 << 2) >> 2];
   if (!($12 >>> 0 > $2 >>> 0 | $2 >>> 0 >= $8 >>> 0)) {
    $6 = HEAPU16[HEAP32[$3 + 12 >> 2] + ($1 << 1) >> 1];
    $9 = $6 + $2 | 0;
    label$4: {
     if (($9 | 0) != ($4 | 0)) {
      if ($4) {
       freeSpace($0, $4 - $5 & 65535, $7 & 65535);
      }
      if ($8 >>> 0 >= $9 >>> 0) {
       break label$4;
      }
      return 0;
     }
     $6 = $6 + $7 | 0;
    }
    $10 = $10 + 1 | 0;
    $7 = $6;
    $4 = $2;
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 if ($4) {
  freeSpace($0, $4 - $5 & 65535, $7 & 65535);
 }
 return $10;
}

function findReusableFd($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!HEAP32[17715]) {
   break label$1;
  }
  label$2: {
   if (FUNCTION_TABLE[HEAP32[16249]]($0, $3) | 0) {
    break label$2;
   }
   $2 = 70860;
   $4 = HEAP32[$3 + 104 >> 2];
   $5 = HEAP32[$3 + 108 >> 2];
   $0 = HEAP32[$3 >> 2];
   while (1) {
    $2 = HEAP32[$2 >> 2];
    if (!$2) {
     break label$2;
    }
    if (!(($4 | 0) == HEAP32[$2 + 8 >> 2] & ($5 | 0) == HEAP32[$2 + 12 >> 2] & HEAP32[$2 >> 2] == ($0 | 0))) {
     $2 = $2 + 44 | 0;
     continue;
    }
    break;
   }
   $0 = $2 + 32 | 0;
   $4 = $1 & 3;
   while (1) {
    $1 = $0;
    $2 = HEAP32[$0 >> 2];
    if (!$2) {
     break label$2;
    }
    $0 = $2 + 8 | 0;
    if (HEAP32[$2 + 4 >> 2] != ($4 | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
   break label$1;
  }
  $2 = 0;
 }
 __stack_pointer = $3 + 112 | 0;
 return $2;
}

function sqlite3SrcListShiftJoinType($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = HEAP32[$0 >> 2];
  if (($2 | 0) < 2) {
   break label$1;
  }
  $5 = $0 + 8 | 0;
  $1 = $2;
  while (1) {
   $6 = $1 - 1 | 0;
   $4 = HEAPU8[(($1 << 6) + $5 | 0) - 92 | 0];
   HEAP8[(($6 << 6) + $5 | 0) + 36 | 0] = $4;
   $3 = $3 & 255 | $4;
   $4 = $1 >>> 0 > 2;
   $1 = $6;
   if ($4) {
    continue;
   }
   break;
  }
  HEAP8[$0 + 44 | 0] = 0;
  if (!($3 & 16)) {
   break label$1;
  }
  while (1) {
   label$4: {
    $1 = $2;
    if (($1 | 0) < 2) {
     $1 = 1;
     break label$4;
    }
    $2 = $1 - 1 | 0;
    if (!(HEAPU8[(($2 << 6) + $0 | 0) + 44 | 0] & 16)) {
     continue;
    }
   }
   break;
  }
  $1 = $1 - 2 | 0;
  while (1) {
   $2 = ($1 << 6) + $0 | 0;
   $3 = $2 + 44 | 0;
   HEAP8[$3 | 0] = HEAPU8[$2 + 44 | 0] | 64;
   $3 = ($1 | 0) > 0;
   $1 = $1 - 1 | 0;
   if ($3) {
    continue;
   }
   break;
  }
 }
}

function computeNumericType($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  label$2: {
   if (HEAPU8[$0 + 17 | 0] & 4) {
    $1 = 0;
    if (sqlite3VdbeMemExpandBlob($0)) {
     break label$2;
    }
   }
   $1 = sqlite3AtoF(HEAP32[$0 + 8 >> 2], $0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]);
   label$4: {
    if (($1 | 0) <= 0) {
     $3 = 8;
     if ($1) {
      break label$1;
     }
     if ((sqlite3Atoi64(HEAP32[$0 + 8 >> 2], $2 + 8 | 0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]) | 0) <= 1) {
      break label$4;
     }
     break label$1;
    }
    $3 = 8;
    if (($1 | 0) != 1) {
     break label$1;
    }
    if (sqlite3Atoi64(HEAP32[$0 + 8 >> 2], $2 + 8 | 0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0])) {
     break label$1;
    }
   }
   $3 = HEAP32[$2 + 12 >> 2];
   $1 = HEAP32[$2 + 8 >> 2];
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $3;
  $3 = 4;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function resolveOrderByTermToExprList($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $4 = HEAP32[$1 + 28 >> 2];
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$3 >> 2] = $0;
 $1 = HEAP32[$1 + 32 >> 2];
 HEAP32[$3 + 24 >> 2] = 524417;
 HEAP32[$3 + 8 >> 2] = $4;
 HEAP32[$3 + 4 >> 2] = $1;
 $1 = HEAP32[$0 >> 2];
 $0 = HEAPU8[$1 + 91 | 0];
 HEAP8[$1 + 91 | 0] = 1;
 $6 = sqlite3ResolveExprNames($3, $2);
 HEAP8[$1 + 91 | 0] = $0;
 label$1: {
  label$2: {
   if ($6) {
    break label$2;
   }
   while (1) {
    if (HEAP32[$4 >> 2] <= ($5 | 0)) {
     break label$2;
    }
    $1 = $5 << 4;
    $0 = $5 + 1 | 0;
    $5 = $0;
    if ((sqlite3ExprCompare(0, HEAP32[($1 + $4 | 0) + 8 >> 2], $2, -1) | 0) > 1) {
     continue;
    }
    break;
   }
   break label$1;
  }
  $0 = 0;
 }
 __stack_pointer = $3 + 32 | 0;
 return $0;
}

function vdbeMergeEngineCompare($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $2 = HEAP32[$0 >> 2] / 2 | 0;
 label$1: {
  if (($2 | 0) <= ($1 | 0)) {
   $4 = $1 - $2 << 1;
   $2 = $4 | 1;
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2] + ($1 << 3) | 0;
  $4 = HEAP32[$2 >> 2];
  $2 = HEAP32[$2 + 4 >> 2];
 }
 $3 = HEAP32[$0 + 12 >> 2];
 label$3: {
  if (!HEAP32[($3 + Math_imul($4, 56) | 0) + 24 >> 2]) {
   break label$3;
  }
  if (!HEAP32[(Math_imul($2, 56) + $3 | 0) + 24 >> 2]) {
   $2 = $4;
   break label$3;
  }
  $6 = HEAP32[$0 + 4 >> 2];
  HEAP32[$5 + 12 >> 2] = 0;
  $7 = Math_imul($4, 56) + $3 | 0;
  $3 = Math_imul($2, 56) + $3 | 0;
  $2 = (FUNCTION_TABLE[HEAP32[$6 + 32 >> 2]]($6, $5 + 12 | 0, HEAP32[$7 + 32 >> 2], HEAP32[$7 + 20 >> 2], HEAP32[$3 + 32 >> 2], HEAP32[$3 + 20 >> 2]) | 0) <= 0 ? $4 : $2;
 }
 HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2] = $2;
 __stack_pointer = $5 + 16 | 0;
}

function timeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 if (!isDate($0, $1, $2, $3 + 16 | 0)) {
  computeHMS($3 + 16 | 0);
  HEAP8[$3 + 2 | 0] = 58;
  HEAP8[$3 + 5 | 0] = 58;
  HEAP8[$3 + 8 | 0] = 0;
  $2 = HEAP32[$3 + 36 >> 2];
  $1 = ($2 | 0) / 10 | 0;
  HEAP8[$3 | 0] = (($1 | 0) % 10 | 0) + 48;
  $4 = HEAP32[$3 + 40 >> 2];
  $5 = ($4 | 0) / 10 | 0;
  HEAP8[$3 + 3 | 0] = (($5 | 0) % 10 | 0) + 48;
  HEAP8[$3 + 1 | 0] = ($2 - Math_imul($1, 10) | 0) + 48;
  HEAP8[$3 + 4 | 0] = ($4 - Math_imul($5, 10) | 0) + 48;
  $6 = HEAPF64[$3 + 48 >> 3];
  label$2: {
   if (Math_abs($6) < 2147483648) {
    $2 = ~~$6;
    break label$2;
   }
   $2 = -2147483648;
  }
  $1 = ($2 | 0) / 10 | 0;
  HEAP8[$3 + 6 | 0] = (($1 | 0) % 10 | 0) + 48;
  HEAP8[$3 + 7 | 0] = ($2 - Math_imul($1, 10) | 0) + 48;
  sqlite3_result_text($0, $3, 8, -1);
 }
 __stack_pointer = $3 - -64 | 0;
}

function properFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if (($1 | 0) == 1) {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
    sqlite3_result_null($0);
    return;
   }
   $1 = sqlite3_value_text(HEAP32[$2 >> 2]);
   $3 = sqlite3StrDup($1);
   if (!$3) {
    break label$1;
   }
   $6 = 1;
   $4 = $3;
   while (1) {
    $2 = HEAPU8[$1 | 0];
    if ($2) {
     $7 = 1;
     $1 = $1 + 1 | 0;
     $5 = $2 << 24 >> 24;
     if (!isblank($5)) {
      $7 = 0;
      label$7: {
       if (($6 | 0) == 1) {
        $2 = toupper($5);
        break label$7;
       }
       $2 = tolower($5);
      }
     }
     HEAP8[$4 | 0] = $2;
     $4 = $4 + 1 | 0;
     $6 = $7;
     continue;
    }
    break;
   }
   HEAP8[$4 | 0] = 0;
   sqlite3_result_text($0, $3, -1, -1);
   sqlite3_free($3);
   return;
  }
  __assert_fail(23175, 17353, 724, 17089);
  abort();
 }
 sqlite3_result_error_nomem($0);
}

function fts3SpecialInsert($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = sqlite3_value_text($1);
 $1 = sqlite3_value_bytes($1);
 if (!$2) {
  return 7;
 }
 label$2: {
  label$3: {
   label$4: {
    switch ($1 - 7 | 0) {
    case 1:
     if (sqlite3_strnicmp($2, 12206, 8)) {
      break label$3;
     }
     return fts3DoOptimize($0, 0);

    case 0:
     if (sqlite3_strnicmp($2, 14330, 7)) {
      break label$3;
     }
     return fts3DoRebuild($0);

    default:
     break label$4;
    }
   }
   if (($1 | 0) != 15) {
    $3 = 1;
    if (($1 | 0) < 7) {
     break label$2;
    }
    break label$3;
   }
   if (sqlite3_strnicmp($2, 11498, 15)) {
    break label$3;
   }
   return fts3DoIntegrityCheck($0);
  }
  if (!sqlite3_strnicmp($2, 21256, 6)) {
   return fts3DoIncrmerge($0, $2 + 6 | 0);
  }
  $3 = 1;
  if ($1 >>> 0 < 11) {
   break label$2;
  }
  if (sqlite3_strnicmp($2, 21252, 10)) {
   break label$2;
  }
  $3 = fts3DoAutoincrmerge($0, $2 + 10 | 0);
 }
 return $3;
}

function walIndexAppend($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = walHashGet($0, walFramePage($1), $3);
 label$1: {
  if ($4) {
   break label$1;
  }
  $5 = $1 - HEAP32[$3 + 8 >> 2] | 0;
  label$2: {
   if (($5 | 0) != 1) {
    $1 = HEAP32[$3 + 4 >> 2];
    break label$2;
   }
   $1 = HEAP32[$3 + 4 >> 2];
   memset($1, 0, (HEAP32[$3 >> 2] - $1 | 0) + 16384 | 0);
  }
  $6 = (($5 << 2) + $1 | 0) - 4 | 0;
  if (HEAP32[$6 >> 2]) {
   walCleanupHash($0);
  }
  $1 = walHash($2);
  $0 = HEAP32[$3 >> 2];
  $4 = $5;
  label$5: {
   while (1) {
    $7 = ($1 << 1) + $0 | 0;
    if (HEAPU16[$7 >> 1]) {
     if (!$4) {
      break label$5;
     }
     $4 = $4 - 1 | 0;
     $1 = walNextHash($1);
     continue;
    }
    break;
   }
   HEAP32[$6 >> 2] = $2;
   HEAP16[$7 >> 1] = $5;
   $4 = 0;
   break label$1;
  }
  $4 = sqlite3CorruptError(62821);
 }
 __stack_pointer = $3 + 16 | 0;
 return $4;
}

function fts3IncrmergeHintLoad($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = 0;
 $0 = fts3SqlStmt($0, 22, $2 + 12 | 0, 0);
 HEAP32[$2 + 8 >> 2] = $0;
 if (!$0) {
  $0 = HEAP32[$2 + 12 >> 2];
  sqlite3_bind_int($0, 1, 1);
  label$2: {
   if ((sqlite3_step($0) | 0) != 100) {
    break label$2;
   }
   $5 = sqlite3_column_blob($0, 0);
   $4 = sqlite3_column_bytes($0, 0);
   if (!$5) {
    break label$2;
   }
   blobGrowBuffer($1, $4, $2 + 8 | 0);
   $3 = HEAP32[$2 + 8 >> 2];
   if ($3) {
    break label$2;
   }
   $3 = HEAP32[$1 >> 2];
   if ($3) {
    __memcpy($3, $5, $4);
   }
   HEAP32[$1 + 4 >> 2] = $4;
   $3 = 0;
  }
  $0 = (wasm2js_i32$0 = $3, wasm2js_i32$1 = sqlite3_reset($0), wasm2js_i32$2 = $3, 
  wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function pager_write($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 20 >> 2];
 label$1: {
  if (HEAPU8[$2 + 17 | 0] == 2) {
   $1 = pager_open_journal($2);
   if ($1) {
    break label$1;
   }
  }
  sqlite3PcacheMakeDirty($0);
  $1 = HEAP32[$2 + 60 >> 2];
  label$3: {
   if (!$1) {
    break label$3;
   }
   $3 = HEAP32[$0 + 24 >> 2];
   if (sqlite3BitvecTestNotNull($1, $3)) {
    break label$3;
   }
   if (HEAPU32[$2 + 32 >> 2] >= $3 >>> 0) {
    $1 = pagerAddPageToRollbackJournal($0);
    if (!$1) {
     break label$3;
    }
    break label$1;
   }
   if (HEAPU8[$2 + 17 | 0] == 4) {
    break label$3;
   }
   HEAP16[$0 + 28 >> 1] = HEAPU16[$0 + 28 >> 1] | 8;
  }
  HEAP16[$0 + 28 >> 1] = HEAPU16[$0 + 28 >> 1] | 4;
  if (HEAP32[$2 + 104 >> 2] <= 0) {
   $1 = 0;
  } else {
   $1 = subjournalPageIfRequired($0);
  }
  $0 = HEAP32[$0 + 24 >> 2];
  if ($0 >>> 0 <= HEAPU32[$2 + 28 >> 2]) {
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = $0;
 }
 return $1;
}

function decodeFlags($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = $1 >>> 3 | 0;
 HEAP8[$0 + 8 | 0] = $3;
 HEAP8[$0 + 10 | 0] = 4 - ($3 << 2);
 $2 = HEAP32[$0 + 52 >> 2];
 label$1: {
  label$2: {
   switch (($1 & -9) - 2 | 0) {
   case 0:
    HEAP32[$0 + 80 >> 2] = 19;
    HEAP32[$0 + 76 >> 2] = 20;
    HEAP8[$0 + 1 | 0] = 0;
    HEAP8[$0 + 2 | 0] = 0;
    HEAP16[$0 + 14 >> 1] = HEAPU16[$2 + 26 >> 1];
    $1 = $2 + 28 | 0;
    break label$1;

   default:
    HEAP32[$0 + 80 >> 2] = 19;
    HEAP32[$0 + 76 >> 2] = 20;
    HEAP8[$0 + 1 | 0] = 0;
    HEAP8[$0 + 2 | 0] = 0;
    return sqlite3CorruptError(68811);

   case 3:
    break label$2;
   }
  }
  HEAP8[$0 + 1 | 0] = 1;
  $1 = $3 & 255;
  HEAP32[$0 + 80 >> 2] = $1 ? 21 : 22;
  HEAP32[$0 + 76 >> 2] = $1 ? 23 : 24;
  HEAP8[$0 + 2 | 0] = ($1 | 0) != 0;
  HEAP16[$0 + 14 >> 1] = HEAPU16[$2 + 30 >> 1];
  $1 = $2 + 32 | 0;
 }
 HEAP16[$0 + 16 >> 1] = HEAPU16[$1 >> 1];
 HEAP8[$0 + 11 | 0] = HEAPU8[$2 + 21 | 0];
 return 0;
}

function sumStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 label$1: {
  $0 = sqlite3_aggregate_context($0, 32);
  $4 = sqlite3_value_numeric_type(HEAP32[$2 >> 2]);
  if (!$0 | ($4 | 0) == 5) {
   break label$1;
  }
  $3 = HEAP32[$0 + 20 >> 2];
  $1 = HEAP32[$0 + 16 >> 2];
  $1 = $1 + 1 | 0;
  $3 = $1 ? $3 : $3 + 1 | 0;
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $3;
  $2 = HEAP32[$2 >> 2];
  label$2: {
   if (($4 | 0) == 1) {
    $3 = sqlite3_value_int64($2);
    $1 = i64toi32_i32$HIGH_BITS;
    HEAPF64[$0 >> 3] = HEAPF64[$0 >> 3] + (+($3 >>> 0) + +($1 | 0) * 4294967296);
    if (HEAPU8[$0 + 24 | 0] | HEAPU8[$0 + 25 | 0]) {
     break label$1;
    }
    if (!sqlite3AddInt64($0 + 8 | 0, $3, $1)) {
     break label$1;
    }
    HEAP8[$0 + 24 | 0] = 1;
    $2 = $0 + 25 | 0;
    break label$2;
   }
   HEAPF64[$0 >> 3] = sqlite3_value_double($2) + HEAPF64[$0 >> 3];
   $2 = $0 + 25 | 0;
  }
  HEAP8[$2 | 0] = 1;
 }
}

function sqlite3VdbeFrameRestore($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = HEAP32[$0 >> 2];
 closeCursorsInFrame($1);
 HEAP32[$1 + 104 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 108 >> 2] = HEAP32[$0 + 52 >> 2];
 HEAP32[$1 + 88 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 20 >> 2] = HEAP32[$0 + 56 >> 2];
 HEAP32[$1 + 96 >> 2] = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 44 >> 2];
 $3 = HEAP32[$0 + 36 >> 2];
 $2 = HEAP32[$0 + 32 >> 2];
 $4 = $2;
 $5 = HEAP32[$1 >> 2];
 $2 = $5;
 HEAP32[$2 + 40 >> 2] = $4;
 HEAP32[$2 + 44 >> 2] = $3;
 $2 = HEAP32[$0 + 76 >> 2];
 $3 = HEAP32[$0 + 72 >> 2];
 HEAP32[$1 + 40 >> 2] = $3;
 HEAP32[$1 + 44 >> 2] = $2;
 $3 = HEAP32[$0 + 84 >> 2];
 $2 = HEAP32[$0 + 80 >> 2];
 $4 = $2;
 $2 = $5;
 HEAP32[$2 + 104 >> 2] = $4;
 HEAP32[$2 + 108 >> 2] = $3;
 sqlite3VdbeDeleteAuxData($2, $1 + 232 | 0, -1, 0);
 HEAP32[$1 + 232 >> 2] = HEAP32[$0 + 40 >> 2];
 HEAP32[$0 + 40 >> 2] = 0;
 return HEAP32[$0 + 48 >> 2];
}

function sqlite3VtabCallCreate($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  label$2: {
   $5 = sqlite3FindTable($0, $2, HEAP32[HEAP32[$0 + 16 >> 2] + ($1 << 4) >> 2]);
   $2 = HEAP32[HEAP32[$5 + 48 >> 2] >> 2];
   $1 = sqlite3HashFind($0 + 384 | 0, $2);
   label$3: {
    if (!$1) {
     break label$3;
    }
    $6 = HEAP32[$1 >> 2];
    $7 = HEAP32[$6 + 4 >> 2];
    if (!$7) {
     break label$3;
    }
    if (HEAP32[$6 + 20 >> 2]) {
     break label$2;
    }
   }
   HEAP32[$4 >> 2] = $2;
   HEAP32[$3 >> 2] = sqlite3MPrintf($0, 7816, $4);
   $1 = 1;
   break label$1;
  }
  $1 = vtabCallConstructor($0, $5, $1, $7, $3);
  if ($1) {
   break label$1;
  }
  $1 = 0;
  if (!sqlite3GetVTable($0, $5)) {
   break label$1;
  }
  $1 = growVTrans($0);
  if ($1) {
   break label$1;
  }
  addToVTrans($0, sqlite3GetVTable($0, $5));
  $1 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $1;
}

function sqlite3ResultSetOfSelect($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP32[$0 >> 2];
 $5 = HEAP32[$4 + 32 >> 2];
 $6 = $5;
 $3 = HEAP32[$4 + 36 >> 2];
 $5 = $3;
 $3 = $6;
 $3 = $3 & -69;
 $3 = $3 | 64;
 HEAP32[$4 + 32 >> 2] = $3;
 $3 = $5;
 HEAP32[$4 + 36 >> 2] = $3;
 sqlite3SelectPrep($0, $1, 0);
 HEAP32[$4 + 32 >> 2] = $6;
 HEAP32[$4 + 36 >> 2] = $3;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  while (1) {
   $3 = $1;
   $1 = HEAP32[$1 + 52 >> 2];
   if ($1) {
    continue;
   }
   break;
  }
  $1 = sqlite3DbMallocZero($4, 64, 0);
  if (!$1) {
   break label$1;
  }
  HEAP16[$1 + 38 >> 1] = 200;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 24 >> 2] = 1;
  sqlite3ColumnsFromExprList($0, HEAP32[$3 + 28 >> 2], $1 + 34 | 0, $1 + 4 | 0);
  sqlite3SelectAddColumnTypeAndCollation($0, $1, $3, $2);
  HEAP16[$1 + 32 >> 1] = 65535;
  if (!HEAPU8[$4 + 87 | 0]) {
   return $1;
  }
  sqlite3DeleteTable($4, $1);
 }
 return 0;
}

function multiSelectOrderByKeyInfo($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  $8 = HEAP32[$0 >> 2];
  $6 = HEAP32[$1 + 48 >> 2];
  if ($6) {
   $2 = HEAP32[$6 >> 2];
  } else {
   $2 = 0;
  }
  $4 = sqlite3KeyInfoAlloc($8, $2 + 1 | 0, 1);
  if (!$4) {
   break label$1;
  }
  $9 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   if (($3 | 0) == ($9 | 0)) {
    break label$1;
   }
   $5 = ($3 << 4) + $6 | 0;
   $7 = HEAP32[$5 + 8 >> 2];
   label$5: {
    if (HEAPU8[$7 + 5 | 0] & 2) {
     $2 = sqlite3ExprCollSeq($0, $7);
     break label$5;
    }
    $2 = multiSelectCollSeq($0, $1, HEAPU16[$5 + 20 >> 1] - 1 | 0);
    if (!$2) {
     $2 = HEAP32[$8 + 8 >> 2];
    }
    HEAP32[$5 + 8 >> 2] = sqlite3ExprAddCollateString($0, $7, HEAP32[$2 >> 2]);
   }
   HEAP32[(($3 << 2) + $4 | 0) + 20 >> 2] = $2;
   HEAP8[HEAP32[$4 + 16 >> 2] + $3 | 0] = HEAPU8[$5 + 16 | 0];
   $3 = $3 + 1 | 0;
   continue;
  }
 }
 return $4;
}

function __strchrnul($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $3 = $1 & 255;
  if ($3) {
   if ($0 & 3) {
    while (1) {
     $2 = HEAPU8[$0 | 0];
     if (!$2 | ($1 & 255) == ($2 | 0)) {
      break label$1;
     }
     $0 = $0 + 1 | 0;
     if ($0 & 3) {
      continue;
     }
     break;
    }
   }
   $2 = HEAP32[$0 >> 2];
   label$5: {
    if (($2 ^ -1) & $2 - 16843009 & -2139062144) {
     break label$5;
    }
    $3 = Math_imul($3, 16843009);
    while (1) {
     $2 = $2 ^ $3;
     if (($2 ^ -1) & $2 - 16843009 & -2139062144) {
      break label$5;
     }
     $2 = HEAP32[$0 + 4 >> 2];
     $0 = $0 + 4 | 0;
     if (!($2 - 16843009 & ($2 ^ -1) & -2139062144)) {
      continue;
     }
     break;
    }
   }
   while (1) {
    $2 = $0;
    $3 = HEAPU8[$2 | 0];
    if ($3) {
     $0 = $2 + 1 | 0;
     if (($1 & 255) != ($3 | 0)) {
      continue;
     }
    }
    break;
   }
   return $2;
  }
  return strlen($0) + $0 | 0;
 }
 return $0;
}

function vdbeUnbind($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (vdbeSafetyNotNull($0)) {
   $2 = sqlite3MisuseError(87434);
   break label$1;
  }
  if (HEAPU8[$0 + 149 | 0] != 1) {
   sqlite3Error(HEAP32[$0 >> 2], 21);
   HEAP32[$3 >> 2] = HEAP32[$0 + 196 >> 2];
   sqlite3_log(21, 17808, $3);
   $2 = sqlite3MisuseError(87442);
   break label$1;
  }
  if (!(($1 | 0) > 0 & HEAP16[$0 + 16 >> 1] >= ($1 | 0))) {
   $2 = 25;
   sqlite3Error(HEAP32[$0 >> 2], 25);
   break label$1;
  }
  $4 = $1 - 1 | 0;
  $2 = HEAP32[$0 + 100 >> 2] + Math_imul($4, 40) | 0;
  sqlite3VdbeMemRelease($2);
  HEAP16[$2 + 16 >> 1] = 1;
  $2 = 0;
  HEAP32[HEAP32[$0 >> 2] + 64 >> 2] = 0;
  $5 = HEAP32[$0 + 224 >> 2];
  if (!$5 | !(($1 >>> 0 > 31 ? -2147483648 : 1 << $4) & $5)) {
   break label$1;
  }
  HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 252 | 1;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3_step($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 if (vdbeSafetyNotNull($0)) {
  return sqlite3MisuseError(86788) | 0;
 }
 $2 = HEAP32[$0 >> 2];
 label$2: {
  while (1) {
   $3 = sqlite3Step($0);
   if (($3 | 0) != 17) {
    break label$2;
   }
   if (($1 | 0) == 50) {
    return 17;
   }
   $3 = HEAP32[$0 + 32 >> 2];
   label$5: {
    $4 = sqlite3Reprepare($0);
    if ($4) {
     $1 = sqlite3_value_text(HEAP32[$2 + 288 >> 2]);
     sqlite3DbFree($2, HEAP32[$0 + 124 >> 2]);
     if (HEAPU8[$2 + 87 | 0]) {
      break label$5;
     }
     HEAP32[$0 + 124 >> 2] = sqlite3DbStrDup($2, $1);
     $1 = sqlite3ApiExit($2, $4);
     HEAP32[$0 + 36 >> 2] = $1;
     return $1 | 0;
    }
    $1 = $1 + 1 | 0;
    sqlite3_reset($0);
    if (($3 | 0) < 0) {
     continue;
    }
    HEAP8[$0 + 147 | 0] = 254;
    continue;
   }
   break;
  }
  $3 = 7;
  HEAP32[$0 + 36 >> 2] = 7;
  HEAP32[$0 + 124 >> 2] = 0;
 }
 return $3 | 0;
}

function jsonParse($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 $3 = 1;
 label$1: {
  if (!$2) {
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = $2;
  $3 = jsonParseValue($0, 0);
  $4 = HEAPU8[$0 + 20 | 0];
  label$2: {
   if ($4 | ($3 | 0) <= 0) {
    break label$2;
   }
   while (1) {
    $5 = $3;
    $3 = $3 + 1 | 0;
    $6 = HEAPU8[$2 + $5 | 0];
    if (HEAPU8[$6 + 50864 | 0]) {
     continue;
    }
    break;
   }
   if ($6) {
    break label$2;
   }
   $3 = 0;
   if (($5 | 0) > 0) {
    break label$1;
   }
  }
  label$4: {
   if (!$1) {
    break label$4;
   }
   if ($4) {
    sqlite3_result_error_nomem($1);
    break label$4;
   }
   sqlite3_result_error($1, 19385, -1);
  }
  jsonParseReset($0);
  $3 = 1;
 }
 return $3;
}

function sqlite3BtreeTripAllCursors($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  label$2: while (1) {
   if (!$0) {
    break label$1;
   }
   sqlite3BtreeEnter($0);
   $3 = HEAP32[$0 + 4 >> 2] + 8 | 0;
   while (1) {
    $3 = HEAP32[$3 >> 2];
    if ($3) {
     label$5: {
      if (!(!$2 | HEAP8[$3 + 1 | 0] & 1)) {
       label$7: {
        switch (HEAPU8[$3 | 0]) {
        case 0:
        case 2:
         break label$7;

        default:
         break label$5;
        }
       }
       $4 = saveCursorPosition($3);
       if (!$4) {
        break label$5;
       }
       $5 = $6 ? $5 : $4;
       $2 = 0;
       $1 = $4;
       $6 = 1;
       continue label$2;
      }
      sqlite3BtreeClearCursor($3);
      HEAP32[$3 + 4 >> 2] = $1;
      HEAP8[$3 | 0] = 4;
     }
     btreeReleaseAllCursorPages($3);
     $3 = $3 + 24 | 0;
     continue;
    }
    break;
   }
   break;
  }
  $7 = $6 ? $5 : 0;
 }
 return $7;
}

function sqlite3WalkSelectExpr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = 2;
 label$1: {
  if (sqlite3WalkExprList($0, HEAP32[$1 + 28 >> 2])) {
   break label$1;
  }
  if (sqlite3WalkExpr($0, HEAP32[$1 + 36 >> 2])) {
   break label$1;
  }
  if (sqlite3WalkExprList($0, HEAP32[$1 + 40 >> 2])) {
   break label$1;
  }
  if (sqlite3WalkExpr($0, HEAP32[$1 + 44 >> 2])) {
   break label$1;
  }
  if (sqlite3WalkExprList($0, HEAP32[$1 + 48 >> 2])) {
   break label$1;
  }
  if (sqlite3WalkExpr($0, HEAP32[$1 + 60 >> 2])) {
   break label$1;
  }
  $2 = 0;
  $1 = HEAP32[$1 + 72 >> 2];
  if (!$1) {
   break label$1;
  }
  $3 = HEAP32[$0 + 12 >> 2];
  label$2: {
   if (($3 | 0) == 39) {
    break label$2;
   }
   $4 = HEAP32[$0 >> 2];
   if ($4) {
    if (($3 | 0) == 63 | HEAPU8[$4 + 208 | 0] > 1) {
     break label$2;
    }
    break label$1;
   }
   if (($3 | 0) != 63) {
    break label$1;
   }
  }
  $2 = walkWindowList($0, $1, 0);
 }
 return $2;
}

function fts3WriteSegdir($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) {
 var $14 = 0, $15 = 0;
 $14 = __stack_pointer - 32 | 0;
 __stack_pointer = $14;
 $15 = fts3SqlStmt($0, 11, $14 + 28 | 0, 0);
 label$1: {
  if ($15) {
   break label$1;
  }
  $0 = HEAP32[$14 + 28 >> 2];
  sqlite3_bind_int64($0, 1, $1, $2);
  sqlite3_bind_int($0, 2, $3);
  sqlite3_bind_int64($0, 3, $4, $5);
  sqlite3_bind_int64($0, 4, $6, $7);
  label$2: {
   if (!($10 | $11)) {
    sqlite3_bind_int64($0, 5, $8, $9);
    break label$2;
   }
   HEAP32[$14 + 8 >> 2] = $10;
   HEAP32[$14 + 12 >> 2] = $11;
   HEAP32[$14 >> 2] = $8;
   HEAP32[$14 + 4 >> 2] = $9;
   $15 = sqlite3_mprintf(14300, $14);
   if (!$15) {
    $15 = 7;
    break label$1;
   }
   sqlite3_bind_text($0, 5, $15, -1, 3);
  }
  sqlite3_bind_blob($0, 6, $12, $13, 0);
  sqlite3_step($0);
  $15 = sqlite3_reset($0);
  sqlite3_bind_null($0, 6);
 }
 __stack_pointer = $14 + 32 | 0;
 return $15;
}

function _medianFinalize($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 0);
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 56 >> 2];
  if (!$2) {
   break label$1;
  }
  HEAP32[$1 + 60 >> 2] = 0;
  map_iterate($2, 429, $1);
  map_destroy(HEAP32[$1 + 56 >> 2]);
  dlfree(HEAP32[$1 + 56 >> 2]);
  $2 = HEAP32[$1 + 52 >> 2];
  if (!($2 | HEAP32[$1 + 48 >> 2])) {
   $2 = HEAP32[$1 >> 2];
   $3 = $2;
   $4 = HEAP32[$1 + 4 >> 2];
   $2 = HEAP32[$1 + 44 >> 2];
   $5 = $2;
   $1 = HEAP32[$1 + 40 >> 2];
   if (!$2 & ($1 | 0) == 1) {
    sqlite3_result_int64($0, $3, $4);
    return;
   }
   $2 = $3;
   $6 = +($2 >>> 0) + +($4 | 0) * 4294967296;
   $2 = $1;
   sqlite3_result_double($0, $6 / (+($2 >>> 0) + +($5 | 0) * 4294967296));
   return;
  }
  $2 = HEAP32[$1 + 44 >> 2];
  sqlite3_result_double($0, HEAPF64[$1 + 8 >> 3] / (+HEAPU32[$1 + 40 >> 2] + +($2 | 0) * 4294967296));
 }
}

function lockTable($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = HEAP32[$0 + 116 >> 2];
 $6 = $6 ? $6 : $0;
 $7 = HEAP32[$6 + 104 >> 2];
 $9 = ($7 | 0) > 0 ? $7 : 0;
 while (1) {
  if (($5 | 0) != ($9 | 0)) {
   $8 = HEAP32[$6 + 108 >> 2];
   $0 = $8 + ($5 << 4) | 0;
   if (!(HEAP32[$0 >> 2] != ($1 | 0) | HEAP32[$0 + 4 >> 2] != ($2 | 0))) {
    $5 = ($5 << 4) + $8 | 0;
    HEAP8[$5 + 8 | 0] = (HEAPU8[$5 + 8 | 0] | $3) != 0;
    return;
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 $0 = ($7 << 4) + 16 | 0;
 $5 = sqlite3DbReallocOrFree(HEAP32[$6 >> 2], HEAP32[$6 + 108 >> 2], $0, $0 >> 31);
 HEAP32[$6 + 108 >> 2] = $5;
 if ($5) {
  $0 = HEAP32[$6 + 104 >> 2];
  HEAP32[$6 + 104 >> 2] = $0 + 1;
  $5 = ($0 << 4) + $5 | 0;
  HEAP32[$5 + 12 >> 2] = $4;
  HEAP8[$5 + 8 | 0] = $3;
  HEAP32[$5 + 4 >> 2] = $2;
  HEAP32[$5 >> 2] = $1;
  return;
 }
 HEAP32[$6 + 104 >> 2] = 0;
 sqlite3OomFault(HEAP32[$6 >> 2]);
}

function jsonParseFillInParentage($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$0 + 8 >> 2];
 HEAP32[HEAP32[$0 + 16 >> 2] + ($1 << 2) >> 2] = $2;
 label$1: {
  label$2: {
   label$3: {
    $3 = Math_imul($1, 12) + $3 | 0;
    switch (HEAPU8[$3 | 0] - 6 | 0) {
    case 1:
     break label$2;

    case 0:
     break label$3;

    default:
     break label$1;
    }
   }
   $2 = 1;
   while (1) {
    if (HEAPU32[$3 + 4 >> 2] < $2 >>> 0) {
     break label$1;
    }
    jsonParseFillInParentage($0, $1 + $2 | 0, $1);
    $2 = jsonNodeSize(Math_imul($2, 12) + $3 | 0) + $2 | 0;
    continue;
   }
  }
  $4 = $3 + 12 | 0;
  $5 = $3;
  $2 = 1;
  while (1) {
   if (HEAPU32[$5 + 4 >> 2] < $2 >>> 0) {
    break label$1;
   }
   $3 = $1 + $2 | 0;
   HEAP32[HEAP32[$0 + 16 >> 2] + ($3 << 2) >> 2] = $1;
   jsonParseFillInParentage($0, $3 + 1 | 0, $1);
   $2 = (jsonNodeSize(Math_imul($2, 12) + $4 | 0) + $2 | 0) + 1 | 0;
   continue;
  }
 }
}

function vdbePmaWriterFinish($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if (HEAP32[$0 >> 2]) {
   break label$1;
  }
  $6 = HEAP32[$0 + 4 >> 2];
  if (!$6) {
   break label$1;
  }
  $4 = HEAP32[$0 + 12 >> 2];
  $7 = HEAP32[$0 + 16 >> 2];
  if (($4 | 0) >= ($7 | 0)) {
   break label$1;
  }
  $2 = HEAP32[$0 + 24 >> 2];
  $5 = $4 + $2 | 0;
  $2 = $4 >> 31;
  $3 = $2 + HEAP32[$0 + 28 >> 2] | 0;
  $3 = $5 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
  HEAP32[$0 >> 2] = sqlite3OsWrite(HEAP32[$0 + 32 >> 2], $4 + $6 | 0, $7 - $4 | 0, $5, $3);
 }
 $3 = HEAP32[$0 + 24 >> 2];
 $7 = $3;
 $2 = HEAP32[$0 + 28 >> 2];
 $4 = $2;
 $2 = HEAP32[$0 + 16 >> 2];
 $3 = $2 >> 31;
 $6 = $2;
 $2 = $3;
 $3 = $4;
 $5 = $2 + $3 | 0;
 $2 = $6 + $7 | 0;
 $5 = $6 >>> 0 > $2 >>> 0 ? $5 + 1 | 0 : $5;
 HEAP32[$1 >> 2] = $2;
 HEAP32[$1 + 4 >> 2] = $5;
 sqlite3_free(HEAP32[$0 + 4 >> 2]);
 $1 = HEAP32[$0 >> 2];
 memset($0, 0, 40);
 return $1;
}

function sqlite3PagerCloseWal($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  label$2: {
   if (HEAP32[$0 + 232 >> 2]) {
    break label$2;
   }
   HEAP32[$3 + 12 >> 2] = 0;
   $2 = pagerLockDb($0, 1);
   if ($2) {
    break label$1;
   }
   $2 = sqlite3OsAccess(HEAP32[$0 >> 2], HEAP32[$0 + 236 >> 2], 0, $3 + 12 | 0);
   if (!($2 | !HEAP32[$3 + 12 >> 2])) {
    $2 = pagerOpenWal($0);
   }
   if ($2) {
    break label$1;
   }
   if (HEAP32[$0 + 232 >> 2]) {
    break label$2;
   }
   $2 = 0;
   break label$1;
  }
  $2 = pagerExclusiveLock($0);
  if ($2) {
   break label$1;
  }
  $2 = 0;
  $1 = sqlite3WalClose(HEAP32[$0 + 232 >> 2], $1, HEAPU8[$0 + 11 | 0], HEAP32[$0 + 168 >> 2], HEAP32[$0 + 224 >> 2]);
  HEAP32[$0 + 232 >> 2] = 0;
  if (!$1) {
   break label$1;
  }
  if (!HEAPU8[$0 + 4 | 0]) {
   pagerUnlockDb($0, 1);
  }
  $2 = $1;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function fts3DeleteByRowid($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $1;
 HEAP32[$4 + 8 >> 2] = 0;
 HEAP32[$4 + 4 >> 2] = 0;
 fts3DeleteTerms($4 + 8 | 0, $0, $1, $3, $4 + 4 | 0);
 $5 = HEAP32[$4 + 8 >> 2];
 if (!($5 | !HEAP32[$4 + 4 >> 2])) {
  HEAP32[$4 >> 2] = 0;
  $1 = fts3IsEmpty($0, $1, $4);
  HEAP32[$4 + 8 >> 2] = $1;
  label$2: {
   if ($1) {
    break label$2;
   }
   if (HEAP32[$4 >> 2]) {
    HEAP32[$4 + 8 >> 2] = fts3DeleteAll($0, 1);
    HEAP32[$2 >> 2] = 0;
    memset($3, 0, (HEAP32[$0 + 24 >> 2] << 3) + 8 | 0);
    break label$2;
   }
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] - 1;
   if (!HEAP32[$0 + 40 >> 2]) {
    fts3SqlExec($4 + 8 | 0, $0, 0, $4 + 12 | 0);
   }
   if (!HEAPU8[$0 + 238 | 0]) {
    break label$2;
   }
   fts3SqlExec($4 + 8 | 0, $0, 19, $4 + 12 | 0);
  }
  $5 = HEAP32[$4 + 8 >> 2];
 }
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function autoIncrementEnd($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = $0 + 112 | 0;
 $7 = HEAP32[$0 >> 2];
 $5 = HEAP32[$0 + 8 >> 2];
 while (1) {
  label$2: {
   $2 = HEAP32[$2 >> 2];
   if (!$2) {
    break label$2;
   }
   $4 = HEAP32[$2 + 12 >> 2];
   $1 = HEAP32[$7 + 16 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $6 = sqlite3GetTempReg($0);
   sqlite3VdbeAddOp3($5, 55, $4 + 2 | 0, sqlite3VdbeCurrentAddr($5) + 7 | 0, $4);
   sqlite3OpenTable($0, 0, HEAP32[$2 + 8 >> 2], HEAP32[HEAP32[(($3 << 4) + $1 | 0) + 12 >> 2] + 72 >> 2], 113);
   $1 = sqlite3VdbeAddOpList($5, 5, 49216);
   if (!$1) {
    break label$2;
   }
   $3 = $4 + 1 | 0;
   HEAP32[$1 + 72 >> 2] = $3;
   HEAP32[$1 + 68 >> 2] = $6;
   HEAP32[$1 + 52 >> 2] = $6;
   HEAP32[$1 + 44 >> 2] = $4 - 1;
   HEAP32[$1 + 28 >> 2] = $3;
   HEAP32[$1 + 4 >> 2] = $3;
   HEAP16[$1 + 62 >> 1] = 8;
   sqlite3ReleaseTempReg($0, $6);
   continue;
  }
  break;
 }
}

function jsonObjectFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 label$1: {
  if ($1 & 1) {
   sqlite3_result_error($0, 3652, -1);
   break label$1;
  }
  jsonInit($3, $0);
  jsonAppendChar($3, 123);
  while (1) {
   if (($1 | 0) > ($4 | 0)) {
    $6 = $4 << 2;
    $5 = $6 + $2 | 0;
    if ((sqlite3_value_type(HEAP32[$5 >> 2]) | 0) != 3) {
     sqlite3_result_error($0, 18216, -1);
     jsonReset($3);
     break label$1;
    } else {
     jsonAppendSeparator($3);
     jsonAppendString($3, sqlite3_value_text(HEAP32[$5 >> 2]), sqlite3_value_bytes(HEAP32[$5 >> 2]));
     jsonAppendChar($3, 58);
     jsonAppendValue($3, HEAP32[($6 | 4) + $2 >> 2]);
     $4 = $4 + 2 | 0;
     continue;
    }
   }
   break;
  }
  jsonAppendChar($3, 125);
  jsonResult($3);
  sqlite3_result_subtype($0, 74);
 }
 __stack_pointer = $3 + 128 | 0;
}

function sqlite3_backup_finish($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 if (!$0) {
  return 0;
 }
 $3 = HEAP32[$0 + 20 >> 2];
 sqlite3BtreeEnter(HEAP32[$0 + 24 >> 2]);
 if (HEAP32[$0 >> 2]) {
  $1 = HEAP32[$0 + 24 >> 2];
  HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] - 1;
 }
 if (HEAP32[$0 + 40 >> 2]) {
  $1 = sqlite3PagerBackupPtr(sqlite3BtreePager(HEAP32[$0 + 24 >> 2]));
  while (1) {
   $4 = $1;
   $2 = HEAP32[$1 >> 2];
   $1 = $2 + 44 | 0;
   if (($0 | 0) != ($2 | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$4 >> 2] = HEAP32[$0 + 44 >> 2];
 }
 sqlite3BtreeRollback(HEAP32[$0 + 4 >> 2], 0, 0);
 $1 = HEAP32[$0 + 28 >> 2];
 $1 = ($1 | 0) == 101 ? 0 : $1;
 $2 = HEAP32[$0 >> 2];
 label$5: {
  if (!$2) {
   break label$5;
  }
  sqlite3Error($2, $1);
  sqlite3LeaveMutexAndCloseZombie(HEAP32[$0 >> 2]);
  if (!HEAP32[$0 >> 2]) {
   break label$5;
  }
  sqlite3_free($0);
 }
 sqlite3LeaveMutexAndCloseZombie($3);
 return $1;
}

function sqlite3FtsUnicodeFold($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (($0 | 0) <= 127) {
  return $0 - 65 >>> 0 < 26 ? $0 + 32 | 0 : $0;
 }
 label$2: {
  if ($0 >>> 0 <= 65535) {
   $2 = 162;
   $5 = -1;
   while (1) {
    if (($2 | 0) >= ($3 | 0)) {
     $4 = ($2 + $3 | 0) / 2 | 0;
     $6 = HEAPU16[($4 << 2) + 53184 >> 1] > ($0 | 0);
     $2 = $6 ? $4 - 1 | 0 : $2;
     $5 = $6 ? $5 : $4;
     $3 = $6 ? $3 : $4 + 1 | 0;
     continue;
    }
    break;
   }
   $2 = $5 << 2;
   $3 = HEAPU16[$2 + 53184 >> 1];
   label$6: {
    if (($3 + HEAPU8[$2 + 53187 | 0] | 0) <= ($0 | 0)) {
     break label$6;
    }
    $2 = HEAPU8[$2 + 53186 | 0];
    if ($2 & ($0 ^ $3) & 1) {
     break label$6;
    }
    $0 = HEAPU16[($2 & 254) + 53840 >> 1] + $0 & 65535;
   }
   if (!$1) {
    break label$2;
   }
   return remove_diacritic($0, ($1 | 0) == 2);
  }
  $0 = $0 - 66560 >>> 0 < 40 ? $0 + 40 | 0 : $0;
 }
 return $0;
}

function identPut($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = HEAP32[$1 >> 2];
 while (1) {
  $5 = HEAPU8[$2 + $4 | 0];
  if (!(!$5 | !(HEAPU8[$5 + 30288 | 0] & 6) & ($5 | 0) != 95)) {
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 label$3: {
  label$4: {
   if (HEAPU8[$2 | 0] - 58 >>> 0 > 4294967285) {
    break label$4;
   }
   if ((sqlite3KeywordCode($2, $4) | 0) != 59 | $5) {
    break label$4;
   }
   $7 = 0;
   if ($4) {
    break label$3;
   }
  }
  HEAP8[$0 + $3 | 0] = 34;
  $3 = $3 + 1 | 0;
  $7 = 1;
 }
 $4 = 0;
 while (1) {
  $5 = $2 + $4 | 0;
  $6 = HEAPU8[$5 | 0];
  if ($6) {
   HEAP8[$0 + $3 | 0] = $6;
   $6 = $3 + 1 | 0;
   if (HEAPU8[$5 | 0] != 34) {
    $3 = $6;
   } else {
    HEAP8[$0 + $6 | 0] = 34;
    $3 = $3 + 2 | 0;
   }
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 if ($7) {
  HEAP8[$0 + $3 | 0] = 34;
  $3 = $3 + 1 | 0;
 }
 HEAP8[$0 + $3 | 0] = 0;
 HEAP32[$1 >> 2] = $3;
}

function fts3PendingListAppendVarint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   if (!$3) {
    $3 = sqlite3_malloc(140);
    if (!$3) {
     return 7;
    }
    HEAP32[$3 + 8 >> 2] = 100;
    HEAP32[$3 >> 2] = 0;
    $4 = $3 + 40 | 0;
    HEAP32[$3 + 4 >> 2] = $4;
    break label$2;
   }
   $4 = HEAP32[$3 + 8 >> 2];
   $5 = HEAP32[$3 >> 2];
   if (($4 | 0) >= ($5 + 11 | 0)) {
    $4 = HEAP32[$3 + 4 >> 2];
    break label$2;
   }
   $5 = $4 << 1;
   $3 = sqlite3_realloc($3, $5 + 40 | 0);
   if (!$3) {
    sqlite3_free(HEAP32[$0 >> 2]);
    $3 = 0;
    $5 = 7;
    break label$1;
   }
   HEAP32[$3 + 8 >> 2] = $5;
   $4 = $3 + 40 | 0;
   HEAP32[$3 + 4 >> 2] = $4;
   $5 = HEAP32[$3 >> 2];
  }
  $4 = sqlite3Fts3PutVarint($4 + $5 | 0, $1, $2) + HEAP32[$3 >> 2] | 0;
  HEAP32[$3 >> 2] = $4;
  HEAP8[HEAP32[$3 + 4 >> 2] + $4 | 0] = 0;
  $5 = 0;
 }
 HEAP32[$0 >> 2] = $3;
 return $5;
}

function explainIndexRange($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $6 = HEAP32[$1 + 32 >> 2];
 $7 = HEAPU16[$1 + 46 >> 1];
 $3 = HEAPU16[$1 + 24 >> 1];
 if (HEAPU8[$1 + 40 | 0] & 48 ? 1 : $3) {
  sqlite3_str_append($0, 26930, 2);
  while (1) {
   if (($2 | 0) != ($3 | 0)) {
    $5 = explainIndexColumnName($6, $2);
    if ($2) {
     sqlite3_str_append($0, 29468, 5);
    }
    HEAP32[$4 >> 2] = $5;
    sqlite3_str_appendf($0, $2 >>> 0 < $7 >>> 0 ? 24451 : 20441, $4);
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  $5 = $3;
  $2 = HEAP32[$1 + 40 >> 2];
  if ($2 & 32) {
   explainAppendTerm($0, $6, HEAPU16[$1 + 26 >> 1], $3, $3, 21226);
   $5 = 1;
   $2 = HEAP32[$1 + 40 >> 2];
  }
  if ($2 & 16) {
   explainAppendTerm($0, $6, HEAPU16[$1 + 28 >> 1], $3, $5, 21263);
  }
  sqlite3_str_append($0, 26910, 1);
 }
 __stack_pointer = $4 + 16 | 0;
}

function exprMightBeIndexed2($0, $1, $2, $3, $4) {
 var $5 = 0;
 while (1) {
  if (!(!$2 & $1 >>> 0 < 2)) {
   $1 = ($2 & 1) << 31 | $1 >>> 1;
   $2 = $2 >>> 1 | 0;
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 $0 = ($5 << 6) + $0 | 0;
 $5 = HEAP32[$0 + 24 >> 2] + 8 | 0;
 $1 = HEAP32[$0 + 48 >> 2];
 while (1) {
  $0 = HEAP32[$5 >> 2];
  if (!$0) {
   return 0;
  }
  label$5: {
   if (!HEAP32[$0 + 40 >> 2]) {
    break label$5;
   }
   $5 = 0;
   while (1) {
    if (HEAPU16[$0 + 50 >> 1] <= $5 >>> 0) {
     break label$5;
    }
    label$7: {
     if (HEAPU16[HEAP32[$0 + 4 >> 2] + ($5 << 1) >> 1] != 65534) {
      break label$7;
     }
     if (sqlite3ExprCompareSkip($4, HEAP32[(HEAP32[$0 + 40 >> 2] + ($5 << 4) | 0) + 8 >> 2], $1)) {
      break label$7;
     }
     HEAP32[$3 + 4 >> 2] = -2;
     HEAP32[$3 >> 2] = $1;
     return 1;
    }
    $5 = $5 + 1 | 0;
    continue;
   }
  }
  $5 = $0 + 20 | 0;
  continue;
 }
}

function agginfoPersistExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (HEAP32[$1 + 4 >> 2] & 81920) {
   break label$1;
  }
  $2 = HEAP32[$1 + 40 >> 2];
  if (!$2) {
   break label$1;
  }
  $3 = HEAP16[$1 + 34 >> 1];
  $4 = HEAP32[$0 >> 2];
  $0 = HEAP32[$4 >> 2];
  label$2: {
   if (HEAPU8[$1 | 0] == 169) {
    if (HEAP32[(HEAP32[$2 + 28 >> 2] + Math_imul($3, 20) | 0) + 4 >> 2] != ($1 | 0)) {
     break label$1;
    }
    $1 = sqlite3ExprDup($0, $1, 0);
    if (!$1) {
     break label$1;
    }
    HEAP32[(HEAP32[$2 + 28 >> 2] + Math_imul($3, 20) | 0) + 4 >> 2] = $1;
    break label$2;
   }
   if (HEAP32[HEAP32[$2 + 40 >> 2] + Math_imul($3, 20) >> 2] != ($1 | 0)) {
    break label$1;
   }
   $1 = sqlite3ExprDup($0, $1, 0);
   if (!$1) {
    break label$1;
   }
   HEAP32[HEAP32[$2 + 40 >> 2] + Math_imul($3, 20) >> 2] = $1;
  }
  sqlite3ExprDeferredDelete($4, $1);
 }
 return 0;
}

function btreeCursor($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP32[$0 + 4 >> 2];
 if ($1 >>> 0 <= 1) {
  if (!$1) {
   return sqlite3CorruptError(71407);
  }
  $1 = (btreePagecount($5) | 0) != 0;
 }
 HEAP32[$4 + 112 >> 2] = $3;
 HEAP8[$4 + 68 | 0] = 255;
 HEAP32[$4 + 64 >> 2] = $1;
 HEAP32[$4 + 20 >> 2] = $5;
 HEAP32[$4 + 8 >> 2] = $0;
 $3 = 0;
 HEAP8[$4 + 1 | 0] = 0;
 $0 = $5 + 8 | 0;
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if ($0) {
   if (HEAP32[$0 + 64 >> 2] == ($1 | 0)) {
    HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] | 32;
    HEAP8[$4 + 1 | 0] = 32;
    $3 = 32;
   }
   $0 = $0 + 24 | 0;
   continue;
  }
  break;
 }
 HEAP8[$4 | 0] = 1;
 HEAP32[$4 + 24 >> 2] = HEAP32[$5 + 8 >> 2];
 HEAP32[$5 + 8 >> 2] = $4;
 label$6: {
  if ($2) {
   HEAP8[$4 + 2 | 0] = 0;
   HEAP8[$4 + 1 | 0] = $3 | 1;
   if (HEAP32[$5 + 84 >> 2]) {
    break label$6;
   }
   return allocateTempSpace($5);
  }
  HEAP8[$4 + 2 | 0] = 2;
 }
 return 0;
}

function cellSizePtr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = HEAPU8[$0 + 10 | 0] + $1 | 0;
 $2 = HEAP8[$5 | 0];
 $3 = $2 & 255;
 label$1: {
  if (($2 | 0) >= 0) {
   $6 = $5;
   break label$1;
  }
  $3 = $3 & 127;
  $2 = 0;
  while (1) {
   $7 = $2 + 1 | 0;
   $6 = $7 + $5 | 0;
   $4 = HEAP8[$6 | 0];
   $3 = $4 & 127 | $3 << 7;
   if (($4 | 0) >= 0) {
    break label$1;
   }
   $4 = $2 >>> 0 < 7;
   $2 = $7;
   if ($4) {
    continue;
   }
   break;
  }
 }
 $2 = $6 + 1 | 0;
 $4 = HEAPU16[$0 + 14 >> 1];
 label$4: {
  if ($4 >>> 0 >= $3 >>> 0) {
   $2 = ($3 - $1 | 0) + $2 | 0;
   $2 = $2 >>> 0 > 4 ? $2 : 4;
   break label$4;
  }
  $5 = $2 - $1 & 65535;
  $2 = HEAPU16[$0 + 16 >> 1];
  $1 = $2;
  $2 = (($3 - $2 >>> 0) % (HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] - 4 >>> 0) | 0) + $2 | 0;
  $2 = ($5 + ($2 >>> 0 > $4 >>> 0 ? $1 : $2) | 0) + 4 | 0;
 }
 return $2 & 65535;
}

function renameWalkTrigger($0, $1) {
 var $2 = 0, $3 = 0;
 sqlite3WalkExpr($0, HEAP32[$1 + 12 >> 2]);
 $1 = $1 + 28 | 0;
 while (1) {
  $2 = HEAP32[$1 >> 2];
  if ($2) {
   sqlite3WalkSelect($0, HEAP32[$2 + 8 >> 2]);
   sqlite3WalkExpr($0, HEAP32[$2 + 20 >> 2]);
   sqlite3WalkExprList($0, HEAP32[$2 + 24 >> 2]);
   $1 = HEAP32[$2 + 32 >> 2];
   if ($1) {
    sqlite3WalkExprList($0, HEAP32[$1 >> 2]);
    sqlite3WalkExprList($0, HEAP32[$1 + 8 >> 2]);
    sqlite3WalkExpr($0, HEAP32[$1 + 12 >> 2]);
    sqlite3WalkExpr($0, HEAP32[$1 + 4 >> 2]);
   }
   $1 = 0;
   label$4: {
    $3 = HEAP32[$2 + 16 >> 2];
    if (!$3) {
     break label$4;
    }
    while (1) {
     if (HEAP32[$3 >> 2] <= ($1 | 0)) {
      break label$4;
     }
     sqlite3WalkSelect($0, HEAP32[(($1 << 6) + $3 | 0) + 28 >> 2]);
     $1 = $1 + 1 | 0;
     $3 = HEAP32[$2 + 16 >> 2];
     continue;
    }
   }
   $1 = $2 + 40 | 0;
   continue;
  }
  break;
 }
}

function memdbRead($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $0 = HEAP32[$0 + 4 >> 2];
 $5 = $0;
 $9 = HEAP32[$5 >> 2];
 $10 = HEAP32[$5 + 4 >> 2];
 $5 = $2;
 $8 = $5 + $3 | 0;
 $6 = ($5 >> 31) + $4 | 0;
 $6 = $3 >>> 0 > $8 >>> 0 ? $6 + 1 | 0 : $6;
 $7 = $8;
 $5 = $6;
 $6 = $10;
 label$1: {
  if ($7 >>> 0 > $9 >>> 0 & ($5 | 0) >= ($6 | 0) | ($6 | 0) < ($5 | 0)) {
   $1 = memset($1, 0, $2);
   $6 = HEAP32[$0 + 4 >> 2];
   $5 = $3;
   $7 = HEAP32[$0 >> 2];
   $2 = 522;
   if (($6 | 0) <= ($4 | 0) & $5 >>> 0 >= $7 >>> 0 | ($4 | 0) > ($6 | 0)) {
    break label$1;
   }
   $5 = $7;
   $9 = $5 - $3 | 0;
   $7 = $6;
   $6 = $4;
   $8 = $6 + ($3 >>> 0 > $5 >>> 0) | 0;
   __memcpy($1, $3 + HEAP32[$0 + 24 >> 2] | 0, $9);
   return 522;
  }
  __memcpy($1, $3 + HEAP32[$0 + 24 >> 2] | 0, $2);
  $2 = 0;
 }
 return $2 | 0;
}

function blobReadWrite($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 if (!$0) {
  return sqlite3MisuseError(97485);
 }
 $9 = HEAP32[$0 + 20 >> 2];
 $6 = 1;
 label$2: {
  if (($2 | $3) < 0) {
   break label$2;
  }
  $7 = HEAP32[$0 >> 2];
  $8 = $7 >> 31;
  $11 = $8;
  $10 = $3 + $2 | 0;
  $5 = $2 >>> 0 > $10 >>> 0 ? 1 : $5;
  $8 = $7;
  $7 = $5;
  $5 = $11;
  if ($8 >>> 0 < $10 >>> 0 & ($7 | 0) >= ($5 | 0) | ($5 | 0) < ($7 | 0)) {
   break label$2;
  }
  $5 = HEAP32[$0 + 16 >> 2];
  if (!$5) {
   $6 = 4;
   break label$2;
  }
  sqlite3BtreeEnterCursor(HEAP32[$0 + 12 >> 2]);
  $6 = 4;
  $3 = FUNCTION_TABLE[$4 | 0](HEAP32[$0 + 12 >> 2], HEAP32[$0 + 4 >> 2] + $3 | 0, $2, $1) | 0;
  if (($3 | 0) == 4) {
   sqlite3VdbeFinalize($5);
   HEAP32[$0 + 16 >> 2] = 0;
   break label$2;
  }
  HEAP32[$5 + 36 >> 2] = $3;
  $6 = $3;
 }
 sqlite3Error($9, $6);
 return sqlite3ApiExit($9, $6);
}

function fts3SnippetAdvance($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 HEAP32[$4 + 12 >> 2] = $5;
 label$1: {
  if (!$5) {
   break label$1;
  }
  $3 = HEAP32[$1 + 4 >> 2];
  $7 = $3;
  $6 = HEAP32[$1 >> 2];
  HEAP32[$4 >> 2] = $6;
  HEAP32[$4 + 4 >> 2] = $3;
  $3 = $2 >> 31;
  $8 = $3;
  while (1) {
   $5 = HEAP32[$4 + 12 >> 2];
   label$3: {
    $3 = $7;
    if ($6 >>> 0 < $2 >>> 0 & ($3 | 0) <= ($8 | 0) | ($3 | 0) < ($8 | 0)) {
     if (HEAPU8[$5 | 0] >= 2) {
      break label$3;
     }
     $6 = -1;
     $7 = -1;
     $5 = 0;
    }
    $3 = $1;
    HEAP32[$3 >> 2] = $6;
    HEAP32[$3 + 4 >> 2] = $7;
    HEAP32[$0 >> 2] = $5;
    break label$1;
   }
   fts3GetDeltaPosition($4 + 12 | 0, $4);
   $6 = HEAP32[$4 >> 2];
   $3 = HEAP32[$4 + 4 >> 2];
   $7 = $3;
   continue;
  }
 }
 __stack_pointer = $4 + 16 | 0;
}

function fkParentIsModified($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = HEAP32[$1 + 20 >> 2];
 $8 = ($4 | 0) > 0 ? $4 : 0;
 while (1) {
  if (($6 | 0) == ($8 | 0)) {
   return 0;
  }
  $4 = 0;
  $5 = HEAP16[$0 + 34 >> 1];
  $9 = ($5 | 0) > 0 ? $5 : 0;
  $7 = HEAP32[(($6 << 3) + $1 | 0) + 40 >> 2];
  label$3: {
   while (1) {
    if (($4 | 0) != ($9 | 0)) {
     label$6: {
      if ((!$3 | HEAP16[$0 + 32 >> 1] != ($4 | 0)) & HEAP32[($4 << 2) + $2 >> 2] < 0) {
       break label$6;
      }
      $5 = HEAP32[$0 + 4 >> 2];
      if ($7) {
       if (sqlite3StrICmp(HEAP32[Math_imul($4, 12) + $5 >> 2], $7)) {
        break label$6;
       }
       break label$3;
      }
      if (HEAP8[(Math_imul($4, 12) + $5 | 0) + 10 | 0] & 1) {
       break label$3;
      }
     }
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   $6 = $6 + 1 | 0;
   continue;
  }
  break;
 }
 return 1;
}

function memdbLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = HEAP32[$0 + 8 >> 2];
 $3 = 0;
 label$1: {
  if (($4 | 0) == ($1 | 0)) {
   break label$1;
  }
  $2 = HEAP32[$0 + 4 >> 2];
  label$2: {
   if (($1 | 0) >= 2) {
    $3 = 8;
    if (HEAPU8[$2 + 36 | 0] & 4) {
     break label$1;
    }
    if (($4 | 0) > 1) {
     break label$2;
    }
    $3 = 5;
    if (HEAP32[$2 + 44 >> 2]) {
     break label$1;
    }
    HEAP32[$2 + 44 >> 2] = 1;
    break label$2;
   }
   if (($1 | 0) == 1) {
    if (($4 | 0) >= 2) {
     HEAP32[$2 + 44 >> 2] = 0;
     break label$2;
    }
    $3 = 5;
    if (HEAP32[$2 + 44 >> 2]) {
     break label$1;
    }
    HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] + 1;
    break label$2;
   }
   if (($4 | 0) >= 2) {
    HEAP32[$2 + 44 >> 2] = 0;
   }
   HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] - 1;
  }
  HEAP32[$0 + 8 >> 2] = $1;
  $3 = 0;
 }
 return $3 | 0;
}

function vdbePmaReaderInit($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0;
 $8 = __stack_pointer - 16 | 0;
 __stack_pointer = $8;
 $1 = vdbePmaReaderSeek($0, $4, $1, $2, $3);
 label$1: {
  if ($1) {
   break label$1;
  }
  $0 = $8;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  $1 = vdbePmaReadVarint($4, $0 + 8 | 0);
  $2 = HEAP32[$0 + 8 >> 2];
  $0 = HEAP32[$0 + 12 >> 2];
  $3 = $0;
  $0 = HEAP32[$4 >> 2];
  $7 = $0;
  $6 = $0 + $2 | 0;
  $0 = HEAP32[$4 + 4 >> 2];
  $0 = $0 + $3 | 0;
  HEAP32[$4 + 8 >> 2] = $6;
  $0 = $6 >>> 0 < $7 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$4 + 12 >> 2] = $0;
  $0 = HEAP32[$5 >> 2];
  $7 = $0;
  $0 = HEAP32[$5 + 4 >> 2];
  $6 = $0 + $3 | 0;
  $0 = $7 + $2 | 0;
  $6 = $0 >>> 0 < $7 >>> 0 ? $6 + 1 | 0 : $6;
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $6;
  if ($1) {
   break label$1;
  }
  $1 = vdbePmaReaderNext($4);
 }
 __stack_pointer = $8 + 16 | 0;
 return $1;
}

function tokenExpr($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$2 + 4 >> 2];
 $3 = sqlite3DbMallocRawNN(HEAP32[$0 >> 2], $4 + 53 | 0, 0);
 label$1: {
  if (!$3) {
   break label$1;
  }
  HEAP32[$3 + 4 >> 2] = 8388608;
  HEAP8[$3 | 0] = $1;
  HEAP32[$3 + 40 >> 2] = 0;
  HEAP32[$3 + 12 >> 2] = 0;
  HEAP32[$3 + 16 >> 2] = 0;
  HEAP32[$3 + 44 >> 2] = 0;
  HEAP32[$3 + 48 >> 2] = 0;
  HEAP32[$3 + 20 >> 2] = 0;
  HEAP16[$3 + 32 >> 1] = 0;
  HEAP32[$3 + 28 >> 2] = 0;
  HEAP8[$3 + 1 | 0] = 0;
  HEAP8[$3 + 2 | 0] = 0;
  $1 = $3 + 52 | 0;
  HEAP32[$3 + 8 >> 2] = $1;
  $5 = HEAP32[$2 >> 2];
  HEAP8[__memcpy($1, $5, $4) + $4 | 0] = 0;
  HEAP32[$3 + 36 >> 2] = $5 - HEAP32[$0 + 232 >> 2];
  if (HEAP8[HEAPU8[HEAP32[$3 + 8 >> 2]] + 30288 | 0] < 0) {
   sqlite3DequoteExpr($3);
  }
  HEAP32[$3 + 24 >> 2] = 1;
  if (HEAPU8[$0 + 208 | 0] < 2) {
   break label$1;
  }
  sqlite3RenameTokenMap($0, $3, $2);
 }
 return $3;
}

function sqlite3WindowAlloc($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0;
 label$1: {
  label$2: {
   if (($2 | 0) == 85 & ($4 | 0) == 88) {
    break label$2;
   }
   label$3: {
    if (($2 | 0) != 86) {
     break label$3;
    }
    switch ($4 - 85 | 0) {
    case 0:
    case 3:
     break label$2;

    default:
     break label$3;
    }
   }
   $7 = sqlite3DbMallocZero(HEAP32[$0 >> 2], 100, 0);
   if (!$7) {
    break label$1;
   }
   HEAP8[$7 + 18 | 0] = $4;
   HEAP8[$7 + 17 | 0] = $2;
   HEAP8[$7 + 16 | 0] = $1 ? $1 : 89;
   $6 = $6 ? $6 : HEAP32[HEAP32[$0 >> 2] + 80 >> 2] << 30 >> 31 & 66;
   HEAP8[$7 + 19 | 0] = !$1;
   HEAP8[$7 + 20 | 0] = $6;
   HEAP32[$7 + 28 >> 2] = sqlite3WindowOffsetExpr($0, $5);
   HEAP32[$7 + 24 >> 2] = sqlite3WindowOffsetExpr($0, $3);
   return $7;
  }
  sqlite3ErrorMsg($0, 10247, 0);
 }
 sqlite3ExprDelete(HEAP32[$0 >> 2], $5);
 sqlite3ExprDelete(HEAP32[$0 >> 2], $3);
 return 0;
}

function sqlite3WindowCompare($0, $1, $2, $3) {
 var $4 = 0;
 $4 = 1;
 label$1: {
  if (!$1 | !$2 | HEAPU8[$1 + 16 | 0] != HEAPU8[$2 + 16 | 0] | (HEAPU8[$1 + 17 | 0] != HEAPU8[$2 + 17 | 0] | HEAPU8[$1 + 18 | 0] != HEAPU8[$2 + 18 | 0])) {
   break label$1;
  }
  if (HEAPU8[$1 + 20 | 0] != HEAPU8[$2 + 20 | 0]) {
   break label$1;
  }
  if (sqlite3ExprCompare($0, HEAP32[$1 + 24 >> 2], HEAP32[$2 + 24 >> 2], -1)) {
   break label$1;
  }
  if (sqlite3ExprCompare($0, HEAP32[$1 + 28 >> 2], HEAP32[$2 + 28 >> 2], -1)) {
   break label$1;
  }
  $4 = sqlite3ExprListCompare(HEAP32[$1 + 8 >> 2], HEAP32[$2 + 8 >> 2], -1);
  if ($4) {
   break label$1;
  }
  $4 = sqlite3ExprListCompare(HEAP32[$1 + 12 >> 2], HEAP32[$2 + 12 >> 2], -1);
  if ($4) {
   break label$1;
  }
  if ($3) {
   $4 = sqlite3ExprCompare($0, HEAP32[$1 + 40 >> 2], HEAP32[$2 + 40 >> 2], -1);
   if ($4) {
    break label$1;
   }
  }
  $4 = 0;
 }
 return $4;
}

function growOpArray($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = HEAP32[$0 + 112 >> 2];
 $1 = $5 >> 31;
 $6 = $5;
 $5 = $1 << 1 | $5 >>> 31;
 $2 = !($1 | $6);
 $3 = $2 ? 51 : $6 << 1;
 $6 = $3;
 $1 = $2 ? 0 : $5;
 $8 = $1;
 $7 = HEAP32[$0 + 12 >> 2];
 $4 = HEAP32[$7 >> 2];
 $1 = HEAP32[$4 + 140 >> 2];
 $3 = $1 >> 31;
 label$1: {
  $5 = $1;
  $2 = $6;
  $1 = $3;
  $3 = $8;
  label$2: {
   if ($5 >>> 0 < $2 >>> 0 & ($1 | 0) <= ($3 | 0) | ($1 | 0) < ($3 | 0)) {
    sqlite3OomFault($4);
    break label$2;
   }
   $1 = HEAP32[$0 + 104 >> 2];
   $2 = $8;
   $3 = __wasm_i64_mul($6, $2, 20, 0);
   $2 = i64toi32_i32$HIGH_BITS;
   $4 = sqlite3DbRealloc($4, $1, $3, $2);
   if ($4) {
    break label$1;
   }
  }
  return 7;
 }
 $1 = sqlite3DbMallocSize(HEAP32[$7 >> 2], $4);
 HEAP32[$7 + 48 >> 2] = $1;
 HEAP32[$0 + 104 >> 2] = $4;
 HEAP32[$0 + 112 >> 2] = ($1 >>> 0) / 20;
 return 0;
}

function sqlite3ResolveSelfReference($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 112 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 32 >> 2] = 0;
 HEAP32[$5 + 36 >> 2] = 0;
 HEAP32[$5 + 24 >> 2] = 0;
 HEAP32[$5 + 28 >> 2] = 0;
 HEAP32[$5 + 16 >> 2] = 0;
 HEAP32[$5 + 20 >> 2] = 0;
 memset($5 + 40 | 0, 0, 72);
 if ($1) {
  HEAP32[$5 + 40 >> 2] = 1;
  $6 = HEAP32[$1 >> 2];
  HEAP32[$5 + 88 >> 2] = -1;
  HEAP32[$5 - -64 >> 2] = $1;
  HEAP32[$5 + 56 >> 2] = $6;
  $2 = HEAP32[$1 + 60 >> 2] == HEAP32[HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + 28 >> 2] ? $2 : $2 | 262144;
 }
 HEAP32[$5 + 8 >> 2] = $0;
 HEAP32[$5 + 32 >> 2] = $2 | 65536;
 HEAP32[$5 + 12 >> 2] = $5 + 40;
 $2 = 1;
 label$2: {
  if (sqlite3ResolveExprNames($5 + 8 | 0, $3)) {
   break label$2;
  }
  $2 = 0;
  if (!$4) {
   break label$2;
  }
  $2 = sqlite3ResolveExprListNames($5 + 8 | 0, $4);
 }
 __stack_pointer = $5 + 112 | 0;
 return $2;
}

function sqlite3ExpandSubquery($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$1 + 20 >> 2];
 $2 = sqlite3DbMallocZero(HEAP32[$0 >> 2], 64, 0);
 HEAP32[$1 + 16 >> 2] = $2;
 if ($2) {
  HEAP32[$2 + 24 >> 2] = 1;
  $5 = HEAP32[$0 >> 2];
  $6 = HEAP32[$1 + 12 >> 2];
  label$2: {
   if ($6) {
    $1 = sqlite3DbStrDup($5, $6);
    break label$2;
   }
   HEAP32[$4 >> 2] = $1;
   $1 = sqlite3MPrintf($5, 18893, $4);
  }
  HEAP32[$2 >> 2] = $1;
  while (1) {
   $1 = $3;
   $3 = HEAP32[$1 + 52 >> 2];
   if ($3) {
    continue;
   }
   break;
  }
  sqlite3ColumnsFromExprList($0, HEAP32[$1 + 28 >> 2], $2 + 34 | 0, $2 + 4 | 0);
  HEAP16[$2 + 38 >> 1] = 200;
  HEAP16[$2 + 32 >> 1] = 65535;
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] | 16896;
  $3 = HEAP32[$0 + 36 >> 2] != 0;
 } else {
  $3 = 7;
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function sqlite3AuthReadCol($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $6 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$6 + 177 | 0]) {
   break label$1;
  }
  $7 = HEAP32[HEAP32[$6 + 16 >> 2] + ($3 << 4) >> 2];
  $5 = FUNCTION_TABLE[HEAP32[$6 + 360 >> 2]](HEAP32[$6 + 364 >> 2], 20, $1, $2, $7, HEAP32[$0 + 248 >> 2]) | 0;
  if (($5 | 0) == 1) {
   HEAP32[$4 + 36 >> 2] = $2;
   HEAP32[$4 + 32 >> 2] = $1;
   $5 = sqlite3_mprintf(6016, $4 + 32 | 0);
   if (!(!$3 & HEAP32[$6 + 20 >> 2] < 3)) {
    HEAP32[$4 + 20 >> 2] = $5;
    HEAP32[$4 + 16 >> 2] = $7;
    $5 = sqlite3_mprintf(1034, $4 + 16 | 0);
   }
   HEAP32[$4 >> 2] = $5;
   sqlite3ErrorMsg($0, 14864, $4);
   HEAP32[$0 + 12 >> 2] = 23;
   $5 = 1;
   break label$1;
  }
  if (!($5 & -3)) {
   break label$1;
  }
  sqliteAuthBadReturnCode($0);
 }
 __stack_pointer = $4 + 48 | 0;
 return $5;
}

function lengthFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     $2 = HEAP32[$2 >> 2];
     switch (sqlite3_value_type($2) - 1 | 0) {
     case 2:
      break label$3;

     case 0:
     case 1:
     case 3:
      break label$4;

     default:
      break label$2;
     }
    }
    sqlite3_result_int($0, sqlite3_value_bytes($2));
    return;
   }
   $1 = sqlite3_value_text($2);
   if (!$1) {
    break label$1;
   }
   $2 = $1;
   label$5: while (1) {
    $3 = HEAPU8[$2 | 0];
    if ($3) {
     $2 = $2 + 1 | 0;
     if ($3 >>> 0 < 192) {
      continue;
     }
     while (1) {
      if ((HEAPU8[$2 | 0] & 192) != 128) {
       continue label$5;
      }
      $1 = $1 + 1 | 0;
      $2 = $2 + 1 | 0;
      continue;
     }
    }
    break;
   }
   sqlite3_result_int($0, $2 - $1 | 0);
   return;
  }
  sqlite3_result_null($0);
 }
}

function cos($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 wasm2js_scratch_store_f64(+$0);
 $3 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $3 = $3 & 2147483647;
 label$1: {
  if ($3 >>> 0 <= 1072243195) {
   $2 = 1;
   if ($3 >>> 0 < 1044816030) {
    break label$1;
   }
   $2 = __cos($0, 0);
   break label$1;
  }
  $2 = $0 - $0;
  if ($3 >>> 0 >= 2146435072) {
   break label$1;
  }
  label$3: {
   switch (__rem_pio2($0, $1) & 3) {
   case 0:
    $2 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;

   case 1:
    $2 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;

   case 2:
    $2 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;

   default:
    break label$3;
   }
  }
  $2 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function sqlite3ReferencesSrcList($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 $4 = $3 + 40 | 0;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$3 + 48 >> 2] = 0;
 HEAP32[$3 + 52 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 40 >> 2] = 66;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 67;
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP32[$3 + 44 >> 2] = 68;
 HEAP32[$3 + 56 >> 2] = $3 + 8;
 $4 = HEAP32[$0 >> 2];
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = $4;
 sqlite3WalkExprList($3 + 32 | 0, HEAP32[$1 + 20 >> 2]);
 if (HEAP8[$1 + 7 | 0] & 1) {
  sqlite3WalkExpr($3 + 32 | 0, HEAP32[HEAP32[$1 + 44 >> 2] + 40 >> 2]);
 }
 sqlite3DbFree(HEAP32[$0 >> 2], HEAP32[$3 + 24 >> 2]);
 __stack_pointer = $3 - -64 | 0;
 $1 = HEAPU16[$3 + 52 >> 1];
 return $1 & 1 ? 1 : $1 ? 0 : -1;
}

function fts3MatchinfoSelectDoctotal($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $7 = __stack_pointer - 16 | 0;
 __stack_pointer = $7;
 $5 = HEAP32[$1 >> 2];
 label$1: {
  if (!$5) {
   $0 = sqlite3Fts3SelectDoctotal($0, $1);
   if ($0) {
    break label$1;
   }
   $5 = HEAP32[$1 >> 2];
  }
  $0 = 267;
  $1 = sqlite3_column_bytes($5, 0);
  $5 = sqlite3_column_blob($5, 0);
  if (!$5) {
   break label$1;
  }
  $8 = $1 + $5 | 0;
  $9 = sqlite3Fts3GetVarintBounded($5, $8, $7 + 8 | 0);
  $6 = HEAP32[$7 + 12 >> 2];
  $11 = $6;
  $10 = HEAP32[$7 + 8 >> 2];
  if (!$10 & ($6 | 0) <= 0 | ($6 | 0) < 0 | ($1 | 0) < ($9 | 0)) {
   break label$1;
  }
  $6 = $2;
  HEAP32[$6 >> 2] = $10;
  HEAP32[$6 + 4 >> 2] = $11;
  if ($3) {
   HEAP32[$3 >> 2] = $5 + $9;
  }
  $0 = 0;
  if (!$4) {
   break label$1;
  }
  HEAP32[$4 >> 2] = $8;
 }
 __stack_pointer = $7 + 16 | 0;
 return $0;
}

function srclistRenumberCursors($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = $2 + 8 | 0;
 while (1) {
  if (HEAP32[$2 >> 2] > ($7 | 0)) {
   label$3: {
    if (($3 | 0) == ($7 | 0)) {
     break label$3;
    }
    $4 = HEAP32[$5 + 40 >> 2] + 1 | 0;
    label$4: {
     if (HEAPU8[$5 + 37 | 0] & 64) {
      $6 = HEAP32[($4 << 2) + $1 >> 2];
      if ($6) {
       break label$4;
      }
     }
     $6 = HEAP32[$0 + 40 >> 2];
     HEAP32[$0 + 40 >> 2] = $6 + 1;
     HEAP32[($4 << 2) + $1 >> 2] = $6;
     $6 = HEAP32[((HEAP32[$5 + 40 >> 2] << 2) + $1 | 0) + 4 >> 2];
    }
    HEAP32[$5 + 40 >> 2] = $6;
    $4 = $5 + 20 | 0;
    while (1) {
     $4 = HEAP32[$4 >> 2];
     if (!$4) {
      break label$3;
     }
     srclistRenumberCursors($0, $1, HEAP32[$4 + 32 >> 2], -1);
     $4 = $4 + 52 | 0;
     continue;
    }
   }
   $5 = $5 - -64 | 0;
   $7 = $7 + 1 | 0;
   continue;
  }
  break;
 }
}

function findCreateFileMode($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 528 | 0;
 __stack_pointer = $5;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$3 >> 2] = 0;
 HEAP32[$4 >> 2] = 0;
 label$1: {
  if ($1 & 526336) {
   $1 = sqlite3Strlen30($0);
   while (1) {
    if (($1 | 0) < 2) {
     break label$1;
    }
    label$4: {
     $1 = $1 - 1 | 0;
     switch (HEAPU8[$1 + $0 | 0] - 45 | 0) {
     case 1:
      break label$1;

     case 0:
      break label$4;

     default:
      continue;
     }
    }
    break;
   }
   $0 = __memcpy($5, $0, $1);
   HEAP8[$1 + $0 | 0] = 0;
   $6 = getFileMode($0, $2, $3, $4);
   break label$1;
  }
  if ($1 & 8) {
   HEAP32[$2 >> 2] = 384;
   break label$1;
  }
  if (!($1 & 64)) {
   break label$1;
  }
  $1 = sqlite3_uri_parameter($0, 12045);
  if (!$1) {
   break label$1;
  }
  $6 = getFileMode($1, $2, $3, $4);
 }
 __stack_pointer = $5 + 528 | 0;
 return $6;
}

function vdbeSorterMerge($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 $4 = $3 + 12 | 0;
 label$1: {
  while (1) {
   $5 = $2 + 8 | 0;
   label$3: {
    while (1) {
     if ((FUNCTION_TABLE[HEAP32[$0 + 32 >> 2]]($0, $3 + 8 | 0, $1 + 8 | 0, HEAP32[$1 >> 2], $5, HEAP32[$2 >> 2]) | 0) > 0) {
      break label$3;
     }
     HEAP32[$4 >> 2] = $1;
     $6 = $1;
     $4 = $1 + 4 | 0;
     $1 = HEAP32[$1 + 4 >> 2];
     if ($1) {
      continue;
     }
     break;
    }
    HEAP32[$6 + 4 >> 2] = $2;
    break label$1;
   }
   HEAP32[$4 >> 2] = $2;
   $5 = HEAP32[$2 + 4 >> 2];
   HEAP32[$3 + 8 >> 2] = 0;
   $6 = $2;
   $4 = $2 + 4 | 0;
   $2 = $5;
   if ($2) {
    continue;
   }
   break;
  }
  HEAP32[$6 + 4 >> 2] = $1;
 }
 __stack_pointer = $3 + 16 | 0;
 $1 = HEAP32[$3 + 12 >> 2];
 return $1;
}

function sqlite3SrcListAppend($0, $1, $2, $3) {
 var $4 = 0;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   label$3: {
    if (!$1) {
     $0 = sqlite3DbMallocRawNN($4, 72, 0);
     if ($0) {
      break label$3;
     }
     break label$1;
    }
    $0 = sqlite3SrcListEnlarge($0, $1, 1, HEAP32[$1 >> 2]);
    if ($0) {
     $1 = HEAP32[$0 >> 2] - 1 | 0;
     break label$2;
    }
    sqlite3SrcListDelete($4, $1);
    break label$1;
   }
   HEAP32[$0 >> 2] = 1;
   HEAP32[$0 + 4 >> 2] = 1;
   memset($0 + 8 | 0, 0, 64);
   HEAP32[$0 + 48 >> 2] = -1;
   $1 = 0;
  }
  if (!(!$3 | !HEAP32[$3 >> 2])) {
   $1 = ($1 << 6) + $0 | 0;
   HEAP32[$1 + 16 >> 2] = sqlite3NameFromToken($4, $3);
   HEAP32[$1 + 12 >> 2] = sqlite3NameFromToken($4, $2);
   return $0;
  }
  $4 = sqlite3NameFromToken($4, $2);
  $1 = ($1 << 6) + $0 | 0;
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$1 + 16 >> 2] = $4;
  return $0;
 }
 return 0;
}

function sqlite3MarkAllShadowTablesOf($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  $4 = sqlite3HashFind($0 + 384 | 0, HEAP32[HEAP32[$1 + 48 >> 2] >> 2]);
  if (!$4) {
   break label$1;
  }
  $0 = HEAP32[$4 >> 2];
  if (!$0 | HEAP32[$0 >> 2] < 3 | !HEAP32[$0 + 92 >> 2]) {
   break label$1;
  }
  $5 = sqlite3Strlen30(HEAP32[$1 >> 2]);
  $0 = HEAP32[$1 + 60 >> 2] + 16 | 0;
  while (1) {
   $0 = HEAP32[$0 >> 2];
   if (!$0) {
    break label$1;
   }
   $2 = HEAP32[$0 + 8 >> 2];
   if (HEAPU8[$2 + 43 | 0] | HEAPU8[$2 + 29 | 0] & 16) {
    continue;
   }
   $3 = HEAP32[$2 >> 2];
   if (sqlite3_strnicmp($3, HEAP32[$1 >> 2], $5)) {
    continue;
   }
   $3 = $3 + $5 | 0;
   if (HEAPU8[$3 | 0] != 95) {
    continue;
   }
   if (!(FUNCTION_TABLE[HEAP32[HEAP32[$4 >> 2] + 92 >> 2]]($3 + 1 | 0) | 0)) {
    continue;
   }
   HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] | 4096;
   continue;
  }
 }
}

function walMerge($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
 $10 = HEAP32[$3 >> 2];
 $11 = HEAP32[$4 >> 2];
 while (1) {
  if (!(($2 | 0) <= ($6 | 0) & ($7 | 0) >= ($11 | 0))) {
   label$3: {
    if (!(($7 | 0) < ($11 | 0) & HEAPU32[(HEAPU16[($6 << 1) + $1 >> 1] << 2) + $0 >> 2] >= HEAPU32[(HEAPU16[($7 << 1) + $10 >> 1] << 2) + $0 >> 2] | ($2 | 0) <= ($6 | 0))) {
     $8 = ($6 << 1) + $1 | 0;
     $6 = $6 + 1 | 0;
     break label$3;
    }
    $8 = ($7 << 1) + $10 | 0;
    $7 = $7 + 1 | 0;
   }
   $8 = HEAPU16[$8 >> 1];
   $12 = HEAP32[($8 << 2) + $0 >> 2];
   HEAP16[($9 << 1) + $5 >> 1] = $8;
   $9 = $9 + 1 | 0;
   if (($2 | 0) <= ($6 | 0)) {
    continue;
   }
   $6 = (HEAP32[(HEAPU16[($6 << 1) + $1 >> 1] << 2) + $0 >> 2] == ($12 | 0)) + $6 | 0;
   continue;
  }
  break;
 }
 HEAP32[$3 >> 2] = $1;
 HEAP32[$4 >> 2] = $9;
 __memcpy($1, $5, $9 << 1);
}

function sqlite3FkDropTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  $3 = HEAP32[$0 >> 2];
  if (HEAPU8[$2 + 43 | 0] | !(HEAPU8[$3 + 33 | 0] & 64)) {
   break label$1;
  }
  $4 = sqlite3GetVdbe($0);
  if (!sqlite3FkReferences($2)) {
   $2 = $2 + 48 | 0;
   while (1) {
    $2 = HEAP32[$2 >> 2];
    if (!$2) {
     break label$1;
    }
    if (!HEAPU8[$2 + 24 | 0]) {
     $2 = $2 + 4 | 0;
     if (!(HEAPU8[$3 + 34 | 0] & 8)) {
      continue;
     }
    }
    break;
   }
   $5 = sqlite3VdbeMakeLabel($0);
   sqlite3VdbeAddOp2($4, 48, 1, $5);
  }
  HEAP8[$0 + 151 | 0] = 1;
  sqlite3DeleteFrom($0, sqlite3SrcListDup($3, $1, 0), 0);
  HEAP8[$0 + 151 | 0] = 0;
  if (!(HEAPU8[$3 + 34 | 0] & 8)) {
   sqlite3VdbeAddOp2($4, 48, 0, sqlite3VdbeCurrentAddr($4) + 2 | 0);
   sqlite3HaltConstraint($0, 787, 2, 0, -1, 4);
  }
  if (!$5) {
   break label$1;
  }
  sqlite3VdbeResolveLabel($4, $5);
 }
}

function __stpcpy($0, $1) {
 var $2 = 0;
 label$1: {
  label$2: {
   if (($0 ^ $1) & 3) {
    $2 = HEAPU8[$1 | 0];
    break label$2;
   }
   if ($1 & 3) {
    while (1) {
     $2 = HEAPU8[$1 | 0];
     HEAP8[$0 | 0] = $2;
     if (!$2) {
      break label$1;
     }
     $0 = $0 + 1 | 0;
     $1 = $1 + 1 | 0;
     if ($1 & 3) {
      continue;
     }
     break;
    }
   }
   $2 = HEAP32[$1 >> 2];
   if (($2 ^ -1) & $2 - 16843009 & -2139062144) {
    break label$2;
   }
   while (1) {
    HEAP32[$0 >> 2] = $2;
    $2 = HEAP32[$1 + 4 >> 2];
    $0 = $0 + 4 | 0;
    $1 = $1 + 4 | 0;
    if (!($2 - 16843009 & ($2 ^ -1) & -2139062144)) {
     continue;
    }
    break;
   }
  }
  HEAP8[$0 | 0] = $2;
  if (!($2 & 255)) {
   break label$1;
  }
  while (1) {
   $2 = HEAPU8[$1 + 1 | 0];
   HEAP8[$0 + 1 | 0] = $2;
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
}

function sqlite3DropTriggerPtr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = HEAP32[$0 >> 2];
 $5 = sqlite3SchemaToIndex($4, HEAP32[$1 + 20 >> 2]);
 $2 = tableOfTrigger($1);
 label$1: {
  if ($2) {
   $6 = ($5 | 0) == 1;
   $7 = HEAP32[$2 >> 2];
   $2 = HEAP32[HEAP32[$4 + 16 >> 2] + ($5 << 4) >> 2];
   if (sqlite3AuthCheck($0, $6 ? 14 : 16, HEAP32[$1 >> 2], $7, $2)) {
    break label$1;
   }
   if (sqlite3AuthCheck($0, 9, $6 ? 8671 : 8690, 0, $2)) {
    break label$1;
   }
  }
  $2 = sqlite3GetVdbe($0);
  if (!$2) {
   break label$1;
  }
  $4 = HEAP32[HEAP32[$4 + 16 >> 2] + ($5 << 4) >> 2];
  HEAP32[$3 + 4 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$3 >> 2] = $4;
  sqlite3NestedParse($0, 27292, $3);
  sqlite3ChangeCookie($0, $5);
  sqlite3VdbeAddOp4($2, 154, $5, 0, 0, HEAP32[$1 >> 2], 0);
 }
 __stack_pointer = $3 + 16 | 0;
}

function fts3EvalStartReaders($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (!(HEAP32[$2 >> 2] | !$1)) {
   if (HEAP32[$1 >> 2] == 5) {
    $5 = HEAP32[$1 + 20 >> 2];
    $4 = HEAP32[$5 + 64 >> 2];
    if (!$4) {
     break label$1;
    }
    $6 = ($4 | 0) > 0 ? $4 : 0;
    while (1) {
     label$5: {
      if (($3 | 0) != ($6 | 0)) {
       if (HEAP32[(Math_imul($3, 24) + $5 | 0) + 88 >> 2]) {
        break label$5;
       }
       $6 = $3;
      }
      HEAP8[$1 + 34 | 0] = ($4 | 0) == ($6 | 0);
      break label$1;
     }
     $3 = $3 + 1 | 0;
     continue;
    }
   }
   fts3EvalStartReaders($0, HEAP32[$1 + 12 >> 2], $2);
   fts3EvalStartReaders($0, HEAP32[$1 + 16 >> 2], $2);
   $3 = HEAPU8[HEAP32[$1 + 12 >> 2] + 34 | 0] ? HEAPU8[HEAP32[$1 + 16 >> 2] + 34 | 0] != 0 : 0;
   HEAP8[$1 + 34 | 0] = $3;
  }
  return;
 }
 HEAP32[$2 >> 2] = fts3EvalPhraseStart($0, 1, $5);
}

function sin($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $2 = $2 & 2147483647;
 label$1: {
  if ($2 >>> 0 <= 1072243195) {
   if ($2 >>> 0 < 1045430272) {
    break label$1;
   }
   $0 = __sin($0, 0, 0);
   break label$1;
  }
  if ($2 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   break label$1;
  }
  label$4: {
   switch (__rem_pio2($0, $1) & 3) {
   case 0:
    $0 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;

   case 1:
    $0 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;

   case 2:
    $0 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;

   default:
    break label$4;
   }
  }
  $0 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function sqlite3IsLikeFunction($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = HEAP32[$1 + 20 >> 2];
 if (!$5) {
  return 0;
 }
 $5 = HEAP32[$5 >> 2];
 $0 = sqlite3FindFunction($0, HEAP32[$1 + 8 >> 2], $5, 1, 0);
 label$2: {
  if (!$0 | !(HEAPU8[$0 + 4 | 0] & 4)) {
   break label$2;
  }
  $4 = HEAP32[$0 + 8 >> 2];
  $7 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8;
  HEAP8[$3 | 0] = $7;
  HEAP8[$3 + 1 | 0] = $7 >>> 8;
  HEAP8[$3 + 2 | 0] = HEAPU8[$4 + 2 | 0];
  if (($5 | 0) >= 3) {
   $4 = 0;
   $1 = HEAP32[HEAP32[$1 + 20 >> 2] + 40 >> 2];
   if (HEAPU8[$1 | 0] != 117) {
    break label$2;
   }
   $1 = HEAP32[$1 + 8 >> 2];
   $6 = HEAPU8[$1 | 0];
   if (!$6 | HEAPU8[$1 + 1 | 0] | (HEAPU8[$3 | 0] == ($6 | 0) | HEAPU8[$3 + 1 | 0] == ($6 | 0))) {
    break label$2;
   }
  }
  HEAP8[$3 + 3 | 0] = $6;
  $4 = 1;
  HEAP32[$2 >> 2] = (HEAP32[$0 + 4 >> 2] ^ -1) >>> 3 & 1;
 }
 return $4;
}

function sqlite3ExprColUsed($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $1 = HEAP16[$0 + 32 >> 1];
 $0 = HEAP32[$0 + 44 >> 2];
 if (!(!(HEAPU8[$0 + 28 | 0] & 96) | !(HEAPU8[(HEAP32[$0 + 4 >> 2] + Math_imul($1, 12) | 0) + 10 | 0] & 96))) {
  $1 = HEAP16[$0 + 34 >> 1];
  $4 = $1 >> 31;
  $3 = $1;
  $5 = $4;
  $2 = $3 & 31;
  if (($3 & 63) >>> 0 >= 32) {
   $1 = -1 << $2;
   $4 = 0;
  } else {
   $1 = (1 << $2) - 1 & -1 >>> 32 - $2 | -1 << $2;
   $4 = -1 << $2;
  }
  $0 = $1 ^ -1;
  $6 = $0;
  $1 = $3;
  $0 = $5;
  $2 = $1 >>> 0 > 63 & ($0 | 0) >= 0 | ($0 | 0) > 0;
  $4 = $2 ? -1 : $4 ^ -1;
  $0 = $6;
  $3 = $2 ? -1 : $0;
  i64toi32_i32$HIGH_BITS = $3;
  return $4;
 }
 $1 = ($1 | 0) < 63 ? $1 : 63;
 $0 = $1 & 31;
 if (($1 & 63) >>> 0 >= 32) {
  $3 = 1 << $0;
  $2 = 0;
 } else {
  $3 = (1 << $0) - 1 & 1 >>> 32 - $0;
  $2 = 1 << $0;
 }
 i64toi32_i32$HIGH_BITS = $3;
 return $2;
}

function sqlite3AddReturning($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAP32[$0 >> 2];
 if (HEAP32[$0 + 244 >> 2]) {
  sqlite3ErrorMsg($0, 8914, 0);
 }
 HEAP8[$0 + 149 | 0] = 1;
 $2 = sqlite3DbMallocZero($3, 104, 0);
 if (!$2) {
  sqlite3ExprListDelete($3, $1);
  return;
 }
 HEAP32[$0 + 132 >> 2] = $2;
 HEAP32[$2 + 4 >> 2] = $1;
 HEAP32[$2 >> 2] = $0;
 sqlite3ParserAddCleanup($0, 35, $2);
 label$3: {
  if (HEAPU8[$3 + 87 | 0]) {
   break label$3;
  }
  HEAP32[$2 + 8 >> 2] = 11950;
  HEAP8[$2 + 18 | 0] = 1;
  HEAP16[$2 + 16 >> 1] = 662;
  $0 = HEAP32[HEAP32[$3 + 16 >> 2] + 28 >> 2];
  HEAP32[$2 + 68 >> 2] = $1;
  $1 = $2 + 8 | 0;
  HEAP32[$2 + 48 >> 2] = $1;
  HEAP8[$2 + 44 | 0] = 150;
  HEAP32[$2 + 36 >> 2] = $2 + 44;
  HEAP32[$2 + 32 >> 2] = $0;
  HEAP32[$2 + 28 >> 2] = $0;
  if ((sqlite3HashInsert($0 + 40 | 0, 11950, $1) | 0) != ($1 | 0)) {
   break label$3;
  }
  sqlite3OomFault($3);
 }
}

function sqlite3ExprCanBeNull($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  while (1) {
   label$3: {
    label$4: {
     $1 = HEAPU8[$0 | 0];
     switch ($1 - 173 | 0) {
     case 3:
      break label$3;

     case 0:
     case 1:
      break label$4;

     default:
      break label$1;
     }
    }
    $0 = HEAP32[$0 + 12 >> 2];
    continue;
   }
   break;
  }
  $1 = HEAPU8[$0 + 2 | 0];
 }
 $1 = $1 & 255;
 label$5: {
  if ($1 - 153 >>> 0 < 3 | ($1 | 0) == 117) {
   break label$5;
  }
  if (($1 | 0) == 167) {
   $2 = 1;
   if (HEAPU8[$0 + 6 | 0] & 32) {
    break label$5;
   }
   $1 = HEAP32[$0 + 44 >> 2];
   if (!$1) {
    break label$5;
   }
   $2 = 0;
   $0 = HEAP16[$0 + 32 >> 1];
   if (($0 | 0) < 0) {
    break label$5;
   }
   $1 = HEAP32[$1 + 4 >> 2];
   if (!$1) {
    break label$5;
   }
   return !(HEAPU8[(Math_imul($0, 12) + $1 | 0) + 4 | 0] & 15);
  }
  $2 = 1;
 }
 return $2;
}

function btreeInitPage($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP32[$0 + 52 >> 2];
 $1 = HEAP32[$0 + 56 >> 2] + HEAPU8[$0 + 9 | 0] | 0;
 if (decodeFlags($0, HEAPU8[$1 | 0])) {
  return sqlite3CorruptError(68961);
 }
 $2 = HEAP32[$4 + 36 >> 2];
 HEAP8[$0 + 12 | 0] = 0;
 HEAP16[$0 + 26 >> 1] = $2 - 1;
 $3 = HEAPU8[$0 + 10 | 0];
 $5 = HEAP32[$0 + 56 >> 2];
 HEAP32[$0 + 68 >> 2] = $3 + $5;
 HEAP32[$0 + 60 >> 2] = $2 + $5;
 HEAP32[$0 + 64 >> 2] = ($1 + $3 | 0) + 8;
 HEAP16[$0 + 18 >> 1] = (HEAPU8[$0 + 9 | 0] + $3 | 0) + 8;
 $1 = HEAPU8[$1 + 3 | 0] | HEAPU8[$1 + 4 | 0] << 8;
 $1 = $1 << 8 | $1 >>> 8;
 HEAP16[$0 + 24 >> 1] = $1;
 if (($2 - 8 >>> 0) / 6 >>> 0 < ($1 & 65535) >>> 0) {
  return sqlite3CorruptError(68975);
 }
 HEAP8[$0 | 0] = 1;
 HEAP32[$0 + 20 >> 2] = -1;
 if (HEAPU8[HEAP32[$4 + 4 >> 2] + 34 | 0] & 32) {
  $6 = btreeCellSizeCheck($0);
 }
 return $6;
}

function unixFileLock($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer + -64 | 0;
 __stack_pointer = $2;
 label$1: {
  if ((HEAPU16[$0 + 18 >> 1] & 3) == 1) {
   $1 = 0;
   $3 = HEAP32[$0 + 8 >> 2];
   if (HEAPU8[$3 + 29 | 0]) {
    break label$1;
   }
   HEAP32[$2 + 48 >> 2] = 510;
   HEAP32[$2 + 52 >> 2] = 0;
   HEAP32[$2 + 32 >> 2] = 1;
   $1 = HEAP32[16232] + 2 | 0;
   $4 = $1 >> 31;
   HEAP32[$2 + 40 >> 2] = $1;
   HEAP32[$2 + 44 >> 2] = $4;
   $0 = HEAP32[$0 + 12 >> 2];
   HEAP32[$2 >> 2] = $2 + 32;
   $1 = FUNCTION_TABLE[HEAP32[16258]]($0, 6, $2) | 0;
   if (($1 | 0) < 0) {
    break label$1;
   }
   HEAP8[$3 + 29 | 0] = 1;
   HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] + 1;
   break label$1;
  }
  $0 = HEAP32[$0 + 12 >> 2];
  HEAP32[$2 + 16 >> 2] = $1;
  $1 = FUNCTION_TABLE[HEAP32[16258]]($0, 6, $2 + 16 | 0) | 0;
 }
 __stack_pointer = $2 - -64 | 0;
 return $1;
}

function translateColumnToCopy($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 label$1: {
  if (HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
   break label$1;
  }
  $0 = HEAP32[$0 + 8 >> 2];
  $5 = sqlite3VdbeCurrentAddr($0);
  $5 = ($1 | 0) < ($5 | 0) ? $5 : $1;
  $0 = sqlite3VdbeGetOp($0, $1);
  while (1) {
   if (($1 | 0) == ($5 | 0)) {
    break label$1;
   }
   label$3: {
    if (HEAP32[$0 + 4 >> 2] != ($2 | 0)) {
     break label$3;
    }
    $6 = HEAPU8[$0 | 0];
    if (($6 | 0) != 135) {
     if (($6 | 0) != 94) {
      break label$3;
     }
     HEAP8[$0 | 0] = 80;
     HEAP16[$0 + 2 >> 1] = 2;
     $6 = HEAP32[$0 + 8 >> 2];
     HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = 0;
     HEAP32[$0 + 4 >> 2] = $3 + $6;
     break label$3;
    }
    HEAP32[$0 + 4 >> 2] = $4;
    HEAP8[$0 | 0] = 126;
   }
   $0 = $0 + 20 | 0;
   $1 = $1 + 1 | 0;
   continue;
  }
 }
}

function sqlite3VListAdd($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $7 = (($3 | 0) / 4 | 0) + 3 | 0;
 label$1: {
  if ($1) {
   $5 = HEAP32[$1 + 4 >> 2];
   $8 = $5 + $7 | 0;
   $6 = HEAP32[$1 >> 2];
   if (($8 | 0) <= ($6 | 0)) {
    $0 = $1;
    break label$1;
   }
   $5 = $6 << 1;
   $8 = $6 >> 31 << 1 | $6 >>> 31;
  } else {
   $5 = 10;
   $8 = 0;
  }
  $6 = $7 >> 31;
  $6 = $6 + $8 | 0;
  $5 = $7 + $5 | 0;
  $6 = $7 >>> 0 > $5 >>> 0 ? $6 + 1 | 0 : $6;
  $0 = sqlite3DbRealloc($0, $1, $5 << 2, $6 << 2 | $5 >>> 30);
  if (!$0) {
   return $1;
  }
  if ($1) {
   $1 = HEAP32[$0 + 4 >> 2];
  } else {
   HEAP32[$0 + 4 >> 2] = 2;
   $1 = 2;
  }
  HEAP32[$0 >> 2] = $5;
  $5 = $1;
  $8 = $5 + $7 | 0;
 }
 $1 = ($5 << 2) + $0 | 0;
 HEAP32[$1 >> 2] = $4;
 HEAP32[$1 + 4 >> 2] = $7;
 HEAP32[$0 + 4 >> 2] = $8;
 HEAP8[__memcpy($1 + 8 | 0, $2, $3) + $3 | 0] = 0;
 return $0;
}

function floorFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 if (($1 | 0) == 1) {
  label$2: {
   switch (sqlite3_value_type(HEAP32[$2 >> 2]) - 1 | 0) {
   case 0:
    $2 = sqlite3_value_int64(HEAP32[$2 >> 2]);
    $1 = i64toi32_i32$HIGH_BITS;
    sqlite3_result_int64($0, $2, $1);
    return;

   case 4:
    sqlite3_result_null($0);
    return;

   default:
    break label$2;
   }
  }
  $3 = Math_floor(sqlite3_value_double(HEAP32[$2 >> 2]));
  label$5: {
   if (Math_abs($3) < 0x8000000000000000) {
    $1 = Math_abs($3) >= 1 ? ~~($3 > 0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $4 = ~~$3 >>> 0;
    break label$5;
   }
   $1 = -2147483648;
  }
  sqlite3_result_int64($0, $4, $1);
  return;
 }
 __assert_fail(23175, 17353, 645, 17055);
 abort();
}

function explainAppendTerm($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 if ($4) {
  sqlite3_str_append($0, 29468, 5);
 }
 if (($2 | 0) >= 2) {
  sqlite3_str_append($0, 26931, 1);
 }
 $4 = 0;
 $6 = ($2 | 0) > 0 ? $2 : 0;
 while (1) {
  if (($4 | 0) != ($6 | 0)) {
   if ($4) {
    sqlite3_str_append($0, 24271, 1);
   }
   sqlite3_str_appendall($0, explainIndexColumnName($1, $3 + $4 | 0));
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 label$6: {
  if (($2 | 0) >= 2) {
   sqlite3_str_append($0, 26910, 1);
   sqlite3_str_append($0, $5, 1);
   sqlite3_str_append($0, 26931, 1);
   break label$6;
  }
  sqlite3_str_append($0, $5, 1);
 }
 $4 = 0;
 while (1) {
  if (($4 | 0) != ($6 | 0)) {
   if ($4) {
    sqlite3_str_append($0, 24271, 1);
   }
   sqlite3_str_append($0, 21197, 1);
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 if (($2 | 0) >= 2) {
  sqlite3_str_append($0, 26910, 1);
 }
}

function ceilFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 if (($1 | 0) == 1) {
  label$2: {
   switch (sqlite3_value_type(HEAP32[$2 >> 2]) - 1 | 0) {
   case 0:
    $2 = sqlite3_value_int64(HEAP32[$2 >> 2]);
    $1 = i64toi32_i32$HIGH_BITS;
    sqlite3_result_int64($0, $2, $1);
    return;

   case 4:
    sqlite3_result_null($0);
    return;

   default:
    break label$2;
   }
  }
  $3 = Math_ceil(sqlite3_value_double(HEAP32[$2 >> 2]));
  label$5: {
   if (Math_abs($3) < 0x8000000000000000) {
    $1 = Math_abs($3) >= 1 ? ~~($3 > 0 ? Math_min(Math_floor($3 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($3 - +(~~$3 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $4 = ~~$3 >>> 0;
    break label$5;
   }
   $1 = -2147483648;
  }
  sqlite3_result_int64($0, $4, $1);
  return;
 }
 __assert_fail(23175, 17353, 620, 17144);
 abort();
}

function subjournalPage($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = HEAP32[$0 + 20 >> 2];
 label$1: {
  if (HEAPU8[$2 + 5 | 0] != 2) {
   $1 = openSubJournal($2);
   if ($1) {
    break label$1;
   }
   $5 = HEAP32[$0 + 4 >> 2];
   $6 = HEAP32[$2 + 72 >> 2];
   $4 = HEAP32[$2 + 168 >> 2];
   $3 = HEAP32[$2 + 172 >> 2];
   $1 = $4 + 4 | 0;
   $3 = $1 >>> 0 < 4 ? $3 + 1 | 0 : $3;
   $4 = __wasm_i64_mul(HEAP32[$2 + 56 >> 2], 0, $1, $3);
   $3 = i64toi32_i32$HIGH_BITS;
   $1 = write32bits($6, $4, $3, HEAP32[$0 + 24 >> 2]);
   if ($1) {
    break label$1;
   }
   $4 = $4 + 4 | 0;
   $1 = $4 >>> 0 < 4 ? $3 + 1 | 0 : $3;
   $1 = sqlite3OsWrite(HEAP32[$2 + 72 >> 2], $5, HEAP32[$2 + 168 >> 2], $4, $1);
   if ($1) {
    break label$1;
   }
  }
  HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] + 1;
  $1 = addToSavepointBitvecs($2, HEAP32[$0 + 24 >> 2]);
 }
 return $1;
}

function clearSelect($0, $1, $2) {
 var $3 = 0, $4 = 0;
 while (1) {
  $3 = $1;
  if ($3) {
   $4 = $2;
   $1 = HEAP32[$3 + 52 >> 2];
   sqlite3ExprListDelete($0, HEAP32[$3 + 28 >> 2]);
   sqlite3SrcListDelete($0, HEAP32[$3 + 32 >> 2]);
   sqlite3ExprDelete($0, HEAP32[$3 + 36 >> 2]);
   sqlite3ExprListDelete($0, HEAP32[$3 + 40 >> 2]);
   sqlite3ExprDelete($0, HEAP32[$3 + 44 >> 2]);
   sqlite3ExprListDelete($0, HEAP32[$3 + 48 >> 2]);
   sqlite3ExprDelete($0, HEAP32[$3 + 60 >> 2]);
   $2 = HEAP32[$3 + 64 >> 2];
   if ($2) {
    sqlite3WithDelete($0, $2);
   }
   $2 = HEAP32[$3 + 72 >> 2];
   if ($2) {
    sqlite3WindowListDelete($0, $2);
   }
   while (1) {
    $2 = HEAP32[$3 + 68 >> 2];
    if ($2) {
     sqlite3WindowUnlinkFromSelect($2);
     continue;
    }
    break;
   }
   $2 = 1;
   if (!$4) {
    continue;
   }
   sqlite3DbFreeNN($0, $3);
   continue;
  }
  break;
 }
}

function jsonRemoveFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 label$1: {
  if (($1 | 0) <= 0) {
   break label$1;
  }
  if (jsonParse($3, $0, sqlite3_value_text(HEAP32[$2 >> 2]))) {
   break label$1;
  }
  $4 = 1;
  label$2: {
   while (1) {
    if (($1 | 0) != ($4 | 0)) {
     $5 = sqlite3_value_text(HEAP32[($4 << 2) + $2 >> 2]);
     if (!$5) {
      break label$2;
     }
     $5 = jsonLookup($3, $5, 0, $0);
     if (HEAPU8[$3 + 21 | 0]) {
      break label$2;
     }
     if ($5) {
      HEAP8[$5 + 1 | 0] = HEAPU8[$5 + 1 | 0] | 4;
     }
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   }
   $4 = HEAP32[$3 + 8 >> 2];
   if (HEAPU8[$4 + 1 | 0] & 4) {
    break label$2;
   }
   jsonReturnJson($4, $0, 0);
  }
  jsonParseReset($3);
 }
 __stack_pointer = $3 + 32 | 0;
}

function zeroPage($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = HEAPU8[$0 + 9 | 0];
 $4 = HEAP32[$0 + 56 >> 2];
 $3 = HEAP32[$0 + 52 >> 2];
 if (HEAPU8[$3 + 24 | 0] & 12) {
  memset($4 + $5 | 0, 0, HEAP32[$3 + 40 >> 2] - $5 | 0);
 }
 $2 = $4 + $5 | 0;
 HEAP8[$2 | 0] = $1;
 HEAP8[$2 + 7 | 0] = 0;
 HEAP8[$2 + 1 | 0] = 0;
 HEAP8[$2 + 2 | 0] = 0;
 HEAP8[$2 + 3 | 0] = 0;
 HEAP8[$2 + 4 | 0] = 0;
 HEAP8[$2 + 5 | 0] = HEAP32[$3 + 40 >> 2] >>> 8;
 HEAP8[$2 + 6 | 0] = HEAP32[$3 + 40 >> 2];
 $2 = ($1 & 8 ? 8 : 12) + $5 | 0;
 HEAP32[$0 + 20 >> 2] = HEAP32[$3 + 40 >> 2] - $2 & 65535;
 decodeFlags($0, $1);
 HEAP16[$0 + 18 >> 1] = $2;
 $3 = HEAP32[$3 + 36 >> 2];
 HEAP32[$0 + 64 >> 2] = $2 + $4;
 HEAP32[$0 + 68 >> 2] = HEAPU8[$0 + 10 | 0] + $4;
 HEAP8[$0 + 12 | 0] = 0;
 HEAP16[$0 + 24 >> 1] = 0;
 HEAP8[$0 | 0] = 1;
 HEAP32[$0 + 60 >> 2] = $3 + $4;
 HEAP16[$0 + 26 >> 1] = $3 - 1;
}

function fts3SyncMethod($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $4 = sqlite3_last_insert_rowid(HEAP32[$0 + 12 >> 2]);
 $5 = i64toi32_i32$HIGH_BITS;
 $3 = sqlite3Fts3PendingTermsFlush($0);
 label$1: {
  if ($3) {
   break label$1;
  }
  $3 = 0;
  if (HEAPU32[$0 + 52 >> 2] < 5) {
   break label$1;
  }
  $1 = HEAP32[$0 + 48 >> 2];
  if (!$1 | ($1 | 0) == 255) {
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
  $3 = sqlite3Fts3MaxLevel($0, $2 + 12 | 0);
  $1 = Math_imul(HEAP32[$2 + 12 >> 2], HEAP32[$0 + 52 >> 2]);
  $1 = $1 + (($1 | 0) / 2 | 0) | 0;
  if (($1 | 0) < 65) {
   break label$1;
  }
  $3 = sqlite3Fts3Incrmerge($0, $1, HEAP32[$0 + 48 >> 2]);
 }
 sqlite3Fts3SegmentsClose($0);
 sqlite3_set_last_insert_rowid(HEAP32[$0 + 12 >> 2], $4, $5);
 __stack_pointer = $2 + 16 | 0;
 return $3 | 0;
}

function btreeParseCellPtrIndex($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = HEAPU8[$0 + 10 | 0] + $1 | 0;
 $3 = HEAP8[$6 | 0];
 $4 = $3 & 255;
 label$1: {
  if (($3 | 0) >= 0) {
   $7 = $6;
   break label$1;
  }
  $4 = $4 & 127;
  $3 = 0;
  while (1) {
   $8 = $3 + 1 | 0;
   $7 = $8 + $6 | 0;
   $5 = HEAP8[$7 | 0];
   $4 = $5 & 127 | $4 << 7;
   if (($5 | 0) >= 0) {
    break label$1;
   }
   $5 = $3 >>> 0 < 7;
   $3 = $8;
   if ($5) {
    continue;
   }
   break;
  }
 }
 HEAP32[$2 + 12 >> 2] = $4;
 HEAP32[$2 >> 2] = $4;
 HEAP32[$2 + 4 >> 2] = 0;
 $3 = $7 + 1 | 0;
 HEAP32[$2 + 8 >> 2] = $3;
 if (HEAPU16[$0 + 14 >> 1] >= $4 >>> 0) {
  HEAP16[$2 + 16 >> 1] = $4;
  $3 = ($3 - $1 | 0) + $4 | 0;
  HEAP16[$2 + 18 >> 1] = $3 & 65532 ? $3 : 4;
  return;
 }
 btreeParseCellAdjustSizeForOverflow($0, $1, $2);
}

function walIteratorNext($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = HEAP32[$0 + 4 >> 2];
 $9 = HEAP32[$0 >> 2];
 $4 = -1;
 label$1: while (1) {
  if (($6 | 0) > 0) {
   $6 = $6 - 1 | 0;
   $3 = Math_imul($6, 20) + $0 | 0;
   $5 = HEAP32[$3 + 8 >> 2];
   $10 = HEAP32[$3 + 20 >> 2];
   while (1) {
    if (($5 | 0) >= ($10 | 0)) {
     continue label$1;
    }
    $8 = HEAPU16[HEAP32[$3 + 12 >> 2] + ($5 << 1) >> 1];
    $7 = HEAP32[HEAP32[$3 + 16 >> 2] + ($8 << 2) >> 2];
    if ($9 >>> 0 < $7 >>> 0) {
     if ($4 >>> 0 <= $7 >>> 0) {
      continue label$1;
     }
     HEAP32[$2 >> 2] = HEAP32[$3 + 24 >> 2] + $8;
     $4 = $7;
     continue label$1;
    } else {
     $5 = $5 + 1 | 0;
     HEAP32[$3 + 8 >> 2] = $5;
     continue;
    }
   }
  }
  break;
 }
 HEAP32[$0 >> 2] = $4;
 HEAP32[$1 >> 2] = $4;
 return ($4 | 0) == -1;
}

function sqlite3_bind_value($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  switch (sqlite3_value_type($2) - 1 | 0) {
  case 0:
   $3 = HEAP32[$2 >> 2];
   $4 = HEAP32[$2 + 4 >> 2];
   return sqlite3_bind_int64($0, $1, $3, $4);

  case 1:
   if (HEAPU8[$2 + 16 | 0] & 8) {
    $5 = HEAPF64[$2 >> 3];
   } else {
    $4 = HEAP32[$2 >> 2];
    $3 = HEAP32[$2 + 4 >> 2];
    $5 = +($4 >>> 0) + +($3 | 0) * 4294967296;
   }
   return sqlite3_bind_double($0, $1, $5);

  case 3:
   if (HEAPU8[$2 + 17 | 0] & 4) {
    return sqlite3_bind_zeroblob($0, $1, HEAP32[$2 >> 2]);
   }
   return sqlite3_bind_blob($0, $1, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2], -1);

  case 2:
   $3 = HEAP32[$2 + 12 >> 2];
   $4 = $3 >> 31;
   return bindText($0, $1, HEAP32[$2 + 8 >> 2], $3, $4, -1, HEAPU8[$2 + 18 | 0]);

  default:
   break label$1;
  }
 }
 return sqlite3_bind_null($0, $1);
}

function sqlite3MatchEName($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (((HEAPU8[$0 + 9 | 0] | HEAPU8[$0 + 10 | 0] << 8) & 3) != 2) {
   break label$1;
  }
  $5 = HEAP32[$0 + 4 >> 2];
  $0 = 0;
  while (1) {
   $6 = $0 + $5 | 0;
   $4 = HEAPU8[$6 | 0];
   if (!(!$4 | ($4 | 0) == 46)) {
    $0 = $0 + 1 | 0;
    continue;
   }
   break;
  }
  if ($3) {
   $4 = 0;
   if (sqlite3_strnicmp($5, $3, $0) | HEAPU8[$0 + $3 | 0]) {
    break label$1;
   }
  }
  $5 = $6 + 1 | 0;
  $0 = 0;
  while (1) {
   $6 = $0 + $5 | 0;
   $4 = HEAPU8[$6 | 0];
   if (!(!$4 | ($4 | 0) == 46)) {
    $0 = $0 + 1 | 0;
    continue;
   }
   break;
  }
  if ($2) {
   $4 = 0;
   if (sqlite3_strnicmp($5, $2, $0) | HEAPU8[$0 + $2 | 0]) {
    break label$1;
   }
  }
  if ($1) {
   $4 = 0;
   if (sqlite3StrICmp($6 + 1 | 0, $1)) {
    break label$1;
   }
  }
  $4 = 1;
 }
 return $4;
}

function sqlite3TriggerList($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = HEAP32[HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + 28 >> 2];
 $0 = $5 + 48 | 0;
 $4 = HEAP32[$1 + 56 >> 2];
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if ($0) {
   $2 = HEAP32[$0 + 8 >> 2];
   $3 = HEAP32[$2 + 24 >> 2];
   $6 = HEAP32[$1 + 60 >> 2];
   label$3: {
    label$4: {
     if (($3 | 0) != ($6 | 0)) {
      break label$4;
     }
     $7 = HEAP32[$2 + 4 >> 2];
     if (!$7) {
      break label$4;
     }
     if (sqlite3StrICmp($7, HEAP32[$1 >> 2])) {
      break label$4;
     }
     if (($3 | 0) != ($5 | 0)) {
      break label$3;
     }
    }
    if (HEAPU8[$2 + 8 | 0] != 150) {
     continue;
    }
    $3 = HEAP32[$1 >> 2];
    HEAP32[$2 + 24 >> 2] = $6;
    HEAP32[$2 + 4 >> 2] = $3;
   }
   HEAP32[$2 + 32 >> 2] = $4;
   $4 = $2;
   continue;
  }
  break;
 }
 return $4;
}

function memdbClose($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if (!HEAP32[$1 + 52 >> 2]) {
   break label$1;
  }
  $0 = 0;
  $3 = HEAP32[17717];
  $5 = ($3 | 0) > 0 ? $3 : 0;
  $4 = HEAP32[17718];
  while (1) {
   if (($0 | 0) == ($5 | 0)) {
    break label$1;
   }
   $2 = $0 << 2;
   $0 = $0 + 1 | 0;
   $2 = $4 + $2 | 0;
   if (HEAP32[$2 >> 2] != ($1 | 0)) {
    continue;
   }
   break;
  }
  if (HEAP32[$1 + 48 >> 2] != 1) {
   break label$1;
  }
  $0 = $3 - 1 | 0;
  HEAP32[17717] = $0;
  HEAP32[$2 >> 2] = HEAP32[($0 << 2) + $4 >> 2];
  if ($0) {
   break label$1;
  }
  sqlite3_free($4);
  HEAP32[17718] = 0;
 }
 $0 = HEAP32[$1 + 48 >> 2];
 HEAP32[$1 + 48 >> 2] = $0 - 1;
 if (($0 | 0) <= 1) {
  if (HEAP8[$1 + 36 | 0] & 1) {
   sqlite3_free(HEAP32[$1 + 24 >> 2]);
  }
  sqlite3_free($1);
 }
 return 0;
}

function fts3EvalRestart($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 while (1) {
  if (!(HEAP32[$2 >> 2] | !$1)) {
   $3 = HEAP32[$1 + 20 >> 2];
   if ($3) {
    fts3EvalInvalidatePoslist($3);
    if (HEAP32[$3 + 40 >> 2]) {
     $4 = 0;
     while (1) {
      if (HEAP32[$3 + 64 >> 2] > ($4 | 0)) {
       $5 = HEAP32[(Math_imul($4, 24) + $3 | 0) + 92 >> 2];
       if ($5) {
        sqlite3Fts3MsrIncrRestart($5);
       }
       $4 = $4 + 1 | 0;
       continue;
      }
      break;
     }
     HEAP32[$2 >> 2] = fts3EvalPhraseStart($0, 0, $3);
    }
    HEAP32[$3 + 48 >> 2] = 0;
    HEAP32[$3 + 16 >> 2] = 0;
    HEAP32[$3 + 20 >> 2] = 0;
    HEAP32[$3 + 8 >> 2] = 0;
   }
   HEAP16[$1 + 32 >> 1] = 0;
   HEAP32[$1 + 24 >> 2] = 0;
   HEAP32[$1 + 28 >> 2] = 0;
   fts3EvalRestart($0, HEAP32[$1 + 12 >> 2], $2);
   $1 = HEAP32[$1 + 16 >> 2];
   continue;
  }
  break;
 }
}

function sqlite3VdbeMemCast($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAPU16[$0 + 16 >> 1];
 label$1: {
  if ($3 & 1) {
   break label$1;
  }
  label$2: {
   switch ($1 - 65 | 0) {
   case 0:
    if (!($3 & 16)) {
     sqlite3ValueApplyAffinity($0, 66, $2);
     $1 = HEAPU16[$0 + 16 >> 1];
     if (!($1 & 2)) {
      break label$1;
     }
     HEAP16[$0 + 16 >> 1] = $1 & 62016 | 16;
     return 0;
    }
    HEAP16[$0 + 16 >> 1] = $3 & 62032;
    return 0;

   case 2:
    sqlite3VdbeMemNumerify($0);
    return 0;

   case 3:
    sqlite3VdbeMemIntegerify($0);
    return 0;

   case 4:
    sqlite3VdbeMemRealify($0);
    return 0;

   default:
    break label$2;
   }
  }
  HEAP16[$0 + 16 >> 1] = $3 >>> 3 & 2 | $3;
  sqlite3ValueApplyAffinity($0, 66, $2);
  HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 64451;
  $4 = sqlite3VdbeChangeEncoding($0, $2);
 }
 return $4;
}

function fts3PoslistNearMerge($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 12 >> 2] = $1;
 $7 = HEAP32[$5 >> 2];
 $8 = HEAP32[$4 >> 2];
 HEAP32[$6 + 8 >> 2] = $1;
 fts3PoslistPhraseMerge($6 + 8 | 0, $2, 0, 0, $4, $5);
 $2 = HEAP32[$6 + 8 >> 2];
 HEAP32[$6 + 4 >> 2] = $2;
 HEAP32[$6 >> 2] = $2;
 HEAP32[$4 >> 2] = $8;
 HEAP32[$5 >> 2] = $7;
 fts3PoslistPhraseMerge($6 + 4 | 0, $3, 1, 0, $5, $4);
 $5 = HEAP32[$6 + 4 >> 2];
 label$1: {
  label$2: {
   if (($1 | 0) != ($2 | 0)) {
    if (($2 | 0) != ($5 | 0)) {
     fts3PoslistMerge($0, $6 + 12 | 0, $6);
     break label$2;
    }
    fts3PoslistCopy($0, $6 + 12 | 0);
    break label$2;
   }
   if (($1 | 0) == ($5 | 0)) {
    break label$1;
   }
   fts3PoslistCopy($0, $6);
  }
  $9 = 1;
 }
 __stack_pointer = $6 + 16 | 0;
 return $9;
}

function rowSetEntrySort($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 160 | 0;
 __stack_pointer = $1;
 $3 = memset($1, 0, 160);
 while (1) {
  if ($0) {
   $5 = HEAP32[$0 + 8 >> 2];
   $1 = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   while (1) {
    $2 = ($1 << 2) + $3 | 0;
    $4 = HEAP32[$2 >> 2];
    if ($4) {
     $0 = rowSetEntryMerge($4, $0);
     HEAP32[$2 >> 2] = 0;
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   }
   HEAP32[$2 >> 2] = $0;
   $0 = $5;
   continue;
  }
  break;
 }
 $0 = HEAP32[$3 >> 2];
 $1 = 1;
 while (1) {
  if (($1 | 0) != 40) {
   $2 = HEAP32[($1 << 2) + $3 >> 2];
   label$7: {
    if (!$2) {
     break label$7;
    }
    if (!$0) {
     $0 = $2;
     break label$7;
    }
    $0 = rowSetEntryMerge($0, $2);
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 160 | 0;
 return $0;
}

function pagerStress($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 label$1: {
  if (HEAP32[$0 + 44 >> 2]) {
   break label$1;
  }
  $3 = HEAPU8[$0 + 21 | 0];
  if ($3 & 3 | HEAPU8[$1 + 28 | 0] & 8 ? $3 : 0) {
   break label$1;
  }
  $2 = $0 + 212 | 0;
  HEAP32[$2 >> 2] = HEAP32[$0 + 212 >> 2] + 1;
  HEAP32[$1 + 16 >> 2] = 0;
  label$3: {
   label$4: {
    if (HEAP32[$0 + 232 >> 2]) {
     $2 = subjournalPageIfRequired($1);
     if ($2) {
      break label$3;
     }
     $2 = pagerWalFrames($0, $1, 0, 0);
     break label$4;
    }
    if (!(!(HEAPU8[$1 + 28 | 0] & 8) & HEAPU8[$0 + 17 | 0] != 3)) {
     $2 = syncJournal($0, 1);
     if ($2) {
      break label$3;
     }
    }
    $2 = pager_write_pagelist($0, $1);
   }
   if ($2) {
    break label$3;
   }
   sqlite3PcacheMakeClean($1);
   $2 = 0;
  }
  $2 = pager_error($0, $2);
 }
 return $2 | 0;
}

function sqlite3OsCurrentTimeInt64($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  label$2: {
   if (HEAP32[$0 >> 2] < 2) {
    break label$2;
   }
   $3 = HEAP32[$0 + 72 >> 2];
   if (!$3) {
    break label$2;
   }
   $0 = FUNCTION_TABLE[$3 | 0]($0, $1) | 0;
   break label$1;
  }
  $0 = FUNCTION_TABLE[HEAP32[$0 + 64 >> 2]]($0, $4 + 8 | 0) | 0;
  $3 = $1;
  $2 = HEAPF64[$4 + 8 >> 3] * 864e5;
  label$3: {
   if (Math_abs($2) < 0x8000000000000000) {
    $1 = Math_abs($2) >= 1 ? ~~($2 > 0 ? Math_min(Math_floor($2 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($2 - +(~~$2 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $5 = ~~$2 >>> 0;
    break label$3;
   }
   $1 = -2147483648;
  }
  HEAP32[$3 >> 2] = $5;
  HEAP32[$3 + 4 >> 2] = $1;
 }
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function fts3MatchinfoCheck($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  label$2: {
   label$3: {
    $4 = $1 - 108 | 0;
    if ($4 >>> 0 > 13) {
     break label$3;
    }
    if (1 << $4 & 12432) {
     break label$1;
    }
    if ($4) {
     if (($4 | 0) != 2) {
      break label$3;
     }
     if (!HEAPU8[$0 + 236 | 0]) {
      break label$2;
     }
     break label$1;
    }
    if (HEAPU8[$0 + 238 | 0]) {
     break label$1;
    }
    break label$2;
   }
   label$5: {
    switch ($1 - 97 | 0) {
    case 1:
    case 2:
     break label$1;

    case 0:
     break label$5;

    default:
     break label$2;
    }
   }
   if (HEAPU8[$0 + 236 | 0]) {
    break label$1;
   }
  }
  HEAP32[$3 >> 2] = $1;
  sqlite3Fts3ErrMsg($2, 17479, $3);
  $5 = 1;
 }
 __stack_pointer = $3 + 16 | 0;
 return $5;
}

function jsonArrayCompute($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = sqlite3_aggregate_context($0, 0);
 label$1: {
  if ($2) {
   HEAP32[$2 >> 2] = $0;
   jsonAppendChar($2, 93);
   label$3: {
    switch (HEAPU8[$2 + 25 | 0]) {
    case 1:
     sqlite3_result_error_nomem($0);
     break label$1;

    case 0:
     break label$3;

    default:
     break label$1;
    }
   }
   $3 = HEAP32[$2 + 16 >> 2];
   $4 = HEAP32[$2 + 4 >> 2];
   if ($1) {
    sqlite3_result_text($0, $4, $3, HEAPU8[$2 + 24 | 0] ? -1 : 3);
    HEAP8[$2 + 24 | 0] = 1;
    break label$1;
   }
   sqlite3_result_text($0, $4, $3, -1);
   $1 = HEAP32[$2 + 16 >> 2];
   $3 = !$1;
   $3 = HEAP32[$2 + 20 >> 2] - $3 | 0;
   $1 = $1 - 1 | 0;
   HEAP32[$2 + 16 >> 2] = $1;
   HEAP32[$2 + 20 >> 2] = $3;
   break label$1;
  }
  sqlite3_result_text($0, 17886, 2, 0);
 }
 sqlite3_result_subtype($0, 74);
}

function sqlite3VtabCallDestroy($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $2 = sqlite3FindTable($0, $2, HEAP32[HEAP32[$0 + 16 >> 2] + ($1 << 4) >> 2]);
 label$1: {
  if (!$2 | HEAPU8[$2 + 43 | 0] != 1) {
   break label$1;
  }
  $1 = HEAP32[$2 + 52 >> 2];
  if (!$1) {
   break label$1;
  }
  while (1) {
   if ($1) {
    if (HEAP32[HEAP32[$1 + 8 >> 2] + 4 >> 2] > 0) {
     return 6;
    } else {
     $1 = HEAP32[$1 + 24 >> 2];
     continue;
    }
   }
   break;
  }
  $1 = vtabDisconnectAll($0, $2);
  $4 = HEAP32[HEAP32[$1 + 4 >> 2] >> 2];
  $3 = HEAP32[$4 + 20 >> 2];
  if (!$3) {
   $3 = HEAP32[$4 + 16 >> 2];
  }
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
  $3 = FUNCTION_TABLE[$3 | 0](HEAP32[$1 + 8 >> 2]) | 0;
  if (!$3) {
   HEAP32[$1 + 8 >> 2] = 0;
   HEAP32[$2 + 52 >> 2] = 0;
   sqlite3VtabUnlock($1);
  }
  sqlite3DeleteTable($0, $2);
 }
 return $3;
}

function sqlite3Fts3EvalPhraseStats($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $7 = HEAP32[$0 >> 2];
 label$1: {
  if (!(!HEAPU8[$1 + 34 | 0] | HEAP32[HEAP32[$1 + 8 >> 2] >> 2] == 1)) {
   while (1) {
    if (HEAP32[$7 + 24 >> 2] <= ($4 | 0)) {
     break label$1;
    }
    $3 = Math_imul($4, 12) + $2 | 0;
    $5 = HEAP32[$0 + 64 >> 2];
    HEAP32[$3 + 8 >> 2] = $5;
    HEAP32[$3 + 4 >> 2] = $5;
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  $6 = fts3EvalGatherStats($0, $1);
  if ($6) {
   break label$1;
  }
  $6 = 0;
  while (1) {
   if (HEAP32[$7 + 24 >> 2] <= ($4 | 0)) {
    break label$1;
   }
   $3 = Math_imul($4, 12);
   $5 = $3 + 4 | 0;
   $0 = HEAP32[$1 + 40 >> 2];
   HEAP32[$5 + $2 >> 2] = HEAP32[$5 + $0 >> 2];
   $3 = $3 + 8 | 0;
   HEAP32[$3 + $2 >> 2] = HEAP32[$0 + $3 >> 2];
   $4 = $4 + 1 | 0;
   continue;
  }
 }
 return $6;
}

function fts3auxColumnMethod($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 label$1: {
  label$2: {
   switch ($2 | 0) {
   case 0:
    sqlite3_result_text($1, HEAP32[$0 + 44 >> 2], HEAP32[$0 + 48 >> 2], -1);
    break label$1;

   case 1:
    $0 = HEAP32[$0 + 104 >> 2];
    if ($0) {
     sqlite3_result_int($1, $0 - 1 | 0);
     break label$1;
    }
    sqlite3_result_text($1, 24304, -1, 0);
    break label$1;

   case 2:
    $0 = HEAP32[$0 + 112 >> 2] + (HEAP32[$0 + 104 >> 2] << 4) | 0;
    sqlite3_result_int64($1, HEAP32[$0 >> 2], HEAP32[$0 + 4 >> 2]);
    break label$1;

   case 3:
    $0 = HEAP32[$0 + 112 >> 2] + (HEAP32[$0 + 104 >> 2] << 4) | 0;
    sqlite3_result_int64($1, HEAP32[$0 + 8 >> 2], HEAP32[$0 + 12 >> 2]);
    break label$1;

   default:
    break label$2;
   }
  }
  sqlite3_result_int($1, HEAP32[$0 + 84 >> 2]);
 }
 return 0;
}

function sqlite3PagerClose($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAP32[$0 + 224 >> 2];
 sqlite3BeginBenignMalloc();
 pagerFreeMapHdrs($0);
 HEAP8[$0 + 4 | 0] = 0;
 $2 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = 0;
  if (HEAPU8[$1 + 33 | 0] & 8) {
   break label$1;
  }
  $2 = databaseIsUnmoved($0) ? 0 : $3;
 }
 sqlite3WalClose(HEAP32[$0 + 232 >> 2], $1, HEAPU8[$0 + 11 | 0], HEAP32[$0 + 168 >> 2], $2);
 HEAP32[$0 + 232 >> 2] = 0;
 pager_reset($0);
 label$2: {
  if (HEAPU8[$0 + 15 | 0]) {
   pager_unlock($0);
   break label$2;
  }
  if (HEAP32[HEAP32[$0 + 68 >> 2] >> 2]) {
   pager_error($0, pagerSyncHotJournal($0));
  }
  pagerUnlockAndRollback($0);
 }
 sqlite3EndBenignMalloc();
 sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
 sqlite3OsClose(HEAP32[$0 + 64 >> 2]);
 sqlite3PageFree($3);
 sqlite3PcacheClose(HEAP32[$0 + 228 >> 2]);
 sqlite3_free($0);
}

function sqlite3PagerRollback($0) {
 var $1 = 0, $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $2 = HEAPU8[$0 + 17 | 0];
 if (($2 | 0) == 6) {
  return HEAP32[$0 + 44 >> 2];
 }
 if ($2 >>> 0 >= 2) {
  label$3: {
   if (HEAP32[$0 + 232 >> 2]) {
    $1 = sqlite3PagerSavepoint($0, 2, -1);
    $1 = (wasm2js_i32$0 = $1, wasm2js_i32$1 = pager_end_transaction($0, HEAPU8[$0 + 20 | 0], 0), 
    wasm2js_i32$2 = $1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
    break label$3;
   }
   if (!(($2 | 0) != 2 ? HEAP32[HEAP32[$0 + 68 >> 2] >> 2] : 0)) {
    $1 = pager_end_transaction($0, 0, 0);
    if (HEAPU8[$0 + 15 | 0] | $2 >>> 0 < 3) {
     break label$3;
    }
    HEAP8[$0 + 17 | 0] = 6;
    HEAP32[$0 + 44 >> 2] = 4;
    setGetterMethod($0);
    return $1;
   }
   $1 = pager_playback($0, 0);
  }
  $1 = pager_error($0, $1);
 }
 return $1;
}

function fts3ReadNextPos($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $2 = HEAP32[$0 >> 2];
 $4 = HEAPU8[$2 | 0];
 label$1: {
  if ($4 >>> 0 >= 2) {
   label$3: {
    if ($4 << 24 >> 24 < 0) {
     $3 = sqlite3Fts3GetVarint32($2, $5 + 12 | 0);
     $4 = HEAP32[$5 + 12 >> 2];
     break label$3;
    }
    $3 = 1;
   }
   HEAP32[$0 >> 2] = $2 + $3;
   $0 = HEAP32[$1 + 4 >> 2];
   $2 = $0;
   $0 = $4 >> 31;
   $3 = $0;
   $0 = $2;
   $3 = $3 + $0 | 0;
   $2 = $4 + HEAP32[$1 >> 2] | 0;
   $3 = $2 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
   $0 = $2;
   $2 = $0 >>> 0 < 2;
   $2 = $3 - $2 | 0;
   $3 = $0 - 2 | 0;
   $0 = $1;
   HEAP32[$0 >> 2] = $3;
   HEAP32[$0 + 4 >> 2] = $2;
   break label$1;
  }
  $0 = $1;
  HEAP32[$0 >> 2] = -1;
  HEAP32[$0 + 4 >> 2] = 2147483647;
 }
 __stack_pointer = $5 + 16 | 0;
}

function unixFullPathname($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $0 = __stack_pointer - 4128 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 4120 >> 2] = 0;
 HEAP32[$0 + 4104 >> 2] = 0;
 HEAP32[$0 + 4108 >> 2] = 0;
 HEAP32[$0 + 4116 >> 2] = $2;
 HEAP32[$0 + 4112 >> 2] = $3;
 label$1: {
  if (HEAPU8[$1 | 0] != 47) {
   if (!(FUNCTION_TABLE[HEAP32[16246]]($0, 4096) | 0)) {
    $1 = unixLogErrorAtLine(sqlite3CantopenError(42030), 14214, $1, 42030);
    break label$1;
   }
   appendAllPathElements($0 + 4104 | 0, $0);
  }
  appendAllPathElements($0 + 4104 | 0, $1);
  $1 = HEAP32[$0 + 4120 >> 2];
  HEAP8[$3 + $1 | 0] = 0;
  if (!(!HEAP32[$0 + 4104 >> 2] & ($1 | 0) > 1)) {
   $1 = sqlite3CantopenError(42036);
   break label$1;
  }
  $1 = (HEAP32[$0 + 4108 >> 2] != 0) << 9;
 }
 __stack_pointer = $0 + 4128 | 0;
 return $1 | 0;
}

function pragmaFunclistLine($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $7 = $3 ? -1 : 3934208;
 while (1) {
  if ($1) {
   label$3: {
    if (!HEAP32[$1 + 16 >> 2]) {
     break label$3;
    }
    $5 = HEAP32[$1 + 4 >> 2];
    if (!($5 & 262144 ? $3 : 1)) {
     break label$3;
    }
    $6 = 1829;
    $6 = HEAP32[$1 + 24 >> 2] ? $6 : HEAP32[$1 + 20 >> 2] ? 17749 : 8343;
    $8 = HEAP32[$1 + 32 >> 2];
    HEAP32[$4 + 16 >> 2] = HEAP8[$1 | 0];
    HEAP32[$4 + 20 >> 2] = $5 & $7 ^ 2097152;
    HEAP32[$4 + 8 >> 2] = $6;
    HEAP32[$4 + 4 >> 2] = $2;
    HEAP32[$4 >> 2] = $8;
    HEAP32[$4 + 12 >> 2] = HEAP32[(($5 & 3) << 2) + 49536 >> 2];
    sqlite3VdbeMultiLoad($0, 1, 11599, $4);
   }
   $1 = HEAP32[$1 + 12 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 32 | 0;
}

function sqlite3Fts3ExprParse($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0;
 $9 = __stack_pointer - 32 | 0;
 __stack_pointer = $9;
 $5 = fts3ExprParseUnbalanced($0, $1, $2, $3, $4, $5, $6, $7);
 label$1: {
  label$2: {
   if ($5) {
    break label$2;
   }
   $4 = 0;
   if (!HEAP32[$7 >> 2]) {
    break label$1;
   }
   $5 = fts3ExprBalance($7, 12);
   if ($5) {
    break label$2;
   }
   $5 = fts3ExprCheckDepth(HEAP32[$7 >> 2], 12);
   if (!$5) {
    break label$1;
   }
  }
  sqlite3Fts3ExprFree(HEAP32[$7 >> 2]);
  HEAP32[$7 >> 2] = 0;
  $4 = 1;
  if (($5 | 0) != 1) {
   $4 = $5;
   if (($5 | 0) != 18) {
    break label$1;
   }
   HEAP32[$9 >> 2] = 12;
   sqlite3Fts3ErrMsg($8, 24980, $9);
   $4 = 1;
   break label$1;
  }
  HEAP32[$9 + 16 >> 2] = $6;
  sqlite3Fts3ErrMsg($8, 17848, $9 + 16 | 0);
 }
 __stack_pointer = $9 + 32 | 0;
 return $4;
}

function unixCheckReservedLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 $5 = 1;
 $4 = HEAP32[$0 + 8 >> 2];
 $3 = 0;
 label$1: {
  if (HEAPU8[$4 + 28 | 0] > 1) {
   break label$1;
  }
  $5 = 0;
  $3 = 0;
  if (HEAPU8[$4 + 29 | 0]) {
   break label$1;
  }
  HEAP32[$2 + 32 >> 2] = 1;
  HEAP32[$2 + 36 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 1;
  $3 = HEAP32[16232] + 1 | 0;
  $4 = $3 >> 31;
  HEAP32[$2 + 24 >> 2] = $3;
  HEAP32[$2 + 28 >> 2] = $4;
  $3 = HEAP32[$0 + 12 >> 2];
  HEAP32[$2 >> 2] = $2 + 16;
  if (FUNCTION_TABLE[HEAP32[16258]]($3, 5, $2) | 0) {
   storeLastErrno($0, HEAP32[__errno_location() >> 2]);
   $3 = 3594;
   break label$1;
  }
  $5 = HEAPU16[$2 + 16 >> 1] != 2;
  $3 = 0;
 }
 HEAP32[$1 >> 2] = $5;
 __stack_pointer = $2 + 48 | 0;
 return $3 | 0;
}

function pcache1ResizeHash($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $1 = HEAP32[$0 + 52 >> 2];
 $2 = $1 << 1;
 $3 = $2 >>> 0 > 256 ? $2 : 256;
 if ($1) {
  sqlite3BeginBenignMalloc();
 }
 $4 = sqlite3MallocZero($3 << 2, 0);
 if (HEAP32[$0 + 52 >> 2]) {
  sqlite3EndBenignMalloc();
 }
 if ($4) {
  $7 = HEAP32[$0 + 52 >> 2];
  while (1) {
   $1 = HEAP32[$0 + 56 >> 2];
   if (($5 | 0) != ($7 | 0)) {
    $1 = HEAP32[($5 << 2) + $1 >> 2];
    while (1) {
     if ($1) {
      $2 = HEAP32[$1 + 16 >> 2];
      $6 = (HEAPU32[$1 + 8 >> 2] % ($3 >>> 0) << 2) + $4 | 0;
      HEAP32[$1 + 16 >> 2] = HEAP32[$6 >> 2];
      HEAP32[$6 >> 2] = $1;
      $1 = $2;
      continue;
     }
     break;
    }
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_free($1);
  HEAP32[$0 + 52 >> 2] = $3;
  HEAP32[$0 + 56 >> 2] = $4;
 }
}

function sqlite3VdbeSwap($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 240 | 0;
 __stack_pointer = $2;
 $3 = __memcpy($2, $0, 240);
 $2 = __memcpy($0, $1, 240);
 $0 = __memcpy($1, $3, 240);
 $1 = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = $1;
 $1 = HEAP32[$2 + 4 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = $1;
 $1 = HEAP32[$2 + 196 >> 2];
 HEAP32[$2 + 196 >> 2] = HEAP32[$0 + 196 >> 2];
 HEAP32[$0 + 196 >> 2] = $1;
 $1 = HEAP32[$2 + 200 >> 2];
 HEAP32[$2 + 200 >> 2] = HEAP32[$0 + 200 >> 2];
 HEAP32[$0 + 200 >> 2] = $1;
 HEAP32[$0 + 224 >> 2] = HEAP32[$2 + 224 >> 2];
 HEAP8[$0 + 148 | 0] = HEAPU8[$2 + 148 | 0];
 __memcpy($0 + 160 | 0, $2 + 160 | 0, 36);
 $1 = $0;
 $0 = $0 + 180 | 0;
 HEAP32[$0 >> 2] = HEAP32[$1 + 180 >> 2] + 1;
 __stack_pointer = $3 + 240 | 0;
}

function sqlite3_value_dup($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = sqlite3_malloc(40);
  if (!$2) {
   break label$1;
  }
  $1 = memset($2, 0, 40);
  $2 = HEAP32[$0 + 16 >> 2];
  HEAP32[$1 + 16 >> 2] = $2;
  $3 = HEAP32[$0 + 12 >> 2];
  $4 = HEAP32[$0 + 8 >> 2];
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $3;
  $4 = HEAP32[$0 + 4 >> 2];
  $3 = HEAP32[$0 >> 2];
  HEAP32[$1 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = $4;
  HEAP32[$1 + 20 >> 2] = 0;
  $0 = $2 & 61439;
  HEAP16[$1 + 16 >> 1] = $0;
  label$2: {
   if ($2 & 18) {
    HEAP16[$1 + 16 >> 1] = $2 & 36863 | 16384;
    if (!sqlite3VdbeMemMakeWriteable($1)) {
     break label$2;
    }
    sqlite3ValueFree($1);
    return 0;
   }
   if (!($0 & 1)) {
    break label$2;
   }
   HEAP16[$1 + 16 >> 1] = $2 & 58879;
  }
 }
 return $1;
}

function pcache1TruncateUnsafe($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$0 + 52 >> 2];
 $3 = HEAP32[$0 + 36 >> 2];
 label$1: {
  if ($2 >>> 0 > $3 - $1 >>> 0) {
   $4 = ($1 >>> 0) % ($2 >>> 0) | 0;
   $5 = ($3 >>> 0) % ($2 >>> 0) | 0;
   break label$1;
  }
  $4 = $2 >>> 1 | 0;
  $5 = $4 - 1 | 0;
 }
 while (1) {
  $3 = HEAP32[$0 + 56 >> 2] + ($4 << 2) | 0;
  while (1) {
   $2 = HEAP32[$3 >> 2];
   if ($2) {
    if (HEAPU32[$2 + 8 >> 2] >= $1 >>> 0) {
     HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] - 1;
     HEAP32[$3 >> 2] = HEAP32[$2 + 16 >> 2];
     if (HEAP32[$2 + 24 >> 2]) {
      pcache1PinPage($2);
     }
     pcache1FreePage($2);
    } else {
     $3 = $2 + 16 | 0;
    }
    continue;
   }
   break;
  }
  if (($4 | 0) != ($5 | 0)) {
   $4 = ($4 + 1 >>> 0) % HEAPU32[$0 + 52 >> 2] | 0;
   continue;
  }
  break;
 }
}

function unixGetTempname($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP8[$1 | 0] = 0;
 $5 = unixTempFileDir();
 label$1: {
  if (!$5) {
   $4 = 6410;
   break label$1;
  }
  $6 = ($0 + $1 | 0) - 2 | 0;
  while (1) {
   sqlite3_randomness(8, $2 + 24 | 0);
   HEAP8[$6 | 0] = 0;
   HEAP32[$2 + 16 >> 2] = 0;
   HEAP32[$2 >> 2] = $5;
   $3 = HEAP32[$2 + 28 >> 2];
   HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 24 >> 2];
   HEAP32[$2 + 12 >> 2] = $3;
   $9 = sqlite3_snprintf($0, $1, 17462, $2);
   $3 = $7 >>> 0 > 10;
   $8 = HEAPU8[$6 | 0];
   $4 = $8 ? 1 : $3 ? 1 : $4;
   if ($3 | $8) {
    break label$1;
   }
   $7 = $7 + 1 | 0;
   if (!(FUNCTION_TABLE[HEAP32[16243]]($9, 0) | 0)) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $2 + 32 | 0;
 return $4;
}

function btreeRestoreCursorPosition($0) {
 var $1 = 0, $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 label$1: {
  if (HEAPU8[$0 | 0] == 4) {
   $1 = HEAP32[$0 + 4 >> 2];
   break label$1;
  }
  HEAP8[$0 | 0] = 1;
  $1 = 10;
  if (sqlite3FaultSim(410)) {
   break label$1;
  }
  $1 = btreeMoveto($0, HEAP32[$0 + 16 >> 2], HEAP32[$0 + 56 >> 2], HEAP32[$0 + 60 >> 2], 0, $2 + 12 | 0);
  if ($1) {
   break label$1;
  }
  sqlite3_free(HEAP32[$0 + 16 >> 2]);
  HEAP32[$0 + 16 >> 2] = 0;
  label$3: {
   $1 = HEAP32[$2 + 12 >> 2];
   if ($1) {
    HEAP32[$0 + 4 >> 2] = $1;
    break label$3;
   }
   if (HEAP32[$0 + 4 >> 2]) {
    break label$3;
   }
   $1 = 0;
   break label$1;
  }
  $1 = 0;
  if (HEAPU8[$0 | 0]) {
   break label$1;
  }
  HEAP8[$0 | 0] = 2;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function jsonObjectCompute($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = sqlite3_aggregate_context($0, 0);
 label$1: {
  if ($2) {
   jsonAppendChar($2, 125);
   label$3: {
    switch (HEAPU8[$2 + 25 | 0]) {
    case 1:
     sqlite3_result_error_nomem($0);
     break label$1;

    case 0:
     break label$3;

    default:
     break label$1;
    }
   }
   $3 = HEAP32[$2 + 16 >> 2];
   $4 = HEAP32[$2 + 4 >> 2];
   if ($1) {
    sqlite3_result_text($0, $4, $3, HEAPU8[$2 + 24 | 0] ? -1 : 3);
    HEAP8[$2 + 24 | 0] = 1;
    break label$1;
   }
   sqlite3_result_text($0, $4, $3, -1);
   $1 = HEAP32[$2 + 16 >> 2];
   $3 = !$1;
   $3 = HEAP32[$2 + 20 >> 2] - $3 | 0;
   $1 = $1 - 1 | 0;
   HEAP32[$2 + 16 >> 2] = $1;
   HEAP32[$2 + 20 >> 2] = $3;
   break label$1;
  }
  sqlite3_result_text($0, 1031, 2, 0);
 }
 sqlite3_result_subtype($0, 74);
}

function __syscall_mmap2($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = -28;
 if (!$0) {
  $0 = $5 << 12;
  label$2: {
   if ($3 & 32) {
    $5 = emscripten_builtin_memalign(65536, $1 + 40 | 0);
    if (!$5) {
     return -48;
    }
    memset($5, 0, $1);
    $6 = $1 + $5 | 0;
    HEAP32[$6 >> 2] = $5;
    HEAP32[$6 + 8 >> 2] = 1;
    HEAP32[$6 + 12 >> 2] = -1;
    break label$2;
   }
   $6 = dlmalloc(40);
   $5 = _mmap_js($1 | 0, $2 | 0, $3 | 0, $4 | 0, $0 | 0, $6 + 8 | 0) | 0;
   if (($5 | 0) < 0) {
    dlfree($6);
    return $5;
   }
   HEAP32[$6 + 12 >> 2] = $4;
   HEAP32[$6 >> 2] = $5;
  }
  HEAP32[$6 + 32 >> 2] = $2;
  HEAP32[$6 + 16 >> 2] = $3;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 24 >> 2] = $0;
  HEAP32[$6 + 28 >> 2] = 0;
  HEAP32[$6 + 36 >> 2] = HEAP32[17774];
  HEAP32[17774] = $6;
  $6 = HEAP32[$6 >> 2];
 }
 return $6;
}

function strcspn($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $2 = HEAP8[$1 | 0];
 label$1: {
  if (!(HEAPU8[$1 + 1 | 0] ? $2 : 0)) {
   $3 = __strchrnul($0, $2);
   break label$1;
  }
  memset($4, 0, 32);
  $2 = HEAPU8[$1 | 0];
  if ($2) {
   while (1) {
    $3 = ($2 >>> 3 & 28) + $4 | 0;
    HEAP32[$3 >> 2] = HEAP32[$3 >> 2] | 1 << $2;
    $2 = HEAPU8[$1 + 1 | 0];
    $1 = $1 + 1 | 0;
    if ($2) {
     continue;
    }
    break;
   }
  }
  $3 = $0;
  $2 = HEAPU8[$0 | 0];
  if (!$2) {
   break label$1;
  }
  $1 = $0;
  while (1) {
   if (HEAP32[($2 >>> 3 & 28) + $4 >> 2] >>> $2 & 1) {
    $3 = $1;
    break label$1;
   }
   $2 = HEAPU8[$1 + 1 | 0];
   $3 = $1 + 1 | 0;
   $1 = $3;
   if ($2) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $4 + 32 | 0;
 return $3 - $0 | 0;
}

function findIndexCol($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $8 = HEAP32[HEAP32[$3 + 32 >> 2] + ($4 << 2) >> 2];
 while (1) {
  label$2: {
   if (HEAP32[$1 >> 2] <= ($5 | 0)) {
    $5 = -1;
    break label$2;
   }
   $7 = HEAP32[(($5 << 4) + $1 | 0) + 8 >> 2];
   $6 = sqlite3ExprSkipCollateAndLikely($7);
   label$4: {
    if (!$6) {
     break label$4;
    }
    label$5: {
     switch (HEAPU8[$6 | 0] - 167 | 0) {
     case 0:
     case 2:
      break label$5;

     default:
      break label$4;
     }
    }
    if (HEAPU16[$6 + 32 >> 1] != HEAPU16[HEAP32[$3 + 4 >> 2] + ($4 << 1) >> 1] | HEAP32[$6 + 28 >> 2] != ($2 | 0)) {
     break label$4;
    }
    if (!sqlite3StrICmp(HEAP32[sqlite3ExprNNCollSeq($0, $7) >> 2], $8)) {
     break label$2;
    }
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 return $5;
}

function sqlite3VdbeCheckFk($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  label$2: {
   if ($1) {
    $1 = HEAP32[$0 >> 2];
    $3 = $1;
    $1 = HEAP32[$3 + 520 >> 2];
    $4 = $1;
    $2 = HEAP32[$3 + 524 >> 2];
    $5 = HEAP32[$3 + 512 >> 2];
    $1 = HEAP32[$3 + 516 >> 2];
    $3 = $4;
    $4 = $5;
    $3 = $3 + $4 | 0;
    $5 = $1;
    $1 = $2;
    $2 = $5 + $1 | 0;
    $2 = $4 >>> 0 > $3 >>> 0 ? $2 + 1 | 0 : $2;
    $1 = $3;
    if (!!$1 & ($2 | 0) >= 0 | ($2 | 0) > 0) {
     break label$2;
    }
    break label$1;
   }
   $1 = HEAP32[$0 + 64 >> 2];
   $4 = $1;
   $2 = HEAP32[$0 + 68 >> 2];
   if (!$4 & ($2 | 0) <= 0 | ($2 | 0) < 0) {
    break label$1;
   }
  }
  HEAP8[$0 + 146 | 0] = 2;
  HEAP32[$0 + 36 >> 2] = 787;
  sqlite3VdbeError($0, 15341, 0);
  return HEAP8[$0 + 148 | 0] >= 0 ? 1 : 787;
 }
 return 0;
}

function fstatat($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  label$2: {
   label$3: {
    if (!(($3 | 0) != 4096 | ($0 | 0) < 0)) {
     if (HEAPU8[$1 | 0]) {
      break label$3;
     }
     $0 = __syscall_fstat64($0 | 0, $2 | 0) | 0;
     break label$1;
    }
    label$5: {
     if (($0 | 0) != -100) {
      $4 = HEAPU8[$1 | 0];
      if (!$3 & ($4 | 0) == 47) {
       break label$5;
      }
      if (($3 | 0) != 256 | ($4 | 0) != 47) {
       break label$3;
      }
      break label$2;
     }
     if (($3 | 0) == 256) {
      break label$2;
     }
     if ($3) {
      break label$3;
     }
    }
    $0 = __syscall_stat64($1 | 0, $2 | 0) | 0;
    break label$1;
   }
   $0 = __syscall_newfstatat($0 | 0, $1 | 0, $2 | 0, $3 | 0) | 0;
   break label$1;
  }
  $0 = __syscall_lstat64($1 | 0, $2 | 0) | 0;
 }
 return __syscall_ret($0);
}

function fts3DoIncrmerge($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 8 >> 2] = $1;
 $6 = fts3Getint($2 + 8 | 0);
 $3 = 8;
 $4 = HEAP32[$2 + 8 >> 2];
 $5 = HEAPU8[$4 | 0];
 label$1: {
  if (($5 | 0) == 44) {
   $1 = 1;
   if (!HEAPU8[$4 + 1 | 0]) {
    break label$1;
   }
   HEAP32[$2 + 8 >> 2] = $4 + 1;
   $3 = fts3Getint($2 + 8 | 0);
   $5 = HEAPU8[HEAP32[$2 + 8 >> 2]];
  }
  $1 = 1;
  if (($3 | 0) < 2 | $5) {
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = 0;
  label$3: {
   if (!HEAPU8[$0 + 237 | 0]) {
    sqlite3Fts3CreateStatTable($2 + 12 | 0, $0);
    $1 = HEAP32[$2 + 12 >> 2];
    if ($1) {
     break label$3;
    }
   }
   $1 = sqlite3Fts3Incrmerge($0, $6, $3);
  }
  sqlite3Fts3SegmentsClose($0);
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function fts3tokDequoteArray($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if ($0) {
   $6 = ($0 | 0) > 0 ? $0 : 0;
   while (1) {
    if (($3 | 0) != ($6 | 0)) {
     $4 = (strlen(HEAP32[($3 << 2) + $1 >> 2]) + $4 | 0) + 1 | 0;
     $3 = $3 + 1 | 0;
     continue;
    }
    break;
   }
   $3 = $0 << 2;
   $5 = sqlite3_malloc64($4 + $3 | 0, 0);
   HEAP32[$2 >> 2] = $5;
   if (!$5) {
    return 7;
   }
   $4 = $3 + $5 | 0;
   $3 = 0;
   while (1) {
    if (($3 | 0) == ($6 | 0)) {
     break label$1;
    }
    $0 = $3 << 2;
    $2 = $1 + $0 | 0;
    $7 = strlen(HEAP32[$2 >> 2]);
    HEAP32[$0 + $5 >> 2] = $4;
    $0 = $7 + 1 | 0;
    $4 = __memcpy($4, HEAP32[$2 >> 2], $0);
    sqlite3Fts3Dequote($4);
    $3 = $3 + 1 | 0;
    $4 = $0 + $4 | 0;
    continue;
   }
  }
  HEAP32[$2 >> 2] = 0;
 }
 return 0;
}

function allocSpace($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (!$1) {
  $4 = HEAP32[$0 + 12 >> 2];
  $6 = $4;
  $1 = HEAP32[$0 + 8 >> 2];
  $7 = $1;
  $4 = $3;
  $5 = $2 + 7 | 0;
  $1 = $5 >>> 0 < 7 ? $4 + 1 | 0 : $4;
  $4 = $5;
  $2 = $4 & -8;
  $3 = $1;
  $4 = $1;
  $1 = $7;
  if (($4 | 0) <= ($6 | 0) & $1 >>> 0 >= $2 >>> 0 | ($4 | 0) < ($6 | 0)) {
   $4 = $2;
   $1 = $7 - $4 | 0;
   $2 = $1;
   $1 = $6;
   $6 = $3;
   $5 = $6 + ($4 >>> 0 > $7 >>> 0) | 0;
   $5 = $1 - $5 | 0;
   HEAP32[$0 + 8 >> 2] = $2;
   HEAP32[$0 + 12 >> 2] = $5;
   return $2 + HEAP32[$0 >> 2] | 0;
  }
  $4 = $2;
  $5 = HEAP32[$0 + 16 >> 2];
  $6 = $4 + $5 | 0;
  $5 = $3;
  $1 = $5 + HEAP32[$0 + 20 >> 2] | 0;
  HEAP32[$0 + 16 >> 2] = $6;
  $1 = $4 >>> 0 > $6 >>> 0 ? $1 + 1 | 0 : $1;
  HEAP32[$0 + 20 >> 2] = $1;
  $1 = 0;
 }
 return $1;
}

function unixSetSystemCall($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 label$1: {
  label$2: {
   if (!$1) {
    while (1) {
     if (($3 | 0) == 29) {
      break label$2;
     }
     $1 = Math_imul($3, 12);
     $0 = HEAP32[$1 + 64952 >> 2];
     if ($0) {
      HEAP32[$1 + 64948 >> 2] = $0;
     }
     $3 = $3 + 1 | 0;
     continue;
    }
   }
   $0 = 12;
   while (1) {
    if (($3 | 0) == 29) {
     break label$1;
    }
    if (strcmp($1, HEAP32[Math_imul($3, 12) + 64944 >> 2])) {
     $3 = $3 + 1 | 0;
     continue;
    } else {
     $3 = Math_imul($3, 12);
     $0 = $3 + 64952 | 0;
     $1 = HEAP32[$0 >> 2];
     if (!$1) {
      $1 = HEAP32[$3 + 64948 >> 2];
      HEAP32[$0 >> 2] = $1;
     }
     HEAP32[$3 + 64948 >> 2] = $2 ? $2 : $1;
    }
    break;
   }
  }
  $0 = 0;
 }
 return $0 | 0;
}

function fts3InsertDocsize($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (!HEAP32[$0 >> 2]) {
  $4 = HEAP32[$1 + 24 >> 2];
  $5 = $4 >> 31;
  $4 = __wasm_i64_mul($4, $5, 10, 0);
  $5 = i64toi32_i32$HIGH_BITS;
  $6 = sqlite3_malloc64($4, $5);
  label$2: {
   if (!$6) {
    $2 = 7;
    break label$2;
   }
   fts3EncodeIntArray(HEAP32[$1 + 24 >> 2], $2, $6, $3 + 12 | 0);
   $2 = fts3SqlStmt($1, 20, $3 + 8 | 0, 0);
   if ($2) {
    sqlite3_free($6);
    break label$2;
   }
   $2 = HEAP32[$3 + 8 >> 2];
   $5 = HEAP32[$1 + 272 >> 2];
   $4 = HEAP32[$1 + 276 >> 2];
   sqlite3_bind_int64($2, 1, $5, $4);
   sqlite3_bind_blob($2, 2, $6, HEAP32[$3 + 12 >> 2], 3);
   sqlite3_step($2);
   $2 = sqlite3_reset($2);
  }
  HEAP32[$0 >> 2] = $2;
 }
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3ExprImpliesNonNullRow($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $0 = sqlite3ExprSkipCollateAndLikely($0);
 $3 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $3 = HEAPU8[$0 | 0];
  label$2: {
   if (($3 | 0) != 51) {
    while (1) {
     if (($3 | 0) != 44) {
      break label$2;
     }
     $3 = 1;
     if (sqlite3ExprImpliesNonNullRow(HEAP32[$0 + 12 >> 2], $1)) {
      break label$1;
     }
     $0 = HEAP32[$0 + 16 >> 2];
     $3 = HEAPU8[$0 | 0];
     continue;
    }
   }
   $0 = HEAP32[$0 + 12 >> 2];
  }
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP16[$2 + 20 >> 1] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 47;
  sqlite3WalkExpr($2, $0);
  $3 = HEAPU16[$2 + 20 >> 1];
 }
 __stack_pointer = $2 + 32 | 0;
 $0 = $3;
 return $0;
}

function sqlite3NestedParse($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 80 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  $5 = HEAP32[$3 + 24 >> 2];
  HEAP32[$4 + 76 >> 2] = $2;
  $2 = sqlite3VMPrintf($3, $1, $2);
  if (!$2) {
   if (!HEAPU8[$3 + 87 | 0]) {
    HEAP32[$0 + 12 >> 2] = 18;
   }
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   break label$1;
  }
  HEAP8[$0 + 18 | 0] = HEAPU8[$0 + 18 | 0] + 1;
  $1 = $0 + 196 | 0;
  $6 = __memcpy($4, $1, 76);
  $1 = memset($1, 0, 76);
  HEAP32[$3 + 24 >> 2] = HEAP32[$3 + 24 >> 2] | 2;
  sqlite3RunParser($0, $2);
  HEAP32[$3 + 24 >> 2] = $5;
  sqlite3DbFree($3, $2);
  __memcpy($1, $6, 76);
  HEAP8[$0 + 18 | 0] = HEAPU8[$0 + 18 | 0] - 1;
 }
 __stack_pointer = $4 + 80 | 0;
}

function sqlite3VdbeMemHandleBom($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $4 = 2;
 label$1: {
  if (HEAP32[$0 + 12 >> 2] < 2) {
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2];
  $3 = HEAPU8[$2 + 1 | 0];
  $2 = HEAPU8[$2 | 0];
  if (!(($2 | 0) == 255 & ($3 & 255) == 254)) {
   if (($2 | 0) != 254) {
    break label$1;
   }
   $4 = 3;
   if (($3 & 255) != 255) {
    break label$1;
   }
  }
  $1 = sqlite3VdbeMemMakeWriteable($0);
  if ($1) {
   break label$1;
  }
  $1 = HEAP32[$0 + 12 >> 2] - 2 | 0;
  HEAP32[$0 + 12 >> 2] = $1;
  $3 = HEAP32[$0 + 8 >> 2];
  memmove($3, $3 + 2 | 0, $1);
  $1 = 0;
  HEAP8[HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] | 0] = 0;
  HEAP8[(HEAP32[$0 + 12 >> 2] + HEAP32[$0 + 8 >> 2] | 0) + 1 | 0] = 0;
  HEAP8[$0 + 18 | 0] = $4;
  HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] | 512;
 }
 return $1;
}

function _ZN17compiler_builtins3int4sdiv3Div3div17he78fc483e41d7ec7E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $4 = $1 >> 31;
 $8 = $4;
 $5 = $1;
 $5 = $4 ^ $5;
 $7 = $1 >> 31;
 $4 = $0 ^ $7;
 $9 = $4 - $7 | 0;
 $0 = $8;
 $6 = $0 + ($4 >>> 0 < $7 >>> 0) | 0;
 $6 = $5 - $6 | 0;
 $10 = $6;
 $6 = $3;
 $4 = $6 >> 31;
 $8 = $4;
 $5 = $6;
 $5 = $4 ^ $5;
 $7 = $6 >> 31;
 $6 = $7;
 $4 = $6 ^ $2;
 $0 = $4 - $6 | 0;
 $6 = $8;
 $4 = $5 - ($6 + ($4 >>> 0 < $7 >>> 0) | 0) | 0;
 $4 = __wasm_i64_udiv($9, $10, $0, $4);
 $6 = $4;
 $4 = $1;
 $4 = $3 ^ $4;
 $0 = $4 >> 31;
 $5 = $4 >> 31;
 $1 = $5;
 $5 = i64toi32_i32$HIGH_BITS;
 $2 = $1 ^ $5;
 $4 = $6;
 $5 = $0 ^ $4;
 $6 = $5 - $0 | 0;
 $4 = $1;
 $0 = $4 + ($0 >>> 0 > $5 >>> 0) | 0;
 $0 = $2 - $0 | 0;
 $5 = $6;
 i64toi32_i32$HIGH_BITS = $0;
 return $5;
}

function fts3StringAppend($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (($2 | 0) < 0) {
  $2 = strlen($1);
 }
 $4 = HEAP32[$0 + 8 >> 2];
 $3 = HEAP32[$0 + 4 >> 2];
 label$2: {
  if (($4 | 0) > (($3 + $2 | 0) + 1 | 0)) {
   $4 = HEAP32[$0 >> 2];
   break label$2;
  }
  $3 = $2 >> 31;
  $6 = $3;
  $3 = $4 >> 31;
  $7 = $3;
  $5 = $4 + $2 | 0;
  $3 = $6;
  $6 = $7 + $3 | 0;
  $6 = $5 >>> 0 < $4 >>> 0 ? $6 + 1 | 0 : $6;
  $3 = $5;
  $5 = $6;
  $7 = $3 + 100 | 0;
  $5 = $7 >>> 0 < 100 ? $5 + 1 | 0 : $5;
  $4 = sqlite3_realloc64(HEAP32[$0 >> 2], $7, $5);
  if (!$4) {
   return 7;
  }
  HEAP32[$0 + 8 >> 2] = $7;
  HEAP32[$0 >> 2] = $4;
  $3 = HEAP32[$0 + 4 >> 2];
 }
 __memcpy($4 + $3 | 0, $1, $2);
 $2 = HEAP32[$0 + 4 >> 2] + $2 | 0;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP8[HEAP32[$0 >> 2] + $2 | 0] = 0;
 return 0;
}

function sqlite3_wal_checkpoint_v2($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 if ($3) {
  HEAP32[$3 >> 2] = -1;
 }
 if ($4) {
  HEAP32[$4 >> 2] = -1;
 }
 $5 = 21;
 label$3: {
  if ($2 >>> 0 > 3) {
   break label$3;
  }
  $5 = 12;
  label$4: {
   label$5: {
    if (!$1 | !HEAPU8[$1 | 0]) {
     break label$5;
    }
    $5 = sqlite3FindDbName($0, $1);
    if (($5 | 0) >= 0) {
     break label$5;
    }
    HEAP32[$6 >> 2] = $1;
    $4 = 1;
    sqlite3ErrorWithMsg($0, 1, 7631, $6);
    break label$4;
   }
   HEAP32[$0 + 452 >> 2] = 0;
   $4 = sqlite3Checkpoint($0, $5, $2, $3, $4);
   sqlite3Error($0, $4);
  }
  $5 = sqlite3ApiExit($0, $4);
  if (HEAP32[$0 + 184 >> 2]) {
   break label$3;
  }
  HEAP32[$0 + 296 >> 2] = 0;
 }
 __stack_pointer = $6 + 16 | 0;
 return $5;
}

function copyNodeContent($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 label$1: {
  if (HEAP32[$2 >> 2]) {
   break label$1;
  }
  $7 = HEAP32[$1 + 4 >> 2];
  $3 = HEAP32[$0 + 56 >> 2];
  $4 = $3 + HEAPU8[$0 + 9 | 0] | 0;
  $5 = HEAPU8[$4 + 5 | 0] << 8 | HEAPU8[$4 + 6 | 0];
  $6 = HEAP32[$1 + 56 >> 2];
  $8 = $3 + $5 | 0;
  $3 = HEAP32[$0 + 52 >> 2];
  __memcpy($5 + $6 | 0, $8, HEAP32[$3 + 40 >> 2] - $5 | 0);
  __memcpy((($7 | 0) == 1 ? 100 : 0) + $6 | 0, $4, HEAPU16[$0 + 18 >> 1] + (HEAPU16[$0 + 24 >> 1] << 1) | 0);
  HEAP8[$1 | 0] = 0;
  $0 = btreeInitPage($1);
  label$2: {
   if ($0) {
    break label$2;
   }
   $0 = btreeComputeFreeSpace($1);
   if ($0) {
    break label$2;
   }
   if (!HEAPU8[$3 + 17 | 0]) {
    break label$1;
   }
   $0 = setChildPtrmaps($1);
  }
  HEAP32[$2 >> 2] = $0;
 }
}

function whereCheckIfBloomFilterIsUseful($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $1 = HEAPU8[$0 + 48 | 0];
 $7 = $1 >>> 0 > 1 ? $1 : 1;
 $3 = HEAPU16[HEAP32[$0 + 848 >> 2] + 22 >> 1];
 $1 = 1;
 while (1) {
  if (($1 | 0) != ($7 | 0)) {
   $2 = HEAP32[(Math_imul($1, 96) + $0 | 0) + 848 >> 2];
   $4 = HEAP32[$2 + 40 >> 2];
   label$3: {
    if (($4 & 8388609) != 8388609 | !($4 & 768)) {
     break label$3;
    }
    $5 = HEAP32[(HEAP32[$0 + 4 >> 2] + (HEAPU8[$2 + 16 | 0] << 6) | 0) + 24 >> 2];
    $6 = HEAP32[$5 + 28 >> 2];
    HEAP32[$5 + 28 >> 2] = $6 | 256;
    if (!($6 & 16) | HEAP16[$5 + 38 >> 1] >= $3 << 16 >> 16) {
     break label$3;
    }
    HEAP32[$2 + 40 >> 2] = $4 & -4194369 | 4194304;
   }
   $1 = $1 + 1 | 0;
   $3 = HEAPU16[$2 + 22 >> 1] + $3 | 0;
   continue;
  }
  break;
 }
}

function isSelfJoinView($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $3 = HEAP32[$1 + 20 >> 2];
  if (HEAP8[$3 + 7 | 0] & 1) {
   break label$1;
  }
  $0 = $0 + 8 | 0;
  while (1) {
   if ($0 >>> 0 >= $1 >>> 0) {
    break label$1;
   }
   label$3: {
    $2 = HEAP32[$0 + 20 >> 2];
    if (!$2 | HEAPU8[$0 + 37 | 0] & 32) {
     break label$3;
    }
    $4 = HEAP32[$0 + 8 >> 2];
    if (!$4) {
     break label$3;
    }
    $5 = HEAP32[HEAP32[$0 + 16 >> 2] + 60 >> 2];
    if (($5 | 0) != HEAP32[HEAP32[$1 + 16 >> 2] + 60 >> 2]) {
     break label$3;
    }
    if (sqlite3_stricmp($4, HEAP32[$1 + 8 >> 2]) | !$5 & HEAP32[$3 + 16 >> 2] != HEAP32[$2 + 16 >> 2] | HEAP8[$2 + 7 | 0] & 1) {
     break label$3;
    }
    $6 = $0;
    break label$1;
   }
   $0 = $0 - -64 | 0;
   continue;
  }
 }
 return $6;
}

function fts3GetDeltaVarint3($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  if ($4 >>> 0 >= $1 >>> 0) {
   HEAP32[$0 >> 2] = 0;
   break label$1;
  }
  HEAP32[$0 >> 2] = sqlite3Fts3GetVarintU($4, $6 + 8 | 0) + HEAP32[$0 >> 2];
  $1 = $3;
  $7 = HEAP32[$1 >> 2];
  $0 = HEAP32[$1 + 4 >> 2];
  $8 = $0;
  $1 = $6;
  $0 = HEAP32[$1 + 8 >> 2];
  $4 = $0;
  $5 = 0 - $0 | 0;
  $1 = HEAP32[$1 + 12 >> 2];
  $0 = $1;
  $9 = 0 - ($0 + (($4 | 0) != 0) | 0) | 0;
  $0 = $2;
  $4 = $0 ? $5 : $4;
  $2 = $4;
  $4 = $0 ? $9 : $1;
  $5 = $4 + $8 | 0;
  $0 = $7;
  $1 = $2 + $0 | 0;
  $5 = $2 >>> 0 > $1 >>> 0 ? $5 + 1 | 0 : $5;
  $0 = $3;
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $5;
 }
 __stack_pointer = $6 + 16 | 0;
}

function walChecksumBytes($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 if ($3) {
  $5 = HEAP32[$3 + 4 >> 2];
  $3 = HEAP32[$3 >> 2];
 } else {
  $3 = 0;
 }
 $6 = $1 + $2 | 0;
 label$3: {
  if (!$0) {
   while (1) {
    $2 = HEAP32[$1 + 4 >> 2];
    $0 = ($2 << 24 | $2 << 8 & 16711680 | ($2 >>> 8 & 65280 | $2 >>> 24)) + $5 | 0;
    $2 = $3 + $5 | 0;
    $5 = HEAP32[$1 >> 2];
    $3 = $2 + ($5 << 24 | $5 << 8 & 16711680 | ($5 >>> 8 & 65280 | $5 >>> 24)) | 0;
    $5 = $0 + $3 | 0;
    $1 = $1 + 8 | 0;
    if ($6 >>> 0 > $1 >>> 0) {
     continue;
    }
    break label$3;
   }
  }
  while (1) {
   $3 = HEAP32[$1 >> 2] + ($3 + $5 | 0) | 0;
   $5 = $3 + (HEAP32[$1 + 4 >> 2] + $5 | 0) | 0;
   $1 = $1 + 8 | 0;
   if ($6 >>> 0 > $1 >>> 0) {
    continue;
   }
   break;
  }
 }
 HEAP32[$4 + 4 >> 2] = $5;
 HEAP32[$4 >> 2] = $3;
}

function vtabBestIndex($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 >> 2];
 $1 = HEAP32[sqlite3GetVTable($3, $1) + 8 >> 2];
 HEAP32[$3 + 56 >> 2] = HEAP32[$3 + 56 >> 2] + 1;
 $3 = FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 12 >> 2]]($1, $2) | 0;
 $2 = HEAP32[$0 >> 2];
 HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] - 1;
 label$1: {
  if (!$3 | ($3 | 0) == 19) {
   break label$1;
  }
  if (($3 | 0) == 7) {
   sqlite3OomFault($2);
   break label$1;
  }
  $2 = HEAP32[$1 + 8 >> 2];
  if (!$2) {
   HEAP32[$4 >> 2] = sqlite3ErrStr($3);
   sqlite3ErrorMsg($0, 8342, $4);
   break label$1;
  }
  HEAP32[$4 + 16 >> 2] = $2;
  sqlite3ErrorMsg($0, 8342, $4 + 16 | 0);
 }
 sqlite3_free(HEAP32[$1 + 8 >> 2]);
 HEAP32[$1 + 8 >> 2] = 0;
 __stack_pointer = $4 + 32 | 0;
 return $3;
}

function seekAndRead($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 while (1) {
  __lseek(HEAP32[$0 + 12 >> 2], $1, $2, 0);
  if ((i64toi32_i32$HIGH_BITS | 0) < 0) {
   storeLastErrno($0, HEAP32[__errno_location() >> 2]);
   return -1;
  }
  label$3: {
   $5 = FUNCTION_TABLE[HEAP32[16261]](HEAP32[$0 + 12 >> 2], $3, $4) | 0;
   label$4: {
    if (($5 | 0) == ($4 | 0)) {
     $5 = $4;
     break label$4;
    }
    if (($5 | 0) < 0) {
     $7 = HEAP32[__errno_location() >> 2];
     if (($7 | 0) == 27) {
      continue;
     }
     storeLastErrno($0, $7);
     $6 = 0;
     break label$4;
    }
    if ($5) {
     break label$3;
    }
    $5 = 0;
   }
   return $5 + $6 | 0;
  }
  $3 = $3 + $5 | 0;
  $6 = $5 + $6 | 0;
  $4 = $4 - $5 | 0;
  $1 = $1 + $5 | 0;
  $2 = $5 >>> 0 > $1 >>> 0 ? $2 + 1 | 0 : $2;
  continue;
 }
}

function fts3tokFilterMethod($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0;
 $3 = HEAP32[$0 >> 2];
 fts3tokResetCursor($0);
 $2 = 1;
 label$1: {
  if (($1 | 0) != 1) {
   break label$1;
  }
  $5 = sqlite3_value_text(HEAP32[$4 >> 2]);
  $1 = sqlite3_value_bytes(HEAP32[$4 >> 2]);
  $2 = $1 + 1 | 0;
  $2 = sqlite3_malloc64($2, $2 >> 31);
  HEAP32[$0 + 4 >> 2] = $2;
  if (!$2) {
   return 7;
  }
  if (($1 | 0) > 0) {
   __memcpy($2, $5, $1);
   $2 = HEAP32[$0 + 4 >> 2];
  }
  HEAP8[$1 + $2 | 0] = 0;
  $2 = FUNCTION_TABLE[HEAP32[HEAP32[$3 + 12 >> 2] + 12 >> 2]](HEAP32[$3 + 16 >> 2], HEAP32[$0 + 4 >> 2], $1, $0 + 8 | 0) | 0;
  if ($2) {
   break label$1;
  }
  HEAP32[HEAP32[$0 + 8 >> 2] >> 2] = HEAP32[$3 + 16 >> 2];
  $2 = fts3tokNextMethod($0);
 }
 return $2 | 0;
}

function substSelect($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  while (1) {
   substExprList($0, HEAP32[$1 + 28 >> 2]);
   substExprList($0, HEAP32[$1 + 40 >> 2]);
   substExprList($0, HEAP32[$1 + 48 >> 2]);
   HEAP32[$1 + 44 >> 2] = substExpr($0, HEAP32[$1 + 44 >> 2]);
   HEAP32[$1 + 36 >> 2] = substExpr($0, HEAP32[$1 + 36 >> 2]);
   $3 = HEAP32[$1 + 32 >> 2];
   $4 = $3 + 8 | 0;
   $3 = HEAP32[$3 >> 2];
   while (1) {
    if (($3 | 0) > 0) {
     substSelect($0, HEAP32[$4 + 20 >> 2], 1);
     if (HEAPU8[$4 + 37 | 0] & 4) {
      substExprList($0, HEAP32[$4 + 56 >> 2]);
     }
     $4 = $4 - -64 | 0;
     $3 = $3 - 1 | 0;
     continue;
    }
    break;
   }
   if (!$2) {
    break label$1;
   }
   $1 = HEAP32[$1 + 52 >> 2];
   if ($1) {
    continue;
   }
   break;
  }
 }
}

function findConstInWhere($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  label$2: {
   label$3: {
    if (!$1 | HEAP32[$0 + 20 >> 2] & HEAP32[$1 + 4 >> 2]) {
     break label$3;
    }
    $2 = HEAPU8[$1 | 0];
    if (($2 | 0) == 44) {
     break label$2;
    }
    if (($2 | 0) != 53) {
     break label$3;
    }
    $2 = HEAP32[$1 + 12 >> 2];
    $3 = HEAP32[$1 + 16 >> 2];
    label$4: {
     if (HEAPU8[$3 | 0] != 167) {
      break label$4;
     }
     if (!sqlite3ExprIsConstant($2)) {
      break label$4;
     }
     constInsert($0, $3, $2, $1);
    }
    if (HEAPU8[$2 | 0] != 167) {
     break label$3;
    }
    if (!sqlite3ExprIsConstant($3)) {
     break label$3;
    }
    constInsert($0, $2, $3, $1);
   }
   return;
  }
  findConstInWhere($0, HEAP32[$1 + 16 >> 2]);
  $1 = HEAP32[$1 + 12 >> 2];
  continue;
 }
}

function jsonAppendObjectPathElement($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$1 + 8 >> 2];
 $2 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if (($2 | 0) < 3) {
   break label$1;
  }
  $1 = 2;
  if (!(HEAPU8[HEAPU8[$3 + 1 | 0] + 30288 | 0] & 2)) {
   break label$1;
  }
  $6 = $3 + 1 | 0;
  $5 = $2 - 1 | 0;
  while (1) {
   label$3: {
    if (($1 | 0) == ($5 | 0)) {
     $1 = $5;
     break label$3;
    }
    if (!(HEAPU8[HEAPU8[$1 + $3 | 0] + 30288 | 0] & 6)) {
     break label$3;
    }
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  $1 = ($1 | 0) == ($5 | 0);
  $2 = $1 ? $2 - 2 | 0 : $2;
  $3 = $1 ? $6 : $3;
 }
 HEAP32[$4 + 4 >> 2] = $3;
 HEAP32[$4 >> 2] = $2;
 jsonPrintf($2 + 2 | 0, $0, 5664, $4);
 __stack_pointer = $4 + 16 | 0;
}

function rowSetEntryMerge($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 16 | 0;
 $3 = $5;
 label$1: {
  label$2: while (1) {
   $2 = HEAP32[$0 >> 2];
   $6 = $2;
   $4 = HEAP32[$0 + 4 >> 2];
   while (1) {
    $7 = HEAP32[$1 >> 2];
    $2 = HEAP32[$1 + 4 >> 2];
    if (($4 | 0) <= ($2 | 0) & $6 >>> 0 <= $7 >>> 0 | ($4 | 0) < ($2 | 0)) {
     if ($6 >>> 0 < $7 >>> 0 & ($4 | 0) <= ($2 | 0) | ($4 | 0) < ($2 | 0)) {
      HEAP32[$3 + 8 >> 2] = $0;
      $3 = $0;
     }
     $0 = HEAP32[$0 + 8 >> 2];
     if ($0) {
      continue label$2;
     }
     break label$1;
    }
    HEAP32[$3 + 8 >> 2] = $1;
    $3 = $1;
    $1 = HEAP32[$1 + 8 >> 2];
    if ($1) {
     continue;
    }
    break;
   }
   break;
  }
  $1 = $0;
 }
 HEAP32[$3 + 8 >> 2] = $1;
 return HEAP32[$5 + 8 >> 2];
}

function sqlite3AddCollateType($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  $2 = HEAP32[$0 + 236 >> 2];
  if (!$2 | HEAPU8[$0 + 208 | 0] > 1) {
   break label$1;
  }
  $3 = HEAP16[$2 + 34 >> 1];
  $5 = HEAP32[$0 >> 2];
  $4 = sqlite3NameFromToken($5, $1);
  if (!$4) {
   break label$1;
  }
  label$2: {
   if (!sqlite3LocateCollSeq($0, $4)) {
    break label$2;
   }
   $1 = $3 - 1 | 0;
   $3 = Math_imul($1, 12);
   sqlite3ColumnSetColl($5, $3 + HEAP32[$2 + 4 >> 2] | 0, $4);
   $0 = $2 + 8 | 0;
   while (1) {
    $0 = HEAP32[$0 >> 2];
    if (!$0) {
     break label$2;
    }
    if (HEAP16[HEAP32[$0 + 4 >> 2] >> 1] == ($1 | 0)) {
     HEAP32[HEAP32[$0 + 32 >> 2] >> 2] = sqlite3ColumnColl(HEAP32[$2 + 4 >> 2] + $3 | 0);
    }
    $0 = $0 + 20 | 0;
    continue;
   }
  }
  sqlite3DbFree($5, $4);
 }
}

function btreeCellSizeCheck($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $4 = HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2];
 $7 = $4 + (HEAPU8[$0 + 8 | 0] ? -4 : -5) | 0;
 $5 = HEAPU16[$0 + 18 >> 1];
 $8 = $5 + (HEAPU16[$0 + 24 >> 1] << 1) | 0;
 $6 = HEAP32[$0 + 56 >> 2];
 label$1: {
  label$2: {
   while (1) {
    if (HEAPU16[$0 + 24 >> 1] <= $2 >>> 0) {
     break label$1;
    }
    $1 = (($2 << 1) + $5 | 0) + $6 | 0;
    $1 = HEAPU8[$1 | 0] << 8 | HEAPU8[$1 + 1 | 0];
    $3 = 68924;
    if ($8 >>> 0 > $1 >>> 0 | ($1 | 0) > ($7 | 0)) {
     break label$2;
    }
    $2 = $2 + 1 | 0;
    if (((FUNCTION_TABLE[HEAP32[$0 + 76 >> 2]]($0, $1 + $6 | 0) | 0) + $1 | 0) <= ($4 | 0)) {
     continue;
    }
    break;
   }
   $3 = 68929;
  }
  $9 = sqlite3CorruptError($3);
 }
 return $9;
}

function sqlite3AutoLoadExtensions($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 label$1: {
  if (!HEAP32[17689]) {
   break label$1;
  }
  $3 = 1;
  while (1) {
   if (!$3) {
    break label$1;
   }
   label$3: {
    if (HEAPU32[17689] <= $4 >>> 0) {
     $3 = 0;
     HEAP32[$1 + 12 >> 2] = 0;
     break label$3;
    }
    $2 = HEAP32[HEAP32[17690] + ($4 << 2) >> 2];
    HEAP32[$1 + 12 >> 2] = 0;
    $3 = 1;
    if (!$2) {
     break label$3;
    }
    $2 = FUNCTION_TABLE[$2 | 0]($0, $1 + 12 | 0, 0) | 0;
    if (!$2) {
     break label$3;
    }
    HEAP32[$1 >> 2] = HEAP32[$1 + 12 >> 2];
    sqlite3ErrorWithMsg($0, $2, 8132, $1);
    $3 = 0;
   }
   sqlite3_free(HEAP32[$1 + 12 >> 2]);
   $4 = $4 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $1 + 16 | 0;
}

function releaseMemArray($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0 | !$1) {
   break label$1;
  }
  $1 = Math_imul($1, 40) + $0 | 0;
  $2 = HEAP32[$0 + 20 >> 2];
  if (!HEAP32[$2 + 528 >> 2]) {
   while (1) {
    label$4: {
     label$5: {
      if (HEAPU8[$0 + 17 | 0] & 144) {
       sqlite3VdbeMemRelease($0);
       break label$5;
      }
      if (!HEAP32[$0 + 24 >> 2]) {
       break label$4;
      }
      sqlite3DbFreeNN($2, HEAP32[$0 + 32 >> 2]);
      HEAP32[$0 + 24 >> 2] = 0;
     }
     HEAP16[$0 + 16 >> 1] = 0;
    }
    $0 = $0 + 40 | 0;
    if ($1 >>> 0 > $0 >>> 0) {
     continue;
    }
    break label$1;
   }
  }
  while (1) {
   if (HEAP32[$0 + 24 >> 2]) {
    sqlite3DbFree($2, HEAP32[$0 + 32 >> 2]);
   }
   $0 = $0 + 40 | 0;
   if ($1 >>> 0 > $0 >>> 0) {
    continue;
   }
   break;
  }
 }
}

function statInit($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = sqlite3_context_db_handle($0);
 $6 = sqlite3_value_int(HEAP32[$2 >> 2]);
 $8 = sqlite3_value_int(HEAP32[$2 + 4 >> 2]);
 $7 = $6 + 1 & -2;
 $3 = ($7 << 3) + 36 | 0;
 $4 = $3 >> 31;
 $1 = sqlite3DbMallocZero($5, $3, $4);
 if (!$1) {
  sqlite3_result_error_nomem($0);
  return;
 }
 HEAP32[$1 >> 2] = $5;
 $4 = sqlite3_value_int64(HEAP32[$2 + 8 >> 2]);
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = $4;
 $3 = sqlite3_value_int64(HEAP32[$2 + 12 >> 2]);
 $2 = $1 + 36 | 0;
 HEAP32[$1 + 32 >> 2] = $2;
 HEAP8[$1 + 24 | 0] = 0;
 HEAP32[$1 + 20 >> 2] = $8;
 HEAP32[$1 + 16 >> 2] = $6;
 HEAP32[$1 + 12 >> 2] = $3;
 HEAP32[$1 + 28 >> 2] = ($7 << 2) + $2;
 sqlite3_result_blob($0, $1, 36, 87);
}

function fts3CursorSeekStmt($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$0 + 12 >> 2]) {
   break label$1;
  }
  $2 = $0 + 12 | 0;
  $1 = HEAP32[$0 >> 2];
  $3 = HEAP32[$1 + 220 >> 2];
  label$2: {
   if ($3) {
    HEAP32[$2 >> 2] = $3;
    HEAP32[$1 + 220 >> 2] = 0;
    break label$2;
   }
   HEAP32[$4 >> 2] = HEAP32[$1 + 224 >> 2];
   $3 = sqlite3_mprintf(21081, $4);
   if (!$3) {
    $2 = 7;
    break label$1;
   }
   HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 56 >> 2] + 1;
   $2 = sqlite3_prepare_v3(HEAP32[$1 + 12 >> 2], $3, -1, 1, $2, 0);
   HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 56 >> 2] - 1;
   sqlite3_free($3);
   if ($2) {
    break label$1;
   }
  }
  HEAP8[$0 + 8 | 0] = 1;
  $2 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $2;
}

function havingToWhereExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer + -64 | 0;
 __stack_pointer = $3;
 label$1: {
  if (HEAPU8[$1 | 0] == 44) {
   break label$1;
  }
  $4 = 1;
  $5 = HEAP32[$0 + 24 >> 2];
  if (!sqlite3ExprIsConstantOrGroupBy(HEAP32[$0 >> 2], $1, HEAP32[$5 + 40 >> 2]) | (HEAP32[$1 + 4 >> 2] & 536870913) == 536870912 | HEAP32[$1 + 40 >> 2]) {
   break label$1;
  }
  $2 = sqlite3Expr(HEAP32[HEAP32[$0 >> 2] >> 2], 155, 23470);
  if (!$2) {
   break label$1;
  }
  $4 = HEAP32[$5 + 36 >> 2];
  __memcpy($3 + 8 | 0, $2, 52);
  $2 = __memcpy($2, $1, 52);
  __memcpy($1, $3 + 8 | 0, 52);
  HEAP32[$5 + 36 >> 2] = sqlite3ExprAnd(HEAP32[$0 >> 2], $4, $2);
  $4 = 1;
  HEAP16[$0 + 20 >> 1] = 1;
 }
 __stack_pointer = $3 - -64 | 0;
 return $4 | 0;
}

function disconnectAllVtab($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 sqlite3BtreeEnterAll($0);
 while (1) {
  if (HEAP32[$0 + 20 >> 2] > ($3 | 0)) {
   label$3: {
    $1 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($3 << 4) | 0) + 12 >> 2];
    if (!$1) {
     break label$3;
    }
    $1 = $1 + 16 | 0;
    while (1) {
     $1 = HEAP32[$1 >> 2];
     if (!$1) {
      break label$3;
     }
     $2 = HEAP32[$1 + 8 >> 2];
     if (HEAPU8[$2 + 43 | 0] != 1) {
      continue;
     }
     sqlite3VtabDisconnect($0, $2);
     continue;
    }
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 $1 = $0 + 392 | 0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if ($1) {
   $2 = HEAP32[HEAP32[$1 + 8 >> 2] + 20 >> 2];
   if (!$2) {
    continue;
   }
   sqlite3VtabDisconnect($0, $2);
   continue;
  }
  break;
 }
 sqlite3VtabUnlockList($0);
}

function deleteTable($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$1 + 8 >> 2];
 while (1) {
  if ($2) {
   $3 = HEAP32[$2 + 20 >> 2];
   if (!(HEAPU8[$1 + 43 | 0] == 1 | (HEAP32[$0 + 528 >> 2] ? $0 : 0))) {
    sqlite3HashInsert(HEAP32[$2 + 24 >> 2] + 24 | 0, HEAP32[$2 >> 2], 0);
   }
   sqlite3FreeIndex($0, $2);
   $2 = $3;
   continue;
  }
  break;
 }
 label$5: {
  label$6: {
   switch (HEAPU8[$1 + 43 | 0]) {
   case 0:
    sqlite3FkDelete($0, $1);
    break label$5;

   case 1:
    sqlite3VtabClear($0, $1);
    break label$5;

   default:
    break label$6;
   }
  }
  sqlite3SelectDelete($0, HEAP32[$1 + 44 >> 2]);
 }
 sqlite3DeleteColumnNames($0, $1);
 sqlite3DbFree($0, HEAP32[$1 >> 2]);
 sqlite3DbFree($0, HEAP32[$1 + 12 >> 2]);
 sqlite3ExprListDelete($0, HEAP32[$1 + 16 >> 2]);
 sqlite3DbFree($0, $1);
}

function btreeHeapPull($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $2 = HEAP32[$0 >> 2];
  if (!$2) {
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAP32[$0 + 4 >> 2];
  $1 = ($2 << 2) + $0 | 0;
  HEAP32[$0 + 4 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$1 >> 2] = -1;
  $3 = HEAP32[$0 >> 2] - 1 | 0;
  HEAP32[$0 >> 2] = $3;
  $2 = 1;
  while (1) {
   $1 = $2 << 1;
   if ($3 >>> 0 < $1 >>> 0) {
    return 1;
   }
   $6 = 1;
   $3 = ($2 << 2) + $0 | 0;
   $4 = HEAP32[$3 >> 2];
   $2 = $1 | 1;
   $1 = HEAPU32[($1 << 2) + $0 >> 2] > HEAPU32[($2 << 2) + $0 >> 2] ? $2 : $1;
   $2 = ($1 << 2) + $0 | 0;
   $5 = HEAP32[$2 >> 2];
   if ($4 >>> 0 < $5 >>> 0) {
    break label$1;
   }
   HEAP32[$3 >> 2] = $5;
   HEAP32[$2 >> 2] = $4;
   $3 = HEAP32[$0 >> 2];
   $2 = $1;
   continue;
  }
 }
 return $6;
}

function sqlite3LogEst($0, $1) {
 var $2 = 0;
 label$1: {
  label$2: {
   if (!$1 & $0 >>> 0 > 7 | $1) {
    $2 = 40;
    while (1) if (!$1 & $0 >>> 0 < 256) {
     while (1) {
      if (!$1 & $0 >>> 0 < 16) {
       break label$2;
      }
      $0 = ($1 & 1) << 31 | $0 >>> 1;
      $1 = $1 >>> 1 | 0;
      $2 = $2 + 10 | 0;
      continue;
     }
    } else {
     $0 = ($1 & 15) << 28 | $0 >>> 4;
     $1 = $1 >>> 4 | 0;
     $2 = $2 + 40 | 0;
     continue;
    }
   }
   $2 = 0;
   if (!$1 & $0 >>> 0 < 2) {
    break label$1;
   }
   $2 = 40;
   while (1) {
    if (!$1 & $0 >>> 0 > 7 | $1) {
     break label$2;
    }
    $1 = $1 << 1 | $0 >>> 31;
    $0 = $0 << 1;
    $2 = $2 - 10 | 0;
    continue;
   }
  }
  $2 = (HEAPU16[(($0 & 7) << 1) + 55216 >> 1] + $2 | 0) - 10 | 0;
 }
 return $2 << 16 >> 16;
}

function fts3CursorSeek($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if (!HEAPU8[$1 + 7 | 0]) {
  return 0;
 }
 $2 = fts3CursorSeekStmt($1);
 label$2: {
  label$3: {
   if ($2) {
    break label$3;
   }
   $2 = HEAP32[$1 >> 2];
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] + 1;
   sqlite3_bind_int64(HEAP32[$1 + 12 >> 2], 1, HEAP32[$1 + 32 >> 2], HEAP32[$1 + 36 >> 2]);
   HEAP8[$1 + 7 | 0] = 0;
   $3 = sqlite3_step(HEAP32[$1 + 12 >> 2]);
   HEAP32[$2 + 56 >> 2] = HEAP32[$2 + 56 >> 2] - 1;
   if (($3 | 0) == 100) {
    break label$2;
   }
   $2 = sqlite3_reset(HEAP32[$1 + 12 >> 2]);
   if ($2) {
    break label$3;
   }
   if (HEAP32[HEAP32[$1 >> 2] + 40 >> 2]) {
    break label$2;
   }
   HEAP8[$1 + 6 | 0] = 1;
   $2 = 267;
  }
  if ($0) {
   sqlite3_result_error_code($0, $2);
  }
  $4 = $2;
 }
 return $4;
}

function sqlite3ReadUtf8($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = $0 + 1 | 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     label$5: {
      $1 = HEAPU8[$0 | 0];
      $3 = HEAPU8[$1 + 56128 | 0];
      switch ($3 - 1 | 0) {
      case 0:
       break label$2;

      case 1:
       break label$3;

      case 2:
       break label$4;

      case 3:
       break label$5;

      default:
       break label$1;
      }
     }
     return 65533;
    }
    $2 = $0 + 2 | 0;
    $1 = HEAPU8[$0 + 1 | 0] + ($1 << 6) | 0;
   }
   $1 = HEAPU8[$2 | 0] + ($1 << 6) | 0;
   $2 = $2 + 1 | 0;
  }
  $0 = $3 << 2;
  $1 = (HEAPU8[$2 | 0] + ($1 << 6) | 0) - HEAP32[$0 + 56384 >> 2] | 0;
  $1 = HEAP32[$0 + 56400 >> 2] & $1 ? ($1 & -2048) == 55296 ? 65533 : ($1 & -2) == 65534 ? 65533 : $1 : 65533;
 }
 return $1;
}

function sqlite3GetUInt32($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $7 = $1;
 label$1: {
  while (1) {
   $1 = HEAPU8[$0 + $3 | 0];
   if ($1 - 58 >>> 0 >= 4294967286) {
    $2 = __wasm_i64_mul($5, $2, 10, 0);
    $5 = $2;
    $2 = $1 << 24;
    $1 = $2 >> 31;
    $6 = $2 >> 24;
    $2 = $1;
    $1 = i64toi32_i32$HIGH_BITS;
    $4 = $2 + $1 | 0;
    $2 = $5;
    $1 = $6 + $2 | 0;
    $5 = $1 - 48 | 0;
    $4 = $1 >>> 0 < $6 >>> 0 ? $4 + 1 | 0 : $4;
    $1 = $1 >>> 0 < 48;
    $1 = $4 - $1 | 0;
    $2 = $1;
    $4 = $5;
    if (($1 | 0) == 1 & ($4 | 0) != 0 | $1 >>> 0 > 1) {
     $1 = 0;
     $3 = 0;
     break label$1;
    } else {
     $3 = $3 + 1 | 0;
     continue;
    }
   }
   break;
  }
  $1 = !$1 & ($3 | 0) != 0;
  $3 = $1 ? $5 : 0;
 }
 HEAP32[$7 >> 2] = $3;
 return $1;
}

function resizeIndexObject($0, $1, $2) {
 var $3 = 0;
 if (HEAPU16[$1 + 52 >> 1] < ($2 | 0)) {
  $3 = Math_imul($2, 9);
  $0 = sqlite3DbMallocZero($0, $3, $3 >> 31);
  if (!$0) {
   return 7;
  }
  $0 = __memcpy($0, HEAP32[$1 + 32 >> 2], HEAPU16[$1 + 52 >> 1] << 2);
  HEAP32[$1 + 32 >> 2] = $0;
  $0 = __memcpy(($2 << 2) + $0 | 0, HEAP32[$1 + 8 >> 2], (HEAPU16[$1 + 50 >> 1] << 1) + 2 | 0);
  HEAP32[$1 + 8 >> 2] = $0;
  $3 = $2 << 1;
  $0 = __memcpy($3 + $0 | 0, HEAP32[$1 + 4 >> 2], HEAPU16[$1 + 52 >> 1] << 1);
  HEAP32[$1 + 4 >> 2] = $0;
  $0 = __memcpy($0 + $3 | 0, HEAP32[$1 + 28 >> 2], HEAPU16[$1 + 52 >> 1]);
  HEAP16[$1 + 52 >> 1] = $2;
  HEAP32[$1 + 28 >> 2] = $0;
  $0 = HEAPU8[$1 + 55 | 0] | HEAPU8[$1 + 56 | 0] << 8 | 16;
  HEAP8[$1 + 55 | 0] = $0;
  HEAP8[$1 + 56 | 0] = $0 >>> 8;
 }
 return 0;
}

function sqlite3BtreeIncrVacuum($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 $0 = 101;
 label$1: {
  if (!HEAPU8[$1 + 17 | 0]) {
   break label$1;
  }
  $2 = btreePagecount($1);
  $3 = sqlite3Get4byte(HEAP32[HEAP32[$1 + 12 >> 2] + 56 >> 2] + 36 | 0);
  $4 = finalDbSize($1, $2, $3);
  if (!($2 >>> 0 > $3 >>> 0 & $2 >>> 0 >= $4 >>> 0)) {
   return sqlite3CorruptError(70865);
  }
  if (!$3) {
   break label$1;
  }
  $0 = saveAllCursors($1, 0, 0);
  if ($0) {
   break label$1;
  }
  invalidateAllOverflowCache($1);
  $0 = incrVacuumStep($1, $4, $2, 0);
  if ($0) {
   break label$1;
  }
  $0 = sqlite3PagerWrite(HEAP32[HEAP32[$1 + 12 >> 2] + 72 >> 2]);
  sqlite3Put4byte(HEAP32[HEAP32[$1 + 12 >> 2] + 56 >> 2] + 28 | 0, HEAP32[$1 + 48 >> 2]);
 }
 return $0;
}

function renameParseSql($0, $1, $2, $3, $4) {
 var $5 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 sqlite3ParseObjectInit($0, $2);
 if (!$3) {
  return 7;
 }
 if (sqlite3_strnicmp($3, 29446, 7)) {
  return sqlite3CorruptError(111220);
 }
 $5 = 1;
 if (!$4) {
  $5 = sqlite3FindDbName($2, $1);
 }
 HEAP8[$2 + 176 | 0] = $5;
 HEAP32[$0 + 136 >> 2] = 1;
 HEAP32[$0 >> 2] = $2;
 HEAP8[$0 + 208 | 0] = 2;
 $3 = (wasm2js_i32$0 = 7, wasm2js_i32$1 = sqlite3RunParser($0, $3), wasm2js_i32$2 = HEAPU8[$2 + 87 | 0], 
 wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
 label$4: {
  if ($3) {
   break label$4;
  }
  $3 = 0;
  if (HEAP32[$0 + 244 >> 2] | (HEAP32[$0 + 236 >> 2] | HEAP32[$0 + 240 >> 2])) {
   break label$4;
  }
  $3 = sqlite3CorruptError(111231);
 }
 HEAP8[$2 + 176 | 0] = 0;
 return $3;
}

function vdbeMergeEngineLevel0($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $7 = HEAP32[$2 >> 2];
 $8 = HEAP32[$2 + 4 >> 2];
 $5 = vdbeMergeEngineNew($1);
 HEAP32[$3 >> 2] = $5;
 $6 = $5 ? 0 : 7;
 $11 = $0 + 40 | 0;
 while (1) {
  if (!(($1 | 0) <= ($9 | 0) | $6)) {
   HEAP32[$4 + 8 >> 2] = 0;
   HEAP32[$4 + 12 >> 2] = 0;
   $10 = HEAP32[$5 + 12 >> 2] + Math_imul($9, 56) | 0;
   $6 = vdbePmaReaderInit($0, $11, $7, $8, $10, $4 + 8 | 0);
   $7 = HEAP32[$10 + 8 >> 2];
   $8 = HEAP32[$10 + 12 >> 2];
   $9 = $9 + 1 | 0;
   continue;
  }
  break;
 }
 if ($6) {
  vdbeMergeEngineFree($5);
  HEAP32[$3 >> 2] = 0;
 }
 HEAP32[$2 >> 2] = $7;
 HEAP32[$2 + 4 >> 2] = $8;
 __stack_pointer = $4 + 16 | 0;
 return $6;
}

function exprSetHeight($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $1 = HEAP32[$0 + 12 >> 2];
 if ($1) {
  $1 = HEAP32[$1 + 24 >> 2];
 } else {
  $1 = 0;
 }
 HEAP32[$2 + 12 >> 2] = $1;
 $3 = HEAP32[$0 + 16 >> 2];
 label$3: {
  if (!$3) {
   break label$3;
  }
  $3 = HEAP32[$3 + 24 >> 2];
  if (($3 | 0) <= ($1 | 0)) {
   break label$3;
  }
  HEAP32[$2 + 12 >> 2] = $3;
 }
 $1 = HEAP32[$0 + 20 >> 2];
 label$4: {
  if (HEAPU8[$0 + 5 | 0] & 16) {
   heightOfSelect($1, $2 + 12 | 0);
   break label$4;
  }
  if (!$1) {
   break label$4;
  }
  heightOfExprList($1, $2 + 12 | 0);
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | sqlite3ExprListFlags(HEAP32[$0 + 20 >> 2]) & 4194824;
 }
 HEAP32[$0 + 24 >> 2] = HEAP32[$2 + 12 >> 2] + 1;
 __stack_pointer = $2 + 16 | 0;
}

function selectAddSubqueryTypeInfo($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $2 = HEAP32[$1 + 4 >> 2];
  if ($2 & 128) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = $2 | 128;
  $3 = HEAP32[$1 + 32 >> 2];
  $2 = $3 + 8 | 0;
  $6 = HEAP32[$0 >> 2];
  while (1) {
   if (HEAP32[$3 >> 2] <= ($4 | 0)) {
    break label$1;
   }
   $5 = HEAP32[$2 + 16 >> 2];
   label$3: {
    if (!(HEAPU8[$5 + 29 | 0] & 64)) {
     break label$3;
    }
    $1 = HEAP32[$2 + 20 >> 2];
    if (!$1) {
     break label$3;
    }
    while (1) {
     $0 = $1;
     $1 = HEAP32[$1 + 52 >> 2];
     if ($1) {
      continue;
     }
     break;
    }
    sqlite3SelectAddColumnTypeAndCollation($6, $5, $0, 64);
   }
   $2 = $2 - -64 | 0;
   $4 = $4 + 1 | 0;
   continue;
  }
 }
}

function fts3EvalNearTrim($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$4 + 64 >> 2];
 $7 = HEAP32[$3 >> 2];
 $8 = HEAP32[$4 + 28 >> 2];
 HEAP32[$5 + 12 >> 2] = $8;
 HEAP32[$5 + 8 >> 2] = $8;
 $0 = fts3PoslistNearMerge($5 + 8 | 0, $1, $0 + $6 | 0, $0 + $7 | 0, $2, $5 + 12 | 0);
 if ($0) {
  $1 = HEAP32[$4 + 28 >> 2];
  $6 = HEAP32[$5 + 8 >> 2] + ($1 ^ -1) | 0;
  label$2: {
   if (($6 | 0) < 0) {
    break label$2;
   }
   $7 = HEAP32[$4 + 32 >> 2];
   if (($7 | 0) < ($6 | 0)) {
    break label$2;
   }
   memset($1 + $6 | 0, 0, $7 - $6 | 0);
   HEAP32[$4 + 32 >> 2] = $6;
   $1 = HEAP32[$4 + 28 >> 2];
  }
  HEAP32[$2 >> 2] = $1;
  HEAP32[$3 >> 2] = HEAP32[$4 + 64 >> 2];
 }
 __stack_pointer = $5 + 16 | 0;
 return $0;
}

function walIndexTryHdr($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 $3 = walIndexHdr($0);
 __memcpy($2 + 56 | 0, $3, 48);
 walShmBarrier($0);
 __memcpy($2 + 8 | 0, $3 + 48 | 0, 48);
 $3 = 1;
 label$1: {
  if (memcmp($2 + 56 | 0, $2 + 8 | 0, 48) | !HEAPU8[$2 + 68 | 0]) {
   break label$1;
  }
  walChecksumBytes(1, $2 + 56 | 0, 40, 0, $2 + 104 | 0);
  if (HEAP32[$2 + 104 >> 2] != HEAP32[$2 + 96 >> 2] | HEAP32[$2 + 108 >> 2] != HEAP32[$2 + 100 >> 2]) {
   break label$1;
  }
  $3 = 0;
  $4 = $0 + 52 | 0;
  if (!memcmp($4, $2 + 56 | 0, 48)) {
   break label$1;
  }
  HEAP32[$1 >> 2] = 1;
  __memcpy($4, $2 + 56 | 0, 48);
  $1 = HEAPU16[$0 + 66 >> 1];
  HEAP32[$0 + 36 >> 2] = ($1 | $1 << 16) & 130560;
 }
 __stack_pointer = $2 + 112 | 0;
 return $3;
}

function sqlite3VdbeFindCompare($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = 27;
 $3 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU16[$3 + 8 >> 1] > 13) {
   break label$1;
  }
  $2 = HEAP32[$0 + 4 >> 2];
  $5 = HEAPU16[$2 + 16 >> 1];
  $1 = HEAPU8[HEAP32[$3 + 16 >> 2]];
  label$2: {
   if (!$1) {
    $1 = 1;
    $6 = 255;
    break label$2;
   }
   if ($1 & 2) {
    break label$1;
   }
   $1 = 255;
   $6 = 1;
  }
  HEAP8[$0 + 25 | 0] = $1;
  HEAP8[$0 + 24 | 0] = $6;
  if ($5 & 4) {
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP32[$0 + 8 >> 2] = HEAP32[$2 >> 2];
   HEAP32[$0 + 12 >> 2] = $1;
   return 28;
  }
  if (HEAP32[$3 + 20 >> 2] | $5 & 57) {
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = HEAP32[$2 + 8 >> 2];
  HEAP32[$0 + 16 >> 2] = HEAP32[$2 + 12 >> 2];
  $4 = 29;
 }
 return $4;
}

function ptrmapGet($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 $6 = ptrmapPageno($0, $1);
 $0 = sqlite3PagerGet($5, $6, $4 + 12 | 0, 0);
 label$1: {
  if ($0) {
   break label$1;
  }
  $0 = HEAP32[$4 + 12 >> 2];
  $5 = sqlite3PagerGetData($0);
  $1 = Math_imul(($6 ^ -1) + $1 | 0, 5);
  label$2: {
   if (($1 | 0) < 0) {
    sqlite3PagerUnref($0);
    $1 = 67925;
    break label$2;
   }
   $1 = $1 + $5 | 0;
   HEAP8[$2 | 0] = HEAPU8[$1 | 0];
   if ($3) {
    HEAP32[$3 >> 2] = sqlite3Get4byte($1 + 1 | 0);
   }
   sqlite3PagerUnref($0);
   $0 = 0;
   $1 = 67933;
   if ((HEAPU8[$2 | 0] - 6 & 255) >>> 0 > 250) {
    break label$1;
   }
  }
  $0 = sqlite3CorruptError($1);
 }
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function fts3ReversePoslist($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = HEAP32[$1 >> 2];
 $3 = $5 - 2 | 0;
 while (1) {
  label$2: {
   if ($0 >>> 0 >= $3 >>> 0) {
    $4 = 0;
    $2 = $3;
    break label$2;
   }
   $4 = HEAPU8[$3 | 0];
   $2 = $3 - 1 | 0;
   $3 = $2;
   if (!$4) {
    continue;
   }
  }
  break;
 }
 label$4: {
  label$5: {
   while (1) {
    if ($0 >>> 0 < $2 >>> 0) {
     $3 = $4 << 24;
     $4 = HEAPU8[$2 | 0];
     if (!($4 & 128 | $3 >> 24)) {
      break label$5;
     }
     $2 = $2 - 1 | 0;
     continue;
    }
    break;
   }
   if ($4 & 255 | $2 + 2 >>> 0 >= $5 >>> 0) {
    break label$4;
   }
  }
  $2 = $2 + 2 | 0;
 }
 while (1) {
  $3 = HEAP8[$2 | 0];
  $4 = $2 + 1 | 0;
  $2 = $4;
  if (($3 | 0) < 0) {
   continue;
  }
  break;
 }
 HEAP32[$1 >> 2] = $4;
}

function multiSelectValues($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $6 = HEAP32[$1 + 60 >> 2];
 $7 = !$6;
 $5 = 1;
 label$1: {
  while (1) {
   if (HEAP32[$1 + 68 >> 2]) {
    $3 = -1;
    break label$1;
   }
   $3 = HEAP32[$1 + 52 >> 2];
   if ($3) {
    $5 = $5 + $7 | 0;
    $1 = $3;
    continue;
   }
   break;
  }
  HEAP32[$4 >> 2] = $5;
  HEAP32[$4 + 4 >> 2] = ($5 | 0) == 1 ? 29623 : 18895;
  sqlite3VdbeExplain($0, 0, 5806, $4);
  while (1) {
   if (!$1) {
    $3 = 0;
    break label$1;
   }
   $3 = 0;
   selectInnerLoop($0, $1, -1, 0, 0, $2, 1, 1);
   if ($6) {
    break label$1;
   }
   HEAP16[$1 + 2 >> 1] = $5;
   $1 = HEAP32[$1 + 56 >> 2];
   continue;
  }
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function subjRequiresPage($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $2 = HEAP32[$0 + 20 >> 2];
 $1 = HEAP32[$2 + 104 >> 2];
 $6 = ($1 | 0) > 0 ? $1 : 0;
 $3 = HEAP32[$0 + 24 >> 2];
 $0 = 0;
 while (1) {
  label$2: {
   if (($0 | 0) == ($6 | 0)) {
    break label$2;
   }
   label$3: {
    $4 = HEAP32[$2 + 100 >> 2];
    $5 = $4 + Math_imul($0, 48) | 0;
    if (HEAPU32[$5 + 20 >> 2] < $3 >>> 0) {
     break label$3;
    }
    if (sqlite3BitvecTestNotNull(HEAP32[$5 + 16 >> 2], $3)) {
     break label$3;
    }
    while (1) {
     $7 = 1;
     $0 = $0 + 1 | 0;
     if (($1 | 0) <= ($0 | 0)) {
      break label$2;
     }
     HEAP32[(Math_imul($0, 48) + $4 | 0) + 28 >> 2] = 0;
     continue;
    }
   }
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 return $7;
}

function sqlite3Fts3AllSegdirs($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = 0;
 label$1: {
  if (($3 | 0) < 0) {
   $6 = fts3SqlStmt($0, 13, $5 + 12 | 0, 0);
   if ($6) {
    break label$1;
   }
   $6 = 0;
   $3 = HEAP32[$5 + 12 >> 2];
   sqlite3_bind_int64($3, 1, getAbsoluteLevel($0, $1, $2, 0), i64toi32_i32$HIGH_BITS);
   sqlite3_bind_int64($3, 2, getAbsoluteLevel($0, $1, $2, 1023), i64toi32_i32$HIGH_BITS);
   break label$1;
  }
  $6 = fts3SqlStmt($0, 12, $5 + 12 | 0, 0);
  if ($6) {
   break label$1;
  }
  sqlite3_bind_int64(HEAP32[$5 + 12 >> 2], 1, getAbsoluteLevel($0, $1, $2, $3), i64toi32_i32$HIGH_BITS);
  $6 = 0;
 }
 HEAP32[$4 >> 2] = HEAP32[$5 + 12 >> 2];
 __stack_pointer = $5 + 16 | 0;
 return $6;
}

function sqlite3BtreeCloseCursor($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 8 >> 2];
 if ($3) {
  $1 = HEAP32[$0 + 20 >> 2];
  sqlite3BtreeEnter($3);
  $2 = HEAP32[$1 + 8 >> 2];
  label$2: {
   if (($2 | 0) == ($0 | 0)) {
    HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 24 >> 2];
    break label$2;
   }
   while (1) {
    $4 = HEAP32[$2 + 24 >> 2];
    if (($4 | 0) == ($0 | 0)) {
     HEAP32[$2 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
     break label$2;
    }
    $2 = $4;
    if ($2) {
     continue;
    }
    break;
   }
  }
  btreeReleaseAllCursorPages($0);
  unlockBtreeIfUnused($1);
  sqlite3_free(HEAP32[$0 + 12 >> 2]);
  sqlite3_free(HEAP32[$0 + 16 >> 2]);
  if (!(HEAP32[$1 + 8 >> 2] | !(HEAPU8[$1 + 16 | 0] & 4))) {
   sqlite3BtreeClose($3);
  }
  HEAP32[$0 + 8 >> 2] = 0;
 }
}

function invokeProfileCallback($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 sqlite3OsCurrentTimeInt64(HEAP32[$0 >> 2], $2 + 8 | 0);
 $4 = HEAP32[$2 + 8 >> 2];
 $5 = HEAP32[$1 + 136 >> 2];
 $3 = HEAP32[$1 + 140 >> 2] + ($4 >>> 0 < $5 >>> 0) | 0;
 $3 = HEAP32[$2 + 12 >> 2] - $3 | 0;
 $4 = __wasm_i64_mul($4 - $5 | 0, $3, 1e6, 0);
 $3 = i64toi32_i32$HIGH_BITS;
 HEAP32[$2 >> 2] = $4;
 HEAP32[$2 + 4 >> 2] = $3;
 $5 = HEAP32[$0 + 220 >> 2];
 if ($5) {
  FUNCTION_TABLE[$5 | 0](HEAP32[$0 + 224 >> 2], HEAP32[$1 + 196 >> 2], $4, $3);
 }
 if (HEAPU8[$0 + 94 | 0] & 2) {
  FUNCTION_TABLE[HEAP32[$0 + 212 >> 2]](2, HEAP32[$0 + 216 >> 2], $1, $2) | 0;
 }
 HEAP32[$1 + 136 >> 2] = 0;
 HEAP32[$1 + 140 >> 2] = 0;
 __stack_pointer = $2 + 16 | 0;
}

function sqlite3_vtab_config($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = HEAP32[$0 + 400 >> 2];
 label$1: {
  if (!$4) {
   $2 = sqlite3MisuseError(148539);
   break label$1;
  }
  HEAP32[$3 + 12 >> 2] = $2;
  label$3: {
   switch ($1 - 1 | 0) {
   case 0:
    $2 = HEAP32[$3 + 12 >> 2];
    HEAP32[$3 + 12 >> 2] = $2 + 4;
    HEAP8[HEAP32[$4 >> 2] + 16 | 0] = HEAP32[$2 >> 2];
    $2 = 0;
    break label$1;

   case 1:
    HEAP8[HEAP32[$4 >> 2] + 17 | 0] = 0;
    $2 = 0;
    break label$1;

   case 2:
    HEAP8[HEAP32[$4 >> 2] + 17 | 0] = 2;
    $2 = 0;
    break label$1;

   default:
    break label$3;
   }
  }
  $2 = sqlite3MisuseError(148557);
 }
 if ($2) {
  sqlite3Error($0, $2);
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function simpleCreate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = sqlite3_malloc(132);
 if (!$3) {
  return 7;
 }
 $3 = memset($3, 0, 132);
 label$2: {
  if (($0 | 0) < 2) {
   $0 = 1;
   while (1) {
    if (($0 | 0) == 128) {
     break label$2;
    }
    HEAP8[($0 + $3 | 0) + 4 | 0] = fts3_isalnum($0) ? 0 : -1;
    $0 = $0 + 1 | 0;
    continue;
   }
  }
  $0 = strlen(HEAP32[$1 + 4 >> 2]);
  $5 = ($0 | 0) > 0 ? $0 : 0;
  $0 = 0;
  while (1) {
   if (($0 | 0) == ($5 | 0)) {
    break label$2;
   }
   $4 = HEAP8[HEAP32[$1 + 4 >> 2] + $0 | 0];
   if (($4 | 0) >= 0) {
    HEAP8[(($4 & 255) + $3 | 0) + 4 | 0] = 1;
    $0 = $0 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_free($3);
  return 1;
 }
 HEAP32[$2 >> 2] = $3;
 return 0;
}

function sqlite3BeginTransaction($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$0 >> 2];
 label$1: {
  if (sqlite3AuthCheck($0, 22, 19447, 0, 0)) {
   break label$1;
  }
  $2 = sqlite3GetVdbe($0);
  if (!$2) {
   break label$1;
  }
  label$2: {
   if (($1 | 0) == 7) {
    break label$2;
   }
   $5 = ($1 | 0) == 9 ? 2 : 1;
   $0 = 0;
   while (1) {
    if (HEAP32[$3 + 20 >> 2] <= ($0 | 0)) {
     break label$2;
    }
    $4 = HEAP32[(HEAP32[$3 + 16 >> 2] + ($0 << 4) | 0) + 4 >> 2];
    label$4: {
     if ($4) {
      $1 = 0;
      if (sqlite3BtreeIsReadonly($4)) {
       break label$4;
      }
     }
     $1 = $5;
    }
    sqlite3VdbeAddOp2($2, 2, $0, $1);
    sqlite3VdbeUsesBtree($2, $0);
    $0 = $0 + 1 | 0;
    continue;
   }
  }
  sqlite3VdbeAddOp0($2, 1);
 }
}

function sift($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $6 = __stack_pointer - 240 | 0;
 __stack_pointer = $6;
 HEAP32[$6 >> 2] = $0;
 $7 = 1;
 label$1: {
  if (($3 | 0) < 2) {
   break label$1;
  }
  $11 = 0 - $1 | 0;
  $5 = $0;
  while (1) {
   $5 = $5 + $11 | 0;
   $9 = $3 - 2 | 0;
   $8 = $5 - HEAP32[($9 << 2) + $4 >> 2] | 0;
   if ((FUNCTION_TABLE[$2 | 0]($0, $8) | 0) >= 0) {
    if ((FUNCTION_TABLE[$2 | 0]($0, $5) | 0) >= 0) {
     break label$1;
    }
   }
   $10 = (FUNCTION_TABLE[$2 | 0]($8, $5) | 0) >= 0;
   $5 = $10 ? $8 : $5;
   HEAP32[($7 << 2) + $6 >> 2] = $5;
   $7 = $7 + 1 | 0;
   $3 = $10 ? $3 - 1 | 0 : $9;
   if (($3 | 0) > 1) {
    continue;
   }
   break;
  }
 }
 cycle($1, $6, $7);
 __stack_pointer = $6 + 240 | 0;
}

function sqlite3AddNotNull($0, $1) {
 var $2 = 0;
 label$1: {
  $2 = HEAP32[$0 + 236 >> 2];
  if (!$2) {
   break label$1;
  }
  $0 = HEAP16[$2 + 34 >> 1];
  if (($0 | 0) <= 0) {
   break label$1;
  }
  $0 = (HEAP32[$2 + 4 >> 2] + Math_imul($0 & 65535, 12) | 0) - 12 | 0;
  HEAP8[$0 + 4 | 0] = HEAPU8[$0 + 4 | 0] & 240 | $1 & 15;
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] | 2048;
  if (!(HEAPU8[$0 + 10 | 0] & 8)) {
   break label$1;
  }
  $0 = $2 + 8 | 0;
  while (1) {
   $0 = HEAP32[$0 >> 2];
   if (!$0) {
    break label$1;
   }
   if (HEAP16[HEAP32[$0 + 4 >> 2] >> 1] == (HEAP16[$2 + 34 >> 1] - 1 | 0)) {
    $1 = HEAPU8[$0 + 55 | 0] | HEAPU8[$0 + 56 | 0] << 8 | 8;
    HEAP8[$0 + 55 | 0] = $1;
    HEAP8[$0 + 56 | 0] = $1 >>> 8;
   }
   $0 = $0 + 20 | 0;
   continue;
  }
 }
}

function sqlite3BitvecTestNotNull($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $1 = $1 - 1 | 0;
  if ($1 >>> 0 >= HEAPU32[$0 >> 2]) {
   break label$1;
  }
  while (1) {
   $2 = HEAP32[$0 + 8 >> 2];
   if ($2) {
    $3 = ($1 >>> 0) / ($2 >>> 0) | 0;
    $1 = $1 - Math_imul($3, $2) | 0;
    $0 = HEAP32[(($3 << 2) + $0 | 0) + 12 >> 2];
    if ($0) {
     continue;
    }
    break label$1;
   }
   break;
  }
  if (HEAPU32[$0 >> 2] <= 4e3) {
   return HEAPU8[(($1 >>> 3 | 0) + $0 | 0) + 12 | 0] >>> ($1 & 7) & 1;
  }
  $2 = $0 + 12 | 0;
  $3 = $1 + 1 | 0;
  while (1) {
   $1 = ($1 >>> 0) % 125 | 0;
   $0 = HEAP32[($1 << 2) + $2 >> 2];
   if (!$0) {
    break label$1;
   }
   $1 = $1 + 1 | 0;
   if (($0 | 0) != ($3 | 0)) {
    continue;
   }
   break;
  }
  return 1;
 }
 return 0;
}

function resolveAlias($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 $5 = HEAP32[$0 >> 2];
 $2 = sqlite3ExprDup($5, HEAP32[(($2 << 4) + $1 | 0) + 8 >> 2], 0);
 label$1: {
  if (HEAPU8[$5 + 87 | 0]) {
   sqlite3ExprDelete($5, $2);
   break label$1;
  }
  incrAggFunctionDepth($2, $4);
  if (HEAPU8[$3 | 0] == 113) {
   $2 = sqlite3ExprAddCollateString($0, $2, HEAP32[$3 + 8 >> 2]);
  }
  __memcpy($6 + 8 | 0, $2, 52);
  $2 = __memcpy($2, $3, 52);
  $5 = __memcpy($3, $6 + 8 | 0, 52);
  label$4: {
   if (!(HEAP8[$5 + 7 | 0] & 1)) {
    break label$4;
   }
   $3 = HEAP32[$5 + 44 >> 2];
   if (!$3) {
    break label$4;
   }
   HEAP32[$3 + 72 >> 2] = $5;
  }
  sqlite3ParserAddCleanup($0, 69, $2);
 }
 __stack_pointer = $6 - -64 | 0;
}

function fts3RemoveElementByHash($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$1 >> 2];
 $4 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if ($4) {
   HEAP32[$4 >> 2] = $3;
   $3 = HEAP32[$1 >> 2];
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = $3;
 }
 if ($3) {
  HEAP32[$3 + 4 >> 2] = $4;
 }
 $4 = HEAP32[$0 + 16 >> 2] + ($2 << 3) | 0;
 if (HEAP32[$4 + 4 >> 2] == ($1 | 0)) {
  HEAP32[$4 + 4 >> 2] = $3;
 }
 $3 = HEAP32[$4 >> 2];
 HEAP32[$4 >> 2] = $3 - 1;
 if (($3 | 0) <= 1) {
  HEAP32[$4 + 4 >> 2] = 0;
 }
 label$6: {
  if (!HEAPU8[$0 + 1 | 0]) {
   break label$6;
  }
  $3 = HEAP32[$1 + 12 >> 2];
  if (!$3) {
   break label$6;
  }
  fts3HashFree($3);
 }
 fts3HashFree($1);
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = $1 - 1;
 if (($1 | 0) <= 1) {
  sqlite3Fts3HashClear($0);
 }
}

function pcache1AllocPage($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  label$2: {
   $2 = HEAP32[$0 + 60 >> 2];
   if (!$2) {
    if (HEAP32[$0 + 48 >> 2]) {
     break label$2;
    }
    if (!pcache1InitBulk($0)) {
     break label$2;
    }
    $2 = HEAP32[$0 + 60 >> 2];
   }
   HEAP32[$0 + 60 >> 2] = HEAP32[$2 + 16 >> 2];
   $1 = $2 + 16 | 0;
   break label$1;
  }
  if ($1) {
   sqlite3BeginBenignMalloc();
  }
  $3 = pcache1Alloc(HEAP32[$0 + 16 >> 2]);
  if ($1) {
   sqlite3EndBenignMalloc();
  }
  if (!$3) {
   return 0;
  }
  $2 = HEAP32[$0 + 8 >> 2] + $3 | 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 >> 2] = $3;
  HEAP32[$2 + 4 >> 2] = $2 + 32;
  $1 = $2 + 28 | 0;
 }
 HEAP32[$1 >> 2] = 0;
 $0 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
 return $2;
}

function minmaxStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$2 >> 2];
 label$1: {
  $2 = sqlite3_aggregate_context($0, 40);
  label$2: {
   if (!$2) {
    break label$2;
   }
   $1 = HEAPU16[$2 + 16 >> 1];
   if ((sqlite3_value_type($3) | 0) == 5) {
    if (!($1 & 65535)) {
     break label$2;
    }
    break label$1;
   }
   if ($1 & 65535) {
    $4 = sqlite3GetFuncCollSeq($0);
    $1 = sqlite3_user_data($0);
    $4 = sqlite3MemCompare($2, $3, $4);
    if (!(($4 | 0) <= 0 | $1 ? ($4 | 0) < 0 ? $1 : 0 : 1)) {
     break label$1;
    }
    sqlite3VdbeMemCopy($2, $3);
    return;
   }
   HEAP32[$2 + 20 >> 2] = sqlite3_context_db_handle($0);
   sqlite3VdbeMemCopy($2, $3);
  }
  return;
 }
 sqlite3SkipAccumulatorLoad($0);
}

function specialcase($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 if (!(0 | $3 & -2147483648)) {
  wasm2js_scratch_store_i32(0, $1 | 0);
  $1 = $2;
  wasm2js_scratch_store_i32(1, $1 - 1058013184 | 0);
  $5 = +wasm2js_scratch_load_f64();
  return ($5 * $0 + $5) * 5486124068793689e288;
 }
 $3 = __stack_pointer - 16 | 0;
 wasm2js_scratch_store_i32(0, $1 | 0);
 wasm2js_scratch_store_i32(1, $2 + 1071644672 | 0);
 $5 = +wasm2js_scratch_load_f64();
 $6 = $5 * $0;
 $0 = $6 + $5;
 if ($0 < 1) {
  $1 = $3;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 1048576;
  HEAPF64[$1 + 8 >> 3] = HEAPF64[$1 + 8 >> 3] * 22250738585072014e-324;
  $7 = $0 + 1;
  $0 = $7 + ($6 + ($5 - $0) + ($0 + (1 - $7))) + -1;
  $0 = $0 == 0 ? 0 : $0;
 }
 return $0 * 22250738585072014e-324;
}

function sameSrcAlias($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$1 >> 2];
 $4 = ($3 | 0) > 0 ? $3 : 0;
 $3 = 0;
 label$1: {
  while (1) {
   if (($3 | 0) == ($4 | 0)) {
    break label$1;
   }
   label$3: {
    $2 = ($3 << 6) + $1 | 0;
    label$4: {
     if (($2 + 8 | 0) == ($0 | 0)) {
      break label$4;
     }
     if (HEAP32[$0 + 16 >> 2] == HEAP32[$2 + 24 >> 2]) {
      if (!sqlite3_stricmp(HEAP32[$0 + 12 >> 2], HEAP32[$2 + 20 >> 2])) {
       break label$3;
      }
     }
     $2 = HEAP32[$2 + 28 >> 2];
     if (!$2 | !(HEAPU8[$2 + 5 | 0] & 8)) {
      break label$4;
     }
     if (sameSrcAlias($0, HEAP32[$2 + 32 >> 2])) {
      break label$3;
     }
    }
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  $5 = 1;
 }
 return $5;
}

function signFunc_1($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (($1 | 0) == 1) {
  label$2: {
   switch (sqlite3_value_type(HEAP32[$2 >> 2]) - 1 | 0) {
   case 0:
    $2 = sqlite3_value_int64(HEAP32[$2 >> 2]);
    $3 = i64toi32_i32$HIGH_BITS;
    $1 = ($3 | $2) != 0;
    $5 = $1 ? -1 : 0;
    $6 = $1 ? -1 : 0;
    $1 = $2;
    $3 = !$1 & ($3 | 0) <= 0 | ($3 | 0) < 0;
    $1 = $5;
    sqlite3_result_int64($0, $3 ? $6 : 1, $3 ? $1 : 0);
    return;

   case 4:
    sqlite3_result_null($0);
    return;

   default:
    break label$2;
   }
  }
  $4 = sqlite3_value_double(HEAP32[$2 >> 2]);
  sqlite3_result_double($0, $4 > 0 ? 1 : $4 < 0 ? -1 : 0);
  return;
 }
 __assert_fail(23175, 17353, 590, 17126);
 abort();
}

function __syscall_munmap($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 $3 = -28;
 $2 = find_mapping($0, $4 + 12 | 0);
 label$1: {
  if (!$1 | !$2 | HEAP32[$2 + 4 >> 2] != ($1 | 0)) {
   break label$1;
  }
  $3 = HEAP32[$4 + 12 >> 2];
  HEAP32[($3 ? $3 + 36 | 0 : 71096) >> 2] = HEAP32[$2 + 36 >> 2];
  $3 = HEAP32[$2 + 16 >> 2];
  if (!($3 & 32)) {
   $3 = _munmap_js($0 | 0, $1 | 0, HEAP32[$2 + 32 >> 2], $3 | 0, HEAP32[$2 + 12 >> 2], HEAP32[$2 + 24 >> 2]) | 0;
   if ($3) {
    break label$1;
   }
  }
  if (HEAP32[$2 + 8 >> 2]) {
   dlfree(HEAP32[$2 >> 2]);
  }
  $3 = 0;
  if (HEAPU8[$2 + 16 | 0] & 32) {
   break label$1;
  }
  dlfree($2);
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function _ZN17compiler_builtins3int4sdiv3Mod4mod_17h2cbb7bbf36e41d68E($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
 $6 = $1;
 $4 = $6 >> 31;
 $8 = $4;
 $7 = $6 >> 31;
 $6 = $7;
 $4 = $0 ^ $6;
 $0 = $4 - $6 | 0;
 $9 = $0;
 $6 = $8;
 $5 = $6 + ($4 >>> 0 < $7 >>> 0) | 0;
 $5 = ($1 ^ $6) - $5 | 0;
 $10 = $5;
 $5 = $3;
 $4 = $5 >> 31;
 $1 = $4;
 $0 = $5 >> 31;
 $5 = $0;
 $4 = $5 ^ $2;
 $6 = $4 - $5 | 0;
 $5 = $1;
 $0 = $5 + ($0 >>> 0 > $4 >>> 0) | 0;
 $0 = ($3 ^ $5) - $0 | 0;
 $4 = $0;
 $0 = $10;
 $4 = __wasm_i64_urem($9, $0, $6, $4);
 $1 = $4;
 $4 = $8;
 $0 = i64toi32_i32$HIGH_BITS;
 $4 = $4 ^ $0;
 $0 = $7 ^ $1;
 $5 = $0 - $7 | 0;
 $6 = ($0 >>> 0 < $7 >>> 0) + $8 | 0;
 $6 = $4 - $6 | 0;
 i64toi32_i32$HIGH_BITS = $6;
 return $5;
}

function sqlite3DecOrHexToI64($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 if (!(HEAPU8[$0 | 0] != 48 | (HEAPU8[$0 + 1 | 0] | 32) != 120)) {
  $2 = 2;
  while (1) {
   $6 = $2;
   $2 = $2 + 1 | 0;
   $5 = HEAPU8[$0 + $6 | 0];
   if (($5 | 0) == 48) {
    continue;
   }
   break;
  }
  $2 = $6;
  while (1) {
   if (HEAPU8[$5 + 30288 | 0] & 8) {
    $7 = $3 << 4;
    $4 = $4 << 4 | $3 >>> 28;
    $3 = sqlite3HexToInt($5 << 24 >> 24) + $7 | 0;
    $4 = $3 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
    $2 = $2 + 1 | 0;
    $5 = HEAPU8[$2 + $0 | 0];
    continue;
   }
   break;
  }
  HEAP32[$1 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = $4;
  return HEAPU8[$0 + $2 | 0] ? 2 : (($2 - $6 | 0) > 16) << 1;
 }
 return sqlite3Atoi64($0, $1, sqlite3Strlen30($0), 1);
}

function sqlite3BtreeSetVersion($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$0 + 4 >> 2];
 HEAP16[$3 + 24 >> 1] = HEAPU16[$3 + 24 >> 1] & 65503 | (($1 | 0) == 1) << 5;
 $2 = sqlite3BtreeBeginTrans($0, 0, 0);
 label$1: {
  if ($2) {
   break label$1;
  }
  $4 = HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2];
  $5 = HEAPU8[$4 + 18 | 0];
  if (($5 | 0) == ($1 & 255)) {
   $2 = 0;
   if (HEAPU8[$4 + 19 | 0] == ($5 | 0)) {
    break label$1;
   }
  }
  $2 = sqlite3BtreeBeginTrans($0, 2, 0);
  if ($2) {
   break label$1;
  }
  $2 = sqlite3PagerWrite(HEAP32[HEAP32[$3 + 12 >> 2] + 72 >> 2]);
  if ($2) {
   break label$1;
  }
  HEAP8[$4 + 19 | 0] = $1;
  HEAP8[$4 + 18 | 0] = $1;
  $2 = 0;
 }
 HEAP16[$3 + 24 >> 1] = HEAPU16[$3 + 24 >> 1] & 65503;
 return $2;
}

function unixShmPurge($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[HEAP32[$0 + 8 >> 2] + 40 >> 2];
 if (!(!$1 | HEAP32[$1 + 28 >> 2])) {
  $3 = unixShmRegionPerMap();
  while (1) {
   if (($2 | 0) < HEAPU16[$1 + 20 >> 1]) {
    label$4: {
     if (HEAP32[$1 + 12 >> 2] >= 0) {
      FUNCTION_TABLE[HEAP32[16306]](HEAP32[HEAP32[$1 + 24 >> 2] + ($2 << 2) >> 2], HEAP32[$1 + 16 >> 2]) | 0;
      break label$4;
     }
     sqlite3_free(HEAP32[HEAP32[$1 + 24 >> 2] + ($2 << 2) >> 2]);
    }
    $2 = $2 + $3 | 0;
    continue;
   }
   break;
  }
  sqlite3_free(HEAP32[$1 + 24 >> 2]);
  $2 = HEAP32[$1 + 12 >> 2];
  if (($2 | 0) >= 0) {
   robust_close($0, $2, 39958);
   HEAP32[$1 + 12 >> 2] = -1;
  }
  HEAP32[HEAP32[$1 >> 2] + 40 >> 2] = 0;
  sqlite3_free($1);
 }
}

function valueToText($0, $1) {
 var $2 = 0;
 $2 = HEAPU16[$0 + 16 >> 1];
 label$1: {
  label$2: {
   if ($2 & 18) {
    if ($2 & 1024) {
     $2 = 0;
     if (sqlite3VdbeMemExpandBlob($0)) {
      break label$1;
     }
     $2 = HEAPU16[$0 + 16 >> 1];
    }
    HEAP16[$0 + 16 >> 1] = $2 | 2;
    $2 = $1 & 247;
    if (($2 | 0) != HEAPU8[$0 + 18 | 0]) {
     sqlite3VdbeChangeEncoding($0, $2);
    }
    if (!(!($1 & 8) | !(HEAP8[$0 + 8 | 0] & 1))) {
     $2 = 0;
     if (sqlite3VdbeMemMakeWriteable($0)) {
      break label$1;
     }
    }
    sqlite3VdbeMemNulTerminate($0);
    break label$2;
   }
   sqlite3VdbeMemStringify($0, $1, 0);
  }
  $2 = 0;
  if (HEAPU8[$0 + 18 | 0] != ($1 & 247)) {
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2];
 }
 return $2;
}

function sqlite3FkDelete($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$1 + 48 >> 2];
 while (1) {
  if ($2) {
   label$3: {
    if (HEAP32[$0 + 528 >> 2] ? $0 : 0) {
     break label$3;
    }
    $3 = HEAP32[$2 + 12 >> 2];
    $4 = HEAP32[$2 + 16 >> 2];
    label$5: {
     if ($4) {
      HEAP32[$4 + 12 >> 2] = $3;
      break label$5;
     }
     sqlite3HashInsert(HEAP32[$1 + 60 >> 2] + 56 | 0, HEAP32[($3 ? $3 : $2) + 8 >> 2], $3);
    }
    $3 = HEAP32[$2 + 12 >> 2];
    if (!$3) {
     break label$3;
    }
    HEAP32[$3 + 16 >> 2] = HEAP32[$2 + 16 >> 2];
   }
   fkTriggerDelete($0, HEAP32[$2 + 28 >> 2]);
   fkTriggerDelete($0, HEAP32[$2 + 32 >> 2]);
   $3 = HEAP32[$2 + 4 >> 2];
   sqlite3DbFree($0, $2);
   $2 = $3;
   continue;
  }
  break;
 }
}

function varianceStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if (($1 | 0) == 1) {
  $1 = sqlite3_aggregate_context($0, 24);
  if ((sqlite3_value_numeric_type(HEAP32[$2 >> 2]) | 0) != 5) {
   $0 = HEAP32[$1 + 20 >> 2];
   $5 = HEAP32[$1 + 16 >> 2] + 1 | 0;
   $0 = $5 ? $0 : $0 + 1 | 0;
   HEAP32[$1 + 16 >> 2] = $5;
   HEAP32[$1 + 20 >> 2] = $0;
   $6 = sqlite3_value_double(HEAP32[$2 >> 2]);
   $3 = HEAPF64[$1 >> 3];
   $4 = $3;
   $3 = $6 - $3;
   $0 = HEAP32[$1 + 16 >> 2];
   $4 = $4 + $3 / (+($0 >>> 0) + +HEAP32[$1 + 20 >> 2] * 4294967296);
   HEAPF64[$1 >> 3] = $4;
   HEAPF64[$1 + 8 >> 3] = $3 * ($6 - $4) + HEAPF64[$1 + 8 >> 3];
  }
  return;
 }
 __assert_fail(23175, 17353, 1395, 9443);
 abort();
}

function fts3DestroyMethod($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 48 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 44 >> 2] = 0;
 $4 = HEAP32[$0 + 12 >> 2];
 $5 = HEAP32[$0 + 40 >> 2];
 $2 = HEAP32[$0 + 16 >> 2];
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 40 >> 2] = $3;
 HEAP32[$1 + 36 >> 2] = $2;
 HEAP32[$1 + 28 >> 2] = $3;
 HEAP32[$1 + 24 >> 2] = $2;
 HEAP32[$1 + 20 >> 2] = $3;
 HEAP32[$1 + 16 >> 2] = $2;
 HEAP32[$1 + 32 >> 2] = $5 ? 24268 : 29623;
 HEAP32[$1 + 12 >> 2] = $3;
 HEAP32[$1 + 8 >> 2] = $2;
 HEAP32[$1 + 4 >> 2] = $3;
 HEAP32[$1 >> 2] = $2;
 fts3DbExec($1 + 44 | 0, $4, 21999, $1);
 $2 = HEAP32[$1 + 44 >> 2];
 if (!$2) {
  fts3DisconnectMethod($0);
 }
 __stack_pointer = $1 + 48 | 0;
 return $2 | 0;
}

function sysconf($0) {
 var $1 = 0;
 label$1: {
  if ($0 >>> 0 <= 248) {
   $0 = HEAP16[($0 << 1) + 63760 >> 1];
   if ($0) {
    break label$1;
   }
  }
  HEAP32[__errno_location() >> 2] = 28;
  return -1;
 }
 label$3: {
  label$4: {
   if (($0 | 0) > -2) {
    break label$4;
   }
   $1 = 200809;
   label$5: {
    switch (($0 & 255) - 1 | 0) {
    case 1:
     return 131072;

    case 2:
     return 32768;

    case 3:
     return 65536;

    case 4:
    case 10:
     return 2147483647;

    case 5:
    case 6:
     return 1;

    case 7:
    case 8:
     return emscripten_get_heap_max() >>> 16 | 0;

    case 0:
     break label$3;

    case 9:
     break label$5;

    default:
     break label$4;
    }
   }
   return 0;
  }
  $1 = $0;
 }
 return $1;
}

function sqlite3Vacuum($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $1;
 $5 = sqlite3GetVdbe($0);
 label$1: {
  if (!$5 | HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  if ($1) {
   $4 = sqlite3TwoPartName($0, $1, $1, $3 + 12 | 0);
   if (($4 | 0) < 0 | ($4 | 0) == 1) {
    break label$1;
   }
  }
  label$3: {
   if (!$2) {
    break label$3;
   }
   if (sqlite3ResolveSelfReference($0, 0, 0, $2, 0)) {
    break label$3;
   }
   $6 = HEAP32[$0 + 44 >> 2] + 1 | 0;
   HEAP32[$0 + 44 >> 2] = $6;
   sqlite3ExprCode($0, $2, $6);
  }
  sqlite3VdbeAddOp2($5, 5, $4, $6);
  sqlite3VdbeUsesBtree($5, $4);
 }
 sqlite3ExprDelete(HEAP32[$0 >> 2], $2);
 __stack_pointer = $3 + 16 | 0;
}
function sqlite3WithDup($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $4 = sqlite3DbMallocZero($0, Math_imul(HEAP32[$1 >> 2], 24) + 12 | 0, 0);
  if (!$4) {
   break label$1;
  }
  HEAP32[$4 >> 2] = HEAP32[$1 >> 2];
  while (1) {
   if (HEAP32[$1 >> 2] <= ($3 | 0)) {
    $0 = $4;
   } else {
    $2 = Math_imul($3, 24);
    $5 = $4 + $2 | 0;
    $2 = $1 + $2 | 0;
    HEAP32[$5 + 20 >> 2] = sqlite3SelectDup($0, HEAP32[$2 + 20 >> 2], 0);
    HEAP32[$5 + 16 >> 2] = sqlite3ExprListDup($0, HEAP32[$2 + 16 >> 2], 0);
    HEAP32[$5 + 12 >> 2] = sqlite3DbStrDup($0, HEAP32[$2 + 12 >> 2]);
    HEAP8[$5 + 32 | 0] = HEAPU8[$2 + 32 | 0];
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  $3 = $0;
 }
 return $3;
}

function sqlite3VtabCallConnect($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  if (sqlite3GetVTable($4, $1)) {
   break label$1;
  }
  $3 = sqlite3HashFind($4 + 384 | 0, HEAP32[HEAP32[$1 + 48 >> 2] >> 2]);
  if (!$3) {
   HEAP32[$2 >> 2] = HEAP32[HEAP32[$1 + 48 >> 2] >> 2];
   sqlite3ErrorMsg($0, 7816, $2);
   $3 = 1;
   break label$1;
  }
  HEAP32[$2 + 28 >> 2] = 0;
  $3 = vtabCallConstructor($4, $1, $3, HEAP32[HEAP32[$3 >> 2] + 8 >> 2], $2 + 28 | 0);
  $1 = HEAP32[$2 + 28 >> 2];
  if ($3) {
   HEAP32[$2 + 16 >> 2] = $1;
   sqlite3ErrorMsg($0, 8342, $2 + 16 | 0);
   HEAP32[$0 + 12 >> 2] = $3;
  }
  sqlite3DbFree($4, $1);
 }
 __stack_pointer = $2 + 32 | 0;
 return $3;
}

function sqlite3ParseObjectReset($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$0 >> 2];
 sqlite3DbFree($2, HEAP32[$0 + 108 >> 2]);
 while (1) {
  $1 = HEAP32[$0 + 128 >> 2];
  if ($1) {
   HEAP32[$0 + 128 >> 2] = HEAP32[$1 >> 2];
   FUNCTION_TABLE[HEAP32[$1 + 8 >> 2]]($2, HEAP32[$1 + 4 >> 2]);
   sqlite3DbFreeNN($2, $1);
   continue;
  }
  break;
 }
 sqlite3DbFree($2, HEAP32[$0 + 64 >> 2]);
 $1 = HEAP32[$0 + 68 >> 2];
 if ($1) {
  sqlite3ExprListDelete($2, $1);
 }
 $3 = HEAP32[$2 + 304 >> 2];
 $4 = HEAPU8[$0 + 24 | 0];
 HEAP32[$2 + 304 >> 2] = $3 - $4;
 $1 = 0;
 $1 = ($3 | 0) == ($4 | 0) ? HEAPU16[$2 + 310 >> 1] : $1;
 HEAP16[$2 + 308 >> 1] = $1;
 HEAP32[$2 + 264 >> 2] = HEAP32[$0 + 184 >> 2];
 HEAP8[$0 + 24 | 0] = 0;
 HEAP32[$0 >> 2] = 0;
}

function sqlite3OpenTempDatabase($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $1 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[HEAP32[$1 + 16 >> 2] + 20 >> 2] | HEAPU8[$0 + 207 | 0]) {
   break label$1;
  }
  label$2: {
   $2 = sqlite3BtreeOpen(HEAP32[$1 >> 2], 0, $1, $3 + 12 | 0, 0, 542);
   label$3: {
    if ($2) {
     sqlite3ErrorMsg($0, 5178, 0);
     HEAP32[$0 + 12 >> 2] = $2;
     break label$3;
    }
    $0 = HEAP32[$3 + 12 >> 2];
    HEAP32[HEAP32[$1 + 16 >> 2] + 20 >> 2] = $0;
    if ((sqlite3BtreeSetPageSize($0, HEAP32[$1 + 100 >> 2], 0, 0) | 0) != 7) {
     break label$2;
    }
    sqlite3OomFault($1);
   }
   $2 = 1;
   break label$1;
  }
  $2 = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3ExprFunction($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$0 >> 2];
 $4 = sqlite3ExprAlloc($6, 172, $2, 1);
 label$1: {
  if (!$4) {
   sqlite3ExprListDelete($6, $1);
   break label$1;
  }
  HEAP32[$4 + 36 >> 2] = HEAP32[$2 >> 2] - HEAP32[$0 + 232 >> 2];
  if (!(HEAPU8[$0 + 18 | 0] | (!$1 | HEAP32[$1 >> 2] <= HEAP32[HEAP32[$0 >> 2] + 144 >> 2]))) {
   HEAP32[$5 >> 2] = $2;
   sqlite3ErrorMsg($0, 18446, $5);
  }
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 8;
  sqlite3ExprSetHeightAndFlags($0, $4);
  if (($3 | 0) != 1) {
   break label$1;
  }
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 4;
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function windowCheckValue($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = sqlite3GetVdbe($0);
 $4 = sqlite3GetTempReg($0);
 sqlite3VdbeAddOp2($3, 71, 0, $4);
 label$1: {
  if (($2 | 0) >= 3) {
   $5 = sqlite3GetTempReg($0);
   sqlite3VdbeAddOp4($3, 117, 0, $5, 0, 29623, -1);
   sqlite3VdbeAddOp3($3, 57, $5, sqlite3VdbeCurrentAddr($3) + 2 | 0, $1);
   sqlite3VdbeChangeP5($3, 83);
   break label$1;
  }
  sqlite3VdbeAddOp2($3, 12, $1, sqlite3VdbeCurrentAddr($3) + 2 | 0);
 }
 $2 = $2 << 2;
 sqlite3VdbeAddOp3($3, HEAP32[$2 + 49088 >> 2], $4, sqlite3VdbeCurrentAddr($3) + 2 | 0, $1);
 sqlite3VdbeChangeP5($3, 67);
 sqlite3MayAbort($0);
 sqlite3VdbeAddOp2($3, 70, 1, 2);
 sqlite3VdbeAppendP4($3, HEAP32[$2 + 49056 >> 2], -1);
 sqlite3ReleaseTempReg($0, $4);
}

function sqlite3VdbeChangeP4($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  $4 = HEAP32[$0 >> 2];
  if (HEAPU8[$4 + 87 | 0]) {
   if (($3 | 0) == -11) {
    break label$1;
   }
   freeP4($4, $3, $2);
   return;
  }
  $5 = HEAP32[$0 + 104 >> 2];
  $1 = ($1 | 0) < 0 ? HEAP32[$0 + 108 >> 2] - 1 | 0 : $1;
  $4 = $5 + Math_imul($1, 20) | 0;
  if (!(HEAPU8[$4 + 1 | 0] ? 0 : ($3 | 0) < 0)) {
   vdbeChangeP4Full($0, $4, $2, $3);
   return;
  }
  if (($3 | 0) == -3) {
   HEAP32[(Math_imul($1, 20) + $5 | 0) + 16 >> 2] = $2;
   HEAP8[$4 + 1 | 0] = 253;
   return;
  }
  if (!$2) {
   break label$1;
  }
  HEAP32[(Math_imul($1, 20) + $5 | 0) + 16 >> 2] = $2;
  HEAP8[$4 + 1 | 0] = $3;
  if (($3 | 0) != -11) {
   break label$1;
  }
  sqlite3VtabLock($2);
 }
}

function checkAppendMsg($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = HEAP32[$0 + 16 >> 2];
 label$1: {
  if (!$4) {
   break label$1;
  }
  HEAP32[$0 + 16 >> 2] = $4 - 1;
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + 1;
  HEAP32[$3 + 12 >> 2] = $2;
  $2 = $0 + 40 | 0;
  if (HEAP32[$0 + 56 >> 2]) {
   sqlite3_str_append($2, 29622, 1);
  }
  $4 = HEAP32[$0 + 28 >> 2];
  if ($4) {
   $5 = HEAP32[$0 + 36 >> 2];
   HEAP32[$3 >> 2] = HEAP32[$0 + 32 >> 2];
   HEAP32[$3 + 4 >> 2] = $5;
   sqlite3_str_appendf($2, $4, $3);
  }
  sqlite3_str_vappendf($2, $1, HEAP32[$3 + 12 >> 2]);
  if (HEAPU8[$0 + 60 | 0] != 7) {
   break label$1;
  }
  HEAP32[$0 + 24 >> 2] = 1;
 }
 __stack_pointer = $3 + 16 | 0;
}

function fts3SegReaderStart($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $7 = HEAP32[$1 + 4 >> 2];
 label$1: {
  while (1) {
   if (!(HEAP32[$1 + 28 >> 2] | HEAP32[$1 + 4 >> 2] <= ($6 | 0))) {
    $5 = HEAP32[HEAP32[$1 >> 2] + ($6 << 2) >> 2];
    while (1) {
     $4 = fts3SegReaderNext($0, $5);
     if ($4) {
      break label$1;
     }
     label$5: {
      if (!$2) {
       $4 = 0;
       break label$5;
      }
      $4 = fts3SegReaderTermCmp($5, $2, $3);
      if (($4 | 0) < 0) {
       continue;
      }
     }
     break;
    }
    if (!(!HEAPU8[$5 + 4 | 0] | !$4)) {
     fts3SegReaderSetEof($5);
    }
    $6 = $6 + 1 | 0;
    continue;
   }
   break;
  }
  fts3SegReaderSort(HEAP32[$1 >> 2], $7, $7, 100);
  $4 = 0;
 }
 return $4;
}

function sqlite3BtreeClose($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 sqlite3BtreeRollback($0, 0, 0);
 label$1: {
  if (HEAPU8[$0 + 9 | 0]) {
   if (!removeFromSharingList($1)) {
    break label$1;
   }
  }
  sqlite3PagerClose(HEAP32[$1 >> 2], HEAP32[$0 >> 2]);
  $2 = HEAP32[$1 + 56 >> 2];
  label$3: {
   if (!$2) {
    break label$3;
   }
   $3 = HEAP32[$1 + 52 >> 2];
   if (!$3) {
    break label$3;
   }
   FUNCTION_TABLE[$2 | 0]($3);
  }
  sqlite3DbFree(0, HEAP32[$1 + 52 >> 2]);
  freeTempSpace($1);
  sqlite3_free($1);
 }
 $1 = HEAP32[$0 + 28 >> 2];
 if ($1) {
  HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 }
 $2 = HEAP32[$0 + 24 >> 2];
 if ($2) {
  HEAP32[$2 + 28 >> 2] = $1;
 }
 sqlite3_free($0);
}

function unixFcntlExternalReader($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 48 | 0;
 __stack_pointer = $2;
 HEAP32[$1 >> 2] = 0;
 $0 = HEAP32[$0 + 36 >> 2];
 label$1: {
  if (!$0) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  HEAP32[$2 + 40 >> 2] = 0;
  HEAP32[$2 + 44 >> 2] = 0;
  HEAP32[$2 + 32 >> 2] = 5;
  HEAP32[$2 + 36 >> 2] = 0;
  HEAP32[$2 + 24 >> 2] = 123;
  HEAP32[$2 + 28 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP16[$2 + 16 >> 1] = 1;
  $0 = HEAP32[$3 + 12 >> 2];
  HEAP32[$2 >> 2] = $2 + 16;
  $3 = 0;
  if ((FUNCTION_TABLE[HEAP32[16258]]($0, 5, $2) | 0) < 0) {
   $3 = 3850;
   break label$1;
  }
  HEAP32[$1 >> 2] = HEAPU16[$2 + 16 >> 1] != 2;
 }
 __stack_pointer = $2 + 48 | 0;
 return $3;
}

function sqlite3ExprDeleteNN($0, $1) {
 var $2 = 0;
 label$1: {
  if (HEAPU8[$1 + 6 | 0] & 129) {
   break label$1;
  }
  $2 = HEAP32[$1 + 12 >> 2];
  if (!(!$2 | HEAPU8[$1 | 0] == 178)) {
   sqlite3ExprDeleteNN($0, $2);
  }
  $2 = HEAP32[$1 + 16 >> 2];
  if ($2) {
   sqlite3ExprDeleteNN($0, $2);
   break label$1;
  }
  $2 = HEAP32[$1 + 20 >> 2];
  if (HEAPU8[$1 + 5 | 0] & 16) {
   sqlite3SelectDelete($0, $2);
   break label$1;
  }
  sqlite3ExprListDelete($0, $2);
  if (!(HEAP8[$1 + 7 | 0] & 1)) {
   break label$1;
  }
  sqlite3WindowDelete($0, HEAP32[$1 + 44 >> 2]);
 }
 $2 = HEAP32[$1 + 4 >> 2];
 if ($2 & 131072) {
  sqlite3DbFree($0, HEAP32[$1 + 8 >> 2]);
  $2 = HEAP32[$1 + 4 >> 2];
 }
 if (!($2 & 134217728)) {
  sqlite3DbFreeNN($0, $1);
 }
}

function isCandidateForInOpt($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if ((HEAP32[$0 + 4 >> 2] & 4160) != 4096) {
   break label$1;
  }
  $0 = HEAP32[$0 + 20 >> 2];
  if (HEAP32[$0 + 52 >> 2] | HEAPU8[$0 + 4 | 0] & 9 | (HEAP32[$0 + 60 >> 2] | HEAP32[$0 + 36 >> 2])) {
   break label$1;
  }
  $1 = HEAP32[$0 + 32 >> 2];
  if (HEAP32[$1 >> 2] != 1 | HEAP32[$1 + 28 >> 2] | HEAPU8[HEAP32[$1 + 24 >> 2] + 43 | 0] == 1) {
   break label$1;
  }
  $1 = 0;
  $3 = HEAP32[$0 + 28 >> 2];
  $2 = HEAP32[$3 >> 2];
  $2 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   if (($1 | 0) == ($2 | 0)) {
    return $0;
   }
   $4 = $1 << 4;
   $1 = $1 + 1 | 0;
   if (HEAPU8[HEAP32[($3 + $4 | 0) + 8 >> 2]] == 167) {
    continue;
   }
   break;
  }
 }
 return 0;
}

function jsonArrayLengthFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  $3 = jsonParseCached($0, $2, $0);
  if (!$3) {
   break label$1;
  }
  label$2: {
   if (($1 | 0) == 2) {
    $1 = jsonLookup($3, sqlite3_value_text(HEAP32[$2 + 4 >> 2]), 0, $0);
    break label$2;
   }
   $1 = HEAP32[$3 + 8 >> 2];
  }
  if (!$1) {
   break label$1;
  }
  label$4: {
   if (HEAPU8[$1 | 0] != 6) {
    break label$4;
   }
   $3 = HEAP32[$1 + 4 >> 2];
   $2 = 1;
   while (1) {
    if ($2 >>> 0 > $3 >>> 0) {
     break label$4;
    }
    $4 = $4 + 1 | 0;
    $5 = $4 ? $5 : $5 + 1 | 0;
    $2 = jsonNodeSize(Math_imul($2, 12) + $1 | 0) + $2 | 0;
    continue;
   }
  }
  sqlite3_result_int64($0, $4, $5);
 }
}

function sqlite3VdbeMemFinalize($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 68 >> 2] = 0;
 HEAP32[$2 + 72 >> 2] = 0;
 HEAP32[$2 + 76 >> 2] = 0;
 HEAP32[$2 + 60 >> 2] = 0;
 HEAP32[$2 + 64 >> 2] = 0;
 memset($2 + 8 | 0, 0, 40);
 HEAP16[$2 + 24 >> 1] = 1;
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP32[$2 + 56 >> 2] = $0;
 HEAP32[$2 + 28 >> 2] = $3;
 HEAP32[$2 + 48 >> 2] = $2 + 8;
 HEAP32[$2 + 52 >> 2] = $1;
 HEAP8[$2 + 72 | 0] = HEAPU8[$3 + 84 | 0];
 FUNCTION_TABLE[HEAP32[$1 + 20 >> 2]]($2 + 48 | 0);
 if (HEAP32[$0 + 24 >> 2] > 0) {
  sqlite3DbFreeNN(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 32 >> 2]);
 }
 __memcpy($0, $2 + 8 | 0, 40);
 __stack_pointer = $2 + 80 | 0;
 $0 = HEAP32[$2 + 68 >> 2];
 return $0;
}

function absFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 label$1: {
  label$2: {
   label$3: {
    $2 = HEAP32[$2 >> 2];
    switch (sqlite3_value_type($2) - 1 | 0) {
    case 4:
     break label$2;

    case 0:
     break label$3;

    default:
     break label$1;
    }
   }
   $2 = sqlite3_value_int64($2);
   $1 = i64toi32_i32$HIGH_BITS;
   if (($1 | 0) < 0) {
    if (!$2 & ($1 | 0) == -2147483648) {
     sqlite3_result_error($0, 1652, -1);
     return;
    }
    $1 = (($2 | 0) != 0) + $1 | 0;
    $1 = 0 - $1 | 0;
    $2 = 0 - $2 | 0;
   }
   sqlite3_result_int64($0, $2, $1);
   return;
  }
  sqlite3_result_null($0);
  return;
 }
 $3 = sqlite3_value_double($2);
 sqlite3_result_double($0, $3 < 0 ? -$3 : $3);
}

function codeApplyAffinity($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  if (!$3) {
   break label$1;
  }
  $5 = HEAP32[$0 + 8 >> 2];
  $4 = $2 >> 31 & $2;
  while (1) {
   label$3: {
    if (($2 | 0) > 0) {
     if (HEAP8[$3 | 0] <= 65) {
      break label$3;
     }
     $4 = $2;
    }
    $0 = $4;
    label$5: {
     while (1) {
      $2 = $0;
      if (($2 | 0) >= 2) {
       $0 = $2 - 1 | 0;
       if (HEAP8[$3 + $0 | 0] < 66) {
        continue;
       }
       break label$5;
      }
      break;
     }
     $2 = 1;
     if (($4 | 0) <= 0) {
      break label$1;
     }
    }
    sqlite3VdbeAddOp4($5, 96, $1, $2, 0, $3, $2);
    break label$1;
   }
   $3 = $3 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 - 1 | 0;
   continue;
  }
 }
}

function sqlite3ExprIsInteger($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  label$2: {
   while (1) {
    if (!$0) {
     break label$1;
    }
    if (HEAPU8[$0 + 5 | 0] & 8) {
     HEAP32[$1 >> 2] = HEAP32[$0 + 8 >> 2];
     break label$2;
    }
    label$5: {
     switch (HEAPU8[$0 | 0] - 173 | 0) {
     case 1:
      $0 = HEAP32[$0 + 12 >> 2];
      continue;

     case 0:
      break label$5;

     default:
      break label$1;
     }
    }
    break;
   }
   HEAP32[$2 + 12 >> 2] = 0;
   if (!sqlite3ExprIsInteger(HEAP32[$0 + 12 >> 2], $2 + 12 | 0)) {
    break label$1;
   }
   HEAP32[$1 >> 2] = 0 - HEAP32[$2 + 12 >> 2];
  }
  $3 = 1;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function termCanDriveIndex($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP32[$0 + 20 >> 2];
 label$1: {
  if (!(HEAPU8[$0 + 12 | 0] & 130) | ($4 | 0) != HEAP32[$1 + 40 >> 2]) {
   break label$1;
  }
  if (HEAPU8[$1 + 36 | 0] & 88) {
   $5 = HEAP32[$0 >> 2];
   if (!(HEAPU8[$5 + 4 | 0] & 3) | HEAP32[$5 + 36 >> 2] != ($4 | 0)) {
    break label$1;
   }
  }
  $4 = HEAP32[$0 + 32 >> 2];
  $5 = $4;
  $4 = $3;
  $3 = HEAP32[$0 + 36 >> 2];
  $4 = $4 & $3;
  $3 = $2 & $5;
  if ($4 | $3) {
   break label$1;
  }
  $4 = HEAP32[$0 + 24 >> 2];
  if (($4 | 0) < 0) {
   break label$1;
  }
  $6 = (sqlite3IndexAffinityOk(HEAP32[$0 >> 2], HEAP8[(HEAP32[HEAP32[$1 + 16 >> 2] + 4 >> 2] + Math_imul($4, 12) | 0) + 5 | 0]) | 0) != 0;
 }
 return $6;
}

function jsonAppendRaw($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $4 = HEAP32[$0 + 12 >> 2];
  $7 = $4;
  $3 = HEAP32[$0 + 20 >> 2];
  $4 = HEAP32[$0 + 16 >> 2];
  $5 = $4;
  $6 = $5 + $2 | 0;
  $3 = $2 >>> 0 > $6 >>> 0 ? $3 + 1 | 0 : $3;
  $5 = $3;
  $3 = $7;
  if (($5 | 0) == ($3 | 0) & $6 >>> 0 >= HEAPU32[$0 + 8 >> 2] | $3 >>> 0 < $5 >>> 0) {
   if (jsonGrow($0, $2)) {
    break label$1;
   }
   $4 = HEAP32[$0 + 16 >> 2];
  }
  __memcpy($4 + HEAP32[$0 + 4 >> 2] | 0, $1, $2);
  $3 = HEAP32[$0 + 16 >> 2];
  $6 = HEAP32[$0 + 20 >> 2];
  $5 = $2;
  $4 = $5 + $3 | 0;
  $6 = $4 >>> 0 < $5 >>> 0 ? $6 + 1 | 0 : $6;
  HEAP32[$0 + 16 >> 2] = $4;
  HEAP32[$0 + 20 >> 2] = $6;
 }
}

function getcwd($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer;
 $5 = $2;
 $3 = 4096;
 $4 = $2 - ($0 ? 16 : 4096) | 0;
 __stack_pointer = $4;
 $2 = $4;
 label$1: {
  label$2: {
   if (!$0) {
    break label$2;
   }
   $2 = $0;
   $3 = $1;
   if ($3) {
    break label$2;
   }
   HEAP32[__errno_location() >> 2] = 28;
   $0 = 0;
   break label$1;
  }
  $0 = 0;
  $3 = __syscall_ret(__syscall_getcwd($2 | 0, $3 | 0) | 0);
  if (($3 | 0) < 0) {
   break label$1;
  }
  if (!(HEAPU8[$2 | 0] == 47 ? $3 : 0)) {
   HEAP32[__errno_location() >> 2] = 44;
   break label$1;
  }
  $0 = $2;
  if (($2 | 0) != ($4 | 0)) {
   break label$1;
  }
  $0 = strdup($4);
 }
 __stack_pointer = $5;
 return $0 | 0;
}

function sqlite3WindowLink($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = $0;
  $4 = $0 + 68 | 0;
  label$2: {
   $3 = HEAP32[$0 + 68 >> 2];
   label$3: {
    if (!$3) {
     HEAP32[$1 + 36 >> 2] = 0;
     break label$3;
    }
    if (sqlite3WindowCompare(0, $3, $1, 0)) {
     break label$2;
    }
    $0 = HEAP32[$2 + 68 >> 2];
    HEAP32[$1 + 36 >> 2] = $0;
    if (!$0) {
     break label$3;
    }
    HEAP32[$0 + 32 >> 2] = $1 + 36;
   }
   HEAP32[$2 + 68 >> 2] = $1;
   HEAP32[$1 + 32 >> 2] = $4;
   return;
  }
  if (!sqlite3ExprListCompare(HEAP32[$1 + 8 >> 2], HEAP32[HEAP32[$2 + 68 >> 2] + 8 >> 2], -1)) {
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 33554432;
 }
}

function walRestartLog($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 label$1: {
  if (HEAPU16[$0 + 40 >> 1]) {
   break label$1;
  }
  label$2: {
   if (!HEAP32[walCkptInfo($0) >> 2]) {
    break label$2;
   }
   sqlite3_randomness(4, $1 + 12 | 0);
   $2 = walLockExclusive($0, 4, 4);
   if (($2 | 0) == 5) {
    break label$2;
   }
   if ($2) {
    break label$1;
   }
   walRestartHdr($0, HEAP32[$1 + 12 >> 2]);
   walUnlockExclusive($0, 4, 4);
  }
  walUnlockShared($0, 3);
  HEAP16[$0 + 40 >> 1] = 65535;
  while (1) {
   $3 = $3 + 1 | 0;
   $2 = walTryBeginRead($0, $1 + 8 | 0, 1, $3);
   if (($2 | 0) == -1) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function rehash($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $1 = $1 << 3 >>> 0 > 1024 ? 128 : $1;
 label$1: {
  if (($1 | 0) == HEAP32[$0 >> 2]) {
   break label$1;
  }
  sqlite3BeginBenignMalloc();
  $1 = sqlite3Malloc($1 << 3, 0);
  sqlite3EndBenignMalloc();
  if (!$1) {
   break label$1;
  }
  sqlite3_free(HEAP32[$0 + 12 >> 2]);
  HEAP32[$0 + 12 >> 2] = $1;
  $2 = sqlite3MallocSize($1);
  $3 = $2 >>> 3 | 0;
  HEAP32[$0 >> 2] = $3;
  $4 = memset($1, 0, $2 & -8);
  $1 = HEAP32[$0 + 8 >> 2];
  HEAP32[$0 + 8 >> 2] = 0;
  while (1) {
   if ($1) {
    $2 = HEAP32[$1 >> 2];
    insertElement($0, ((strHash(HEAP32[$1 + 12 >> 2]) >>> 0) % ($3 >>> 0) << 3) + $4 | 0, $1);
    $1 = $2;
    continue;
   }
   break;
  }
  $2 = 1;
 }
 return $2;
}

function fts3DatabasePageSize($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 if (!HEAP32[$0 >> 2]) {
  HEAP32[$2 >> 2] = HEAP32[$1 + 16 >> 2];
  $4 = sqlite3_mprintf(12173, $2);
  label$2: {
   if (!$4) {
    $3 = 7;
    break label$2;
   }
   $3 = sqlite3_prepare(HEAP32[$1 + 12 >> 2], $4, -1, $2 + 12 | 0, 0);
   if (($3 | 0) != 23) {
    if ($3) {
     break label$2;
    }
    sqlite3_step(HEAP32[$2 + 12 >> 2]);
    HEAP32[$1 + 244 >> 2] = sqlite3_column_int(HEAP32[$2 + 12 >> 2], 0);
    $3 = sqlite3_finalize(HEAP32[$2 + 12 >> 2]);
    break label$2;
   }
   HEAP32[$1 + 244 >> 2] = 1024;
   $3 = 0;
  }
  sqlite3_free($4);
  HEAP32[$0 >> 2] = $3;
 }
 __stack_pointer = $2 + 16 | 0;
}

function applyNumericAffinity($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = sqlite3AtoF(HEAP32[$0 + 8 >> 2], $3 + 8 | 0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]);
 if (($2 | 0) > 0) {
  $4 = HEAPF64[$3 + 8 >> 3];
  label$2: {
   label$3: {
    if (($2 | 0) != 1) {
     break label$3;
    }
    if (!alsoAnInt($0, $4, $0)) {
     break label$3;
    }
    $2 = HEAPU16[$0 + 16 >> 1] | 4;
    break label$2;
   }
   HEAPF64[$0 >> 3] = $4;
   $2 = HEAPU16[$0 + 16 >> 1] | 8;
   HEAP16[$0 + 16 >> 1] = $2;
   if (!$1) {
    break label$2;
   }
   sqlite3VdbeIntegerAffinity($0);
   $2 = HEAPU16[$0 + 16 >> 1];
  }
  HEAP16[$0 + 16 >> 1] = $2 & 65533;
 }
 __stack_pointer = $3 + 16 | 0;
}

function fts3PendingTermsDocid($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = HEAP32[$0 + 272 >> 2];
 $5 = HEAP32[$0 + 276 >> 2];
 label$1: {
  label$2: {
   label$3: {
    if ($3 >>> 0 < $6 >>> 0 & ($5 | 0) >= ($4 | 0) | ($4 | 0) < ($5 | 0)) {
     break label$3;
    }
    if (HEAP32[$0 + 280 >> 2] != ($2 | 0) | (HEAP32[$0 + 284 >> 2] ? 0 : ($3 | 0) == ($6 | 0) & ($5 | 0) == ($4 | 0))) {
     break label$3;
    }
    if (HEAP32[$0 + 268 >> 2] <= HEAP32[$0 + 264 >> 2]) {
     break label$2;
    }
   }
   $5 = sqlite3Fts3PendingTermsFlush($0);
   if ($5) {
    break label$1;
   }
  }
  HEAP32[$0 + 284 >> 2] = $1;
  HEAP32[$0 + 280 >> 2] = $2;
  HEAP32[$0 + 272 >> 2] = $3;
  HEAP32[$0 + 276 >> 2] = $4;
  $5 = 0;
 }
 return $5;
}

function sqlite3ErrorMsg($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 >> 2];
 HEAP32[$3 + 68 >> 2] = -2;
 HEAP32[$4 + 12 >> 2] = $2;
 $2 = sqlite3VMPrintf($3, $1, $2);
 if (HEAP32[$3 + 68 >> 2] <= -2) {
  HEAP32[$3 + 68 >> 2] = -1;
 }
 label$2: {
  if (HEAPU8[$3 + 91 | 0]) {
   sqlite3DbFree($3, $2);
   if (!HEAPU8[$3 + 87 | 0]) {
    break label$2;
   }
   HEAP32[$0 + 12 >> 2] = 7;
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   break label$2;
  }
  HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
  sqlite3DbFree($3, HEAP32[$0 + 4 >> 2]);
  HEAP32[$0 + 264 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 1;
  HEAP32[$0 + 4 >> 2] = $2;
 }
 __stack_pointer = $4 + 16 | 0;
}

function memdbEnlarge($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = 13;
 label$1: {
  if (!(HEAPU8[$0 + 36 | 0] & 2) | HEAP32[$0 + 32 >> 2] > 0) {
   break label$1;
  }
  $5 = HEAP32[$0 + 16 >> 2];
  $4 = $1;
  $6 = HEAP32[$0 + 20 >> 2];
  if ($5 >>> 0 < $1 >>> 0 & ($2 | 0) >= ($6 | 0) | ($2 | 0) > ($6 | 0)) {
   break label$1;
  }
  $1 = $1 << 1;
  $2 = $2 << 1 | $4 >>> 31;
  $4 = $6;
  $3 = $1 >>> 0 < $5 >>> 0 & ($2 | 0) <= ($4 | 0) | ($2 | 0) < ($4 | 0);
  $4 = $3 ? $1 : $5;
  $1 = $4;
  $5 = $3 ? $2 : $6;
  $2 = $5;
  $3 = sqlite3Realloc(HEAP32[$0 + 24 >> 2], $1, $2);
  if (!$3) {
   return 3082;
  }
  HEAP32[$0 + 8 >> 2] = $1;
  HEAP32[$0 + 12 >> 2] = $2;
  HEAP32[$0 + 24 >> 2] = $3;
  $3 = 0;
 }
 return $3;
}

function explainSimpleCount($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (HEAPU8[$0 + 207 | 0] == 2) {
  label$2: {
   if (!$2) {
    $5 = HEAP32[$1 >> 2];
    $1 = 29623;
    $4 = 29623;
    break label$2;
   }
   label$4: {
    if (!(HEAPU8[$1 + 28 | 0] & 128)) {
     $5 = HEAP32[$1 >> 2];
     break label$4;
    }
    $5 = HEAP32[$1 >> 2];
    $1 = 29623;
    $4 = 29623;
    if (((HEAPU8[$2 + 55 | 0] | HEAPU8[$2 + 56 | 0] << 8) & 3) == 2) {
     break label$2;
    }
   }
   $1 = 29066;
   $4 = HEAP32[$2 >> 2];
  }
  HEAP32[$3 + 8 >> 2] = $4;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 >> 2] = $5;
  sqlite3VdbeExplain($0, 0, 5775, $3);
 }
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3VdbeMultiLoad($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 12 >> 2] = $3;
 $3 = 0;
 while (1) {
  $4 = HEAPU8[$2 + $3 | 0];
  label$2: {
   if (($4 | 0) != 105) {
    if (($4 | 0) != 115) {
     if (!$4) {
      sqlite3VdbeAddOp2($0, 84, $1, $3);
     }
     __stack_pointer = $5 + 16 | 0;
     return;
    }
    $4 = HEAP32[$5 + 12 >> 2];
    HEAP32[$5 + 12 >> 2] = $4 + 4;
    $4 = HEAP32[$4 >> 2];
    sqlite3VdbeAddOp4($0, $4 ? 117 : 75, 0, $1 + $3 | 0, 0, $4, 0);
    break label$2;
   }
   $4 = HEAP32[$5 + 12 >> 2];
   HEAP32[$5 + 12 >> 2] = $4 + 4;
   sqlite3VdbeAddOp2($0, 71, HEAP32[$4 >> 2], $1 + $3 | 0);
  }
  $3 = $3 + 1 | 0;
  continue;
 }
}

function __gettimeofday($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = +_emscripten_date_now();
 $2 = $3 / 1e3;
 label$1: {
  if (Math_abs($2) < 0x8000000000000000) {
   $1 = Math_abs($2) >= 1 ? ~~($2 > 0 ? Math_min(Math_floor($2 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($2 - +(~~$2 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
   $4 = ~~$2 >>> 0;
   break label$1;
  }
  $1 = -2147483648;
 }
 HEAP32[$0 >> 2] = $4;
 HEAP32[$0 + 4 >> 2] = $1;
 $2 = +(__wasm_i64_mul($4, $1, 1e3, 0) >>> 0);
 $1 = i64toi32_i32$HIGH_BITS;
 $3 = ($3 - ($2 + +($1 | 0) * 4294967296)) * 1e3;
 label$3: {
  if (Math_abs($3) < 2147483648) {
   $1 = ~~$3;
   break label$3;
  }
  $1 = -2147483648;
 }
 HEAP32[$0 + 8 >> 2] = $1;
 return 0;
}

function sqlite3VdbeDeleteAuxData($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = ($2 | 0) < 0;
 while (1) {
  $4 = HEAP32[$1 >> 2];
  if ($4) {
   label$3: {
    label$4: {
     if ($6) {
      break label$4;
     }
     if (HEAP32[$4 >> 2] != ($2 | 0)) {
      break label$3;
     }
     $5 = HEAP32[$4 + 4 >> 2];
     if (($5 | 0) < 0) {
      break label$3;
     }
     if ($5 >>> 0 > 31) {
      break label$4;
     }
     if ($3 >>> $5 & 1) {
      break label$3;
     }
    }
    $5 = HEAP32[$4 + 12 >> 2];
    if ($5) {
     FUNCTION_TABLE[$5 | 0](HEAP32[$4 + 8 >> 2]);
    }
    HEAP32[$1 >> 2] = HEAP32[$4 + 16 >> 2];
    sqlite3DbFree($0, $4);
    continue;
   }
   $1 = $4 + 16 | 0;
   continue;
  }
  break;
 }
}

function openDirectory($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = __stack_pointer - 544 | 0;
 __stack_pointer = $4;
 HEAP32[$4 >> 2] = $0;
 $2 = sqlite3_snprintf(512, $4 + 16 | 0, 8342, $4);
 $0 = strlen($2);
 label$1: {
  while (1) {
   if (($0 | 0) > 0) {
    $3 = $0 + $2 | 0;
    $0 = $0 - 1 | 0;
    if (HEAPU8[$3 | 0] != 47) {
     continue;
    }
    break label$1;
   }
   break;
  }
  if (HEAPU8[$2 | 0] != 47) {
   HEAP8[$2 | 0] = 46;
  }
  $3 = $2 + 1 | 0;
 }
 $0 = 0;
 HEAP8[$3 | 0] = 0;
 $3 = robust_open($2, 0, 0);
 HEAP32[$1 >> 2] = $3;
 if (($3 | 0) < 0) {
  $0 = unixLogErrorAtLine(sqlite3CantopenError(39192), 1113, $2, 39192);
 }
 __stack_pointer = $4 + 544 | 0;
 return $0 | 0;
}

function cycle($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 256 | 0;
 __stack_pointer = $5;
 label$1: {
  if (($2 | 0) < 2) {
   break label$1;
  }
  $7 = ($2 << 2) + $1 | 0;
  HEAP32[$7 >> 2] = $5;
  if (!$0) {
   break label$1;
  }
  while (1) {
   $4 = $0 >>> 0 < 256 ? $0 : 256;
   __memcpy(HEAP32[$7 >> 2], HEAP32[$1 >> 2], $4);
   $3 = 0;
   while (1) {
    $6 = ($3 << 2) + $1 | 0;
    $3 = $3 + 1 | 0;
    __memcpy(HEAP32[$6 >> 2], HEAP32[($3 << 2) + $1 >> 2], $4);
    HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + $4;
    if (($2 | 0) != ($3 | 0)) {
     continue;
    }
    break;
   }
   $0 = $0 - $4 | 0;
   if ($0) {
    continue;
   }
   break;
  }
 }
 __stack_pointer = $5 + 256 | 0;
}

function checkPtrmap($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $5 = ptrmapGet(HEAP32[$0 >> 2], $1, $4 + 47 | 0, $4 + 40 | 0);
 label$1: {
  if ($5) {
   if (!(($5 | 0) != 3082 & ($5 | 0) != 7)) {
    HEAP32[$0 + 24 >> 2] = 1;
   }
   HEAP32[$4 >> 2] = $1;
   checkAppendMsg($0, 15982, $4);
   break label$1;
  }
  $6 = HEAPU8[$4 + 47 | 0];
  $5 = HEAP32[$4 + 40 >> 2];
  if (($6 | 0) == ($2 | 0) & ($5 | 0) == ($3 | 0)) {
   break label$1;
  }
  HEAP32[$4 + 32 >> 2] = $5;
  HEAP32[$4 + 28 >> 2] = $6;
  HEAP32[$4 + 24 >> 2] = $3;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[$4 + 16 >> 2] = $1;
  checkAppendMsg($0, 24861, $4 + 16 | 0);
 }
 __stack_pointer = $4 + 48 | 0;
}

function printfFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 $4 = sqlite3_context_db_handle($0);
 label$1: {
  if (($1 | 0) <= 0) {
   break label$1;
  }
  $5 = sqlite3_value_text(HEAP32[$2 >> 2]);
  if (!$5) {
   break label$1;
  }
  HEAP32[$3 + 36 >> 2] = 0;
  HEAP32[$3 + 40 >> 2] = $2 + 4;
  HEAP32[$3 + 32 >> 2] = $1 - 1;
  sqlite3StrAccumInit($3 + 8 | 0, $4, 0, 0, HEAP32[$4 + 120 >> 2]);
  HEAP8[$3 + 29 | 0] = 2;
  HEAP32[$3 >> 2] = $3 + 32;
  sqlite3_str_appendf($3 + 8 | 0, $5, $3);
  $1 = HEAP32[$3 + 24 >> 2];
  sqlite3_result_text($0, sqlite3StrAccumFinish($3 + 8 | 0), $1, 1);
 }
 __stack_pointer = $3 + 48 | 0;
}

function exprVectorRegister($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 label$1: {
  label$2: {
   label$3: {
    label$4: {
     $6 = HEAPU8[$1 | 0];
     switch ($6 - 176 | 0) {
     case 1:
      break label$2;

     case 0:
      break label$4;

     default:
      break label$3;
     }
    }
    HEAP32[$4 >> 2] = sqlite3VectorFieldSubexpr($1, $2);
    return HEAP32[$1 + 28 >> 2] + $2 | 0;
   }
   $5 = 0;
   if (($6 | 0) != 138) {
    break label$1;
   }
   HEAP32[$4 >> 2] = HEAP32[(HEAP32[HEAP32[$1 + 20 >> 2] + 28 >> 2] + ($2 << 4) | 0) + 8 >> 2];
   return $2 + $3 | 0;
  }
  $1 = HEAP32[(HEAP32[$1 + 20 >> 2] + ($2 << 4) | 0) + 8 >> 2];
  HEAP32[$4 >> 2] = $1;
  $5 = sqlite3ExprCodeTemp($0, $1, $5);
 }
 return $5;
}

function sqlite3Init($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[HEAP32[$0 + 16 >> 2] + 12 >> 2];
 HEAP8[$0 + 84 | 0] = HEAPU8[$2 + 77 | 0];
 $4 = HEAP32[$0 + 24 >> 2];
 label$1: {
  if (!(HEAP8[$2 + 78 | 0] & 1)) {
   $3 = sqlite3InitOne($0, 0, $1, 0);
   if ($3) {
    break label$1;
   }
  }
  $4 = $4 & 1;
  $2 = HEAP32[$0 + 20 >> 2];
  while (1) {
   if (($2 | 0) >= 2) {
    $2 = $2 - 1 | 0;
    if (HEAP8[HEAP32[(HEAP32[$0 + 16 >> 2] + ($2 << 4) | 0) + 12 >> 2] + 78 | 0] & 1) {
     continue;
    }
    $3 = sqlite3InitOne($0, $2, $1, 0);
    if (!$3) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $3 = 0;
  if ($4) {
   break label$1;
  }
  sqlite3CommitInternalChanges($0);
 }
 return $3;
}

function sqlite3BtreeSetPageSize($0, $1, $2, $3) {
 var $4 = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 HEAP8[$4 + 22 | 0] = $2;
 $0 = 8;
 label$1: {
  if (HEAPU8[$4 + 24 | 0] & 2) {
   break label$1;
  }
  $0 = HEAP32[$4 + 36 >> 2] - HEAP32[$4 + 40 >> 2] | 0;
  $2 = ($0 | 0) > ($2 | 0) ? $0 : $2;
  $0 = $4 + 36 | 0;
  if (!($1 - 512 >>> 0 > 65024 | __wasm_popcnt_i32($1) >>> 0 > 1)) {
   HEAP32[$4 + 36 >> 2] = ($1 | 0) == 512 ? ($2 | 0) > 32 ? 1024 : $1 : $1;
   freeTempSpace($4);
  }
  $0 = sqlite3PagerSetPagesize(HEAP32[$4 >> 2], $0, $2);
  HEAP32[$4 + 40 >> 2] = HEAP32[$4 + 36 >> 2] - ($2 & 65535);
  if (!$3) {
   break label$1;
  }
  HEAP16[$4 + 24 >> 1] = HEAPU16[$4 + 24 >> 1] | 2;
 }
 return $0;
}

function propagateConstantExprRewrite($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $0 = HEAP32[$0 + 24 >> 2];
 label$1: {
  label$2: {
   if (!HEAP32[$0 + 16 >> 2]) {
    break label$2;
   }
   $2 = HEAPU8[$1 | 0] - 45 | 0;
   if ($2 >>> 0 > 12) {
    break label$2;
   }
   $3 = 1;
   if (!(1 << $2 & 7937)) {
    break label$2;
   }
   propagateConstantExprRewriteOne($0, HEAP32[$1 + 12 >> 2], 0);
   if (HEAPU8[HEAP32[$0 + 4 >> 2]]) {
    break label$1;
   }
   if ((sqlite3ExprAffinity(HEAP32[$1 + 12 >> 2]) | 0) == 66) {
    break label$2;
   }
   propagateConstantExprRewriteOne($0, HEAP32[$1 + 16 >> 2], 0);
  }
  $3 = propagateConstantExprRewriteOne($0, $1, HEAP32[$0 + 16 >> 2]);
 }
 return $3 | 0;
}

function fts3DoAutoincrmerge($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $1;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 $1 = fts3Getint($2 + 12 | 0);
 HEAP32[$0 + 48 >> 2] = ($1 | 0) == 1 ? 8 : ($1 | 0) > 16 ? 8 : $1;
 label$1: {
  if (!HEAPU8[$0 + 237 | 0]) {
   sqlite3Fts3CreateStatTable($2 + 8 | 0, $0);
   $1 = HEAP32[$2 + 8 >> 2];
   if ($1) {
    break label$1;
   }
  }
  $1 = fts3SqlStmt($0, 23, $2 + 4 | 0, 0);
  if ($1) {
   break label$1;
  }
  $1 = HEAP32[$2 + 4 >> 2];
  sqlite3_bind_int($1, 1, 2);
  sqlite3_bind_int($1, 2, HEAP32[$0 + 48 >> 2]);
  sqlite3_step($1);
  $1 = sqlite3_reset($1);
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function unixTruncate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = HEAP32[$0 + 40 >> 2];
 if (($4 | 0) > 0) {
  $6 = $2;
  $5 = $6;
  $3 = $4 + $1 | 0;
  $1 = $3 - 1 | 0;
  $5 = $3 >>> 0 < $4 >>> 0 ? $5 + 1 | 0 : $5;
  $3 = !$3;
  $3 = $5 - $3 | 0;
  $2 = $3;
  $6 = __wasm_i64_srem($1, $3, $4, 0);
  $3 = i64toi32_i32$HIGH_BITS;
  $7 = $3;
  $5 = $1;
  $4 = $6;
  $1 = $5 - $4 | 0;
  $3 = $2;
  $6 = $7;
  $2 = $3 - ($6 + ($5 >>> 0 < $4 >>> 0) | 0) | 0;
 }
 if (!robust_ftruncate(HEAP32[$0 + 12 >> 2], $1, $2)) {
  return 0;
 }
 storeLastErrno($0, HEAP32[__errno_location() >> 2]);
 unixLogErrorAtLine(1546, 12553, HEAP32[$0 + 32 >> 2], 39278);
 return 1546;
}

function tanh($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 $3 = $1;
 wasm2js_scratch_store_i32(0, $2 | 0);
 $1 = $1 & 2147483647;
 wasm2js_scratch_store_i32(1, $1 | 0);
 $0 = +wasm2js_scratch_load_f64();
 label$1: {
  if ($1 >>> 0 >= 1071748075) {
   if ($1 >>> 0 >= 1077149697) {
    $0 = -0 / $0 + 1;
    break label$1;
   }
   $0 = 1 - 2 / (expm1($0 + $0) + 2);
   break label$1;
  }
  if ($1 >>> 0 >= 1070618799) {
   $0 = expm1($0 + $0);
   $0 = $0 / ($0 + 2);
   break label$1;
  }
  if ($1 >>> 0 < 1048576) {
   break label$1;
  }
  $0 = expm1($0 * -2);
  $0 = -$0 / ($0 + 2);
 }
 return ($3 | 0) < 0 ? -$0 : $0;
}

function sqlite3Fts3OpenTokenizer($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$0 >> 2];
 HEAP32[$5 + 12 >> 2] = 0;
 $3 = FUNCTION_TABLE[HEAP32[$6 + 12 >> 2]]($0, $2, $3, $5 + 12 | 0) | 0;
 label$1: {
  if ($3) {
   break label$1;
  }
  HEAP32[HEAP32[$5 + 12 >> 2] >> 2] = $0;
  if (HEAP32[$6 >> 2] <= 0) {
   $3 = 0;
   break label$1;
  }
  $3 = 0;
  $0 = FUNCTION_TABLE[HEAP32[$6 + 24 >> 2]](HEAP32[$5 + 12 >> 2], $1) | 0;
  if (!$0) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[$6 + 16 >> 2]](HEAP32[$5 + 12 >> 2]) | 0;
  HEAP32[$5 + 12 >> 2] = 0;
  $3 = $0;
 }
 HEAP32[$4 >> 2] = HEAP32[$5 + 12 >> 2];
 __stack_pointer = $5 + 16 | 0;
 return $3;
}

function sqlite3LockAndPrepare($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0;
 HEAP32[$5 >> 2] = 0;
 $7 = sqlite3SafetyCheckOk($0);
 if (!($7 ? $1 : 0)) {
  return sqlite3MisuseError(135359);
 }
 sqlite3BtreeEnterAll($0);
 while (1) {
  label$3: {
   $7 = sqlite3Prepare($0, $1, $2, $3, $4, $5, $6);
   if (!$7 | HEAPU8[$0 + 87 | 0]) {
    break label$3;
   }
   $8 = $9;
   if (($7 | 0) != 17) {
    if (($7 | 0) != 513) {
     break label$3;
    }
    $9 = $8 + 1 | 0;
    if (($8 | 0) < 25) {
     continue;
    }
    break label$3;
   }
   sqlite3ResetOneSchema($0, -1);
   $9 = 1;
   if (!$8) {
    continue;
   }
  }
  break;
 }
 $7 = sqlite3ApiExit($0, $7);
 HEAP32[$0 + 452 >> 2] = 0;
 return $7;
}

function pagerOpenWalIfPresent($0) {
 var $1 = 0, $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (HEAPU8[$0 + 12 | 0]) {
   break label$1;
  }
  $1 = sqlite3OsAccess(HEAP32[$0 >> 2], HEAP32[$0 + 236 >> 2], 0, $2 + 12 | 0);
  if ($1) {
   break label$1;
  }
  if (HEAP32[$2 + 12 >> 2]) {
   $1 = pagerPagecount($0, $2 + 8 | 0);
   if ($1) {
    break label$1;
   }
   if (!HEAP32[$2 + 8 >> 2]) {
    $1 = sqlite3OsDelete(HEAP32[$0 >> 2], HEAP32[$0 + 236 >> 2], 0);
    break label$1;
   }
   $1 = sqlite3PagerOpenWal($0, 0);
   break label$1;
  }
  $1 = 0;
  if (HEAPU8[$0 + 5 | 0] != 5) {
   break label$1;
  }
  HEAP8[$0 + 5 | 0] = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function fts3EvalPhraseLoad($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $4 = HEAP32[$0 >> 2];
 $0 = 0;
 while (1) {
  if (!(HEAP32[$1 + 64 >> 2] <= ($0 | 0) | $3)) {
   $3 = Math_imul($0, 24) + $1 | 0;
   label$3: {
    if (!HEAP32[$3 + 92 >> 2]) {
     $3 = 0;
     break label$3;
    }
    HEAP32[$2 + 12 >> 2] = 0;
    HEAP32[$2 + 8 >> 2] = 0;
    $3 = fts3TermSelect($4, $3 + 72 | 0, HEAP32[$1 + 68 >> 2], $2 + 12 | 0, $2 + 8 | 0);
    if ($3) {
     break label$3;
    }
    $3 = fts3EvalPhraseMergeToken($4, $1, $0, HEAP32[$2 + 8 >> 2], HEAP32[$2 + 12 >> 2]);
   }
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function __floatsitf($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = $1 >> 31;
  $2 = ($2 ^ $1) - $2 | 0;
  $4 = $2;
  $2 = Math_clz32($2);
  __ashlti3($3, $4, 0, 0, 0, $2 + 81 | 0);
  $2 = (HEAP32[$3 + 12 >> 2] ^ 65536) + (16414 - $2 << 16) | 0;
  $4 = 0 + HEAP32[$3 + 8 >> 2] | 0;
  $2 = $5 >>> 0 > $4 >>> 0 ? $2 + 1 | 0 : $2;
  $5 = $2;
  $2 = $4;
  $6 = 0 | $2;
  $4 = $1 & -2147483648 | $5;
  $5 = HEAP32[$3 >> 2];
  $2 = HEAP32[$3 + 4 >> 2];
 }
 HEAP32[$0 >> 2] = $5;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 + 8 >> 2] = $6;
 $2 = $4;
 HEAP32[$0 + 12 >> 2] = $2;
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3WhereClauseClear($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 if (($1 | 0) > 0) {
  $3 = HEAP32[HEAP32[HEAP32[$0 >> 2] >> 2] >> 2];
  $2 = Math_imul($1, 48);
  $1 = HEAP32[$0 + 24 >> 2];
  $4 = ($2 + $1 | 0) - 48 | 0;
  while (1) {
   $0 = $1;
   $1 = HEAPU16[$0 + 10 >> 1];
   if ($1 & 1) {
    sqlite3ExprDelete($3, HEAP32[$0 >> 2]);
    $1 = HEAPU16[$0 + 10 >> 1];
   }
   label$4: {
    if (!($1 & 48)) {
     break label$4;
    }
    $2 = HEAP32[$0 + 24 >> 2];
    if ($1 & 16) {
     whereOrInfoDelete($3, $2);
     break label$4;
    }
    whereAndInfoDelete($3, $2);
   }
   $1 = $0 + 48 | 0;
   if (($0 | 0) != ($4 | 0)) {
    continue;
   }
   break;
  }
 }
}

function sqlite3VtabBeginParse($0, $1, $2, $3, $4) {
 sqlite3StartTable($0, $1, $2, 0, 0, 1, $4);
 $4 = HEAP32[$0 + 236 >> 2];
 label$1: {
  if (!$4) {
   break label$1;
  }
  HEAP8[$4 + 43 | 0] = 1;
  $2 = HEAP32[$0 >> 2];
  addModuleArgument($0, $4, sqlite3NameFromToken($2, $3));
  addModuleArgument($0, $4, 0);
  addModuleArgument($0, $4, sqlite3DbStrDup($2, HEAP32[$4 >> 2]));
  HEAP32[$0 + 192 >> 2] = (HEAP32[$3 >> 2] + HEAP32[$3 + 4 >> 2] | 0) - HEAP32[$0 + 188 >> 2];
  $3 = HEAP32[$4 + 48 >> 2];
  if (!$3) {
   break label$1;
  }
  sqlite3AuthCheck($0, 29, HEAP32[$4 >> 2], HEAP32[$3 >> 2], HEAP32[HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + (sqlite3SchemaToIndex($2, HEAP32[$4 + 60 >> 2]) << 4) >> 2]);
 }
}

function unixDelete($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if ((FUNCTION_TABLE[HEAP32[16285]]($1) | 0) == -1) {
   $3 = 5898;
   if (HEAP32[__errno_location() >> 2] == 44) {
    break label$1;
   }
   $3 = 2570;
   unixLogErrorAtLine(2570, 11341, $1, 41853);
   break label$1;
  }
  if (!($2 & 1)) {
   break label$1;
  }
  if (FUNCTION_TABLE[HEAP32[16288]]($1, $0 + 12 | 0) | 0) {
   break label$1;
  }
  if (full_fsync(HEAP32[$0 + 12 >> 2])) {
   unixLogErrorAtLine(1290, 16990, $1, 41863);
   $3 = 1290;
  }
  robust_close(0, HEAP32[$0 + 12 >> 2], 41865);
 }
 __stack_pointer = $0 + 16 | 0;
 return $3 | 0;
}

function yy_find_shift_action($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if ($1 >>> 0 <= 575) {
  $2 = HEAPU16[($1 << 1) + 36640 >> 1];
  label$2: {
   label$3: {
    while (1) {
     $4 = $0;
     $0 = $0 & 65535;
     $3 = $2 + $0 | 0;
     if (HEAPU16[($3 << 1) + 37792 >> 1] == ($0 | 0)) {
      break label$3;
     }
     $0 = HEAPU16[($0 << 1) + 35840 >> 1];
     if ($0) {
      continue;
     }
     break;
    }
    $0 = $2 + 101 | 0;
    if (!(!($4 & 65535) | HEAPU16[($0 << 1) + 37792 >> 1] != 101)) {
     $0 = ($0 << 1) + 42368 | 0;
     break label$2;
    }
    $0 = ($1 << 1) + 46576 | 0;
    break label$2;
   }
   $0 = ($3 << 1) + 42368 | 0;
  }
  $1 = HEAPU16[$0 >> 1];
 }
 return $1 & 65535;
}

function sqlite3Fts3ExprFree($0) {
 var $1 = 0, $2 = 0;
 while (1) {
  $1 = $0;
  if ($0) {
   $0 = HEAP32[$1 + 12 >> 2];
   if ($0) {
    continue;
   }
   $0 = HEAP32[$1 + 16 >> 2];
   if ($0) {
    continue;
   }
  }
  break;
 }
 while (1) {
  $2 = $1;
  if ($1) {
   $0 = HEAP32[$2 + 8 >> 2];
   fts3FreeExprNode($2);
   $1 = 0;
   if (!$0) {
    continue;
   }
   $1 = $0;
   if (HEAP32[$0 + 12 >> 2] != ($2 | 0)) {
    continue;
   }
   $0 = HEAP32[$0 + 16 >> 2];
   if (!$0) {
    continue;
   }
   while (1) {
    $1 = $0;
    $0 = HEAP32[$0 + 12 >> 2];
    if ($0) {
     continue;
    }
    $0 = HEAP32[$1 + 16 >> 2];
    if ($0) {
     continue;
    }
    break;
   }
   continue;
  }
  break;
 }
}

function execSql($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = sqlite3_prepare_v2($0, $2, -1, $3 + 12 | 0, 0);
 if (!$2) {
  while (1) {
   $2 = sqlite3_step(HEAP32[$3 + 12 >> 2]);
   if (($2 | 0) == 100) {
    $2 = sqlite3_column_text(HEAP32[$3 + 12 >> 2], 0);
    if (!$2) {
     continue;
    }
    if (strncmp($2, 19775, 3)) {
     if (strncmp($2, 18699, 3)) {
      continue;
     }
    }
    $2 = execSql($0, $1, $2);
    if (!$2) {
     continue;
    }
   }
   break;
  }
  $2 = ($2 | 0) == 101 ? 0 : $2;
  if ($2) {
   sqlite3SetString($1, $0, sqlite3_errmsg($0));
  }
  sqlite3_finalize(HEAP32[$3 + 12 >> 2]);
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function querySharedCacheTableLock($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (!HEAPU8[$0 + 9 | 0]) {
   break label$1;
  }
  label$2: {
   $4 = HEAP32[$0 + 4 >> 2];
   if (HEAP32[$4 + 80 >> 2] != ($0 | 0)) {
    if (HEAPU8[$4 + 24 | 0] & 64) {
     break label$2;
    }
   }
   $3 = $4 + 76 | 0;
   while (1) {
    $3 = HEAP32[$3 >> 2];
    if (!$3) {
     break label$1;
    }
    if (!(HEAP32[$3 >> 2] == ($0 | 0) | HEAP32[$3 + 4 >> 2] != ($1 | 0) | HEAPU8[$3 + 8 | 0] == ($2 | 0))) {
     if (($2 | 0) != 2) {
      break label$2;
     }
     HEAP16[$4 + 24 >> 1] = HEAPU16[$4 + 24 >> 1] | 128;
     break label$2;
    }
    $3 = $3 + 12 | 0;
    continue;
   }
  }
  return 262;
 }
 return 0;
}

function unixCurrentTimeInt64($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 __gettimeofday($4, 0);
 $0 = HEAP32[$4 + 8 >> 2] / 1e3 | 0;
 $2 = $0 >> 31;
 $3 = $0;
 $5 = $2;
 $2 = HEAP32[$4 >> 2];
 $0 = HEAP32[$4 + 4 >> 2];
 $2 = __wasm_i64_mul($2, $0, 1e3, 0);
 $6 = $2;
 $3 = $2 + $3 | 0;
 $0 = i64toi32_i32$HIGH_BITS;
 $2 = $0;
 $0 = $5;
 $2 = $2 + $0 | 0;
 $2 = $3 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
 $0 = $3;
 $3 = $2 + 49096 | 0;
 $2 = $0 + 1045635584 | 0;
 $3 = $2 >>> 0 < 1045635584 ? $3 + 1 | 0 : $3;
 $0 = $1;
 HEAP32[$0 >> 2] = $2;
 HEAP32[$0 + 4 >> 2] = $3;
 __stack_pointer = $4 + 16 | 0;
 return 0;
}

function vdbeIncrMergerNew($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (sqlite3FaultSim(100)) {
   HEAP32[$2 >> 2] = 0;
   break label$1;
  }
  $3 = sqlite3MallocZero(64, 0);
  HEAP32[$2 >> 2] = $3;
  if (!$3) {
   break label$1;
  }
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  $1 = HEAP32[$0 + 8 >> 2];
  $2 = HEAP32[$1 + 8 >> 2] + 9 | 0;
  $1 = HEAP32[$1 + 4 >> 2] / 2 | 0;
  $1 = ($1 | 0) < ($2 | 0) ? $2 : $1;
  HEAP32[$3 + 16 >> 2] = $1;
  $2 = $0 - -64 | 0;
  $0 = HEAP32[$2 + 4 >> 2] + ($1 >> 31) | 0;
  $3 = $1 + HEAP32[$2 >> 2] | 0;
  HEAP32[$2 >> 2] = $3;
  $0 = $1 >>> 0 > $3 >>> 0 ? $0 + 1 | 0 : $0;
  HEAP32[$2 + 4 >> 2] = $0;
  return 0;
 }
 vdbeMergeEngineFree($1);
 return 7;
}

function __futimesat($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 label$1: {
  if ($1) {
   $5 = 1;
   while (1) {
    $2 = $2 << 4;
    $3 = $2 + $1 | 0;
    $6 = HEAP32[$3 + 8 >> 2];
    if ($6 >>> 0 >= 1e6) {
     $2 = __syscall_ret(-28);
     break label$1;
    }
    $7 = HEAP32[$3 + 4 >> 2];
    $3 = HEAP32[$3 >> 2];
    $2 = $2 + $4 | 0;
    HEAP32[$2 + 8 >> 2] = Math_imul($6, 1e3);
    HEAP32[$2 >> 2] = $3;
    HEAP32[$2 + 4 >> 2] = $7;
    $2 = 1;
    $3 = $5;
    $5 = 0;
    if ($3) {
     continue;
    }
    break;
   }
   $2 = $4;
  }
  $2 = utimensat($0, $2);
 }
 __stack_pointer = $4 + 32 | 0;
 return $2;
}

function minmaxFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = sqlite3_user_data($0);
 $5 = sqlite3GetFuncCollSeq($0);
 label$1: {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   break label$1;
  }
  $6 = $3 ? -1 : 0;
  $7 = ($1 | 0) > 1 ? $1 : 1;
  $3 = 0;
  $1 = 1;
  while (1) {
   if (($1 | 0) != ($7 | 0)) {
    $4 = HEAP32[($1 << 2) + $2 >> 2];
    if ((sqlite3_value_type($4) | 0) == 5) {
     break label$1;
    }
    $3 = (sqlite3MemCompare(HEAP32[($3 << 2) + $2 >> 2], $4, $5) ^ $6) < 0 ? $3 : $1;
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_result_value($0, HEAP32[($3 << 2) + $2 >> 2]);
 }
}

function exprCommute($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$1 + 12 >> 2];
 label$1: {
  label$2: {
   if (HEAPU8[$2 | 0] == 177) {
    break label$2;
   }
   $3 = HEAP32[$1 + 16 >> 2];
   if (HEAPU8[$3 | 0] == 177) {
    break label$2;
   }
   if ((sqlite3BinaryCompareCollSeq($0, $2, $3) | 0) == (sqlite3BinaryCompareCollSeq($0, HEAP32[$1 + 16 >> 2], HEAP32[$1 + 12 >> 2]) | 0)) {
    break label$1;
   }
  }
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] ^ 1024;
 }
 HEAP32[$1 + 12 >> 2] = __wasm_rotl_i64(HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2], 32, 0);
 HEAP32[$1 + 16 >> 2] = i64toi32_i32$HIGH_BITS;
 $0 = HEAPU8[$1 | 0];
 if ($0 >>> 0 >= 54) {
  HEAP8[$1 | 0] = ($0 - 54 ^ 2) + 54;
 }
}

function hexFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = sqlite3_value_blob(HEAP32[$2 >> 2]);
 $3 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
 $1 = $3 >> 31;
 $2 = $1 << 1 | $3 >>> 31;
 $1 = $3 << 1;
 $1 = contextMalloc($0, $1 | 1, $2);
 if ($1) {
  $7 = ($3 | 0) > 0 ? $3 : 0;
  $2 = $1;
  while (1) {
   if (($5 | 0) != ($7 | 0)) {
    $6 = HEAPU8[$4 | 0];
    HEAP8[$2 + 1 | 0] = HEAPU8[($6 & 15) + 50720 | 0];
    HEAP8[$2 | 0] = HEAPU8[($6 >>> 4 | 0) + 50720 | 0];
    $4 = $4 + 1 | 0;
    $5 = $5 + 1 | 0;
    $2 = $2 + 2 | 0;
    continue;
   }
   break;
  }
  HEAP8[$2 | 0] = 0;
  sqlite3_result_text($0, $1, $3 << 1, 3);
 }
}

function sqlite3ExprForVectorField($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  $4 = HEAPU8[$1 | 0];
  label$2: {
   label$3: {
    if (($4 | 0) != 177) {
     if (($4 | 0) != 138) {
      break label$3;
     }
     $0 = sqlite3PExpr($0, 178, 0, 0);
     $4 = 0;
     if (!$0) {
      break label$2;
     }
     HEAP16[$0 + 32 >> 1] = $2;
     HEAP32[$0 + 28 >> 2] = $3;
     HEAP32[$0 + 12 >> 2] = $1;
     return $0;
    }
    $2 = HEAP32[$1 + 20 >> 2] + ($2 << 4) | 0;
    $4 = $2 + 8 | 0;
    $1 = HEAP32[$4 >> 2];
    if (HEAPU8[$0 + 208 | 0] >= 2) {
     break label$1;
    }
   }
   $4 = sqlite3ExprDup(HEAP32[$0 >> 2], $1, 0);
  }
  return $4;
 }
 HEAP32[$2 + 8 >> 2] = 0;
 return $1;
}

function pcacheFetchFinishWithInit($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$2 + 4 >> 2];
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP32[$3 >> 2] = $2;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 $4 = HEAP32[$2 >> 2];
 HEAP8[$3 + 40 | 0] = 0;
 HEAP8[$3 + 41 | 0] = 0;
 HEAP8[$3 + 42 | 0] = 0;
 HEAP8[$3 + 43 | 0] = 0;
 HEAP8[$3 + 44 | 0] = 0;
 HEAP8[$3 + 45 | 0] = 0;
 HEAP8[$3 + 46 | 0] = 0;
 HEAP8[$3 + 47 | 0] = 0;
 HEAP32[$3 + 8 >> 2] = $3 + 40;
 HEAP32[$3 + 4 >> 2] = $4;
 HEAP16[$3 + 28 >> 1] = 1;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 12 >> 2] = $0;
 return sqlite3PcacheFetchFinish($0, $1, $2);
}

function sqlite3PcacheTruncate($0, $1) {
 var $2 = 0, $3 = 0;
 if (HEAP32[$0 + 44 >> 2]) {
  $3 = HEAP32[$0 >> 2];
  while (1) {
   $2 = $3;
   if ($2) {
    $3 = HEAP32[$2 + 32 >> 2];
    if (HEAPU32[$2 + 24 >> 2] <= $1 >>> 0) {
     continue;
    }
    sqlite3PcacheMakeClean($2);
    continue;
   }
   break;
  }
  label$4: {
   if ($1) {
    break label$4;
   }
   if (!HEAP32[$0 + 12 >> 2]) {
    $1 = 0;
    break label$4;
   }
   $1 = 0;
   $2 = FUNCTION_TABLE[HEAP32[16100]](HEAP32[$0 + 44 >> 2], 1, 0) | 0;
   if (!$2) {
    break label$4;
   }
   memset(HEAP32[$2 >> 2], 0, HEAP32[$0 + 24 >> 2]);
   $1 = 1;
  }
  FUNCTION_TABLE[HEAP32[16103]](HEAP32[$0 + 44 >> 2], $1 + 1 | 0);
 }
}

function sqlite3ColumnDefault($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAPU8[$1 + 43 | 0] == 2) {
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = 0;
  $5 = sqlite3VdbeDb($0);
  $6 = HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0;
  sqlite3ValueFromExpr($5, sqlite3ColumnExpr($1, $6), HEAPU8[$5 + 84 | 0], HEAPU8[$6 + 5 | 0], $4 + 12 | 0);
  $5 = HEAP32[$4 + 12 >> 2];
  if (!$5) {
   break label$1;
  }
  sqlite3VdbeAppendP4($0, $5, -10);
 }
 if (!(HEAPU8[$1 + 43 | 0] == 1 | HEAPU8[(HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0) + 5 | 0] != 69)) {
  sqlite3VdbeAddOp1($0, 87, $3);
 }
 __stack_pointer = $4 + 16 | 0;
}

function copy_stemmer($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $6 = ($1 | 0) > 0 ? $1 : 0;
 while (1) {
  if (($5 | 0) != ($6 | 0)) {
   $4 = HEAPU8[$0 + $5 | 0];
   $8 = ($4 - 65 & 255) >>> 0 < 26;
   HEAP8[$2 + $5 | 0] = $8 ? $4 + 32 | 0 : $4;
   $7 = $8 ? $7 : ($4 - 48 & 255) >>> 0 < 10 ? 1 : $7;
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 $4 = $7 ? 3 : 10;
 if ($4 << 1 < ($1 | 0)) {
  $5 = $1 - $4 | 0;
  while (1) {
   if (($1 | 0) <= ($5 | 0)) {
    $0 = $4;
   } else {
    HEAP8[$2 + $4 | 0] = HEAPU8[$2 + $5 | 0];
    $4 = $4 + 1 | 0;
    $5 = $5 + 1 | 0;
    continue;
   }
   break;
  }
  $6 = $0;
 }
 HEAP8[$2 + $6 | 0] = 0;
 HEAP32[$3 >> 2] = $6;
}

function sqlite3VtabMakeWritable($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$0 + 116 >> 2];
 $2 = $2 ? $2 : $0;
 $4 = HEAP32[$2 + 212 >> 2];
 $5 = ($4 | 0) > 0 ? $4 : 0;
 label$1: {
  while (1) {
   if (($3 | 0) != ($5 | 0)) {
    $0 = $3 << 2;
    $3 = $3 + 1 | 0;
    if (HEAP32[HEAP32[$2 + 260 >> 2] + $0 >> 2] != ($1 | 0)) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $0 = ($4 << 2) + 4 | 0;
  $3 = sqlite3Realloc(HEAP32[$2 + 260 >> 2], $0, $0 >> 31);
  if ($3) {
   HEAP32[$2 + 260 >> 2] = $3;
   $0 = HEAP32[$2 + 212 >> 2];
   HEAP32[$2 + 212 >> 2] = $0 + 1;
   HEAP32[($0 << 2) + $3 >> 2] = $1;
   return;
  }
  sqlite3OomFault(HEAP32[$2 >> 2]);
 }
}

function sqlite3TriggerColmask($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0;
 $8 = $2 ? 129 : 128;
 $9 = $3 << 2;
 while (1) {
  $3 = $7;
  label$2: {
   label$3: {
    if ($1) {
     if (!(HEAPU8[$1 + 9 | 0] & $4) | HEAPU8[$1 + 8 | 0] != ($8 | 0)) {
      break label$3;
     }
     if (!checkColumnOverlap(HEAP32[$1 + 16 >> 2], $2)) {
      break label$3;
     }
     $7 = -1;
     if (HEAPU8[$1 + 10 | 0]) {
      break label$2;
     }
     $7 = getRowTrigger($0, $1, $5, $6);
     if (!$7) {
      break label$3;
     }
     $7 = HEAP32[($7 + $9 | 0) + 16 >> 2] | $3;
     break label$2;
    }
    return $3;
   }
   $7 = $3;
  }
  $1 = HEAP32[$1 + 32 >> 2];
  continue;
 }
}

function incrPhraseTokenNext($0, $1, $2, $3, $4) {
 label$1: {
  label$2: {
   if (HEAP32[$1 + 44 >> 2] == ($2 | 0)) {
    fts3EvalDlPhraseNext($0, $1, $4);
    HEAP32[$3 + 16 >> 2] = HEAP32[$1 + 28 >> 2];
    HEAP32[$3 + 20 >> 2] = HEAP32[$1 + 32 >> 2];
    $0 = HEAP32[$1 + 20 >> 2];
    HEAP32[$3 + 8 >> 2] = HEAP32[$1 + 16 >> 2];
    HEAP32[$3 + 12 >> 2] = $0;
    break label$2;
   }
   $1 = HEAP32[(Math_imul($2, 24) + $1 | 0) + 92 >> 2];
   if ($1) {
    $1 = sqlite3Fts3MsrIncrNext($0, $1, $3 + 8 | 0, $3 + 16 | 0, $3 + 20 | 0);
    if (HEAP32[$3 + 16 >> 2]) {
     break label$1;
    }
    HEAP8[$4 | 0] = 1;
    return $1;
   }
   HEAP32[$3 >> 2] = 1;
  }
  $1 = 0;
 }
 return $1;
}

function sqlite3WhereFindTerm($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0;
 $7 = __stack_pointer - 96 | 0;
 __stack_pointer = $7;
 $9 = $5 & 130;
 $5 = whereScanInit($7, $0, $1, $2, $5, $6);
 while (1) {
  label$2: {
   label$3: {
    if ($5) {
     $0 = HEAP32[$5 + 32 >> 2];
     $6 = $0;
     $0 = $4;
     $1 = HEAP32[$5 + 36 >> 2];
     $2 = $1;
     $0 = $0 & $1;
     $1 = $3 & $6;
     if ($0 | $1) {
      break label$2;
     }
     $1 = $2;
     if (!(HEAPU16[$5 + 12 >> 1] & $9) | ($1 | $6)) {
      break label$3;
     }
     $8 = $5;
    }
    __stack_pointer = $7 + 96 | 0;
    return $8;
   }
   $8 = $8 ? $8 : $5;
  }
  $5 = whereScanNext($7);
  continue;
 }
}

function unixShmUnmap($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = HEAP32[$0 + 36 >> 2];
 label$1: {
  if (!$3) {
   break label$1;
  }
  $4 = HEAP32[$3 >> 2];
  $2 = $4 + 32 | 0;
  while (1) {
   $6 = $2;
   $5 = HEAP32[$2 >> 2];
   $2 = $5 + 4 | 0;
   if (($3 | 0) != ($5 | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$6 >> 2] = HEAP32[$3 + 4 >> 2];
  sqlite3_free($3);
  HEAP32[$0 + 36 >> 2] = 0;
  $2 = HEAP32[$4 + 28 >> 2] - 1 | 0;
  HEAP32[$4 + 28 >> 2] = $2;
  if ($2) {
   break label$1;
  }
  if (!(!$1 | HEAP32[$4 + 12 >> 2] < 0)) {
   FUNCTION_TABLE[HEAP32[16285]](HEAP32[$4 + 8 >> 2]) | 0;
  }
  unixShmPurge($0);
 }
 return 0;
}

function charindexFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 if (($1 & -2) == 2) {
  label$2: {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
    if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
     break label$2;
    }
   }
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_text(HEAP32[$2 >> 2]);
  if ($3) {
   $4 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
   if (($1 | 0) == 3) {
    $2 = sqlite3_value_int(HEAP32[$2 + 8 >> 2]);
    $5 = (($2 | 0) > 1 ? $2 : 1) - 1 | 0;
   }
   sqlite3_result_int($0, _substr($3, $4, $5) + 1 | 0);
  }
  return;
 }
 __assert_fail(23008, 17353, 1038, 16996);
 abort();
}

function isSimpleCount($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $2 = HEAP32[$0 + 28 >> 2];
  if (HEAP32[$2 >> 2] != 1) {
   break label$1;
  }
  $3 = HEAP32[$0 + 32 >> 2];
  if (HEAP32[$3 >> 2] != 1 | HEAP32[$3 + 28 >> 2] | (HEAP32[$0 + 44 >> 2] | HEAP32[$1 + 44 >> 2] != 1)) {
   break label$1;
  }
  $0 = HEAP32[$3 + 24 >> 2];
  if (HEAPU8[$0 + 43 | 0]) {
   break label$1;
  }
  $2 = HEAP32[$2 + 8 >> 2];
  if (!(HEAP8[HEAP32[HEAP32[$1 + 40 >> 2] + 4 >> 2] + 5 | 0] & 1) | (HEAPU8[$2 | 0] != 168 | HEAP32[$2 + 40 >> 2] != ($1 | 0))) {
   break label$1;
  }
  $4 = HEAP32[$2 + 4 >> 2] & 16777220 ? 0 : $0;
 }
 return $4;
}

function sqlite3CodeRowTrigger($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0;
 $10 = ($2 | 0) != 129;
 while (1) {
  if ($1) {
   $9 = HEAPU8[$1 + 8 | 0];
   label$3: {
    if (($9 | 0) != ($2 | 0) & (!HEAPU8[$1 + 10 | 0] | $10 | ($9 | 0) != 127) | HEAPU8[$1 + 9 | 0] != ($4 | 0)) {
     break label$3;
    }
    if (!checkColumnOverlap(HEAP32[$1 + 16 >> 2], $3)) {
     break label$3;
    }
    if (!HEAPU8[$1 + 10 | 0]) {
     sqlite3CodeRowTriggerDirect($0, $1, $5, $6, $7, $8);
     break label$3;
    }
    if (HEAP32[$0 + 116 >> 2]) {
     break label$3;
    }
    codeReturningTrigger($0, $1, $5, $6);
   }
   $1 = HEAP32[$1 + 32 >> 2];
   continue;
  }
  break;
 }
}

function computeHMS($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 if (!HEAPU8[$0 + 43 | 0]) {
  computeJD($0);
  HEAP8[$0 + 43 | 0] = 1;
  HEAP8[$0 + 41 | 0] = 0;
  $2 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$0 >> 2];
  $1 = $1 + 432e5 | 0;
  $2 = $1 >>> 0 < 432e5 ? $2 + 1 | 0 : $2;
  $1 = __wasm_i64_srem($1, $2, 864e5, 0);
  $3 = +($1 | 0) / 1e3;
  label$2: {
   if (Math_abs($3) < 2147483648) {
    $2 = ~~$3;
    break label$2;
   }
   $2 = -2147483648;
  }
  $1 = ($2 | 0) / 3600 | 0;
  HEAP32[$0 + 20 >> 2] = $1;
  $1 = Math_imul($1, -3600) + $2 | 0;
  $4 = ($1 | 0) / 60 | 0;
  HEAP32[$0 + 24 >> 2] = $4;
  HEAPF64[$0 + 32 >> 3] = $3 - +($2 | 0) + +(Math_imul($4, -60) + $1 | 0);
 }
}

function addModuleArgument($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$1 + 44 >> 2];
 $5 = ($3 << 2) + 8 | 0;
 $6 = $3 + 3 | 0;
 $3 = HEAP32[$0 >> 2];
 if (($6 | 0) >= HEAP32[$3 + 128 >> 2]) {
  HEAP32[$4 >> 2] = HEAP32[$1 >> 2];
  sqlite3ErrorMsg($0, 6165, $4);
 }
 $0 = sqlite3DbRealloc($3, HEAP32[$1 + 48 >> 2], $5, 0);
 label$2: {
  if (!$0) {
   sqlite3DbFree($3, $2);
   break label$2;
  }
  $3 = HEAP32[$1 + 44 >> 2];
  $5 = $3 + 1 | 0;
  HEAP32[$1 + 44 >> 2] = $5;
  HEAP32[($3 << 2) + $0 >> 2] = $2;
  HEAP32[($5 << 2) + $0 >> 2] = 0;
  HEAP32[$1 + 48 >> 2] = $0;
 }
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3LogEstFromDouble($0) {
 var $1 = 0, $2 = 0;
 $1 = 0;
 label$1: {
  if ($0 <= 1) {
   break label$1;
  }
  if ($0 <= 2e9) {
   label$3: {
    if ($0 < 0x10000000000000000 & $0 >= 0) {
     $1 = Math_abs($0) >= 1 ? ~~($0 > 0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
     $2 = ~~$0 >>> 0;
     break label$3;
    }
    $2 = 0;
   }
   $1 = sqlite3LogEst($2, $1);
   break label$1;
  }
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = Math_imul($1 >>> 20 | 0, 10) - 10220 | 0;
 }
 return $1 << 16 >> 16;
}

function sqlite3UnlinkAndDeleteTrigger($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $2 = sqlite3HashInsert(HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 40 | 0, $2, 0);
 if ($2) {
  label$2: {
   if (HEAP32[$2 + 20 >> 2] != HEAP32[$2 + 24 >> 2]) {
    break label$2;
   }
   $1 = tableOfTrigger($2);
   if (!$1) {
    break label$2;
   }
   $3 = $1 + 56 | 0;
   while (1) {
    $4 = $3;
    $1 = HEAP32[$4 >> 2];
    if (!$1) {
     break label$2;
    }
    $3 = $1 + 32 | 0;
    if (($1 | 0) != ($2 | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$4 >> 2] = HEAP32[$2 + 32 >> 2];
  }
  sqlite3DeleteTrigger($0, $2);
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | 1;
 }
}

function sqlite3Fts3Dequote($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = HEAPU8[$0 | 0];
 if (!(!(($1 | 0) == 34 | ($1 | 0) == 39 | ($1 | 0) == 96) & ($1 | 0) != 91)) {
  $3 = ($1 | 0) == 91 ? 93 : $1;
  $1 = 1;
  while (1) {
   label$3: {
    $4 = HEAPU8[$0 + $1 | 0];
    if (!$4) {
     break label$3;
    }
    $5 = $1 + 1 | 0;
    label$4: {
     if (($3 | 0) == ($4 | 0)) {
      if (HEAPU8[$0 + $5 | 0] != ($3 | 0)) {
       break label$3;
      }
      HEAP8[$0 + $2 | 0] = $3;
      $1 = $1 + 2 | 0;
      break label$4;
     }
     HEAP8[$0 + $2 | 0] = $4;
     $1 = $5;
    }
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$0 + $2 | 0] = 0;
 }
}

function fts3SegReaderFirstDocid($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (!(!HEAPU8[$0 + 239 | 0] | !HEAP32[$1 + 56 >> 2])) {
   $0 = 0;
   HEAP32[$1 + 84 >> 2] = 0;
   HEAP32[$1 + 88 >> 2] = 0;
   HEAP32[$1 + 92 >> 2] = 0;
   sqlite3Fts3DoclistPrev(0, HEAP32[$1 + 72 >> 2], HEAP32[$1 + 76 >> 2], $1 + 80 | 0, $1 + 88 | 0, $1 + 84 | 0, $2 + 15 | 0);
   break label$1;
  }
  $0 = fts3SegReaderRequire($1, HEAP32[$1 + 72 >> 2], 10);
  if ($0) {
   break label$1;
  }
  HEAP32[$1 + 80 >> 2] = sqlite3Fts3GetVarint(HEAP32[$1 + 72 >> 2], $1 + 88 | 0) + HEAP32[$1 + 72 >> 2];
  $0 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function fts3ExprLocalHitsCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$2 + 4 >> 2];
 $6 = Math_imul(Math_imul($3, $1), 3);
 $1 = 0;
 while (1) {
  if (!(($1 | 0) >= ($3 | 0) | $5)) {
   $5 = sqlite3Fts3EvalPhrasePoslist(HEAP32[$2 >> 2], $0, $1, $4 + 12 | 0);
   if (HEAP32[$4 + 12 >> 2]) {
    $3 = fts3ColumnlistCount($4 + 12 | 0);
   } else {
    $3 = 0;
   }
   HEAP32[HEAP32[$2 + 28 >> 2] + (Math_imul($1, 3) + $6 << 2) >> 2] = $3;
   $1 = $1 + 1 | 0;
   $3 = HEAP32[$2 + 4 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $4 + 16 | 0;
 return $5 | 0;
}

function fts3DecodeIntArray($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 label$1: {
  if (!$3 | HEAP8[($2 + $3 | 0) - 1 | 0] < 0) {
   break label$1;
  }
  while (1) {
   if (($0 | 0) <= ($4 | 0) | ($3 | 0) <= ($5 | 0)) {
    break label$1;
   }
   $7 = sqlite3Fts3GetVarint($2 + $5 | 0, $6 + 8 | 0);
   HEAP32[($4 << 2) + $1 >> 2] = HEAP32[$6 + 8 >> 2];
   $4 = $4 + 1 | 0;
   $5 = $5 + $7 | 0;
   continue;
  }
 }
 $5 = ($0 | 0) < ($4 | 0) ? $4 : $0;
 while (1) {
  if (($4 | 0) != ($5 | 0)) {
   HEAP32[($4 << 2) + $1 >> 2] = 0;
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $6 + 16 | 0;
}

function sqlite3_compileoption_used($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 sqlite3CompileOptions($1 + 12 | 0);
 $2 = (sqlite3_strnicmp($0, 17767, 7) ? 0 : 7) + $0 | 0;
 $3 = sqlite3Strlen30($2);
 $0 = HEAP32[$1 + 12 >> 2];
 $5 = ($0 | 0) > 0 ? $0 : 0;
 $0 = 0;
 while (1) {
  label$2: {
   if (($0 | 0) != ($5 | 0)) {
    $4 = HEAP32[($0 << 2) + 55232 >> 2];
    if (sqlite3_strnicmp($2, $4, $3)) {
     break label$2;
    }
    if (sqlite3IsIdChar(HEAPU8[$3 + $4 | 0])) {
     break label$2;
    }
    $6 = 1;
   }
   __stack_pointer = $1 + 16 | 0;
   return $6;
  }
  $0 = $0 + 1 | 0;
  continue;
 }
}

function fts3GetDeltaPosition($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 >> 2];
 $2 = HEAP8[$3 | 0];
 label$1: {
  if (($2 | 0) < 0) {
   $2 = sqlite3Fts3GetVarint32($3, $4 + 12 | 0);
   $5 = HEAP32[$4 + 12 >> 2];
   break label$1;
  }
  $5 = $2 & 255;
  $2 = 1;
 }
 HEAP32[$0 >> 2] = $2 + $3;
 $2 = HEAP32[$1 + 4 >> 2];
 $3 = $2;
 $0 = HEAP32[$1 >> 2];
 $6 = $0;
 $0 = $5 - 2 | 0;
 $2 = $0 >> 31;
 $5 = $0;
 $6 = $6 + $0 | 0;
 $0 = $2;
 $2 = $3;
 $0 = $0 + $2 | 0;
 HEAP32[$1 >> 2] = $6;
 $0 = $6 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
 HEAP32[$1 + 4 >> 2] = $0;
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3VdbeTransferError($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = HEAP32[$0 + 36 >> 2];
 $1 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$0 + 124 >> 2]) {
   HEAP8[$1 + 88 | 0] = HEAPU8[$1 + 88 | 0] + 1;
   sqlite3BeginBenignMalloc();
   $2 = HEAP32[$1 + 288 >> 2];
   if (!$2) {
    $2 = sqlite3ValueNew($1);
    HEAP32[$1 + 288 >> 2] = $2;
   }
   sqlite3ValueSetStr($2, HEAP32[$0 + 124 >> 2], 1, -1);
   sqlite3EndBenignMalloc();
   HEAP8[$1 + 88 | 0] = HEAPU8[$1 + 88 | 0] - 1;
   break label$1;
  }
  $0 = HEAP32[$1 + 288 >> 2];
  if (!$0) {
   break label$1;
  }
  sqlite3ValueSetNull($0);
 }
 HEAP32[$1 + 68 >> 2] = -1;
 HEAP32[$1 + 64 >> 2] = $3;
 return $3;
}

function sqlite3VdbeAddOp4Dup8($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $7 = sqlite3DbMallocRawNN(sqlite3VdbeDb($0), 8, 0);
 if ($7) {
  $5 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
  $6 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
  $3 = $5;
  $5 = $7;
  HEAP8[$5 | 0] = $3;
  HEAP8[$5 + 1 | 0] = $3 >>> 8;
  HEAP8[$5 + 2 | 0] = $3 >>> 16;
  HEAP8[$5 + 3 | 0] = $3 >>> 24;
  HEAP8[$5 + 4 | 0] = $6;
  HEAP8[$5 + 5 | 0] = $6 >>> 8;
  HEAP8[$5 + 6 | 0] = $6 >>> 16;
  HEAP8[$5 + 7 | 0] = $6 >>> 24;
 }
 sqlite3VdbeAddOp4($0, $1, 0, $2, 0, $7, $4);
}

function sqlite3RenameExprlistUnmap($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 label$1: {
  if (!$1) {
   break label$1;
  }
  HEAP32[$2 + 24 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 38;
  HEAP32[$2 >> 2] = $0;
  sqlite3WalkExprList($2, $1);
  while (1) {
   if (HEAP32[$1 >> 2] <= ($3 | 0)) {
    break label$1;
   }
   $4 = ($3 << 4) + $1 | 0;
   if (!(HEAPU8[$4 + 17 | 0] & 3)) {
    sqlite3RenameTokenRemap($0, 0, HEAP32[$4 + 12 >> 2]);
   }
   $3 = $3 + 1 | 0;
   continue;
  }
 }
 __stack_pointer = $2 + 32 | 0;
}

function sqlite3GetCollSeq($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   if (!$2) {
    $2 = sqlite3FindCollSeq($5, $1, $3, 0);
    if (!$2) {
     break label$2;
    }
   }
   if (HEAP32[$2 + 12 >> 2]) {
    break label$1;
   }
  }
  callCollNeeded($5, $1, $3);
  $2 = sqlite3FindCollSeq($5, $1, $3, 0);
  if ($2) {
   if (HEAP32[$2 + 12 >> 2]) {
    break label$1;
   }
   if (!synthCollSeq($5, $2)) {
    break label$1;
   }
  }
  HEAP32[$4 >> 2] = $3;
  sqlite3ErrorMsg($0, 7988, $4);
  HEAP32[$0 + 12 >> 2] = 257;
  $2 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $2;
}

function sqlite3SetJoinExpr($0, $1, $2) {
 var $3 = 0, $4 = 0;
 while (1) {
  if ($0) {
   HEAP32[$0 + 36 >> 2] = $1;
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | $2;
   label$3: {
    if (HEAPU8[$0 | 0] != 172) {
     break label$3;
    }
    $3 = 0;
    $4 = HEAP32[$0 + 20 >> 2];
    if (!$4) {
     break label$3;
    }
    while (1) {
     if (HEAP32[$4 >> 2] <= ($3 | 0)) {
      break label$3;
     }
     sqlite3SetJoinExpr(HEAP32[(($3 << 4) + $4 | 0) + 8 >> 2], $1, $2);
     $3 = $3 + 1 | 0;
     $4 = HEAP32[$0 + 20 >> 2];
     continue;
    }
   }
   sqlite3SetJoinExpr(HEAP32[$0 + 12 >> 2], $1, $2);
   $0 = HEAP32[$0 + 16 >> 2];
   continue;
  }
  break;
 }
}

function recomputeColumnsNotIndexed($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = HEAPU16[$0 + 52 >> 1];
 $6 = HEAP32[$0 + 12 >> 2];
 while (1) {
  if (($3 | 0) > 0) {
   $3 = $3 - 1 | 0;
   $1 = HEAP16[HEAP32[$0 + 4 >> 2] + ($3 << 1) >> 1];
   if (($1 | 0) < 0 | (HEAPU8[(HEAP32[$6 + 4 >> 2] + Math_imul($1, 12) | 0) + 10 | 0] & 32 | $1 >>> 0 > 62)) {
    continue;
   }
   $2 = $1 & 31;
   if (($1 & 63) >>> 0 >= 32) {
    $1 = 1 << $2;
    $2 = 0;
   } else {
    $1 = (1 << $2) - 1 & 1 >>> 32 - $2;
    $2 = 1 << $2;
   }
   $4 = $2 | $4;
   $5 = $1 | $5;
   continue;
  }
  break;
 }
 HEAP32[$0 + 64 >> 2] = $4 ^ -1;
 HEAP32[$0 + 68 >> 2] = $5 ^ -1;
}

function exprINAffinity($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = HEAP32[$1 + 12 >> 2];
 $2 = sqlite3ExprVectorSize($5);
 $4 = HEAPU8[$1 + 5 | 0] & 16 ? HEAP32[$1 + 20 >> 2] : $4;
 $1 = $2 + 1 | 0;
 $3 = sqlite3DbMallocRaw(HEAP32[$0 >> 2], $1, $1 >> 31);
 if ($3) {
  $1 = 0;
  $6 = ($2 | 0) > 0 ? $2 : 0;
  while (1) {
   if (($1 | 0) != ($6 | 0)) {
    $0 = sqlite3ExprAffinity(sqlite3VectorFieldSubexpr($5, $1));
    if ($4) {
     $0 = sqlite3CompareAffinity(HEAP32[(HEAP32[$4 + 28 >> 2] + ($1 << 4) | 0) + 8 >> 2], $0);
    }
    HEAP8[$1 + $3 | 0] = $0;
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$2 + $3 | 0] = 0;
 }
 return $3;
}

function sqlite3UnlinkAndDeleteIndex($0, $1, $2) {
 var $3 = 0;
 $3 = sqlite3HashInsert(HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 24 | 0, $2, 0);
 if ($3) {
  $2 = HEAP32[$3 + 12 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  label$2: {
   label$3: {
    if (($3 | 0) == ($1 | 0)) {
     $1 = $2 + 8 | 0;
     break label$3;
    }
    while (1) {
     $2 = $1;
     if (!$2) {
      break label$2;
     }
     $1 = HEAP32[$2 + 20 >> 2];
     if (($3 | 0) != ($1 | 0)) {
      continue;
     }
     break;
    }
    $1 = $2 + 20 | 0;
   }
   HEAP32[$1 >> 2] = HEAP32[$3 + 20 >> 2];
  }
  sqlite3FreeIndex($0, $3);
 }
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | 1;
}

function disableTerm($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  label$2: {
   $2 = HEAPU16[$1 + 10 >> 1];
   if ($2 & 4 | (HEAP8[HEAP32[$1 >> 2] + 4 | 0] & 1 ? 0 : HEAP32[$0 >> 2]) | (HEAP32[$1 + 40 >> 2] & HEAP32[$0 + 88 >> 2] | HEAP32[$1 + 44 >> 2] & HEAP32[$0 + 92 >> 2])) {
    break label$2;
   }
   HEAP16[$1 + 10 >> 1] = ($3 ? $2 & 1024 ? 512 : 4 : 4) | $2;
   $2 = HEAP32[$1 + 16 >> 2];
   if (($2 | 0) < 0) {
    break label$2;
   }
   $1 = HEAP32[HEAP32[$1 + 4 >> 2] + 24 >> 2] + Math_imul($2, 48) | 0;
   $2 = HEAPU8[$1 + 14 | 0] - 1 | 0;
   HEAP8[$1 + 14 | 0] = $2;
   if ($2 & 255) {
    break label$2;
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
}

function unixSync($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 label$1: {
  if (full_fsync(HEAP32[$0 + 12 >> 2])) {
   storeLastErrno($0, HEAP32[__errno_location() >> 2]);
   $2 = 1034;
   unixLogErrorAtLine(1034, 16985, HEAP32[$0 + 32 >> 2], 39233);
   break label$1;
  }
  if (!(HEAPU8[$0 + 18 | 0] & 8)) {
   break label$1;
  }
  if (!(FUNCTION_TABLE[HEAP32[16288]](HEAP32[$0 + 32 >> 2], $1 + 12 | 0) | 0)) {
   full_fsync(HEAP32[$1 + 12 >> 2]);
   robust_close($0, HEAP32[$1 + 12 >> 2], 39247);
  }
  HEAP16[$0 + 18 >> 1] = HEAPU16[$0 + 18 >> 1] & 65527;
 }
 __stack_pointer = $1 + 16 | 0;
 return $2 | 0;
}

function sqlite3ResetOneSchema($0, $1) {
 var $2 = 0;
 if (($1 | 0) >= 0) {
  $2 = HEAP32[$0 + 16 >> 2];
  $1 = HEAP32[($2 + ($1 << 4) | 0) + 12 >> 2];
  HEAP16[$1 + 78 >> 1] = HEAPU16[$1 + 78 >> 1] | 8;
  $1 = HEAP32[$2 + 28 >> 2];
  HEAP16[$1 + 78 >> 1] = HEAPU16[$1 + 78 >> 1] | 8;
  HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] & -17;
 }
 label$2: {
  if (HEAP32[$0 + 56 >> 2]) {
   break label$2;
  }
  $1 = 0;
  while (1) {
   if (HEAP32[$0 + 20 >> 2] <= ($1 | 0)) {
    break label$2;
   }
   $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
   if (HEAPU8[$2 + 78 | 0] & 8) {
    sqlite3SchemaClear($2);
   }
   $1 = $1 + 1 | 0;
   continue;
  }
 }
}

function verifyDbFile($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 label$1: {
  if (HEAPU8[$0 + 18 | 0] & 128) {
   break label$1;
  }
  $2 = 6492;
  label$2: {
   if (FUNCTION_TABLE[HEAP32[16252]](HEAP32[$0 + 12 >> 2], $1 + 16 | 0) | 0) {
    break label$2;
   }
   $2 = 7441;
   label$3: {
    switch (HEAP32[$1 + 32 >> 2]) {
    default:
     $2 = 7835;
     break label$2;

    case 0:
     break label$2;

    case 1:
     break label$3;
    }
   }
   $2 = 7413;
   if (!fileHasMoved($0)) {
    break label$1;
   }
  }
  HEAP32[$1 >> 2] = HEAP32[$0 + 32 >> 2];
  sqlite3_log(28, $2, $1);
 }
 __stack_pointer = $1 + 128 | 0;
}

function clearAllSharedCacheTableLocks($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 $3 = $2 + 76 | 0;
 while (1) {
  $1 = HEAP32[$3 >> 2];
  if ($1) {
   if (HEAP32[$1 >> 2] != ($0 | 0)) {
    $3 = $1 + 12 | 0;
    continue;
   }
   HEAP32[$3 >> 2] = HEAP32[$1 + 12 >> 2];
   if (HEAP32[$1 + 4 >> 2] == 1) {
    continue;
   }
   sqlite3_free($1);
   continue;
  }
  break;
 }
 label$4: {
  label$5: {
   if (HEAP32[$2 + 80 >> 2] == ($0 | 0)) {
    HEAP32[$2 + 80 >> 2] = 0;
    $1 = 65343;
    break label$5;
   }
   $1 = 65407;
   if (HEAP32[$2 + 44 >> 2] != 2) {
    break label$4;
   }
  }
  HEAP16[$2 + 24 >> 1] = HEAPU16[$2 + 24 >> 1] & $1;
 }
}

function sqlite3VtabCreateModule($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 if ($2) {
  $6 = sqlite3Strlen30($1);
  $5 = sqlite3Malloc($6 + 25 | 0, 0);
  if (!$5) {
   sqlite3OomFault($0);
   return 0;
  }
  $1 = __memcpy($5 + 24 | 0, $1, $6 + 1 | 0);
  HEAP32[$5 + 20 >> 2] = 0;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 >> 2] = $2;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = 1;
 }
 $1 = sqlite3HashInsert($0 + 384 | 0, $1, $5);
 if ($1) {
  if (($1 | 0) == ($5 | 0)) {
   sqlite3OomFault($0);
   sqlite3DbFree($0, $5);
   return 0;
  }
  sqlite3VtabEponymousTableClear($0, $1);
  sqlite3VtabModuleUnref($0, $1);
 }
 return $5;
}

function freeP4($0, $1, $2) {
 label$1: {
  label$2: {
   switch ($1 + 15 | 0) {
   case 0:
    freeP4FuncCtx($0, $2);
    return;

   case 1:
   case 2:
   case 3:
   case 9:
    sqlite3DbFree($0, $2);
    return;

   case 7:
    if (HEAP32[$0 + 528 >> 2]) {
     break label$1;
    }
    sqlite3KeyInfoUnref($2);
    return;

   case 8:
    freeEphemeralFunction($0, $2);
    return;

   case 5:
    if (!HEAP32[$0 + 528 >> 2]) {
     sqlite3ValueFree($2);
     return;
    }
    freeP4Mem($0, $2);
    return;

   case 4:
    break label$2;

   default:
    break label$1;
   }
  }
  if (HEAP32[$0 + 528 >> 2]) {
   break label$1;
  }
  sqlite3VtabUnlock($2);
 }
}

function __procfdname($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 while (1) {
  $4 = $0 + $2 | 0;
  HEAP8[$4 | 0] = HEAPU8[$2 + 24243 | 0];
  $3 = ($2 | 0) != 14;
  $2 = $2 + 1 | 0;
  if ($3) {
   continue;
  }
  break;
 }
 if ($1) {
  $2 = 14;
  $3 = $1;
  while (1) {
   $2 = $2 + 1 | 0;
   $4 = $3 >>> 0 > 9;
   $3 = ($3 >>> 0) / 10 | 0;
   if ($4) {
    continue;
   }
   break;
  }
  HEAP8[$0 + $2 | 0] = 0;
  while (1) {
   $2 = $2 - 1 | 0;
   $3 = ($1 >>> 0) / 10 | 0;
   HEAP8[$2 + $0 | 0] = Math_imul($3, 246) + $1 | 48;
   $4 = $1 >>> 0 > 9;
   $1 = $3;
   if ($4) {
    continue;
   }
   break;
  }
  return;
 }
 HEAP8[$4 | 0] = 48;
 HEAP8[$0 + 15 | 0] = 0;
}

function pcacheMergeDirtyList($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 $2 = $5 + 8 | 0;
 label$1: {
  label$2: while (1) {
   $4 = $0;
   $0 = HEAP32[$4 + 24 >> 2];
   while (1) {
    $3 = $1;
    if (HEAPU32[$3 + 24 >> 2] > $0 >>> 0) {
     HEAP32[$2 + 16 >> 2] = $4;
     $2 = $4;
     $2 = $4;
     $0 = HEAP32[$4 + 16 >> 2];
     if ($0) {
      continue label$2;
     }
     break label$1;
    }
    HEAP32[$2 + 16 >> 2] = $3;
    $2 = $3;
    $1 = HEAP32[$3 + 16 >> 2];
    if ($1) {
     continue;
    }
    break;
   }
   break;
  }
  $2 = $3;
  $3 = $4;
 }
 HEAP32[$2 + 16 >> 2] = $3;
 return HEAP32[$5 + 24 >> 2];
}

function m_gt_1($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 while (1) {
  $1 = $0;
  $0 = $0 + 1 | 0;
  if (isVowel($1)) {
   continue;
  }
  break;
 }
 label$2: {
  if (!HEAPU8[$1 | 0]) {
   break label$2;
  }
  while (1) {
   $0 = $1;
   $1 = $0 + 1 | 0;
   if (isConsonant($0)) {
    continue;
   }
   break;
  }
  if (!HEAPU8[$0 | 0]) {
   break label$2;
  }
  while (1) {
   $1 = $0;
   $0 = $0 + 1 | 0;
   if (isVowel($1)) {
    continue;
   }
   break;
  }
  if (!HEAPU8[$1 | 0]) {
   break label$2;
  }
  while (1) {
   $0 = $1;
   $1 = $0 + 1 | 0;
   if (isConsonant($0)) {
    continue;
   }
   break;
  }
  $2 = HEAPU8[$0 | 0] != 0;
 }
 return $2 | 0;
}

function sqlite3TriggerUpdateStep($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = HEAP32[$0 >> 2];
 $7 = triggerStepAllocate($0, 129, $1, $6, $7);
 if ($7) {
  label$2: {
   if (HEAPU8[$0 + 208 | 0] >= 2) {
    HEAP32[$7 + 20 >> 2] = $4;
    HEAP32[$7 + 24 >> 2] = $3;
    $4 = 0;
    $0 = $2;
    $3 = 0;
    $2 = 0;
    break label$2;
   }
   HEAP32[$7 + 24 >> 2] = sqlite3ExprListDup($8, $3, 1);
   HEAP32[$7 + 20 >> 2] = sqlite3ExprDup($8, $4, 1);
   $0 = sqlite3SrcListDup($8, $2, 1);
  }
  HEAP8[$7 + 1 | 0] = $5;
  HEAP32[$7 + 16 >> 2] = $0;
 }
 sqlite3ExprListDelete($8, $3);
 sqlite3ExprDelete($8, $4);
 sqlite3SrcListDelete($8, $2);
 return $7;
}

function sqlite3_blob_reopen($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!$0) {
   $0 = sqlite3MisuseError(97585);
   break label$1;
  }
  $5 = HEAP32[$0 + 20 >> 2];
  $4 = HEAP32[$0 + 16 >> 2];
  label$3: {
   if (!$4) {
    $0 = 4;
    break label$3;
   }
   HEAP32[$4 + 36 >> 2] = 0;
   $0 = blobSeekToRow($0, $1, $2, $3 + 12 | 0);
   if (!$0) {
    break label$3;
   }
   $4 = HEAP32[$3 + 12 >> 2];
   HEAP32[$3 >> 2] = $4;
   sqlite3ErrorWithMsg($5, $0, $4 ? 8342 : 0, $3);
   sqlite3DbFree($5, $4);
  }
  $0 = sqlite3ApiExit($5, $0);
 }
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function sqlite3IntFloatCompare($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 __floatditf($4, $0, $1);
 __extenddftf2($4 + 16 | 0, $2);
 $3 = $4;
 $0 = HEAP32[$3 >> 2];
 $5 = HEAP32[$3 + 24 >> 2];
 $6 = HEAP32[$3 + 28 >> 2];
 $1 = HEAP32[$3 + 4 >> 2];
 $7 = HEAP32[$3 + 8 >> 2];
 $8 = HEAP32[$3 + 12 >> 2];
 $9 = HEAP32[$3 + 16 >> 2];
 $10 = HEAP32[$3 + 20 >> 2];
 $3 = $10;
 $11 = __letf2($0, $1, $7, $8, $9, $3, $5, $6);
 $3 = $8;
 $0 = __getf2($0, $1, $7, $3, $9, $10, $5, $6);
 __stack_pointer = $4 + 32 | 0;
 return ($11 | 0) < 0 ? -1 : ($0 | 0) > 0;
}

function walCleanupHash($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $2 = HEAP32[$0 + 68 >> 2];
 label$1: {
  if (!$2) {
   break label$1;
  }
  if (walHashGet($0, walFramePage($2), $1)) {
   break label$1;
  }
  $3 = HEAP32[$0 + 68 >> 2] - HEAP32[$1 + 8 >> 2] | 0;
  $4 = HEAP32[$1 >> 2];
  $0 = 0;
  while (1) {
   if (($0 | 0) != 8192) {
    $2 = ($0 << 1) + $4 | 0;
    if (HEAPU16[$2 >> 1] > ($3 | 0)) {
     HEAP16[$2 >> 1] = 0;
    }
    $0 = $0 + 1 | 0;
    continue;
   }
   break;
  }
  $0 = HEAP32[$1 + 4 >> 2] + ($3 << 2) | 0;
  memset($0, 0, $4 - $0 | 0);
 }
 __stack_pointer = $1 + 16 | 0;
}

function sqlite3ExprSimplifiedAndOr($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = HEAPU8[$0 | 0];
 label$1: {
  if (($1 - 43 & 255) >>> 0 > 1) {
   break label$1;
  }
  $2 = sqlite3ExprSimplifiedAndOr(HEAP32[$0 + 16 >> 2]);
  label$2: {
   $3 = sqlite3ExprSimplifiedAndOr(HEAP32[$0 + 12 >> 2]);
   $4 = HEAP32[$3 + 4 >> 2];
   if (($4 & 268435457) != 268435456) {
    $5 = HEAP32[$2 + 4 >> 2];
    if (($5 & 536870913) != 536870912) {
     break label$2;
    }
   }
   return ($1 | 0) == 44 ? $2 : $3;
  }
  if (($5 & 268435457) != 268435456 & ($4 & 536870913) != 536870912) {
   break label$1;
  }
  $0 = ($1 | 0) == 44 ? $3 : $2;
 }
 return $0;
}

function fts3tokBestIndexMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $0 = HEAP32[$1 >> 2];
 $3 = ($0 | 0) > 0 ? $0 : 0;
 label$1: {
  while (1) {
   if (($2 | 0) != ($3 | 0)) {
    $0 = HEAP32[$1 + 4 >> 2] + Math_imul($2, 12) | 0;
    if (!(!HEAPU8[$0 + 5 | 0] | HEAP32[$0 >> 2] | HEAPU8[$0 + 4 | 0] != 2)) {
     HEAP32[$1 + 20 >> 2] = 1;
     $2 = HEAP32[$1 + 16 >> 2] + ($2 << 3) | 0;
     HEAP8[$2 + 4 | 0] = 1;
     HEAP32[$2 >> 2] = 1;
     HEAP32[$1 + 40 >> 2] = 0;
     HEAP32[$1 + 44 >> 2] = 1072693248;
     break label$1;
    }
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$1 + 20 >> 2] = 0;
 }
 return 0;
}

function upperFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $1 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
 label$1: {
  if (!$4) {
   break label$1;
  }
  $2 = $1 >> 31;
  $3 = $1 + 1 | 0;
  $2 = $3 ? $2 : $2 + 1 | 0;
  $3 = contextMalloc($0, $3, $2);
  if (!$3) {
   break label$1;
  }
  $2 = 0;
  $6 = ($1 | 0) > 0 ? $1 : 0;
  while (1) {
   if (($2 | 0) != ($6 | 0)) {
    $5 = HEAPU8[$2 + $4 | 0];
    HEAP8[$2 + $3 | 0] = $5 & (HEAPU8[$5 + 30288 | 0] ^ -1 | 223);
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_result_text($0, $3, $1, 3);
 }
}

function sqlite3IdListAppend($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$0 >> 2];
 label$1: {
  label$2: {
   if (!$1) {
    $3 = sqlite3DbMallocZero($4, 16, 0);
    if ($3) {
     break label$2;
    }
    break label$1;
   }
   $3 = sqlite3DbRealloc($4, $1, (HEAP32[$1 >> 2] << 3) + 16 | 0, 0);
   if ($3) {
    break label$2;
   }
   sqlite3IdListDelete($4, $1);
   break label$1;
  }
  $1 = HEAP32[$3 >> 2];
  HEAP32[$3 >> 2] = $1 + 1;
  $5 = ($1 << 3) + $3 | 0;
  $1 = sqlite3NameFromToken($4, $2);
  HEAP32[$5 + 8 >> 2] = $1;
  if (!(!$1 | HEAPU8[$0 + 208 | 0] < 2)) {
   sqlite3RenameTokenMap($0, $1, $2);
  }
  return $3;
 }
 return 0;
}

function searchWith($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$1 + 8 >> 2];
 while (1) {
  label$2: {
   if (!$0) {
    break label$2;
   }
   $1 = 0;
   $3 = HEAP32[$0 >> 2];
   $5 = ($3 | 0) > 0 ? $3 : 0;
   label$3: {
    while (1) {
     if (($1 | 0) == ($5 | 0)) {
      break label$3;
     }
     $3 = Math_imul($1, 24);
     $1 = $1 + 1 | 0;
     $3 = ($0 + $3 | 0) + 12 | 0;
     if (sqlite3StrICmp($4, HEAP32[$3 >> 2])) {
      continue;
     }
     break;
    }
    HEAP32[$2 >> 2] = $0;
    return $3;
   }
   if (HEAP32[$0 + 4 >> 2]) {
    break label$2;
   }
   $0 = HEAP32[$0 + 8 >> 2];
   continue;
  }
  break;
 }
 return 0;
}

function sqlite3TriggerInsertStep($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0;
 $8 = HEAP32[$0 >> 2];
 $7 = triggerStepAllocate($0, 127, $1, $6, $7);
 label$1: {
  if ($7) {
   label$3: {
    if (HEAPU8[$0 + 208 | 0] > 1) {
     $6 = $3;
     $3 = 0;
     break label$3;
    }
    $6 = sqlite3SelectDup($8, $3, 1);
   }
   HEAP32[$7 + 32 >> 2] = $5;
   HEAP32[$7 + 28 >> 2] = $2;
   HEAP32[$7 + 8 >> 2] = $6;
   HEAP8[$7 + 1 | 0] = $4;
   if (!$5) {
    break label$1;
   }
   sqlite3HasExplicitNulls($0, HEAP32[$5 >> 2]);
   break label$1;
  }
  sqlite3IdListDelete($8, $2);
  sqlite3UpsertDelete($8, $5);
 }
 sqlite3SelectDelete($8, $3);
 return $7;
}

function getAbsoluteLevel($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $5 = $3;
 $4 = $5 >> 31;
 $6 = $4;
 $5 = $2;
 $4 = $5 >> 31;
 $7 = $4;
 $4 = HEAP32[$0 + 256 >> 2];
 $5 = $4 >> 31;
 $8 = $4;
 $0 = $5;
 $4 = $1;
 $5 = $4 >> 31;
 $4 = $5;
 $5 = $0;
 $4 = __wasm_i64_mul($8, $5, $1, $4);
 $0 = $4;
 $2 = $4 + $2 | 0;
 $5 = i64toi32_i32$HIGH_BITS;
 $4 = $5;
 $5 = $7;
 $4 = $4 + $5 | 0;
 $5 = $2;
 $1 = $5 << 10;
 $4 = $5 >>> 0 < $0 >>> 0 ? $4 + 1 | 0 : $4;
 $5 = $4 << 10 | $5 >>> 22;
 $2 = $6 + $5 | 0;
 $0 = $1;
 $4 = $3;
 $4 = $0 + $4 | 0;
 $2 = $4 >>> 0 < $0 >>> 0 ? $2 + 1 | 0 : $2;
 i64toi32_i32$HIGH_BITS = $2;
 return $4;
}

function sqlite3Fts3DeferredTokenList($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$1 >> 2] = 0;
 HEAP32[$2 >> 2] = 0;
 $3 = HEAP32[$0 + 12 >> 2];
 label$1: {
  if (!$3) {
   break label$1;
  }
  $3 = sqlite3_malloc(HEAP32[$3 >> 2]);
  if (!$3) {
   $7 = 7;
   break label$1;
  }
  $5 = sqlite3Fts3GetVarint(HEAP32[HEAP32[$0 + 12 >> 2] + 4 >> 2], $4 + 8 | 0);
  $6 = HEAP32[HEAP32[$0 + 12 >> 2] >> 2] - $5 | 0;
  HEAP32[$2 >> 2] = $6;
  HEAP32[$1 >> 2] = $3;
  __memcpy($3, HEAP32[HEAP32[$0 + 12 >> 2] + 4 >> 2] + $5 | 0, $6);
 }
 __stack_pointer = $4 + 16 | 0;
 return $7;
}

function ptrmapPutOvflPtr($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$3 >> 2]) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[$0 + 80 >> 2]]($0, $2, $4 + 8 | 0);
  $5 = HEAPU16[$4 + 24 >> 1];
  if ($5 >>> 0 >= HEAPU32[$4 + 20 >> 2]) {
   break label$1;
  }
  $1 = HEAP32[$1 + 60 >> 2];
  if (!($2 >>> 0 > $1 >>> 0 | $2 + $5 >>> 0 <= $1 >>> 0)) {
   HEAP32[$3 >> 2] = sqlite3CorruptError(68325);
   break label$1;
  }
  ptrmapPut(HEAP32[$0 + 52 >> 2], sqlite3Get4byte((HEAPU16[$4 + 26 >> 1] + $2 | 0) - 4 | 0), 3, HEAP32[$0 + 4 >> 2], $3);
 }
 __stack_pointer = $4 + 32 | 0;
}

function sqlite3VdbeIdxKeyCompare($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $1 = HEAP32[$1 + 36 >> 2];
 $5 = sqlite3BtreePayloadSize($1);
 label$1: {
  if (($5 | 0) <= 0) {
   HEAP32[$3 >> 2] = 0;
   $1 = sqlite3CorruptError(85744);
   break label$1;
  }
  sqlite3VdbeMemInit($4 + 8 | 0, $0, 0);
  $1 = sqlite3VdbeMemFromBtreeZeroOffset($1, $5, $4 + 8 | 0);
  if ($1) {
   break label$1;
  }
  $1 = 0;
  HEAP32[$3 >> 2] = sqlite3VdbeRecordCompareWithSkip(HEAP32[$4 + 20 >> 2], HEAP32[$4 + 16 >> 2], $2, 0);
  sqlite3VdbeMemReleaseMalloc($4 + 8 | 0);
 }
 __stack_pointer = $4 + 48 | 0;
 return $1;
}

function sqlite3Fts3EvalTestDeferred($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = HEAP32[$1 >> 2];
 HEAP32[$3 + 12 >> 2] = $2;
 if (!$2) {
  label$2: {
   if (!HEAP32[$0 + 28 >> 2]) {
    break label$2;
   }
   $2 = fts3CursorSeek(0, $0);
   HEAP32[$3 + 12 >> 2] = $2;
   if ($2) {
    break label$2;
   }
   HEAP32[$3 + 12 >> 2] = sqlite3Fts3CacheDeferredDoclists($0);
  }
  $4 = fts3EvalTestExpr($0, HEAP32[$0 + 16 >> 2], $3 + 12 | 0);
  sqlite3Fts3FreeDeferredDoclists($0);
  $2 = HEAP32[$3 + 12 >> 2];
  HEAP32[$1 >> 2] = $2;
  $4 = !$4;
 }
 __stack_pointer = $3 + 16 | 0;
 return !$2 & $4;
}

function scalbn($0, $1) {
 label$1: {
  if (($1 | 0) >= 1024) {
   $0 = $0 * 898846567431158e293;
   if ($1 >>> 0 < 2047) {
    $1 = $1 - 1023 | 0;
    break label$1;
   }
   $0 = $0 * 898846567431158e293;
   $1 = (($1 | 0) < 3069 ? $1 : 3069) - 2046 | 0;
   break label$1;
  }
  if (($1 | 0) > -1023) {
   break label$1;
  }
  $0 = $0 * 2004168360008973e-307;
  if ($1 >>> 0 > 4294965304) {
   $1 = $1 + 969 | 0;
   break label$1;
  }
  $0 = $0 * 2004168360008973e-307;
  $1 = (($1 | 0) > -2960 ? $1 : -2960) + 1938 | 0;
 }
 wasm2js_scratch_store_i32(0, 0);
 wasm2js_scratch_store_i32(1, $1 + 1023 << 20);
 return $0 * +wasm2js_scratch_load_f64();
}

function sqlite3MaterializeView($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $4 = HEAP32[$0 >> 2];
 $6 = sqlite3SchemaToIndex($4, HEAP32[$1 + 60 >> 2]);
 $7 = sqlite3ExprDup($4, $2, 0);
 $2 = sqlite3SrcListAppend($0, 0, 0, 0);
 if ($2) {
  HEAP32[$2 + 16 >> 2] = sqlite3DbStrDup($4, HEAP32[$1 >> 2]);
  HEAP32[$2 + 12 >> 2] = sqlite3DbStrDup($4, HEAP32[HEAP32[$4 + 16 >> 2] + ($6 << 4) >> 2]);
 }
 $2 = sqlite3SelectNew($0, 0, $2, $7, 0, 0, 0, 131072, 0);
 sqlite3SelectDestInit($5, 12, $3);
 sqlite3Select($0, $2, $5);
 sqlite3SelectDelete($4, $2);
 __stack_pointer = $5 + 32 | 0;
}

function jsonAppendValue($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  switch (sqlite3_value_type($1) - 1 | 0) {
  case 4:
   jsonAppendRaw($0, 11103, 4);
   return;

  case 0:
  case 1:
   jsonAppendRaw($0, sqlite3_value_text($1), sqlite3_value_bytes($1));
   return;

  case 2:
   $2 = sqlite3_value_text($1);
   $3 = sqlite3_value_bytes($1);
   if ((sqlite3_value_subtype($1) | 0) == 74) {
    jsonAppendRaw($0, $2, $3);
    return;
   }
   jsonAppendString($0, $2, $3);
   return;

  default:
   break label$1;
  }
 }
 if (!HEAPU8[$0 + 25 | 0]) {
  sqlite3_result_error(HEAP32[$0 >> 2], 5048, -1);
  HEAP8[$0 + 25 | 0] = 2;
  jsonReset($0);
 }
}

function fts3Rehash($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  $3 = fts3HashMalloc($1 << 3, 0);
  if (!$3) {
   $4 = 1;
   break label$1;
  }
  fts3HashFree(HEAP32[$0 + 16 >> 2]);
  HEAP32[$0 + 12 >> 2] = $1;
  HEAP32[$0 + 16 >> 2] = $3;
  $5 = ftsHashFunction(HEAP8[$0 | 0]);
  $2 = HEAP32[$0 + 8 >> 2];
  HEAP32[$0 + 8 >> 2] = 0;
  $6 = $1 - 1 | 0;
  while (1) {
   if (!$2) {
    break label$1;
   }
   $1 = FUNCTION_TABLE[$5 | 0](HEAP32[$2 + 12 >> 2], HEAP32[$2 + 16 >> 2]) | 0;
   $7 = HEAP32[$2 >> 2];
   fts3HashInsertElement($0, (($1 & $6) << 3) + $3 | 0, $2);
   $2 = $7;
   continue;
  }
 }
 return $4;
}

function asinh($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $1 = wasm2js_scratch_load_i32(0) | 0;
 wasm2js_scratch_store_i32(0, $1 | 0);
 wasm2js_scratch_store_i32(1, $2 & 2147483647);
 $0 = +wasm2js_scratch_load_f64();
 $1 = $2 >>> 20 & 2047;
 label$1: {
  if ($1 >>> 0 >= 1049) {
   $0 = log($0) + .6931471805599453;
   break label$1;
  }
  if ($1 >>> 0 >= 1024) {
   $0 = log($0 + $0 + 1 / (sqrt($0 * $0 + 1) + $0));
   break label$1;
  }
  if ($1 >>> 0 < 997) {
   break label$1;
  }
  $3 = $0 * $0;
  $0 = log1p($3 / (sqrt($3 + 1) + 1) + $0);
 }
 return ($2 | 0) < 0 ? -$0 : $0;
}

function unixTempFileDir() {
 var $0 = 0, $1 = 0, $2 = 0;
 $1 = __stack_pointer - 112 | 0;
 __stack_pointer = $1;
 $0 = 70764;
 while (1) {
  label$2: {
   $0 = HEAP32[$0 >> 2];
   label$3: {
    label$4: {
     if (!$0) {
      break label$4;
     }
     if (FUNCTION_TABLE[HEAP32[16249]]($0, $1) | (HEAP32[$1 + 12 >> 2] & 61440) != 16384) {
      break label$4;
     }
     if (!(FUNCTION_TABLE[HEAP32[16243]]($0, 3) | 0)) {
      break label$3;
     }
    }
    if (($2 | 0) != 6) {
     break label$2;
    }
    $0 = 0;
   }
   __stack_pointer = $1 + 112 | 0;
   return $0;
  }
  $0 = ($2 << 2) + 65296 | 0;
  $2 = $2 + 1 | 0;
  continue;
 }
}

function doWalCallbacks($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 while (1) {
  if (($2 | 0) < HEAP32[$0 + 20 >> 2]) {
   $3 = $2 << 4;
   $1 = HEAP32[($3 + HEAP32[$0 + 16 >> 2] | 0) + 4 >> 2];
   label$3: {
    if (!$1) {
     break label$3;
    }
    sqlite3BtreeEnter($1);
    $1 = sqlite3PagerWalCallback(sqlite3BtreePager($1));
    if (($1 | 0) <= 0) {
     break label$3;
    }
    $4 = HEAP32[$0 + 268 >> 2];
    if (!$4 | $5) {
     break label$3;
    }
    $5 = FUNCTION_TABLE[$4 | 0](HEAP32[$0 + 272 >> 2], $0, HEAP32[HEAP32[$0 + 16 >> 2] + $3 >> 2], $1) | 0;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 return $5;
}

function sqlite3RowidConstraint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $4 = HEAP16[$2 + 32 >> 1];
 label$1: {
  if (($4 | 0) >= 0) {
   $5 = HEAP32[$0 >> 2];
   $6 = HEAP32[$2 >> 2];
   HEAP32[$3 + 4 >> 2] = HEAP32[HEAP32[$2 + 4 >> 2] + Math_imul($4 & 65535, 12) >> 2];
   HEAP32[$3 >> 2] = $6;
   $2 = 1555;
   $4 = sqlite3MPrintf($5, 6016, $3);
   break label$1;
  }
  $4 = HEAP32[$0 >> 2];
  HEAP32[$3 + 16 >> 2] = HEAP32[$2 >> 2];
  $2 = 2579;
  $4 = sqlite3MPrintf($4, 14362, $3 + 16 | 0);
 }
 sqlite3HaltConstraint($0, $2, $1, $4, -6, 2);
 __stack_pointer = $3 + 32 | 0;
}

function sqlite3BtreeRollback($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 label$1: {
  if (!$1) {
   $2 = 0;
   $1 = saveAllCursors($3, 0, 0);
   if (!$1) {
    break label$1;
   }
  }
  sqlite3BtreeTripAllCursors($0, $1, $2);
 }
 if (HEAPU8[$0 + 8 | 0] == 2) {
  sqlite3PagerRollback(HEAP32[$3 >> 2]);
  if (!btreeGetPage($3, 1, $4 + 12 | 0, 0)) {
   $1 = HEAP32[$4 + 12 >> 2];
   btreeSetNPage($3, $1);
   releasePageOne($1);
  }
  HEAP8[$3 + 20 | 0] = 1;
  btreeClearHasContent($3);
 }
 btreeEndTransaction($0);
 __stack_pointer = $4 + 16 | 0;
}

function indexCellCompare($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $0 = HEAP32[$0 + 116 >> 2];
 $1 = HEAP32[$0 + 64 >> 2] + ($1 << 1) | 0;
 $1 = HEAP32[$0 + 68 >> 2] + (HEAPU16[$0 + 26 >> 1] & (HEAPU8[$1 + 1 | 0] | HEAPU8[$1 | 0] << 8)) | 0;
 $4 = $1 + 1 | 0;
 $5 = HEAPU8[$1 | 0];
 if ($5 >>> 0 <= HEAPU8[$0 + 11 | 0]) {
  return FUNCTION_TABLE[$3 | 0]($5, $4, $2) | 0;
 }
 $6 = 99;
 $4 = HEAP8[$4 | 0];
 label$2: {
  if (($4 | 0) < 0) {
   break label$2;
  }
  $4 = ($5 << 7 & 16256) + ($4 & 255) | 0;
  if ($4 >>> 0 > HEAPU16[$0 + 14 >> 1]) {
   break label$2;
  }
  $6 = FUNCTION_TABLE[$3 | 0]($4, $1 + 2 | 0, $2) | 0;
 }
 return $6;
}

function fts3SegReaderSort($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $6 = $1 - 1 | 0;
 $2 = $2 - (($1 | 0) == ($2 | 0)) | 0;
 while (1) {
  $5 = $2 - 1 | 0;
  $1 = $5;
  label$2: {
   if (($2 | 0) > 0) {
    while (1) {
     if (($1 | 0) >= ($6 | 0)) {
      break label$2;
     }
     $2 = ($1 << 2) + $0 | 0;
     $1 = $1 + 1 | 0;
     $4 = ($1 << 2) + $0 | 0;
     if ((FUNCTION_TABLE[$3 | 0](HEAP32[$2 >> 2], HEAP32[$4 >> 2]) | 0) < 0) {
      break label$2;
     }
     $7 = HEAP32[$4 >> 2];
     HEAP32[$4 >> 2] = HEAP32[$2 >> 2];
     HEAP32[$2 >> 2] = $7;
     continue;
    }
   }
   return;
  }
  $2 = $5;
  continue;
 }
}

function jsonEachComputePath($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (!$2) {
   jsonAppendChar($1, 36);
   break label$1;
  }
  $3 = HEAP32[HEAP32[$0 + 48 >> 2] + ($2 << 2) >> 2];
  jsonEachComputePath($0, $1, $3);
  $0 = HEAP32[$0 + 40 >> 2];
  $3 = $0 + Math_imul($3, 12) | 0;
  if (HEAPU8[$3 | 0] == 6) {
   HEAP32[$4 >> 2] = HEAP32[$3 + 8 >> 2];
   jsonPrintf(30, $1, 17881, $4);
   break label$1;
  }
  $2 = Math_imul($2, 12) + $0 | 0;
  jsonAppendObjectPathElement($1, ($2 + Math_imul(HEAPU8[$2 + 1 | 0] >>> 6 & 1, 12) | 0) - 12 | 0);
 }
 __stack_pointer = $4 + 16 | 0;
}

function fts3SegmentIsMaxLevel($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $0 = fts3SqlStmt($0, 15, $6 + 12 | 0, 0);
 if (!$0) {
  $5 = $2;
  $4 = $1 + 1 | 0;
  $5 = $4 ? $5 : $5 + 1 | 0;
  $0 = HEAP32[$6 + 12 >> 2];
  sqlite3_bind_int64($0, 1, $4, $5);
  $4 = $2;
  $5 = $1 & -1024;
  $1 = $5 + 1024 | 0;
  $4 = $1 >>> 0 < 1024 ? $4 + 1 | 0 : $4;
  sqlite3_bind_int64($0, 2, $1, $4);
  HEAP32[$3 >> 2] = 0;
  if ((sqlite3_step($0) | 0) == 100) {
   HEAP32[$3 >> 2] = (sqlite3_column_type($0, 0) | 0) == 5;
  }
  $0 = sqlite3_reset($0);
 }
 __stack_pointer = $6 + 16 | 0;
 return $0;
}

function sqlite3SrcListAssignCursors($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = $1 + 8 | 0;
  $4 = HEAP32[$1 >> 2];
  while (1) {
   if (($4 | 0) <= ($5 | 0)) {
    break label$1;
   }
   label$3: {
    if (HEAP32[$2 + 40 >> 2] >= 0) {
     break label$3;
    }
    $3 = HEAP32[$0 + 40 >> 2];
    HEAP32[$0 + 40 >> 2] = $3 + 1;
    HEAP32[$2 + 40 >> 2] = $3;
    $3 = HEAP32[$2 + 20 >> 2];
    if (!$3) {
     break label$3;
    }
    sqlite3SrcListAssignCursors($0, HEAP32[$3 + 32 >> 2]);
    $4 = HEAP32[$1 >> 2];
   }
   $2 = $2 - -64 | 0;
   $5 = $5 + 1 | 0;
   continue;
  }
 }
}

function fts3AllocateSegdirIdx($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $5 = fts3SqlStmt($0, 8, $6 + 12 | 0, 0);
 label$1: {
  if ($5) {
   break label$1;
  }
  $5 = HEAP32[$6 + 12 >> 2];
  sqlite3_bind_int64($5, 1, getAbsoluteLevel($0, $1, $2, $3), i64toi32_i32$HIGH_BITS);
  if ((sqlite3_step($5) | 0) == 100) {
   $7 = sqlite3_column_int($5, 0);
  }
  $5 = sqlite3_reset($5);
  if ($5) {
   break label$1;
  }
  $5 = 0;
  if (($7 | 0) >= 16) {
   $7 = 0;
   $5 = fts3SegmentMerge($0, $1, $2, $3);
  }
  HEAP32[$4 >> 2] = $7;
 }
 __stack_pointer = $6 + 16 | 0;
 return $5;
}

function squareFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  label$2: {
   switch (sqlite3_value_type(HEAP32[$2 >> 2]) - 1 | 0) {
   case 0:
    $2 = sqlite3_value_int64(HEAP32[$2 >> 2]);
    $1 = i64toi32_i32$HIGH_BITS;
    $2 = __wasm_i64_mul($2, $1, $2, $1);
    $1 = i64toi32_i32$HIGH_BITS;
    sqlite3_result_int64($0, $2, $1);
    return;

   case 4:
    sqlite3_result_null($0);
    return;

   default:
    break label$2;
   }
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  sqlite3_result_double($0, $3 * $3);
  return;
 }
 __assert_fail(23175, 17353, 514, 17242);
 abort();
}

function sqlite3InsertBuiltinFuncs($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = ($1 | 0) > 0 ? $1 : 0;
 $1 = 0;
 while (1) {
  if (($1 | 0) != ($5 | 0)) {
   $3 = Math_imul($1, 40) + $0 | 0;
   $2 = HEAP32[$3 + 32 >> 2];
   $4 = (sqlite3Strlen30($2) + HEAP8[$2 | 0] | 0) % 23 | 0;
   $2 = sqlite3FunctionSearch($4, $2);
   label$3: {
    if ($2) {
     HEAP32[$3 + 12 >> 2] = HEAP32[$2 + 12 >> 2];
     $2 = $2 + 12 | 0;
     break label$3;
    }
    HEAP32[$3 + 12 >> 2] = 0;
    $2 = ($4 << 2) + 70768 | 0;
    HEAP32[$3 + 36 >> 2] = HEAP32[$2 >> 2];
   }
   HEAP32[$2 >> 2] = $3;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
}

function sqlite3IndexedByLookup($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = HEAP32[$1 + 16 >> 2] + 8 | 0;
 $4 = HEAP32[$1 + 56 >> 2];
 label$1: {
  label$2: {
   while (1) {
    $2 = HEAP32[$2 >> 2];
    if ($2) {
     if (!sqlite3StrICmp(HEAP32[$2 >> 2], $4)) {
      break label$2;
     }
     $2 = $2 + 20 | 0;
     continue;
    }
    break;
   }
   HEAP32[$3 + 4 >> 2] = 0;
   HEAP32[$3 >> 2] = $4;
   sqlite3ErrorMsg($0, 7046, $3);
   HEAP8[$0 + 17 | 0] = 1;
   $2 = 1;
   break label$1;
  }
  HEAP32[$1 + 60 >> 2] = $2;
  $2 = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3DeleteColumnNames($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $2 = HEAP32[$1 + 4 >> 2];
  if (!$2) {
   break label$1;
  }
  while (1) {
   if (($3 | 0) < HEAP16[$1 + 34 >> 1]) {
    sqlite3DbFree($0, HEAP32[$2 >> 2]);
    $2 = $2 + 12 | 0;
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFree($0, HEAP32[$1 + 4 >> 2]);
  if (!HEAPU8[$1 + 43 | 0]) {
   sqlite3ExprListDelete($0, HEAP32[$1 + 52 >> 2]);
  }
  if (HEAP32[$0 + 528 >> 2] ? $0 : 0) {
   break label$1;
  }
  HEAP16[$1 + 34 >> 1] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  if (HEAPU8[$1 + 43 | 0]) {
   break label$1;
  }
  HEAP32[$1 + 52 >> 2] = 0;
 }
}

function sqlite3WhereGetMask($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = 1;
 if (HEAP32[$0 + 8 >> 2] != ($1 | 0)) {
  $2 = HEAP32[$0 + 4 >> 2];
  $3 = ($2 | 0) > 1 ? $2 : 1;
  $2 = 1;
  while (1) {
   if (($2 | 0) == ($3 | 0)) {
    i64toi32_i32$HIGH_BITS = 0;
    return 0;
   }
   if (HEAP32[(($2 << 2) + $0 | 0) + 8 >> 2] == ($1 | 0)) {
    $1 = $2 & 31;
    if (($2 & 63) >>> 0 >= 32) {
     $0 = 1 << $1;
     $1 = 0;
    } else {
     $0 = (1 << $1) - 1 & 1 >>> 32 - $1;
     $1 = 1 << $1;
    }
   } else {
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  $3 = $1;
  $2 = $0;
 }
 $0 = $2;
 i64toi32_i32$HIGH_BITS = $0;
 return $3;
}

function sqlite3IdListDup($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = sqlite3DbMallocRawNN($0, (HEAP32[$1 >> 2] << 3) + 8 | 0, 0);
  if (!$2) {
   break label$1;
  }
  HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
  HEAP8[$2 + 4 | 0] = HEAPU8[$1 + 4 | 0];
  while (1) {
   if (HEAP32[$1 >> 2] <= ($3 | 0)) {
    $0 = $2;
   } else {
    $4 = $3 << 3;
    $5 = $4 + $2 | 0;
    $4 = $1 + $4 | 0;
    HEAP32[$5 + 8 >> 2] = sqlite3DbStrDup($0, HEAP32[$4 + 8 >> 2]);
    HEAP32[$5 + 12 >> 2] = HEAP32[$4 + 12 >> 2];
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  $3 = $0;
 }
 return $3;
}

function sqlite3BlobCompare($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$1 + 12 >> 2];
 $3 = HEAP32[$0 + 12 >> 2];
 $4 = HEAPU16[$0 + 16 >> 1];
 $5 = HEAPU16[$1 + 16 >> 1];
 if (($4 | $5) & 1024) {
  $4 = $4 & 1024;
  if ($5 & $4) {
   return HEAP32[$0 >> 2] - HEAP32[$1 >> 2] | 0;
  }
  if ($4) {
   if (!isAllZero(HEAP32[$1 + 8 >> 2], $2)) {
    return -1;
   }
   return HEAP32[$0 >> 2] - $2 | 0;
  }
  if (!isAllZero(HEAP32[$0 + 8 >> 2], $3)) {
   return 1;
  }
  return $3 - HEAP32[$1 >> 2] | 0;
 }
 $0 = memcmp(HEAP32[$0 + 8 >> 2], HEAP32[$1 + 8 >> 2], ($2 | 0) > ($3 | 0) ? $3 : $2);
 return $0 ? $0 : $3 - $2 | 0;
}

function fts3InsertTerms($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = 2;
 while (1) {
  label$2: {
   if ((HEAP32[$0 + 24 >> 2] + 2 | 0) <= ($5 | 0)) {
    $4 = 0;
    break label$2;
   }
   $4 = $5 - 2 | 0;
   if (!HEAPU8[$4 + HEAP32[$0 + 32 >> 2] | 0]) {
    $6 = ($5 << 2) + $2 | 0;
    $4 = fts3PendingTermsAdd($0, $1, sqlite3_value_text(HEAP32[$6 >> 2]), $4, ($4 << 2) + $3 | 0);
    if ($4) {
     break label$2;
    }
    $4 = sqlite3_value_bytes(HEAP32[$6 >> 2]);
    $6 = (HEAP32[$0 + 24 >> 2] << 2) + $3 | 0;
    HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + $4;
   }
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
 return $4;
}

function exprCompareVariable($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 sqlite3ValueFromExpr(HEAP32[$0 >> 2], $2, 1, 65, $3 + 12 | 0);
 $2 = HEAP32[$3 + 12 >> 2];
 if ($2) {
  $4 = HEAP16[$1 + 32 >> 1];
  sqlite3VdbeSetVarmask(HEAP32[$0 + 8 >> 2], $4);
  $0 = sqlite3VdbeGetBoundValue(HEAP32[$0 + 228 >> 2], $4);
  if ($0) {
   if ((sqlite3_value_type($0) | 0) == 3) {
    sqlite3_value_text($0);
   }
   $4 = !sqlite3MemCompare($0, $2, 0);
  } else {
   $4 = 0;
  }
  sqlite3ValueFree($2);
  sqlite3ValueFree($0);
 }
 __stack_pointer = $3 + 16 | 0;
 return $4;
}

function sqlite3IsShadowTableOf($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (HEAPU8[$1 + 43 | 0] != 1) {
   break label$1;
  }
  $3 = HEAP32[$1 >> 2];
  $4 = sqlite3Strlen30($3);
  if (sqlite3_strnicmp($2, $3, $4)) {
   break label$1;
  }
  $2 = $2 + $4 | 0;
  if (HEAPU8[$2 | 0] != 95) {
   break label$1;
  }
  $1 = sqlite3HashFind($0 + 384 | 0, HEAP32[HEAP32[$1 + 48 >> 2] >> 2]);
  if (!$1) {
   break label$1;
  }
  $1 = HEAP32[$1 >> 2];
  if (HEAP32[$1 >> 2] < 3) {
   break label$1;
  }
  $1 = HEAP32[$1 + 92 >> 2];
  if (!$1) {
   break label$1;
  }
  $5 = FUNCTION_TABLE[$1 | 0]($2 + 1 | 0) | 0;
 }
 return $5;
}

function jsonLookup($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  if (HEAPU8[$1 | 0] == 36) {
   $5 = jsonLookupStep($0, 0, $1 + 1 | 0, $2, $4 + 12 | 0);
   $1 = HEAP32[$4 + 12 >> 2];
   if (!$1) {
    break label$1;
   }
  }
  HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] + 1;
  $1 = jsonPathSyntaxError($1);
  label$3: {
   if ($1) {
    sqlite3_result_error($3, $1, -1);
    sqlite3_free($1);
    break label$3;
   }
   sqlite3_result_error_nomem($3);
  }
  $5 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function insertElement($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  label$2: {
   if (!$1) {
    break label$2;
   }
   $4 = HEAP32[$1 >> 2];
   $3 = $4 ? HEAP32[$1 + 4 >> 2] : 0;
   HEAP32[$1 + 4 >> 2] = $2;
   HEAP32[$1 >> 2] = $4 + 1;
   if (!$3) {
    break label$2;
   }
   HEAP32[$2 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   HEAP32[($1 ? $1 : $0 + 8 | 0) >> 2] = $2;
   $1 = $3 + 4 | 0;
   break label$1;
  }
  $1 = HEAP32[$0 + 8 >> 2];
  HEAP32[$2 >> 2] = $1;
  if ($1) {
   HEAP32[$1 + 4 >> 2] = $2;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  $1 = $0 + 8 | 0;
 }
 HEAP32[$1 >> 2] = $2;
}

function getenv($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __strchrnul($0, 61);
 if (($1 | 0) == ($0 | 0)) {
  return 0;
 }
 $3 = $1 - $0 | 0;
 label$2: {
  if (HEAPU8[$3 + $0 | 0]) {
   break label$2;
  }
  $2 = HEAP32[17762];
  if (!$2) {
   break label$2;
  }
  $1 = HEAP32[$2 >> 2];
  if (!$1) {
   break label$2;
  }
  while (1) {
   label$4: {
    if (!strncmp($0, $1, $3)) {
     $1 = $1 + $3 | 0;
     if (HEAPU8[$1 | 0] == 61) {
      break label$4;
     }
    }
    $1 = HEAP32[$2 + 4 >> 2];
    $2 = $2 + 4 | 0;
    if ($1) {
     continue;
    }
    break label$2;
   }
   break;
  }
  $4 = $1 + 1 | 0;
 }
 return $4;
}

function closeAllCursors($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 212 >> 2];
 if ($1) {
  while (1) {
   $2 = $1;
   $1 = HEAP32[$1 + 4 >> 2];
   if ($1) {
    continue;
   }
   break;
  }
  sqlite3VdbeFrameRestore($2);
  HEAP32[$0 + 220 >> 2] = 0;
  HEAP32[$0 + 212 >> 2] = 0;
 }
 closeCursorsInFrame($0);
 releaseMemArray(HEAP32[$0 + 88 >> 2], HEAP32[$0 + 20 >> 2]);
 while (1) {
  $1 = HEAP32[$0 + 216 >> 2];
  if ($1) {
   HEAP32[$0 + 216 >> 2] = HEAP32[$1 + 4 >> 2];
   sqlite3VdbeFrameDelete($1);
   continue;
  }
  break;
 }
 if (HEAP32[$0 + 232 >> 2]) {
  sqlite3VdbeDeleteAuxData(HEAP32[$0 >> 2], $0 + 232 | 0, -1, 0);
 }
}

function sqlite3ClearStatTables($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = __stack_pointer + -64 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + ($1 << 4) >> 2];
 $1 = 1;
 while (1) {
  if (($1 | 0) != 5) {
   HEAP32[$4 + 16 >> 2] = $1;
   $6 = sqlite3_snprintf(24, $4 + 32 | 0, 15893, $4 + 16 | 0);
   if (sqlite3FindTable(HEAP32[$0 >> 2], $6, $5)) {
    HEAP32[$4 + 12 >> 2] = $3;
    HEAP32[$4 + 8 >> 2] = $2;
    HEAP32[$4 + 4 >> 2] = $6;
    HEAP32[$4 >> 2] = $5;
    sqlite3NestedParse($0, 19029, $4);
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $4 - -64 | 0;
}

function m_eq_1($0) {
 var $1 = 0, $2 = 0;
 while (1) {
  $1 = $0;
  $0 = $0 + 1 | 0;
  if (isVowel($1)) {
   continue;
  }
  break;
 }
 label$2: {
  if (!HEAPU8[$1 | 0]) {
   break label$2;
  }
  while (1) {
   $0 = $1;
   $1 = $0 + 1 | 0;
   if (isConsonant($0)) {
    continue;
   }
   break;
  }
  if (!HEAPU8[$0 | 0]) {
   break label$2;
  }
  while (1) {
   $1 = $0;
   $0 = $0 + 1 | 0;
   if (isVowel($1)) {
    continue;
   }
   break;
  }
  if (!HEAPU8[$1 | 0]) {
   return 1;
  }
  while (1) {
   $0 = $1;
   $1 = $0 + 1 | 0;
   if (isConsonant($0)) {
    continue;
   }
   break;
  }
  $2 = !HEAPU8[$0 | 0];
 }
 return $2;
}

function renameColumnExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 24 >> 2];
 $3 = HEAPU8[$1 | 0];
 label$1: {
  if (($3 | 0) != 167) {
   if (($3 | 0) != 77 | HEAP32[$2 + 8 >> 2] != HEAP16[$1 + 32 >> 1]) {
    break label$1;
   }
   $0 = HEAP32[$0 >> 2];
   if (HEAP32[$0 + 120 >> 2] != HEAP32[$2 + 12 >> 2]) {
    break label$1;
   }
   renameTokenFind($0, $2, $1);
   break label$1;
  }
  if (HEAPU8[$1 + 7 | 0] & 3 | HEAP32[$2 + 8 >> 2] != HEAP16[$1 + 32 >> 1] | HEAP32[$2 + 12 >> 2] != HEAP32[$1 + 44 >> 2]) {
   break label$1;
  }
  renameTokenFind(HEAP32[$0 >> 2], $2, $1);
 }
 return 0;
}

function minMaxQuery($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$1 + 20 >> 2];
 label$1: {
  if (!$3 | HEAP32[$3 >> 2] != 1 | (HEAP8[$1 + 7 | 0] & 1 | HEAP8[$0 + 82 | 0] & 1)) {
   break label$1;
  }
  $1 = HEAP32[$1 + 8 >> 2];
  label$2: {
   if (!sqlite3StrICmp($1, 10747)) {
    $1 = 1;
    $4 = ((sqlite3ExprCanBeNull(HEAP32[$3 + 8 >> 2]) | 0) != 0) << 1;
    break label$2;
   }
   if (sqlite3StrICmp($1, 1563)) {
    break label$1;
   }
   $1 = 2;
   $4 = 1;
  }
  $5 = $1;
  $1 = sqlite3ExprListDup($0, $3, 0);
  HEAP32[$2 >> 2] = $1;
  if (!$1) {
   break label$1;
  }
  HEAP8[$1 + 16 | 0] = $4;
 }
 return $5;
}

function termIsEquivalence($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (HEAPU8[HEAP32[$0 >> 2] + 80 | 0] & 128) {
   break label$1;
  }
  $2 = HEAPU8[$1 | 0];
  if (($2 | 0) != 53 & ($2 | 0) != 45 | HEAP8[$1 + 4 | 0] & 1) {
   break label$1;
  }
  $2 = sqlite3ExprAffinity(HEAP32[$1 + 12 >> 2]);
  $3 = sqlite3ExprAffinity(HEAP32[$1 + 16 >> 2]);
  if (($2 | 0) != ($3 | 0) & (($2 | 0) < 67 | ($3 | 0) < 67)) {
   break label$1;
  }
  $4 = 1;
  if (sqlite3IsBinary(sqlite3ExprCompareCollSeq($0, $1))) {
   break label$1;
  }
  $4 = sqlite3ExprCollSeqMatch($0, HEAP32[$1 + 12 >> 2], HEAP32[$1 + 16 >> 2]);
 }
 return $4;
}

function callFinaliser($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = HEAP32[$0 + 404 >> 2];
 if ($2) {
  HEAP32[$0 + 404 >> 2] = 0;
  while (1) {
   if (($3 | 0) < HEAP32[$0 + 380 >> 2]) {
    $4 = HEAP32[($3 << 2) + $2 >> 2];
    $5 = HEAP32[$4 + 8 >> 2];
    label$4: {
     if (!$5) {
      break label$4;
     }
     $6 = HEAP32[HEAP32[$5 >> 2] + $1 >> 2];
     if (!$6) {
      break label$4;
     }
     FUNCTION_TABLE[$6 | 0]($5) | 0;
    }
    HEAP32[$4 + 20 >> 2] = 0;
    sqlite3VtabUnlock($4);
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFree($0, $2);
  HEAP32[$0 + 380 >> 2] = 0;
 }
}

function sqlite3VdbeSorterReset($0, $1) {
 var $2 = 0, $3 = 0;
 vdbeMergeEngineFree(HEAP32[$1 + 20 >> 2]);
 HEAP32[$1 + 20 >> 2] = 0;
 while (1) {
  if ($2 >>> 0 < HEAPU8[$1 + 59 | 0]) {
   $3 = Math_imul($2, 72) + $1 | 0;
   vdbeSortSubtaskCleanup($0, $3 - -64 | 0);
   HEAP32[$3 + 72 >> 2] = $1;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 if (!HEAP32[$1 + 40 >> 2]) {
  vdbeSorterRecordFree(0, HEAP32[$1 + 36 >> 2]);
 }
 HEAP8[$1 + 56 | 0] = 0;
 HEAP32[$1 + 36 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 44 >> 2] = 0;
 HEAP32[$1 + 48 >> 2] = 0;
 sqlite3DbFree($0, HEAP32[$1 + 32 >> 2]);
 HEAP32[$1 + 32 >> 2] = 0;
}

function parseDateOrTime($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!parseYyyyMmDd($1, $2)) {
   break label$1;
  }
  if (!parseHhMmSs($1, $2)) {
   break label$1;
  }
  label$2: {
   if (sqlite3StrICmp($1, 1648)) {
    break label$2;
   }
   if (!sqlite3NotPureFunc($0)) {
    break label$2;
   }
   $4 = setDateTimeToCurrent($0, $2);
   break label$1;
  }
  $4 = 1;
  if ((sqlite3AtoF($1, $3 + 8 | 0, sqlite3Strlen30($1), 1) | 0) <= 0) {
   break label$1;
  }
  setRawDateNumber($2, HEAPF64[$3 + 8 >> 3]);
  $4 = 0;
 }
 __stack_pointer = $3 + 16 | 0;
 return $4;
}

function memdbFetch($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 $5 = ($3 >> 31) + $2 | 0;
 $6 = $1 + $3 | 0;
 $5 = $1 >>> 0 > $6 >>> 0 ? $5 + 1 | 0 : $5;
 $2 = $5;
 $3 = HEAP32[$0 + 4 >> 2];
 $5 = HEAP32[$3 >> 2];
 $0 = $5 >>> 0 < $6 >>> 0;
 $5 = HEAP32[$3 + 4 >> 2];
 $6 = 0;
 label$1: {
  if ($0 & ($5 | 0) <= ($2 | 0) | ($5 | 0) < ($2 | 0)) {
   break label$1;
  }
  $6 = 0;
  if (HEAPU8[$3 + 36 | 0] & 2) {
   break label$1;
  }
  HEAP32[$3 + 32 >> 2] = HEAP32[$3 + 32 >> 2] + 1;
  $6 = $1 + HEAP32[$3 + 24 >> 2] | 0;
 }
 HEAP32[$4 >> 2] = $6;
 return 0;
}

function fts3QuoteId($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = (strlen($0) << 1) + 3 | 0;
 $2 = sqlite3_malloc64($1, $1 >> 31);
 if ($2) {
  HEAP8[$2 | 0] = 34;
  $1 = $2;
  while (1) {
   label$3: {
    $5 = $0 + $4 | 0;
    $3 = HEAPU8[$5 | 0];
    label$4: {
     if (($3 | 0) != 34) {
      if (!$3) {
       break label$3;
      }
      $1 = $1 + 1 | 0;
      break label$4;
     }
     HEAP8[$1 + 1 | 0] = 34;
     $3 = HEAPU8[$5 | 0];
     $1 = $1 + 2 | 0;
    }
    HEAP8[$1 | 0] = $3;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$1 + 1 | 0] = 34;
  HEAP8[$1 + 2 | 0] = 0;
 }
 return $2;
}

function findCollSeqEntry($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = $0 + 428 | 0;
 $3 = sqlite3HashFind($4, $1);
 label$1: {
  if ($3 | !$2) {
   break label$1;
  }
  $5 = sqlite3Strlen30($1);
  $3 = sqlite3DbMallocZero($0, $5 + 61 | 0, 0);
  if ($3) {
   HEAP8[$3 + 4 | 0] = 1;
   HEAP8[$3 + 44 | 0] = 3;
   $2 = $3 + 60 | 0;
   HEAP32[$3 + 40 >> 2] = $2;
   HEAP8[$3 + 24 | 0] = 2;
   HEAP32[$3 + 20 >> 2] = $2;
   HEAP32[$3 >> 2] = $2;
   $1 = sqlite3HashInsert($4, __memcpy($2, $1, $5 + 1 | 0), $3);
   if (!$1) {
    break label$1;
   }
   sqlite3OomFault($0);
   sqlite3DbFree($0, $1);
  }
  $3 = 0;
 }
 return $3;
}

function tableAndColumnIndex($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0, $9 = 0;
 while (1) {
  label$2: {
   label$3: {
    if (($1 | 0) > ($2 | 0)) {
     break label$3;
    }
    $8 = HEAP32[(($1 << 6) + $0 | 0) + 24 >> 2];
    $7 = sqlite3ColumnIndex($8, $3);
    if (($7 | 0) < 0 | (HEAPU8[(HEAP32[$8 + 4 >> 2] + Math_imul($7, 12) | 0) + 10 | 0] & 2 ? $6 : 0)) {
     break label$2;
    }
    $9 = 1;
    if (!$4) {
     break label$3;
    }
    sqlite3SrcItemColumnUsed((($1 << 6) + $0 | 0) + 8 | 0, $7);
    HEAP32[$4 >> 2] = $1;
    HEAP32[$5 >> 2] = $7;
   }
   return $9;
  }
  $1 = $1 + 1 | 0;
  continue;
 }
}

function node_insert($0, $1, $2) {
 var $3 = 0;
 while (1) {
  $3 = HEAP32[$0 >> 2];
  if (!$3) {
   $3 = xcalloc(1, 24, $0);
   HEAP32[$3 + 16 >> 2] = 1;
   HEAP32[$3 + 20 >> 2] = 0;
   HEAP32[$3 + 8 >> 2] = $2;
   HEAP32[$0 >> 2] = $3;
   return;
  }
  $3 = FUNCTION_TABLE[$1 | 0](HEAP32[$3 + 8 >> 2], $2) | 0;
  if ($3) {
   $0 = HEAP32[$0 >> 2];
   $0 = ($3 | 0) > 0 ? $0 : $0 + 4 | 0;
   continue;
  } else {
   $0 = HEAP32[$0 >> 2];
   $1 = HEAP32[$0 + 20 >> 2];
   $3 = HEAP32[$0 + 16 >> 2] + 1 | 0;
   $1 = $3 ? $1 : $1 + 1 | 0;
   HEAP32[$0 + 16 >> 2] = $3;
   HEAP32[$0 + 20 >> 2] = $1;
   xfree($2);
  }
  break;
 }
}

function sqlite3HasExplicitNulls($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 >> 2];
  $4 = ($2 | 0) > 0 ? $2 : 0;
  $2 = 0;
  while (1) {
   if (($2 | 0) == ($4 | 0)) {
    break label$1;
   }
   if (!(HEAPU8[(($2 << 4) + $1 | 0) + 17 | 0] & 32)) {
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  $2 = HEAPU8[(($2 << 4) + $1 | 0) + 16 | 0];
  HEAP32[$3 >> 2] = $2 ? ($2 | 0) == 3 ? 18250 : 18256 : 18250;
  sqlite3ErrorMsg($0, 6870, $3);
  $5 = 1;
 }
 __stack_pointer = $3 + 16 | 0;
 return $5;
}

function fts3ExprParseUnbalanced($0, $1, $2, $3, $4, $5, $6, $7) {
 var $8 = 0, $9 = 0;
 $8 = __stack_pointer - 48 | 0;
 __stack_pointer = $8;
 HEAP32[$8 + 40 >> 2] = 0;
 HEAP32[$8 + 32 >> 2] = 0;
 HEAP32[$8 + 36 >> 2] = 0;
 HEAP32[$8 + 28 >> 2] = $5;
 HEAP32[$8 + 24 >> 2] = $4;
 HEAP32[$8 + 16 >> 2] = $2;
 HEAP32[$8 + 12 >> 2] = $1;
 HEAP32[$8 + 8 >> 2] = $0;
 HEAP32[$8 + 20 >> 2] = $3;
 label$1: {
  if (!$6) {
   HEAP32[$7 >> 2] = 0;
   break label$1;
  }
  $6 = fts3ExprParse($8 + 8 | 0, $6, strlen($6), $7, $8 + 44 | 0);
  $9 = $6 ? $6 : HEAP32[$8 + 40 >> 2] ? 1 : $6;
 }
 __stack_pointer = $8 + 48 | 0;
 return $9;
}

function ntileStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $1 = sqlite3_aggregate_context($0, 24);
 if ($1) {
  $3 = HEAP32[$1 + 4 >> 2];
  label$2: {
   if ($3 | HEAP32[$1 >> 2]) {
    break label$2;
   }
   $2 = sqlite3_value_int64(HEAP32[$2 >> 2]);
   HEAP32[$1 + 8 >> 2] = $2;
   $3 = i64toi32_i32$HIGH_BITS;
   HEAP32[$1 + 12 >> 2] = $3;
   if (!!$2 & ($3 | 0) >= 0 | ($3 | 0) > 0) {
    break label$2;
   }
   sqlite3_result_error($0, 9016, -1);
  }
  $3 = HEAP32[$1 + 4 >> 2];
  $0 = HEAP32[$1 >> 2] + 1 | 0;
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $0 ? $3 : $3 + 1 | 0;
 }
}

function sqlite3KeyInfoFromExprList($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $4 = HEAP32[$1 >> 2];
  $3 = sqlite3KeyInfoAlloc(HEAP32[$0 >> 2], $4 - $2 | 0, $3 + 1 | 0);
  if (!$3) {
   break label$1;
  }
  $6 = ($2 | 0) < ($4 | 0) ? $4 : $2;
  $4 = (($2 << 4) + $1 | 0) + 8 | 0;
  $1 = $2;
  while (1) {
   if (($1 | 0) == ($6 | 0)) {
    break label$1;
   }
   $5 = $1 - $2 | 0;
   HEAP32[(($5 << 2) + $3 | 0) + 20 >> 2] = sqlite3ExprNNCollSeq($0, HEAP32[$4 >> 2]);
   HEAP8[HEAP32[$3 + 16 >> 2] + $5 | 0] = HEAPU8[$4 + 8 | 0];
   $4 = $4 + 16 | 0;
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 return $3;
}

function exprCodeVector($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = sqlite3ExprVectorSize($1);
 if (($3 | 0) == 1) {
  return sqlite3ExprCodeTemp($0, $1, $2);
 }
 HEAP32[$2 >> 2] = 0;
 label$2: {
  if (HEAPU8[$1 | 0] == 138) {
   $2 = sqlite3CodeSubselect($0, $1);
   break label$2;
  }
  $2 = HEAP32[$0 + 44 >> 2];
  HEAP32[$0 + 44 >> 2] = $3 + $2;
  $3 = ($3 | 0) > 0 ? $3 : 0;
  $2 = $2 + 1 | 0;
  while (1) {
   if (($3 | 0) == ($4 | 0)) {
    break label$2;
   }
   sqlite3ExprCodeFactorable($0, HEAP32[(HEAP32[$1 + 20 >> 2] + ($4 << 4) | 0) + 8 >> 2], $2 + $4 | 0);
   $4 = $4 + 1 | 0;
   continue;
  }
 }
 return $2;
}

function sqlite3FtsUnicodeIsalnum($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if ($0 >>> 0 <= 127) {
  return !(HEAP32[($0 >>> 3 & 536870908) + 53168 >> 2] >>> $0 & 1);
 }
 $1 = 1;
 if ($0 >>> 0 <= 4194303) {
  $6 = $0 << 10 | 1023;
  $1 = 405;
  while (1) {
   if (($1 | 0) >= ($3 | 0)) {
    $2 = ($1 + $3 | 0) / 2 | 0;
    $4 = HEAPU32[($2 << 2) + 51536 >> 2] > $6 >>> 0;
    $3 = $4 ? $3 : $2 + 1 | 0;
    $1 = $4 ? $2 - 1 | 0 : $1;
    $5 = $4 ? $5 : $2;
    continue;
   }
   break;
  }
  $1 = HEAP32[($5 << 2) + 51536 >> 2];
  $1 = ($1 >>> 10 | 0) + ($1 & 1023) >>> 0 <= $0 >>> 0;
 }
 return $1;
}

function exprTableRegister($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = HEAP32[$0 >> 2];
 $4 = sqlite3Expr($6, 176, 0);
 if ($4) {
  if (!(HEAPU16[$1 + 32 >> 1] == ($3 & 65535) | ($3 | 0) < 0)) {
   $5 = HEAP32[$1 + 4 >> 2];
   HEAP32[$4 + 28 >> 2] = (sqlite3TableColumnToStorage($1, $3) + $2 | 0) + 1;
   $3 = Math_imul($3, 12) + $5 | 0;
   HEAP8[$4 + 1 | 0] = HEAPU8[$3 + 5 | 0];
   $3 = sqlite3ColumnColl($3);
   if (!$3) {
    $3 = HEAP32[HEAP32[$6 + 8 >> 2] >> 2];
   }
   return sqlite3ExprAddCollateString($0, $4, $3);
  }
  HEAP8[$4 + 1 | 0] = 68;
  HEAP32[$4 + 28 >> 2] = $2;
  $5 = $4;
 }
 return $5;
}

function whereApplyPartialIndexConstraints($0, $1, $2) {
 var $3 = 0, $4 = 0;
 while (1) {
  if (HEAPU8[$0 | 0] == 44) {
   whereApplyPartialIndexConstraints(HEAP32[$0 + 12 >> 2], $1, $2);
   $0 = HEAP32[$0 + 16 >> 2];
   continue;
  }
  break;
 }
 $3 = HEAP32[$2 + 24 >> 2];
 while (1) {
  if (($4 | 0) < HEAP32[$2 + 12 >> 2]) {
   label$5: {
    if (HEAPU8[$3 + 10 | 0] & 4) {
     break label$5;
    }
    if (sqlite3ExprCompare(0, HEAP32[$3 >> 2], $0, $1)) {
     break label$5;
    }
    HEAP16[$3 + 10 >> 1] = HEAPU16[$3 + 10 >> 1] | 4;
   }
   $3 = $3 + 48 | 0;
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
}

function sqlite3ResetAllSchemasOfConnection($0) {
 var $1 = 0, $2 = 0;
 sqlite3BtreeEnterAll($0);
 while (1) {
  if (($2 | 0) < HEAP32[$0 + 20 >> 2]) {
   $1 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($2 << 4) | 0) + 12 >> 2];
   label$3: {
    if (!$1) {
     break label$3;
    }
    if (!HEAP32[$0 + 56 >> 2]) {
     sqlite3SchemaClear($1);
     break label$3;
    }
    HEAP16[$1 + 78 >> 1] = HEAPU16[$1 + 78 >> 1] | 8;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] & -18;
 sqlite3VtabUnlockList($0);
 if (!HEAP32[$0 + 56 >> 2]) {
  sqlite3CollapseDatabaseArray($0);
 }
}

function lowerFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = sqlite3_value_text(HEAP32[$2 >> 2]);
 $1 = sqlite3_value_bytes(HEAP32[$2 >> 2]);
 label$1: {
  if (!$4) {
   break label$1;
  }
  $2 = $1 >> 31;
  $3 = $1 + 1 | 0;
  $2 = $3 ? $2 : $2 + 1 | 0;
  $3 = contextMalloc($0, $3, $2);
  if (!$3) {
   break label$1;
  }
  $2 = 0;
  $5 = ($1 | 0) > 0 ? $1 : 0;
  while (1) {
   if (($2 | 0) != ($5 | 0)) {
    HEAP8[$2 + $3 | 0] = HEAPU8[HEAPU8[$2 + $4 | 0] + 29904 | 0];
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_result_text($0, $3, $1, 3);
 }
}

function jsonLookupAppend($0, $1, $2, $3) {
 var $4 = 0;
 HEAP32[$2 >> 2] = 1;
 $4 = HEAPU8[$1 | 0];
 label$1: {
  if (($4 | 0) == 46) {
   $4 = 7;
  } else {
   if (!$4) {
    jsonParseAddNode($0, 0, 0, 0);
    $4 = 0;
    if (HEAPU8[$0 + 20 | 0]) {
     break label$1;
    }
    return (HEAP32[$0 + 8 >> 2] + Math_imul(HEAP32[$0 >> 2], 12) | 0) - 12 | 0;
   }
   $4 = 0;
   if (strncmp($1, 17889, 3)) {
    break label$1;
   }
   $4 = 6;
  }
  jsonParseAddNode($0, $4, 0, 0);
  $4 = 0;
  if (HEAPU8[$0 + 20 | 0]) {
   break label$1;
  }
  $4 = jsonLookupStep($0, HEAP32[$0 >> 2] - 1 | 0, $1, $2, $3);
 }
 return $4;
}

function sqlite3OomFault($0) {
 var $1 = 0;
 label$1: {
  if (HEAPU8[$0 + 87 | 0] | HEAPU8[$0 + 88 | 0]) {
   break label$1;
  }
  HEAP8[$0 + 87 | 0] = 1;
  if (HEAP32[$0 + 196 >> 2] > 0) {
   HEAP32[$0 + 296 >> 2] = 1;
  }
  HEAP16[$0 + 308 >> 1] = 0;
  HEAP32[$0 + 304 >> 2] = HEAP32[$0 + 304 >> 2] + 1;
  $1 = HEAP32[$0 + 264 >> 2];
  if (!$1) {
   break label$1;
  }
  sqlite3ErrorMsg($1, 1141, 0);
  $0 = HEAP32[$0 + 264 >> 2];
  while (1) {
   HEAP32[$0 + 12 >> 2] = 7;
   $0 = HEAP32[$0 + 184 >> 2];
   if (!$0) {
    break label$1;
   }
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   continue;
  }
 }
}

function sqlite3VdbeMemCopy($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if (HEAPU8[$0 + 17 | 0] & 144) {
  vdbeMemClearExternAndSetNull($0);
 }
 $2 = $0 + 16 | 0;
 $4 = HEAP32[$1 + 16 >> 2];
 HEAP32[$2 >> 2] = $4;
 $2 = HEAP32[$1 + 4 >> 2];
 $3 = HEAP32[$1 >> 2];
 HEAP32[$0 >> 2] = $3;
 HEAP32[$0 + 4 >> 2] = $2;
 $3 = HEAP32[$1 + 12 >> 2];
 $2 = HEAP32[$1 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = $2;
 HEAP32[$0 + 12 >> 2] = $3;
 $3 = $4 & -4097;
 HEAP16[$0 + 16 >> 1] = $3;
 $2 = 0;
 if (!(!($4 & 18) | HEAPU8[$1 + 17 | 0] & 32)) {
  HEAP16[$0 + 16 >> 1] = $3 | 16384;
  $2 = sqlite3VdbeMemMakeWriteable($0);
 }
 return $2;
}

function sqlite3BtreeRowCountEst($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = -1;
 $3 = -1;
 label$1: {
  if (HEAPU8[$0 | 0]) {
   break label$1;
  }
  $1 = HEAP32[$0 + 116 >> 2];
  if (!HEAPU8[$1 + 8 | 0]) {
   break label$1;
  }
  $5 = HEAP8[$0 + 68 | 0];
  $2 = HEAPU16[$1 + 24 >> 1];
  $3 = 0;
  $1 = 0;
  while (1) {
   $4 = $1 & 255;
   if (($4 | 0) >= ($5 | 0)) {
    break label$1;
   }
   $1 = $1 + 1 | 0;
   $2 = __wasm_i64_mul($2, $3, HEAPU16[HEAP32[(($4 << 2) + $0 | 0) + 120 >> 2] + 24 >> 1], 0);
   $3 = i64toi32_i32$HIGH_BITS;
   continue;
  }
 }
 i64toi32_i32$HIGH_BITS = $3;
 return $2;
}

function sqlite3GetVarint32($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP8[$0 + 1 | 0];
 $4 = $3 & 255;
 $5 = HEAPU8[$0 | 0];
 label$1: {
  if (($3 | 0) >= 0) {
   HEAP32[$1 >> 2] = $5 << 7 & 16256 | $4;
   $0 = 2;
   break label$1;
  }
  $3 = HEAP8[$0 + 2 | 0];
  if (($3 | 0) >= 0) {
   HEAP32[$1 >> 2] = ($3 & 255 | $5 << 14) & 2080895 | $4 << 7 & 16256;
   $0 = 3;
   break label$1;
  }
  $0 = sqlite3GetVarint($0, $2 + 8 | 0);
  HEAP32[$1 >> 2] = HEAP32[$2 + 12 >> 2] ? -1 : HEAP32[$2 + 8 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function pcache1Rekey($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP32[$0 + 52 >> 2];
 $2 = HEAP32[$0 + 56 >> 2] + (($2 >>> 0) % ($4 >>> 0) << 2) | 0;
 while (1) {
  $6 = $2;
  $5 = HEAP32[$2 >> 2];
  $2 = $5 + 16 | 0;
  if (($1 | 0) != ($5 | 0)) {
   continue;
  }
  break;
 }
 HEAP32[$6 >> 2] = HEAP32[$1 + 16 >> 2];
 HEAP32[$1 + 8 >> 2] = $3;
 $2 = HEAP32[$0 + 56 >> 2] + (($3 >>> 0) % ($4 >>> 0) << 2) | 0;
 HEAP32[$1 + 16 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$2 >> 2] = $1;
 if (HEAPU32[$0 + 36 >> 2] < $3 >>> 0) {
  HEAP32[$0 + 36 >> 2] = $3;
 }
}

function percent_rankValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $1 = sqlite3_aggregate_context($0, 24);
 if ($1) {
  $2 = HEAP32[$1 + 8 >> 2];
  $5 = $2;
  $3 = HEAP32[$1 + 12 >> 2];
  $6 = $3;
  HEAP32[$1 >> 2] = $2;
  HEAP32[$1 + 4 >> 2] = $3;
  $3 = HEAP32[$1 + 16 >> 2];
  $2 = HEAP32[$1 + 20 >> 2];
  $7 = $2;
  $1 = $3;
  if (($2 | 0) >= 0 & $1 >>> 0 >= 2 | ($2 | 0) > 0) {
   $2 = $5;
   $1 = $6;
   $4 = +($2 >>> 0) + +($1 | 0) * 4294967296;
   $1 = $7;
   $4 = $4 / (+($3 - 1 >>> 0) + +($1 - !$3 | 0) * 4294967296);
  }
  sqlite3_result_double($0, $4);
 }
}

function cosh($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $3 = wasm2js_scratch_load_i32(0) | 0;
 wasm2js_scratch_store_i32(0, $3 | 0);
 $1 = $1 & 2147483647;
 wasm2js_scratch_store_i32(1, $1 | 0);
 $0 = +wasm2js_scratch_load_f64();
 label$1: {
  if ($1 >>> 0 <= 1072049729) {
   $2 = 1;
   if ($1 >>> 0 < 1045430272) {
    break label$1;
   }
   $0 = expm1($0);
   $2 = $0 * $0;
   $0 = $0 + 1;
   return $2 / ($0 + $0) + 1;
  }
  if ($1 >>> 0 <= 1082535489) {
   $0 = exp($0);
   return ($0 + 1 / $0) * .5;
  }
  $2 = __expo2($0, 1);
 }
 return $2;
}

function codeExprOrVector($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  label$2: {
   if (!$1) {
    break label$2;
   }
   if (!sqlite3ExprIsVector($1)) {
    break label$2;
   }
   if (HEAPU8[$1 + 5 | 0] & 16) {
    sqlite3VdbeAddOp3(HEAP32[$0 + 8 >> 2], 80, sqlite3CodeSubselect($0, $1), $2, $3 - 1 | 0);
    return;
   }
   $3 = ($3 | 0) > 0 ? $3 : 0;
   $1 = HEAP32[$1 + 20 >> 2];
   while (1) {
    if (($3 | 0) == ($4 | 0)) {
     break label$1;
    }
    sqlite3ExprCode($0, HEAP32[(($4 << 4) + $1 | 0) + 8 >> 2], $2 + $4 | 0);
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  sqlite3ExprCode($0, $1, $2);
 }
}

function walkWindowList($0, $1, $2) {
 var $3 = 0;
 label$1: {
  while (1) {
   if (!$1) {
    return 0;
   }
   $3 = 2;
   if (sqlite3WalkExprList($0, HEAP32[$1 + 12 >> 2])) {
    break label$1;
   }
   if (sqlite3WalkExprList($0, HEAP32[$1 + 8 >> 2])) {
    break label$1;
   }
   if (sqlite3WalkExpr($0, HEAP32[$1 + 40 >> 2])) {
    break label$1;
   }
   if (sqlite3WalkExpr($0, HEAP32[$1 + 24 >> 2])) {
    break label$1;
   }
   $3 = sqlite3WalkExpr($0, HEAP32[$1 + 28 >> 2]);
   if (!($3 | $2)) {
    $1 = HEAP32[$1 + 36 >> 2];
    continue;
   }
   break;
  }
  $3 = (($3 | 0) != 0) << 1;
 }
 return $3;
}

function whereLoopClearUnion($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $2 = HEAP32[$1 + 40 >> 2];
  if (!($2 & 17408)) {
   break label$1;
  }
  label$2: {
   if (!(!($2 & 1024) | !(HEAP8[$1 + 28 | 0] & 1))) {
    $2 = $1 + 32 | 0;
    sqlite3_free(HEAP32[$2 >> 2]);
    HEAP8[$1 + 28 | 0] = HEAPU8[$1 + 28 | 0] & 254;
    break label$2;
   }
   if (!($2 & 16384)) {
    break label$1;
   }
   $3 = $1;
   $2 = $1 + 32 | 0;
   $1 = HEAP32[$2 >> 2];
   if (!$1) {
    break label$1;
   }
   sqlite3DbFree($0, HEAP32[$1 + 16 >> 2]);
   sqlite3DbFreeNN($0, HEAP32[$3 + 32 >> 2]);
  }
  HEAP32[$2 >> 2] = 0;
 }
}

function synthCollSeq($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = HEAP32[$1 >> 2];
 $4 = 1;
 label$1: {
  while (1) {
   if (($2 | 0) == 3) {
    break label$1;
   }
   $3 = $2 + 35828 | 0;
   $2 = $2 + 1 | 0;
   $3 = sqlite3FindCollSeq($0, HEAPU8[$3 | 0], $5, 0);
   if (!HEAP32[$3 + 12 >> 2]) {
    continue;
   }
   break;
  }
  $0 = HEAP32[$3 + 4 >> 2];
  $2 = HEAP32[$3 >> 2];
  HEAP32[$1 >> 2] = $2;
  HEAP32[$1 + 4 >> 2] = $0;
  $2 = HEAP32[$3 + 12 >> 2];
  $0 = HEAP32[$3 + 8 >> 2];
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 12 >> 2] = $2;
  $4 = 0;
  HEAP32[$1 + 16 >> 2] = 0;
 }
 return $4;
}

function sqlite3WalkSelectFrom($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$1 + 32 >> 2];
 label$1: {
  if (!$2) {
   break label$1;
  }
  $1 = $2 + 8 | 0;
  $2 = HEAP32[$2 >> 2];
  while (1) {
   if (($2 | 0) <= 0) {
    break label$1;
   }
   label$3: {
    $3 = HEAP32[$1 + 20 >> 2];
    if ($3) {
     if (sqlite3WalkSelect($0, $3)) {
      break label$3;
     }
    }
    if (HEAPU8[$1 + 37 | 0] & 4) {
     if (sqlite3WalkExprList($0, HEAP32[$1 + 56 >> 2])) {
      break label$3;
     }
    }
    $1 = $1 - -64 | 0;
    $2 = $2 - 1 | 0;
    continue;
   }
   break;
  }
  $4 = 2;
 }
 return $4;
}

function bindText($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $7 = vdbeUnbind($0, $1);
 label$1: {
  if (!$7) {
   $7 = 0;
   if (!$2) {
    break label$1;
   }
   $8 = (HEAP32[$0 + 100 >> 2] + Math_imul($1, 40) | 0) - 40 | 0;
   $1 = sqlite3VdbeMemSetStr($8, $2, $3, $4, $6, $5);
   if (!($1 | !$6)) {
    $1 = sqlite3VdbeChangeEncoding($8, HEAPU8[HEAP32[$0 >> 2] + 84 | 0]);
   }
   if (!$1) {
    break label$1;
   }
   sqlite3Error(HEAP32[$0 >> 2], $1);
   return sqlite3ApiExit(HEAP32[$0 >> 2], $1);
  }
  if ($5 + 1 >>> 0 < 2) {
   break label$1;
  }
  FUNCTION_TABLE[$5 | 0]($2);
 }
 return $7;
}

function sqlite3VdbeSorterNext($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $1 = HEAP32[$1 + 36 >> 2];
 label$1: {
  if (HEAPU8[$1 + 56 | 0]) {
   HEAP32[$2 + 12 >> 2] = 0;
   $1 = vdbeMergeEngineStep(HEAP32[$1 + 20 >> 2], $2 + 12 | 0);
   $1 = $1 ? $1 : HEAP32[$2 + 12 >> 2] ? 101 : $1;
   break label$1;
  }
  $3 = HEAP32[$1 + 36 >> 2];
  HEAP32[$1 + 36 >> 2] = HEAP32[$3 + 4 >> 2];
  HEAP32[$3 + 4 >> 2] = 0;
  if (!HEAP32[$1 + 40 >> 2]) {
   vdbeSorterRecordFree($0, $3);
  }
  $1 = HEAP32[$1 + 36 >> 2] ? 0 : 101;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function selectWindowRewriteEList($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0;
 $6 = __stack_pointer + -64 | 0;
 __stack_pointer = $6;
 HEAP32[$6 + 52 >> 2] = 0;
 HEAP32[$6 + 44 >> 2] = 0;
 HEAP32[$6 + 48 >> 2] = 0;
 HEAP32[$6 + 24 >> 2] = 0;
 $7 = HEAP32[$5 >> 2];
 HEAP32[$6 + 20 >> 2] = $4;
 HEAP32[$6 + 12 >> 2] = $2;
 HEAP32[$6 + 8 >> 2] = $1;
 HEAP32[$6 + 16 >> 2] = $7;
 HEAP32[$6 + 40 >> 2] = 77;
 HEAP32[$6 + 36 >> 2] = 78;
 HEAP32[$6 + 32 >> 2] = $0;
 HEAP32[$6 + 56 >> 2] = $6 + 8;
 sqlite3WalkExprList($6 + 32 | 0, $3);
 HEAP32[$5 >> 2] = HEAP32[$6 + 16 >> 2];
 __stack_pointer = $6 - -64 | 0;
}

function findElementWithHash($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 12 >> 2];
 label$1: {
  if ($3) {
   $4 = (strHash($1) >>> 0) % HEAPU32[$0 >> 2] | 0;
   $3 = ($4 << 3) + $3 | 0;
   $0 = $3 + 4 | 0;
   break label$1;
  }
  $3 = $0 + 4 | 0;
  $0 = $0 + 8 | 0;
 }
 $0 = HEAP32[$0 >> 2];
 $3 = HEAP32[$3 >> 2];
 if ($2) {
  HEAP32[$2 >> 2] = $4;
 }
 while (1) {
  label$5: {
   if (!$3) {
    $0 = 70992;
    break label$5;
   }
   if (!sqlite3StrICmp(HEAP32[$0 + 12 >> 2], $1)) {
    break label$5;
   }
   $3 = $3 - 1 | 0;
   $0 = HEAP32[$0 >> 2];
   continue;
  }
  break;
 }
 return $0;
}

function walLimitSize($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 sqlite3BeginBenignMalloc();
 $4 = sqlite3OsFileSize(HEAP32[$0 + 8 >> 2], $3 + 8 | 0);
 label$1: {
  if ($4) {
   break label$1;
  }
  $4 = 0;
  $5 = HEAP32[$3 + 12 >> 2];
  if (($5 | 0) <= ($2 | 0) & $1 >>> 0 >= HEAPU32[$3 + 8 >> 2] | ($2 | 0) > ($5 | 0)) {
   break label$1;
  }
  $4 = sqlite3OsTruncate(HEAP32[$0 + 8 >> 2], $1, $2);
 }
 sqlite3EndBenignMalloc();
 if ($4) {
  HEAP32[$3 >> 2] = HEAP32[$0 + 108 >> 2];
  sqlite3_log($4, 7495, $3);
 }
 __stack_pointer = $3 + 16 | 0;
}

function setSharedCacheTableLock($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 $3 = $4 + 76 | 0;
 label$1: {
  while (1) {
   $3 = HEAP32[$3 >> 2];
   if ($3) {
    if (HEAP32[$3 + 4 >> 2] == ($1 | 0) & HEAP32[$3 >> 2] == ($0 | 0)) {
     break label$1;
    }
    $3 = $3 + 12 | 0;
    continue;
   }
   break;
  }
  $3 = sqlite3MallocZero(16, 0);
  if (!$3) {
   return 7;
  }
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 12 >> 2] = HEAP32[$4 + 76 >> 2];
  HEAP32[$4 + 76 >> 2] = $3;
 }
 if (HEAPU8[$3 + 8 | 0] < $2 >>> 0) {
  HEAP8[$3 + 8 | 0] = $2;
 }
 return 0;
}

function jsonPatchFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $1 = __stack_pointer + -64 | 0;
 __stack_pointer = $1;
 if (!jsonParse($1 + 32 | 0, $0, sqlite3_value_text(HEAP32[$2 >> 2]))) {
  $3 = $1 + 32 | 0;
  if (!jsonParse($1, $0, sqlite3_value_text(HEAP32[$2 + 4 >> 2]))) {
   $2 = jsonMergePatch($1 + 32 | 0, 0, HEAP32[$1 + 8 >> 2]);
   label$3: {
    if ($2) {
     jsonReturnJson($2, $0, 0);
     break label$3;
    }
    sqlite3_result_error_nomem($0);
   }
   jsonParseReset($1 + 32 | 0);
   $3 = $1;
  }
  jsonParseReset($3);
 }
 __stack_pointer = $1 - -64 | 0;
}

function exprNodeIsConstantOrGroupBy($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 24 >> 2];
 while (1) {
  if (HEAP32[$3 >> 2] > ($2 | 0)) {
   label$3: {
    $4 = HEAP32[(($2 << 4) + $3 | 0) + 8 >> 2];
    if ((sqlite3ExprCompare(0, $1, $4, -1) | 0) > 1) {
     break label$3;
    }
    if (!sqlite3IsBinary(sqlite3ExprNNCollSeq(HEAP32[$0 >> 2], $4))) {
     break label$3;
    }
    return 1;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 if (HEAPU8[$1 + 5 | 0] & 16) {
  HEAP16[$0 + 20 >> 1] = 0;
  return 2;
 }
 return exprNodeIsConstant($0, $1) | 0;
}

function vdbeMergeEngineInit($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 HEAP32[$1 + 4 >> 2] = $0;
 $2 = HEAP32[$1 >> 2];
 $4 = ($2 | 0) > 0 ? $2 : 0;
 label$1: {
  while (1) {
   if (($3 | 0) != ($4 | 0)) {
    $2 = Math_imul($3, 56);
    $3 = $3 + 1 | 0;
    $2 = vdbePmaReaderIncrInit(HEAP32[$1 + 12 >> 2] + $2 | 0);
    if (!$2) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $3 = HEAP32[$1 >> 2];
  while (1) {
   if (($3 | 0) >= 2) {
    $3 = $3 - 1 | 0;
    vdbeMergeEngineCompare($1, $3);
    continue;
   }
   break;
  }
  $2 = HEAPU8[HEAP32[$0 + 12 >> 2] + 23 | 0];
 }
 return $2;
}

function sqlite3DefaultRowEst($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAPU16[$0 + 50 >> 1];
 $1 = $1 >>> 0 < 5 ? $1 : 5;
 $3 = HEAP32[$0 + 8 >> 2];
 $4 = HEAP32[$0 + 12 >> 2];
 $2 = HEAP16[$4 + 38 >> 1];
 if (($2 | 0) <= 98) {
  HEAP16[$4 + 38 >> 1] = 99;
  $2 = 99;
 }
 HEAP16[$3 >> 1] = HEAP32[$0 + 36 >> 2] ? $2 - 10 | 0 : $2;
 __memcpy($3 + 2 | 0, 33404, $1 << 1);
 while (1) {
  $2 = HEAPU16[$0 + 50 >> 1];
  if ($1 >>> 0 < $2 >>> 0) {
   $1 = $1 + 1 | 0;
   HEAP16[($1 << 1) + $3 >> 1] = 23;
   continue;
  }
  break;
 }
 if (HEAPU8[$0 + 54 | 0]) {
  HEAP16[($2 << 1) + $3 >> 1] = 0;
 }
}

function fts3WriteExprList($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 if ($1) {
  $5 = fts3QuoteId($1);
  $1 = $5;
 } else {
  $1 = 29623;
 }
 fts3Appendf($2, $3 + 12 | 0, 21197, 0);
 while (1) {
  if (($4 | 0) < HEAP32[$0 + 24 >> 2]) {
   HEAP32[$3 >> 2] = $1;
   fts3Appendf($2, $3 + 12 | 0, 25715, $3);
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 if (HEAP32[$0 + 44 >> 2]) {
  fts3Appendf($2, $3 + 12 | 0, 21195, 0);
 }
 sqlite3_free($5);
 __stack_pointer = $3 + 16 | 0;
 $4 = HEAP32[$3 + 12 >> 2];
 return $4;
}

function jsonObjectStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $1 = sqlite3_aggregate_context($0, 128);
 if ($1) {
  label$2: {
   label$3: {
    if (!HEAP32[$1 + 4 >> 2]) {
     jsonInit($1, $0);
     $3 = 123;
     break label$3;
    }
    $3 = 44;
    if (!HEAP32[$1 + 20 >> 2] & HEAPU32[$1 + 16 >> 2] < 2) {
     break label$2;
    }
   }
   jsonAppendChar($1, $3);
  }
  HEAP32[$1 >> 2] = $0;
  jsonAppendString($1, sqlite3_value_text(HEAP32[$2 >> 2]), sqlite3_value_bytes(HEAP32[$2 >> 2]));
  jsonAppendChar($1, 58);
  jsonAppendValue($1, HEAP32[$2 + 4 >> 2]);
 }
}

function __emscripten_environ_constructor() {
 var $0 = 0, $1 = 0, $2 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 label$1: {
  if (__wasi_environ_sizes_get($0 + 12 | 0, $0 + 8 | 0) | 0) {
   break label$1;
  }
  $1 = dlmalloc((HEAP32[$0 + 12 >> 2] << 2) + 4 | 0);
  HEAP32[17762] = $1;
  if (!$1) {
   break label$1;
  }
  $1 = dlmalloc(HEAP32[$0 + 8 >> 2]);
  if ($1) {
   $2 = HEAP32[17762];
   HEAP32[$2 + (HEAP32[$0 + 12 >> 2] << 2) >> 2] = 0;
   if (!(__wasi_environ_get($2 | 0, $1 | 0) | 0)) {
    break label$1;
   }
  }
  HEAP32[17762] = 0;
 }
 __stack_pointer = $0 + 16 | 0;
}

function fts3ExprLHitGather($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  while (1) {
   $2 = 0;
   if (HEAPU8[$0 + 32 | 0]) {
    break label$1;
   }
   $3 = HEAP32[$1 >> 2];
   $4 = HEAP32[$3 + 36 >> 2];
   $5 = HEAP32[$3 + 32 >> 2];
   $3 = HEAP32[$0 + 24 >> 2];
   if (($5 | 0) != ($3 | 0) | ($4 | 0) != HEAP32[$0 + 28 >> 2]) {
    break label$1;
   }
   $2 = HEAP32[$0 + 12 >> 2];
   if ($2) {
    $2 = fts3ExprLHitGather($2, $1);
    if ($2) {
     break label$1;
    }
    $0 = HEAP32[$0 + 16 >> 2];
    continue;
   }
   break;
  }
  $2 = fts3ExprLHits($0, $1);
 }
 return $2;
}

function sqlite3PcacheSetPageSize($0, $1) {
 var $2 = 0, $3 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 if (HEAP32[$0 + 24 >> 2]) {
  $2 = FUNCTION_TABLE[HEAP32[16097]]($1, HEAP32[$0 + 28 >> 2] + 40 | 0, HEAPU8[$0 + 32 | 0]) | 0;
  if (!$2) {
   return 7;
  }
  wasm2js_i32$1 = $2, wasm2js_i32$2 = numberOfCachePages($0), wasm2js_i32$0 = HEAP32[16098], 
  FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0);
  $3 = HEAP32[$0 + 44 >> 2];
  if ($3) {
   FUNCTION_TABLE[HEAP32[16104]]($3);
  }
  HEAP32[$0 + 24 >> 2] = $1;
  HEAP32[$0 + 44 >> 2] = $2;
 }
 return 0;
}

function sqlite3DbFreeNN($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  if (HEAP32[$0 + 528 >> 2]) {
   measureAllocationSize($0, $1);
   return;
  }
  if (HEAPU32[$0 + 356 >> 2] <= $1 >>> 0) {
   break label$1;
  }
  if (HEAPU32[$0 + 348 >> 2] <= $1 >>> 0) {
   $2 = $0;
   $0 = $0 + 344 | 0;
   HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$2 + 344 >> 2] = $1;
   return;
  }
  if (HEAPU32[$0 + 352 >> 2] > $1 >>> 0) {
   break label$1;
  }
  $2 = $0;
  $0 = $0 + 336 | 0;
  HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$2 + 336 >> 2] = $1;
  return;
 }
 sqlite3_free($1);
}

function fts3SegReaderCmp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$1 + 40 >> 2];
 label$1: {
  label$2: {
   $3 = HEAP32[$0 + 40 >> 2];
   if ($3) {
    if ($2) {
     break label$2;
    }
    $2 = -1;
   } else {
    $2 = $2 ? 0 : -1;
   }
   $2 = $2 + !$3 | 0;
   break label$1;
  }
  $2 = HEAP32[$0 + 60 >> 2];
  $4 = $2;
  $3 = HEAP32[$1 + 60 >> 2];
  $2 = $2 - $3 | 0;
  $3 = memcmp(HEAP32[$0 + 64 >> 2], HEAP32[$1 + 64 >> 2], ($2 | 0) < 0 ? $4 : $3);
  $2 = $3 ? $3 : $2;
 }
 if (!$2) {
  $2 = HEAP32[$1 >> 2] - HEAP32[$0 >> 2] | 0;
 }
 return $2 | 0;
}

function fts3SegmentMaxLevel($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $4 = fts3SqlStmt($0, 15, $5 + 12 | 0, 0);
 if (!$4) {
  $4 = HEAP32[$5 + 12 >> 2];
  sqlite3_bind_int64($4, 1, getAbsoluteLevel($0, $1, $2, 0), i64toi32_i32$HIGH_BITS);
  sqlite3_bind_int64($4, 2, getAbsoluteLevel($0, $1, $2, 1023), i64toi32_i32$HIGH_BITS);
  if ((sqlite3_step($4) | 0) == 100) {
   HEAP32[$3 >> 2] = sqlite3_column_int64($4, 0);
   HEAP32[$3 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
  }
  $4 = sqlite3_reset($4);
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function unixWrite($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 while (1) {
  $5 = seekAndWrite($0, $3, $4, $1, $2);
  $6 = ($5 | 0) >= ($2 | 0);
  if (!($6 | ($5 | 0) <= 0)) {
   $1 = $1 + $5 | 0;
   $2 = $2 - $5 | 0;
   $3 = $3 + $5 | 0;
   $4 = $5 >>> 0 > $3 >>> 0 ? $4 + 1 | 0 : $4;
   continue;
  }
  break;
 }
 $2 = 0;
 label$3: {
  if ($6) {
   break label$3;
  }
  if (($5 | 0) < 0) {
   $2 = 778;
   if (HEAP32[$0 + 20 >> 2] != 51) {
    break label$3;
   }
  }
  storeLastErrno($0, 0);
  $2 = 13;
 }
 return $2 | 0;
}

function remove_diacritic($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $7 = $0 << 3 | 7;
 $2 = 125;
 while (1) {
  if (($2 | 0) >= ($5 | 0)) {
   $3 = ($2 + $5 | 0) / 2 | 0;
   $6 = HEAPU16[($3 << 1) + 54e3 >> 1] > $7 >>> 0;
   $5 = $6 ? $5 : $3 + 1 | 0;
   $2 = $6 ? $3 - 1 | 0 : $2;
   $4 = $6 ? $4 : $3;
   continue;
  }
  break;
 }
 label$3: {
  if (!$1 & HEAP8[$4 + 54256 | 0] < 0) {
   break label$3;
  }
  $2 = HEAPU16[($4 << 1) + 54e3 >> 1];
  if ((($2 >>> 3 | 0) + ($2 & 7) | 0) < ($0 | 0)) {
   break label$3;
  }
  $0 = HEAPU8[$4 + 54256 | 0] & 127;
 }
 return $0;
}

function sqlite3PcacheSetSpillsize($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$1) {
   $1 = HEAP32[$0 + 20 >> 2];
   break label$1;
  }
  if (($1 | 0) < 0) {
   $4 = $1 << 10;
   $2 = $1 >> 31;
   $1 = ($2 << 10 | $1 >>> 22) + (($4 | 0) != 0) | 0;
   $1 = 0 - $1 | 0;
   $3 = $1;
   $2 = HEAP32[$0 + 28 >> 2] + HEAP32[$0 + 24 >> 2] | 0;
   $1 = $2 >> 31;
   $5 = $1;
   $1 = $3;
   $3 = $2;
   $2 = $5;
   $2 = __wasm_i64_sdiv(0 - $4 | 0, $1, $3, $2);
   $1 = $2;
  }
  HEAP32[$0 + 20 >> 2] = $1;
 }
 $0 = numberOfCachePages($0);
 return ($0 | 0) > ($1 | 0) ? $0 : $1;
}

function fts3tokColumnMethod($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 label$1: {
  label$2: {
   switch ($2 | 0) {
   case 0:
    sqlite3_result_text($1, HEAP32[$0 + 4 >> 2], -1, -1);
    break label$1;

   case 1:
    sqlite3_result_text($1, HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], -1);
    break label$1;

   case 2:
    sqlite3_result_int($1, HEAP32[$0 + 24 >> 2]);
    break label$1;

   case 3:
    sqlite3_result_int($1, HEAP32[$0 + 28 >> 2]);
    break label$1;

   default:
    break label$2;
   }
  }
  sqlite3_result_int($1, HEAP32[$0 + 32 >> 2]);
 }
 return 0;
}

function sqlite3PagerSetFlags($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if (HEAPU8[$0 + 12 | 0]) {
  $3 = 1;
 } else {
  $3 = $1 & 7;
  $2 = ($3 | 0) == 4;
  $4 = $3 >>> 0 > 2;
  $3 = ($3 | 0) == 1;
 }
 HEAP8[$0 + 9 | 0] = $2;
 HEAP8[$0 + 8 | 0] = $4;
 HEAP8[$0 + 7 | 0] = $3;
 $2 = 0;
 label$3: {
  if ($3) {
   break label$3;
  }
  $2 = 3;
  if ($1 & 8) {
   break label$3;
  }
  $2 = 2;
 }
 HEAP8[$0 + 10 | 0] = $2;
 HEAP8[$0 + 21 | 0] = ($1 >>> 5 & 1 | HEAPU8[$0 + 21 | 0] & 254) ^ 1;
 $4 = $4 ? $2 : 0;
 $2 = $2 << 2;
 HEAP8[$0 + 11 | 0] = $4 | ($3 ? $2 : ($1 & 16) >>> 4 | 0 ? 12 : $2);
}

function getSafetyLevel($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (HEAPU8[$0 | 0] - 58 >>> 0 >= 4294967286) {
   $2 = sqlite3Atoi($0);
   break label$1;
  }
  $4 = sqlite3Strlen30($0);
  $1 = !$1;
  while (1) {
   if (($3 | 0) == 8) {
    break label$1;
   }
   label$4: {
    if (HEAPU8[$3 + 49505 | 0] != ($4 | 0)) {
     break label$4;
    }
    if (sqlite3_strnicmp(HEAPU8[$3 + 49497 | 0] + 49472 | 0, $0, $4) | !($3 >>> 0 < 6 | $1)) {
     break label$4;
    }
    $2 = HEAPU8[$3 + 49513 | 0];
    break label$1;
   }
   $3 = $3 + 1 | 0;
   continue;
  }
 }
 return $2 & 255;
}

function fts3Appendf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 if (!HEAP32[$0 >> 2]) {
  HEAP32[$4 + 12 >> 2] = $3;
  $2 = sqlite3_vmprintf($2, $3);
  label$2: {
   if ($2) {
    $3 = HEAP32[$1 >> 2];
    if (!$3) {
     $3 = $2;
     break label$2;
    }
    HEAP32[$4 + 4 >> 2] = $2;
    HEAP32[$4 >> 2] = $3;
    $3 = sqlite3_mprintf(5782, $4);
    sqlite3_free($2);
    if ($3) {
     break label$2;
    }
   }
   HEAP32[$0 >> 2] = 7;
   $3 = 0;
  }
  sqlite3_free(HEAP32[$1 >> 2]);
  HEAP32[$1 >> 2] = $3;
 }
 __stack_pointer = $4 + 16 | 0;
}

function removeElementGivenHash($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = HEAP32[$1 >> 2];
 $3 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if ($3) {
   HEAP32[$3 >> 2] = $4;
   $4 = HEAP32[$1 >> 2];
   break label$1;
  }
  HEAP32[$0 + 8 >> 2] = $4;
 }
 if ($4) {
  HEAP32[$4 + 4 >> 2] = $3;
 }
 $3 = HEAP32[$0 + 12 >> 2];
 if ($3) {
  $3 = ($2 << 3) + $3 | 0;
  if (HEAP32[$3 + 4 >> 2] == ($1 | 0)) {
   HEAP32[$3 + 4 >> 2] = $4;
  }
  HEAP32[$3 >> 2] = HEAP32[$3 >> 2] - 1;
 }
 sqlite3_free($1);
 $1 = HEAP32[$0 + 4 >> 2] - 1 | 0;
 HEAP32[$0 + 4 >> 2] = $1;
 if (!$1) {
  sqlite3HashClear($0);
 }
}

function atanh($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 wasm2js_scratch_store_f64(+$0);
 $2 = wasm2js_scratch_load_i32(1) | 0;
 $1 = wasm2js_scratch_load_i32(0) | 0;
 wasm2js_scratch_store_i32(0, $1 | 0);
 wasm2js_scratch_store_i32(1, $2 & 2147483647);
 $0 = +wasm2js_scratch_load_f64();
 $1 = $2 >>> 20 & 2047;
 label$1: {
  label$2: {
   if ($1 >>> 0 <= 1021) {
    if ($1 >>> 0 < 991) {
     break label$1;
    }
    $3 = $0 + $0;
    $0 = $3 + $3 * $0 / (1 - $0);
    break label$2;
   }
   $0 = $0 / (1 - $0);
   $0 = $0 + $0;
  }
  $0 = log1p($0) * .5;
 }
 return ($2 | 0) < 0 ? -$0 : $0;
}

function sqlite3ColumnSetColl($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $4 = HEAP32[$1 >> 2];
 $5 = sqlite3Strlen30($4) + 1 | 0;
 $7 = $5;
 if (HEAPU8[$1 + 10 | 0] & 4) {
  $6 = $7;
  $3 = $6 + (sqlite3Strlen30($4 + $5 | 0) + 1 | 0) | 0;
  $7 = $3;
  $8 = $3 >>> 0 < $6 >>> 0 ? 1 : $8;
 }
 $3 = $8;
 $5 = sqlite3Strlen30($2) + 1 | 0;
 $6 = $5 + $7 | 0;
 $3 = $6 >>> 0 < $5 >>> 0 ? $3 + 1 | 0 : $3;
 $4 = sqlite3DbRealloc($0, $4, $6, $3);
 if ($4) {
  HEAP32[$1 >> 2] = $4;
  __memcpy($4 + $7 | 0, $2, $5);
  HEAP16[$1 + 10 >> 1] = HEAPU16[$1 + 10 >> 1] | 512;
 }
}

function fts3MIBufferNew($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $3 = $0 >>> 29 | 0;
 $5 = $0 << 3;
 $4 = strlen($1);
 $2 = $5 + $4 | 0;
 $6 = $3;
 $7 = $2 >>> 0 < $4 >>> 0 ? $3 + 1 | 0 : $3;
 $3 = $2;
 $2 = $7;
 $3 = $3 + 25 | 0;
 $2 = $3 >>> 0 < 25 ? $2 + 1 | 0 : $2;
 $2 = sqlite3Fts3MallocZero($3, $2);
 if ($2) {
  HEAP32[$2 + 16 >> 2] = 20;
  $3 = $0 << 2;
  HEAP32[($3 + $2 | 0) + 20 >> 2] = $3 + 24;
  $3 = ($2 + $5 | 0) + 24 | 0;
  HEAP32[$2 + 12 >> 2] = $3;
  HEAP32[$2 + 4 >> 2] = $0;
  __memcpy($3, $1, $4 + 1 | 0);
  HEAP8[$2 | 0] = 1;
 }
 return $2;
}

function doubleToInt64($0) {
 var $1 = 0, $2 = 0;
 $1 = -2147483648;
 $2 = 0;
 label$1: {
  if ($0 <= -0x8000000000000000) {
   break label$1;
  }
  $1 = 2147483647;
  $2 = -1;
  if ($0 >= 0x8000000000000000) {
   break label$1;
  }
  if (Math_abs($0) < 0x8000000000000000) {
   $1 = ~~$0 >>> 0;
   i64toi32_i32$HIGH_BITS = Math_abs($0) >= 1 ? ~~($0 > 0 ? Math_min(Math_floor($0 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($0 - +(~~$0 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
   return $1;
  }
  $1 = -2147483648;
  $2 = 0;
 }
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function sqlite3TwoPartName($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAP32[$2 + 4 >> 2]) {
   if (HEAPU8[$5 + 177 | 0]) {
    sqlite3ErrorMsg($0, 12902, 0);
    $2 = -1;
    break label$1;
   }
   HEAP32[$3 >> 2] = $2;
   $2 = sqlite3FindDb($5, $1);
   if (($2 | 0) >= 0) {
    break label$1;
   }
   HEAP32[$4 >> 2] = $1;
   sqlite3ErrorMsg($0, 18480, $4);
   $2 = -1;
   break label$1;
  }
  $2 = HEAPU8[$5 + 176 | 0];
  HEAP32[$3 >> 2] = $1;
 }
 __stack_pointer = $4 + 16 | 0;
 return $2;
}

function sqlite3RealSameAsInt($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = 1;
 label$1: {
  if ($0 == 0) {
   break label$1;
  }
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $5 = $3;
  $3 = $2;
  wasm2js_scratch_store_f64(+(+($1 >>> 0) + +($3 | 0) * 4294967296));
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $1 = $3;
  $3 = $5;
  $1 = ($4 | 0) != (wasm2js_scratch_load_i32(0) | 0) | ($1 | 0) != ($3 | 0);
  $3 = 0;
  if ($1 | ($2 | 0) < -524288) {
   break label$1;
  }
  $3 = ($2 | 0) < 524288;
 }
 return $3;
}

function sqlite3FkClearTriggerCache($0, $1) {
 var $2 = 0;
 $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 16 | 0;
 label$1: while (1) {
  $2 = HEAP32[$2 >> 2];
  if ($2) {
   $1 = HEAP32[$2 + 8 >> 2];
   if (HEAPU8[$1 + 43 | 0]) {
    continue;
   }
   $1 = $1 + 48 | 0;
   while (1) {
    $1 = HEAP32[$1 >> 2];
    if (!$1) {
     continue label$1;
    }
    fkTriggerDelete($0, HEAP32[$1 + 28 >> 2]);
    HEAP32[$1 + 28 >> 2] = 0;
    fkTriggerDelete($0, HEAP32[$1 + 32 >> 2]);
    HEAP32[$1 + 32 >> 2] = 0;
    $1 = $1 + 4 | 0;
    continue;
   }
  }
  break;
 }
}

function modeFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 0);
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 56 >> 2];
  if (!$2) {
   break label$1;
  }
  map_iterate($2, 428, $1);
  map_destroy(HEAP32[$1 + 56 >> 2]);
  dlfree(HEAP32[$1 + 56 >> 2]);
  if (HEAP32[$1 + 40 >> 2] != 1 | HEAP32[$1 + 44 >> 2]) {
   break label$1;
  }
  if (!(HEAP32[$1 + 48 >> 2] | HEAP32[$1 + 52 >> 2])) {
   sqlite3_result_int64($0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
   return;
  }
  sqlite3_result_double($0, HEAPF64[$1 + 8 >> 3]);
 }
}

function fts3EvalPhraseNext($0, $1, $2) {
 var $3 = 0, $4 = 0;
 if (HEAP32[$1 + 40 >> 2]) {
  return fts3EvalIncrPhraseNext($0, $1, $2);
 }
 label$2: {
  label$3: {
   $3 = HEAPU8[$0 + 52 | 0];
   $0 = HEAP32[$0 >> 2];
   $4 = HEAPU8[$0 + 239 | 0];
   if (($3 | 0) == ($4 | 0)) {
    break label$3;
   }
   $3 = HEAP32[$1 + 4 >> 2];
   if (!$3) {
    break label$3;
   }
   sqlite3Fts3DoclistPrev($4, HEAP32[$1 >> 2], $3, $1 + 8 | 0, $1 + 16 | 0, $1 + 32 | 0, $2);
   HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 8 >> 2];
   break label$2;
  }
  fts3EvalDlPhraseNext($0, $1, $2);
 }
 return 0;
}

function triggerStepAllocate($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  $7 = HEAP32[$0 >> 2];
  $5 = sqlite3DbMallocZero($7, HEAP32[$2 + 4 >> 2] + 49 | 0, 0);
  if (!$5) {
   break label$1;
  }
  $6 = __memcpy($5 + 48 | 0, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
  sqlite3Dequote($6);
  HEAP8[$5 | 0] = $1;
  HEAP32[$5 + 12 >> 2] = $6;
  HEAP32[$5 + 36 >> 2] = triggerSpanDup($7, $3, $4);
  if (HEAPU8[$0 + 208 | 0] >= 2) {
   sqlite3RenameTokenMap($0, HEAP32[$5 + 12 >> 2], $2);
  }
  $6 = $5;
 }
 return $6;
}

function fts3PutDeltaVarint3($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 label$1: {
  if (!(HEAP32[$3 >> 2] ? $1 : 0)) {
   $6 = $4;
   $1 = $2;
   $7 = HEAP32[$1 >> 2];
   $8 = HEAP32[$1 + 4 >> 2];
   $9 = $5;
   break label$1;
  }
  $1 = $2;
  $6 = HEAP32[$1 >> 2];
  $7 = $4;
  $8 = $5;
  $9 = HEAP32[$1 + 4 >> 2];
 }
 $1 = $6;
 $6 = ($7 >>> 0 > $1 >>> 0) + $8 | 0;
 $6 = $9 - $6 | 0;
 HEAP32[$0 >> 2] = sqlite3Fts3PutVarint(HEAP32[$0 >> 2], $1 - $7 | 0, $6) + HEAP32[$0 >> 2];
 $1 = $2;
 HEAP32[$1 >> 2] = $4;
 HEAP32[$1 + 4 >> 2] = $5;
 HEAP32[$3 >> 2] = 1;
}

function fts3OptimizeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 label$1: {
  if (fts3FunctionArg($0, 12206, HEAP32[$2 >> 2], $1 + 12 | 0)) {
   break label$1;
  }
  label$2: {
   $2 = sqlite3Fts3Optimize(HEAP32[HEAP32[$1 + 12 >> 2] >> 2]);
   if (($2 | 0) != 101) {
    if ($2) {
     break label$2;
    }
    sqlite3_result_text($0, 14592, -1, 0);
    break label$1;
   }
   sqlite3_result_text($0, 11295, -1, 0);
   break label$1;
  }
  sqlite3_result_error_code($0, $2);
 }
 __stack_pointer = $1 + 16 | 0;
}

function unicodeOpen($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $0 = sqlite3_malloc(28);
 if (!$0) {
  return 7;
 }
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = $1;
 label$2: {
  if (!$1) {
   HEAP32[$0 + 4 >> 2] = 29623;
   break label$2;
  }
  if (($2 | 0) < 0) {
   HEAP32[$0 + 8 >> 2] = strlen($1);
   break label$2;
  }
  HEAP32[$0 + 8 >> 2] = $2;
 }
 HEAP32[$3 >> 2] = $0;
 return 0;
}

function fts3MIBufferAlloc($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!HEAPU8[$0 + 1 | 0]) {
   HEAP8[$0 + 1 | 0] = 1;
   $2 = $0 + 20 | 0;
   $3 = 111;
   break label$1;
  }
  if (!HEAPU8[$0 + 2 | 0]) {
   HEAP8[$0 + 2 | 0] = 1;
   $2 = ((HEAP32[$0 + 4 >> 2] << 2) + $0 | 0) + 24 | 0;
   $3 = 111;
   break label$1;
  }
  $2 = sqlite3_malloc64(HEAP32[$0 + 4 >> 2] << 2, 0);
  if (!$2) {
   $2 = 0;
   break label$1;
  }
  $3 = 3;
  if (!HEAP32[$0 + 8 >> 2]) {
   break label$1;
  }
  __memcpy($2, $0 + 20 | 0, HEAP32[$0 + 4 >> 2] << 2);
 }
 HEAP32[$1 >> 2] = $2;
 return $3;
}

function fixExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$0 + 24 >> 2];
 if (!HEAPU8[$3 + 36 | 0]) {
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1073741824;
 }
 $0 = 0;
 label$2: {
  if (HEAPU8[$1 | 0] != 156) {
   break label$2;
  }
  $4 = HEAP32[$3 >> 2];
  if (HEAPU8[HEAP32[$4 >> 2] + 177 | 0]) {
   HEAP8[$1 | 0] = 121;
   break label$2;
  }
  HEAP32[$2 >> 2] = HEAP32[$3 + 44 >> 2];
  sqlite3ErrorMsg($4, 5451, $2);
  $0 = 2;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0 | 0;
}

function vdbeMemRenderNum($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 label$1: {
  if (HEAPU8[$1 + 16 | 0] & 4) {
   sqlite3Int64ToText(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], $0);
   break label$1;
  }
  sqlite3StrAccumInit($2 + 8 | 0, 0, $0, 32, 0);
  if (HEAPU8[$1 + 16 | 0] & 32) {
   $3 = +HEAPU32[$1 >> 2] + +HEAP32[$1 + 4 >> 2] * 4294967296;
  } else {
   $3 = HEAPF64[$1 >> 3];
  }
  HEAPF64[$2 >> 3] = $3;
  sqlite3_str_appendf($2 + 8 | 0, 12016, $2);
  HEAP8[HEAP32[$2 + 24 >> 2] + $0 | 0] = 0;
 }
 __stack_pointer = $2 + 32 | 0;
}

function sqlite3VdbeEnter($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (!HEAP32[$0 + 156 >> 2]) {
   break label$1;
  }
  $1 = HEAP32[$0 >> 2];
  $3 = HEAP32[$1 + 20 >> 2];
  $3 = ($3 | 0) > 0 ? $3 : 0;
  $4 = HEAP32[$1 + 16 >> 2];
  while (1) {
   if (($2 | 0) == ($3 | 0)) {
    break label$1;
   }
   label$3: {
    if (!(HEAP32[$0 + 156 >> 2] >>> $2 & 1) | ($2 | 0) == 1) {
     break label$3;
    }
    $1 = HEAP32[(($2 << 4) + $4 | 0) + 4 >> 2];
    if (!$1) {
     break label$3;
    }
    sqlite3BtreeEnter($1);
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
}

function destroyTable($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $8 = $1 + 8 | 0;
 $5 = HEAP32[$1 + 20 >> 2];
 while (1) {
  $2 = $4 ? $4 >>> 0 > $5 >>> 0 ? $5 : 0 : $5;
  $3 = $8;
  while (1) {
   $3 = HEAP32[$3 >> 2];
   if ($3) {
    $6 = HEAP32[$3 + 44 >> 2];
    $7 = $2 >>> 0 < $6 >>> 0 ? $6 : $2;
    $2 = $4 ? $4 >>> 0 > $6 >>> 0 ? $7 : $2 : $7;
    $3 = $3 + 20 | 0;
    continue;
   }
   break;
  }
  if ($2) {
   destroyRootPage($0, $2, sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$1 + 60 >> 2]));
   $4 = $2;
   continue;
  }
  break;
 }
}

function sqlite3VtabSync($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = HEAP32[$0 + 404 >> 2];
 HEAP32[$0 + 404 >> 2] = 0;
 while (1) {
  if (!(HEAP32[$0 + 380 >> 2] <= ($3 | 0) | $4)) {
   $4 = 0;
   $2 = HEAP32[HEAP32[($3 << 2) + $5 >> 2] + 8 >> 2];
   label$3: {
    if (!$2) {
     break label$3;
    }
    $6 = HEAP32[HEAP32[$2 >> 2] + 60 >> 2];
    if (!$6) {
     break label$3;
    }
    $4 = FUNCTION_TABLE[$6 | 0]($2) | 0;
    sqlite3VtabImportErrmsg($1, $2);
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 + 404 >> 2] = $5;
 return $4;
}

function tan($0) {
 var $1 = 0, $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $1 = $1 & 2147483647;
 label$1: {
  if ($1 >>> 0 <= 1072243195) {
   if ($1 >>> 0 < 1044381696) {
    break label$1;
   }
   $0 = __tan($0, 0, 0);
   break label$1;
  }
  if ($1 >>> 0 >= 2146435072) {
   $0 = $0 - $0;
   break label$1;
  }
  $1 = __rem_pio2($0, $2);
  $0 = __tan(HEAPF64[$2 >> 3], HEAPF64[$2 + 8 >> 3], $1 & 1);
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function sqlite3ExprListCompare($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!($0 | $1)) {
   break label$1;
  }
  $3 = 1;
  if (!$0 | !$1 | HEAP32[$0 >> 2] != HEAP32[$1 >> 2]) {
   break label$1;
  }
  while (1) {
   if (HEAP32[$0 >> 2] <= ($4 | 0)) {
    return 0;
   }
   $3 = $4 << 4;
   $5 = $3 + $0 | 0;
   $3 = $1 + $3 | 0;
   if (HEAPU8[$5 + 16 | 0] != HEAPU8[$3 + 16 | 0]) {
    return 1;
   }
   $4 = $4 + 1 | 0;
   $3 = sqlite3ExprCompare(0, HEAP32[$5 + 8 >> 2], HEAP32[$3 + 8 >> 2], $2);
   if (!$3) {
    continue;
   }
   break;
  }
 }
 return $3;
}

function setRawDateNumber($0, $1) {
 var $2 = 0, $3 = 0;
 HEAP8[$0 + 41 | 0] = 1;
 HEAPF64[$0 + 32 >> 3] = $1;
 if (!(!($1 >= 0) | !($1 < 5373484.5))) {
  HEAP8[$0 + 40 | 0] = 1;
  $1 = $1 * 864e5 + .5;
  label$2: {
   if (Math_abs($1) < 0x8000000000000000) {
    $2 = Math_abs($1) >= 1 ? ~~($1 > 0 ? Math_min(Math_floor($1 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($1 - +(~~$1 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
    $3 = ~~$1 >>> 0;
    break label$2;
   }
   $2 = -2147483648;
   $3 = 0;
  }
  HEAP32[$0 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $2;
 }
}

function sqlite3RowSetInsert($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = rowSetEntryAlloc($0);
 if ($3) {
  HEAP32[$3 + 8 >> 2] = 0;
  HEAP32[$3 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  $4 = HEAP32[$0 + 12 >> 2];
  label$2: {
   if ($4) {
    $5 = HEAP32[$4 >> 2];
    $1 = $5 >>> 0 >= $1 >>> 0;
    $5 = HEAP32[$4 + 4 >> 2];
    if ($1 & ($2 | 0) <= ($5 | 0) | ($2 | 0) < ($5 | 0)) {
     HEAP16[$0 + 26 >> 1] = HEAPU16[$0 + 26 >> 1] & 65534;
    }
    HEAP32[$4 + 8 >> 2] = $3;
    break label$2;
   }
   HEAP32[$0 + 8 >> 2] = $3;
  }
  HEAP32[$0 + 12 >> 2] = $3;
 }
}

function sqlite3Dequote($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = HEAPU8[$0 | 0];
  if (HEAP8[$1 + 30288 | 0] >= 0) {
   break label$1;
  }
  $2 = ($1 | 0) == 91 ? 93 : $1;
  $1 = 1;
  while (1) {
   label$3: {
    $3 = HEAPU8[$0 + $1 | 0];
    if (($3 | 0) == ($2 | 0)) {
     $3 = $2;
     $1 = $1 + 1 | 0;
     if (HEAPU8[$1 + $0 | 0] != ($2 | 0)) {
      break label$3;
     }
    }
    HEAP8[$0 + $4 | 0] = $3;
    $1 = $1 + 1 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP8[$0 + $4 | 0] = 0;
 }
}

function resolveAsName($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 59) {
   break label$1;
  }
  $2 = HEAP32[$0 >> 2];
  $3 = ($2 | 0) > 0 ? $2 : 0;
  $4 = HEAP32[$1 + 8 >> 2];
  $1 = 0;
  while (1) {
   if (($1 | 0) == ($3 | 0)) {
    break label$1;
   }
   label$3: {
    $2 = ($1 << 4) + $0 | 0;
    if (HEAPU8[$2 + 17 | 0] & 3) {
     break label$3;
    }
    if (sqlite3_stricmp(HEAP32[$2 + 12 >> 2], $4)) {
     break label$3;
    }
    $5 = $1 + 1 | 0;
    break label$1;
   }
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 return $5;
}

function sqlite3VdbeMemFromBtree($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 HEAP16[$3 + 16 >> 1] = 1;
 $5 = sqlite3BtreeMaxRecordSize($0) >>> 0 < $1 + $2 >>> 0;
 $4 = i64toi32_i32$HIGH_BITS;
 if ($5 & ($4 | 0) <= 0 | ($4 | 0) < 0) {
  return sqlite3CorruptError(79981);
 }
 $4 = sqlite3VdbeMemClearAndResize($3, $2 + 1 | 0);
 if (!$4) {
  $4 = sqlite3BtreePayload($0, $1, $2, HEAP32[$3 + 8 >> 2]);
  if (!$4) {
   HEAP8[HEAP32[$3 + 8 >> 2] + $2 | 0] = 0;
   HEAP32[$3 + 12 >> 2] = $2;
   HEAP16[$3 + 16 >> 1] = 16;
   return 0;
  }
  sqlite3VdbeMemRelease($3);
 }
 return $4;
}

function sqlite3AllocateIndexObject($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $5 = ($1 << 2) + 7 & -8;
 $4 = $1 << 1;
 $6 = $4 + 2 | 0;
 $7 = ($5 + (($6 + ($1 + $4 | 0) | 0) + 7 & -8) | 0) + 72 | 0;
 $2 = $7 + $2 | 0;
 $2 = sqlite3DbMallocZero($0, $2, $2 >> 31);
 if ($2) {
  HEAP16[$2 + 52 >> 1] = $1;
  $0 = $2 + 72 | 0;
  HEAP32[$2 + 32 >> 2] = $0;
  HEAP16[$2 + 50 >> 1] = $1 - 1;
  $1 = $0 + $5 | 0;
  HEAP32[$2 + 8 >> 2] = $1;
  $1 = $1 + $6 | 0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 28 >> 2] = $1 + $4;
  HEAP32[$3 >> 2] = $2 + $7;
 }
 return $2;
}

function fts3NextMethod($0) {
 $0 = $0 | 0;
 var $1 = 0;
 if (HEAPU16[$0 + 4 >> 1] <= 1) {
  $1 = HEAP32[$0 >> 2];
  HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 56 >> 2] + 1;
  label$2: {
   if ((sqlite3_step(HEAP32[$0 + 12 >> 2]) | 0) != 100) {
    HEAP8[$0 + 6 | 0] = 1;
    $0 = sqlite3_reset(HEAP32[$0 + 12 >> 2]);
    break label$2;
   }
   HEAP32[$0 + 32 >> 2] = sqlite3_column_int64(HEAP32[$0 + 12 >> 2], 0);
   HEAP32[$0 + 36 >> 2] = i64toi32_i32$HIGH_BITS;
   $0 = 0;
  }
  HEAP32[$1 + 56 >> 2] = HEAP32[$1 + 56 >> 2] - 1;
  return $0 | 0;
 }
 return fts3EvalNext($0) | 0;
}

function sqlite3Reprepare($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $2 = sqlite3_sql($0);
 $1 = sqlite3VdbeDb($0);
 $2 = sqlite3LockAndPrepare($1, $2, -1, sqlite3VdbePrepareFlags($0), $0, $3 + 12 | 0, 0);
 label$1: {
  if ($2) {
   if (($2 | 0) != 7) {
    break label$1;
   }
   sqlite3OomFault($1);
   break label$1;
  }
  $1 = HEAP32[$3 + 12 >> 2];
  sqlite3VdbeSwap($1, $0);
  sqlite3TransferBindings($1, $0);
  sqlite3VdbeResetStepResult($1);
  sqlite3VdbeFinalize($1);
 }
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function alsoAnInt($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $5 = $1;
 label$1: {
  if (Math_abs($1) < 0x8000000000000000) {
   $3 = Math_abs($1) >= 1 ? ~~($1 > 0 ? Math_min(Math_floor($1 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($1 - +(~~$1 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
   $4 = ~~$1 >>> 0;
   break label$1;
  }
  $3 = -2147483648;
 }
 if (sqlite3RealSameAsInt($5, $4, $3)) {
  HEAP32[$2 >> 2] = $4;
  HEAP32[$2 + 4 >> 2] = $3;
  return 1;
 }
 return !sqlite3Atoi64(HEAP32[$0 + 8 >> 2], $2, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]);
}

function destroyRootPage($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $5 = sqlite3GetVdbe($0);
 $4 = sqlite3GetTempReg($0);
 if (($1 | 0) <= 1) {
  sqlite3ErrorMsg($0, 17701, 0);
 }
 sqlite3VdbeAddOp3($5, 144, $1, $4, $2);
 sqlite3MayAbort($0);
 $2 = HEAP32[HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + ($2 << 4) >> 2];
 HEAP32[$3 + 12 >> 2] = $4;
 HEAP32[$3 + 8 >> 2] = $4;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 sqlite3NestedParse($0, 16084, $3);
 sqlite3ReleaseTempReg($0, $4);
 __stack_pointer = $3 + 16 | 0;
}

function unixShmSystemLock($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 48 | 0;
 __stack_pointer = $4;
 $0 = HEAP32[HEAP32[HEAP32[$0 + 8 >> 2] + 40 >> 2] + 12 >> 2];
 if (($0 | 0) >= 0) {
  HEAP16[$4 + 16 >> 1] = $1;
  $1 = $3 >> 31;
  HEAP32[$4 + 32 >> 2] = $3;
  HEAP32[$4 + 36 >> 2] = $1;
  $3 = $2;
  $1 = $3 >> 31;
  HEAP32[$4 + 24 >> 2] = $3;
  HEAP32[$4 + 28 >> 2] = $1;
  HEAP32[$4 >> 2] = $4 + 16;
  HEAP16[$4 + 18 >> 1] = 0;
  $5 = (FUNCTION_TABLE[HEAP32[16258]]($0, 6, $4) | 0) == -1 ? 5 : 0;
 }
 __stack_pointer = $4 + 48 | 0;
 return $5;
}

function sqlite3VdbeAddFunctionCall($0, $1, $2, $3, $4, $5, $6) {
 var $7 = 0, $8 = 0;
 $8 = HEAP32[$0 + 8 >> 2];
 $7 = ($4 << 2) + 28 | 0;
 $7 = sqlite3DbMallocRawNN(HEAP32[$0 >> 2], $7, $7 >> 31);
 if (!$7) {
  freeEphemeralFunction(HEAP32[$0 >> 2], $5);
  return;
 }
 HEAP8[$7 + 26 | 0] = $4;
 HEAP32[$7 + 20 >> 2] = 0;
 HEAP32[$7 + 12 >> 2] = 0;
 HEAP32[$7 + 4 >> 2] = $5;
 HEAP32[$7 >> 2] = 0;
 HEAP32[$7 + 16 >> 2] = sqlite3VdbeCurrentAddr($8);
 sqlite3VdbeAddOp4($8, $6 ? 65 : 66, $1, $2, $3, $7, -15);
 sqlite3VdbeChangeP5($8, $6 & 46);
 sqlite3MayAbort($0);
}

function seekAndWriteFd($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0;
 $7 = $4 & 131071;
 label$1: {
  label$2: {
   while (1) {
    __lseek($0, $1, $2, 0);
    $4 = i64toi32_i32$HIGH_BITS;
    if (($4 | 0) > 0 | ($4 | 0) >= 0) {
     $4 = FUNCTION_TABLE[HEAP32[16270]]($0, $3, $7) | 0;
     if (($4 | 0) >= 0) {
      break label$1;
     }
     $6 = __errno_location();
     if (HEAP32[$6 >> 2] == 27) {
      continue;
     }
     break label$2;
    }
    break;
   }
   $4 = -1;
   $6 = __errno_location();
  }
  HEAP32[$5 >> 2] = HEAP32[$6 >> 2];
 }
 return $4;
}

function __subtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 var $9 = 0, $10 = 0, $11 = 0;
 $11 = __stack_pointer - 16 | 0;
 __stack_pointer = $11;
 $9 = $8;
 $8 = $9 ^ -2147483648;
 $10 = $4;
 $9 = $6;
 $4 = $8;
 __addtf3($11, $1, $2, $3, $10, $5, $9, $7, $4);
 $10 = $11;
 $4 = HEAP32[$10 >> 2];
 $7 = $4;
 $9 = HEAP32[$10 + 4 >> 2];
 $8 = $9;
 $4 = HEAP32[$10 + 12 >> 2];
 $9 = HEAP32[$10 + 8 >> 2];
 $1 = $9;
 $9 = $0;
 HEAP32[$9 + 8 >> 2] = $1;
 HEAP32[$9 + 12 >> 2] = $4;
 HEAP32[$9 >> 2] = $7;
 $4 = $8;
 HEAP32[$9 + 4 >> 2] = $4;
 __stack_pointer = $10 + 16 | 0;
}

function renameTableSelectCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = 1;
 if (!(HEAPU16[$1 + 6 >> 1] & 1056)) {
  $3 = HEAP32[$1 + 32 >> 2];
  if (!$3) {
   return 2;
  }
  $4 = HEAP32[$0 + 24 >> 2];
  $2 = 0;
  while (1) {
   if (HEAP32[$3 >> 2] > ($2 | 0)) {
    $5 = ($2 << 6) + $3 | 0;
    if (HEAP32[$5 + 24 >> 2] == HEAP32[$4 + 12 >> 2]) {
     renameTokenFind(HEAP32[$0 >> 2], $4, HEAP32[$5 + 16 >> 2]);
    }
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  renameWalkWith($0, $1);
  $2 = 0;
 }
 return $2 | 0;
}

function powerFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 if (($1 | 0) == 2) {
  label$2: {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
    if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
     break label$2;
    }
   }
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  $4 = sqlite3_value_double(HEAP32[$2 + 4 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, pow($3, $4));
  return;
 }
 __assert_fail(23018, 17353, 546, 17065);
 abort();
}

function isAlterableTable($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$1 >> 2];
 label$1: {
  label$2: {
   if (!sqlite3_strnicmp($3, 17751, 7)) {
    break label$2;
   }
   $4 = HEAP32[$1 + 28 >> 2];
   if ($4 & 32768) {
    break label$2;
   }
   $1 = 0;
   if (!($4 & 4096)) {
    break label$1;
   }
   if (!sqlite3ReadOnlyShadowTables(HEAP32[$0 >> 2])) {
    break label$1;
   }
  }
  HEAP32[$2 >> 2] = $3;
  sqlite3ErrorMsg($0, 15112, $2);
  $1 = 1;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function saveCursorsOnList($0, $1, $2) {
 var $3 = 0;
 label$1: {
  while (1) {
   label$3: {
    if (($0 | 0) == ($2 | 0) | (HEAP32[$0 + 64 >> 2] != ($1 | 0) ? $1 : 0)) {
     break label$3;
    }
    label$5: {
     switch (HEAPU8[$0 | 0]) {
     case 0:
     case 2:
      $3 = saveCursorPosition($0);
      if (!$3) {
       break label$3;
      }
      break label$1;

     default:
      break label$5;
     }
    }
    btreeReleaseAllCursorPages($0);
   }
   $0 = HEAP32[$0 + 24 >> 2];
   if ($0) {
    continue;
   }
   break;
  }
  $3 = 0;
 }
 return $3;
}

function exprProbability($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = -1074790400;
 $3 = -1;
 label$1: {
  if (HEAPU8[$0 | 0] != 153) {
   break label$1;
  }
  $0 = HEAP32[$0 + 8 >> 2];
  sqlite3AtoF($0, $1 + 8 | 0, sqlite3Strlen30($0), 1);
  $2 = HEAPF64[$1 + 8 >> 3];
  if ($2 > 1) {
   break label$1;
  }
  $2 = $2 * 134217728;
  if (Math_abs($2) < 2147483648) {
   $3 = ~~$2;
   break label$1;
  }
  $3 = -2147483648;
 }
 __stack_pointer = $1 + 16 | 0;
 return $3;
}

function fts3DoclistCountDocids($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $4 = $0 + $1 | 0;
  while (1) {
   if ($0 >>> 0 >= $4 >>> 0) {
    break label$1;
   }
   while (1) {
    $1 = HEAP8[$0 | 0];
    $0 = $0 + 1 | 0;
    if (($1 | 0) < 0) {
     continue;
    }
    break;
   }
   HEAP32[$2 + 12 >> 2] = $0;
   fts3PoslistCopy(0, $2 + 12 | 0);
   $3 = $3 + 1 | 0;
   $0 = HEAP32[$2 + 12 >> 2];
   continue;
  }
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function connectionIsBusy($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $2 = 1;
 label$1: {
  if (HEAP32[$0 + 4 >> 2]) {
   break label$1;
  }
  $2 = 0;
  $1 = HEAP32[$0 + 20 >> 2];
  $4 = ($1 | 0) > 0 ? $1 : 0;
  $1 = 0;
  while (1) {
   if (($1 | 0) == ($4 | 0)) {
    break label$1;
   }
   label$3: {
    $3 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
    if (!$3) {
     break label$3;
    }
    if (!sqlite3BtreeIsInBackup($3)) {
     break label$3;
    }
    $2 = 1;
    break label$1;
   }
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 return $2;
}

function checkRef($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 label$1: {
  if (HEAPU32[$0 + 12 >> 2] <= $1 - 1 >>> 0) {
   HEAP32[$2 + 16 >> 2] = $1;
   checkAppendMsg($0, 16504, $2 + 16 | 0);
   $3 = 1;
   break label$1;
  }
  if (getPageReferenced($0, $1)) {
   HEAP32[$2 >> 2] = $1;
   checkAppendMsg($0, 16549, $2);
   $3 = 1;
   break label$1;
  }
  $3 = 1;
  if (HEAP32[HEAP32[$0 + 68 >> 2] + 296 >> 2]) {
   break label$1;
  }
  setPageReferenced($0, $1);
  $3 = 0;
 }
 __stack_pointer = $2 + 32 | 0;
 return $3;
}

function fts3LcsIteratorAdvance($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 if ($0) {
  $2 = HEAP32[$0 + 8 >> 2];
  $3 = sqlite3Fts3GetVarint($2, $1 + 8 | 0);
  $4 = HEAP32[$1 + 8 >> 2];
  label$3: {
   if (!HEAP32[$1 + 12 >> 2] & $4 >>> 0 < 2) {
    $5 = 1;
    $3 = 0;
    break label$3;
   }
   HEAP32[$0 + 12 >> 2] = ($4 + HEAP32[$0 + 12 >> 2] | 0) - 2;
   $3 = $2 + $3 | 0;
  }
  HEAP32[$0 + 8 >> 2] = $3;
  $0 = $5;
 } else {
  $0 = 1;
 }
 $2 = $0;
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function dotlockLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 24 >> 2];
 if (HEAPU8[$0 + 16 | 0]) {
  HEAP8[$0 + 16 | 0] = $1;
  utimes($2, 0);
  return 0;
 }
 $2 = FUNCTION_TABLE[HEAP32[16291]]($2, 511) | 0;
 label$2: {
  if (($2 | 0) < 0) {
   $2 = 5;
   $1 = HEAP32[__errno_location() >> 2];
   if (($1 | 0) == 20) {
    break label$2;
   }
   $3 = sqliteErrorFromPosixError($1);
   if (($3 | 0) == 5) {
    break label$2;
   }
   storeLastErrno($0, $1);
   return $3 | 0;
  }
  HEAP8[$0 + 16 | 0] = $1;
 }
 return $2 | 0;
}

function sqlite3RootPageMoved($0, $1, $2, $3) {
 var $4 = 0;
 $4 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
 $1 = $4 + 16 | 0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if ($1) {
   $0 = HEAP32[$1 + 8 >> 2];
   if (HEAP32[$0 + 20 >> 2] != ($2 | 0)) {
    continue;
   }
   HEAP32[$0 + 20 >> 2] = $3;
   continue;
  }
  break;
 }
 $1 = $4 + 32 | 0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if ($1) {
   $0 = HEAP32[$1 + 8 >> 2];
   if (HEAP32[$0 + 44 >> 2] != ($2 | 0)) {
    continue;
   }
   HEAP32[$0 + 44 >> 2] = $3;
   continue;
  }
  break;
 }
}

function sqlite3WalkSelect($0, $1) {
 var $2 = 0;
 label$1: {
  if (!(!$1 | !HEAP32[$0 + 8 >> 2])) {
   while (1) {
    $2 = FUNCTION_TABLE[HEAP32[$0 + 8 >> 2]]($0, $1) | 0;
    if ($2) {
     return $2 & 2;
    }
    $2 = 2;
    if (sqlite3WalkSelectExpr($0, $1)) {
     break label$1;
    }
    if (sqlite3WalkSelectFrom($0, $1)) {
     break label$1;
    }
    $2 = HEAP32[$0 + 12 >> 2];
    if ($2) {
     FUNCTION_TABLE[$2 | 0]($0, $1);
    }
    $1 = HEAP32[$1 + 52 >> 2];
    if ($1) {
     continue;
    }
    break;
   }
  }
  $2 = 0;
 }
 return $2;
}

function sqlite3ExprImpliesExpr($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = 1;
 label$1: {
  if (!sqlite3ExprCompare($0, $1, $2, $3)) {
   break label$1;
  }
  $4 = HEAPU8[$2 | 0];
  if (($4 | 0) == 43) {
   if (sqlite3ExprImpliesExpr($0, $1, HEAP32[$2 + 12 >> 2], $3)) {
    break label$1;
   }
   if (sqlite3ExprImpliesExpr($0, $1, HEAP32[$2 + 16 >> 2], $3)) {
    break label$1;
   }
   $4 = HEAPU8[$2 | 0];
  }
  if (($4 | 0) == 51) {
   if (exprImpliesNotNull($0, $1, HEAP32[$2 + 12 >> 2], $3, 0)) {
    break label$1;
   }
  }
  $5 = 0;
 }
 return $5;
}

function sqlite3Checkpoint($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
 $8 = ($1 | 0) == 12;
 while (1) {
  if (!(HEAP32[$0 + 20 >> 2] <= ($6 | 0) | $5)) {
   label$3: {
    if (!$8) {
     $5 = 0;
     if (($1 | 0) != ($6 | 0)) {
      break label$3;
     }
    }
    $5 = sqlite3BtreeCheckpoint(HEAP32[(HEAP32[$0 + 16 >> 2] + ($6 << 4) | 0) + 4 >> 2], $2, $3, $4);
    $3 = 0;
    $4 = ($5 | 0) == 5;
    $5 = $4 ? 0 : $5;
    $7 = $4 ? 1 : $7;
    $4 = 0;
   }
   $6 = $6 + 1 | 0;
   continue;
  }
  break;
 }
 return $5 ? $5 : $7 ? 5 : $5;
}

function renameColumnElistNames($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $6 = HEAP32[$2 >> 2];
  while (1) {
   if (($5 | 0) >= ($6 | 0)) {
    break label$1;
   }
   $4 = ($5 << 4) + $2 | 0;
   label$3: {
    if (HEAPU8[$4 + 17 | 0] & 3) {
     break label$3;
    }
    $4 = HEAP32[$4 + 12 >> 2];
    if (!$4) {
     break label$3;
    }
    if (sqlite3_stricmp($4, $3)) {
     break label$3;
    }
    renameTokenFind($0, $1, $4);
    $6 = HEAP32[$2 >> 2];
   }
   $5 = $5 + 1 | 0;
   continue;
  }
 }
}

function callCollNeeded($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (HEAP32[$0 + 276 >> 2]) {
   $3 = sqlite3DbStrDup($0, $2);
   if (!$3) {
    break label$1;
   }
   FUNCTION_TABLE[HEAP32[$0 + 276 >> 2]](HEAP32[$0 + 284 >> 2], $0, $1, $3);
   sqlite3DbFree($0, $3);
  }
  if (!HEAP32[$0 + 280 >> 2]) {
   break label$1;
  }
  $1 = sqlite3ValueNew($0);
  sqlite3ValueSetStr($1, $2, 1, 0);
  $2 = sqlite3ValueText($1, 2);
  if ($2) {
   FUNCTION_TABLE[HEAP32[$0 + 280 >> 2]](HEAP32[$0 + 284 >> 2], $0, HEAPU8[$0 + 84 | 0], $2);
  }
  sqlite3ValueFree($1);
 }
}

function pcache1EnforceMaxPage($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2];
 while (1) {
  label$2: {
   if (HEAPU32[$1 + 16 >> 2] <= HEAPU32[$1 + 4 >> 2]) {
    break label$2;
   }
   $2 = HEAP32[$1 + 48 >> 2];
   if (HEAPU16[$2 + 14 >> 1]) {
    break label$2;
   }
   pcache1RemoveFromHash(pcache1PinPage($2), 1);
   continue;
  }
  break;
 }
 label$3: {
  if (HEAP32[$0 + 48 >> 2]) {
   break label$3;
  }
  $1 = HEAP32[$0 + 64 >> 2];
  if (!$1) {
   break label$3;
  }
  sqlite3_free($1);
  HEAP32[$0 + 60 >> 2] = 0;
  HEAP32[$0 + 64 >> 2] = 0;
 }
}

function fts3DisconnectMethod($0) {
 $0 = $0 | 0;
 var $1 = 0;
 sqlite3_finalize(HEAP32[$0 + 220 >> 2]);
 while (1) {
  if (($1 | 0) != 40) {
   sqlite3_finalize(HEAP32[(($1 << 2) + $0 | 0) + 60 >> 2]);
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3_free(HEAP32[$0 + 248 >> 2]);
 sqlite3_free(HEAP32[$0 + 224 >> 2]);
 sqlite3_free(HEAP32[$0 + 228 >> 2]);
 sqlite3_free(HEAP32[$0 + 40 >> 2]);
 sqlite3_free(HEAP32[$0 + 44 >> 2]);
 $1 = HEAP32[$0 + 36 >> 2];
 FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 8 >> 2]]($1) | 0;
 sqlite3_free($0);
 return 0;
}

function sqlite3_str_appendchar($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  $3 = $1 >> 31;
  $4 = $1 + HEAP32[$0 + 16 >> 2] | 0;
  $3 = $1 >>> 0 > $4 >>> 0 ? $3 + 1 | 0 : $3;
  if (HEAPU32[$0 + 8 >> 2] <= $4 >>> 0 & ($3 | 0) >= 0 | ($3 | 0) > 0) {
   $1 = sqlite3StrAccumEnlarge($0, $1);
   if (($1 | 0) <= 0) {
    break label$1;
   }
  }
  while (1) {
   if (($1 | 0) <= 0) {
    break label$1;
   }
   $3 = HEAP32[$0 + 16 >> 2];
   HEAP32[$0 + 16 >> 2] = $3 + 1;
   HEAP8[HEAP32[$0 + 4 >> 2] + $3 | 0] = $2;
   $1 = $1 - 1 | 0;
   continue;
  }
 }
}

function fts3SelectDocsize($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 $5 = fts3SqlStmt($0, 21, $4 + 12 | 0, 0);
 $0 = HEAP32[$4 + 12 >> 2];
 label$1: {
  if ($5) {
   break label$1;
  }
  sqlite3_bind_int64($0, 1, $1, $2);
  if ((sqlite3_step($0) | 0) == 100) {
   $5 = 0;
   if ((sqlite3_column_type($0, 0) | 0) == 4) {
    break label$1;
   }
  }
  $0 = sqlite3_reset($0);
  $5 = $0 ? $0 : 267;
  $0 = 0;
 }
 HEAP32[$3 >> 2] = $0;
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function createFunctionApi($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
 var $11 = 0;
 label$1: {
  if ($10) {
   $11 = sqlite3Malloc(12, 0);
   if (!$11) {
    sqlite3OomFault($0);
    FUNCTION_TABLE[$10 | 0]($4);
    $9 = 1;
    break label$1;
   }
   HEAP32[$11 + 8 >> 2] = $4;
   HEAP32[$11 + 4 >> 2] = $10;
   HEAP32[$11 >> 2] = 0;
  }
  $9 = sqlite3CreateFunc($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $11);
  if (HEAP32[$11 >> 2] | !$11) {
   break label$1;
  }
  FUNCTION_TABLE[$10 | 0]($4);
  sqlite3_free($11);
 }
 return sqlite3ApiExit($0, $9);
}

function sqlite3AuthCheck($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $6 = HEAP32[$0 >> 2];
 $7 = HEAP32[$6 + 360 >> 2];
 label$1: {
  if (HEAPU8[$0 + 208 | 0] | (!$7 | HEAPU8[$6 + 177 | 0])) {
   break label$1;
  }
  $5 = FUNCTION_TABLE[$7 | 0](HEAP32[$6 + 364 >> 2], $1, $2, $3, $4, HEAP32[$0 + 248 >> 2]) | 0;
  label$2: {
   if (($5 | 0) == 1) {
    sqlite3ErrorMsg($0, 14577, 0);
    HEAP32[$0 + 12 >> 2] = 23;
    break label$2;
   }
   if (!($5 & -3)) {
    break label$1;
   }
   sqliteAuthBadReturnCode($0);
  }
  $5 = 1;
 }
 return $5;
}

function whereIndexExprTransColumn($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $0 = HEAP32[$0 + 24 >> 2];
  if (HEAP32[$1 + 28 >> 2] != HEAP32[$0 + 4 >> 2] | HEAP32[$0 + 16 >> 2] != HEAP16[$1 + 32 >> 1]) {
   break label$1;
  }
  preserveExpr($0, $1);
  HEAP8[$1 + 1 | 0] = sqlite3TableColumnAffinity(HEAP32[$1 + 44 >> 2], HEAP16[$1 + 32 >> 1]);
  HEAP32[$1 + 28 >> 2] = HEAP32[$0 + 8 >> 2];
  $0 = HEAP32[$0 + 12 >> 2];
  HEAP32[$1 + 44 >> 2] = 0;
  HEAP16[$1 + 32 >> 1] = $0;
 }
 return 0;
}

function unixNextSystemCall($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $0 = -1;
 label$1: {
  if (!$1) {
   break label$1;
  }
  while (1) {
   $0 = 28;
   if (($2 | 0) == 28) {
    break label$1;
   }
   if (strcmp($1, HEAP32[Math_imul($2, 12) + 64944 >> 2])) {
    $2 = $2 + 1 | 0;
    continue;
   } else {
    $0 = $2;
   }
   break;
  }
 }
 while (1) {
  if (($0 | 0) == 28) {
   return 0;
  }
  $0 = $0 + 1 | 0;
  if (!HEAP32[Math_imul($0, 12) + 64948 >> 2]) {
   continue;
  }
  break;
 }
 return HEAP32[Math_imul($0, 12) + 64944 >> 2];
}

function sqlite3Fts3GetVarint32($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP8[$0 + 1 | 0];
 $3 = HEAPU8[$0 | 0] & 127 | ($2 & 255) << 7;
 $4 = 2;
 label$1: {
  if (($2 | 0) >= 0) {
   break label$1;
  }
  $2 = HEAP8[$0 + 2 | 0];
  $3 = $3 & 16383 | ($2 & 255) << 14;
  $4 = 3;
  if (($2 | 0) >= 0) {
   break label$1;
  }
  $2 = HEAP8[$0 + 3 | 0];
  $3 = $3 & 2097151 | ($2 & 255) << 21;
  $4 = 4;
  if (($2 | 0) >= 0) {
   break label$1;
  }
  $3 = $3 & 268435455 | (HEAPU8[$0 + 4 | 0] & 7) << 28;
  $4 = 5;
 }
 HEAP32[$1 >> 2] = $3;
 return $4;
}

function vdbeSorterSetupMerge($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 label$1: {
  label$2: {
   $2 = vdbeSorterMergeTreeBuild($0, $1 + 12 | 0);
   if ($2) {
    $4 = HEAP32[$1 + 12 >> 2];
    break label$2;
   }
   $3 = HEAP32[$1 + 12 >> 2];
   $2 = vdbeMergeEngineInit($0 - -64 | 0, $3);
   HEAP32[$0 + 20 >> 2] = $3;
   if ($2) {
    break label$2;
   }
   $2 = 0;
   break label$1;
  }
  vdbeMergeEngineFree($4);
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function sqlite3TableColumnToStorage($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (!(HEAP32[$0 + 28 >> 2] & 32) | ($1 | 0) < 0) {
   break label$1;
  }
  $4 = HEAP32[$0 + 4 >> 2];
  while (1) {
   if (($1 | 0) != ($2 | 0)) {
    $3 = ((HEAPU16[(Math_imul($2, 12) + $4 | 0) + 10 >> 1] ^ -1) >>> 5 & 1) + $3 | 0;
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  if (!(HEAPU8[(Math_imul($1, 12) + $4 | 0) + 10 | 0] & 32)) {
   $1 = $3;
   break label$1;
  }
  $1 = HEAPU16[$0 + 36 >> 1] + ($1 - $3 | 0) | 0;
 }
 return $1 << 16 >> 16;
}

function sqlite3BtreeSavepoint($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (!$0 | HEAPU8[$0 + 8 | 0] != 2) {
   break label$1;
  }
  $3 = HEAP32[$0 + 4 >> 2];
  sqlite3BtreeEnter($0);
  if (($1 | 0) == 2) {
   $4 = saveAllCursors($3, 0, 0);
   if ($4) {
    break label$1;
   }
  }
  $4 = sqlite3PagerSavepoint(HEAP32[$3 >> 2], $1, $2);
  if ($4) {
   break label$1;
  }
  if (!(!(HEAPU8[$3 + 24 | 0] & 16) | ($2 | 0) >= 0)) {
   HEAP32[$3 + 48 >> 2] = 0;
  }
  $4 = newDatabase($3);
  btreeSetNPage($3, HEAP32[$3 + 12 >> 2]);
 }
 return $4;
}

function fts3DeleteSegment($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (!(HEAP32[$1 + 8 >> 2] | HEAP32[$1 + 12 >> 2])) {
   $0 = 0;
   break label$1;
  }
  $0 = fts3SqlStmt($0, 17, $2 + 12 | 0, 0);
  if ($0) {
   break label$1;
  }
  $0 = HEAP32[$2 + 12 >> 2];
  sqlite3_bind_int64($0, 1, HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
  sqlite3_bind_int64($0, 2, HEAP32[$1 + 24 >> 2], HEAP32[$1 + 28 >> 2]);
  sqlite3_step($0);
  $0 = sqlite3_reset($0);
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function sqlite3Fts3SelectDoctotal($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 $3 = fts3SqlStmt($0, 22, $2 + 12 | 0, 0);
 $0 = HEAP32[$2 + 12 >> 2];
 label$1: {
  if ($3) {
   break label$1;
  }
  sqlite3_bind_int($0, 1, 0);
  if ((sqlite3_step($0) | 0) == 100) {
   $3 = 0;
   if ((sqlite3_column_type($0, 0) | 0) == 4) {
    break label$1;
   }
  }
  $0 = sqlite3_reset($0);
  $3 = $0 ? $0 : 267;
  $0 = 0;
 }
 HEAP32[$1 >> 2] = $0;
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function renameColumnParseError($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $2 = sqlite3_value_text($2);
 $3 = sqlite3_value_text($3);
 $6 = HEAP32[$4 >> 2];
 $7 = HEAPU8[$1 | 0];
 HEAP32[$5 + 16 >> 2] = HEAP32[$4 + 4 >> 2];
 HEAP32[$5 + 12 >> 2] = $1;
 HEAP32[$5 + 4 >> 2] = $3;
 HEAP32[$5 >> 2] = $2;
 HEAP32[$5 + 8 >> 2] = $7 ? 29598 : 29623;
 $1 = sqlite3MPrintf($6, 7209, $5);
 sqlite3_result_error($0, $1, -1);
 sqlite3DbFree(HEAP32[$4 >> 2], $1);
 __stack_pointer = $5 + 32 | 0;
}

function stem($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = HEAP32[$0 >> 2];
 while (1) {
  $5 = HEAPU8[$1 | 0];
  if ($5) {
   if (HEAPU8[$4 | 0] != ($5 | 0)) {
    return 0;
   } else {
    $1 = $1 + 1 | 0;
    $4 = $4 + 1 | 0;
    continue;
   }
  }
  break;
 }
 label$5: {
  if ($3) {
   if (!(FUNCTION_TABLE[$3 | 0]($4) | 0)) {
    break label$5;
   }
  }
  while (1) {
   $1 = HEAPU8[$2 | 0];
   if ($1) {
    $4 = $4 - 1 | 0;
    HEAP8[$4 | 0] = $1;
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$0 >> 2] = $4;
 }
 return 1;
}

function sqlite3PCacheBufferSetup($0, $1, $2) {
 var $3 = 0;
 if (HEAP32[17732]) {
  $2 = $0 ? $2 : 0;
  HEAP32[17742] = $2;
  HEAP32[17736] = $2;
  $3 = $0 ? $2 ? $1 & -8 : 0 : 0;
  HEAP32[17735] = $3;
  HEAP32[17738] = $0;
  $1 = ($2 | 0) <= 90 ? (($2 | 0) / 10 | 0) + 1 | 0 : 10;
  HEAP32[17737] = $1;
  HEAP32[17743] = 0;
  HEAP32[17741] = 0;
  $1 = 0;
  while (1) {
   if ($2) {
    HEAP32[$0 >> 2] = $1;
    HEAP32[17741] = $0;
    $2 = $2 - 1 | 0;
    $1 = $0;
    $0 = $0 + $3 | 0;
    continue;
   }
   break;
  }
  HEAP32[17739] = $0;
 }
}

function sqlite3_hard_heap_limit64($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = -1;
 $4 = -1;
 label$1: {
  if (sqlite3_initialize()) {
   break label$1;
  }
  $3 = HEAP32[17620];
  $4 = HEAP32[17621];
  if (($1 | 0) < 0) {
   break label$1;
  }
  HEAP32[17620] = $0;
  HEAP32[17621] = $1;
  $2 = HEAP32[17619];
  $5 = HEAP32[17618];
  if ((($2 | 0) <= ($1 | 0) & $0 >>> 0 >= $5 >>> 0 | ($1 | 0) > ($2 | 0)) & ($2 | $5) != 0) {
   break label$1;
  }
  HEAP32[17618] = $0;
  HEAP32[17619] = $1;
 }
 i64toi32_i32$HIGH_BITS = $4;
 return $3;
}

function sqlite3DequoteToken($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  $2 = HEAP32[$0 + 4 >> 2];
  if ($2 >>> 0 < 2) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  if (HEAP8[HEAPU8[$3 | 0] + 30288 | 0] >= 0) {
   break label$1;
  }
  $4 = $2 - 1 | 0;
  $1 = 1;
  while (1) {
   if (($1 | 0) != ($4 | 0)) {
    $5 = $1 + $3 | 0;
    $1 = $1 + 1 | 0;
    if (HEAP8[HEAPU8[$5 | 0] + 30288 | 0] >= 0) {
     continue;
    }
    break label$1;
   }
   break;
  }
  HEAP32[$0 >> 2] = $3 + 1;
  HEAP32[$0 + 4 >> 2] = $2 - 2;
 }
}

function sqlite3VdbeReset($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2];
 if (HEAPU8[$0 + 149 | 0] == 2) {
  sqlite3VdbeHalt($0);
 }
 label$2: {
  if (HEAP32[$0 + 32 >> 2] < 0) {
   break label$2;
  }
  if (HEAP32[$0 + 124 >> 2] ? 1 : HEAP32[$1 + 288 >> 2]) {
   sqlite3VdbeTransferError($0);
   break label$2;
  }
  HEAP32[$1 + 64 >> 2] = HEAP32[$0 + 36 >> 2];
 }
 $2 = HEAP32[$0 + 124 >> 2];
 if ($2) {
  sqlite3DbFree($1, $2);
  HEAP32[$0 + 124 >> 2] = 0;
 }
 HEAP32[$0 + 120 >> 2] = 0;
 return HEAP32[$1 + 72 >> 2] & HEAP32[$0 + 36 >> 2];
}

function growVTrans($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 380 >> 2];
 if (!(($2 | 0) % 5 | 0)) {
  $1 = $2 >> 31;
  $3 = $1 << 2 | $2 >>> 30;
  $1 = $2 << 2;
  $1 = $1 + 20 | 0;
  $3 = $1 >>> 0 < 20 ? $3 + 1 | 0 : $3;
  $2 = sqlite3DbRealloc($0, HEAP32[$0 + 404 >> 2], $1, $3);
  if (!$2) {
   return 7;
  }
  $1 = (HEAP32[$0 + 380 >> 2] << 2) + $2 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 + 16 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$0 + 404 >> 2] = $2;
 }
 return 0;
}

function sqlite3ExprCheckIN($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = HEAP32[$1 + 12 >> 2];
 $3 = sqlite3ExprVectorSize($4);
 label$1: {
  label$2: {
   if (!(HEAPU8[HEAP32[$0 >> 2] + 87 | 0] | !(HEAPU8[$1 + 5 | 0] & 16))) {
    $1 = HEAP32[HEAP32[HEAP32[$1 + 20 >> 2] + 28 >> 2] >> 2];
    $2 = 0;
    if (($3 | 0) == ($1 | 0)) {
     break label$1;
    }
    sqlite3SubselectError($0, $1, $3);
    break label$2;
   }
   $2 = 0;
   if (($3 | 0) == 1) {
    break label$1;
   }
   sqlite3VectorErrorMsg($0, $4);
  }
  $2 = 1;
 }
 return $2;
}

function sqlite3FkActions($0, $1, $2, $3, $4, $5) {
 var $6 = 0, $7 = 0;
 label$1: {
  if (!(HEAPU8[HEAP32[$0 >> 2] + 33 | 0] & 64)) {
   break label$1;
  }
  $6 = sqlite3FkReferences($1);
  while (1) {
   if (!$6) {
    break label$1;
   }
   label$3: {
    if ($4) {
     if (!fkParentIsModified($1, $6, $4, $5)) {
      break label$3;
     }
    }
    $7 = fkActionTrigger($0, $1, $6, $2);
    if (!$7) {
     break label$3;
    }
    sqlite3CodeRowTriggerDirect($0, $7, $1, $3, 2, 0);
   }
   $6 = HEAP32[$6 + 12 >> 2];
   continue;
  }
 }
}

function numberOfCachePages($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAP32[$0 + 16 >> 2];
 if (($1 | 0) < 0) {
  $2 = $1;
  $4 = $2 << 10;
  $1 = $2 >> 31;
  $2 = $1 << 10 | $2 >>> 22;
  $3 = $2 + (($4 | 0) != 0) | 0;
  $3 = 0 - $3 | 0;
  $2 = $3;
  $1 = HEAP32[$0 + 28 >> 2] + HEAP32[$0 + 24 >> 2] | 0;
  $3 = $1 >> 31;
  $0 = $3;
  $3 = $2;
  $2 = $1;
  $1 = $0;
  $1 = __wasm_i64_sdiv(0 - $4 | 0, $3, $2, $1);
  $3 = i64toi32_i32$HIGH_BITS;
  $2 = $1 >>> 0 < 1e9 & ($3 | 0) <= 0 | ($3 | 0) < 0;
  $1 = $2 ? $1 : 1e9;
 }
 return $1;
}

function sqlite3SrcListIndexedBy($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $3 = HEAP32[$2 + 4 >> 2];
  if (!$3) {
   break label$1;
  }
  $4 = HEAP32[$1 >> 2] - 1 | 0;
  $5 = 1;
  if (!(HEAP32[$2 >> 2] ? 0 : ($3 | 0) == 1)) {
   HEAP32[(($4 << 6) + $1 | 0) - -64 >> 2] = sqlite3NameFromToken(HEAP32[$0 >> 2], $2);
   $5 = 2;
  }
  $0 = ($4 << 6) + $1 | 0;
  $1 = $0 + 45 | 0;
  $0 = HEAPU8[$0 + 45 | 0] | HEAPU8[$0 + 46 | 0] << 8 | $5;
  HEAP8[$1 | 0] = $0;
  HEAP8[$1 + 1 | 0] = $0 >>> 8;
 }
}

function sqlite3NotPureFunc($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $1 = 1;
 $3 = HEAP32[HEAP32[$0 + 12 >> 2] + 104 >> 2] + Math_imul(HEAP32[$0 + 16 >> 2], 20) | 0;
 if (HEAPU8[$3 | 0] == 65) {
  $1 = HEAPU16[$3 + 2 >> 1];
  HEAP32[$2 >> 2] = HEAP32[HEAP32[$0 + 4 >> 2] + 32 >> 2];
  HEAP32[$2 + 4 >> 2] = $1 & 4 ? 2486 : $1 & 8 ? 10582 : 1510;
  $1 = sqlite3_mprintf(6261, $2);
  sqlite3_result_error($0, $1, -1);
  sqlite3_free($1);
  $1 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function btreeMoveto($0, $1, $2, $3, $4, $5) {
 if ($1) {
  $3 = HEAP32[$0 + 112 >> 2];
  $4 = sqlite3VdbeAllocUnpackedRecord($3);
  if (!$4) {
   return 7;
  }
  sqlite3VdbeRecordUnpack($3, $2, $1, $4);
  $1 = HEAPU16[$4 + 20 >> 1];
  label$3: {
   if (!(HEAPU16[$3 + 8 >> 1] >= $1 >>> 0 ? $1 : 0)) {
    $1 = sqlite3CorruptError(67681);
    break label$3;
   }
   $1 = sqlite3BtreeIndexMoveto($0, $4, $5);
  }
  sqlite3DbFree(HEAP32[HEAP32[$0 + 112 >> 2] + 12 >> 2], $4);
  return $1;
 }
 return sqlite3BtreeTableMoveto($0, $2, $3, $4, $5);
}

function unixAccess($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $0 = __stack_pointer - 112 | 0;
 __stack_pointer = $0;
 label$1: {
  if (!$2) {
   $2 = 0;
   if (!(FUNCTION_TABLE[HEAP32[16249]]($1, $0) | 0)) {
    $1 = HEAP32[$0 + 44 >> 2];
    $2 = !!HEAP32[$0 + 40 >> 2] & ($1 | 0) >= 0 | ($1 | 0) > 0 | (HEAP32[$0 + 12 >> 2] & 61440) != 32768;
   }
   HEAP32[$3 >> 2] = $2;
   break label$1;
  }
  HEAP32[$3 >> 2] = !(FUNCTION_TABLE[HEAP32[16243]]($1, 6) | 0);
 }
 __stack_pointer = $0 + 112 | 0;
 return 0;
}

function fts3HashInsertElement($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$1 + 4 >> 2];
 label$1: {
  if ($3) {
   HEAP32[$2 >> 2] = $3;
   HEAP32[$2 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
   $4 = HEAP32[$3 + 4 >> 2];
   HEAP32[($4 ? $4 : $0 + 8 | 0) >> 2] = $2;
   $3 = $3 + 4 | 0;
   break label$1;
  }
  $3 = HEAP32[$0 + 8 >> 2];
  HEAP32[$2 >> 2] = $3;
  if ($3) {
   HEAP32[$3 + 4 >> 2] = $2;
  }
  HEAP32[$2 + 4 >> 2] = 0;
  $3 = $0 + 8 | 0;
 }
 HEAP32[$3 >> 2] = $2;
 HEAP32[$1 + 4 >> 2] = $2;
 HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
}

function sqlite3Close($0, $1) {
 if ($0) {
  if (!sqlite3SafetyCheckSickOrOk($0)) {
   return sqlite3MisuseError(171876);
  }
  if (HEAPU8[$0 + 94 | 0] & 8) {
   FUNCTION_TABLE[HEAP32[$0 + 212 >> 2]](8, HEAP32[$0 + 216 >> 2], $0, 0) | 0;
  }
  disconnectAllVtab($0);
  sqlite3VtabRollback($0);
  label$4: {
   if ($1) {
    break label$4;
   }
   if (!connectionIsBusy($0)) {
    break label$4;
   }
   sqlite3ErrorWithMsg($0, 5, 4481, 0);
   return 5;
  }
  HEAP8[$0 + 97 | 0] = 167;
  sqlite3LeaveMutexAndCloseZombie($0);
 }
 return 0;
}

function pager_incr_changecounter($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 if (!(HEAPU8[$0 + 19 | 0] | !HEAP32[$0 + 28 >> 2])) {
  $2 = sqlite3PagerGet($0, 1, $1 + 12 | 0, 0);
  label$2: {
   if ($2) {
    break label$2;
   }
   $2 = sqlite3PagerWrite(HEAP32[$1 + 12 >> 2]);
   if ($2) {
    break label$2;
   }
   pager_write_changecounter(HEAP32[$1 + 12 >> 2]);
   HEAP8[$0 + 19 | 0] = 1;
   $2 = 0;
  }
  sqlite3PagerUnref(HEAP32[$1 + 12 >> 2]);
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function windowReadPeerValues($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 label$1: {
  $3 = HEAP32[$0 + 4 >> 2];
  $4 = HEAP32[$3 + 12 >> 2];
  if (!$4) {
   break label$1;
  }
  $5 = sqlite3GetVdbe(HEAP32[$0 >> 2]);
  $0 = 0;
  $6 = HEAP32[$3 + 76 >> 2];
  $3 = HEAP32[$3 + 8 >> 2];
  if ($3) {
   $7 = HEAP32[$3 >> 2];
  }
  $3 = $6 + $7 | 0;
  while (1) {
   if (HEAP32[$4 >> 2] <= ($0 | 0)) {
    break label$1;
   }
   sqlite3VdbeAddOp3($5, 94, $1, $0 + $3 | 0, $0 + $2 | 0);
   $0 = $0 + 1 | 0;
   continue;
  }
 }
}

function pcache1Alloc($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (HEAP32[17735] < ($0 | 0)) {
   break label$1;
  }
  $1 = HEAP32[17741];
  if (!$1) {
   break label$1;
  }
  HEAP32[17741] = HEAP32[$1 >> 2];
  $2 = HEAP32[17742];
  HEAP32[17742] = $2 - 1;
  HEAP32[17743] = HEAP32[17737] >= ($2 | 0);
  sqlite3StatusHighwater(7, $0);
  sqlite3StatusUp(1, 1);
  return $1;
 }
 $1 = sqlite3Malloc($0, $0 >> 31);
 if ($1) {
  $2 = sqlite3MallocSize($1);
  sqlite3StatusHighwater(7, $0);
  sqlite3StatusUp(2, $2);
  $2 = $1;
 }
 return $2;
}

function sqlite3WhereMinMaxOptEarlyOut($0, $1) {
 var $2 = 0;
 if (!(!(HEAPU8[$1 + 52 | 0] & 4) | !HEAPU8[$1 + 49 | 0])) {
  $2 = HEAPU8[$1 + 48 | 0];
  label$2: {
   label$3: {
    while (1) {
     if (($2 | 0) <= 0) {
      break label$3;
     }
     $2 = $2 - 1 | 0;
     if (!(HEAPU8[HEAP32[(Math_imul($2, 96) + $1 | 0) + 848 >> 2] + 40 | 0] & 4)) {
      continue;
     }
     break;
    }
    $2 = (Math_imul($2, 96) + $1 | 0) + 784 | 0;
    break label$2;
   }
   $2 = $1 + 36 | 0;
  }
  sqlite3VdbeGoto($0, HEAP32[$2 >> 2]);
 }
}

function unixFileSize($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 label$1: {
  if (FUNCTION_TABLE[HEAP32[16252]](HEAP32[$0 + 12 >> 2], $2) | 0) {
   storeLastErrno($0, HEAP32[__errno_location() >> 2]);
   $5 = 1802;
   break label$1;
  }
  $0 = HEAP32[$2 + 40 >> 2];
  $3 = HEAP32[$2 + 44 >> 2];
  $4 = !$3 & ($0 | 0) == 1;
  HEAP32[$1 >> 2] = $4 ? 0 : $0;
  HEAP32[$1 + 4 >> 2] = $4 ? 0 : $3;
 }
 __stack_pointer = $2 + 112 | 0;
 return $5 | 0;
}

function strncmp($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 if (!$2) {
  return 0;
 }
 $3 = HEAPU8[$0 | 0];
 label$2: {
  if (!$3) {
   break label$2;
  }
  while (1) {
   label$4: {
    $4 = HEAPU8[$1 | 0];
    if (!$4) {
     break label$4;
    }
    $2 = $2 - 1 | 0;
    if (!$2 | ($3 | 0) != ($4 | 0)) {
     break label$4;
    }
    $1 = $1 + 1 | 0;
    $3 = HEAPU8[$0 + 1 | 0];
    $0 = $0 + 1 | 0;
    if ($3) {
     continue;
    }
    break label$2;
   }
   break;
  }
  $5 = $3;
 }
 return ($5 & 255) - HEAPU8[$1 | 0] | 0;
}

function fts3FindElementByHash($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  $4 = HEAP32[$0 + 16 >> 2];
  if (!$4) {
   break label$1;
  }
  $4 = ($3 << 3) + $4 | 0;
  $3 = $4 + 4 | 0;
  $4 = HEAP32[$4 >> 2];
  $0 = ftsCompareFunction(HEAP8[$0 | 0]);
  while (1) {
   if (!$4) {
    break label$1;
   }
   $3 = HEAP32[$3 >> 2];
   if (!$3) {
    break label$1;
   }
   $4 = $4 - 1 | 0;
   if (FUNCTION_TABLE[$0 | 0](HEAP32[$3 + 12 >> 2], HEAP32[$3 + 16 >> 2], $1, $2) | 0) {
    continue;
   }
   break;
  }
  return $3;
 }
 return 0;
}

function applyAffinity($0, $1, $2) {
 label$1: {
  if (($1 | 0) >= 67) {
   $1 = HEAPU16[$0 + 16 >> 1];
   if ($1 & 4) {
    break label$1;
   }
   if (!($1 & 8)) {
    if (!($1 & 2)) {
     break label$1;
    }
    applyNumericAffinity($0, 1);
    return;
   }
   sqlite3VdbeIntegerAffinity($0);
   return;
  }
  if (($1 | 0) != 66) {
   break label$1;
  }
  $1 = HEAPU16[$0 + 16 >> 1];
  if (!($1 & 2 | !($1 & 44))) {
   sqlite3VdbeMemStringify($0, $2, 1);
   $1 = HEAPU16[$0 + 16 >> 1];
  }
  HEAP16[$0 + 16 >> 1] = $1 & 65491;
 }
}

function sqlite3ErrorWithMsg($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$0 + 64 >> 2] = $1;
 sqlite3SystemError($0, $1);
 label$1: {
  if (!$2) {
   sqlite3Error($0, $1);
   break label$1;
  }
  if (!HEAP32[$0 + 288 >> 2]) {
   $1 = sqlite3ValueNew($0);
   HEAP32[$0 + 288 >> 2] = $1;
   if (!$1) {
    break label$1;
   }
  }
  HEAP32[$4 + 12 >> 2] = $3;
  $1 = sqlite3VMPrintf($0, $2, $3);
  sqlite3ValueSetStr(HEAP32[$0 + 288 >> 2], $1, 1, 1);
 }
 __stack_pointer = $4 + 16 | 0;
}

function whereIndexExprTransNode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $0 = HEAP32[$0 + 24 >> 2];
 if (!sqlite3ExprCompare(0, $1, HEAP32[$0 >> 2], HEAP32[$0 + 4 >> 2])) {
  $1 = sqlite3ExprSkipCollate($1);
  preserveExpr($0, $1);
  $2 = sqlite3ExprAffinity($1);
  HEAP8[$1 | 0] = 167;
  HEAP8[$1 + 1 | 0] = $2;
  HEAP32[$1 + 28 >> 2] = HEAP32[$0 + 8 >> 2];
  HEAP16[$1 + 32 >> 1] = HEAP32[$0 + 12 >> 2];
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -50864129;
  HEAP32[$1 + 44 >> 2] = 0;
  $2 = 1;
 }
 return $2 | 0;
}

function sqlite3FixInit($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP32[$1 >> 2];
 HEAP32[$0 >> 2] = $1;
 $5 = HEAP32[$5 + 16 >> 2] + ($2 << 4) | 0;
 HEAP32[$0 + 40 >> 2] = HEAP32[$5 >> 2];
 $5 = HEAP32[$5 + 12 >> 2];
 HEAP32[$0 + 48 >> 2] = $4;
 HEAP32[$0 + 44 >> 2] = $3;
 HEAP32[$0 + 32 >> 2] = $5;
 HEAP8[$0 + 36 | 0] = ($2 | 0) == 1;
 HEAP32[$0 + 28 >> 2] = $0;
 HEAP16[$0 + 24 >> 1] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 39;
 HEAP32[$0 + 12 >> 2] = 40;
 HEAP32[$0 + 8 >> 2] = 41;
 HEAP32[$0 + 4 >> 2] = $1;
}

function sqlite3DbRealloc($0, $1, $2, $3) {
 if (!$1) {
  return sqlite3DbMallocRawNN($0, $2, $3);
 }
 label$2: {
  label$3: {
   if (HEAPU32[$0 + 356 >> 2] <= $1 >>> 0) {
    break label$3;
   }
   if (HEAPU32[$0 + 348 >> 2] <= $1 >>> 0) {
    if (!$3 & $2 >>> 0 >= 129 | $3) {
     break label$3;
    }
    break label$2;
   }
   if (HEAPU32[$0 + 352 >> 2] > $1 >>> 0) {
    break label$3;
   }
   if (!$3 & HEAPU16[$0 + 310 >> 1] >= $2 >>> 0) {
    break label$2;
   }
  }
  $1 = dbReallocFinish($0, $1, $2, $3);
 }
 return $1;
}

function sqlite3VdbeMemAggValue($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 16 >> 2] = 0;
 sqlite3VdbeMemSetNull($1);
 HEAP32[$3 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = $0;
 HEAP8[$3 + 24 | 0] = HEAPU8[HEAP32[$0 + 20 >> 2] + 84 | 0];
 FUNCTION_TABLE[HEAP32[$2 + 24 >> 2]]($3);
 __stack_pointer = $3 + 32 | 0;
 $1 = HEAP32[$3 + 20 >> 2];
 return $1;
}

function btreeEndTransaction($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAP32[$0 >> 2];
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP8[$1 + 19 | 0] = 0;
 label$1: {
  if (!HEAPU8[$0 + 8 | 0]) {
   break label$1;
  }
  if (HEAP32[$2 + 188 >> 2] >= 2) {
   downgradeAllSharedCacheTableLocks($0);
   HEAP8[$0 + 8 | 0] = 1;
   return;
  }
  clearAllSharedCacheTableLocks($0);
  $2 = HEAP32[$1 + 44 >> 2] - 1 | 0;
  HEAP32[$1 + 44 >> 2] = $2;
  if ($2) {
   break label$1;
  }
  HEAP8[$1 + 20 | 0] = 0;
 }
 HEAP8[$0 + 8 | 0] = 0;
 unlockBtreeIfUnused($1);
}

function releaseAllSavepoints($0) {
 var $1 = 0;
 while (1) {
  if (($1 | 0) < HEAP32[$0 + 104 >> 2]) {
   sqlite3BitvecDestroy(HEAP32[(HEAP32[$0 + 100 >> 2] + Math_imul($1, 48) | 0) + 16 >> 2]);
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 $1 = HEAP32[$0 + 72 >> 2];
 label$3: {
  if (HEAPU8[$0 + 4 | 0]) {
   if (!sqlite3JournalIsInMemory($1)) {
    break label$3;
   }
  }
  sqlite3OsClose($1);
 }
 sqlite3_free(HEAP32[$0 + 100 >> 2]);
 HEAP32[$0 + 56 >> 2] = 0;
 HEAP32[$0 + 100 >> 2] = 0;
 HEAP32[$0 + 104 >> 2] = 0;
}

function analyzeDatabase($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[(HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
 sqlite3BeginWriteOperation($0, 0, $1);
 $3 = HEAP32[$0 + 40 >> 2];
 HEAP32[$0 + 40 >> 2] = $3 + 3;
 openStatTable($0, $1, $3, 0, 0);
 $2 = $2 + 16 | 0;
 $4 = HEAP32[$0 + 44 >> 2] + 1 | 0;
 $5 = HEAP32[$0 + 40 >> 2];
 while (1) {
  $2 = HEAP32[$2 >> 2];
  if ($2) {
   analyzeOneTable($0, HEAP32[$2 + 8 >> 2], 0, $3, $4, $5);
   continue;
  }
  break;
 }
 loadAnalysis($0, $1);
}

function quoteFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 $3 = sqlite3_context_db_handle($0);
 sqlite3StrAccumInit($1 + 8 | 0, $3, 0, 0, HEAP32[$3 + 120 >> 2]);
 sqlite3QuoteValue($1 + 8 | 0, HEAP32[$2 >> 2]);
 sqlite3_result_text($0, sqlite3StrAccumFinish($1 + 8 | 0), HEAP32[$1 + 24 >> 2], 1);
 if (HEAPU8[$1 + 28 | 0]) {
  sqlite3_result_null($0);
  sqlite3_result_error_code($0, HEAPU8[$1 + 28 | 0]);
 }
 __stack_pointer = $1 + 32 | 0;
}

function pcache1Cachesize($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 if (HEAP32[$0 + 20 >> 2]) {
  $2 = HEAP32[$0 + 28 >> 2];
  $3 = HEAP32[$0 >> 2];
  $4 = HEAP32[$3 + 4 >> 2];
  $5 = ($2 - $4 | 0) + 2147418112 | 0;
  $1 = $1 >>> 0 > $5 >>> 0 ? $5 : $1;
  $2 = ($1 - $2 | 0) + $4 | 0;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = ($2 - HEAP32[$3 + 8 >> 2] | 0) + 10;
  HEAP32[$0 + 32 >> 2] = (Math_imul($1, 9) >>> 0) / 10;
  HEAP32[$0 + 28 >> 2] = $1;
  pcache1EnforceMaxPage($0);
 }
}

function isDupColumn($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = ($1 | 0) > 0 ? $1 : 0;
 $5 = HEAPU16[HEAP32[$2 + 4 >> 2] + ($3 << 1) >> 1];
 $1 = 0;
 while (1) {
  label$2: {
   if (($1 | 0) != ($4 | 0)) {
    if (HEAPU16[HEAP32[$0 + 4 >> 2] + ($1 << 1) >> 1] != ($5 | 0)) {
     break label$2;
    }
    if (sqlite3StrICmp(HEAP32[HEAP32[$0 + 32 >> 2] + ($1 << 2) >> 2], HEAP32[HEAP32[$2 + 32 >> 2] + ($3 << 2) >> 2])) {
     break label$2;
    }
    $6 = 1;
   }
   return $6;
  }
  $1 = $1 + 1 | 0;
  continue;
 }
}

function sqlite3VdbeFrameDelete($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $2 = $0 + 88 | 0;
 $4 = $2 + Math_imul(HEAP32[$0 + 60 >> 2], 40) | 0;
 while (1) {
  if (HEAP32[$0 + 64 >> 2] > ($1 | 0)) {
   $3 = HEAP32[($1 << 2) + $4 >> 2];
   if ($3) {
    sqlite3VdbeFreeCursorNN(HEAP32[$0 >> 2], $3);
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 releaseMemArray($2, HEAP32[$0 + 60 >> 2]);
 sqlite3VdbeDeleteAuxData(HEAP32[HEAP32[$0 >> 2] >> 2], $0 + 40 | 0, -1, 0);
 sqlite3DbFree(HEAP32[HEAP32[$0 >> 2] >> 2], $0);
}

function sqlite3BtreeNext($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 HEAP16[$0 + 50 >> 1] = 0;
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 249;
 label$1: {
  if (HEAPU8[$0 | 0]) {
   break label$1;
  }
  $1 = HEAPU16[$0 + 70 >> 1];
  $2 = $1 + 1 | 0;
  HEAP16[$0 + 70 >> 1] = $2;
  $3 = $2 & 65535;
  $2 = HEAP32[$0 + 116 >> 2];
  if ($3 >>> 0 >= HEAPU16[$2 + 24 >> 1]) {
   HEAP16[$0 + 70 >> 1] = $1;
   break label$1;
  }
  $1 = 0;
  if (!HEAPU8[$2 + 8 | 0]) {
   $1 = moveToLeftmost($0);
  }
  return $1;
 }
 return btreeNext($0);
}

function unicodeIsException($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 if (($2 | 0) <= 0) {
  return 0;
 }
 $2 = $2 - 1 | 0;
 $5 = HEAP32[$0 + 12 >> 2];
 $0 = 0;
 while (1) {
  label$3: {
   if (($0 | 0) <= ($2 | 0)) {
    $4 = ($0 + $2 | 0) / 2 | 0;
    $3 = HEAP32[($4 << 2) + $5 >> 2];
    if (($3 | 0) != ($1 | 0)) {
     break label$3;
    }
    $6 = 1;
   }
   return $6;
  }
  $3 = ($1 | 0) > ($3 | 0);
  $2 = $3 ? $2 : $4 - 1 | 0;
  $0 = $3 ? $4 + 1 | 0 : $0;
  continue;
 }
}

function sumFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 0);
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 20 >> 2];
  if (!HEAP32[$1 + 16 >> 2] & ($2 | 0) <= 0 | ($2 | 0) < 0) {
   break label$1;
  }
  if (HEAPU8[$1 + 24 | 0]) {
   sqlite3_result_error($0, 1652, -1);
   return;
  }
  if (HEAPU8[$1 + 25 | 0]) {
   sqlite3_result_double($0, HEAPF64[$1 >> 3]);
   return;
  }
  $2 = HEAP32[$1 + 12 >> 2];
  sqlite3_result_int64($0, HEAP32[$1 + 8 >> 2], $2);
 }
}

function sqlite3DeleteTriggerStep($0, $1) {
 var $2 = 0;
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 + 40 >> 2];
   sqlite3ExprDelete($0, HEAP32[$1 + 20 >> 2]);
   sqlite3ExprListDelete($0, HEAP32[$1 + 24 >> 2]);
   sqlite3SelectDelete($0, HEAP32[$1 + 8 >> 2]);
   sqlite3IdListDelete($0, HEAP32[$1 + 28 >> 2]);
   sqlite3UpsertDelete($0, HEAP32[$1 + 32 >> 2]);
   sqlite3SrcListDelete($0, HEAP32[$1 + 16 >> 2]);
   sqlite3DbFree($0, HEAP32[$1 + 36 >> 2]);
   sqlite3DbFree($0, $1);
   $1 = $2;
   continue;
  }
  break;
 }
}

function fts3SetHasStat($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $1 = 0;
 label$1: {
  if (HEAPU8[$0 + 237 | 0] != 2) {
   break label$1;
  }
  HEAP32[$2 >> 2] = HEAP32[$0 + 20 >> 2];
  $3 = sqlite3_mprintf(3288, $2);
  $1 = 7;
  if (!$3) {
   break label$1;
  }
  $1 = sqlite3_table_column_metadata(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 16 >> 2], $3, 0, 0, 0, 0, 0, 0);
  sqlite3_free($3);
  HEAP8[$0 + 237 | 0] = !$1;
  $1 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function strlen($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = $0;
 label$1: {
  if ($1 & 3) {
   while (1) {
    if (!HEAPU8[$1 | 0]) {
     break label$1;
    }
    $1 = $1 + 1 | 0;
    if ($1 & 3) {
     continue;
    }
    break;
   }
  }
  while (1) {
   $2 = $1;
   $1 = $1 + 4 | 0;
   $3 = HEAP32[$2 >> 2];
   if (!(($3 ^ -1) & $3 - 16843009 & -2139062144)) {
    continue;
   }
   break;
  }
  while (1) {
   $1 = $2;
   $2 = $1 + 1 | 0;
   if (HEAPU8[$1 | 0]) {
    continue;
   }
   break;
  }
 }
 return $1 - $0 | 0;
}

function renameParseCleanup($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAP32[$0 >> 2];
 $1 = HEAP32[$0 + 8 >> 2];
 if ($1) {
  sqlite3VdbeFinalize($1);
 }
 sqlite3DeleteTable($2, HEAP32[$0 + 236 >> 2]);
 while (1) {
  $1 = HEAP32[$0 + 240 >> 2];
  if ($1) {
   HEAP32[$0 + 240 >> 2] = HEAP32[$1 + 20 >> 2];
   sqlite3FreeIndex($2, $1);
   continue;
  }
  break;
 }
 sqlite3DeleteTrigger($2, HEAP32[$0 + 244 >> 2]);
 sqlite3DbFree($2, HEAP32[$0 + 4 >> 2]);
 renameTokenFree($2, HEAP32[$0 + 268 >> 2]);
 sqlite3ParseObjectReset($0);
}

function sqlite3_errmsg($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = 7;
 label$1: {
  label$2: {
   if (!$0) {
    break label$2;
   }
   if (!sqlite3SafetyCheckSickOrOk($0)) {
    $1 = sqlite3MisuseError(173250);
    break label$2;
   }
   if (HEAPU8[$0 + 87 | 0]) {
    break label$2;
   }
   if (!HEAP32[$0 + 64 >> 2]) {
    $1 = 0;
    break label$2;
   }
   $1 = sqlite3_value_text(HEAP32[$0 + 288 >> 2]);
   if ($1) {
    break label$1;
   }
   $1 = HEAP32[$0 + 64 >> 2];
  }
  $1 = sqlite3ErrStr($1);
 }
 return $1 | 0;
}

function sqlite3FindIndex($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 while (1) {
  label$2: {
   if (HEAP32[$0 + 20 >> 2] <= ($4 | 0)) {
    $3 = 0;
    break label$2;
   }
   $5 = $4 >>> 0 < 2 ^ $4;
   $3 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($5 << 4) | 0) + 12 >> 2];
   label$4: {
    if ($2) {
     if (!sqlite3DbIsNamed($0, $5, $2)) {
      break label$4;
     }
    }
    $3 = sqlite3HashFind($3 + 24 | 0, $1);
    if ($3) {
     break label$2;
    }
   }
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 return $3;
}

function rowSetListToTree($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $4 = HEAP32[$0 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 $3 = 1;
 while (1) {
  $2 = $4;
  if ($2) {
   HEAP32[$1 + 12 >> 2] = HEAP32[$2 + 8 >> 2];
   HEAP32[$2 + 12 >> 2] = $0;
   HEAP32[$2 + 8 >> 2] = rowSetNDeepTree($1 + 12 | 0, $3);
   $3 = $3 + 1 | 0;
   $4 = HEAP32[$1 + 12 >> 2];
   $0 = $2;
   continue;
  }
  break;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function vdbeMergeEngineNew($0) {
 var $1 = 0, $2 = 0;
 $1 = 2;
 while (1) {
  $2 = $1;
  $1 = $2 << 1;
  if (($0 | 0) > ($2 | 0)) {
   continue;
  }
  break;
 }
 $1 = 0;
 label$2: {
  if (sqlite3FaultSim(100)) {
   break label$2;
  }
  $0 = Math_imul($2, 60) + 16 | 0;
  $0 = sqlite3MallocZero($0, $0 >> 31);
  if (!$0) {
   break label$2;
  }
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 >> 2] = $2;
  $1 = $0 + 16 | 0;
  HEAP32[$0 + 12 >> 2] = $1;
  HEAP32[$0 + 8 >> 2] = Math_imul($2, 56) + $1;
  $1 = $0;
 }
 return $1;
}

function sqlite3WalUndo($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if (!HEAPU8[$0 + 44 | 0]) {
  return 0;
 }
 $2 = $0 + 68 | 0;
 $3 = HEAP32[$2 >> 2];
 __memcpy($0 + 52 | 0, walIndexHdr($0), 48);
 $2 = HEAP32[$0 + 68 >> 2];
 while (1) {
  label$3: {
   if ($4) {
    break label$3;
   }
   $2 = $2 + 1 | 0;
   if ($3 >>> 0 < $2 >>> 0) {
    break label$3;
   }
   $4 = pagerUndoCallback($1, walFramePgno($0, $2));
   continue;
  }
  break;
 }
 if (HEAP32[$0 + 68 >> 2] != ($3 | 0)) {
  walCleanupHash($0);
 }
 return $4;
}

function sqlite3VdbeMemMakeWriteable($0) {
 var $1 = 0;
 $1 = HEAPU16[$0 + 16 >> 1];
 label$1: {
  label$2: {
   if (!($1 & 18)) {
    break label$2;
   }
   if ($1 & 1024) {
    $1 = 7;
    if (sqlite3VdbeMemExpandBlob($0)) {
     break label$1;
    }
   }
   if (HEAP32[$0 + 8 >> 2] == HEAP32[$0 + 32 >> 2] ? HEAP32[$0 + 24 >> 2] : 0) {
    break label$2;
   }
   $1 = vdbeMemAddTerminator($0);
   if ($1) {
    break label$1;
   }
  }
  HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 49151;
  $1 = 0;
 }
 return $1;
}

function fts3IsSpecialColumn($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = $0;
 label$1: {
  while (1) {
   $5 = HEAPU8[$3 | 0];
   if (!$5) {
    break label$1;
   }
   if (($5 | 0) != 61) {
    $3 = $3 + 1 | 0;
    continue;
   }
   break;
  }
  HEAP32[$1 >> 2] = $3 - $0;
  $5 = 1;
  HEAP32[$4 >> 2] = $3 + 1;
  $3 = sqlite3_mprintf(8342, $4);
  if ($3) {
   sqlite3Fts3Dequote($3);
  }
  HEAP32[$2 >> 2] = $3;
 }
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function sqlite3VdbeMemExpandBlob($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2] + HEAP32[$0 + 12 >> 2] | 0;
 label$1: {
  if (($1 | 0) <= 0) {
   $1 = 1;
   if (!(HEAPU8[$0 + 16 | 0] & 16)) {
    break label$1;
   }
  }
  $2 = 7;
  if (sqlite3VdbeMemGrow($0, $1, 1)) {
   break label$1;
  }
  $2 = 0;
  memset(HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] | 0, 0, HEAP32[$0 >> 2]);
  HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + HEAP32[$0 >> 2];
  HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 63999;
 }
 return $2;
}

function sqlite3Fts3HashClear($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 fts3HashFree(HEAP32[$0 + 16 >> 2]);
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 while (1) {
  if ($1) {
   $3 = HEAP32[$1 >> 2];
   label$3: {
    if (!HEAPU8[$0 + 1 | 0]) {
     break label$3;
    }
    $2 = HEAP32[$1 + 12 >> 2];
    if (!$2) {
     break label$3;
    }
    fts3HashFree($2);
   }
   fts3HashFree($1);
   $1 = $3;
   continue;
  }
  break;
 }
 HEAP32[$0 + 4 >> 2] = 0;
}

function releaseInodeInfo($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = HEAP32[$0 + 8 >> 2];
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 36 >> 2] - 1 | 0;
  HEAP32[$1 + 36 >> 2] = $2;
  if ($2) {
   break label$1;
  }
  closePendingFds($0);
  $0 = HEAP32[$1 + 44 >> 2];
  $2 = HEAP32[$1 + 48 >> 2];
  label$2: {
   if ($2) {
    HEAP32[$2 + 44 >> 2] = $0;
    $0 = HEAP32[$1 + 44 >> 2];
    break label$2;
   }
   HEAP32[17715] = $0;
  }
  if ($0) {
   HEAP32[$0 + 48 >> 2] = $2;
  }
  sqlite3_free($1);
 }
}

function indexIteratorNext($0, $1) {
 var $2 = 0, $3 = 0;
 if (HEAP32[$0 >> 2]) {
  $2 = HEAP32[$0 + 4 >> 2] + 1 | 0;
  HEAP32[$0 + 4 >> 2] = $2;
  if (HEAP32[$0 + 8 >> 2] <= ($2 | 0)) {
   HEAP32[$1 >> 2] = $2;
   return 0;
  }
  $3 = $0;
  $2 = $2 << 3;
  $0 = $0 + 12 | 0;
  HEAP32[$1 >> 2] = HEAP32[($2 + HEAP32[$0 >> 2] | 0) + 4 >> 2];
  return HEAP32[HEAP32[$3 + 12 >> 2] + $2 >> 2];
 }
 HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
 $1 = HEAP32[HEAP32[$0 + 8 >> 2] + 20 >> 2];
 HEAP32[$0 + 8 >> 2] = $1;
 return $1;
}

function areDoubleQuotedStringsEnabled($0, $1) {
 var $2 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 $2 = 1;
 label$1: {
  if (HEAPU8[$0 + 177 | 0]) {
   break label$1;
  }
  if (HEAP8[$1 + 26 | 0] & 1) {
   $1 = HEAP32[$0 + 32 >> 2];
   if (wasm2js_i32$0 = sqlite3WritableSchema($0), wasm2js_i32$1 = 0, wasm2js_i32$2 = $1 & 1073741824, 
   wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
    break label$1;
   }
   return $1 >>> 29 & 1;
  }
  $2 = HEAP32[$0 + 32 >> 2] >>> 30 & 1;
 }
 return $2;
}

function pcache1FetchNoMutex($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 56 >> 2] + (($1 >>> 0) % HEAPU32[$0 + 52 >> 2] << 2) | 0;
 label$1: {
  label$2: {
   while (1) {
    $3 = HEAP32[$3 >> 2];
    if (!$3) {
     break label$2;
    }
    if (HEAP32[$3 + 8 >> 2] != ($1 | 0)) {
     $3 = $3 + 16 | 0;
     continue;
    }
    break;
   }
   if (!HEAP32[$3 + 24 >> 2]) {
    break label$1;
   }
   return pcache1PinPage($3);
  }
  if (!$2) {
   return 0;
  }
  $3 = pcache1FetchStage2($0, $1, $2);
 }
 return $3;
}

function vdbeIncrSwap($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = vdbeIncrPopulate($0);
 $2 = HEAP32[$0 + 60 >> 2];
 $5 = $2;
 $1 = HEAP32[$0 + 56 >> 2];
 $3 = $1;
 HEAP32[$0 + 40 >> 2] = $1;
 HEAP32[$0 + 44 >> 2] = $2;
 $1 = HEAP32[$0 + 52 >> 2];
 $2 = HEAP32[$0 + 48 >> 2];
 HEAP32[$0 + 32 >> 2] = $2;
 HEAP32[$0 + 36 >> 2] = $1;
 $1 = HEAP32[$0 + 8 >> 2];
 $3 = ($3 | 0) == ($1 | 0);
 $1 = $5;
 $2 = HEAP32[$0 + 12 >> 2];
 if ($3 & ($1 | 0) == ($2 | 0)) {
  HEAP32[$0 + 20 >> 2] = 1;
 }
 return $4;
}

function getToken($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$0 >> 2];
 while (1) {
  $3 = sqlite3GetToken($3, $2 + 12 | 0) + $3 | 0;
  $1 = HEAP32[$2 + 12 >> 2];
  if (($1 | 0) == 183) {
   continue;
  }
  break;
 }
 label$2: {
  if (!($1 - 117 >>> 0 < 2 | $1 - 164 >>> 0 < 2 | ($1 | 0) == 59)) {
   if ((sqlite3ParserFallback($1) | 0) != 59) {
    break label$2;
   }
  }
  $1 = 59;
 }
 HEAP32[$0 >> 2] = $3;
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function fileHasMoved($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 $1 = 0;
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   break label$1;
  }
  $1 = 1;
  if (FUNCTION_TABLE[HEAP32[16249]](HEAP32[$0 + 32 >> 2], $2) | 0) {
   break label$1;
  }
  $0 = HEAP32[$0 + 8 >> 2];
  $1 = HEAP32[$0 + 12 >> 2];
  $3 = HEAP32[$0 + 8 >> 2];
  $0 = HEAP32[$2 + 104 >> 2];
  $1 = ($3 | 0) != ($0 | 0) | ($1 | 0) != HEAP32[$2 + 108 >> 2];
 }
 __stack_pointer = $2 + 112 | 0;
 return $1;
}

function sqlite3LogEstAdd($0, $1) {
 label$1: {
  if (($0 | 0) >= ($1 | 0)) {
   if (($1 + 49 | 0) < ($0 | 0)) {
    break label$1;
   }
   if (($1 + 31 | 0) < ($0 | 0)) {
    $0 = $0 + 1 | 0;
    break label$1;
   }
   $0 = HEAPU8[($0 - $1 | 0) + 48928 | 0] + $0 | 0;
   break label$1;
  }
  if (($0 + 49 | 0) < ($1 | 0)) {
   $0 = $1;
   break label$1;
  }
  if (($0 + 31 | 0) < ($1 | 0)) {
   $0 = $1 + 1 | 0;
   break label$1;
  }
  $0 = HEAPU8[($1 - $0 | 0) + 48928 | 0] + $1 | 0;
 }
 return $0 << 16 >> 16;
}

function sqlite3Fts3ReadInt($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 while (1) {
  $3 = HEAPU8[$0 + $5 | 0];
  if (($3 - 48 & 255) >>> 0 <= 9) {
   $2 = $3 - 48 | 0;
   $6 = $2;
   $3 = __wasm_i64_mul($4, $7, 10, 0) + $2 | 0;
   $2 = i64toi32_i32$HIGH_BITS;
   $4 = $3;
   $2 = $4 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   $7 = $2;
   if (!$2 & $4 >>> 0 > 2147483647 | $2) {
    return -1;
   } else {
    $5 = $5 + 1 | 0;
    continue;
   }
  }
  break;
 }
 HEAP32[$1 >> 2] = $4;
 return $5;
}

function sqlite3ExprCodeTemp($0, $1, $2) {
 var $3 = 0;
 $3 = sqlite3ExprSkipCollateAndLikely($1);
 label$1: {
  if (!HEAPU8[$0 + 23 | 0] | !$3 | HEAPU8[$3 | 0] == 176) {
   break label$1;
  }
  if (!sqlite3ExprIsConstantNotJoin($3)) {
   break label$1;
  }
  HEAP32[$2 >> 2] = 0;
  return sqlite3ExprCodeRunJustOnce($0, $3, -1);
 }
 $1 = sqlite3GetTempReg($0);
 $3 = sqlite3ExprCodeTarget($0, $3, $1);
 if (($1 | 0) != ($3 | 0)) {
  sqlite3ReleaseTempReg($0, $1);
  $1 = 0;
 }
 HEAP32[$2 >> 2] = $1;
 return $3;
}

function removeFromSharingList($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAP32[$0 + 68 >> 2];
 HEAP32[$0 + 68 >> 2] = $2 - 1;
 if (($2 | 0) <= 1) {
  $1 = HEAP32[17744];
  label$2: {
   if (($1 | 0) == ($0 | 0)) {
    $1 = 70976;
   } else {
    while (1) {
     $2 = $1;
     if (!$1) {
      break label$2;
     }
     $1 = HEAP32[$2 + 72 >> 2];
     if (($1 | 0) != ($0 | 0)) {
      continue;
     }
     break;
    }
    $1 = $2 + 72 | 0;
   }
   HEAP32[$1 >> 2] = HEAP32[$0 + 72 >> 2];
  }
  $1 = 1;
 }
 return $1;
}

function sqlite3_strnicmp($0, $1, $2) {
 var $3 = 0;
 if (!$0) {
  return $1 ? -1 : 0;
 }
 if (!$1) {
  return 1;
 }
 while (1) {
  if (($2 | 0) <= 0) {
   return 0;
  }
  label$5: {
   $3 = HEAPU8[$0 | 0];
   if (!$3) {
    $3 = 0;
    break label$5;
   }
   $3 = HEAPU8[$3 + 29904 | 0];
   if (($3 | 0) != HEAPU8[HEAPU8[$1 | 0] + 29904 | 0]) {
    break label$5;
   }
   $2 = $2 - 1 | 0;
   $1 = $1 + 1 | 0;
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 return $3 - HEAPU8[HEAPU8[$1 | 0] + 29904 | 0] | 0;
}

function sqlite3ExprIsTableConstraint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAPU8[$1 + 36 | 0];
 label$1: {
  if ($2 & 64) {
   break label$1;
  }
  $3 = HEAP32[$0 + 4 >> 2] & 1;
  label$2: {
   if ($2 & 8) {
    if (!$3) {
     break label$1;
    }
    $2 = HEAP32[$0 + 36 >> 2];
    if (($2 | 0) == HEAP32[$1 + 40 >> 2]) {
     break label$2;
    }
    break label$1;
   }
   if ($3) {
    break label$1;
   }
   $2 = HEAP32[$1 + 40 >> 2];
  }
  $4 = sqlite3ExprIsTableConstant($0, $2);
 }
 return $4;
}

function sqlite3VdbeIntegerAffinity($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAPF64[$0 >> 3];
 $3 = doubleToInt64($4);
 $2 = i64toi32_i32$HIGH_BITS;
 $5 = $2;
 $6 = +($3 >>> 0) + +($2 | 0) * 4294967296 != $4;
 $1 = $2 + 2147483647 | 0;
 $2 = $3 - 1 | 0;
 $1 = ($2 | 0) != -1 ? $1 + 1 | 0 : $1;
 if (!($6 | ($1 | 0) == -1 & $2 >>> 0 > 4294967293)) {
  $1 = $0;
  HEAP32[$1 >> 2] = $3;
  $2 = $5;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 4;
 }
}

function sqlite3FindDbName($0, $1) {
 var $2 = 0, $3 = 0;
 if (!$1) {
  return -1;
 }
 $2 = HEAP32[$0 + 20 >> 2] - 1 | 0;
 $3 = ($2 | 0) < -1 ? $2 : -1;
 $0 = HEAP32[$0 + 16 >> 2] + ($2 << 4) | 0;
 while (1) {
  label$3: {
   if (($2 | 0) >= 0) {
    if (!sqlite3_stricmp(HEAP32[$0 >> 2], $1)) {
     return $2;
    }
    if ($2) {
     break label$3;
    }
    if (sqlite3_stricmp(10765, $1)) {
     break label$3;
    }
    $3 = 0;
   }
   return $3;
  }
  $0 = $0 - 16 | 0;
  $2 = $2 - 1 | 0;
  continue;
 }
}

function invalidateIncrblobCursors($0, $1, $2, $3, $4) {
 var $5 = 0;
 HEAP8[$0 + 11 | 0] = 0;
 $5 = HEAP32[$0 + 4 >> 2] + 8 | 0;
 while (1) {
  $5 = HEAP32[$5 >> 2];
  if ($5) {
   label$3: {
    if (!(HEAPU8[$5 + 1 | 0] & 16)) {
     break label$3;
    }
    HEAP8[$0 + 11 | 0] = 1;
    if (!$4 & (($2 | 0) != HEAP32[$5 + 32 >> 2] | HEAP32[$5 + 36 >> 2] != ($3 | 0)) | HEAP32[$5 + 64 >> 2] != ($1 | 0)) {
     break label$3;
    }
    HEAP8[$5 | 0] = 1;
   }
   $5 = $5 + 24 | 0;
   continue;
  }
  break;
 }
}

function renameTokenFind($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $3 = $0 + 268 | 0;
  while (1) {
   $0 = HEAP32[$3 >> 2];
   if (!$0) {
    break label$1;
   }
   if (HEAP32[$0 >> 2] == ($2 | 0)) {
    if ($1) {
     HEAP32[$3 >> 2] = HEAP32[$0 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$1 >> 2] = $0;
     HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
    }
    return $0;
   } else {
    $3 = $0 + 12 | 0;
    continue;
   }
  }
 }
 return 0;
}

function jsonArrayFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 jsonInit($3, $0);
 jsonAppendChar($3, 91);
 $1 = ($1 | 0) > 0 ? $1 : 0;
 while (1) {
  if (($1 | 0) != ($4 | 0)) {
   jsonAppendSeparator($3);
   jsonAppendValue($3, HEAP32[($4 << 2) + $2 >> 2]);
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 jsonAppendChar($3, 93);
 jsonResult($3);
 sqlite3_result_subtype($0, 74);
 __stack_pointer = $3 + 128 | 0;
}

function sqliteViewResetAll($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
 if (HEAPU8[$2 + 78 | 0] & 2) {
  $2 = $2 + 16 | 0;
  while (1) {
   $2 = HEAP32[$2 >> 2];
   if ($2) {
    $3 = HEAP32[$2 + 8 >> 2];
    if (HEAPU8[$3 + 43 | 0] != 2) {
     continue;
    }
    sqlite3DeleteColumnNames($0, $3);
    continue;
   }
   break;
  }
  $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2];
  HEAP16[$2 + 78 >> 1] = HEAPU16[$2 + 78 >> 1] & 65533;
 }
}

function journalHdrOffset($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 84 >> 2];
 $1 = HEAP32[$0 + 80 >> 2];
 $4 = $1;
 if (!($3 | $1)) {
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 $1 = $3;
 $2 = $4 - 1 | 0;
 $3 = $1 - !$4 | 0;
 $1 = $0;
 $4 = HEAP32[$1 + 156 >> 2];
 $1 = __wasm_i64_sdiv($2, $3, $4, 0);
 $2 = i64toi32_i32$HIGH_BITS;
 $3 = $1 + 1 | 0;
 $2 = $3 ? $2 : $2 + 1 | 0;
 $1 = __wasm_i64_mul($3, $2, $4, 0);
 $2 = i64toi32_i32$HIGH_BITS;
 i64toi32_i32$HIGH_BITS = $2;
 return $1;
}

function sqlite3StmtCurrentTime($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 $3 = HEAP32[$1 + 56 >> 2];
 $2 = HEAP32[$1 + 60 >> 2];
 if (!($2 | $3)) {
  $2 = HEAP32[HEAP32[HEAP32[$0 >> 2] + 20 >> 2] >> 2];
  $0 = $1 + 56 | 0;
  if (!sqlite3OsCurrentTimeInt64($2, $0)) {
   i64toi32_i32$HIGH_BITS = HEAP32[$1 + 60 >> 2];
   $2 = HEAP32[$1 + 56 >> 2];
   return $2;
  }
  HEAP32[$1 + 56 >> 2] = 0;
  HEAP32[$1 + 60 >> 2] = 0;
  $3 = 0;
  $2 = 0;
 }
 i64toi32_i32$HIGH_BITS = $2;
 return $3;
}

function sqlite3RowSetNext($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU16[$0 + 26 >> 1];
 if (!($2 & 2)) {
  if (!($2 & 1)) {
   HEAP32[$0 + 8 >> 2] = rowSetEntrySort(HEAP32[$0 + 8 >> 2]);
   $2 = HEAPU16[$0 + 26 >> 1];
  }
  HEAP16[$0 + 26 >> 1] = $2 | 3;
 }
 $2 = HEAP32[$0 + 8 >> 2];
 if (!$2) {
  return 0;
 }
 $3 = HEAP32[$2 + 4 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$2 >> 2];
 HEAP32[$1 + 4 >> 2] = $3;
 $2 = HEAP32[$2 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = $2;
 if (!$2) {
  sqlite3RowSetClear($0);
 }
 return 1;
}

function fts3IsEmpty($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $1;
 label$1: {
  if (HEAP32[$0 + 40 >> 2]) {
   $0 = 0;
   HEAP32[$2 >> 2] = 0;
   break label$1;
  }
  $0 = fts3SqlStmt($0, 1, $3 + 8 | 0, $3 + 12 | 0);
  if ($0) {
   break label$1;
  }
  $0 = HEAP32[$3 + 8 >> 2];
  if ((sqlite3_step($0) | 0) == 100) {
   HEAP32[$2 >> 2] = sqlite3_column_int($0, 0);
  }
  $0 = sqlite3_reset($0);
 }
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function btreeHeapInsert($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$0 >> 2] + 1 | 0;
 HEAP32[$0 >> 2] = $2;
 HEAP32[($2 << 2) + $0 >> 2] = $1;
 while (1) {
  label$2: {
   if ($2 >>> 0 < 2) {
    break label$2;
   }
   $1 = $2 >>> 1 | 0;
   $3 = ($1 << 2) + $0 | 0;
   $4 = HEAP32[$3 >> 2];
   $2 = ($2 << 2) + $0 | 0;
   $5 = HEAP32[$2 >> 2];
   if ($4 >>> 0 <= $5 >>> 0) {
    break label$2;
   }
   HEAP32[$3 >> 2] = $5;
   HEAP32[$2 >> 2] = $4;
   $2 = $1;
   continue;
  }
  break;
 }
}

function vdbeSorterOpenTempFile($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = 3338;
 label$1: {
  if (sqlite3FaultSim(202)) {
   break label$1;
  }
  $3 = sqlite3OsOpenMalloc(HEAP32[$0 >> 2], 0, $1, 4126, $2 + 12 | 0);
  HEAP32[$2 + 12 >> 2] = $3;
  if ($3) {
   break label$1;
  }
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  sqlite3OsFileControlHint(HEAP32[$1 >> 2], 18, $2);
  $3 = HEAP32[$2 + 12 >> 2];
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function randomFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 sqlite3_randomness(8, $3 + 8 | 0);
 $4 = HEAP32[$3 + 8 >> 2];
 $2 = $4;
 $1 = HEAP32[$3 + 12 >> 2];
 if (($1 | 0) < 0) {
  $4 = $2;
  $2 = 0 - $2 | 0;
  $1 = $1 & 2147483647;
  $1 = $1 + (($4 | 0) != 0) | 0;
  $1 = 0 - $1 | 0;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $1;
 }
 sqlite3_result_int64($0, $2, $1);
 __stack_pointer = $3 + 16 | 0;
}

function whereLoopResize($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = 0;
 label$1: {
  if (HEAPU16[$1 + 48 >> 1] >= ($2 | 0)) {
   break label$1;
  }
  $2 = $2 + 7 & -8;
  $4 = sqlite3DbMallocRawNN($0, $2 << 2, 0);
  $3 = 7;
  if (!$4) {
   break label$1;
  }
  $3 = __memcpy($4, HEAP32[$1 + 52 >> 2], HEAPU16[$1 + 48 >> 1] << 2);
  $4 = HEAP32[$1 + 52 >> 2];
  if (($4 | 0) != ($1 + 60 | 0)) {
   sqlite3DbFreeNN($0, $4);
  }
  HEAP16[$1 + 48 >> 1] = $2;
  HEAP32[$1 + 52 >> 2] = $3;
  $3 = 0;
 }
 return $3;
}

function sqlite3VdbeExplain($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAPU8[$0 + 207 | 0] != 2) {
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = $3;
  $3 = sqlite3VMPrintf(HEAP32[$0 >> 2], $2, $3);
  $2 = HEAP32[$0 + 8 >> 2];
  $5 = $2;
  $2 = HEAP32[$2 + 108 >> 2];
  sqlite3VdbeAddOp4($5, 185, $2, HEAP32[$0 + 220 >> 2], 0, $3, -6);
  if (!$1) {
   break label$1;
  }
  HEAP32[$0 + 220 >> 2] = $2;
 }
 __stack_pointer = $4 + 16 | 0;
}

function jsonAppendChar($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  $2 = HEAP32[$0 + 20 >> 2];
  $3 = HEAP32[$0 + 12 >> 2];
  $4 = HEAP32[$0 + 16 >> 2];
  if (($2 | 0) == ($3 | 0) & $4 >>> 0 >= HEAPU32[$0 + 8 >> 2] | $2 >>> 0 > $3 >>> 0) {
   if (jsonGrow($0, 1)) {
    break label$1;
   }
   $4 = HEAP32[$0 + 16 >> 2];
   $2 = HEAP32[$0 + 20 >> 2];
  }
  $3 = $4 + 1 | 0;
  HEAP32[$0 + 16 >> 2] = $3;
  HEAP32[$0 + 20 >> 2] = $3 ? $2 : $2 + 1 | 0;
  HEAP8[$4 + HEAP32[$0 + 4 >> 2] | 0] = $1;
 }
}

function sqlite3PagerCheckpoint($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = HEAP32[$0 + 232 >> 2];
 label$1: {
  if (!$6) {
   $5 = 0;
   if (HEAPU8[$0 + 5 | 0] != 5) {
    break label$1;
   }
   sqlite3_exec($1, 2197, 0, 0, 0);
   $6 = HEAP32[$0 + 232 >> 2];
   $5 = 0;
   if (!$6) {
    break label$1;
   }
  }
  $5 = sqlite3WalCheckpoint($6, $1, $2, $2 ? HEAP32[$0 + 192 >> 2] : 0, HEAP32[$0 + 196 >> 2], HEAPU8[$0 + 11 | 0], HEAP32[$0 + 168 >> 2], HEAP32[$0 + 224 >> 2], $3, $4);
 }
 return $5;
}

function sqlite3ExprCoveredByIndex($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = 0;
 HEAP32[$3 + 28 >> 2] = 0;
 HEAP32[$3 + 32 >> 2] = 0;
 HEAP32[$3 + 36 >> 2] = 0;
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 85;
 HEAP32[$3 + 12 >> 2] = $1;
 HEAP32[$3 + 8 >> 2] = $2;
 HEAP32[$3 + 40 >> 2] = $3 + 8;
 sqlite3WalkExpr($3 + 16 | 0, $0);
 __stack_pointer = $3 + 48 | 0;
 $1 = HEAPU16[$3 + 36 >> 1];
 return !$1;
}

function recomputeColumnsUsed($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 if (HEAP32[$1 + 16 >> 2]) {
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 50;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = 80;
  HEAP32[$1 + 48 >> 2] = 0;
  HEAP32[$1 + 52 >> 2] = 0;
  sqlite3WalkSelect($2, $0);
 }
 __stack_pointer = $2 + 32 | 0;
}

function fts3SegReaderDoclistCmpRev($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = !HEAP32[$0 + 80 >> 2] - !HEAP32[$1 + 80 >> 2] | 0;
 if (!$2) {
  $4 = HEAP32[$0 + 88 >> 2];
  $5 = HEAP32[$1 + 88 >> 2];
  $2 = HEAP32[$0 + 92 >> 2];
  $3 = HEAP32[$1 + 92 >> 2];
  if (($4 | 0) == ($5 | 0) & ($2 | 0) == ($3 | 0)) {
   return HEAP32[$1 >> 2] - HEAP32[$0 >> 2] | 0;
  }
  $2 = $4 >>> 0 < $5 >>> 0 & ($2 | 0) <= ($3 | 0) | ($2 | 0) < ($3 | 0) ? 1 : -1;
 }
 return $2 | 0;
}

function moveToChild($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP8[$0 + 68 | 0];
 if (($2 | 0) >= 19) {
  return sqlite3CorruptError(72115);
 }
 HEAP16[$0 + 50 >> 1] = 0;
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 249;
 $3 = HEAP32[$0 + 20 >> 2];
 HEAP16[(($2 << 1) + $0 | 0) + 72 >> 1] = HEAPU16[$0 + 70 >> 1];
 HEAP32[(($2 << 2) + $0 | 0) + 120 >> 2] = HEAP32[$0 + 116 >> 2];
 HEAP8[$0 + 68 | 0] = $2 + 1;
 HEAP16[$0 + 70 >> 1] = 0;
 return getAndInitPage($3, $1, $0 + 116 | 0, $0, HEAPU8[$0 + 2 | 0]);
}

function fts3DeleteAll($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 sqlite3Fts3PendingTermsClear($0);
 if ($1) {
  fts3SqlExec($2 + 12 | 0, $0, 2, 0);
 }
 fts3SqlExec($2 + 12 | 0, $0, 3, 0);
 fts3SqlExec($2 + 12 | 0, $0, 4, 0);
 if (HEAPU8[$0 + 238 | 0]) {
  fts3SqlExec($2 + 12 | 0, $0, 5, 0);
 }
 if (HEAPU8[$0 + 237 | 0]) {
  fts3SqlExec($2 + 12 | 0, $0, 6, 0);
 }
 __stack_pointer = $2 + 16 | 0;
 $0 = HEAP32[$2 + 12 >> 2];
 return $0;
}

function sqlite3VdbeMemShallowCopy($0, $1, $2) {
 var $3 = 0, $4 = 0;
 if (HEAPU8[$0 + 17 | 0] & 144) {
  vdbeClrCopy($0, $1, $2);
  return;
 }
 $3 = HEAP32[$1 + 4 >> 2];
 $4 = HEAP32[$1 >> 2];
 HEAP32[$0 >> 2] = $4;
 HEAP32[$0 + 4 >> 2] = $3;
 HEAP32[$0 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
 $4 = HEAP32[$1 + 12 >> 2];
 $3 = HEAP32[$1 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 + 12 >> 2] = $4;
 if (!(HEAPU8[$1 + 17 | 0] & 32)) {
  HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 36863 | $2;
 }
}

function sqlite3Utf8Read($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 >> 2];
 $2 = $1 + 1 | 0;
 HEAP32[$0 >> 2] = $2;
 $1 = HEAPU8[$1 | 0];
 if ($1 >>> 0 >= 192) {
  $1 = HEAPU8[$1 + 32128 | 0];
  while (1) {
   if ((HEAPU8[$2 | 0] & 192) == 128) {
    $3 = $2 + 1 | 0;
    HEAP32[$0 >> 2] = $3;
    $1 = HEAPU8[$2 | 0] & 63 | $1 << 6;
    $2 = $3;
    continue;
   }
   break;
  }
  $1 = ($1 & -2) == 65534 ? 65533 : $1 >>> 0 < 128 ? 65533 : ($1 & -2048) == 55296 ? 65533 : $1;
 }
 return $1;
}

function selectRefLeave($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $0 = HEAP32[$0 + 24 >> 2];
 $3 = $0;
 $4 = HEAP32[$3 + 8 >> 2];
 $5 = $4;
 $2 = HEAP32[$3 + 12 >> 2];
 $6 = $2;
 if ($2 | $4) {
  $3 = HEAP32[$1 + 32 >> 2];
  $2 = HEAP32[$3 >> 2];
  $4 = $2 >> 31;
  $1 = $2;
  $2 = $4;
  $3 = $5;
  $2 = $2 + ($1 >>> 0 > $3 >>> 0) | 0;
  $1 = $3 - $1 | 0;
  $3 = $0;
  HEAP32[$3 + 8 >> 2] = $1;
  $4 = $6;
  $2 = $4 - $2 | 0;
  HEAP32[$3 + 12 >> 2] = $2;
 }
}

function fts3SegReaderDoclistCmp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = !HEAP32[$0 + 80 >> 2] - !HEAP32[$1 + 80 >> 2] | 0;
 if (!$2) {
  $4 = HEAP32[$0 + 88 >> 2];
  $5 = HEAP32[$1 + 88 >> 2];
  $2 = HEAP32[$0 + 92 >> 2];
  $3 = HEAP32[$1 + 92 >> 2];
  if (($4 | 0) == ($5 | 0) & ($2 | 0) == ($3 | 0)) {
   return HEAP32[$1 >> 2] - HEAP32[$0 >> 2] | 0;
  }
  $2 = $4 >>> 0 > $5 >>> 0 & ($2 | 0) >= ($3 | 0) | ($2 | 0) > ($3 | 0) ? 1 : -1;
 }
 return $2 | 0;
}

function columnName($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = HEAP32[$0 >> 2];
 $6 = sqlite3_column_count($0);
 label$1: {
  if (($1 | 0) < 0 | ($6 | 0) <= ($1 | 0)) {
   break label$1;
  }
  $0 = HEAP32[$0 + 116 >> 2] + Math_imul(Math_imul($3, $6) + $1 | 0, 40) | 0;
  label$2: {
   if ($2) {
    $4 = sqlite3_value_text16($0);
    break label$2;
   }
   $4 = sqlite3_value_text($0);
  }
  if (!HEAPU8[$5 + 87 | 0]) {
   break label$1;
  }
  sqlite3OomClear($5);
  $4 = 0;
 }
 return $4;
}

function notValidImpl($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $1 = HEAP32[$1 + 24 >> 2];
 $6 = 4714;
 label$1: {
  if ($1 & 32) {
   break label$1;
  }
  $6 = 3573;
  if ($1 & 4) {
   break label$1;
  }
  $6 = $1 & 8 ? 4857 : 5113;
 }
 HEAP32[$5 + 4 >> 2] = $6;
 HEAP32[$5 >> 2] = $2;
 sqlite3ErrorMsg($0, 6211, $5);
 if ($3) {
  HEAP8[$3 | 0] = 121;
 }
 sqlite3RecordErrorOffsetOfExpr(HEAP32[$0 >> 2], $4);
 __stack_pointer = $5 + 16 | 0;
}

function __fixtfsi($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $6 = $3 >>> 16 & 32767;
 $4 = 0;
 label$1: {
  if ($6 >>> 0 < 16383) {
   break label$1;
  }
  $4 = $3 >> 31 ^ 2147483647;
  if ($6 - 16415 >>> 0 <= 4294967263) {
   break label$1;
  }
  __lshrti3($5, $0, $1, $2, $3 & 65535 | 65536, 16495 - $6 | 0);
  $4 = HEAP32[$5 >> 2];
  $4 = ($3 | 0) > 0 | ($3 | 0) >= 0 ? $4 : 0 - $4 | 0;
 }
 __stack_pointer = $5 + 16 | 0;
 return $4;
}

function finalizeAggFunctions($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$1 + 40 >> 2];
 $4 = HEAP32[$0 + 8 >> 2];
 $0 = 0;
 while (1) {
  if (($0 | 0) < HEAP32[$1 + 44 >> 2]) {
   $5 = HEAP32[$2 + 8 >> 2];
   $3 = HEAP32[HEAP32[$2 >> 2] + 20 >> 2];
   if ($3) {
    $3 = HEAP32[$3 >> 2];
   } else {
    $3 = 0;
   }
   sqlite3VdbeAddOp2($4, 165, $5, $3);
   sqlite3VdbeAppendP4($4, HEAP32[$2 + 4 >> 2], -7);
   $2 = $2 + 20 | 0;
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
}

function __time($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = +_emscripten_date_now() / 1e3;
 label$1: {
  if (Math_abs($1) < 0x8000000000000000) {
   $2 = Math_abs($1) >= 1 ? ~~($1 > 0 ? Math_min(Math_floor($1 * 2.3283064365386963e-10), 4294967295) : Math_ceil(($1 - +(~~$1 >>> 0 >>> 0)) * 2.3283064365386963e-10)) >>> 0 : 0;
   $3 = ~~$1 >>> 0;
   break label$1;
  }
  $2 = -2147483648;
 }
 if ($0) {
  HEAP32[$0 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $2;
 }
 i64toi32_i32$HIGH_BITS = $2;
 return $3;
}

function walRestartHdr($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = walCkptInfo($0);
 HEAP32[$0 + 68 >> 2] = 0;
 HEAP32[$0 + 112 >> 2] = HEAP32[$0 + 112 >> 2] + 1;
 $3 = $0 + 84 | 0;
 sqlite3Put4byte($3, sqlite3Get4byte($3) + 1 | 0);
 HEAP32[$0 + 88 >> 2] = $1;
 walIndexWriteHdr($0);
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 32 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 $0 = 2;
 while (1) {
  if (($0 | 0) != 5) {
   HEAP32[(($0 << 2) + $2 | 0) + 4 >> 2] = -1;
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
}

function reindexTable($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (HEAPU8[$1 + 43 | 0] == 1) {
   break label$1;
  }
  $3 = $1 + 8 | 0;
  while (1) {
   $3 = HEAP32[$3 >> 2];
   if (!$3) {
    break label$1;
   }
   label$3: {
    if ($2) {
     if (!collationMatch($2, $3)) {
      break label$3;
     }
    }
    sqlite3BeginWriteOperation($0, 0, sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$1 + 60 >> 2]));
    sqlite3RefillIndex($0, $3, -1);
   }
   $3 = $3 + 20 | 0;
   continue;
  }
 }
}

function allocateTempSpace($0) {
 var $1 = 0;
 $1 = sqlite3PageMalloc(HEAP32[$0 + 36 >> 2]);
 HEAP32[$0 + 84 >> 2] = $1;
 if (!$1) {
  $1 = HEAP32[$0 + 8 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[$1 + 24 >> 2];
  memset($1, 0, 200);
  return 7;
 }
 HEAP8[$1 | 0] = 0;
 HEAP8[$1 + 1 | 0] = 0;
 HEAP8[$1 + 2 | 0] = 0;
 HEAP8[$1 + 3 | 0] = 0;
 HEAP8[$1 + 4 | 0] = 0;
 HEAP8[$1 + 5 | 0] = 0;
 HEAP8[$1 + 6 | 0] = 0;
 HEAP8[$1 + 7 | 0] = 0;
 HEAP32[$0 + 84 >> 2] = HEAP32[$0 + 84 >> 2] + 4;
 return 0;
}

function vdbePmaWriterInit($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $1 = memset($1, 0, 40);
 $5 = $2 >> 31;
 $6 = sqlite3Malloc($2, $5);
 HEAP32[$1 + 4 >> 2] = $6;
 if (!$6) {
  HEAP32[$1 >> 2] = 7;
  return;
 }
 HEAP32[$1 + 32 >> 2] = $0;
 HEAP32[$1 + 8 >> 2] = $2;
 $2 = __wasm_i64_srem($3, $4, $2, $5);
 HEAP32[$1 + 24 >> 2] = $3 - $2;
 $5 = i64toi32_i32$HIGH_BITS;
 HEAP32[$1 + 28 >> 2] = $4 - ($5 + ($3 >>> 0 < $2 >>> 0) | 0);
 HEAP32[$1 + 16 >> 2] = $2;
 HEAP32[$1 + 12 >> 2] = $2;
}

function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = $2 >>> 16 | 0;
 $5 = $0 >>> 16 | 0;
 $3 = (Math_imul($4, $5) + Math_imul($1, $2) | 0) + Math_imul($3, $0) | 0;
 $2 = $2 & 65535;
 $0 = $0 & 65535;
 $1 = Math_imul($2, $0);
 $2 = ($1 >>> 16 | 0) + Math_imul($2, $5) | 0;
 $3 = $3 + ($2 >>> 16 | 0) | 0;
 $2 = Math_imul($0, $4) + ($2 & 65535) | 0;
 i64toi32_i32$HIGH_BITS = $3 + ($2 >>> 16 | 0) | 0;
 return $1 & 65535 | $2 << 16;
}

function whereInfoFree($0, $1) {
 var $2 = 0, $3 = 0;
 sqlite3WhereClauseClear($1 + 88 | 0);
 while (1) {
  $2 = HEAP32[$1 + 64 >> 2];
  if ($2) {
   HEAP32[$1 + 64 >> 2] = HEAP32[$2 + 56 >> 2];
   whereLoopDelete($0, $2);
   continue;
  } else {
   $2 = HEAP32[$1 + 72 >> 2];
   while (1) {
    if ($2) {
     $3 = HEAP32[$2 >> 2];
     sqlite3DbFreeNN($0, $2);
     HEAP32[$1 + 72 >> 2] = $3;
     $2 = $3;
     continue;
    }
    break;
   }
   sqlite3DbFreeNN($0, $1);
  }
  break;
 }
}

function renameTestSchema($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 48 | 0;
 __stack_pointer = $5;
 HEAP8[$0 + 16 | 0] = 1;
 HEAP32[$5 + 32 >> 2] = $4;
 HEAP32[$5 + 28 >> 2] = $3;
 HEAP32[$5 + 24 >> 2] = $2;
 HEAP32[$5 + 20 >> 2] = $1;
 HEAP32[$5 + 16 >> 2] = $1;
 sqlite3NestedParse($0, 29089, $5 + 16 | 0);
 if (!$2) {
  HEAP32[$5 + 8 >> 2] = $4;
  HEAP32[$5 + 4 >> 2] = $3;
  HEAP32[$5 >> 2] = $1;
  sqlite3NestedParse($0, 29264, $5);
 }
 __stack_pointer = $5 + 48 | 0;
}

function pcache1Unpin($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 label$1: {
  if (!$2) {
   $2 = HEAP32[$0 >> 2];
   if (HEAPU32[$2 + 16 >> 2] <= HEAPU32[$2 + 4 >> 2]) {
    break label$1;
   }
  }
  pcache1RemoveFromHash($1, 1);
  return;
 }
 HEAP32[$1 + 28 >> 2] = $2 + 20;
 $3 = $2;
 $2 = $2 + 44 | 0;
 $2 = HEAP32[$2 >> 2];
 HEAP32[$1 + 24 >> 2] = $2;
 HEAP32[$2 + 28 >> 2] = $1;
 HEAP32[$3 + 44 >> 2] = $1;
 HEAP32[$0 + 44 >> 2] = HEAP32[$0 + 44 >> 2] + 1;
}

function __mmap($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 if ($5 & 4095 | $6 & -4096) {
  HEAP32[__errno_location() >> 2] = 28;
  return -1;
 }
 if ($1 >>> 0 >= 2147483647) {
  HEAP32[__errno_location() >> 2] = 48;
  return -1;
 }
 $1 = __syscall_mmap2($0, $1, $2, $3, $4, ($6 & 4095) << 20 | $5 >>> 12);
 return __syscall_ret($0 ? $1 : ($1 | 0) != -63 ? $1 : $3 & 32 ? $3 & 16 ? -63 : -48 : -63) | 0;
}

function sqlite3ExprListSetSortOrder($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $3 = (HEAP32[$0 >> 2] - 1 << 4) + $0 | 0;
  $0 = ($1 | 0) == -1 ? 0 : $1;
  HEAP8[$3 + 16 | 0] = $0;
  if (($2 | 0) == -1) {
   break label$1;
  }
  $1 = $3 + 17 | 0;
  $4 = HEAPU8[$3 + 17 | 0] | HEAPU8[$3 + 18 | 0] << 8 | 32;
  HEAP8[$1 | 0] = $4;
  HEAP8[$1 + 1 | 0] = $4 >>> 8;
  if (($0 | 0) == ($2 | 0)) {
   break label$1;
  }
  HEAP8[$3 + 16 | 0] = $0 | 2;
 }
}

function rankStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 label$1: {
  $0 = sqlite3_aggregate_context($0, 24);
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[$0 + 12 >> 2];
  $3 = HEAP32[$0 + 8 >> 2] + 1 | 0;
  $1 = $3 ? $1 : $1 + 1 | 0;
  $2 = $1;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $1;
  $1 = HEAP32[$0 >> 2];
  if (HEAP32[$0 + 4 >> 2] | $1) {
   break label$1;
  }
  HEAP32[$0 >> 2] = $3;
  $1 = $2;
  HEAP32[$0 + 4 >> 2] = $1;
 }
}

function analyzeTable($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = sqlite3SchemaToIndex(HEAP32[$0 >> 2], HEAP32[$1 + 60 >> 2]);
 sqlite3BeginWriteOperation($0, 0, $3);
 $4 = HEAP32[$0 + 40 >> 2];
 HEAP32[$0 + 40 >> 2] = $4 + 3;
 label$1: {
  if ($2) {
   openStatTable($0, $3, $4, HEAP32[$2 >> 2], 1545);
   break label$1;
  }
  openStatTable($0, $3, $4, HEAP32[$1 >> 2], 11231);
 }
 analyzeOneTable($0, $1, $2, $4, HEAP32[$0 + 44 >> 2] + 1 | 0, HEAP32[$0 + 40 >> 2]);
 loadAnalysis($0, $3);
}

function pcache1Destroy($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 >> 2];
 if (HEAP32[$0 + 48 >> 2]) {
  pcache1TruncateUnsafe($0, 0);
 }
 $2 = HEAP32[$1 + 4 >> 2] - HEAP32[$0 + 28 >> 2] | 0;
 HEAP32[$1 + 4 >> 2] = $2;
 $3 = HEAP32[$1 + 8 >> 2] - HEAP32[$0 + 24 >> 2] | 0;
 HEAP32[$1 + 8 >> 2] = $3;
 HEAP32[$1 + 12 >> 2] = ($2 - $3 | 0) + 10;
 pcache1EnforceMaxPage($0);
 sqlite3_free(HEAP32[$0 + 64 >> 2]);
 sqlite3_free(HEAP32[$0 + 56 >> 2]);
 sqlite3_free($0);
}

function sqlite3WindowListDup($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 $4 = $2 + 12 | 0;
 while (1) {
  label$2: {
   if (!$1) {
    break label$2;
   }
   $3 = sqlite3WindowDup($0, 0, $1);
   HEAP32[$4 >> 2] = $3;
   if (!$3) {
    break label$2;
   }
   $4 = $3 + 36 | 0;
   $1 = HEAP32[$1 + 36 >> 2];
   continue;
  }
  break;
 }
 __stack_pointer = $2 + 16 | 0;
 $1 = HEAP32[$2 + 12 >> 2];
 return $1;
}

function walIndexClose($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!(HEAPU8[$0 + 50 | 0] ? 0 : HEAPU8[$0 + 43 | 0] != 2)) {
   while (1) {
    if (($2 | 0) < HEAP32[$0 + 24 >> 2]) {
     $3 = $2 << 2;
     sqlite3_free(HEAP32[$3 + HEAP32[$0 + 32 >> 2] >> 2]);
     HEAP32[HEAP32[$0 + 32 >> 2] + $3 >> 2] = 0;
     $2 = $2 + 1 | 0;
     continue;
    }
    break;
   }
   if (HEAPU8[$0 + 43 | 0] == 2) {
    break label$1;
   }
  }
  sqlite3OsShmUnmap(HEAP32[$0 + 4 >> 2], $1);
 }
}

function unixRead($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $4 = seekAndRead($0, $3, $4, $1, $2);
 $3 = 0;
 label$1: {
  if (($4 | 0) == ($2 | 0)) {
   break label$1;
  }
  if (($4 | 0) < 0) {
   $2 = HEAP32[$0 + 20 >> 2];
   $3 = 8458;
   if (($2 | 0) == 29 | ($2 | 0) == 60 | ($2 | 0) == 68) {
    break label$1;
   }
   return 266;
  }
  storeLastErrno($0, 0);
  memset($1 + $4 | 0, 0, $2 - $4 | 0);
  $3 = 522;
 }
 return $3 | 0;
}

function sqlite3Fts3Optimize($0) {
 var $1 = 0, $2 = 0;
 $1 = sqlite3_exec(HEAP32[$0 + 12 >> 2], 22840, 0, 0, 0);
 label$1: {
  if ($1) {
   break label$1;
  }
  $1 = fts3DoOptimize($0, 1);
  if (!($1 ? ($1 | 0) != 101 : 0)) {
   $2 = sqlite3_exec(HEAP32[$0 + 12 >> 2], 22872, 0, 0, 0);
   $1 = $2 ? $2 : $1;
   break label$1;
  }
  sqlite3_exec(HEAP32[$0 + 12 >> 2], 22855, 0, 0, 0);
  sqlite3_exec(HEAP32[$0 + 12 >> 2], 22872, 0, 0, 0);
 }
 sqlite3Fts3SegmentsClose($0);
 return $1;
}

function atn2Func($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 if (($1 | 0) == 2) {
  label$2: {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) != 5) {
    if ((sqlite3_value_type(HEAP32[$2 + 4 >> 2]) | 0) != 5) {
     break label$2;
    }
   }
   sqlite3_result_null($0);
   return;
  }
  sqlite3_result_double($0, atan2(sqlite3_value_double(HEAP32[$2 >> 2]), sqlite3_value_double(HEAP32[$2 + 4 >> 2])));
  return;
 }
 __assert_fail(23018, 17353, 570, 17289);
 abort();
}

function sqlite3Malloc($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = $0 >>> 0 < 2147483392;
 $3 = $1 - $3 | 0;
 $1 = 0;
 label$1: {
  if (($3 | 0) == -1 & $0 - 2147483392 >>> 0 < 2147483905 | ($3 | 0) != -1) {
   break label$1;
  }
  if (HEAP32[16068]) {
   mallocWithAlarm($0, $2 + 12 | 0);
   $1 = HEAP32[$2 + 12 >> 2];
   break label$1;
  }
  $1 = FUNCTION_TABLE[HEAP32[16076]]($0) | 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function sqlite3BtreeCommitPhaseTwo($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!HEAPU8[$0 + 8 | 0]) {
   break label$1;
  }
  sqlite3BtreeEnter($0);
  if (HEAPU8[$0 + 8 | 0] == 2) {
   $2 = HEAP32[$0 + 4 >> 2];
   $3 = sqlite3PagerCommitPhaseTwo(HEAP32[$2 >> 2]);
   if (!($3 ? $1 : 1)) {
    break label$1;
   }
   HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] - 1;
   HEAP8[$2 + 20 | 0] = 1;
   btreeClearHasContent($2);
  }
  btreeEndTransaction($0);
  $3 = 0;
 }
 return $3;
}

function printfTempBuf($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (HEAPU8[$0 + 20 | 0]) {
   break label$1;
  }
  label$2: {
   if (HEAPU32[$0 + 8 >> 2] < $1 >>> 0 & ($2 | 0) >= 0 | ($2 | 0) > 0) {
    $3 = 18;
    if (HEAPU32[$0 + 12 >> 2] < $1 >>> 0 & ($2 | 0) >= 0 | ($2 | 0) > 0) {
     break label$2;
    }
   }
   $3 = sqlite3DbMallocRaw(HEAP32[$0 >> 2], $1, $2);
   if ($3) {
    break label$1;
   }
   $3 = 7;
  }
  sqlite3StrAccumSetError($0, $3);
  $3 = 0;
 }
 return $3;
}

function sqlite3MallocInit() {
 var $0 = 0;
 if (!HEAP32[16076]) {
  sqlite3MemSetDefault();
 }
 HEAP32[17616] = 8;
 if (!(!(!HEAP32[16114] | HEAP32[16115] < 512) & HEAP32[16116] > 0)) {
  HEAP32[16114] = 0;
  HEAP32[16115] = 0;
 }
 $0 = FUNCTION_TABLE[HEAP32[16081]](HEAP32[16083]) | 0;
 if ($0) {
  HEAP32[17622] = 0;
  HEAP32[17623] = 0;
  HEAP32[17620] = 0;
  HEAP32[17621] = 0;
  HEAP32[17618] = 0;
  HEAP32[17619] = 0;
  HEAP32[17616] = 0;
  HEAP32[17617] = 0;
 }
 return $0;
}

function rowSetTreeToList($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 while (1) {
  $3 = $0;
  $0 = HEAP32[$3 + 12 >> 2];
  label$2: {
   if ($0) {
    rowSetTreeToList($0, $1, $4 + 12 | 0);
    HEAP32[HEAP32[$4 + 12 >> 2] + 8 >> 2] = $3;
    break label$2;
   }
   HEAP32[$1 >> 2] = $3;
  }
  $1 = $3 + 8 | 0;
  $0 = HEAP32[$3 + 8 >> 2];
  if ($0) {
   continue;
  }
  break;
 }
 HEAP32[$2 >> 2] = $3;
 __stack_pointer = $4 + 16 | 0;
}

function parserAddExprIdListTerm($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 $1 = sqlite3ExprListAppend($0, $1, 0);
 if (!(HEAPU8[HEAP32[$0 >> 2] + 177 | 0] | !$3 & ($4 | 0) == -1)) {
  HEAP32[$5 >> 2] = __wasm_rotl_i64(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2], 32, 0);
  HEAP32[$5 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
  sqlite3ErrorMsg($0, 28453, $5);
 }
 sqlite3ExprListSetName($0, $1, $2, 1);
 __stack_pointer = $5 + 16 | 0;
 return $1;
}

function estimateIndexWidth($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $5 = HEAPU16[$0 + 52 >> 1];
 $6 = HEAP32[HEAP32[$0 + 12 >> 2] + 4 >> 2];
 while (1) {
  if (($1 | 0) != ($5 | 0)) {
   $2 = 1;
   $3 = HEAP16[HEAP32[$0 + 4 >> 2] + ($1 << 1) >> 1];
   if (($3 | 0) >= 0) {
    $2 = HEAPU8[(Math_imul($3 & 65535, 12) + $6 | 0) + 6 | 0];
   }
   $1 = $1 + 1 | 0;
   $4 = $2 + $4 | 0;
   continue;
  }
  break;
 }
 HEAP16[$0 + 48 >> 1] = sqlite3LogEst($4 << 2, 0);
}

function sqlite3ColumnSetExpr($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = HEAPU16[$2 + 8 >> 1];
 $4 = HEAP32[$1 + 52 >> 2];
 if (!(!(!$5 | !$4) & HEAP32[$4 >> 2] >= ($5 | 0))) {
  $5 = $4 ? HEAPU16[$4 >> 1] + 1 | 0 : 1;
  HEAP16[$2 + 8 >> 1] = $5;
  HEAP32[$1 + 52 >> 2] = sqlite3ExprListAppend($0, $4, $3);
  return;
 }
 $4 = $4 + 8 | 0;
 sqlite3ExprDelete(HEAP32[$0 >> 2], HEAP32[($4 + ($5 << 4) | 0) - 16 >> 2]);
 HEAP32[((HEAPU16[$2 + 8 >> 1] << 4) + $4 | 0) - 16 >> 2] = $3;
}

function sqlite3BtreeLast($0, $1) {
 var $2 = 0;
 if (!(HEAPU8[$0 | 0] | !(HEAPU8[$0 + 1 | 0] & 8))) {
  HEAP32[$1 >> 2] = 0;
  return 0;
 }
 $2 = moveToRoot($0);
 label$2: {
  if (($2 | 0) != 16) {
   if ($2) {
    break label$2;
   }
   HEAP32[$1 >> 2] = 0;
   $2 = moveToRightmost($0);
   $1 = HEAPU8[$0 + 1 | 0];
   if (!$2) {
    HEAP8[$0 + 1 | 0] = $1 | 8;
    return 0;
   }
   HEAP8[$0 + 1 | 0] = $1 & 247;
   return $2;
  }
  HEAP32[$1 >> 2] = 1;
  $2 = 0;
 }
 return $2;
}

function simpleOpen($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $0 = sqlite3_malloc(28);
 if (!$0) {
  return 7;
 }
 HEAP32[$0 + 4 >> 2] = $1;
 label$2: {
  if (!$1) {
   break label$2;
  }
  $4 = $2;
  if (($4 | 0) >= 0) {
   break label$2;
  }
  $4 = strlen($1);
 }
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = $4;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$3 >> 2] = $0;
 return 0;
}

function porterOpen($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $0 = sqlite3_malloc(28);
 if (!$0) {
  return 7;
 }
 HEAP32[$0 + 4 >> 2] = $1;
 label$2: {
  if (!$1) {
   break label$2;
  }
  $4 = $2;
  if (($4 | 0) >= 0) {
   break label$2;
  }
  $4 = strlen($1);
 }
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = $4;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$3 >> 2] = $0;
 return 0;
}

function renumberCursors($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 srclistRenumberCursors($0, $3, HEAP32[$1 + 32 >> 2], $2);
 $2 = $4 + 8 | 0;
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$4 + 16 >> 2] = 0;
 HEAP32[$4 + 20 >> 2] = 0;
 HEAP32[$4 + 8 >> 2] = 50;
 HEAP32[$4 >> 2] = 0;
 HEAP32[$4 + 4 >> 2] = 0;
 HEAP32[$4 + 24 >> 2] = $3;
 HEAP32[$4 + 4 >> 2] = 79;
 sqlite3WalkSelect($4, $1);
 __stack_pointer = $4 + 32 | 0;
}

function vtabDisconnectAll($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = $1 + 52 | 0;
 $4 = HEAP32[$2 >> 2];
 HEAP32[$1 + 52 >> 2] = 0;
 while (1) {
  $2 = $4;
  if ($2) {
   $4 = HEAP32[$2 + 24 >> 2];
   $3 = HEAP32[$2 >> 2];
   if (($3 | 0) == ($0 | 0)) {
    HEAP32[$1 + 52 >> 2] = $2;
    HEAP32[$2 + 24 >> 2] = 0;
    $5 = $2;
   } else {
    HEAP32[$2 + 24 >> 2] = HEAP32[$3 + 408 >> 2];
    HEAP32[$3 + 408 >> 2] = $2;
   }
   continue;
  }
  break;
 }
 return $5;
}

function finalDbSize($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = ptrmapPageno($0, $1) + ($2 - $1 | 0) | 0;
 $3 = HEAPU32[$0 + 40 >> 2] / 5 | 0;
 $2 = $1 - ((($4 + $3 >>> 0) / ($3 >>> 0) | 0) + $2 | 0) | 0;
 $3 = (HEAPU32[16232] / HEAPU32[$0 + 36 >> 2] | 0) + 1 | 0;
 $2 = $2 - ($3 >>> 0 < $1 >>> 0 & $2 >>> 0 < $3 >>> 0) | 0;
 while (1) {
  $1 = $2;
  $2 = $1 - 1 | 0;
  if ((ptrmapPageno($0, $1) | 0) == ($1 | 0) | ($1 | 0) == ($3 | 0)) {
   continue;
  }
  break;
 }
 return $1;
}

function sqlite3MemRealloc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = dlrealloc($0 - 8 | 0, $1 + 8 | 0);
 label$1: {
  if ($3) {
   HEAP32[$3 >> 2] = $1;
   HEAP32[$3 + 4 >> 2] = $1 >> 31;
   $1 = $3 + 8 | 0;
   break label$1;
  }
  $0 = sqlite3MemSize($0);
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = $0;
  sqlite3_log(7, 5077, $2);
  $1 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $1 | 0;
}

function fts3SegReaderCursorAppend($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $2 = HEAP32[$0 + 4 >> 2];
  label$2: {
   if ($2 & 15) {
    $3 = HEAP32[$0 >> 2];
    break label$2;
   }
   $3 = sqlite3_realloc64(HEAP32[$0 >> 2], ($2 << 2) - -64 | 0, 0);
   if (!$3) {
    break label$1;
   }
   HEAP32[$0 >> 2] = $3;
   $2 = HEAP32[$0 + 4 >> 2];
  }
  HEAP32[$0 + 4 >> 2] = $2 + 1;
  HEAP32[($2 << 2) + $3 >> 2] = $1;
  return 0;
 }
 sqlite3Fts3SegReaderFree($1);
 return 7;
}

function sqlite3Fts3MsrIncrRestart($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 HEAP32[$0 + 28 >> 2] = 1;
 HEAP32[$0 + 8 >> 2] = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 $3 = ($1 | 0) > 0 ? $1 : 0;
 $1 = 0;
 while (1) {
  if (($1 | 0) != ($3 | 0)) {
   $2 = HEAP32[$0 >> 2] + ($1 << 2) | 0;
   HEAP32[HEAP32[$2 >> 2] + 80 >> 2] = 0;
   $2 = HEAP32[$2 >> 2];
   HEAP32[$2 + 88 >> 2] = 0;
   HEAP32[$2 + 92 >> 2] = 0;
   HEAP32[$2 + 84 >> 2] = 0;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
}

function setPragmaResultColumnNames($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU8[$1 + 7 | 0];
 sqlite3VdbeSetNumCols($0, $2 ? $2 : 1);
 label$1: {
  if (!$2) {
   sqlite3VdbeSetColName($0, 0, 0, HEAP32[$1 >> 2], 0);
   break label$1;
  }
  $3 = HEAPU8[$1 + 6 | 0];
  $1 = 0;
  while (1) {
   if (($1 | 0) == ($2 | 0)) {
    break label$1;
   }
   sqlite3VdbeSetColName($0, $1, 0, HEAP32[($3 << 2) + 35600 >> 2], 0);
   $3 = $3 + 1 | 0;
   $1 = $1 + 1 | 0;
   continue;
  }
 }
}

function fixDistinctOpenEph($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  if (HEAP32[$0 + 36 >> 2] | $1 - 1 >>> 0 > 1) {
   break label$1;
  }
  $0 = HEAP32[$0 + 8 >> 2];
  sqlite3VdbeChangeToNoop($0, $3);
  $4 = $3 + 1 | 0;
  if (HEAPU8[sqlite3VdbeGetOp($0, $4) | 0] == 185) {
   sqlite3VdbeChangeToNoop($0, $4);
  }
  if (($1 | 0) != 2) {
   break label$1;
  }
  $0 = sqlite3VdbeGetOp($0, $3);
  HEAP32[$0 + 8 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = 1;
  HEAP8[$0 | 0] = 75;
 }
}

function fchmod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $3 = __syscall_fchmod($0 | 0, $1 | 0) | 0;
 label$1: {
  if (($3 | 0) != -8) {
   $0 = __syscall_ret($3);
   break label$1;
  }
  if (!__wasi_fd_is_valid($0)) {
   $0 = __syscall_ret(-8);
   break label$1;
  }
  __procfdname($2, $0);
  $0 = __syscall_ret(__syscall_chmod($2 | 0, $1 | 0) | 0);
 }
 __stack_pointer = $2 + 32 | 0;
 return $0 | 0;
}

function sqlite3VdbeDelete($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 >> 2];
 sqlite3VdbeClearObject($2, $0);
 label$1: {
  if (HEAP32[$2 + 528 >> 2]) {
   break label$1;
  }
  $1 = HEAP32[$0 + 8 >> 2];
  $3 = HEAP32[$0 + 4 >> 2];
  label$2: {
   if ($3) {
    HEAP32[$3 + 8 >> 2] = $1;
    $1 = HEAP32[$0 + 8 >> 2];
    break label$2;
   }
   HEAP32[$2 + 4 >> 2] = $1;
  }
  if (!$1) {
   break label$1;
  }
  HEAP32[$1 + 4 >> 2] = $3;
 }
 sqlite3DbFreeNN($2, $0);
}

function sqlite3ColumnIndex($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = sqlite3StrIHash($1);
 $2 = HEAP16[$0 + 34 >> 1];
 $2 = ($2 | 0) > 0 ? $2 : 0;
 $0 = HEAP32[$0 + 4 >> 2];
 while (1) {
  label$2: {
   if (($3 | 0) == ($2 | 0)) {
    $3 = -1;
    break label$2;
   }
   if (HEAPU8[$0 + 7 | 0] == ($4 | 0)) {
    if (!sqlite3StrICmp(HEAP32[$0 >> 2], $1)) {
     break label$2;
    }
   }
   $3 = $3 + 1 | 0;
   $0 = $0 + 12 | 0;
   continue;
  }
  break;
 }
 return $3;
}

function rowSetNDeepTree($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 >> 2];
 if (!$2) {
  return 0;
 }
 if (($1 | 0) >= 2) {
  $3 = $1 - 1 | 0;
  $1 = rowSetNDeepTree($0, $3);
  $2 = HEAP32[$0 >> 2];
  if (!$2) {
   return $1;
  }
  HEAP32[$2 + 12 >> 2] = $1;
  HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
  HEAP32[$2 + 8 >> 2] = rowSetNDeepTree($0, $3);
  return $2;
 }
 HEAP32[$0 >> 2] = HEAP32[$2 + 8 >> 2];
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 return $2;
}

function jsonRemoveAllNulls($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 $2 = 2;
 while (1) {
  if (($2 | 0) <= ($4 | 0)) {
   $1 = Math_imul($2, 12) + $0 | 0;
   $3 = HEAPU8[$1 | 0];
   label$3: {
    if (($3 | 0) != 7) {
     if ($3) {
      break label$3;
     }
     HEAP8[$1 + 1 | 0] = HEAPU8[$1 + 1 | 0] | 4;
     break label$3;
    }
    jsonRemoveAllNulls($1);
   }
   $2 = (jsonNodeSize($1) + $2 | 0) + 1 | 0;
   continue;
  }
  break;
 }
}

function fts3GetReverseVarint($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = HEAP32[$0 >> 2] - 2 | 0;
 while (1) {
  if (!($1 >>> 0 > $3 >>> 0 | HEAP8[$3 | 0] >= 0)) {
   $3 = $3 - 1 | 0;
   continue;
  }
  break;
 }
 $3 = $3 + 1 | 0;
 HEAP32[$0 >> 2] = $3;
 sqlite3Fts3GetVarint($3, $4 + 8 | 0);
 $0 = HEAP32[$4 + 12 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$4 + 8 >> 2];
 HEAP32[$2 + 4 >> 2] = $0;
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3VdbeFinishMoveto($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $2 = sqlite3BtreeTableMoveto(HEAP32[$0 + 36 >> 2], HEAP32[$0 + 56 >> 2], HEAP32[$0 + 60 >> 2], 0, $1 + 12 | 0);
 label$1: {
  if ($2) {
   break label$1;
  }
  if (HEAP32[$1 + 12 >> 2]) {
   $2 = sqlite3CorruptError(84317);
   break label$1;
  }
  $2 = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  HEAP8[$0 + 3 | 0] = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function vfsUnlink($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[17614];
  if (($1 | 0) == ($0 | 0)) {
   $1 = 70456;
  } else {
   if (!$1) {
    break label$1;
   }
   while (1) {
    $2 = $1;
    $1 = HEAP32[$1 + 12 >> 2];
    if (($0 | 0) != ($1 | 0) ? $1 : 0) {
     continue;
    }
    break;
   }
   if (($0 | 0) != ($1 | 0)) {
    break label$1;
   }
   $1 = $2 + 12 | 0;
  }
  HEAP32[$1 >> 2] = HEAP32[$0 + 12 >> 2];
 }
}

function jsonArrayStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $1 = sqlite3_aggregate_context($0, 128);
 if ($1) {
  label$2: {
   label$3: {
    if (!HEAP32[$1 + 4 >> 2]) {
     jsonInit($1, $0);
     $3 = 91;
     break label$3;
    }
    $3 = 44;
    if (!HEAP32[$1 + 20 >> 2] & HEAPU32[$1 + 16 >> 2] < 2) {
     break label$2;
    }
   }
   jsonAppendChar($1, $3);
  }
  HEAP32[$1 >> 2] = $0;
  jsonAppendValue($1, HEAP32[$2 >> 2]);
 }
}

function sqliteErrorFromPosixError($0) {
 var $1 = 0;
 $1 = 5;
 label$1: {
  label$2: {
   label$3: {
    switch ($0 - 6 | 0) {
    case 0:
    case 4:
     break label$1;

    case 1:
    case 2:
    case 3:
     break label$2;

    default:
     break label$3;
    }
   }
   if (($0 | 0) == 2 | ($0 | 0) == 27 | (($0 | 0) == 46 | ($0 | 0) == 73)) {
    break label$1;
   }
   if (($0 | 0) != 63) {
    break label$2;
   }
   return 3;
  }
  $1 = 3850;
 }
 return $1;
}

function sqlite3UpsertNew($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = sqlite3DbMallocZero($0, 48, 0);
 if (!$6) {
  sqlite3ExprListDelete($0, $1);
  sqlite3ExprDelete($0, $2);
  sqlite3ExprListDelete($0, $3);
  sqlite3ExprDelete($0, $4);
  sqlite3UpsertDelete($0, $5);
  return $6;
 }
 HEAP32[$6 + 12 >> 2] = $4;
 HEAP32[$6 + 8 >> 2] = $3;
 HEAP32[$6 + 4 >> 2] = $2;
 HEAP32[$6 >> 2] = $1;
 HEAP32[$6 + 16 >> 2] = $5;
 HEAP8[$6 + 20 | 0] = ($3 | 0) != 0;
 return $6;
}

function sqlite3KeyInfoAlloc($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = $1 + $2 | 0;
 $4 = Math_imul($3, 5);
 $2 = sqlite3DbMallocRawNN($0, $4 + 20 | 0, 0);
 if ($2) {
  HEAP16[$2 + 8 >> 1] = $3;
  HEAP16[$2 + 6 >> 1] = $1;
  HEAP32[$2 + 16 >> 2] = (($3 << 2) + $2 | 0) + 20;
  $1 = HEAPU8[$0 + 84 | 0];
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP8[$2 + 4 | 0] = $1;
  HEAP32[$2 >> 2] = 1;
  memset($2 + 24 | 0, 0, $4 - 4 | 0);
  return $2;
 }
 sqlite3OomFault($0);
 return $2;
}

function updateRangeAffinityStr($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $5 = ($1 | 0) > 0 ? $1 : 0;
 while (1) {
  if (($3 | 0) != ($5 | 0)) {
   $4 = sqlite3VectorFieldSubexpr($0, $3);
   $1 = $2 + $3 | 0;
   label$3: {
    if ((sqlite3CompareAffinity($4, HEAP8[$1 | 0]) | 0) != 65) {
     if (!sqlite3ExprNeedsNoAffinityChange($4, HEAP8[$1 | 0])) {
      break label$3;
     }
    }
    HEAP8[$1 | 0] = 65;
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
}

function sqlite3ExprReferencesUpdatedColumn($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 16 >> 2] = 0;
 HEAP32[$3 + 20 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 >> 2] = 0;
 HEAP32[$3 + 4 >> 2] = 0;
 HEAP32[$3 + 24 >> 2] = $1;
 HEAP32[$3 + 4 >> 2] = 57;
 sqlite3WalkExpr($3, $0);
 __stack_pointer = $3 + 32 | 0;
 $1 = HEAPU16[$3 + 20 >> 1];
 return (($2 ? $1 : $1 & 65533) | 0) != 0;
}

function sqlite3ColumnColl($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAPU16[$0 + 10 >> 1];
 if ($1 & 512) {
  $2 = HEAP32[$0 >> 2];
  while (1) {
   $0 = $2;
   $2 = $0 + 1 | 0;
   if (HEAPU8[$0 | 0]) {
    continue;
   }
   break;
  }
  label$3: {
   if (!($1 & 4)) {
    $1 = $0;
    break label$3;
   }
   while (1) {
    $2 = HEAPU8[$0 + 1 | 0];
    $1 = $0 + 1 | 0;
    $0 = $1;
    if ($2) {
     continue;
    }
    break;
   }
  }
  $2 = $1 + 1 | 0;
 }
 return $2;
}

function exprIsDeterministic($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = 0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 24 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 59;
 HEAP32[$1 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = 81;
 HEAP16[$1 + 20 >> 1] = 1;
 sqlite3WalkExpr($1, $0);
 __stack_pointer = $1 + 32 | 0;
 $0 = HEAPU16[$1 + 20 >> 1];
 return $0;
}

function vdbeSorterMapFile($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  $4 = HEAP32[$1 + 8 >> 2];
  $5 = $4;
  $3 = HEAP32[$1 + 12 >> 2];
  $6 = $3;
  $3 = HEAP32[HEAP32[HEAP32[$0 + 8 >> 2] + 24 >> 2] + 168 >> 2];
  $4 = $3 >> 31;
  $0 = $4;
  $5 = $5 >>> 0 > $3 >>> 0;
  $4 = $6;
  $3 = $0;
  if ($5 & ($4 | 0) >= ($3 | 0) | ($4 | 0) > ($3 | 0) | HEAP32[HEAP32[HEAP32[$1 >> 2] >> 2] >> 2] < 3) {
   break label$1;
  }
  sqlite3OsFetch($2);
 }
}

function vdbeChangeP4Full($0, $1, $2, $3) {
 var $4 = 0;
 $4 = HEAP8[$1 + 1 | 0];
 if ($4) {
  freeP4(HEAP32[$0 >> 2], $4, HEAP32[$1 + 16 >> 2]);
  HEAP32[$1 + 16 >> 2] = 0;
  HEAP8[$1 + 1 | 0] = 0;
 }
 if (($3 | 0) < 0) {
  sqlite3VdbeChangeP4($0, ($1 - HEAP32[$0 + 104 >> 2] | 0) / 20 | 0, $2, $3);
  return;
 }
 if (!$3) {
  $3 = sqlite3Strlen30($2);
 }
 $3 = sqlite3DbStrNDup(HEAP32[$0 >> 2], $2, $3, 0);
 HEAP8[$1 + 1 | 0] = 250;
 HEAP32[$1 + 16 >> 2] = $3;
}

function sqlite3BtreeCommitPhaseOne($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (HEAPU8[$0 + 8 | 0] != 2) {
   break label$1;
  }
  $2 = HEAP32[$0 + 4 >> 2];
  sqlite3BtreeEnter($0);
  if (HEAPU8[$2 + 17 | 0]) {
   $3 = autoVacuumCommit($0);
   if ($3) {
    break label$1;
   }
  }
  if (HEAPU8[$2 + 19 | 0]) {
   sqlite3PagerTruncateImage(HEAP32[$2 >> 2], HEAP32[$2 + 48 >> 2]);
  }
  $3 = sqlite3PagerCommitPhaseOne(HEAP32[$2 >> 2], $1, 0);
 }
 return $3;
}

function exprMightBeIndexed($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = HEAPU8[$4 | 0];
 if (!(($6 | 0) != 177 | $5 - 54 >>> 0 > 3)) {
  $4 = HEAP32[HEAP32[$4 + 20 >> 2] + 8 >> 2];
  $6 = HEAPU8[$4 | 0];
 }
 if (($6 & 255) == 167) {
  HEAP32[$3 >> 2] = HEAP32[$4 + 28 >> 2];
  HEAP32[$3 + 4 >> 2] = HEAP16[$4 + 32 >> 1];
  return 1;
 }
 $6 = 0;
 if (!(!($1 | $2) | ($1 - 1 & $1 | $2 & $2 - !$1))) {
  $6 = exprMightBeIndexed2($0, $1, $2, $3, $4);
 }
 return $6;
}

function tabIsReadOnly($0, $1) {
 var $2 = 0, $3 = 0;
 if (HEAPU8[$1 + 43 | 0] == 1) {
  return !HEAP32[HEAP32[HEAP32[sqlite3GetVTable(HEAP32[$0 >> 2], $1) + 4 >> 2] >> 2] + 52 >> 2];
 }
 $1 = HEAP32[$1 + 28 >> 2];
 label$2: {
  if (!($1 & 4097)) {
   break label$2;
  }
  $2 = HEAP32[$0 >> 2];
  if ($1 & 1) {
   if (sqlite3WritableSchema($2)) {
    break label$2;
   }
   return !HEAPU8[$0 + 18 | 0];
  }
  $3 = sqlite3ReadOnlyShadowTables($2);
 }
 return $3;
}

function generateColumnTypes($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 $5 = HEAP32[$0 + 8 >> 2];
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 >> 2] = $0;
 HEAP32[$3 + 4 >> 2] = $1;
 while (1) {
  if (($4 | 0) < HEAP32[$2 >> 2]) {
   sqlite3VdbeSetColName($5, $4, 1, columnTypeImpl($3, HEAP32[(($4 << 4) + $2 | 0) + 8 >> 2]), -1);
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 __stack_pointer = $3 + 32 | 0;
}

function sqlite3VdbeMemFromBtreeZeroOffset($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = sqlite3BtreePayloadFetch($0, $3 + 12 | 0);
 label$1: {
  if (HEAPU32[$3 + 12 >> 2] >= $1 >>> 0) {
   HEAP32[$2 + 12 >> 2] = $1;
   HEAP16[$2 + 16 >> 1] = 16400;
   break label$1;
  }
  $4 = sqlite3VdbeMemFromBtree($0, 0, $1, $2);
 }
 __stack_pointer = $3 + 16 | 0;
 return $4;
}

function sqlite3Fts3PendingTermsClear($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 while (1) {
  if (($2 | 0) < HEAP32[$0 + 256 >> 2]) {
   $3 = HEAP32[$0 + 260 >> 2] + Math_imul($2, 24) | 0;
   $1 = $3 + 12 | 0;
   while (1) {
    $1 = HEAP32[$1 >> 2];
    if ($1) {
     fts3PendingListDelete(HEAP32[$1 + 8 >> 2]);
     continue;
    }
    break;
   }
   sqlite3Fts3HashClear($3 + 4 | 0);
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 + 268 >> 2] = 0;
}

function sqlite3CodeVerifyNamedSchema($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$0 >> 2];
 while (1) {
  if (($2 | 0) < HEAP32[$3 + 20 >> 2]) {
   $4 = HEAP32[$3 + 16 >> 2] + ($2 << 4) | 0;
   label$3: {
    if (!HEAP32[$4 + 4 >> 2]) {
     break label$3;
    }
    if ($1) {
     if (sqlite3StrICmp($1, HEAP32[$4 >> 2])) {
      break label$3;
     }
    }
    sqlite3CodeVerifySchema($0, $2);
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
}

function jsonParseAddNode($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  $4 = HEAP32[$0 + 8 >> 2];
  if ($4) {
   $5 = HEAP32[$0 >> 2];
   if ($5 >>> 0 < HEAPU32[$0 + 4 >> 2]) {
    break label$1;
   }
  }
  return jsonParseAddNodeExpand($0, $1, $2, $3);
 }
 $4 = Math_imul($5, 12) + $4 | 0;
 HEAP32[$4 + 8 >> 2] = $3;
 HEAP32[$4 + 4 >> 2] = $2;
 HEAP8[$4 + 1 | 0] = 0;
 HEAP8[$4 | 0] = $1;
 $3 = HEAP32[$0 >> 2];
 HEAP32[$0 >> 2] = $3 + 1;
 return $3;
}

function sqlite3VdbeSorterRowkey($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = 7;
 $4 = vdbeSorterRowkey(HEAP32[$0 + 36 >> 2], $2 + 12 | 0);
 $0 = HEAP32[$2 + 12 >> 2];
 if (!sqlite3VdbeMemClearAndResize($1, $0)) {
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP16[$1 + 16 >> 1] = HEAPU16[$1 + 16 >> 1] & 62016 | 16;
  __memcpy(HEAP32[$1 + 8 >> 2], $4, $0);
  $3 = 0;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function jsonTypeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 label$1: {
  $3 = jsonParseCached($0, $2, $0);
  if (!$3) {
   break label$1;
  }
  label$2: {
   if (($1 | 0) == 2) {
    $2 = jsonLookup($3, sqlite3_value_text(HEAP32[$2 + 4 >> 2]), 0, $0);
    break label$2;
   }
   $2 = HEAP32[$3 + 8 >> 2];
  }
  if (!$2) {
   break label$1;
  }
  sqlite3_result_text($0, HEAP32[(HEAPU8[$2 | 0] << 2) + 51152 >> 2], -1, 0);
 }
}

function whereLoopXfer($0, $1, $2) {
 whereLoopClearUnion($0, $1);
 if (whereLoopResize($0, $1, HEAPU16[$2 + 44 >> 1])) {
  memset($1, 0, 48);
  return 7;
 }
 $1 = __memcpy($1, $2, 48);
 __memcpy(HEAP32[$1 + 52 >> 2], HEAP32[$2 + 52 >> 2], HEAPU16[$1 + 44 >> 1] << 2);
 $1 = HEAP32[$2 + 40 >> 2];
 if ($1 & 1024) {
  $1 = $2 + 28 | 0;
  HEAP8[$1 | 0] = HEAPU8[$2 + 28 | 0] & 254;
  return 0;
 }
 if ($1 & 16384) {
  HEAP32[$2 + 32 >> 2] = 0;
 }
 return 0;
}

function renameColumnTokenNext($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 >> 2];
 $1 = $2;
 while (1) {
  $1 = HEAP32[$1 + 12 >> 2];
  if ($1) {
   $2 = HEAPU32[$1 + 4 >> 2] > HEAPU32[$2 + 4 >> 2] ? $1 : $2;
   continue;
  } else {
   while (1) {
    $3 = $0;
    $1 = HEAP32[$0 >> 2];
    $0 = $1 + 12 | 0;
    if (($2 | 0) != ($1 | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$3 >> 2] = HEAP32[$2 + 12 >> 2];
  }
  break;
 }
 return $2;
}

function pragmaLocate($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = 65;
 while (1) {
  label$2: {
   $5 = ($2 | 0) < ($4 | 0);
   if ($5) {
    break label$2;
   }
   $3 = ($2 + $4 | 0) / 2 | 0;
   $1 = sqlite3_stricmp($0, HEAP32[($3 << 4) + 34544 >> 2]);
   if (!$1) {
    break label$2;
   }
   $1 = ($1 | 0) < 0;
   $2 = $1 ? $3 - 1 | 0 : $2;
   $4 = $1 ? $4 : $3 + 1 | 0;
   continue;
  }
  break;
 }
 return $5 ? 0 : ($3 << 4) + 34544 | 0;
}

function sqlite3VdbeCreate($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 >> 2];
 $1 = sqlite3DbMallocRawNN($2, 240, 0);
 if ($1) {
  memset($1 + 104 | 0, 0, 136);
  HEAP32[$1 >> 2] = $2;
  $3 = HEAP32[$2 + 4 >> 2];
  if ($3) {
   HEAP32[$3 + 4 >> 2] = $1;
  }
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$1 + 12 >> 2] = $0;
  HEAP32[$0 + 8 >> 2] = $1;
  sqlite3VdbeAddOp2($1, 64, 0, 1);
 }
 return $1;
}

function sqlite3ExprListAppendGrow($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$1 + 4 >> 2];
 HEAP32[$1 + 4 >> 2] = $3 << 1;
 $3 = sqlite3DbRealloc($0, $1, $3 << 5 | 8, 0);
 if (!$3) {
  sqlite3ExprListDelete($0, $1);
  sqlite3ExprDelete($0, $2);
  return $3;
 }
 $1 = HEAP32[$3 >> 2];
 HEAP32[$3 >> 2] = $1 + 1;
 $1 = ($1 << 4) + $3 | 0;
 HEAP32[$1 + 20 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 HEAP32[$1 + 16 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = $2;
 return $3;
}

function isSetNullAction($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 116 >> 2];
 $0 = HEAP32[($2 ? $2 : $0) + 124 >> 2];
 $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $0 = HEAP32[$0 >> 2];
  if (($0 | 0) == HEAP32[$1 + 28 >> 2]) {
   $2 = 1;
   if (HEAPU8[$1 + 25 | 0] == 8) {
    break label$1;
   }
  }
  if (HEAP32[$1 + 32 >> 2] == ($0 | 0)) {
   $2 = 1;
   if (HEAPU8[$1 + 26 | 0] == 8) {
    break label$1;
   }
  }
  $2 = 0;
 }
 return $2;
}

function moveToRightmost($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  while (1) {
   $1 = HEAP32[$0 + 116 >> 2];
   if (!HEAPU8[$1 + 8 | 0]) {
    $2 = sqlite3Get4byte((HEAPU8[$1 + 9 | 0] + HEAP32[$1 + 56 >> 2] | 0) + 8 | 0);
    HEAP16[$0 + 70 >> 1] = HEAPU16[$1 + 24 >> 1];
    $1 = moveToChild($0, $2);
    if (!$1) {
     continue;
    }
    break label$1;
   }
   break;
  }
  HEAP16[$0 + 70 >> 1] = HEAPU16[$1 + 24 >> 1] - 1;
  $1 = 0;
 }
 return $1;
}

function fts3IncrmergeOutputIdx($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 $0 = fts3SqlStmt($0, 8, $4 + 12 | 0, 0);
 if (!$0) {
  $1 = $1 + 1 | 0;
  $2 = $1 ? $2 : $2 + 1 | 0;
  $0 = HEAP32[$4 + 12 >> 2];
  sqlite3_bind_int64($0, 1, $1, $2);
  sqlite3_step($0);
  HEAP32[$3 >> 2] = sqlite3_column_int($0, 0);
  $0 = sqlite3_reset($0);
 }
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function sqlite3VdbeAddOp3($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP32[$0 + 108 >> 2];
 if (($5 | 0) >= HEAP32[$0 + 112 >> 2]) {
  return growOp3($0, $1, $2, $3, $4);
 }
 HEAP32[$0 + 108 >> 2] = $5 + 1;
 $0 = HEAP32[$0 + 104 >> 2] + Math_imul($5, 20) | 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = $4;
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP16[$0 + 2 >> 1] = 0;
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = 0;
 return $5;
}

function sqlite3HexToBlob($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = sqlite3DbMallocRawNN($0, (($2 | 0) / 2 | 0) + 1 | 0, 0);
 if ($3) {
  $4 = $2 - 1 | 0;
  $2 = 0;
  while (1) {
   if (($2 | 0) < ($4 | 0)) {
    $0 = sqlite3HexToInt(HEAP8[$1 + $2 | 0]);
    HEAP8[($2 >>> 1 | 0) + $3 | 0] = sqlite3HexToInt(HEAP8[($2 | 1) + $1 | 0]) | $0 << 4;
    $2 = $2 + 2 | 0;
    continue;
   }
   break;
  }
  HEAP8[($2 >>> 1 | 0) + $3 | 0] = 0;
 }
 return $3;
}

function recomputeColumnsUsedExpr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $0 = HEAP32[$0 + 24 >> 2];
  if (HEAP32[$0 + 40 >> 2] != HEAP32[$1 + 28 >> 2] | HEAP16[$1 + 32 >> 1] < 0) {
   break label$1;
  }
  $2 = HEAP32[$0 + 52 >> 2];
  HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] | sqlite3ExprColUsed($1);
  HEAP32[$0 + 52 >> 2] = i64toi32_i32$HIGH_BITS | $2;
 }
 return 0;
}

function dotlockUnlock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 label$1: {
  if (HEAPU8[$0 + 16 | 0] == ($1 | 0)) {
   break label$1;
  }
  if (($1 | 0) == 1) {
   HEAP8[$0 + 16 | 0] = 1;
   return 0;
  }
  if ((FUNCTION_TABLE[HEAP32[16294]](HEAP32[$0 + 24 >> 2]) | 0) < 0) {
   $1 = HEAP32[__errno_location() >> 2];
   if (($1 | 0) == 44) {
    break label$1;
   }
   storeLastErrno($0, $1);
   return 2058;
  }
  HEAP8[$0 + 16 | 0] = 0;
 }
 return 0;
}

function sqlite3Fts3EvalPhraseCleanup($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  sqlite3_free(HEAP32[$0 >> 2]);
  fts3EvalInvalidatePoslist($0);
  $1 = memset($0, 0, 40);
  $0 = 0;
  while (1) {
   if (HEAP32[$1 + 64 >> 2] <= ($0 | 0)) {
    break label$1;
   }
   $2 = Math_imul($0, 24) + $1 | 0;
   fts3SegReaderCursorFree(HEAP32[$2 + 92 >> 2]);
   HEAP32[$2 + 92 >> 2] = 0;
   $0 = $0 + 1 | 0;
   continue;
  }
 }
}

function fts3GetDeltaVarint($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$0 >> 2] = sqlite3Fts3GetVarint(HEAP32[$0 >> 2], $2 + 8 | 0) + HEAP32[$0 >> 2];
 $0 = HEAP32[$1 + 4 >> 2] + HEAP32[$2 + 12 >> 2] | 0;
 $3 = HEAP32[$2 + 8 >> 2];
 $4 = $3 + HEAP32[$1 >> 2] | 0;
 HEAP32[$1 >> 2] = $4;
 $0 = $3 >>> 0 > $4 >>> 0 ? $0 + 1 | 0 : $0;
 HEAP32[$1 + 4 >> 2] = $0;
 __stack_pointer = $2 + 16 | 0;
}

function sqlite3VdbeFreeCursorNN($0, $1) {
 label$1: {
  switch (HEAPU8[$1 | 0]) {
  case 1:
   sqlite3VdbeSorterClose(HEAP32[$0 >> 2], $1);
   return;

  case 0:
   sqlite3BtreeCloseCursor(HEAP32[$1 + 36 >> 2]);
   return;

  case 2:
   $0 = HEAP32[$1 + 36 >> 2];
   $1 = HEAP32[$0 >> 2];
   HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - 1;
   FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 28 >> 2]]($0) | 0;
   break;

  default:
   break label$1;
  }
 }
}

function fts3IncrmergeHintStore($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 $0 = fts3SqlStmt($0, 23, $2 + 12 | 0, 0);
 if (!$0) {
  $3 = HEAP32[$2 + 12 >> 2];
  sqlite3_bind_int($3, 1, 1);
  sqlite3_bind_blob($3, 2, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], 0);
  sqlite3_step($3);
  $0 = sqlite3_reset($3);
  sqlite3_bind_null($3, 2);
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function setResultStrOrError($0, $1, $2, $3, $4) {
 var $5 = 0;
 label$1: {
  $5 = HEAP32[$0 >> 2];
  $2 = sqlite3VdbeMemSetStr($5, $1, $2, $2 >> 31, $3, $4);
  label$2: {
   if ($2) {
    if (($2 | 0) == 18) {
     break label$2;
    }
    sqlite3_result_error_nomem($0);
    return;
   }
   sqlite3VdbeChangeEncoding($5, HEAPU8[$0 + 24 | 0]);
   if (!sqlite3VdbeMemTooBig($5)) {
    break label$1;
   }
  }
  sqlite3_result_error_toobig($0);
 }
}

function pcache1RemoveFromHash($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = HEAP32[$0 + 20 >> 2];
 $3 = HEAP32[$2 + 56 >> 2] + (HEAPU32[$0 + 8 >> 2] % HEAPU32[$2 + 52 >> 2] << 2) | 0;
 while (1) {
  $4 = $3;
  $5 = HEAP32[$4 >> 2];
  $3 = $5 + 16 | 0;
  if (($0 | 0) != ($5 | 0)) {
   continue;
  }
  break;
 }
 HEAP32[$4 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$2 + 48 >> 2] = HEAP32[$2 + 48 >> 2] - 1;
 if ($1) {
  pcache1FreePage($0);
 }
}

function pagerLockDb($0, $1) {
 var $2 = 0;
 $2 = HEAPU8[$0 + 18 | 0];
 label$1: {
  label$2: {
   if (($2 | 0) != 5 & ($1 | 0) <= ($2 | 0)) {
    break label$2;
   }
   if (!HEAPU8[$0 + 13 | 0]) {
    $2 = sqlite3OsLock(HEAP32[$0 + 64 >> 2], $1);
    if ($2) {
     break label$1;
    }
    $2 = HEAPU8[$0 + 18 | 0];
   }
   if (($2 & 255) == 5 & ($1 | 0) != 4) {
    break label$2;
   }
   HEAP8[$0 + 18 | 0] = $1;
  }
  $2 = 0;
 }
 return $2;
}

function backupTruncateFile($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = sqlite3OsFileSize($0, $3 + 8 | 0);
 label$1: {
  if ($4) {
   break label$1;
  }
  $4 = 0;
  $5 = HEAP32[$3 + 12 >> 2];
  if (($5 | 0) <= ($2 | 0) & $1 >>> 0 >= HEAPU32[$3 + 8 >> 2] | ($2 | 0) > ($5 | 0)) {
   break label$1;
  }
  $4 = sqlite3OsTruncate($0, $1, $2);
 }
 __stack_pointer = $3 + 16 | 0;
 return $4;
}

function sqlite3StrICmp($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  label$2: {
   $2 = HEAPU8[$0 | 0];
   $3 = HEAPU8[$1 | 0];
   label$3: {
    if (($2 | 0) == ($3 | 0)) {
     if ($2) {
      break label$3;
     }
     $2 = 0;
     break label$2;
    }
    $2 = HEAPU8[$2 + 29904 | 0] - HEAPU8[$3 + 29904 | 0] | 0;
    if ($2) {
     break label$2;
    }
   }
   $1 = $1 + 1 | 0;
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 return $2;
}

function rowSetEntryAlloc($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAPU16[$0 + 24 >> 1];
 label$1: {
  if ($1) {
   $2 = HEAP32[$0 + 16 >> 2];
   $1 = $1 - 1 | 0;
   break label$1;
  }
  $1 = sqlite3DbMallocRawNN(HEAP32[$0 + 4 >> 2], 1016, 0);
  if (!$1) {
   return 0;
  }
  HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$0 >> 2] = $1;
  $2 = $1 + 8 | 0;
  $1 = 62;
 }
 HEAP16[$0 + 24 >> 1] = $1;
 $1 = $2;
 HEAP32[$0 + 16 >> 2] = $1 + 16;
 return $1;
}

function findNextHostParameter($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$1 >> 2] = 0;
 while (1) {
  label$2: {
   if (HEAPU8[$0 | 0]) {
    $3 = sqlite3GetToken($0, $2 + 12 | 0);
    if (HEAP32[$2 + 12 >> 2] != 156) {
     break label$2;
    }
    HEAP32[$1 >> 2] = $3;
   }
   __stack_pointer = $2 + 16 | 0;
   return $4;
  }
  $0 = $0 + $3 | 0;
  $4 = $3 + $4 | 0;
  continue;
 }
}

function dbReallocFinish($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  if (HEAPU8[$0 + 87 | 0]) {
   break label$1;
  }
  if (isLookaside($0, $1)) {
   $2 = sqlite3DbMallocRawNN($0, $2, $3);
   if (!$2) {
    break label$1;
   }
   $4 = __memcpy($2, $1, lookasideMallocSize($0, $1));
   sqlite3DbFree($0, $1);
   return $4;
  }
  $4 = sqlite3Realloc($1, $2, $3);
  if ($4) {
   break label$1;
  }
  sqlite3OomFault($0);
  $4 = 0;
 }
 return $4;
}

function moveToLeftmost($0) {
 var $1 = 0, $2 = 0;
 while (1) {
  label$2: {
   if ($1) {
    break label$2;
   }
   $2 = HEAP32[$0 + 116 >> 2];
   if (HEAPU8[$2 + 8 | 0]) {
    break label$2;
   }
   $1 = HEAP32[$2 + 64 >> 2] + (HEAPU16[$0 + 70 >> 1] << 1) | 0;
   $1 = moveToChild($0, sqlite3Get4byte(HEAP32[$2 + 56 >> 2] + (HEAPU16[$2 + 26 >> 1] & (HEAPU8[$1 | 0] << 8 | HEAPU8[$1 + 1 | 0])) | 0));
   continue;
  }
  break;
 }
 return $1;
}

function sqlite3RenameExprUnmap($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 $3 = HEAPU8[$0 + 208 | 0];
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 24 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 37;
 HEAP32[$2 + 4 >> 2] = 38;
 HEAP32[$2 >> 2] = $0;
 HEAP8[$0 + 208 | 0] = 3;
 sqlite3WalkExpr($2, $1);
 HEAP8[$0 + 208 | 0] = $3;
 __stack_pointer = $2 + 32 | 0;
}

function whereSortingCost($0, $1, $2, $3) {
 var $4 = 0;
 $2 = (Math_imul($2 - $3 | 0, 100) | 0) / ($2 | 0) | 0;
 $3 = sqlite3LogEst($2, $2 >> 31);
 $4 = HEAPU16[$0 + 44 >> 1];
 label$1: {
  if ($4 & 16384) {
   $2 = HEAP16[$0 + 46 >> 1];
   if (($2 | 0) < ($1 | 0)) {
    break label$1;
   }
  }
  $2 = ($1 | 0) > 10 ? ($4 & 256) >>> 8 | 0 ? $1 - 10 | 0 : $1 : $1;
 }
 return (estLog($2 << 16 >> 16) + ($1 + $3 | 0) << 16) - 3276800 >> 16;
}

function sqlite3Utf8CharLen($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = ($1 | 0) >= 0 ? $0 + $1 | 0 : -1;
 while (1) {
  $2 = HEAPU8[$0 | 0];
  if (!(!$2 | $0 >>> 0 >= $4 >>> 0)) {
   $1 = $0 + 1 | 0;
   $0 = $1;
   if ($2 >>> 0 >= 192) {
    while (1) {
     $0 = $1;
     $1 = $0 + 1 | 0;
     if ((HEAPU8[$0 | 0] & 192) == 128) {
      continue;
     }
     break;
    }
   }
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 return $3;
}

function open($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  if (!($1 & 64)) {
   $4 = 0;
   if (($1 & 4259840) != 4259840) {
    break label$1;
   }
  }
  HEAP32[$3 + 12 >> 2] = $2 + 4;
  $4 = HEAP32[$2 >> 2];
 }
 HEAP32[$3 >> 2] = $4;
 HEAP32[$3 + 4 >> 2] = 0;
 $1 = __syscall_ret(__syscall_openat(-100, $0 | 0, $1 | 32768, $3 | 0) | 0);
 __stack_pointer = $3 + 16 | 0;
 return $1;
}

function insertBinaryOperator($0, $1, $2) {
 var $3 = 0;
 label$1: {
  label$2: {
   while (1) {
    $3 = $1;
    $1 = HEAP32[$1 + 8 >> 2];
    if (!$1) {
     break label$2;
    }
    if ((opPrecedence($1) | 0) <= (opPrecedence($2) | 0)) {
     continue;
    }
    break;
   }
   HEAP32[$1 + 16 >> 2] = $2;
   HEAP32[$2 + 8 >> 2] = $1;
   break label$1;
  }
  HEAP32[$0 >> 2] = $2;
 }
 HEAP32[$2 + 12 >> 2] = $3;
 HEAP32[$3 + 8 >> 2] = $2;
}

function __clock_nanosleep($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = 28;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2];
  if ($2 >>> 0 > 999999999) {
   break label$1;
  }
  $3 = HEAP32[$0 >> 2];
  $0 = HEAP32[$0 + 4 >> 2];
  $4 = $0;
  if (($0 | 0) < 0) {
   break label$1;
  }
  $0 = $3;
  emscripten_thread_sleep((+($0 >>> 0) + +($4 | 0) * 4294967296) * 1e3 + +($2 | 0) / 1e6);
  $1 = 0;
 }
 return $1;
}

function walWriteOneFrame($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = __stack_pointer - 32 | 0;
 __stack_pointer = $5;
 $6 = HEAP32[$1 + 4 >> 2];
 walEncodeFrame(HEAP32[$0 >> 2], HEAP32[$1 + 24 >> 2], $2, $6, $5);
 $1 = walWriteToLog($0, $5, 24, $3, $4);
 if (!$1) {
  $1 = $3 + 24 | 0;
  $4 = $1 >>> 0 < 24 ? $4 + 1 | 0 : $4;
  $1 = walWriteToLog($0, $6, HEAP32[$0 + 20 >> 2], $1, $4);
 }
 __stack_pointer = $5 + 32 | 0;
 return $1;
}

function uriParameter($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = sqlite3Strlen30($0);
 while (1) {
  label$2: {
   label$3: {
    if (!$0) {
     break label$3;
    }
    $0 = ($0 + $2 | 0) + 1 | 0;
    if (!HEAPU8[$0 | 0]) {
     break label$3;
    }
    $2 = strcmp($0, $1);
    $0 = (sqlite3Strlen30($0) + $0 | 0) + 1 | 0;
    if ($2) {
     break label$2;
    }
    $3 = $0;
   }
   return $3;
  }
  $2 = sqlite3Strlen30($0);
  continue;
 }
}

function dense_rankValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = sqlite3_aggregate_context($0, 24);
 if ($1) {
  $2 = HEAP32[$1 >> 2];
  $3 = HEAP32[$1 + 4 >> 2];
  if (HEAP32[$1 + 8 >> 2] | HEAP32[$1 + 12 >> 2]) {
   HEAP32[$1 + 8 >> 2] = 0;
   HEAP32[$1 + 12 >> 2] = 0;
   $2 = $2 + 1 | 0;
   $3 = $2 ? $3 : $3 + 1 | 0;
   HEAP32[$1 >> 2] = $2;
   HEAP32[$1 + 4 >> 2] = $3;
  }
  sqlite3_result_int64($0, $2, $3);
 }
}

function sqlite3WindowDelete($0, $1) {
 if ($1) {
  sqlite3WindowUnlinkFromSelect($1);
  sqlite3ExprDelete($0, HEAP32[$1 + 40 >> 2]);
  sqlite3ExprListDelete($0, HEAP32[$1 + 8 >> 2]);
  sqlite3ExprListDelete($0, HEAP32[$1 + 12 >> 2]);
  sqlite3ExprDelete($0, HEAP32[$1 + 28 >> 2]);
  sqlite3ExprDelete($0, HEAP32[$1 + 24 >> 2]);
  sqlite3DbFree($0, HEAP32[$1 >> 2]);
  sqlite3DbFree($0, HEAP32[$1 + 4 >> 2]);
  sqlite3DbFree($0, $1);
 }
}

function fts3ExprIterate2($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 label$1: {
  while (1) {
   $5 = HEAP32[$0 >> 2];
   if (($5 | 0) != 5) {
    $4 = fts3ExprIterate2(HEAP32[$0 + 12 >> 2], $1, $2, $3);
    if ($4 | ($5 | 0) == 2) {
     break label$1;
    }
    $0 = HEAP32[$0 + 16 >> 2];
    continue;
   }
   break;
  }
  $4 = FUNCTION_TABLE[$2 | 0]($0, HEAP32[$1 >> 2], $3) | 0;
  HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
 }
 return $4;
}

function sqlite3RenameTokenMap($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (HEAPU8[$0 + 208 | 0] == 3) {
   break label$1;
  }
  $3 = sqlite3DbMallocZero(HEAP32[$0 >> 2], 16, 0);
  if (!$3) {
   break label$1;
  }
  HEAP32[$3 >> 2] = $1;
  $4 = HEAP32[$2 + 4 >> 2];
  HEAP32[$3 + 4 >> 2] = HEAP32[$2 >> 2];
  HEAP32[$3 + 8 >> 2] = $4;
  HEAP32[$3 + 12 >> 2] = HEAP32[$0 + 268 >> 2];
  HEAP32[$0 + 268 >> 2] = $3;
 }
 return $1;
}

function sqlite3PagerWrite($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 if (!(!(HEAPU8[$0 + 28 | 0] & 4) | HEAPU32[$1 + 28 >> 2] < HEAPU32[$0 + 24 >> 2])) {
  if (!HEAP32[$1 + 104 >> 2]) {
   return 0;
  }
  return subjournalPageIfRequired($0);
 }
 $2 = HEAP32[$1 + 44 >> 2];
 if (!$2) {
  if (HEAPU32[$1 + 156 >> 2] > HEAPU32[$1 + 168 >> 2]) {
   return pagerWriteLargeSector($0);
  }
  $2 = pager_write($0);
 }
 return $2;
}

function setAllPagerFlags($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 label$1: {
  if (!HEAPU8[$0 + 85 | 0]) {
   break label$1;
  }
  $2 = HEAP32[$0 + 20 >> 2];
  $1 = HEAP32[$0 + 16 >> 2];
  while (1) {
   if (($2 | 0) <= 0) {
    break label$1;
   }
   $3 = HEAP32[$1 + 4 >> 2];
   if ($3) {
    sqlite3BtreeSetPagerFlags($3, HEAPU8[$1 + 8 | 0] | HEAP32[$0 + 32 >> 2] & 56);
   }
   $2 = $2 - 1 | 0;
   $1 = $1 + 16 | 0;
   continue;
  }
 }
}

function databaseIsUnmoved($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 label$1: {
  if (HEAPU8[$0 + 12 | 0] | !HEAP32[$0 + 28 >> 2]) {
   break label$1;
  }
  $0 = sqlite3OsFileControl(HEAP32[$0 + 64 >> 2], 20, $1 + 12 | 0);
  if (($0 | 0) == 12) {
   break label$1;
  }
  $2 = $0 ? $0 : HEAP32[$1 + 12 >> 2] ? 1032 : $0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function windowIfNewPeer($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = sqlite3GetVdbe($0);
 if ($1) {
  $6 = HEAP32[$1 >> 2];
  $1 = sqlite3KeyInfoFromExprList($0, $1, 0, 0);
  sqlite3VdbeAddOp3($5, 90, $3, $2, $6);
  sqlite3VdbeAppendP4($5, $1, -8);
  $1 = sqlite3VdbeCurrentAddr($5) + 1 | 0;
  sqlite3VdbeAddOp3($5, 13, $1, $4, $1);
  sqlite3VdbeAddOp3($5, 80, $2, $3, $6 - 1 | 0);
  return;
 }
 sqlite3VdbeAddOp2($5, 8, 0, $4);
}

function fts3GobbleInt($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 $3 = HEAP32[$0 >> 2];
 $4 = sqlite3Fts3ReadInt($3, $2 + 12 | 0);
 label$1: {
  if (!$4) {
   $6 = 1;
   break label$1;
  }
  $5 = HEAP32[$2 + 12 >> 2];
  HEAP32[$1 >> 2] = ($5 | 0) > 1e7 ? 0 : $5;
  HEAP32[$0 >> 2] = $3 + $4;
 }
 __stack_pointer = $2 + 16 | 0;
 return $6;
}

function sqlite3ExprListSetName($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $4 = ((HEAP32[$1 >> 2] << 4) + $1 | 0) - 4 | 0;
  $1 = sqlite3DbStrNDup(HEAP32[$0 >> 2], HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2], 0);
  HEAP32[$4 >> 2] = $1;
  if (!$3) {
   break label$1;
  }
  sqlite3Dequote($1);
  if (HEAPU8[$0 + 208 | 0] < 2) {
   break label$1;
  }
  sqlite3RenameTokenMap($0, HEAP32[$4 >> 2], $2);
 }
}

function countInverse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $0 = sqlite3_aggregate_context($0, 8);
 label$1: {
  if ($1) {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
    break label$1;
   }
  }
  if (!$0) {
   break label$1;
  }
  $3 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$0 >> 2];
  $2 = !$1;
  $1 = $1 - 1 | 0;
  HEAP32[$0 >> 2] = $1;
  $2 = $3 - $2 | 0;
  HEAP32[$0 + 4 >> 2] = $2;
 }
}

function contextMalloc($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[sqlite3_context_db_handle($0) + 120 >> 2];
 $4 = $3;
 $3 = $3 >> 31;
 label$1: {
  label$2: {
   if (($3 | 0) <= ($2 | 0) & $1 >>> 0 > $4 >>> 0 | ($2 | 0) > ($3 | 0)) {
    sqlite3_result_error_toobig($0);
    break label$2;
   }
   $1 = sqlite3Malloc($1, $2);
   if ($1) {
    break label$1;
   }
   sqlite3_result_error_nomem($0);
  }
  $1 = 0;
 }
 return $1;
}

function cursorOnLastPage($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $1 = HEAP8[$0 + 68 | 0];
 $4 = ($1 | 0) > 0 ? $1 : 0;
 $3 = 1;
 label$1: {
  while (1) {
   if (($2 | 0) == ($4 | 0)) {
    break label$1;
   }
   $1 = $2 << 1;
   $5 = $2 << 2;
   $2 = $2 + 1 | 0;
   if (HEAPU16[($0 + $1 | 0) + 72 >> 1] >= HEAPU16[HEAP32[($0 + $5 | 0) + 120 >> 2] + 24 >> 1]) {
    continue;
   }
   break;
  }
  $3 = 0;
 }
 return $3;
}

function sqlite3OpenTable($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP32[$0 + 8 >> 2];
 sqlite3TableLock($0, $2, HEAP32[$3 + 20 >> 2], ($4 | 0) == 113, HEAP32[$3 >> 2]);
 if (!(HEAPU8[$3 + 28 | 0] & 128)) {
  sqlite3VdbeAddOp4Int($5, $4, $1, HEAP32[$3 + 20 >> 2], $2, HEAP16[$3 + 36 >> 1]);
  return;
 }
 $3 = sqlite3PrimaryKeyIndex($3);
 sqlite3VdbeAddOp3($5, $4, $1, HEAP32[$3 + 44 >> 2], $2);
 sqlite3VdbeSetP4KeyInfo($0, $3);
}

function explainIndexColumnName($0, $1) {
 var $2 = 0;
 $2 = 21199;
 label$1: {
  label$2: {
   label$3: {
    $1 = HEAPU16[HEAP32[$0 + 4 >> 2] + ($1 << 1) >> 1];
    switch ($1 - 65534 | 0) {
    case 0:
     break label$1;

    case 1:
     break label$3;

    default:
     break label$2;
    }
   }
   return 14442;
  }
  $2 = HEAP32[HEAP32[HEAP32[$0 + 12 >> 2] + 4 >> 2] + Math_imul($1 << 16 >> 16, 12) >> 2];
 }
 return $2;
}

function sqlite3ExprListAppend($0, $1, $2) {
 var $3 = 0;
 if (!$1) {
  return sqlite3ExprListAppendNew(HEAP32[$0 >> 2], $2);
 }
 $3 = HEAP32[$1 >> 2];
 if (($3 | 0) >= HEAP32[$1 + 4 >> 2]) {
  return sqlite3ExprListAppendGrow(HEAP32[$0 >> 2], $1, $2);
 }
 HEAP32[$1 >> 2] = $3 + 1;
 $0 = ($3 << 4) + $1 | 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = $2;
 return $1;
}

function getRowTrigger($0, $1, $2, $3) {
 var $4 = 0;
 $4 = HEAP32[$0 + 116 >> 2];
 $4 = ($4 ? $4 : $0) + 124 | 0;
 label$1: {
  while (1) {
   $4 = HEAP32[$4 >> 2];
   if ($4) {
    if (HEAP32[$4 >> 2] == ($1 | 0) & HEAP32[$4 + 12 >> 2] == ($3 | 0)) {
     break label$1;
    }
    $4 = $4 + 4 | 0;
    continue;
   }
   break;
  }
  $4 = codeRowTrigger($0, $1, $2, $3);
  HEAP32[HEAP32[$0 >> 2] + 68 >> 2] = -1;
 }
 return $4;
}

function invalidateTempStorage($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2];
 $2 = HEAP32[HEAP32[$1 + 16 >> 2] + 20 >> 2];
 if (!$2) {
  return 0;
 }
 label$2: {
  if (HEAPU8[$1 + 85 | 0]) {
   if (!sqlite3BtreeTxnState($2)) {
    break label$2;
   }
  }
  sqlite3ErrorMsg($0, 10050, 0);
  return 1;
 }
 sqlite3BtreeClose($2);
 HEAP32[HEAP32[$1 + 16 >> 2] + 20 >> 2] = 0;
 sqlite3ResetAllSchemasOfConnection($1);
 return 0;
}

function reindexDatabases($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$0 >> 2];
 $3 = HEAP32[$4 + 16 >> 2];
 while (1) {
  if (($5 | 0) < HEAP32[$4 + 20 >> 2]) {
   $2 = HEAP32[$3 + 12 >> 2] + 16 | 0;
   while (1) {
    $2 = HEAP32[$2 >> 2];
    if ($2) {
     reindexTable($0, HEAP32[$2 + 8 >> 2], $1);
     continue;
    }
    break;
   }
   $3 = $3 + 16 | 0;
   $5 = $5 + 1 | 0;
   continue;
  }
  break;
 }
}

function stdevFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 20 >> 2];
  $3 = HEAP32[$1 + 16 >> 2];
  if ($3 >>> 0 < 2 & ($2 | 0) <= 0 | ($2 | 0) < 0) {
   break label$1;
  }
  $4 = Math_sqrt(HEAPF64[$1 + 8 >> 3] / (+($3 - 1 >>> 0) + +($2 - !$3 | 0) * 4294967296));
 }
 sqlite3_result_double($0, $4);
}

function checkConstraintExprNode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $2 = HEAP16[$1 + 32 >> 1];
  label$2: {
   if (($2 | 0) < 0) {
    $1 = 2;
    break label$2;
   }
   $1 = 1;
   if (HEAP32[HEAP32[$0 + 24 >> 2] + (($2 & 65535) << 2) >> 2] < 0) {
    break label$1;
   }
  }
  HEAP16[$0 + 20 >> 1] = HEAPU16[$0 + 20 >> 1] | $1;
 }
 return 0;
}

function sqlite3_value_blob($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = HEAPU16[$0 + 16 >> 1];
 label$1: {
  if ($1 & 18) {
   if ($1 & 1024) {
    $1 = 0;
    if (sqlite3VdbeMemExpandBlob($0)) {
     break label$1;
    }
    $1 = HEAPU16[$0 + 16 >> 1];
   }
   HEAP16[$0 + 16 >> 1] = $1 | 16;
   if (!HEAP32[$0 + 12 >> 2]) {
    return 0;
   }
   return HEAP32[$0 + 8 >> 2];
  }
  $1 = sqlite3_value_text($0);
 }
 return $1 | 0;
}

function seriesColumn($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 label$1: {
  label$2: {
   switch ($2 - 1 | 0) {
   case 0:
    $2 = $0 + 8 | 0;
    break label$1;

   case 1:
    $2 = $0 + 16 | 0;
    break label$1;

   case 2:
    $2 = $0 + 24 | 0;
    break label$1;

   default:
    break label$2;
   }
  }
  $2 = $0 + 48 | 0;
 }
 sqlite3_result_int64($1, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
 return 0;
}

function tableMayNotBeDropped($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 >> 2];
 if (!sqlite3_strnicmp($2, 17751, 7)) {
  $1 = $2 + 7 | 0;
  if (!sqlite3_strnicmp($1, 3304, 4)) {
   return 0;
  }
  return (sqlite3_strnicmp($1, 4162, 10) | 0) != 0;
 }
 $2 = HEAP32[$1 + 28 >> 2];
 label$3: {
  if ($2 & 4096) {
   $1 = 1;
   if (sqlite3ReadOnlyShadowTables($0)) {
    break label$3;
   }
  }
  $1 = $2 >>> 15 & 1;
 }
 return $1;
}

function sqlite3RowSetInit($0) {
 var $1 = 0, $2 = 0;
 $1 = sqlite3DbMallocRawNN($0, 32, 0);
 if ($1) {
  $2 = sqlite3DbMallocSize($0, $1);
  HEAP32[$1 + 20 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = $0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 28 >> 2] = 0;
  HEAP16[$1 + 26 >> 1] = 1;
  HEAP32[$1 + 16 >> 2] = $1 + 32;
  HEAP16[$1 + 24 >> 1] = $2 + 1048544 >>> 4;
 }
 return $1;
}

function sqlite3_finalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 if (!$0) {
  return 0;
 }
 $1 = HEAP32[$0 >> 2];
 if (!vdbeSafety($0)) {
  $2 = HEAP32[$0 + 140 >> 2];
  if (!!HEAP32[$0 + 136 >> 2] & ($2 | 0) >= 0 | ($2 | 0) > 0) {
   invokeProfileCallback($1, $0);
  }
  $0 = sqlite3ApiExit($1, sqlite3VdbeFinalize($0));
  sqlite3LeaveMutexAndCloseZombie($1);
  return $0 | 0;
 }
 return sqlite3MisuseError(86106) | 0;
}

function sqlite3TriggersExist($0, $1, $2, $3, $4) {
 label$1: {
  label$2: {
   label$3: {
    if (!HEAP32[$1 + 56 >> 2]) {
     if (!tempTriggersExist(HEAP32[$0 >> 2])) {
      break label$3;
     }
    }
    if (!HEAPU8[$0 + 151 | 0]) {
     break label$2;
    }
   }
   $0 = 0;
   if (!$4) {
    break label$1;
   }
   HEAP32[$4 >> 2] = 0;
   return 0;
  }
  $0 = triggersReallyExist($0, $1, $2, $3, $4);
 }
 return $0;
}

function sqlite3ExprCodeGeneratedColumn($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = HEAP32[$0 + 8 >> 2];
 $4 = HEAP32[$0 + 52 >> 2];
 if (($4 | 0) <= 0) {
  $4 = 0;
 } else {
  $4 = sqlite3VdbeAddOp3($5, 18, $4 - 1 | 0, 0, $3);
 }
 sqlite3ExprCodeCopy($0, sqlite3ColumnExpr($1, $2), $3);
 if (HEAP8[$2 + 5 | 0] >= 66) {
  sqlite3VdbeAddOp4($5, 96, $3, 1, 0, $2 + 5 | 0, 1);
 }
 if ($4) {
  sqlite3VdbeJumpHere($5, $4);
 }
}

function sqlite3ExprAnd($0, $1, $2) {
 var $3 = 0;
 if ($1) {
  if (!$2) {
   return $1;
  }
  $3 = HEAP32[$0 >> 2];
  if (!((HEAP32[$1 + 4 >> 2] & 536870913) != 536870912 & (HEAP32[$2 + 4 >> 2] & 536870913) != 536870912 | HEAPU8[$0 + 208 | 0] > 1)) {
   sqlite3ExprDeferredDelete($0, $1);
   sqlite3ExprDeferredDelete($0, $2);
   return sqlite3Expr($3, 155, 24241);
  }
  $2 = sqlite3PExpr($0, 44, $1, $2);
 }
 return $2;
}

function fts3NodeFree($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $0 = HEAP32[$0 + 8 >> 2];
  fts3NodeFree(HEAP32[$0 >> 2]);
  while (1) {
   if (!$0) {
    break label$1;
   }
   $2 = HEAP32[$0 + 4 >> 2];
   $1 = HEAP32[$0 + 36 >> 2];
   if (($1 | 0) != ($0 + 40 | 0)) {
    sqlite3_free($1);
   }
   sqlite3_free(HEAP32[$0 + 28 >> 2]);
   sqlite3_free($0);
   $0 = $2;
   continue;
  }
 }
}

function btreePayloadToLocal($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $5 = HEAPU16[$0 + 14 >> 1];
 if (($2 | 0) <= 0 & $5 >>> 0 >= $1 >>> 0 | ($2 | 0) < 0) {
  return $1;
 }
 $3 = HEAPU16[$0 + 16 >> 1];
 $4 = $1 - $3 | 0;
 $0 = __wasm_i64_srem($4, $2 - ($1 >>> 0 < $3 >>> 0) | 0, HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] - 4 | 0, 0);
 $4 = i64toi32_i32$HIGH_BITS;
 $0 = $0 + $3 | 0;
 return ($0 | 0) > ($5 | 0) ? $3 : $0;
}

function windowRemoveExprFromSelect($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 if (HEAP32[$0 + 68 >> 2]) {
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 + 24 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = 75;
  sqlite3WalkExpr($2, $1);
 }
 __stack_pointer = $2 + 32 | 0;
}
function sqlite3IsReadOnly($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = 15629;
 label$1: {
  if (!tabIsReadOnly($0, $1)) {
   if ($2) {
    break label$1;
   }
   $4 = 1742;
   if (HEAPU8[$1 + 43 | 0] != 2) {
    break label$1;
   }
  }
  HEAP32[$3 >> 2] = HEAP32[$1 >> 2];
  sqlite3ErrorMsg($0, $4, $3);
  $5 = 1;
 }
 __stack_pointer = $3 + 16 | 0;
 return $5;
}

function appendAllPathElements($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 while (1) {
  $2 = $3;
  while (1) {
   $5 = $1 + $2 | 0;
   $4 = HEAPU8[$5 | 0];
   if (!(!$4 | ($4 | 0) == 47)) {
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  if (($2 | 0) > ($3 | 0)) {
   appendOnePathElement($0, $1 + $3 | 0, $2 - $3 | 0);
   $4 = HEAPU8[$5 | 0];
  }
  $3 = $2 + 1 | 0;
  if ($4) {
   continue;
  }
  break;
 }
}

function sqlite3_clear_bindings($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 while (1) {
  if (($1 | 0) < HEAP16[$0 + 16 >> 1]) {
   $2 = Math_imul($1, 40);
   sqlite3VdbeMemRelease($2 + HEAP32[$0 + 100 >> 2] | 0);
   HEAP16[(HEAP32[$0 + 100 >> 2] + $2 | 0) + 16 >> 1] = 1;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 if (HEAP32[$0 + 224 >> 2]) {
  HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 252 | 1;
 }
 return 0;
}

function sqlite3VdbeMemStringify($0, $1, $2) {
 var $3 = 0;
 if (sqlite3VdbeMemClearAndResize($0, 32)) {
  HEAP8[$0 + 18 | 0] = 0;
  return 7;
 }
 vdbeMemRenderNum(HEAP32[$0 + 8 >> 2], $0);
 $3 = strlen(HEAP32[$0 + 8 >> 2]);
 HEAP8[$0 + 18 | 0] = 1;
 HEAP32[$0 + 12 >> 2] = $3 & 1073741823;
 $3 = HEAPU16[$0 + 16 >> 1] | 514;
 HEAP16[$0 + 16 >> 1] = $2 ? $3 & 65491 : $3;
 sqlite3VdbeChangeEncoding($0, $1);
 return 0;
}

function sqlite3SubInt64($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (!$1 & ($2 | 0) == -2147483648) {
   $1 = HEAP32[$0 >> 2];
   $2 = HEAP32[$0 + 4 >> 2];
   $3 = 1;
   if (($2 | 0) > 0 | ($2 | 0) >= 0) {
    break label$1;
   }
   HEAP32[$0 >> 2] = $1;
   $2 = $2 ^ -2147483648;
   HEAP32[$0 + 4 >> 2] = $2;
   return 0;
  }
  $3 = sqlite3AddInt64($0, 0 - $1 | 0, 0 - ((($1 | 0) != 0) + $2 | 0) | 0);
 }
 return $3;
}

function populateCellCache($0, $1, $2) {
 var $3 = 0, $4 = 0;
 while (1) {
  if (($2 | 0) > 0) {
   $4 = $1 << 1;
   if (!HEAPU16[$4 + HEAP32[$0 + 12 >> 2] >> 1]) {
    $3 = HEAP32[$0 + 4 >> 2];
    $3 = FUNCTION_TABLE[HEAP32[$3 + 76 >> 2]]($3, HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2]) | 0;
    HEAP16[HEAP32[$0 + 12 >> 2] + $4 >> 1] = $3;
   }
   $2 = $2 - 1 | 0;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
}

function groupConcatValue($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  label$2: {
   $2 = HEAPU8[$1 + 20 | 0];
   if (($2 | 0) != 7) {
    if (($2 | 0) != 18) {
     break label$2;
    }
    sqlite3_result_error_toobig($0);
    return;
   }
   sqlite3_result_error_nomem($0);
   return;
  }
  sqlite3_result_text($0, sqlite3_str_value($1), HEAP32[$1 + 16 >> 2], -1);
 }
}

function varianceFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 20 >> 2];
  $3 = HEAP32[$1 + 16 >> 2];
  if ($3 >>> 0 < 2 & ($2 | 0) <= 0 | ($2 | 0) < 0) {
   break label$1;
  }
  $4 = HEAPF64[$1 + 8 >> 3] / (+($3 - 1 >>> 0) + +($2 - !$3 | 0) * 4294967296);
 }
 sqlite3_result_double($0, $4);
}

function sqlite3RegisterLikeFunctions($0, $1) {
 var $2 = 0;
 $2 = $1 ? 49552 : 30284;
 sqlite3CreateFunc($0, 13857, 2, 1, $2, 62, 0, 0, 0, 0, 0);
 sqlite3CreateFunc($0, 13857, 3, 1, $2, 62, 0, 0, 0, 0, 0);
 $2 = sqlite3FindFunction($0, 13857, 2, 1, 0);
 $1 = $1 ? 12 : 4;
 HEAP32[$2 + 4 >> 2] = $1 | HEAP32[$2 + 4 >> 2];
 $0 = sqlite3FindFunction($0, 13857, 3, 1, 0);
 HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | $1;
}

function sqlite3ExprListSetSpan($0, $1, $2, $3) {
 label$1: {
  if (!$1) {
   break label$1;
  }
  $1 = (HEAP32[$1 >> 2] - 1 << 4) + $1 | 0;
  if (HEAP32[$1 + 12 >> 2]) {
   break label$1;
  }
  HEAP32[$1 + 12 >> 2] = sqlite3DbSpanDup(HEAP32[$0 >> 2], $2, $3);
  $0 = $1;
  $1 = $1 + 17 | 0;
  $0 = (HEAPU8[$0 + 17 | 0] | HEAPU8[$0 + 18 | 0] << 8) & 65532 | 1;
  HEAP8[$1 | 0] = $0;
  HEAP8[$1 + 1 | 0] = $0 >>> 8;
 }
}

function fts3tokResetCursor($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 if ($1) {
  FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[$0 >> 2] + 12 >> 2] + 16 >> 2]]($1) | 0;
  HEAP32[$0 + 8 >> 2] = 0;
 }
 sqlite3_free(HEAP32[$0 + 4 >> 2]);
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 32 >> 2] = 0;
}

function sqlite3VdbeAllocUnpackedRecord($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = HEAP32[$0 + 12 >> 2];
 $2 = __wasm_i64_mul(HEAPU16[$0 + 6 >> 1], 0, 40, 0);
 $1 = i64toi32_i32$HIGH_BITS;
 $2 = $2 + 72 | 0;
 $1 = $2 >>> 0 < 72 ? $1 + 1 | 0 : $1;
 $1 = sqlite3DbMallocRaw($3, $2, $1);
 if ($1) {
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $1 + 32;
  HEAP16[$1 + 20 >> 1] = HEAPU16[$0 + 6 >> 1] + 1;
 }
 return $1;
}

function sqlite3SrcListAppendList($0, $1, $2) {
 var $3 = 0;
 if ($2) {
  $3 = sqlite3SrcListEnlarge($0, $1, HEAP32[$2 >> 2], 1);
  if (!$3) {
   sqlite3SrcListDelete(HEAP32[$0 >> 2], $2);
   return $1;
  }
  __memcpy($3 + 72 | 0, $2 + 8 | 0, HEAP32[$2 >> 2] << 6);
  sqlite3DbFree(HEAP32[$0 >> 2], $2);
  $2 = $3 + 44 | 0;
  HEAP8[$2 | 0] = HEAPU8[$3 + 44 | 0] | HEAPU8[$3 + 108 | 0] & 64;
  $1 = $3;
 }
 return $1;
}

function sqlite3PExpr($0, $1, $2, $3) {
 var $4 = 0;
 $4 = sqlite3DbMallocRawNN(HEAP32[$0 >> 2], 52, 0);
 if ($4) {
  $4 = memset($4, 0, 52);
  HEAP16[$4 + 34 >> 1] = 65535;
  HEAP8[$4 | 0] = $1;
  sqlite3ExprAttachSubtrees(HEAP32[$0 >> 2], $4, $2, $3);
  sqlite3ExprCheckHeight($0, HEAP32[$4 + 24 >> 2]);
  return $4;
 }
 sqlite3ExprDelete(HEAP32[$0 >> 2], $2);
 sqlite3ExprDelete(HEAP32[$0 >> 2], $3);
 return $4;
}

function sqlite3BtreePrevious($0) {
 var $1 = 0;
 HEAP16[$0 + 50 >> 1] = 0;
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 241;
 label$1: {
  label$2: {
   if (HEAPU8[$0 | 0]) {
    break label$2;
   }
   $1 = HEAPU16[$0 + 70 >> 1];
   if (!$1) {
    break label$2;
   }
   if (HEAPU8[HEAP32[$0 + 116 >> 2] + 8 | 0]) {
    break label$1;
   }
  }
  return btreePrevious($0);
 }
 HEAP16[$0 + 70 >> 1] = $1 - 1;
 return 0;
}

function sqlite3WalSavepointUndo($0, $1) {
 var $2 = 0;
 if (HEAP32[$1 + 12 >> 2] == HEAP32[$0 + 112 >> 2]) {
  $2 = HEAP32[$1 >> 2];
 } else {
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 12 >> 2] = HEAP32[$0 + 112 >> 2];
  $2 = 0;
 }
 if ($2 >>> 0 < HEAPU32[$0 + 68 >> 2]) {
  HEAP32[$0 + 68 >> 2] = $2;
  HEAP32[$0 + 76 >> 2] = HEAP32[$1 + 4 >> 2];
  HEAP32[$0 + 80 >> 2] = HEAP32[$1 + 8 >> 2];
  walCleanupHash($0);
 }
}

function sqlite3SelectExpand($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 4 >> 2] = 71;
 HEAP32[$2 >> 2] = $0;
 if (HEAPU8[$0 + 22 | 0]) {
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 72;
  sqlite3WalkSelect($2, $1);
 }
 HEAP16[$2 + 20 >> 1] = 0;
 HEAP32[$2 + 12 >> 2] = 63;
 HEAP32[$2 + 8 >> 2] = 73;
 sqlite3WalkSelect($2, $1);
 __stack_pointer = $2 + 32 | 0;
}

function inAnyUsingClause($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  while (1) {
   $3 = $1;
   if (($2 | 0) <= 0) {
    break label$1;
   }
   $1 = $3 - -64 | 0;
   $2 = $2 - 1 | 0;
   if (!(HEAPU8[$3 + 102 | 0] & 4)) {
    continue;
   }
   $3 = HEAP32[$3 + 108 >> 2];
   if (!$3) {
    continue;
   }
   if ((sqlite3IdListIndex($3, $0) | 0) < 0) {
    continue;
   }
   break;
  }
  $4 = 1;
 }
 return $4;
}

function windowCacheFrame($0) {
 var $1 = 0, $2 = 0;
 $2 = 1;
 label$1: {
  if (HEAP32[$0 + 88 >> 2]) {
   break label$1;
  }
  while (1) {
   if (!$0) {
    $2 = 0;
    break label$1;
   }
   $1 = HEAP32[HEAP32[$0 + 44 >> 2] + 32 >> 2];
   if (($1 | 0) == 48743 | ($1 | 0) == 48738 | (($1 | 0) == 48960 | ($1 | 0) == 48970)) {
    break label$1;
   }
   $0 = HEAP32[$0 + 36 >> 2];
   continue;
  }
 }
 return $2;
}

function rtrimCollFunc($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 while (1) {
  $0 = $1;
  if ($1) {
   $1 = $0 - 1 | 0;
   if (HEAPU8[$2 + $1 | 0] == 32) {
    continue;
   }
  }
  break;
 }
 while (1) {
  $1 = $3;
  if ($1) {
   $3 = $1 - 1 | 0;
   if (HEAPU8[$4 + $3 | 0] == 32) {
    continue;
   }
  }
  break;
 }
 return binCollFunc($3, $0, $2, $1, $4) | 0;
}

function exprIdxCover($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $2 = HEAP32[$0 + 24 >> 2];
  if (HEAP32[$1 + 28 >> 2] != HEAP32[$2 + 4 >> 2]) {
   break label$1;
  }
  if ((sqlite3TableColumnToIndex(HEAP32[$2 >> 2], HEAP16[$1 + 32 >> 1]) | 0) >= 0) {
   break label$1;
  }
  HEAP16[$0 + 20 >> 1] = 1;
  $3 = 2;
 }
 return $3 | 0;
}

function downgradeAllSharedCacheTableLocks($0) {
 var $1 = 0;
 label$1: {
  $1 = HEAP32[$0 + 4 >> 2];
  if (HEAP32[$1 + 80 >> 2] != ($0 | 0)) {
   break label$1;
  }
  HEAP32[$1 + 80 >> 2] = 0;
  HEAP16[$1 + 24 >> 1] = HEAPU16[$1 + 24 >> 1] & 65343;
  $0 = $1 + 76 | 0;
  while (1) {
   $0 = HEAP32[$0 >> 2];
   if (!$0) {
    break label$1;
   }
   HEAP8[$0 + 8 | 0] = 1;
   $0 = $0 + 12 | 0;
   continue;
  }
 }
}

function unixepochFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 if (!isDate($0, $1, $2, $3)) {
  computeJD($3);
  $1 = __wasm_i64_sdiv(HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], 1e3, 0);
  sqlite3_result_int64($0, $1 - 413362496 | 0, i64toi32_i32$HIGH_BITS - (($1 >>> 0 < 413362496) + 49 | 0) | 0);
 }
 __stack_pointer = $3 + 48 | 0;
}

function sqlite3VdbeIntValue($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAPU16[$0 + 16 >> 1];
 if ($2 & 36) {
  i64toi32_i32$HIGH_BITS = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$0 >> 2];
  return $1;
 }
 if ($2 & 8) {
  $1 = doubleToInt64(HEAPF64[$0 >> 3]);
  return $1;
 }
 if (!(!($2 & 18) | !HEAP32[$0 + 8 >> 2])) {
  $1 = memIntValue($0);
  $3 = i64toi32_i32$HIGH_BITS;
 }
 i64toi32_i32$HIGH_BITS = $3;
 return $1;
}

function isRealTable($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $4 = HEAPU8[$1 + 43 | 0];
 $4 = ($4 | 0) == 1 ? 13550 : ($4 | 0) == 2 ? 1826 : 0;
 if ($4) {
  HEAP32[$3 + 8 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$3 + 4 >> 2] = $4;
  HEAP32[$3 >> 2] = $2 ? 10902 : 12059;
  sqlite3ErrorMsg($0, 28504, $3);
  $5 = 1;
 }
 __stack_pointer = $3 + 16 | 0;
 return $5;
}

function sqlite3ValueBytes($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAPU16[$0 + 16 >> 1];
 if (!(!($3 & 2) | HEAPU8[$0 + 18 | 0] != ($1 | 0))) {
  return HEAP32[$0 + 12 >> 2];
 }
 label$2: {
  if ($3 & 16) {
   $2 = HEAP32[$0 + 12 >> 2];
   if (!($3 & 1024)) {
    break label$2;
   }
   return HEAP32[$0 >> 2] + $2 | 0;
  }
  $2 = 0;
  if ($3 & 1) {
   break label$2;
  }
  $2 = valueBytes($0, $1);
 }
 return $2;
}

function sqlite3SchemaGet($0, $1) {
 label$1: {
  if ($1) {
   $1 = sqlite3BtreeSchema($1, 84, 13);
   break label$1;
  }
  $1 = sqlite3DbMallocZero(0, 84, 0);
 }
 if (!$1) {
  sqlite3OomFault($0);
  return $1;
 }
 if (!HEAPU8[$1 + 76 | 0]) {
  sqlite3HashInit($1 + 8 | 0);
  sqlite3HashInit($1 + 24 | 0);
  sqlite3HashInit($1 + 40 | 0);
  sqlite3HashInit($1 + 56 | 0);
  HEAP8[$1 + 77 | 0] = 1;
 }
 return $1;
}

function yy_shift($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = HEAP32[$0 >> 2];
 $5 = $4 + 12 | 0;
 HEAP32[$0 >> 2] = $5;
 if (HEAPU32[$0 + 1208 >> 2] < $5 >>> 0) {
  HEAP32[$0 >> 2] = $4;
  yyStackOverflow($0);
  return;
 }
 HEAP16[$4 + 14 >> 1] = $2;
 HEAP16[$4 + 12 >> 1] = $1 >>> 0 > 575 ? $1 + 408 | 0 : $1;
 $0 = HEAP32[$3 + 4 >> 2];
 HEAP32[$4 + 16 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$4 + 20 >> 2] = $0;
}

function sqlite3VtabClear($0, $1) {
 var $2 = 0;
 if (!(HEAP32[$0 + 528 >> 2] ? $0 : 0)) {
  vtabDisconnectAll(0, $1);
 }
 if (HEAP32[$1 + 48 >> 2]) {
  while (1) {
   if (HEAP32[$1 + 44 >> 2] > ($2 | 0)) {
    if (($2 | 0) != 1) {
     sqlite3DbFree($0, HEAP32[HEAP32[$1 + 48 >> 2] + ($2 << 2) >> 2]);
    }
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFree($0, HEAP32[$1 + 48 >> 2]);
 }
}

function pagerUnlockAndRollback($0) {
 label$1: {
  label$2: {
   switch (HEAPU8[$0 + 17 | 0]) {
   default:
    sqlite3BeginBenignMalloc();
    sqlite3PagerRollback($0);
    sqlite3EndBenignMalloc();
    break label$1;

   case 0:
   case 6:
    break label$1;

   case 1:
    break label$2;
   }
  }
  if (HEAPU8[$0 + 4 | 0]) {
   break label$1;
  }
  pager_end_transaction($0, 0, 0);
 }
 pager_unlock($0);
}

function incrAggFunctionDepth($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 if (($1 | 0) > 0) {
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$2 + 24 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = 70;
  sqlite3WalkExpr($2, $0);
 }
 __stack_pointer = $2 + 32 | 0;
}

function sqlite3WalExclusiveMode($0, $1) {
 if (!$1) {
  if (!HEAPU8[$0 + 43 | 0]) {
   return 0;
  }
  HEAP8[$0 + 43 | 0] = 0;
  if (!walLockShared($0, HEAP16[$0 + 40 >> 1] + 3 | 0)) {
   return !HEAPU8[$0 + 43 | 0];
  }
  HEAP8[$0 + 43 | 0] = 1;
  return 0;
 }
 if (($1 | 0) > 0) {
  walUnlockShared($0, HEAP16[$0 + 40 >> 1] + 3 | 0);
  HEAP8[$0 + 43 | 0] = 1;
  return 1;
 }
 return !HEAPU8[$0 + 43 | 0];
}

function sqlite3VListNameToNum($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 if ($0) {
  $6 = HEAP32[$0 + 4 >> 2];
  $3 = 2;
  while (1) {
   $4 = ($3 << 2) + $0 | 0;
   $5 = $4 + 8 | 0;
   if (!(strncmp($5, $1, $2) | HEAPU8[$2 + $5 | 0])) {
    return HEAP32[($3 << 2) + $0 >> 2];
   }
   $3 = HEAP32[$4 + 4 >> 2] + $3 | 0;
   if (($6 | 0) > ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 return 0;
}

function sqlite3BtreeUpdateMeta($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 $0 = HEAP32[$3 + 12 >> 2];
 $4 = HEAP32[$0 + 56 >> 2];
 $0 = sqlite3PagerWrite(HEAP32[$0 + 72 >> 2]);
 label$1: {
  if ($0) {
   break label$1;
  }
  sqlite3Put4byte((($1 << 2) + $4 | 0) + 36 | 0, $2);
  if (($1 | 0) != 7) {
   break label$1;
  }
  HEAP8[$3 + 18 | 0] = $2;
 }
 return $0;
}

function matchQuality($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = 4;
 $4 = HEAP8[$0 | 0];
 label$1: {
  if (($4 | 0) != ($1 | 0)) {
   if (($1 | 0) == -2) {
    return HEAP32[$0 + 16 >> 2] ? 6 : 0;
   }
   $1 = 0;
   if (($4 | 0) >= 0) {
    break label$1;
   }
   $3 = 1;
  }
  $0 = HEAP32[$0 + 4 >> 2];
  if (($0 & 3) == ($2 | 0)) {
   return $3 | 2;
  }
  $1 = (($0 & $2) >>> 1 & 1) + $3 | 0;
 }
 return $1;
}

function sqlite3ReadSchema($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2];
 label$1: {
  if (HEAPU8[$1 + 177 | 0]) {
   break label$1;
  }
  $2 = sqlite3Init($1, $0 + 4 | 0);
  if ($2) {
   HEAP32[$0 + 12 >> 2] = $2;
   HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
   return $2;
  }
  if (!HEAPU8[$1 + 95 | 0]) {
   break label$1;
  }
  HEAP32[$1 + 24 >> 2] = HEAP32[$1 + 24 >> 2] | 16;
 }
 return 0;
}

function sqlite3ExprVectorSize($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAPU8[$0 | 0];
 if (($1 | 0) == 176) {
  $1 = HEAPU8[$0 + 2 | 0];
 }
 $2 = $1 & 255;
 label$1: {
  label$2: {
   if (($2 | 0) != 138) {
    $1 = 1;
    if (($2 | 0) != 177) {
     break label$1;
    }
    $0 = $0 + 20 | 0;
    break label$2;
   }
   $0 = HEAP32[$0 + 20 >> 2] + 28 | 0;
  }
  $1 = HEAP32[HEAP32[$0 >> 2] >> 2];
 }
 return $1;
}

function sqlite3ExprCode($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   break label$1;
  }
  $3 = sqlite3ExprCodeTarget($0, $1, $2);
  if (($3 | 0) == ($2 | 0)) {
   break label$1;
  }
  $4 = HEAP32[$0 + 8 >> 2];
  label$2: {
   if ($1) {
    $0 = 80;
    if (HEAPU8[$1 + 6 | 0] & 64) {
     break label$2;
    }
   }
   $0 = 81;
  }
  sqlite3VdbeAddOp2($4, $0, $3, $2);
 }
}

function pagerUndoCallback($0, $1) {
 var $2 = 0;
 $1 = sqlite3PagerLookup($0, $1);
 label$1: {
  if (!$1) {
   break label$1;
  }
  if ((sqlite3PcachePageRefcount($1) | 0) == 1) {
   sqlite3PcacheDrop($1);
   break label$1;
  }
  $2 = readDbPage($1);
  if (!$2) {
   FUNCTION_TABLE[HEAP32[$0 + 216 >> 2]]($1);
  }
  sqlite3PagerUnrefNotNull($1);
 }
 sqlite3BackupRestart(HEAP32[$0 + 96 >> 2]);
 return $2;
}

function collationMatch($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAPU16[$1 + 52 >> 1];
 while (1) {
  label$2: {
   if (($2 | 0) != ($3 | 0)) {
    if (HEAP16[HEAP32[$1 + 4 >> 2] + ($2 << 1) >> 1] < 0) {
     break label$2;
    }
    if (sqlite3StrICmp(HEAP32[HEAP32[$1 + 32 >> 2] + ($2 << 2) >> 2], $0)) {
     break label$2;
    }
    $4 = 1;
   }
   return $4;
  }
  $2 = $2 + 1 | 0;
  continue;
 }
}

function sqlite3Fts3SegReaderFinish($0) {
 var $1 = 0, $2 = 0;
 if ($0) {
  while (1) {
   $2 = HEAP32[$0 >> 2];
   if (($1 | 0) < HEAP32[$0 + 4 >> 2]) {
    sqlite3Fts3SegReaderFree(HEAP32[($1 << 2) + $2 >> 2]);
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3_free($2);
  sqlite3_free(HEAP32[$0 + 16 >> 2]);
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
}

function renameColumnIdlistNames($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  $5 = HEAP32[$2 >> 2];
  while (1) {
   if (($5 | 0) <= ($4 | 0)) {
    break label$1;
   }
   $6 = HEAP32[(($4 << 3) + $2 | 0) + 8 >> 2];
   if (!sqlite3_stricmp($6, $3)) {
    renameTokenFind($0, $1, $6);
    $5 = HEAP32[$2 >> 2];
   }
   $4 = $4 + 1 | 0;
   continue;
  }
 }
}

function jsonEachConnect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $1 = sqlite3_declare_vtab($0, 25302);
 if (!$1) {
  $1 = sqlite3_malloc(12);
  HEAP32[$4 >> 2] = $1;
  if (!$1) {
   return 7;
  }
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = 0;
  sqlite3_vtab_config($0, 2, 0);
  $1 = 0;
 }
 return $1 | 0;
}

function vdbeMemAddTerminator($0) {
 var $1 = 0;
 $1 = 7;
 if (!sqlite3VdbeMemGrow($0, HEAP32[$0 + 12 >> 2] + 3 | 0, 1)) {
  HEAP8[HEAP32[$0 + 8 >> 2] + HEAP32[$0 + 12 >> 2] | 0] = 0;
  HEAP8[(HEAP32[$0 + 12 >> 2] + HEAP32[$0 + 8 >> 2] | 0) + 1 | 0] = 0;
  HEAP8[(HEAP32[$0 + 12 >> 2] + HEAP32[$0 + 8 >> 2] | 0) + 2 | 0] = 0;
  HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] | 512;
  $1 = 0;
 }
 return $1;
}

function seriesConnect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $1 = sqlite3_declare_vtab($0, 24666);
 if (!$1) {
  $1 = sqlite3_malloc(12);
  HEAP32[$4 >> 2] = $1;
  if (!$1) {
   return 7;
  }
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 + 8 >> 2] = 0;
  sqlite3_vtab_config($0, 2, 0);
  $1 = 0;
 }
 return $1 | 0;
}

function fts3WriteSegment($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $6 = __stack_pointer - 16 | 0;
 __stack_pointer = $6;
 $0 = fts3SqlStmt($0, 9, $6 + 12 | 0, 0);
 if (!$0) {
  $5 = HEAP32[$6 + 12 >> 2];
  sqlite3_bind_int64($5, 1, $1, $2);
  sqlite3_bind_blob($5, 2, $3, $4, 0);
  sqlite3_step($5);
  $0 = sqlite3_reset($5);
  sqlite3_bind_null($5, 2);
 }
 __stack_pointer = $6 + 16 | 0;
 return $0;
}

function rad2degFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, rad2deg($3));
  return;
 }
 __assert_fail(23175, 17353, 498, 17209);
 abort();
}

function deg2radFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, deg2rad($3));
  return;
 }
 __assert_fail(23175, 17353, 499, 17268);
 abort();
}

function countStep($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 8);
 label$1: {
  if ($1) {
   if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
    break label$1;
   }
  }
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[$0 + 4 >> 2];
  $2 = HEAP32[$0 >> 2] + 1 | 0;
  $1 = $2 ? $1 : $1 + 1 | 0;
  HEAP32[$0 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = $1;
 }
}

function avgFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  $2 = sqlite3_aggregate_context($0, 0);
  if (!$2) {
   break label$1;
  }
  $1 = HEAP32[$2 + 20 >> 2];
  $4 = $1;
  $3 = HEAP32[$2 + 16 >> 2];
  if (!$3 & ($1 | 0) <= 0 | ($1 | 0) < 0) {
   break label$1;
  }
  $1 = $3;
  sqlite3_result_double($0, HEAPF64[$2 >> 3] / (+($1 >>> 0) + +($4 | 0) * 4294967296));
 }
}

function sqrtFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, Math_sqrt($3));
  return;
 }
 __assert_fail(23175, 17353, 375, 17010);
 abort();
}

function sqlite3LookasideUsed($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = countLookasideSlots(HEAP32[$0 + 332 >> 2]);
 $3 = countLookasideSlots(HEAP32[$0 + 336 >> 2]);
 $2 = countLookasideSlots(HEAP32[$0 + 340 >> 2]) + $2 | 0;
 $4 = countLookasideSlots(HEAP32[$0 + 344 >> 2]);
 if ($1) {
  HEAP32[$1 >> 2] = HEAP32[$0 + 316 >> 2] - $2;
 }
 return HEAP32[$0 + 316 >> 2] - (($2 + $3 | 0) + $4 | 0) | 0;
}

function fts3IsAppendable($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 $0 = fts3SqlStmt($0, 34, $4 + 12 | 0, 0);
 if (!$0) {
  $0 = HEAP32[$4 + 12 >> 2];
  sqlite3_bind_int64($0, 1, $1, $2);
  $5 = (sqlite3_step($0) | 0) == 100;
  $0 = sqlite3_reset($0);
 }
 HEAP32[$3 >> 2] = $5;
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function fts3FindFunctionMethod($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $5 = 0, $6 = 0;
 while (1) {
  label$2: {
   if (($5 | 0) != 4) {
    if (strcmp($2, HEAP32[($5 << 3) + 55040 >> 2])) {
     break label$2;
    }
    HEAP32[$3 >> 2] = HEAP32[($5 << 3) + 55044 >> 2];
    $6 = 1;
   }
   return $6 | 0;
  }
  $5 = $5 + 1 | 0;
  continue;
 }
}

function sqlite3ExprCodeLoadIndexColumn($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP16[HEAP32[$1 + 4 >> 2] + ($3 << 1) >> 1];
 if (($5 | 0) == -2) {
  HEAP32[$0 + 52 >> 2] = $2 + 1;
  sqlite3ExprCodeCopy($0, HEAP32[(HEAP32[$1 + 40 >> 2] + ($3 << 4) | 0) + 8 >> 2], $4);
  HEAP32[$0 + 52 >> 2] = 0;
  return;
 }
 sqlite3ExprCodeGetColumnOfTable(HEAP32[$0 + 8 >> 2], HEAP32[$1 + 12 >> 2], $2, $5, $4);
}

function sqlite3DbMallocSize($0, $1) {
 var $2 = 0;
 label$1: {
  label$2: {
   if (!$0 | HEAPU32[$0 + 356 >> 2] <= $1 >>> 0) {
    break label$2;
   }
   $2 = 128;
   if (HEAPU32[$0 + 348 >> 2] <= $1 >>> 0) {
    break label$1;
   }
   if (HEAPU32[$0 + 352 >> 2] > $1 >>> 0) {
    break label$2;
   }
   return HEAPU16[$0 + 310 >> 1];
  }
  $2 = FUNCTION_TABLE[HEAP32[16079]]($1) | 0;
 }
 return $2;
}

function whereRangeScanEst($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = HEAP16[$2 + 22 >> 1];
 $3 = whereRangeAdjust($1, whereRangeAdjust($0, $4));
 $3 = !$0 | !$1 | HEAP16[$0 + 8 >> 1] <= 0 ? $3 : HEAP16[$1 + 8 >> 1] > 0 ? $3 - 20 | 0 : $3;
 $0 = (($0 ? -1 : 0) - (($1 | 0) != 0) | 0) + $4 | 0;
 $1 = $3 << 16 >> 16;
 $1 = ($1 | 0) > 10 ? $1 : 10;
 HEAP16[$2 + 22 >> 1] = ($0 | 0) < ($1 | 0) ? $0 : $1;
}

function sqlite3WindowAssemble($0, $1, $2, $3, $4) {
 label$1: {
  if ($1) {
   HEAP32[$1 + 12 >> 2] = $3;
   HEAP32[$1 + 8 >> 2] = $2;
   if (!$4) {
    break label$1;
   }
   HEAP32[$1 + 4 >> 2] = sqlite3DbStrNDup(HEAP32[$0 >> 2], HEAP32[$4 >> 2], HEAP32[$4 + 4 >> 2], 0);
   return $1;
  }
  sqlite3ExprListDelete(HEAP32[$0 >> 2], $2);
  sqlite3ExprListDelete(HEAP32[$0 >> 2], $3);
 }
 return $1;
}

function sqlite3Fts3MaxLevel($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 0;
 $0 = fts3SqlStmt($0, 36, $2 + 12 | 0, 0);
 if (!$0) {
  $0 = HEAP32[$2 + 12 >> 2];
  if ((sqlite3_step($0) | 0) == 100) {
   $3 = sqlite3_column_int($0, 0);
  }
  $0 = sqlite3_reset($0);
 }
 HEAP32[$1 >> 2] = $3;
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function sqlite3VdbeReusable($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAP32[$0 + 108 >> 2];
 $3 = ($1 | 0) > 1 ? $1 : 1;
 $1 = 1;
 label$1: {
  while (1) {
   if (($1 | 0) == ($3 | 0)) {
    break label$1;
   }
   $4 = Math_imul($1, 20);
   $1 = $1 + 1 | 0;
   $2 = HEAP32[$0 + 104 >> 2];
   if (HEAPU8[$2 + $4 | 0] != 166) {
    continue;
   }
   break;
  }
  HEAP8[$2 + 20 | 0] = 184;
 }
}

function sqlite3VMPrintf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 112 | 0;
 __stack_pointer = $3;
 sqlite3StrAccumInit($3 + 8 | 0, $0, $3 + 32 | 0, 70, HEAP32[$0 + 120 >> 2]);
 HEAP8[$3 + 29 | 0] = 1;
 sqlite3_str_vappendf($3 + 8 | 0, $1, $2);
 $2 = sqlite3StrAccumFinish($3 + 8 | 0);
 if (HEAPU8[$3 + 28 | 0] == 7) {
  sqlite3OomFault($0);
 }
 __stack_pointer = $3 + 112 | 0;
 return $2;
}

function sqlite3CteNew($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0;
 $5 = HEAP32[$0 >> 2];
 $6 = sqlite3DbMallocZero($5, 24, 0);
 if (HEAPU8[$5 + 87 | 0]) {
  sqlite3ExprListDelete($5, $2);
  sqlite3SelectDelete($5, $3);
  return $6;
 }
 HEAP32[$6 + 4 >> 2] = $2;
 HEAP32[$6 + 8 >> 2] = $3;
 $5 = sqlite3NameFromToken(HEAP32[$0 >> 2], $1);
 HEAP8[$6 + 20 | 0] = $4;
 HEAP32[$6 >> 2] = $5;
 return $6;
}

function log10Func($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, log10($3));
  return;
 }
 __assert_fail(23175, 17353, 473, 17298);
 abort();
}

function atanhFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, atanh($3));
  return;
 }
 __assert_fail(23175, 17353, 410, 17191);
 abort();
}

function asinhFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, asinh($3));
  return;
 }
 __assert_fail(23175, 17353, 402, 17181);
 abort();
}

function acoshFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, acosh($3));
  return;
 }
 __assert_fail(23175, 17353, 394, 17171);
 abort();
}

function fts3Writelock($0) {
 var $1 = 0, $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (HEAP32[$0 + 268 >> 2]) {
   break label$1;
  }
  $1 = fts3SqlStmt($0, 16, $2 + 12 | 0, 0);
  if ($1) {
   break label$1;
  }
  $1 = HEAP32[$2 + 12 >> 2];
  sqlite3_bind_null($1, 1);
  sqlite3_step($1);
  $1 = sqlite3_reset($1);
 }
 __stack_pointer = $2 + 16 | 0;
 return $1;
}

function tanhFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, tanh($3));
  return;
 }
 __assert_fail(23175, 17353, 454, 17192);
 abort();
}

function strcmp($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU8[$0 | 0];
 $3 = HEAPU8[$1 | 0];
 label$1: {
  if (!$2 | ($3 | 0) != ($2 | 0)) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$1 + 1 | 0];
   $2 = HEAPU8[$0 + 1 | 0];
   if (!$2) {
    break label$1;
   }
   $1 = $1 + 1 | 0;
   $0 = $0 + 1 | 0;
   if (($2 | 0) == ($3 | 0)) {
    continue;
   }
   break;
  }
 }
 return $2 - $3 | 0;
}

function sqlite3WhereMalloc($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = $2;
 $3 = $1 + 16 | 0;
 $4 = $3 >>> 0 < 16 ? $4 + 1 | 0 : $4;
 $3 = sqlite3DbMallocRawNN(HEAP32[HEAP32[$0 >> 2] >> 2], $3, $4);
 if (!$3) {
  return 0;
 }
 $5 = HEAP32[$0 + 72 >> 2];
 HEAP32[$3 + 8 >> 2] = $1;
 $4 = $2;
 HEAP32[$3 + 12 >> 2] = $4;
 HEAP32[$3 >> 2] = $5;
 HEAP32[$0 + 72 >> 2] = $3;
 return $3 + 16 | 0;
}

function sinhFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, sinh($3));
  return;
 }
 __assert_fail(23175, 17353, 438, 17182);
 abort();
}

function cothFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, coth($3));
  return;
 }
 __assert_fail(23175, 17353, 456, 17162);
 abort();
}

function coshFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, cosh($3));
  return;
 }
 __assert_fail(23175, 17353, 446, 17172);
 abort();
}

function atanFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, atan($3));
  return;
 }
 __assert_fail(23175, 17353, 380, 17135);
 abort();
}

function asinFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, asin($3));
  return;
 }
 __assert_fail(23175, 17353, 379, 17117);
 abort();
}

function acosFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, acos($3));
  return;
 }
 __assert_fail(23175, 17353, 378, 17046);
 abort();
}

function upsertDelete($0, $1) {
 var $2 = 0;
 while (1) {
  $2 = HEAP32[$1 + 16 >> 2];
  sqlite3ExprListDelete($0, HEAP32[$1 >> 2]);
  sqlite3ExprDelete($0, HEAP32[$1 + 4 >> 2]);
  sqlite3ExprListDelete($0, HEAP32[$1 + 8 >> 2]);
  sqlite3ExprDelete($0, HEAP32[$1 + 12 >> 2]);
  sqlite3DbFree($0, HEAP32[$1 + 24 >> 2]);
  sqlite3DbFree($0, $1);
  $1 = $2;
  if ($1) {
   continue;
  }
  break;
 }
}

function sqlite3ExprAttachSubtrees($0, $1, $2, $3) {
 if (!$1) {
  sqlite3ExprDelete($0, $2);
  sqlite3ExprDelete($0, $3);
  return;
 }
 if ($3) {
  HEAP32[$1 + 16 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | HEAP32[$3 + 4 >> 2] & 4194824;
 }
 if ($2) {
  HEAP32[$1 + 12 >> 2] = $2;
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | HEAP32[$2 + 4 >> 2] & 4194824;
 }
 exprSetHeight($1);
}

function tanFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, tan($3));
  return;
 }
 __assert_fail(23175, 17353, 421, 17136);
 abort();
}

function sqlite3_get_auxdata($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$0 + 12 >> 2] + 232 | 0;
 $3 = ($1 | 0) < 0;
 while (1) {
  label$2: {
   $2 = HEAP32[$2 >> 2];
   if ($2) {
    if (!$3 & HEAP32[$2 >> 2] != HEAP32[$0 + 16 >> 2] | HEAP32[$2 + 4 >> 2] != ($1 | 0)) {
     break label$2;
    }
    $4 = HEAP32[$2 + 8 >> 2];
   }
   return $4;
  }
  $2 = $2 + 16 | 0;
  continue;
 }
}

function sqlite3WhereExprListUsage($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  while (1) {
   if (HEAP32[$1 >> 2] <= ($2 | 0)) {
    break label$1;
   }
   $3 = sqlite3WhereExprUsage($0, HEAP32[(($2 << 4) + $1 | 0) + 8 >> 2]) | $3;
   $4 = i64toi32_i32$HIGH_BITS | $4;
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 i64toi32_i32$HIGH_BITS = $4;
 return $3;
}

function sqlite3WalBeginWriteTransaction($0) {
 var $1 = 0;
 $1 = 8;
 label$1: {
  if (HEAPU8[$0 + 46 | 0]) {
   break label$1;
  }
  $1 = walLockExclusive($0, 0, 1);
  if ($1) {
   break label$1;
  }
  HEAP8[$0 + 44 | 0] = 1;
  $1 = 0;
  if (!memcmp($0 + 52 | 0, walIndexHdr($0), 48)) {
   break label$1;
  }
  walUnlockExclusive($0, 0, 1);
  HEAP8[$0 + 44 | 0] = 0;
  $1 = 517;
 }
 return $1;
}

function sqlite3VdbeGetBoundValue($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = (HEAP32[$0 + 100 >> 2] + Math_imul($1, 40) | 0) - 40 | 0;
  if (HEAP8[$1 + 16 | 0] & 1) {
   break label$1;
  }
  $0 = sqlite3ValueNew(HEAP32[$0 >> 2]);
  if (!$0) {
   break label$1;
  }
  sqlite3VdbeMemCopy($0, $1);
  sqlite3ValueApplyAffinity($0, 65, 1);
  $2 = $0;
 }
 return $2;
}

function sqlite3SrcListLookup($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = $1 + 8 | 0;
 $2 = sqlite3LocateTableItem($0, 0, $3);
 sqlite3DeleteTable(HEAP32[$0 >> 2], HEAP32[$1 + 24 >> 2]);
 HEAP32[$1 + 24 >> 2] = $2;
 if ($2) {
  HEAP32[$2 + 24 >> 2] = HEAP32[$2 + 24 >> 2] + 1;
  if (!(HEAPU8[$1 + 45 | 0] & 2)) {
   return $2;
  }
  $4 = sqlite3IndexedByLookup($0, $3) ? 0 : $2;
 }
 return $4;
}

function sqlite3ErrStr($0) {
 var $1 = 0;
 label$1: {
  switch ($0 - 100 | 0) {
  case 0:
   return 13753;

  case 1:
   return 13775;

  default:
   break label$1;
  }
 }
 $1 = 19673;
 label$4: {
  if (($0 | 0) == 516) {
   break label$4;
  }
  $0 = $0 & 255;
  $1 = 8530;
  if ($0 >>> 0 > 28 | 16842756 >>> $0 & 1) {
   break label$4;
  }
  $1 = HEAP32[($0 << 2) + 51280 >> 2];
 }
 return $1;
}

function sinFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, sin($3));
  return;
 }
 __assert_fail(23175, 17353, 419, 17118);
 abort();
}

function pragmaVtabNext($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 $2 = HEAP32[$0 + 8 >> 2] + 1 | 0;
 $1 = $2 ? $1 : $1 + 1 | 0;
 HEAP32[$0 + 8 >> 2] = $2;
 HEAP32[$0 + 12 >> 2] = $1;
 if ((sqlite3_step(HEAP32[$0 + 4 >> 2]) | 0) != 100) {
  $3 = sqlite3_finalize(HEAP32[$0 + 4 >> 2]);
  HEAP32[$0 + 4 >> 2] = 0;
  pragmaVtabCursorClear($0);
 }
 return $3 | 0;
}

function logFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, log($3));
  return;
 }
 __assert_fail(23175, 17353, 472, 17201);
 abort();
}

function fts3ExprLoadDoclists($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 4 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 >> 2] = $0;
 $0 = fts3ExprIterate(HEAP32[$0 + 16 >> 2], 109, $3);
 if ($1) {
  HEAP32[$1 >> 2] = HEAP32[$3 + 4 >> 2];
 }
 if ($2) {
  HEAP32[$2 >> 2] = HEAP32[$3 + 8 >> 2];
 }
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function expFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, exp($3));
  return;
 }
 __assert_fail(23175, 17353, 474, 17109);
 abort();
}

function cotFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, cot($3));
  return;
 }
 __assert_fail(23175, 17353, 422, 17019);
 abort();
}

function cosFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (($1 | 0) == 1) {
  if ((sqlite3_value_type(HEAP32[$2 >> 2]) | 0) == 5) {
   sqlite3_result_null($0);
   return;
  }
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  HEAP32[__errno_location() >> 2] = 0;
  sqlite3_result_double($0, cos($3));
  return;
 }
 __assert_fail(23175, 17353, 420, 17047);
 abort();
}

function codeCompare($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 if (!HEAP32[$0 + 36 >> 2]) {
  label$2: {
   if ($8) {
    $8 = sqlite3BinaryCompareCollSeq($0, $2, $1);
    break label$2;
   }
   $8 = sqlite3BinaryCompareCollSeq($0, $1, $2);
  }
  $2 = binaryCompareP5($1, $2, $7);
  sqlite3VdbeAddOp4(HEAP32[$0 + 8 >> 2], $3, $5, $6, $4, $8, -2);
  sqlite3VdbeChangeP5(HEAP32[$0 + 8 >> 2], $2);
 }
}

function fkChildIsModified($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = HEAP32[$1 + 20 >> 2];
 $6 = ($4 | 0) > 0 ? $4 : 0;
 while (1) {
  if (($5 | 0) == ($6 | 0)) {
   return 0;
  }
  $4 = HEAP32[(($5 << 3) + $1 | 0) + 36 >> 2];
  if (HEAP32[($4 << 2) + $2 >> 2] < 0) {
   $5 = $5 + 1 | 0;
   if (!$3 | HEAP16[$0 + 32 >> 1] != ($4 | 0)) {
    continue;
   }
  }
  break;
 }
 return 1;
}

function sqlite3DbSpanDup($0, $1, $2) {
 var $3 = 0;
 while (1) {
  $3 = $1;
  $1 = $3 + 1 | 0;
  if (HEAP8[HEAPU8[$3 | 0] + 30288 | 0] & 1) {
   continue;
  }
  break;
 }
 $1 = $2 - $3 | 0;
 while (1) {
  $2 = $1;
  if (($2 | 0) > 0) {
   $1 = $2 - 1 | 0;
   if (HEAP8[HEAPU8[$3 + $1 | 0] + 30288 | 0] & 1) {
    continue;
   }
  }
  break;
 }
 return sqlite3DbStrNDup($0, $3, $2, $2 >> 31);
}

function saveAllCursors($0, $1, $2) {
 $0 = $0 + 8 | 0;
 label$1: {
  while (1) {
   $0 = HEAP32[$0 >> 2];
   if (!$0) {
    break label$1;
   }
   if (!((!$1 | HEAP32[$0 + 64 >> 2] == ($1 | 0)) & ($0 | 0) != ($2 | 0))) {
    $0 = $0 + 24 | 0;
    continue;
   }
   break;
  }
  return saveCursorsOnList($0, $1, $2);
 }
 if ($2) {
  HEAP8[$2 + 1 | 0] = HEAPU8[$2 + 1 | 0] & 223;
 }
 return 0;
}

function jsonParseAddNodeExpand($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = -1;
 if (!HEAPU8[$0 + 20 | 0]) {
  $4 = (HEAP32[$0 + 4 >> 2] << 1) + 10 | 0;
  $5 = sqlite3_realloc64(HEAP32[$0 + 8 >> 2], Math_imul($4, 12), 0);
  if (!$5) {
   HEAP8[$0 + 20 | 0] = 1;
   return -1;
  }
  HEAP32[$0 + 8 >> 2] = $5;
  HEAP32[$0 + 4 >> 2] = $4;
  $4 = jsonParseAddNode($0, $1, $2, $3);
 }
 return $4;
}

function fts3DbExec($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 label$1: {
  if (HEAP32[$0 >> 2]) {
   break label$1;
  }
  HEAP32[$4 + 12 >> 2] = $3;
  $3 = sqlite3_vmprintf($2, $3);
  if (!$3) {
   HEAP32[$0 >> 2] = 7;
   break label$1;
  }
  HEAP32[$0 >> 2] = sqlite3_exec($1, $3, 0, 0, 0);
  sqlite3_free($3);
 }
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3RecordErrorByteOffset($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0 | HEAP32[$0 + 68 >> 2] != -2) {
   break label$1;
  }
  $2 = HEAP32[$0 + 264 >> 2];
  if (!$2) {
   break label$1;
  }
  $2 = HEAP32[$2 + 232 >> 2];
  if (!$2 | $1 >>> 0 < $2 >>> 0) {
   break label$1;
  }
  if (strlen($2) + $2 >>> 0 <= $1 >>> 0) {
   break label$1;
  }
  HEAP32[$0 + 68 >> 2] = $1 - $2;
 }
}

function moveToParent($0) {
 var $1 = 0, $2 = 0;
 HEAP16[$0 + 50 >> 1] = 0;
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 249;
 $1 = HEAP8[$0 + 68 | 0];
 HEAP16[$0 + 70 >> 1] = HEAPU16[(($1 << 1) + $0 | 0) + 70 >> 1];
 $1 = $1 - 1 | 0;
 HEAP8[$0 + 68 | 0] = $1;
 $2 = HEAP32[$0 + 116 >> 2];
 HEAP32[$0 + 116 >> 2] = HEAP32[(($1 << 24 >> 24 << 2) + $0 | 0) + 120 >> 2];
 releasePageNotNull($2);
}

function unixLogErrorAtLine($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 $5 = HEAP32[__errno_location() >> 2];
 HEAP32[$4 + 16 >> 2] = strerror($5);
 HEAP32[$4 + 12 >> 2] = $2 ? $2 : 29623;
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP32[$4 + 4 >> 2] = $5;
 HEAP32[$4 >> 2] = $3;
 sqlite3_log($0, 8314, $4);
 __stack_pointer = $4 + 32 | 0;
 return $0;
}

function sqlite3PagerOpenWal($0, $1) {
 label$1: {
  if (!(HEAPU8[$0 + 12 | 0] | HEAP32[$0 + 232 >> 2])) {
   if (!sqlite3PagerWalSupported($0)) {
    return 14;
   }
   sqlite3OsClose(HEAP32[$0 + 68 >> 2]);
   $1 = pagerOpenWal($0);
   if ($1) {
    break label$1;
   }
   HEAP8[$0 + 17 | 0] = 0;
   HEAP8[$0 + 5 | 0] = 5;
   return 0;
  }
  HEAP32[$1 >> 2] = 1;
  $1 = 0;
 }
 return $1;
}

function sqlite3MemMalloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $2 = dlmalloc($0 + 8 | 0);
 label$1: {
  if ($2) {
   HEAP32[$2 >> 2] = $0;
   HEAP32[$2 + 4 >> 2] = $0 >> 31;
   $0 = $2 + 8 | 0;
   break label$1;
  }
  HEAP32[$1 >> 2] = $0;
  sqlite3_log(7, 1155, $1);
  $0 = 0;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0 | 0;
}

function fts3RemoveSegdirEntry($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = 0;
 $0 = fts3SqlStmt($0, 30, $4 + 12 | 0, 0);
 if (!$0) {
  $0 = HEAP32[$4 + 12 >> 2];
  sqlite3_bind_int64($0, 1, $1, $2);
  sqlite3_bind_int($0, 2, $3);
  sqlite3_step($0);
  $0 = sqlite3_reset($0);
 }
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function fts3MatchinfoFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (!fts3FunctionArg($0, 9629, HEAP32[$2 >> 2], $3 + 12 | 0)) {
  if (($1 | 0) >= 2) {
   $4 = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
  }
  sqlite3Fts3Matchinfo($0, HEAP32[$3 + 12 >> 2], $4);
 }
 __stack_pointer = $3 + 16 | 0;
}

function createAggContext($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 if (($1 | 0) <= 0) {
  sqlite3VdbeMemSetNull($2);
  HEAP32[$2 + 8 >> 2] = 0;
  return 0;
 }
 sqlite3VdbeMemClearAndResize($2, $1);
 HEAP16[$2 + 16 >> 1] = 32768;
 HEAP32[$2 >> 2] = HEAP32[$0 + 4 >> 2];
 $0 = HEAP32[$2 + 8 >> 2];
 if ($0) {
  memset($0, 0, $1);
  $3 = HEAP32[$2 + 8 >> 2];
 }
 return $3;
}

function heightOfSelect($0, $1) {
 while (1) {
  if ($0) {
   heightOfExpr(HEAP32[$0 + 36 >> 2], $1);
   heightOfExpr(HEAP32[$0 + 44 >> 2], $1);
   heightOfExpr(HEAP32[$0 + 60 >> 2], $1);
   heightOfExprList(HEAP32[$0 + 28 >> 2], $1);
   heightOfExprList(HEAP32[$0 + 40 >> 2], $1);
   heightOfExprList(HEAP32[$0 + 48 >> 2], $1);
   $0 = HEAP32[$0 + 52 >> 2];
   continue;
  }
  break;
 }
}

function sqlite3CodeRowTriggerDirect($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = sqlite3GetVdbe($0);
 $4 = getRowTrigger($0, $1, $2, $4);
 if ($4) {
  $1 = !(HEAP32[$1 >> 2] ? HEAPU8[HEAP32[$0 >> 2] + 33 | 0] & 32 : 1);
  $2 = HEAP32[$0 + 44 >> 2] + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $2;
  sqlite3VdbeAddOp4($6, 47, $3, $5, $2, HEAP32[$4 + 8 >> 2], -4);
  sqlite3VdbeChangeP5($6, $1);
 }
}

function __sin($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $3 = $0 * $0;
 $5 = $3 * ($3 * $3) * ($3 * 1.58969099521155e-10 + -2.5050760253406863e-8) + ($3 * ($3 * 27557313707070068e-22 + -.0001984126982985795) + .00833333333332249);
 $4 = $3 * $0;
 if (!$2) {
  return $4 * ($3 * $5 + -.16666666666666632) + $0;
 }
 return $0 - ($3 * ($1 * .5 - $5 * $4) - $1 + $4 * .16666666666666632);
}

function sqlite3VdbeSetNumCols($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAP32[$0 >> 2];
 $2 = HEAPU16[$0 + 144 >> 1];
 if ($2) {
  releaseMemArray(HEAP32[$0 + 116 >> 2], $2 << 1);
  sqlite3DbFree($3, HEAP32[$0 + 116 >> 2]);
 }
 HEAP16[$0 + 144 >> 1] = $1;
 $2 = sqlite3DbMallocRawNN($3, Math_imul($1, 80), 0);
 HEAP32[$0 + 116 >> 2] = $2;
 if ($2) {
  initMemArray($2, $1 << 1, $3, 1);
 }
}

function sqlite3TriggerDeleteStep($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP32[$0 >> 2];
 $4 = triggerStepAllocate($0, 128, $1, $3, $4);
 if ($4) {
  label$2: {
   if (HEAPU8[$0 + 208 | 0] > 1) {
    $0 = $2;
    $2 = 0;
    break label$2;
   }
   $0 = sqlite3ExprDup($5, $2, 1);
  }
  HEAP8[$4 + 1 | 0] = 11;
  HEAP32[$4 + 20 >> 2] = $0;
 }
 sqlite3ExprDelete($5, $2);
 return $4;
}

function jsonLabelCompare($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if (HEAP8[$0 + 1 | 0] & 1) {
   $3 = 0;
   if (($2 | 0) != ($4 | 0)) {
    break label$1;
   }
   return !strncmp(HEAP32[$0 + 8 >> 2], $1, $2);
  }
  $3 = 0;
  if (($2 + 2 | 0) != ($4 | 0)) {
   break label$1;
  }
  $3 = !strncmp(HEAP32[$0 + 8 >> 2] + 1 | 0, $1, $2);
 }
 return $3;
}

function extendFJMatch($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = sqlite3ExprAlloc(HEAP32[$0 >> 2], 167, 0, 0);
 if ($4) {
  $5 = HEAP32[$2 + 40 >> 2];
  HEAP16[$4 + 32 >> 1] = $3;
  HEAP32[$4 + 28 >> 2] = $5;
  HEAP32[$4 + 44 >> 2] = HEAP32[$2 + 16 >> 2];
  HEAP32[$4 + 4 >> 2] = HEAP32[$4 + 4 >> 2] | 2097152;
  HEAP32[$1 >> 2] = sqlite3ExprListAppend($0, HEAP32[$1 >> 2], $4);
 }
}

function windowFind($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 label$1: {
  while (1) {
   if ($1) {
    if (!sqlite3StrICmp(HEAP32[$1 >> 2], $2)) {
     break label$1;
    }
    $1 = HEAP32[$1 + 36 >> 2];
    continue;
   }
   break;
  }
  HEAP32[$3 >> 2] = $2;
  sqlite3ErrorMsg($0, 7064, $3);
 }
 __stack_pointer = $3 + 16 | 0;
 return $1;
}

function fts3OffsetsFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 label$1: {
  if (fts3FunctionArg($0, 3889, HEAP32[$2 >> 2], $1 + 12 | 0)) {
   break label$1;
  }
  $2 = HEAP32[$1 + 12 >> 2];
  if (fts3CursorSeek($0, $2)) {
   break label$1;
  }
  sqlite3Fts3Offsets($0, $2);
 }
 __stack_pointer = $1 + 16 | 0;
}

function windowExprGtZero($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $0 = HEAP32[$0 >> 2];
 HEAP32[$2 + 12 >> 2] = 0;
 sqlite3ValueFromExpr($0, $1, HEAPU8[$0 + 84 | 0], 67, $2 + 12 | 0);
 $0 = HEAP32[$2 + 12 >> 2];
 if ($0) {
  $3 = (sqlite3_value_int($0) | 0) > 0;
 }
 sqlite3ValueFree($0);
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function saveCursorPosition($0) {
 var $1 = 0;
 $1 = 2835;
 if (!(HEAPU8[$0 + 1 | 0] & 64)) {
  label$2: {
   if (HEAPU8[$0 | 0] == 2) {
    HEAP8[$0 | 0] = 0;
    break label$2;
   }
   HEAP32[$0 + 4 >> 2] = 0;
  }
  $1 = saveCursorKey($0);
  if (!$1) {
   btreeReleaseAllCursorPages($0);
   HEAP8[$0 | 0] = 3;
  }
  HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 241;
 }
 return $1;
}

function pagerRollbackWal($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 32 >> 2];
 $2 = sqlite3WalUndo(HEAP32[$0 + 232 >> 2], $0);
 $1 = sqlite3PcacheDirtyList(HEAP32[$0 + 228 >> 2]);
 while (1) {
  if (!(!$1 | $2)) {
   $3 = HEAP32[$1 + 16 >> 2];
   $2 = pagerUndoCallback($0, HEAP32[$1 + 24 >> 2]);
   $1 = $3;
   continue;
  }
  break;
 }
 return $2;
}

function btreeReleaseAllCursorPages($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP8[$0 + 68 | 0];
 if (($1 | 0) >= 0) {
  while (1) {
   if (($2 | 0) < ($1 | 0)) {
    releasePageNotNull(HEAP32[(($2 << 2) + $0 | 0) + 120 >> 2]);
    $2 = $2 + 1 | 0;
    $1 = HEAP8[$0 + 68 | 0];
    continue;
   }
   break;
  }
  releasePageNotNull(HEAP32[$0 + 116 >> 2]);
  HEAP8[$0 + 68 | 0] = 255;
 }
}

function fts3tokQueryTokenizer($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $5 = 1;
 $0 = sqlite3Fts3HashFind($0, $1, strlen($1) + 1 | 0);
 label$1: {
  if (!$0) {
   HEAP32[$4 >> 2] = $1;
   sqlite3Fts3ErrMsg($3, 7260, $4);
   break label$1;
  }
  HEAP32[$2 >> 2] = $0;
  $5 = 0;
 }
 __stack_pointer = $4 + 16 | 0;
 return $5;
}

function fts3IncrmergeHintPush($0, $1, $2, $3, $4) {
 blobGrowBuffer($0, HEAP32[$0 + 4 >> 2] + 20 | 0, $4);
 if (!HEAP32[$4 >> 2]) {
  $4 = sqlite3Fts3PutVarint(HEAP32[$0 >> 2] + HEAP32[$0 + 4 >> 2] | 0, $1, $2) + HEAP32[$0 + 4 >> 2] | 0;
  HEAP32[$0 + 4 >> 2] = $4;
  HEAP32[$0 + 4 >> 2] = sqlite3Fts3PutVarint(HEAP32[$0 >> 2] + $4 | 0, $3, $3 >> 31) + HEAP32[$0 + 4 >> 2];
 }
}

function sqlite3WindowAttach($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if ($1) {
   HEAP32[$1 + 44 >> 2] = $2;
   $3 = HEAP32[$1 + 4 >> 2];
   HEAP32[$1 + 4 >> 2] = $3 | 16777216;
   HEAP32[$2 + 72 >> 2] = $1;
   if (!($3 & 4) | HEAPU8[$2 + 16 | 0] == 166) {
    break label$1;
   }
   sqlite3ErrorMsg($0, 4576, 0);
   return;
  }
  sqlite3WindowDelete(HEAP32[$0 >> 2], $2);
 }
}

function sqlite3Savepoint($0, $1, $2) {
 var $3 = 0;
 $2 = sqlite3NameFromToken(HEAP32[$0 >> 2], $2);
 if ($2) {
  label$2: {
   $3 = sqlite3GetVdbe($0);
   if ($3) {
    if (!sqlite3AuthCheck($0, 32, HEAP32[($1 << 2) + 48660 >> 2], $2, 0)) {
     break label$2;
    }
   }
   sqlite3DbFree(HEAP32[$0 >> 2], $2);
   return;
  }
  sqlite3VdbeAddOp4($3, 0, $1, 0, 0, $2, -6);
 }
}

function btreeParseCellAdjustSizeForOverflow($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAPU16[$0 + 16 >> 1];
 $4 = $3;
 $3 = ((HEAP32[$2 + 12 >> 2] - $3 >>> 0) % (HEAP32[HEAP32[$0 + 52 >> 2] + 40 >> 2] - 4 >>> 0) | 0) + $3 | 0;
 $0 = HEAPU16[$0 + 14 >> 1] < ($3 | 0) ? $4 : $3;
 HEAP16[$2 + 16 >> 1] = $0;
 HEAP16[$2 + 18 >> 1] = ((HEAP32[$2 + 8 >> 2] + $0 | 0) - $1 | 0) + 4;
}

function acosh($0) {
 var $1 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 wasm2js_scratch_load_i32(0) | 0;
 $1 = $1 >>> 20 & 2047;
 if ($1 >>> 0 <= 1023) {
  $0 = $0 + -1;
  return log1p($0 + sqrt($0 * $0 + ($0 + $0)));
 }
 if ($1 >>> 0 <= 1048) {
  return log($0 + $0 + -1 / (sqrt($0 * $0 + -1) + $0));
 }
 return log($0) + .6931471805599453;
}

function sqlite3_limit($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = -1;
 label$1: {
  if ($1 >>> 0 > 11) {
   break label$1;
  }
  $3 = $1 << 2;
  $5 = $3 + $0 | 0;
  $0 = $5 + 120 | 0;
  $4 = HEAP32[$0 >> 2];
  if (($2 | 0) < 0) {
   break label$1;
  }
  $3 = HEAP32[$3 + 31824 >> 2];
  HEAP32[$5 + 120 >> 2] = ($2 | 0) > ($3 | 0) ? $3 : $1 | $2 ? $2 : 1;
 }
 return $4;
}

function sqlite3WhereSplit($0, $1, $2) {
 var $3 = 0;
 while (1) {
  $3 = sqlite3ExprSkipCollateAndLikely($1);
  HEAP8[$0 + 8 | 0] = $2;
  label$2: {
   if ($3) {
    if (HEAPU8[$3 | 0] == ($2 | 0)) {
     break label$2;
    }
    whereClauseInsert($0, $1, 0);
   }
   return;
  }
  sqlite3WhereSplit($0, HEAP32[$3 + 12 >> 2], $2);
  $1 = HEAP32[$3 + 16 >> 2];
  continue;
 }
}

function pcache1Free($0) {
 if ($0) {
  if (!(HEAPU32[17739] <= $0 >>> 0 | HEAPU32[17738] > $0 >>> 0)) {
   sqlite3StatusDown(1, 1);
   HEAP32[$0 >> 2] = HEAP32[17741];
   HEAP32[17741] = $0;
   $0 = HEAP32[17742] + 1 | 0;
   HEAP32[17742] = $0;
   HEAP32[17743] = HEAP32[17737] > ($0 | 0);
   return;
  }
  sqlite3StatusDown(2, sqlite3MallocSize($0));
  sqlite3_free($0);
 }
}

function checkColumnOverlap($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if (!(!$0 | !$1)) {
  $2 = HEAP32[$1 >> 2];
  $3 = ($2 | 0) > 0 ? $2 : 0;
  $2 = 0;
  while (1) {
   if (($2 | 0) == ($3 | 0)) {
    return 0;
   }
   $4 = $2 << 4;
   $2 = $2 + 1 | 0;
   if ((sqlite3IdListIndex($0, HEAP32[($1 + $4 | 0) + 12 >> 2]) | 0) < 0) {
    continue;
   }
   break;
  }
 }
 return 1;
}

function sqlite3VdbeSorterRewind($0, $1) {
 var $2 = 0;
 $0 = HEAP32[$0 + 36 >> 2];
 if (!HEAPU8[$0 + 56 | 0]) {
  if (HEAP32[$0 + 36 >> 2]) {
   HEAP32[$1 >> 2] = 0;
   return vdbeSorterSort($0 - -64 | 0, $0 + 36 | 0);
  }
  HEAP32[$1 >> 2] = 1;
  return 0;
 }
 $2 = vdbeSorterFlushPMA($0);
 if (!$2) {
  $2 = vdbeSorterSetupMerge($0);
  HEAP32[$1 >> 2] = 0;
 }
 return $2;
}

function sqlite3TableColumnToIndex($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAPU16[$0 + 52 >> 1];
 $1 = $1 & 65535;
 while (1) {
  label$2: {
   if (($2 | 0) == ($3 | 0)) {
    $2 = 65535;
    break label$2;
   }
   if (HEAPU16[HEAP32[$0 + 4 >> 2] + ($2 << 1) >> 1] == ($1 | 0)) {
    break label$2;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 return $2 << 16 >> 16;
}

function sqlite3Fts3CreateStatTable($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$1 + 12 >> 2];
 $4 = HEAP32[$1 + 20 >> 2];
 HEAP32[$2 >> 2] = HEAP32[$1 + 16 >> 2];
 HEAP32[$2 + 4 >> 2] = $4;
 fts3DbExec($0, $3, 21464, $2);
 if (!HEAP32[$0 >> 2]) {
  HEAP8[$1 + 237 | 0] = 1;
 }
 __stack_pointer = $2 + 16 | 0;
}

function sbrk($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[17592];
 $2 = $0 + 7 & -8;
 $0 = $1 + $2 | 0;
 label$1: {
  if ($0 >>> 0 <= $1 >>> 0 ? $2 : 0) {
   break label$1;
  }
  if (emscripten_get_heap_size() >>> 0 < $0 >>> 0) {
   if (!(emscripten_resize_heap($0 | 0) | 0)) {
    break label$1;
   }
  }
  HEAP32[17592] = $0;
  return $1;
 }
 HEAP32[17757] = 48;
 return -1;
}

function int_cmp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$0 >> 2];
 $4 = HEAP32[$0 + 4 >> 2];
 $0 = $1;
 $2 = HEAP32[$0 >> 2];
 $1 = HEAP32[$0 + 4 >> 2];
 $0 = $3;
 $3 = ($4 | 0) <= ($1 | 0) & $2 >>> 0 > $0 >>> 0 | ($4 | 0) < ($1 | 0) ? -1 : 1;
 $2 = ($0 | 0) == ($2 | 0);
 $0 = $4;
 return ($2 & ($0 | 0) == ($1 | 0) ? 0 : $3) | 0;
}

function pagerBeginReadTransaction($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 sqlite3WalEndReadTransaction(HEAP32[$0 + 232 >> 2]);
 $2 = sqlite3WalBeginReadTransaction(HEAP32[$0 + 232 >> 2], $1 + 12 | 0);
 if ($2 | HEAP32[$1 + 12 >> 2]) {
  pager_reset($0);
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function sqlite3OsOpenMalloc($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = HEAP32[$0 + 4 >> 2];
 $5 = sqlite3MallocZero($5, $5 >> 31);
 label$1: {
  label$2: {
   if (!$5) {
    $0 = 7;
    break label$2;
   }
   $0 = sqlite3OsOpen($0, $1, $5, $3, $4);
   if (!$0) {
    $0 = 0;
    break label$1;
   }
   sqlite3_free($5);
  }
  $5 = 0;
 }
 HEAP32[$2 >> 2] = $5;
 return $0;
}

function multiSelectCollSeq($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$1 + 52 >> 2];
 label$1: {
  if ($3) {
   $3 = multiSelectCollSeq($0, $3, $2);
   if ($3) {
    break label$1;
   }
  }
  $3 = 0;
  $1 = HEAP32[$1 + 28 >> 2];
  if (HEAP32[$1 >> 2] <= ($2 | 0)) {
   break label$1;
  }
  $3 = sqlite3ExprCollSeq($0, HEAP32[(($2 << 4) + $1 | 0) + 8 >> 2]);
 }
 return $3;
}

function getFileMode($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $4 = __stack_pointer - 112 | 0;
 __stack_pointer = $4;
 $5 = 1802;
 if (!(FUNCTION_TABLE[HEAP32[16249]]($0, $4) | 0)) {
  HEAP32[$1 >> 2] = HEAP32[$4 + 12 >> 2] & 511;
  HEAP32[$2 >> 2] = HEAP32[$4 + 20 >> 2];
  HEAP32[$3 >> 2] = HEAP32[$4 + 24 >> 2];
  $5 = 0;
 }
 __stack_pointer = $4 + 112 | 0;
 return $5;
}

function sqlite3Fts3DeferToken($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = sqlite3_malloc(16);
 if (!$3) {
  return 7;
 }
 HEAP32[$3 + 4 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 >> 2] = $1;
 HEAP32[$3 + 12 >> 2] = 0;
 $4 = HEAP32[$0 + 28 >> 2];
 HEAP32[$3 + 4 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = $4;
 HEAP32[$0 + 28 >> 2] = $3;
 HEAP32[$1 + 16 >> 2] = $3;
 return 0;
}

function memcmp($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 label$1: {
  if (!$2) {
   break label$1;
  }
  while (1) {
   $3 = HEAPU8[$0 | 0];
   $4 = HEAPU8[$1 | 0];
   if (($3 | 0) == ($4 | 0)) {
    $1 = $1 + 1 | 0;
    $0 = $0 + 1 | 0;
    $2 = $2 - 1 | 0;
    if ($2) {
     continue;
    }
    break label$1;
   }
   break;
  }
  $5 = $3 - $4 | 0;
 }
 return $5;
}

function readlink($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 $1 = $2 ? $1 : $3 + 15 | 0;
 $2 = __syscall_readlinkat(-100, $0 | 0, $1 | 0, ($2 ? $2 : 1) | 0) | 0;
 $2 = __syscall_ret(($3 + 15 | 0) == ($1 | 0) ? ($2 | 0) > 0 ? 0 : $2 : $2);
 __stack_pointer = $3 + 16 | 0;
 return $2 | 0;
}

function memIntValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 sqlite3Atoi64(HEAP32[$0 + 8 >> 2], $1 + 8 | 0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]);
 __stack_pointer = $1 + 16 | 0;
 $0 = HEAP32[$1 + 8 >> 2];
 $1 = HEAP32[$1 + 12 >> 2];
 i64toi32_i32$HIGH_BITS = $1;
 return $0;
}

function sqlite3ExprSkipCollateAndLikely($0) {
 var $1 = 0;
 while (1) {
  label$2: {
   if (!$0) {
    break label$2;
   }
   $1 = HEAP32[$0 + 4 >> 2];
   if (!($1 & 532480)) {
    break label$2;
   }
   if ($1 & 524288) {
    $0 = HEAP32[$0 + 20 >> 2] + 8 | 0;
   } else {
    $0 = $0 + 12 | 0;
   }
   $0 = HEAP32[$0 >> 2];
   continue;
  }
  break;
 }
 return $0;
}

function pragmaVtabColumn($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = HEAPU8[HEAP32[$0 >> 2] + 21 | 0];
 label$1: {
  if (($3 | 0) > ($2 | 0)) {
   sqlite3_result_value($1, sqlite3_column_value(HEAP32[$0 + 4 >> 2], $2));
   break label$1;
  }
  sqlite3_result_text($1, HEAP32[(($2 - $3 << 2) + $0 | 0) + 16 >> 2], -1, -1);
 }
 return 0;
}

function pagerOpenWal($0) {
 var $1 = 0;
 label$1: {
  if (HEAPU8[$0 + 4 | 0]) {
   $1 = pagerExclusiveLock($0);
   if ($1) {
    break label$1;
   }
   $1 = HEAPU8[$0 + 4 | 0];
  } else {
   $1 = 0;
  }
  $1 = sqlite3WalOpen(HEAP32[$0 >> 2], HEAP32[$0 + 64 >> 2], HEAP32[$0 + 236 >> 2], $1, HEAP32[$0 + 176 >> 2], HEAP32[$0 + 180 >> 2], $0 + 232 | 0);
 }
 return $1;
}

function sqlite3PagerCommitPhaseTwo($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 44 >> 2];
 if (!$1) {
  HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 108 >> 2] + 1;
  if (!(!HEAPU8[$0 + 4 | 0] | HEAPU8[$0 + 17 | 0] != 2 | HEAPU8[$0 + 5 | 0] != 1)) {
   HEAP8[$0 + 17 | 0] = 1;
   return 0;
  }
  $1 = pager_error($0, pager_end_transaction($0, HEAPU8[$0 + 20 | 0], 1));
 }
 return $1;
}

function randomBlob($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $1 = sqlite3_value_int64(HEAP32[$2 >> 2]);
 $2 = i64toi32_i32$HIGH_BITS;
 $3 = $1 >>> 0 > 1 & ($2 | 0) >= 0 | ($2 | 0) > 0;
 $1 = $3 ? $1 : 1;
 $2 = $3 ? $2 : 0;
 $2 = contextMalloc($0, $1, $2);
 if ($2) {
  sqlite3_randomness($1, $2);
  sqlite3_result_blob($0, $2, $1, 3);
 }
}

function fts3tokNextMethod($0) {
 $0 = $0 | 0;
 var $1 = 0;
 HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
 $1 = FUNCTION_TABLE[HEAP32[HEAP32[HEAP32[$0 >> 2] + 12 >> 2] + 20 >> 2]](HEAP32[$0 + 8 >> 2], $0 + 16 | 0, $0 + 20 | 0, $0 + 24 | 0, $0 + 28 | 0, $0 + 32 | 0) | 0;
 if (!$1) {
  return 0;
 }
 fts3tokResetCursor($0);
 return (($1 | 0) == 101 ? 0 : $1) | 0;
}

function sqlite3SafetyCheckOk($0) {
 var $1 = 0;
 label$1: {
  label$2: {
   label$3: {
    if (!$0) {
     $1 = 19646;
     break label$3;
    }
    $1 = 1;
    if (HEAPU8[$0 + 97 | 0] == 118) {
     break label$1;
    }
    $1 = 15278;
    if (!sqlite3SafetyCheckSickOrOk($0)) {
     break label$2;
    }
   }
   logBadConnection($1);
  }
  $1 = 0;
 }
 return $1;
}

function strAccumFinishRealloc($0) {
 var $1 = 0;
 $1 = sqlite3DbMallocRaw(HEAP32[$0 >> 2], HEAP32[$0 + 16 >> 2] + 1 | 0, 0);
 label$1: {
  if ($1) {
   __memcpy($1, HEAP32[$0 + 4 >> 2], HEAP32[$0 + 16 >> 2] + 1 | 0);
   HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] | 4;
   break label$1;
  }
  sqlite3StrAccumSetError($0, 7);
 }
 HEAP32[$0 + 4 >> 2] = $1;
 return $1;
}

function sqlite3RecordErrorOffsetOfExpr($0, $1) {
 var $2 = 0;
 label$1: {
  while (1) {
   if (!$1) {
    break label$1;
   }
   label$3: {
    if (!(HEAPU8[$1 + 4 | 0] & 3)) {
     $2 = HEAP32[$1 + 36 >> 2];
     if (($2 | 0) > 0) {
      break label$3;
     }
    }
    $1 = HEAP32[$1 + 12 >> 2];
    continue;
   }
   break;
  }
  HEAP32[$0 + 68 >> 2] = $2;
 }
}

function fts3FunctionArg($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $2 = sqlite3_value_pointer($2, 8495);
 HEAP32[$3 >> 2] = $2;
 $3 = 0;
 if (!$2) {
  HEAP32[$4 >> 2] = $1;
  $3 = sqlite3_mprintf(6099, $4);
  sqlite3_result_error($0, $3, -1);
  sqlite3_free($3);
  $3 = 1;
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function sqlite3StorageColumnToTable($0, $1) {
 var $2 = 0;
 label$1: {
  if (!(HEAPU8[$0 + 28 | 0] & 32)) {
   break label$1;
  }
  while (1) {
   if ($1 << 16 >> 16 < ($2 | 0)) {
    break label$1;
   }
   $1 = (HEAPU16[(HEAP32[$0 + 4 >> 2] + Math_imul($2, 12) | 0) + 10 >> 1] >>> 5 & 1) + $1 | 0;
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 return $1 << 16 >> 16;
}

function sqlite3Fts3PutVarint($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
 $3 = $0;
 while (1) {
  $4 = $3;
  $5 = $1;
  HEAP8[$3 | 0] = $1 | 128;
  $3 = $3 + 1 | 0;
  $6 = !$2 & $1 >>> 0 > 127 | ($2 | 0) != 0;
  $1 = ($2 & 127) << 25 | $1 >>> 7;
  $2 = $2 >>> 7 | 0;
  if ($6) {
   continue;
  }
  break;
 }
 HEAP8[$4 | 0] = $5 & 127;
 return $3 - $0 | 0;
}

function write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = $1;
 $2 = __wasi_syscall_ret(__wasi_fd_write($0 | 0, $3 + 8 | 0, 1, $3 + 4 | 0) | 0);
 __stack_pointer = $3 + 16 | 0;
 $1 = HEAP32[$3 + 4 >> 2];
 return ($2 ? -1 : $1) | 0;
}

function sqlite3BtreeSetAutoVacuum($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 $0 = $1 & 255;
 label$1: {
  if (HEAPU8[$2 + 24 | 0] & 2) {
   $1 = 8;
   if (HEAPU8[$2 + 17 | 0] != (($0 | 0) != 0 | 0)) {
    break label$1;
   }
  }
  HEAP8[$2 + 18 | 0] = ($0 | 0) == 2;
  HEAP8[$2 + 17 | 0] = ($0 | 0) != 0;
  $1 = 0;
 }
 return $1;
}

function havingToWhere($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 52;
 HEAP32[$2 >> 2] = $0;
 HEAP32[$2 + 24 >> 2] = $1;
 sqlite3WalkExpr($2, HEAP32[$1 + 44 >> 2]);
 __stack_pointer = $2 + 32 | 0;
}

function sqlite3WalkExprList($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = $1 + 8 | 0;
  $1 = HEAP32[$1 >> 2];
  while (1) {
   if (($1 | 0) <= 0) {
    break label$1;
   }
   if (!sqlite3WalkExpr($0, HEAP32[$2 >> 2])) {
    $2 = $2 + 16 | 0;
    $1 = $1 - 1 | 0;
    continue;
   }
   break;
  }
  $3 = 2;
 }
 return $3;
}

function read($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = $1;
 $2 = __wasi_syscall_ret(__wasi_fd_read($0 | 0, $3 + 8 | 0, 1, $3 + 4 | 0) | 0);
 __stack_pointer = $3 + 16 | 0;
 $1 = HEAP32[$3 + 4 >> 2];
 return ($2 ? -1 : $1) | 0;
}

function sqlite3VListNumToName($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 if ($0) {
  $4 = HEAP32[$0 + 4 >> 2];
  $2 = 2;
  while (1) {
   $3 = ($2 << 2) + $0 | 0;
   if (HEAP32[$3 >> 2] == ($1 | 0)) {
    return (($2 << 2) + $0 | 0) + 8 | 0;
   }
   $2 = HEAP32[$3 + 4 >> 2] + $2 | 0;
   if (($4 | 0) > ($2 | 0)) {
    continue;
   }
   break;
  }
 }
 return 0;
}

function sqlite3GetTempRange($0, $1) {
 var $2 = 0;
 if (($1 | 0) == 1) {
  return sqlite3GetTempReg($0);
 }
 $2 = HEAP32[$0 + 28 >> 2];
 if (($2 | 0) >= ($1 | 0)) {
  HEAP32[$0 + 28 >> 2] = $2 - $1;
  $2 = HEAP32[$0 + 32 >> 2];
  HEAP32[$0 + 32 >> 2] = $2 + $1;
  return $2;
 }
 $2 = HEAP32[$0 + 44 >> 2];
 HEAP32[$0 + 44 >> 2] = $2 + $1;
 return $2 + 1 | 0;
}

function exprColumnFlagUnion($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $1 = HEAP16[$1 + 32 >> 1];
  if (($1 | 0) < 0) {
   break label$1;
  }
  HEAP16[$0 + 20 >> 1] = HEAPU16[$0 + 20 >> 1] | HEAPU16[(HEAP32[HEAP32[$0 + 24 >> 2] + 4 >> 2] + Math_imul($1 & 65535, 12) | 0) + 10 >> 1];
 }
 return 0;
}

function backupUpdate($0, $1, $2) {
 var $3 = 0;
 while (1) {
  label$2: {
   if (isFatalError(HEAP32[$0 + 28 >> 2]) | HEAPU32[$0 + 16 >> 2] <= $1 >>> 0) {
    break label$2;
   }
   $3 = backupOnePage($0, $1, $2, 1);
   if (!$3) {
    break label$2;
   }
   HEAP32[$0 + 28 >> 2] = $3;
  }
  $0 = HEAP32[$0 + 44 >> 2];
  if ($0) {
   continue;
  }
  break;
 }
}

function __cos($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $2 = $0 * $0;
 $3 = $2 * .5;
 $4 = 1 - $3;
 $5 = 1 - $4 - $3;
 $3 = $2 * $2;
 return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2480158728947673e-20 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -11359647557788195e-27 + 2.087572321298175e-9) + -2.7557314351390663e-7)) - $0 * $1));
}

function triggerSpanDup($0, $1, $2) {
 var $3 = 0;
 label$1: {
  $3 = sqlite3DbSpanDup($0, $1, $2);
  if (!$3) {
   break label$1;
  }
  $2 = 0;
  while (1) {
   $0 = $2 + $3 | 0;
   $1 = HEAPU8[$0 | 0];
   if (!$1) {
    break label$1;
   }
   if (HEAP8[$1 + 30288 | 0] & 1) {
    HEAP8[$0 | 0] = 32;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
 }
 return $3;
}

function sqlite3SelectPrep($0, $1, $2) {
 label$1: {
  if (HEAPU8[HEAP32[$0 >> 2] + 87 | 0] | HEAPU8[$1 + 4 | 0] & 128) {
   break label$1;
  }
  sqlite3SelectExpand($0, $1);
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  sqlite3ResolveSelectNames($0, $1, $2);
  if (HEAP32[$0 + 36 >> 2]) {
   break label$1;
  }
  sqlite3SelectAddTypeInfo($0, $1);
 }
}

function sqlite3IdListIndex($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAP32[$0 >> 2];
 $3 = ($3 | 0) > 0 ? $3 : 0;
 while (1) {
  label$2: {
   if (($2 | 0) == ($3 | 0)) {
    $2 = -1;
    break label$2;
   }
   if (!sqlite3StrICmp(HEAP32[(($2 << 3) + $0 | 0) + 8 >> 2], $1)) {
    break label$2;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 return $2;
}

function sqlite3BtreeGetMeta($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 label$1: {
  if (($1 | 0) == 15) {
   $0 = HEAP32[$0 + 20 >> 2] + sqlite3PagerDataVersion(HEAP32[$3 >> 2]) | 0;
   break label$1;
  }
  $0 = sqlite3Get4byte((HEAP32[HEAP32[$3 + 12 >> 2] + 56 >> 2] + ($1 << 2) | 0) + 36 | 0);
 }
 HEAP32[$2 >> 2] = $0;
}

function btreeSetHasContent($0, $1) {
 var $2 = 0;
 label$1: {
  $2 = HEAP32[$0 + 64 >> 2];
  if ($2) {
   break label$1;
  }
  $2 = sqlite3BitvecCreate(HEAP32[$0 + 48 >> 2]);
  HEAP32[$0 + 64 >> 2] = $2;
  if ($2) {
   break label$1;
  }
  return 7;
 }
 $0 = 0;
 if (sqlite3BitvecSize($2) >>> 0 >= $1 >>> 0) {
  $0 = sqlite3BitvecSet($2, $1);
 }
 return $0;
}

function yy_syntax_error($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if (HEAPU8[HEAP32[$1 >> 2]]) {
   HEAP32[$2 >> 2] = $1;
   sqlite3ErrorMsg($3, 8506, $2);
   break label$1;
  }
  sqlite3ErrorMsg($3, 2018, 0);
 }
 HEAP32[$0 + 4 >> 2] = $3;
 __stack_pointer = $2 + 16 | 0;
}

function sqlite3VdbeUsesBtree($0, $1) {
 var $2 = 0;
 $2 = 1 << $1;
 HEAP32[$0 + 152 >> 2] = $2 | HEAP32[$0 + 152 >> 2];
 label$1: {
  if (($1 | 0) == 1) {
   break label$1;
  }
  if (!sqlite3BtreeSharable(HEAP32[(HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2])) {
   break label$1;
  }
  HEAP32[$0 + 156 >> 2] = HEAP32[$0 + 156 >> 2] | $2;
 }
}

function fts3PoslistCopy($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $3 = HEAP32[$1 >> 2];
 $2 = $3;
 while (1) {
  $4 = $2 + 1 | 0;
  $2 = HEAP8[$2 | 0];
  if ($2 | $5 & 255) {
   $5 = $2 & 128;
   $2 = $4;
   continue;
  }
  break;
 }
 if ($0) {
  $2 = $4 - $3 | 0;
  HEAP32[$0 >> 2] = $2 + __memcpy(HEAP32[$0 >> 2], $3, $2);
 }
 HEAP32[$1 >> 2] = $4;
}

function vdbeSorterCompare($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $6 = 0;
 $6 = HEAP32[$0 + 12 >> 2];
 if (!HEAP32[$1 >> 2]) {
  sqlite3VdbeRecordUnpack(HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2], $5, $4, $6);
  HEAP32[$1 >> 2] = 1;
 }
 return sqlite3VdbeRecordCompare($3, $2, $6) | 0;
}

function sqlite3BtreeEnterAll($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 $3 = ($1 | 0) > 0 ? $1 : 0;
 while (1) {
  if (($2 | 0) != ($3 | 0)) {
   $1 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($2 << 4) | 0) + 4 >> 2];
   if ($1) {
    HEAP32[HEAP32[$1 + 4 >> 2] + 4 >> 2] = HEAP32[$1 >> 2];
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
}

function last_valueStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = sqlite3_aggregate_context($0, 8);
 if ($1) {
  sqlite3_value_free(HEAP32[$1 >> 2]);
  $2 = sqlite3_value_dup(HEAP32[$2 >> 2]);
  HEAP32[$1 >> 2] = $2;
  if (!$2) {
   sqlite3_result_error_nomem($0);
   return;
  }
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
 }
}

function dupedExprSize($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = $1 & 1;
 while (1) {
  label$2: {
   if ($0) {
    $2 = dupedExprNodeSize($0, $1);
    if ($4) {
     break label$2;
    }
    $5 = $2;
   }
   return $3 + $5 | 0;
  }
  $3 = (dupedExprSize(HEAP32[$0 + 12 >> 2], $1) + $2 | 0) + $3 | 0;
  $0 = HEAP32[$0 + 16 >> 2];
  continue;
 }
}

function fts3PutDeltaVarint($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $4 = $1;
 $6 = HEAP32[$4 >> 2];
 $5 = HEAP32[$4 + 4 >> 2];
 $4 = $2;
 $5 = $5 + ($6 >>> 0 > $4 >>> 0) | 0;
 $5 = $3 - $5 | 0;
 HEAP32[$0 >> 2] = sqlite3Fts3PutVarint(HEAP32[$0 >> 2], $4 - $6 | 0, $5) + HEAP32[$0 >> 2];
 $4 = $1;
 HEAP32[$4 >> 2] = $2;
 HEAP32[$4 + 4 >> 2] = $3;
}

function sqlite3WhereExprUsageNN($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = HEAP32[$1 + 4 >> 2];
 if (!($3 & 32 | HEAPU8[$1 | 0] != 167)) {
  $2 = sqlite3WhereGetMask($0, HEAP32[$1 + 28 >> 2]);
  return $2;
 }
 if (!($3 & 8454144)) {
  $2 = sqlite3WhereExprUsageFull($0, $1);
  $4 = i64toi32_i32$HIGH_BITS;
 }
 i64toi32_i32$HIGH_BITS = $4;
 return $2;
}

function sqlite3ResultStrAccum($0, $1) {
 var $2 = 0;
 $2 = HEAPU8[$1 + 20 | 0];
 label$1: {
  if ($2) {
   sqlite3_result_error_code($0, $2);
   break label$1;
  }
  if (HEAPU8[$1 + 21 | 0] & 4) {
   sqlite3_result_text($0, HEAP32[$1 + 4 >> 2], HEAP32[$1 + 16 >> 2], 1);
   return;
  }
  sqlite3_result_text($0, 29623, 0, 0);
 }
 sqlite3_str_reset($1);
}

function sqlite3WalReadFrame($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = HEAP32[$0 + 8 >> 2];
 $0 = HEAPU16[$0 + 66 >> 1];
 $0 = ($0 | $0 << 16) & 130560;
 $4 = __wasm_i64_mul($0 | 24, 0, $1 - 1 | 0, 0) + 56 | 0;
 $1 = i64toi32_i32$HIGH_BITS;
 $1 = $4 >>> 0 < 56 ? $1 + 1 | 0 : $1;
 return sqlite3OsRead($5, $3, ($0 | 0) < ($2 | 0) ? $0 : $2, $4, $1);
}

function sqlite3ExprIsConstantOrGroupBy($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = 0;
 HEAP32[$3 + 4 >> 2] = 82;
 HEAP16[$3 + 20 >> 1] = 1;
 HEAP32[$3 >> 2] = $0;
 sqlite3WalkExpr($3, $1);
 __stack_pointer = $3 + 32 | 0;
 $2 = HEAPU16[$3 + 20 >> 1];
 return $2;
}

function osLocaltime($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = localtime($0);
 label$1: {
  if (HEAP32[16133]) {
   $3 = 1;
   $4 = HEAP32[16134];
   if (!$4) {
    break label$1;
   }
   $2 = $1;
   if (FUNCTION_TABLE[$4 | 0]($0, $1) | 0) {
    break label$1;
   }
  }
  if (!$2) {
   return 1;
  }
  __memcpy($1, $2, 44);
  $3 = 0;
 }
 return $3;
}

function codeTableLocks($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $3 = HEAP32[$0 + 8 >> 2];
 while (1) {
  if (($2 | 0) < HEAP32[$0 + 104 >> 2]) {
   $1 = HEAP32[$0 + 108 >> 2] + ($2 << 4) | 0;
   sqlite3VdbeAddOp4($3, 169, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAPU8[$1 + 8 | 0], HEAP32[$1 + 12 >> 2], -1);
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
}

function fts3MsrBufferData($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (HEAP32[$0 + 20 >> 2] >= ($2 | 0)) {
   $3 = HEAP32[$0 + 16 >> 2];
   break label$1;
  }
  $3 = $2 << 1;
  HEAP32[$0 + 20 >> 2] = $3;
  $3 = sqlite3_realloc(HEAP32[$0 + 16 >> 2], $3);
  if (!$3) {
   return 7;
  }
  HEAP32[$0 + 16 >> 2] = $3;
 }
 __memcpy($3, $1, $2);
 return 0;
}

function fts3ColumnlistCopy($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$1 >> 2];
 $2 = $4;
 while (1) {
  $5 = HEAPU8[$2 | 0];
  if ($5 & 254 | $3) {
   $3 = $5 & 128;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 if ($0) {
  $3 = $2 - $4 | 0;
  HEAP32[$0 >> 2] = $3 + __memcpy(HEAP32[$0 >> 2], $4, $3);
 }
 HEAP32[$1 >> 2] = $2;
}

function dlcalloc($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = 0;
 label$2: {
  if (!$0) {
   break label$2;
  }
  $2 = __wasm_i64_mul($0, 0, $1, 0);
  $3 = i64toi32_i32$HIGH_BITS;
  if (($0 | $1) >>> 0 < 65536) {
   break label$2;
  }
  $2 = $3 ? -1 : $2;
 }
 $0 = dlmalloc($2);
 if (!(!$0 | !(HEAPU8[$0 - 4 | 0] & 3))) {
  memset($0, 0, $2);
 }
 return $0;
}

function vdbeSortAllocUnpacked($0) {
 var $1 = 0;
 if (!HEAP32[$0 + 12 >> 2]) {
  $1 = sqlite3VdbeAllocUnpackedRecord(HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2]);
  HEAP32[$0 + 12 >> 2] = $1;
  if (!$1) {
   return 7;
  }
  $0 = HEAPU16[HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2] + 6 >> 1];
  HEAP8[$1 + 23 | 0] = 0;
  HEAP16[$1 + 20 >> 1] = $0;
 }
 return 0;
}

function pagerUnlockDb($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 64 >> 2];
 label$1: {
  if (!HEAP32[$2 >> 2]) {
   break label$1;
  }
  if (!HEAPU8[$0 + 13 | 0]) {
   $3 = sqlite3OsUnlock($2, $1);
  }
  if (HEAPU8[$0 + 18 | 0] == 5) {
   break label$1;
  }
  HEAP8[$0 + 18 | 0] = $1;
 }
 HEAP8[$0 + 19 | 0] = HEAPU8[$0 + 12 | 0];
 return $3;
}

function vdbeFreeOpArray($0, $1, $2) {
 var $3 = 0;
 if ($1) {
  $2 = (Math_imul($2, 20) + $1 | 0) - 20 | 0;
  while (1) {
   $3 = HEAP8[$2 + 1 | 0];
   if (($3 | 0) <= -6) {
    freeP4($0, $3, HEAP32[$2 + 16 >> 2]);
   }
   $3 = ($1 | 0) != ($2 | 0);
   $2 = $2 - 20 | 0;
   if ($3) {
    continue;
   }
   break;
  }
  sqlite3DbFreeNN($0, $1);
 }
}

function fts3ExprCheckDepth($0, $1) {
 var $2 = 0;
 while (1) {
  if (!$0) {
   return 0;
  }
  label$3: {
   if (($1 | 0) < 0) {
    $2 = 18;
    break label$3;
   }
   $1 = $1 - 1 | 0;
   $2 = fts3ExprCheckDepth(HEAP32[$0 + 12 >> 2], $1);
   if ($2) {
    break label$3;
   }
   $0 = HEAP32[$0 + 16 >> 2];
   continue;
  }
  break;
 }
 return $2;
}

function estimateTableWidth($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 $2 = HEAP16[$0 + 34 >> 1];
 while (1) {
  if (($2 | 0) > 0) {
   $2 = $2 - 1 | 0;
   $3 = HEAPU8[$1 + 6 | 0] + $3 | 0;
   $1 = $1 + 12 | 0;
   continue;
  }
  break;
 }
 HEAP16[$0 + 40 >> 1] = sqlite3LogEst((HEAPU16[$0 + 32 >> 1] >>> 15 | 0) + $3 << 2, 0);
}

function addToSavepointBitvecs($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 while (1) {
  if (($2 | 0) < HEAP32[$0 + 104 >> 2]) {
   $3 = HEAP32[$0 + 100 >> 2] + Math_imul($2, 48) | 0;
   if (HEAPU32[$3 + 20 >> 2] >= $1 >>> 0) {
    $4 = sqlite3BitvecSet(HEAP32[$3 + 16 >> 2], $1) | $4;
   }
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 return $4;
}

function sqlite3_status64($0, $1, $2, $3) {
 var $4 = 0;
 if ($0 >>> 0 >= 10) {
  return sqlite3MisuseError(23009);
 }
 $0 = $0 << 2;
 $4 = HEAP32[$0 + 70376 >> 2];
 HEAP32[$1 >> 2] = $4;
 HEAP32[$1 + 4 >> 2] = 0;
 $0 = $0 + 70416 | 0;
 HEAP32[$2 >> 2] = HEAP32[$0 >> 2];
 HEAP32[$2 + 4 >> 2] = 0;
 if ($3) {
  HEAP32[$0 >> 2] = $4;
 }
 return 0;
}

function sqlite3InvokeBusyHandler($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 >> 2];
 if (!$1) {
  return 0;
 }
 $2 = HEAP32[$0 + 8 >> 2];
 if (($2 | 0) >= 0) {
  $3 = FUNCTION_TABLE[$1 | 0](HEAP32[$0 + 4 >> 2], $2) | 0;
  if ($3) {
   $1 = HEAP32[$0 + 8 >> 2] + 1 | 0;
  } else {
   $1 = -1;
  }
  HEAP32[$0 + 8 >> 2] = $1;
 }
 return $3;
}

function sqlite3DbStrNDup($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $4 = $3;
  $6 = $2 + 1 | 0;
  $4 = $6 ? $4 : $4 + 1 | 0;
  $0 = sqlite3DbMallocRawNN($0, $6, $4);
  if (!$0) {
   break label$1;
  }
  $5 = $2;
  $1 = __memcpy($0, $1, $5);
  HEAP8[$1 + $5 | 0] = 0;
  $5 = $1;
 }
 return $5;
}

function sqlite3BitvecDestroy($0) {
 var $1 = 0, $2 = 0;
 if ($0) {
  label$2: {
   if (!HEAP32[$0 + 8 >> 2]) {
    break label$2;
   }
   $2 = $0 + 12 | 0;
   while (1) {
    if (($1 | 0) == 125) {
     break label$2;
    }
    sqlite3BitvecDestroy(HEAP32[($1 << 2) + $2 >> 2]);
    $1 = $1 + 1 | 0;
    continue;
   }
  }
  sqlite3_free($0);
 }
}

function vdbeSorterTreeDepth($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
 $5 = $0;
 $4 = $0 >> 31;
 $2 = 16;
 $0 = 0;
 while (1) {
  $1 = $5;
  if (!($1 >>> 0 <= $2 >>> 0 & ($3 | 0) >= ($4 | 0) | ($3 | 0) > ($4 | 0))) {
   $0 = $0 + 1 | 0;
   $1 = $2;
   $2 = $1 << 4;
   $3 = $3 << 4 | $1 >>> 28;
   continue;
  }
  break;
 }
 return $0;
}

function disallowAggregatesInOrderByCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 if (!(HEAP32[$1 + 40 >> 2] | HEAPU8[$1 | 0] != 168)) {
  $0 = HEAP32[$0 >> 2];
  HEAP32[$2 >> 2] = HEAP32[$1 + 8 >> 2];
  sqlite3ErrorMsg($0, 26027, $2);
 }
 __stack_pointer = $2 + 16 | 0;
 return 0;
}

function sqlite3_result_zeroblob64($0, $1, $2) {
 var $3 = 0, $4 = 0, $5 = 0;
 $4 = HEAP32[$0 >> 2];
 $3 = HEAP32[HEAP32[$4 + 20 >> 2] + 120 >> 2];
 $5 = $3;
 $3 = $3 >> 31;
 if (($3 | 0) == ($2 | 0) & $1 >>> 0 > $5 >>> 0 | $2 >>> 0 > $3 >>> 0) {
  sqlite3_result_error_toobig($0);
  return 18;
 }
 sqlite3VdbeMemSetZeroBlob($4, $1);
 return 0;
}

function sqlite3RowSetClear($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2];
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 >> 2];
   sqlite3DbFree(HEAP32[$0 + 4 >> 2], $1);
   $1 = $2;
   continue;
  }
  break;
 }
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 65536;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
}

function btreePageFromDbPage($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = sqlite3PagerGetExtra($0);
 if (HEAP32[$3 + 4 >> 2] != ($1 | 0)) {
  $4 = sqlite3PagerGetData($0);
  HEAP32[$3 + 72 >> 2] = $0;
  HEAP32[$3 + 56 >> 2] = $4;
  HEAP32[$3 + 52 >> 2] = $2;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP8[$3 + 9 | 0] = ($1 | 0) == 1 ? 100 : 0;
 }
 return $3;
}

function sqlite3VtabDisconnect($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = $1 + 52 | 0;
 label$1: {
  while (1) {
   $3 = $2;
   $1 = HEAP32[$3 >> 2];
   if (!$1) {
    break label$1;
   }
   $2 = $1 + 24 | 0;
   if (HEAP32[$1 >> 2] != ($0 | 0)) {
    continue;
   }
   break;
  }
  HEAP32[$3 >> 2] = HEAP32[$1 + 24 >> 2];
  sqlite3VtabUnlock($1);
 }
}

function resizeResolveLabel($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = 10 - HEAP32[$0 + 56 >> 2] | 0;
 $3 = sqlite3DbReallocOrFree(HEAP32[$0 >> 2], HEAP32[$0 + 64 >> 2], $4 << 2, 0);
 HEAP32[$0 + 64 >> 2] = $3;
 if (!$3) {
  HEAP32[$0 + 60 >> 2] = 0;
  return;
 }
 HEAP32[$0 + 60 >> 2] = $4;
 HEAP32[($2 << 2) + $3 >> 2] = HEAP32[$1 + 108 >> 2];
}

function fts3auxGrowStatArray($0, $1) {
 var $2 = 0, $3 = 0;
 if (HEAP32[$0 + 108 >> 2] < ($1 | 0)) {
  $2 = sqlite3_realloc64(HEAP32[$0 + 112 >> 2], $1 << 4, 0);
  if (!$2) {
   return 7;
  }
  $3 = HEAP32[$0 + 108 >> 2];
  memset(($3 << 4) + $2 | 0, 0, $1 - $3 << 4);
  HEAP32[$0 + 108 >> 2] = $1;
  HEAP32[$0 + 112 >> 2] = $2;
 }
 return 0;
}

function unixCurrentTime($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 unixCurrentTimeInt64($0, $0 + 8 | 0);
 HEAPF64[$1 >> 3] = (+HEAPU32[$0 + 8 >> 2] + +HEAP32[$0 + 12 >> 2] * 4294967296) / 864e5;
 __stack_pointer = $0 + 16 | 0;
 return 0;
}

function sqlite3SelectWrongNumTermsError($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 label$1: {
  if (HEAPU8[$1 + 5 | 0] & 2) {
   sqlite3ErrorMsg($0, 4921, 0);
   break label$1;
  }
  HEAP32[$2 >> 2] = sqlite3SelectOpName(HEAPU8[$1 | 0]);
  sqlite3ErrorMsg($0, 4732, $2);
 }
 __stack_pointer = $2 + 16 | 0;
}

function btreeSetNPage($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $1 = sqlite3Get4byte(HEAP32[$1 + 56 >> 2] + 28 | 0);
 HEAP32[$2 + 12 >> 2] = $1;
 if (!$1) {
  sqlite3PagerPagecount(HEAP32[$0 >> 2], $2 + 12 | 0);
  $1 = HEAP32[$2 + 12 >> 2];
 }
 HEAP32[$0 + 48 >> 2] = $1;
 __stack_pointer = $2 + 16 | 0;
}

function sqlite3_normalized_sql($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[$0 + 200 >> 2];
  if ($1) {
   break label$1;
  }
  $1 = 0;
  $2 = HEAP32[$0 + 196 >> 2];
  if (!$2) {
   break label$1;
  }
  $1 = sqlite3Normalize($0, $2);
  HEAP32[$0 + 200 >> 2] = $1;
 }
 return $1 | 0;
}

function btreeGetUnusedPage($0, $1, $2, $3) {
 $3 = btreeGetPage($0, $1, $2, $3);
 if (!$3) {
  $3 = HEAP32[$2 >> 2];
  if ((sqlite3PagerPageRefcount(HEAP32[$3 + 72 >> 2]) | 0) >= 2) {
   releasePage($3);
   HEAP32[$2 >> 2] = 0;
   return sqlite3CorruptError(69219);
  }
  HEAP8[$3 | 0] = 0;
  return 0;
 }
 HEAP32[$2 >> 2] = 0;
 return $3;
}

function vdbeSorterRowkey($0, $1) {
 if (HEAPU8[$0 + 56 | 0]) {
  $0 = HEAP32[$0 + 20 >> 2];
  $0 = HEAP32[$0 + 12 >> 2] + Math_imul(HEAP32[HEAP32[$0 + 8 >> 2] + 4 >> 2], 56) | 0;
  HEAP32[$1 >> 2] = HEAP32[$0 + 20 >> 2];
  return HEAP32[$0 + 32 >> 2];
 }
 $0 = HEAP32[$0 + 36 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 >> 2];
 return $0 + 8 | 0;
}

function renameTableExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 label$1: {
  if (HEAPU8[$1 + 7 | 0] & 3 | HEAPU8[$1 | 0] != 167) {
   break label$1;
  }
  $2 = HEAP32[$0 + 24 >> 2];
  if (HEAP32[$2 + 12 >> 2] != HEAP32[$1 + 44 >> 2]) {
   break label$1;
  }
  renameTokenFind(HEAP32[$0 >> 2], $2, $1 + 44 | 0);
 }
 return 0;
}

function pragmaVtabOpen($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = sqlite3_malloc(24);
 if (!$2) {
  return 7;
 }
 HEAP32[$2 >> 2] = 0;
 HEAP32[$2 + 4 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 >> 2] = $0;
 HEAP32[$1 >> 2] = $2;
 return 0;
}

function sqlite3VtabUnlock($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 12 >> 2] - 1 | 0;
 HEAP32[$0 + 12 >> 2] = $1;
 if (!$1) {
  $1 = HEAP32[$0 + 8 >> 2];
  $2 = HEAP32[$0 >> 2];
  sqlite3VtabModuleUnref($2, HEAP32[$0 + 4 >> 2]);
  if ($1) {
   FUNCTION_TABLE[HEAP32[HEAP32[$1 >> 2] + 16 >> 2]]($1) | 0;
  }
  sqlite3DbFree($2, $0);
 }
}

function makeSorterRecord($0, $1, $2, $3, $4) {
 var $5 = 0, $6 = 0, $7 = 0;
 $6 = HEAP32[$1 + 4 >> 2];
 $5 = HEAP32[$0 + 44 >> 2] + 1 | 0;
 HEAP32[$0 + 44 >> 2] = $5;
 $7 = HEAP32[$0 + 8 >> 2];
 $1 = HEAP32[$1 + 36 >> 2];
 if ($1) {
  innerLoopLoadRow($0, $2, $1);
 }
 sqlite3VdbeAddOp3($7, 97, $3 + $6 | 0, $4 - $6 | 0, $5);
 return $5;
}

function sqlite3WithPush($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  if ($2) {
   $1 = sqlite3ParserAddCleanup($0, 36, $1);
   if (!$1) {
    break label$1;
   }
  }
  if (!HEAP32[$0 + 36 >> 2]) {
   HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 264 >> 2];
   HEAP32[$0 + 264 >> 2] = $1;
  }
  $3 = $1;
 }
 return $3;
}

function first_valueStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 16);
  if (!$1 | HEAP32[$1 + 8 >> 2]) {
   break label$1;
  }
  $2 = sqlite3_value_dup(HEAP32[$2 >> 2]);
  HEAP32[$1 + 8 >> 2] = $2;
  if ($2) {
   break label$1;
  }
  sqlite3_result_error_nomem($0);
 }
}

function comparisonAffinity($0) {
 var $1 = 0, $2 = 0;
 $1 = sqlite3ExprAffinity(HEAP32[$0 + 12 >> 2]);
 $2 = HEAP32[$0 + 16 >> 2];
 if ($2) {
  return sqlite3CompareAffinity($2, $1);
 }
 if (HEAPU8[$0 + 5 | 0] & 16) {
  return sqlite3CompareAffinity(HEAP32[HEAP32[HEAP32[$0 + 20 >> 2] + 28 >> 2] + 8 >> 2], $1);
 }
 return $1 ? $1 : 65;
}

function __lseek($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = __wasi_syscall_ret(legalfunc$__wasi_fd_seek($0, $1, $2, $3 & 255, $4 + 8 | 0));
 __stack_pointer = $4 + 16 | 0;
 $2 = HEAP32[$4 + 12 >> 2];
 i64toi32_i32$HIGH_BITS = $3 ? -1 : $2;
 $1 = HEAP32[$4 + 8 >> 2];
 return $3 ? -1 : $1;
}

function sqlite3_vmprintf($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 112 | 0;
 __stack_pointer = $2;
 if (!sqlite3_initialize()) {
  sqlite3StrAccumInit($2 + 8 | 0, 0, $2 + 32 | 0, 70, 1e9);
  sqlite3_str_vappendf($2 + 8 | 0, $0, $1);
  $3 = sqlite3StrAccumFinish($2 + 8 | 0);
 }
 __stack_pointer = $2 + 112 | 0;
 return $3;
}

function sqlite3PagerWalSupported($0) {
 var $1 = 0;
 $1 = 0;
 label$1: {
  if (HEAPU8[$0 + 13 | 0]) {
   break label$1;
  }
  $1 = 1;
  if (HEAPU8[$0 + 4 | 0]) {
   break label$1;
  }
  $0 = HEAP32[HEAP32[$0 + 64 >> 2] >> 2];
  $1 = 0;
  if (HEAP32[$0 >> 2] < 2) {
   break label$1;
  }
  $1 = HEAP32[$0 + 52 >> 2] != 0;
 }
 return $1;
}

function sqlite3VdbeAddDblquoteStr($0, $1, $2) {
 var $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $3 = sqlite3Strlen30($2);
  $0 = sqlite3DbMallocRawNN($0, $3 + 5 | 0, 0);
  if (!$0) {
   break label$1;
  }
  HEAP32[$0 >> 2] = HEAP32[$1 + 204 >> 2];
  HEAP32[$1 + 204 >> 2] = $0;
  __memcpy($0 + 4 | 0, $2, $3 + 1 | 0);
 }
}

function renderLogMsg($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 240 | 0;
 __stack_pointer = $3;
 sqlite3StrAccumInit($3 + 216 | 0, 0, $3, 210, 0);
 sqlite3_str_vappendf($3 + 216 | 0, $1, $2);
 $2 = HEAP32[16127];
 FUNCTION_TABLE[$2 | 0](HEAP32[16128], $0, sqlite3StrAccumFinish($3 + 216 | 0));
 __stack_pointer = $3 + 240 | 0;
}

function unixGetSystemCall($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 while (1) {
  label$2: {
   if (($2 | 0) != 29) {
    if (strcmp($1, HEAP32[Math_imul($2, 12) + 64944 >> 2])) {
     break label$2;
    }
    $3 = HEAP32[Math_imul($2, 12) + 64948 >> 2];
   }
   return $3 | 0;
  }
  $2 = $2 + 1 | 0;
  continue;
 }
}

function sqlite3DeleteTrigger($0, $1) {
 if (!(HEAPU8[$1 + 10 | 0] | !$1)) {
  sqlite3DeleteTriggerStep($0, HEAP32[$1 + 28 >> 2]);
  sqlite3DbFree($0, HEAP32[$1 >> 2]);
  sqlite3DbFree($0, HEAP32[$1 + 4 >> 2]);
  sqlite3ExprDelete($0, HEAP32[$1 + 12 >> 2]);
  sqlite3IdListDelete($0, HEAP32[$1 + 16 >> 2]);
  sqlite3DbFree($0, $1);
 }
}

function closeCursorsInFrame($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 while (1) {
  if (HEAP32[$0 + 24 >> 2] > ($1 | 0)) {
   $2 = $1 << 2;
   $3 = HEAP32[$2 + HEAP32[$0 + 96 >> 2] >> 2];
   if ($3) {
    sqlite3VdbeFreeCursorNN($0, $3);
    HEAP32[HEAP32[$0 + 96 >> 2] + $2 >> 2] = 0;
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
}

function sqlite3VdbeAddParseSchemaOp($0, $1, $2, $3) {
 var $4 = 0;
 sqlite3VdbeAddOp4($0, 149, $1, 0, 0, $2, -6);
 sqlite3VdbeChangeP5($0, $3);
 while (1) {
  if (($4 | 0) < HEAP32[HEAP32[$0 >> 2] + 20 >> 2]) {
   sqlite3VdbeUsesBtree($0, $4);
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3MayAbort(HEAP32[$0 + 12 >> 2]);
}

function sqlite3PcacheOpen($0, $1, $2, $3, $4) {
 $4 = memset($4, 0, 48);
 HEAP32[$4 + 40 >> 2] = $3;
 HEAP32[$4 + 36 >> 2] = $2;
 HEAP8[$4 + 33 | 0] = 2;
 HEAP8[$4 + 32 | 0] = $1;
 HEAP32[$4 + 24 >> 2] = 1;
 HEAP32[$4 + 28 >> 2] = 88;
 HEAP32[$4 + 16 >> 2] = 100;
 HEAP32[$4 + 20 >> 2] = 1;
 return sqlite3PcacheSetPageSize($4, $0);
}

function last_valueInvFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 label$1: {
  $0 = sqlite3_aggregate_context($0, 8);
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[$0 + 4 >> 2] - 1 | 0;
  HEAP32[$0 + 4 >> 2] = $1;
  if ($1) {
   break label$1;
  }
  sqlite3_value_free(HEAP32[$0 >> 2]);
  HEAP32[$0 >> 2] = 0;
 }
}

function sqlite3_db_release_memory($0) {
 var $1 = 0, $2 = 0;
 sqlite3BtreeEnterAll($0);
 while (1) {
  if (HEAP32[$0 + 20 >> 2] > ($1 | 0)) {
   $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
   if ($2) {
    sqlite3PagerShrink(sqlite3BtreePager($2));
   }
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 return 0;
}

function sqlite3ExprAnalyzeAggregates($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 24 >> 2] = $0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 44;
 HEAP32[$2 + 8 >> 2] = 43;
 HEAP32[$2 + 4 >> 2] = 53;
 HEAP32[$2 >> 2] = 0;
 sqlite3WalkExpr($2, $1);
 __stack_pointer = $2 + 32 | 0;
}

function nodeReaderInit($0, $1, $2) {
 memset($0 + 8 | 0, 0, 40);
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP32[$0 >> 2] = $1;
 if (!$1) {
  HEAP32[$0 + 8 >> 2] = 1;
  return 0;
 }
 if (HEAPU8[$1 | 0]) {
  $1 = sqlite3Fts3GetVarint($1 + 1 | 0, $0 + 16 | 0) + 1 | 0;
 } else {
  $1 = 1;
 }
 HEAP32[$0 + 8 >> 2] = $1;
 return nodeReaderNext($0);
}

function sqlite3PCachePercentDirty($0) {
 var $1 = 0, $2 = 0;
 $1 = numberOfCachePages($0);
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if ($0) {
   $0 = $0 + 32 | 0;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 if (!$1) {
  return 0;
 }
 return __wasm_i64_sdiv(__wasm_i64_mul($2, 0, 100, 0), i64toi32_i32$HIGH_BITS, $1, $1 >> 31);
}

function fts3SqlExec($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 if (!HEAP32[$0 >> 2]) {
  $3 = fts3SqlStmt($1, $2, $4 + 12 | 0, $3);
  if (!$3) {
   $3 = HEAP32[$4 + 12 >> 2];
   sqlite3_step($3);
   $3 = sqlite3_reset($3);
  }
  HEAP32[$0 >> 2] = $3;
 }
 __stack_pointer = $4 + 16 | 0;
}

function first_valueFinalizeFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 16);
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 8 >> 2];
  if (!$2) {
   break label$1;
  }
  sqlite3_result_value($0, $2);
  sqlite3_value_free(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 8 >> 2] = 0;
 }
}

function sqlite3_reset($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 if (!$0) {
  return 0;
 }
 $2 = HEAP32[$0 >> 2];
 $1 = HEAP32[$0 + 140 >> 2];
 if (!!HEAP32[$0 + 136 >> 2] & ($1 | 0) >= 0 | ($1 | 0) > 0) {
  invokeProfileCallback($2, $0);
 }
 $1 = sqlite3VdbeReset($0);
 sqlite3VdbeRewind($0);
 return sqlite3ApiExit($2, $1) | 0;
}

function sqlite3JournalOpen($0, $1, $2, $3, $4) {
 $2 = memset($2, 0, 64);
 if (!$4) {
  return sqlite3OsOpen($0, $1, $2, $3, 0);
 }
 HEAP32[$2 + 56 >> 2] = $1;
 HEAP32[$2 + 48 >> 2] = $3;
 HEAP32[$2 + 8 >> 2] = $4;
 HEAP32[$2 >> 2] = 32184;
 HEAP32[$2 + 52 >> 2] = $0;
 HEAP32[$2 + 4 >> 2] = ($4 | 0) > 0 ? $4 : 1020;
 return 0;
}

function sqlite3HashClear($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 HEAP32[$0 + 8 >> 2] = 0;
 sqlite3_free(HEAP32[$0 + 12 >> 2]);
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 >> 2];
   sqlite3_free($1);
   $1 = $2;
   continue;
  }
  break;
 }
 HEAP32[$0 + 4 >> 2] = 0;
}

function exprListDeleteNN($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = $1 + 8 | 0;
 $3 = HEAP32[$1 >> 2];
 while (1) {
  sqlite3ExprDelete($0, HEAP32[$2 >> 2]);
  sqlite3DbFree($0, HEAP32[$2 + 4 >> 2]);
  $2 = $2 + 16 | 0;
  $4 = ($3 | 0) > 1;
  $3 = $3 - 1 | 0;
  if ($4) {
   continue;
  }
  break;
 }
 sqlite3DbFreeNN($0, $1);
}

function walHashGet($0, $1, $2) {
 var $3 = 0;
 $0 = walIndexPage($0, $1, $2 + 4 | 0);
 $3 = HEAP32[$2 + 4 >> 2];
 if ($3) {
  HEAP32[$2 >> 2] = $3 + 16384;
  if (!$1) {
   HEAP32[$2 + 8 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = $3 + 136;
   return $0;
  }
  HEAP32[$2 + 8 >> 2] = ($1 << 12) - 34;
  return $0;
 }
 return $0 ? $0 : 1;
}

function sqlite3LocateTableItem($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$2 >> 2];
 label$1: {
  if ($3) {
   $4 = HEAP32[$0 >> 2];
   $3 = HEAP32[$4 + 16 >> 2] + (sqlite3SchemaToIndex($4, $3) << 4) | 0;
   break label$1;
  }
  $3 = $2 + 4 | 0;
 }
 return sqlite3LocateTable($0, $1, HEAP32[$2 + 8 >> 2], HEAP32[$3 >> 2]);
}

function fts3TokenizerEnabled($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $0 = sqlite3_context_db_handle($0);
 HEAP32[$1 >> 2] = -1;
 HEAP32[$1 + 12 >> 2] = 0;
 HEAP32[$1 + 4 >> 2] = $1 + 12;
 sqlite3_db_config($0, 1004, $1);
 __stack_pointer = $1 + 16 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 return $0;
}

function nth_valueFinalizeFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 0);
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 + 8 >> 2];
  if (!$2) {
   break label$1;
  }
  sqlite3_result_value($0, $2);
  sqlite3_value_free(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 8 >> 2] = 0;
 }
}

function fts3CompareElemByTerm($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $0 = HEAP32[$0 >> 2];
 $3 = HEAP32[$0 + 12 >> 2];
 $2 = HEAP32[$1 >> 2];
 $1 = HEAP32[$0 + 16 >> 2];
 $0 = HEAP32[$2 + 16 >> 2];
 $2 = memcmp($3, HEAP32[$2 + 12 >> 2], ($0 | 0) > ($1 | 0) ? $1 : $0);
 return ($2 ? $2 : $1 - $0 | 0) | 0;
}

function unicodeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $2 = sqlite3_value_text(HEAP32[$2 >> 2]);
 HEAP32[$1 + 12 >> 2] = $2;
 if (!(!$2 | !HEAPU8[$2 | 0])) {
  sqlite3_result_int($0, sqlite3Utf8Read($1 + 12 | 0));
 }
 __stack_pointer = $1 + 16 | 0;
}

function sqlite3_vfs_find($0) {
 var $1 = 0;
 label$1: {
  if (sqlite3_initialize()) {
   break label$1;
  }
  $1 = 70456;
  while (1) {
   $1 = HEAP32[$1 >> 2];
   if (!$0 | !$1) {
    break label$1;
   }
   if (!strcmp($0, HEAP32[$1 + 16 >> 2])) {
    break label$1;
   }
   $1 = $1 + 12 | 0;
   continue;
  }
 }
 return $1;
}

function sqlite3PagerOkToChangeJournalMode($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (HEAPU8[$0 + 17 | 0] > 2) {
   break label$1;
  }
  if (HEAP32[HEAP32[$0 + 68 >> 2] >> 2]) {
   $1 = HEAP32[$0 + 84 >> 2];
   if (!!HEAP32[$0 + 80 >> 2] & ($1 | 0) >= 0 | ($1 | 0) > 0) {
    break label$1;
   }
  }
  $2 = 1;
 }
 return $2;
}

function memmove($0, $1, $2) {
 var $3 = 0;
 if ($0 >>> 0 < $1 >>> 0) {
  return __memcpy($0, $1, $2);
 }
 if ($2) {
  $3 = $0 + $2 | 0;
  $1 = $1 + $2 | 0;
  while (1) {
   $3 = $3 - 1 | 0;
   $1 = $1 - 1 | 0;
   HEAP8[$3 | 0] = HEAPU8[$1 | 0];
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function memdbTruncate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0;
 $3 = 11;
 $0 = HEAP32[$0 + 4 >> 2];
 $4 = HEAP32[$0 + 4 >> 2];
 if (($2 | 0) <= ($4 | 0) & HEAPU32[$0 >> 2] >= $1 >>> 0 | ($2 | 0) < ($4 | 0)) {
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  $3 = 0;
 }
 return $3 | 0;
}

function fts3CursorFinalizeStmt($0) {
 var $1 = 0, $2 = 0;
 if (HEAPU8[$0 + 8 | 0]) {
  $1 = HEAP32[$0 >> 2];
  if (!HEAP32[$1 + 220 >> 2]) {
   $2 = HEAP32[$0 + 12 >> 2];
   HEAP32[$1 + 220 >> 2] = $2;
   sqlite3_reset($2);
   HEAP32[$0 + 12 >> 2] = 0;
  }
  HEAP8[$0 + 8 | 0] = 0;
 }
 sqlite3_finalize(HEAP32[$0 + 12 >> 2]);
}

function isAsteriskTerm($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAPU8[$1 | 0];
 label$1: {
  if (($3 | 0) != 141) {
   $2 = 1;
   if (($3 | 0) == 180) {
    break label$1;
   }
   return 0;
  }
  $2 = 0;
  if (HEAPU8[HEAP32[$1 + 16 >> 2]] != 180) {
   break label$1;
  }
  sqlite3ErrorMsg($0, 5610, 0);
  $2 = 1;
 }
 return $2;
}

function anotherValidCursor($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 20 >> 2] + 8 | 0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if (!$1) {
   return 0;
  }
  if (!(HEAPU8[$1 | 0] | ($0 | 0) == ($1 | 0) | HEAP32[$1 + 116 >> 2] != HEAP32[$0 + 116 >> 2])) {
   return sqlite3CorruptError(75589);
  }
  $1 = $1 + 24 | 0;
  continue;
 }
}

function juliandayFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 48 | 0;
 __stack_pointer = $3;
 if (!isDate($0, $1, $2, $3)) {
  computeJD($3);
  sqlite3_result_double($0, (+HEAPU32[$3 >> 2] + +HEAP32[$3 + 4 >> 2] * 4294967296) / 864e5);
 }
 __stack_pointer = $3 + 48 | 0;
}

function execSqlF($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $3;
 $3 = sqlite3VMPrintf($0, $2, $3);
 label$1: {
  if (!$3) {
   $2 = 7;
   break label$1;
  }
  $2 = execSql($0, $1, $3);
  sqlite3DbFree($0, $3);
 }
 __stack_pointer = $4 + 16 | 0;
 return $2;
}

function codeReal($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 if ($1) {
  sqlite3AtoF($1, $4 + 8 | 0, sqlite3Strlen30($1), 1);
  if ($2) {
   HEAPF64[$4 + 8 >> 3] = -HEAPF64[$4 + 8 >> 3];
  }
  sqlite3VdbeAddOp4Dup8($0, 153, $3, $4 + 8 | 0, -12);
 }
 __stack_pointer = $4 + 16 | 0;
}

function sqlite3VdbeSetChanges($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = $0;
 HEAP32[$3 + 104 >> 2] = $1;
 HEAP32[$3 + 108 >> 2] = $2;
 $4 = $1 + HEAP32[$3 + 112 >> 2] | 0;
 $3 = HEAP32[$3 + 116 >> 2];
 $2 = $3 + $2 | 0;
 HEAP32[$0 + 112 >> 2] = $4;
 $2 = $1 >>> 0 > $4 >>> 0 ? $2 + 1 | 0 : $2;
 HEAP32[$0 + 116 >> 2] = $2;
}

function sqlite3ParserAddCleanup($0, $1, $2) {
 var $3 = 0;
 $3 = sqlite3DbMallocRaw(HEAP32[$0 >> 2], 12, 0);
 if ($3) {
  HEAP32[$3 >> 2] = HEAP32[$0 + 128 >> 2];
  HEAP32[$0 + 128 >> 2] = $3;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 4 >> 2] = $2;
  return $2;
 }
 FUNCTION_TABLE[$1 | 0](HEAP32[$0 >> 2], $2);
 return 0;
}

function sqlite3ExprCodeGetColumn($0, $1, $2, $3, $4, $5) {
 sqlite3ExprCodeGetColumnOfTable(HEAP32[$0 + 8 >> 2], $1, $3, $2, $4);
 label$1: {
  if (!$5) {
   break label$1;
  }
  $0 = sqlite3VdbeGetOp(HEAP32[$0 + 8 >> 2], -1);
  if (HEAPU8[$0 | 0] != 94) {
   break label$1;
  }
  HEAP16[$0 + 2 >> 1] = $5;
 }
 return $4;
}

function sqlite3ExprAnalyzeAggList($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = $1 + 8 | 0;
  while (1) {
   if (HEAP32[$1 >> 2] <= ($3 | 0)) {
    break label$1;
   }
   sqlite3ExprAnalyzeAggregates($0, HEAP32[$2 >> 2]);
   $2 = $2 + 16 | 0;
   $3 = $3 + 1 | 0;
   continue;
  }
 }
}

function zeroblobFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $2 = sqlite3_value_int64(HEAP32[$2 >> 2]);
 $1 = i64toi32_i32$HIGH_BITS;
 $3 = !!$2 & ($1 | 0) >= 0 | ($1 | 0) > 0;
 $2 = sqlite3_result_zeroblob64($0, $3 ? $2 : 0, $3 ? $1 : 0);
 if ($2) {
  sqlite3_result_error_code($0, $2);
 }
}

function sqlite3ExprListAppendNew($0, $1) {
 var $2 = 0;
 $2 = sqlite3DbMallocRawNN($0, 88, 0);
 if (!$2) {
  sqlite3ExprDelete($0, $1);
  return $2;
 }
 HEAP32[$2 >> 2] = 1;
 HEAP32[$2 + 4 >> 2] = 4;
 HEAP32[$2 + 8 >> 2] = $1;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP32[$2 + 16 >> 2] = 0;
 HEAP32[$2 + 20 >> 2] = 0;
 return $2;
}

function sqlite3ExprFunctionUsable($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (!(!(HEAPU8[$1 + 7 | 0] & 64) | !(HEAPU8[HEAP32[$0 >> 2] + 32 | 0] & 128 ? HEAPU8[$2 + 6 | 0] & 8 : 1))) {
  HEAP32[$3 >> 2] = $1;
  sqlite3ErrorMsg($0, 26125, $3);
 }
 __stack_pointer = $3 + 16 | 0;
}

function node_iterate($0, $1, $2) {
 var $3 = 0;
 while (1) {
  if ($0) {
   $3 = HEAP32[$0 >> 2];
   if ($3) {
    node_iterate($3, $1, $2);
   }
   FUNCTION_TABLE[$1 | 0](HEAP32[$0 + 8 >> 2], HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], $2);
   $0 = HEAP32[$0 + 4 >> 2];
   if ($0) {
    continue;
   }
  }
  break;
 }
}

function sqlite3OomClear($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 if (!(HEAP32[$0 + 196 >> 2] | !HEAPU8[$0 + 87 | 0])) {
  HEAP32[$0 + 296 >> 2] = 0;
  HEAP8[$0 + 87 | 0] = 0;
  $1 = HEAP32[$0 + 304 >> 2] - 1 | 0;
  HEAP32[$0 + 304 >> 2] = $1;
  $2 = $1 ? $2 : HEAPU16[$0 + 310 >> 1];
  HEAP16[$0 + 308 >> 1] = $2;
 }
}

function sqlite3ExprIdToTrueFalse($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 label$1: {
  if ($1 & 67110912) {
   break label$1;
  }
  $2 = sqlite3IsTrueOrFalse(HEAP32[$0 + 8 >> 2]);
  if (!$2) {
   break label$1;
  }
  HEAP8[$0 | 0] = 170;
  HEAP32[$0 + 4 >> 2] = $1 | $2;
  $3 = 1;
 }
 return $3;
}

function addArgumentToVtab($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 label$1: {
  $1 = HEAP32[$0 + 252 >> 2];
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$0 + 236 >> 2];
  if (!$2) {
   break label$1;
  }
  $3 = HEAP32[$0 + 256 >> 2];
  addModuleArgument($0, $2, sqlite3DbStrNDup(HEAP32[$0 >> 2], $1, $3, $3 >> 31));
 }
}

function sqlite3_vsnprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 32 | 0;
 __stack_pointer = $4;
 if (($0 | 0) > 0) {
  sqlite3StrAccumInit($4 + 8 | 0, 0, $1, $0, 0);
  sqlite3_str_vappendf($4 + 8 | 0, $2, $3);
  HEAP8[HEAP32[$4 + 24 >> 2] + $1 | 0] = 0;
 }
 __stack_pointer = $4 + 32 | 0;
 return $1;
}

function sqlite3UpsertDup($0, $1) {
 if (!$1) {
  return 0;
 }
 return sqlite3UpsertNew($0, sqlite3ExprListDup($0, HEAP32[$1 >> 2], 0), sqlite3ExprDup($0, HEAP32[$1 + 4 >> 2], 0), sqlite3ExprListDup($0, HEAP32[$1 + 8 >> 2], 0), sqlite3ExprDup($0, HEAP32[$1 + 12 >> 2], 0), sqlite3UpsertDup($0, HEAP32[$1 + 16 >> 2]));
}

function resolveOutOfRangeError($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = __stack_pointer - 16 | 0;
 __stack_pointer = $5;
 HEAP32[$5 + 8 >> 2] = $3;
 HEAP32[$5 + 4 >> 2] = $1;
 HEAP32[$5 >> 2] = $2;
 sqlite3ErrorMsg($0, 16677, $5);
 sqlite3RecordErrorOffsetOfExpr(HEAP32[$0 >> 2], $4);
 __stack_pointer = $5 + 16 | 0;
}

function indexColumnIsBeingUpdated($0, $1, $2, $3) {
 var $4 = 0;
 $4 = HEAP16[HEAP32[$0 + 4 >> 2] + ($1 << 1) >> 1];
 if (($4 | 0) >= 0) {
  return (HEAP32[(($4 & 65535) << 2) + $2 >> 2] ^ -1) >>> 31 | 0;
 }
 return sqlite3ExprReferencesUpdatedColumn(HEAP32[(HEAP32[$0 + 40 >> 2] + ($1 << 4) | 0) + 8 >> 2], $2, $3);
}

function sqlite3ExprAddCollateToken($0, $1, $2, $3) {
 label$1: {
  if (!HEAP32[$2 + 4 >> 2]) {
   break label$1;
  }
  $2 = sqlite3ExprAlloc(HEAP32[$0 >> 2], 113, $2, $3);
  if (!$2) {
   break label$1;
  }
  HEAP32[$2 + 12 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 8704;
  return $2;
 }
 return $1;
}

function pcache1FreePage($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 label$1: {
  if (HEAPU16[$0 + 12 >> 1]) {
   HEAP32[$0 + 16 >> 2] = HEAP32[$1 + 60 >> 2];
   HEAP32[$1 + 60 >> 2] = $0;
   break label$1;
  }
  pcache1Free(HEAP32[$0 >> 2]);
 }
 $0 = HEAP32[$1 + 4 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - 1;
}

function last_valueFinalizeFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 8);
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 >> 2];
  if (!$2) {
   break label$1;
  }
  sqlite3_result_value($0, $2);
  sqlite3_value_free(HEAP32[$1 >> 2]);
  HEAP32[$1 >> 2] = 0;
 }
}

function fts3auxDisconnectMethod($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $2 = HEAP32[$0 + 12 >> 2];
 while (1) {
  if (($1 | 0) != 40) {
   sqlite3_finalize(HEAP32[(($1 << 2) + $2 | 0) + 60 >> 2]);
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3_free(HEAP32[$2 + 248 >> 2]);
 sqlite3_free($0);
 return 0;
}

function sqlite3VdbeHandleMovedCursor($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 $2 = sqlite3BtreeCursorRestore(HEAP32[$0 + 36 >> 2], $1 + 12 | 0);
 HEAP32[$0 + 24 >> 2] = 0;
 if (HEAP32[$1 + 12 >> 2]) {
  HEAP8[$0 + 2 | 0] = 1;
 }
 __stack_pointer = $1 + 16 | 0;
 return $2;
}

function sqlite3StrAccumFinish($0) {
 var $1 = 0;
 label$1: {
  $1 = HEAP32[$0 + 4 >> 2];
  if (!$1) {
   break label$1;
  }
  HEAP8[HEAP32[$0 + 16 >> 2] + $1 | 0] = 0;
  if (!HEAP32[$0 + 12 >> 2] | HEAPU8[$0 + 21 | 0] & 4) {
   break label$1;
  }
  return strAccumFinishRealloc($0);
 }
 return HEAP32[$0 + 4 >> 2];
}

function sqlite3PcacheSetCachesize($0, $1) {
 var wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
 HEAP32[$0 + 16 >> 2] = $1;
 wasm2js_i32$1 = HEAP32[$0 + 44 >> 2], wasm2js_i32$2 = numberOfCachePages($0), wasm2js_i32$0 = HEAP32[16098], 
 FUNCTION_TABLE[wasm2js_i32$0](wasm2js_i32$1 | 0, wasm2js_i32$2 | 0);
}

function sqlite3PcacheRelease($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] - 1;
 $1 = HEAPU16[$0 + 30 >> 1] - 1 | 0;
 HEAP16[$0 + 30 >> 1] = $1;
 if (!($1 & 65535)) {
  if (HEAP8[$0 + 28 | 0] & 1) {
   pcacheUnpin($0);
   return;
  }
  pcacheManageDirtyList($0, 3);
 }
}

function pager_write_changecounter($0) {
 var $1 = 0, $2 = 0;
 if ($0) {
  $2 = HEAP32[$0 + 4 >> 2] + 24 | 0;
  $1 = sqlite3Get4byte(HEAP32[$0 + 20 >> 2] + 112 | 0) + 1 | 0;
  sqlite3Put4byte($2, $1);
  sqlite3Put4byte(HEAP32[$0 + 4 >> 2] + 92 | 0, $1);
  sqlite3Put4byte(HEAP32[$0 + 4 >> 2] + 96 | 0, 3039003);
 }
}

function analyzeFilterKeyword($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 label$1: {
  if (($1 | 0) == 23) {
   $0 = 166;
   if ((getToken($2 + 12 | 0) | 0) == 22) {
    break label$1;
   }
  }
  $0 = 59;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function sqlite3ValueText($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = HEAPU16[$0 + 16 >> 1];
  if (!(($2 & 514) != 514 | HEAPU8[$0 + 18 | 0] != ($1 | 0))) {
   return HEAP32[$0 + 8 >> 2];
  }
  if ($2 & 1) {
   break label$1;
  }
  $3 = valueToText($0, $1);
 }
 return $3;
}

function fts3SegReaderRequire($0, $1, $2) {
 $1 = $1 + $2 | 0;
 $2 = 0;
 while (1) {
  label$2: {
   if (!(!HEAP32[$0 + 52 >> 2] | $2)) {
    if (HEAP32[$0 + 48 >> 2] < ($1 - HEAP32[$0 + 40 >> 2] | 0)) {
     break label$2;
    }
    $2 = 0;
   }
   return $2;
  }
  $2 = fts3SegReaderIncrRead($0);
  continue;
 }
}

function sqlite3IsNaN($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $3 = $1;
 $2 = $1 & 2146435072;
 $1 = 0;
 $4 = !$1 & ($2 | 0) == 2146435072;
 $1 = $3;
 $2 = $1 & 1048575;
 $1 = wasm2js_scratch_load_i32(0) | 0;
 return $4 & ($2 | $1) != 0;
}

function R_1($0) {
 return ($0 * ($0 * ($0 * ($0 * ($0 * 3479331075960212e-20 + .0007915349942898145) + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) * $0 / ($0 * ($0 * ($0 * ($0 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1);
}

function exprIsConst($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 24 >> 2] = $2;
 HEAP32[$3 + 8 >> 2] = 59;
 HEAP32[$3 + 4 >> 2] = 60;
 HEAP16[$3 + 20 >> 1] = $1;
 sqlite3WalkExpr($3, $0);
 __stack_pointer = $3 + 32 | 0;
 $2 = HEAPU16[$3 + 20 >> 1];
 return $2;
}

function sqlite3VdbeUsesDoubleQuotedString($0, $1) {
 var $2 = 0;
 $0 = HEAP32[$0 + 204 >> 2];
 label$1: {
  if (!$0) {
   break label$1;
  }
  while (1) {
   if (!$0) {
    break label$1;
   }
   if (strcmp($1, $0 + 4 | 0)) {
    $0 = HEAP32[$0 >> 2];
    continue;
   }
   break;
  }
  $2 = 1;
 }
 return $2;
}

function sqlite3PagerSync($0, $1) {
 $1 = sqlite3OsFileControl(HEAP32[$0 + 64 >> 2], 21, $1);
 $1 = ($1 | 0) == 12 ? 0 : $1;
 label$1: {
  if ($1) {
   break label$1;
  }
  $1 = 0;
  if (HEAPU8[$0 + 7 | 0]) {
   break label$1;
  }
  $1 = sqlite3OsSync(HEAP32[$0 + 64 >> 2], HEAPU8[$0 + 10 | 0]);
 }
 return $1;
}

function sqlite3ExprCheckHeight($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 $3 = HEAP32[HEAP32[$0 >> 2] + 132 >> 2];
 if (($3 | 0) < ($1 | 0)) {
  HEAP32[$2 >> 2] = $3;
  sqlite3ErrorMsg($0, 25032, $2);
  $4 = 1;
 }
 __stack_pointer = $2 + 16 | 0;
 return $4;
}

function m_gt_0($0) {
 $0 = $0 | 0;
 var $1 = 0;
 while (1) {
  $1 = $0;
  $0 = $0 + 1 | 0;
  if (isVowel($1)) {
   continue;
  }
  break;
 }
 if (!HEAPU8[$1 | 0]) {
  return 0;
 }
 while (1) {
  $0 = $1;
  $1 = $0 + 1 | 0;
  if (isConsonant($0)) {
   continue;
  }
  break;
 }
 return HEAPU8[$0 | 0] != 0 | 0;
}

function fts3MIBufferFree($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = $0 - HEAP32[$0 - 4 >> 2] | 0;
 label$1: {
  if (($1 + 20 | 0) == ($0 | 0)) {
   HEAP8[$1 + 1 | 0] = 0;
   break label$1;
  }
  HEAP8[$1 + 2 | 0] = 0;
 }
 if (!(HEAPU8[$1 + 2 | 0] | (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0]))) {
  sqlite3_free($1);
 }
}

function R($0) {
 return ($0 * ($0 * ($0 * ($0 * ($0 * 3479331075960212e-20 + .0007915349942898145) + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) * $0 / ($0 * ($0 * ($0 * ($0 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1);
}

function sqlite3SelectPopWith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 label$1: {
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$1 + 52 >> 2] | !HEAP32[$0 + 264 >> 2]) {
   break label$1;
  }
  $1 = HEAP32[findRightmost($1) + 64 >> 2];
  if (!$1) {
   break label$1;
  }
  HEAP32[$0 + 264 >> 2] = HEAP32[$1 + 8 >> 2];
 }
}

function renameReloadSchema($0, $1, $2) {
 label$1: {
  if (!HEAP32[$0 + 8 >> 2]) {
   break label$1;
  }
  sqlite3ChangeCookie($0, $1);
  sqlite3VdbeAddParseSchemaOp(HEAP32[$0 + 8 >> 2], $1, 0, $2);
  if (($1 | 0) == 1) {
   break label$1;
  }
  sqlite3VdbeAddParseSchemaOp(HEAP32[$0 + 8 >> 2], 1, 0, $2);
 }
}

function sqlite3ResolveSelectNames($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 32 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 HEAP32[$3 + 8 >> 2] = 56;
 HEAP32[$3 + 4 >> 2] = 55;
 HEAP32[$3 + 24 >> 2] = $2;
 HEAP32[$3 >> 2] = $0;
 sqlite3WalkSelect($3, $1);
 __stack_pointer = $3 + 32 | 0;
}

function sqlite3IndexHasDuplicateRootPage($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAP32[$0 + 12 >> 2] + 8 | 0;
 while (1) {
  $1 = HEAP32[$2 >> 2];
  if (!$1) {
   return 0;
  }
  $2 = $1 + 20 | 0;
  if (($0 | 0) == ($1 | 0) | HEAP32[$1 + 44 >> 2] != HEAP32[$0 + 44 >> 2]) {
   continue;
  }
  break;
 }
 return 1;
}

function sqlite3BtreeCursorRestore($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAPU8[$0 | 0];
 label$1: {
  if ($2 >>> 0 >= 3) {
   $3 = btreeRestoreCursorPosition($0);
   $2 = 1;
   if ($3) {
    break label$1;
   }
   $2 = HEAPU8[$0 | 0];
  }
  $3 = 0;
  $2 = ($2 | 0) != 0;
 }
 HEAP32[$1 >> 2] = $2;
 return $3;
}

function fts3Getint($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 >> 2];
 while (1) {
  $2 = HEAP8[$1 | 0];
  if (!(($2 | 0) < 48 | $2 >>> 0 > 57 | ($3 | 0) > 214748362)) {
   $1 = $1 + 1 | 0;
   $3 = (Math_imul($3, 10) + $2 | 0) - 48 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 >> 2] = $1;
 return $3;
}

function fkTriggerDelete($0, $1) {
 var $2 = 0;
 if ($1) {
  $2 = HEAP32[$1 + 28 >> 2];
  sqlite3ExprDelete($0, HEAP32[$2 + 20 >> 2]);
  sqlite3ExprListDelete($0, HEAP32[$2 + 24 >> 2]);
  sqlite3SelectDelete($0, HEAP32[$2 + 8 >> 2]);
  sqlite3ExprDelete($0, HEAP32[$1 + 12 >> 2]);
  sqlite3DbFree($0, $1);
 }
}

function sqlite3VdbeRewind($0) {
 HEAP32[$0 + 36 >> 2] = 0;
 HEAP8[$0 + 149 | 0] = 1;
 HEAP32[$0 + 40 >> 2] = 0;
 HEAP32[$0 + 44 >> 2] = 0;
 HEAP16[$0 + 146 >> 1] = 65282;
 HEAP32[$0 + 28 >> 2] = 1;
 HEAP32[$0 + 32 >> 2] = -1;
 HEAP32[$0 + 64 >> 2] = 0;
 HEAP32[$0 + 68 >> 2] = 0;
 HEAP32[$0 + 48 >> 2] = 0;
}

function sqlite3WindowExtraAggFuncDepth($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 label$1: {
  if (HEAPU8[$1 | 0] != 168) {
   break label$1;
  }
  $2 = HEAP32[$0 + 16 >> 2];
  $0 = HEAPU8[$1 + 2 | 0];
  if (($2 | 0) > ($0 | 0)) {
   break label$1;
  }
  HEAP8[$1 + 2 | 0] = $0 + 1;
 }
 return 0;
}

function substExprList($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  while (1) {
   if (HEAP32[$1 >> 2] <= ($2 | 0)) {
    break label$1;
   }
   $3 = ($2 << 4) + $1 | 0;
   HEAP32[$3 + 8 >> 2] = substExpr($0, HEAP32[$3 + 8 >> 2]);
   $2 = $2 + 1 | 0;
   continue;
  }
 }
}

function sqlite3_vfs_register($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $3 = sqlite3_initialize();
 if (!$3) {
  vfsUnlink($0);
  $4 = 70456;
  $2 = HEAP32[17614];
  if (!(!$2 | $1)) {
   $4 = $2 + 12 | 0;
   $2 = HEAP32[$2 + 12 >> 2];
  }
  HEAP32[$0 + 12 >> 2] = $2;
  HEAP32[$4 >> 2] = $0;
 }
 return $3;
}

function sqlite3Utf8CharLen_1($0) {
 var $1 = 0, $2 = 0;
 while (1) {
  label$2: {
   if (($0 | 0) == -1) {
    break label$2;
   }
   $1 = HEAPU8[$0 | 0];
   if (!$1) {
    break label$2;
   }
   $2 = $2 + 1 | 0;
   $0 = (HEAPU8[$1 + 56128 | 0] + $0 | 0) + 1 | 0;
   continue;
  }
  break;
 }
 return $2;
}

function sqlite3StringToId($0) {
 label$1: {
  label$2: {
   switch (HEAPU8[$0 | 0] - 113 | 0) {
   case 0:
    $0 = HEAP32[$0 + 12 >> 2];
    if (HEAPU8[$0 | 0] != 117) {
     break label$1;
    }
    break;

   case 4:
    break label$2;

   default:
    break label$1;
   }
  }
  HEAP8[$0 | 0] = 59;
 }
}

function sqlite3SrcListFuncArgs($0, $1, $2) {
 if ($1) {
  $1 = (HEAP32[$1 >> 2] << 6) + $1 | 0;
  HEAP32[$1 >> 2] = $2;
  $1 = $1 - 19 | 0;
  $0 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | 4;
  HEAP8[$1 | 0] = $0;
  HEAP8[$1 + 1 | 0] = $0 >>> 8;
  return;
 }
 sqlite3ExprListDelete(HEAP32[$0 >> 2], $2);
}

function operatorMask($0) {
 var $1 = 0;
 $1 = 1;
 label$1: {
  label$2: {
   switch ($0 - 45 | 0) {
   case 5:
    $1 = 256;
    break label$1;

   case 0:
    $1 = 128;
    break label$1;

   case 4:
    break label$1;

   default:
    break label$2;
   }
  }
  $1 = 2 << $0 - 53;
 }
 return $1 & 65535;
}

function sqlite3BinaryCompareCollSeq($0, $1, $2) {
 if (HEAPU8[$1 + 5 | 0] & 2) {
  return sqlite3ExprCollSeq($0, $1);
 }
 label$2: {
  if (!(HEAPU8[$2 + 5 | 0] & 2 ? $2 : 0)) {
   $1 = sqlite3ExprCollSeq($0, $1);
   if ($1) {
    break label$2;
   }
  }
  $1 = sqlite3ExprCollSeq($0, $2);
 }
 return $1;
}

function pragmaVtabCursorClear($0) {
 var $1 = 0, $2 = 0;
 sqlite3_finalize(HEAP32[$0 + 4 >> 2]);
 HEAP32[$0 + 4 >> 2] = 0;
 while (1) {
  if (($1 | 0) != 2) {
   $2 = ($1 << 2) + $0 | 0;
   sqlite3_free(HEAP32[$2 + 16 >> 2]);
   HEAP32[$2 + 16 >> 2] = 0;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
}

function compare2pow63($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  if (!($3 >>> 0 > 17 | $2)) {
   $2 = Math_imul(HEAP8[Math_imul($1, $3) + $0 | 0] - HEAP8[$3 + 23846 | 0] | 0, 10);
   $3 = $3 + 1 | 0;
   continue;
  }
  break;
 }
 $2 = $2 ? $2 : HEAP8[Math_imul($1, 18) + $0 | 0] - 56 | 0;
 return $2;
}

function cellSizePtrNoPayload($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $0 = 4;
 while (1) {
  label$2: {
   $2 = $0 + 1 | 0;
   if (HEAP8[$1 + $0 | 0] >= 0) {
    break label$2;
   }
   $3 = $0 >>> 0 < 12;
   $0 = $2;
   if ($3) {
    continue;
   }
  }
  break;
 }
 return $2 & 65535;
}

function sqlite3InvalidFunction($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = sqlite3_user_data($0);
 $2 = sqlite3_mprintf(1950, $1);
 sqlite3_result_error($0, $2, -1);
 sqlite3_free($2);
 __stack_pointer = $1 + 16 | 0;
}

function sqlite3DeleteTable($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  if (!(HEAP32[$0 + 528 >> 2] ? $0 : 0)) {
   $2 = HEAP32[$1 + 24 >> 2] - 1 | 0;
   HEAP32[$1 + 24 >> 2] = $2;
   if ($2) {
    break label$1;
   }
  }
  deleteTable($0, $1);
 }
}

function sqlite3DbNameToBtree($0, $1) {
 var $2 = 0;
 label$1: {
  label$2: {
   if (!$1) {
    $1 = 0;
    break label$2;
   }
   $1 = sqlite3FindDbName($0, $1);
   $2 = 0;
   if (($1 | 0) < 0) {
    break label$1;
   }
  }
  $2 = HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2];
 }
 return $2;
}

function openSubJournal($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 72 >> 2];
 if (!HEAP32[$2 >> 2]) {
  $3 = HEAP32[$0 >> 2];
  if (HEAPU8[$0 + 22 | 0] | HEAPU8[$0 + 5 | 0] == 4) {
   $1 = -1;
  } else {
   $1 = HEAP32[16075];
  }
  $1 = sqlite3JournalOpen($3, 0, $2, 8222, $1);
 }
 return $1;
}

function fts3EncodeIntArray($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 $5 = ($0 | 0) > 0 ? $0 : 0;
 $0 = 0;
 while (1) {
  if (($4 | 0) != ($5 | 0)) {
   $0 = sqlite3Fts3PutVarint($0 + $2 | 0, HEAP32[($4 << 2) + $1 >> 2], 0) + $0 | 0;
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 HEAP32[$3 >> 2] = $0;
}

function sqlite3VdbeChangeToNoop($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 >> 2];
 if (!HEAPU8[$2 + 87 | 0]) {
  $0 = HEAP32[$0 + 104 >> 2] + Math_imul($1, 20) | 0;
  freeP4($2, HEAP8[$0 + 1 | 0], HEAP32[$0 + 16 >> 2]);
  HEAP32[$0 + 16 >> 2] = 0;
  HEAP16[$0 >> 1] = 184;
  $3 = 1;
 }
 return $3;
}

function closePendingFds($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 $1 = HEAP32[$2 + 32 >> 2];
 while (1) {
  if ($1) {
   $3 = HEAP32[$1 + 8 >> 2];
   robust_close($0, HEAP32[$1 >> 2], 36787);
   sqlite3_free($1);
   $1 = $3;
   continue;
  }
  break;
 }
 HEAP32[$2 + 32 >> 2] = 0;
}

function utimensat($0, $1) {
 var $2 = 0;
 $2 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = $1;
  if (HEAP32[$1 + 8 >> 2] != 1073741823) {
   break label$1;
  }
  $2 = HEAP32[$1 + 24 >> 2] == 1073741823 ? 0 : $1;
 }
 return __syscall_ret(__syscall_utimensat(-100, $0 | 0, $2 | 0, 0) | 0);
}

function isAllZero($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = ($1 | 0) > 0 ? $1 : 0;
 $3 = 1;
 label$1: {
  while (1) {
   if (($2 | 0) == ($4 | 0)) {
    break label$1;
   }
   $1 = $0 + $2 | 0;
   $2 = $2 + 1 | 0;
   if (!HEAPU8[$1 | 0]) {
    continue;
   }
   break;
  }
  $3 = 0;
 }
 return $3;
}

function functionDestroy($0, $1) {
 var $2 = 0;
 label$1: {
  $1 = HEAP32[$1 + 36 >> 2];
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 >> 2] - 1 | 0;
  HEAP32[$1 >> 2] = $2;
  if ($2) {
   break label$1;
  }
  FUNCTION_TABLE[HEAP32[$1 + 4 >> 2]](HEAP32[$1 + 8 >> 2]);
  sqlite3DbFree($0, $1);
 }
}

function fts3TermCmp($0, $1, $2, $3) {
 var $4 = 0;
 label$1: {
  label$2: {
   if (!$2 | !$0) {
    break label$2;
   }
   $4 = ($1 | 0) < ($3 | 0) ? $1 : $3;
   if (!$4) {
    break label$2;
   }
   $2 = memcmp($0, $2, $4);
   if ($2) {
    break label$1;
   }
  }
  $2 = $1 - $3 | 0;
 }
 return $2;
}

function sqlite3_errcode($0) {
 var $1 = 0;
 $1 = 7;
 label$1: {
  if (!$0) {
   break label$1;
  }
  if (!sqlite3SafetyCheckSickOrOk($0)) {
   return sqlite3MisuseError(173329);
  }
  if (HEAPU8[$0 + 87 | 0]) {
   break label$1;
  }
  $1 = HEAP32[$0 + 72 >> 2] & HEAP32[$0 + 64 >> 2];
 }
 return $1;
}

function sqlite3PagerJournalSizeLimit($0, $1, $2) {
 if (($1 | 0) == -1 & ($2 | 0) >= -1 | ($2 | 0) >= 0) {
  HEAP32[$0 + 176 >> 2] = $1;
  HEAP32[$0 + 180 >> 2] = $2;
  sqlite3WalLimit(HEAP32[$0 + 232 >> 2], $1, $2);
 }
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 180 >> 2];
 return HEAP32[$0 + 176 >> 2];
}

function sqlite3ColumnExpr($0, $1) {
 var $2 = 0;
 $1 = HEAPU16[$1 + 8 >> 1];
 label$1: {
  if (HEAPU8[$0 + 43 | 0] | !$1) {
   break label$1;
  }
  $0 = HEAP32[$0 + 52 >> 2];
  if (!$0 | HEAP32[$0 >> 2] < ($1 | 0)) {
   break label$1;
  }
  $2 = HEAP32[(($1 << 4) + $0 | 0) - 8 >> 2];
 }
 return $2;
}

function memRealValue($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 8 >> 2] = 0;
 HEAP32[$1 + 12 >> 2] = 0;
 sqlite3AtoF(HEAP32[$0 + 8 >> 2], $1 + 8 | 0, HEAP32[$0 + 12 >> 2], HEAPU8[$0 + 18 | 0]);
 __stack_pointer = $1 + 16 | 0;
 return HEAPF64[$1 + 8 >> 3];
}

function analyzeOverKeyword($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = $0;
 $0 = 59;
 if (($1 | 0) == 23) {
  $0 = getToken($2 + 12 | 0);
  $0 = ($0 | 0) == 59 ? 165 : ($0 | 0) == 22 ? 165 : 59;
 }
 __stack_pointer = $2 + 16 | 0;
 return $0;
}

function sqlite3VtabArgExtend($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$1 >> 2];
 $3 = HEAP32[$0 + 252 >> 2];
 label$1: {
  if (!$3) {
   HEAP32[$0 + 252 >> 2] = $2;
   $1 = HEAP32[$1 + 4 >> 2];
   break label$1;
  }
  $1 = (HEAP32[$1 + 4 >> 2] + $2 | 0) - $3 | 0;
 }
 HEAP32[$0 + 256 >> 2] = $1;
}

function sqlite3PcacheMakeDirty($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = HEAPU16[$0 + 28 >> 1];
  if (!($1 & 17)) {
   break label$1;
  }
  $2 = $1 & 65519;
  HEAP16[$0 + 28 >> 1] = $2;
  if (!($1 & 1)) {
   break label$1;
  }
  HEAP16[$0 + 28 >> 1] = $2 ^ 3;
  pcacheManageDirtyList($0, 2);
 }
}

function vdbeMergeEngineFree($0) {
 var $1 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  while (1) {
   if (HEAP32[$0 >> 2] <= ($1 | 0)) {
    break label$1;
   }
   vdbePmaReaderClear(HEAP32[$0 + 12 >> 2] + Math_imul($1, 56) | 0);
   $1 = $1 + 1 | 0;
   continue;
  }
 }
 sqlite3_free($0);
}

function sqlite3OsRandomness($0, $1) {
 if (HEAP32[16137]) {
  $0 = memset($1, 0, 256);
  $1 = HEAP32[16137];
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
  HEAP8[$0 + 2 | 0] = $1 >>> 16;
  HEAP8[$0 + 3 | 0] = $1 >>> 24;
  return;
 }
 FUNCTION_TABLE[HEAP32[$0 + 56 >> 2]]($0, 256, $1) | 0;
}

function sqlite3ExprListFlags($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 >> 2];
 $3 = ($1 | 0) > 0 ? $1 : 0;
 $1 = 0;
 while (1) {
  if (($1 | 0) != ($3 | 0)) {
   $2 = HEAP32[HEAP32[(($1 << 4) + $0 | 0) + 8 >> 2] + 4 >> 2] | $2;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 return $2;
}

function sqlite3BtreeClearTable($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $4 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 $3 = saveAllCursors($4, $1, 0);
 if (!$3) {
  if (HEAPU8[$0 + 11 | 0]) {
   invalidateIncrblobCursors($0, $1, 0, 0, 1);
  }
  $3 = clearDatabasePage($4, $1, 0, $2);
 }
 return $3;
}

function btreeGetPage($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $3 = sqlite3PagerGet(HEAP32[$0 >> 2], $1, $4 + 12 | 0, $3);
 if (!$3) {
  HEAP32[$2 >> 2] = btreePageFromDbPage(HEAP32[$4 + 12 >> 2], $1, $0);
 }
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function renumberCursorDoMapping($0, $1) {
 var $2 = 0;
 label$1: {
  $2 = HEAP32[$1 >> 2];
  $0 = HEAP32[$0 + 24 >> 2];
  if (($2 | 0) >= HEAP32[$0 >> 2]) {
   break label$1;
  }
  $0 = HEAP32[(($2 << 2) + $0 | 0) + 4 >> 2];
  if (($0 | 0) <= 0) {
   break label$1;
  }
  HEAP32[$1 >> 2] = $0;
 }
}

function jsonEachCursorReset($0) {
 sqlite3_free(HEAP32[$0 + 24 >> 2]);
 sqlite3_free(HEAP32[$0 + 28 >> 2]);
 jsonParseReset($0 + 32 | 0);
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP8[$0 + 20 | 0] = 0;
}

function indexIteratorFirst($0, $1) {
 var $2 = 0;
 label$1: {
  if (HEAP32[$0 >> 2]) {
   $2 = $0;
   $0 = $0 + 12 | 0;
   HEAP32[$1 >> 2] = HEAP32[HEAP32[$0 >> 2] + 4 >> 2];
   $0 = HEAP32[$2 + 12 >> 2];
   break label$1;
  }
  HEAP32[$1 >> 2] = 0;
  $0 = $0 + 8 | 0;
 }
 return HEAP32[$0 >> 2];
}

function getIntArg($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 if (($1 | 0) < HEAP32[$0 >> 2]) {
  HEAP32[$0 + 4 >> 2] = $1 + 1;
  $2 = sqlite3_value_int64(HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2]);
  $3 = i64toi32_i32$HIGH_BITS;
 }
 i64toi32_i32$HIGH_BITS = $3;
 return $2;
}

function walIndexPage($0, $1, $2) {
 var $3 = 0, $4 = 0;
 label$1: {
  if (HEAP32[$0 + 24 >> 2] > ($1 | 0)) {
   $4 = HEAP32[HEAP32[$0 + 32 >> 2] + ($1 << 2) >> 2];
   HEAP32[$2 >> 2] = $4;
   $3 = 0;
   if ($4) {
    break label$1;
   }
  }
  $3 = walIndexPageRealloc($0, $1, $2);
 }
 return $3;
}

function unixModeBit($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$2 >> 2];
 if (($3 | 0) < 0) {
  HEAP32[$2 >> 2] = (HEAPU16[$0 + 18 >> 1] & $1) != 0;
  return;
 }
 if (!$3) {
  HEAP16[$0 + 18 >> 1] = HEAPU16[$0 + 18 >> 1] & ($1 ^ -1);
  return;
 }
 HEAP16[$0 + 18 >> 1] = HEAPU16[$0 + 18 >> 1] | $1;
}

function sqlite3ShadowTableName($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = strrchr($1, 95);
 if (!$2) {
  return 0;
 }
 HEAP8[$2 | 0] = 0;
 $3 = sqlite3FindTable($0, $1, 0);
 HEAP8[$2 | 0] = 95;
 if (!(!$3 | HEAPU8[$3 + 43 | 0] != 1)) {
  $4 = sqlite3IsShadowTableOf($0, $3, $1);
 }
 return $4;
}

function sqlite3FunctionSearch($0, $1) {
 $0 = ($0 << 2) + 70768 | 0;
 while (1) {
  label$2: {
   $0 = HEAP32[$0 >> 2];
   if (!$0) {
    break label$2;
   }
   if (!sqlite3StrICmp(HEAP32[$0 + 32 >> 2], $1)) {
    break label$2;
   }
   $0 = $0 + 36 | 0;
   continue;
  }
  break;
 }
 return $0;
}

function upper_quartileFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  HEAPF64[$1 + 24 >> 3] = (+(__wasm_i64_mul(HEAP32[$1 + 16 >> 2], HEAP32[$1 + 20 >> 2], 3, 0) >>> 0) + +(i64toi32_i32$HIGH_BITS | 0) * 4294967296) * .25;
  _medianFinalize($0);
 }
}

function vdbeMemClearExternAndSetNull($0) {
 var $1 = 0;
 $1 = HEAP16[$0 + 16 >> 1];
 if (($1 | 0) < 0) {
  sqlite3VdbeMemFinalize($0, HEAP32[$0 >> 2]);
  $1 = HEAPU16[$0 + 16 >> 1];
 }
 if ($1 & 4096) {
  FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]](HEAP32[$0 + 8 >> 2]);
 }
 HEAP16[$0 + 16 >> 1] = 1;
}

function sqlite3LocateCollSeq($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $2 = HEAP32[$0 >> 2];
 $3 = HEAPU8[$2 + 84 | 0];
 $4 = HEAPU8[$2 + 177 | 0];
 $2 = sqlite3FindCollSeq($2, $3, $1, $4);
 if (!((HEAP32[$2 + 12 >> 2] ? $2 : 0) | $4)) {
  $2 = sqlite3GetCollSeq($0, $3, $2, $1);
 }
 return $2;
}

function percent_rankStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 24);
 if ($0) {
  $1 = HEAP32[$0 + 20 >> 2];
  $2 = HEAP32[$0 + 16 >> 2] + 1 | 0;
  $1 = $2 ? $1 : $1 + 1 | 0;
  HEAP32[$0 + 16 >> 2] = $2;
  HEAP32[$0 + 20 >> 2] = $1;
 }
}

function gatherSelectWindows($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 64;
 HEAP32[$1 + 4 >> 2] = 65;
 HEAP32[$1 + 24 >> 2] = $0;
 HEAP32[$1 >> 2] = 0;
 sqlite3WalkSelect($1, $0);
 __stack_pointer = $1 + 32 | 0;
}

function fts3auxCloseMethod($0) {
 $0 = $0 | 0;
 sqlite3Fts3SegmentsClose(HEAP32[HEAP32[$0 >> 2] + 12 >> 2]);
 sqlite3Fts3SegReaderFinish($0 + 4 | 0);
 sqlite3_free(HEAP32[$0 + 60 >> 2]);
 sqlite3_free(HEAP32[$0 + 76 >> 2]);
 sqlite3_free(HEAP32[$0 + 112 >> 2]);
 sqlite3_free($0);
 return 0;
}

function freeIndexInfo($0, $1) {
 var $2 = 0, $3 = 0, $4 = 0;
 $4 = $1 + 92 | 0;
 while (1) {
  if (($2 | 0) < HEAP32[$1 >> 2]) {
   $3 = ($2 << 2) + $4 | 0;
   sqlite3ValueFree(HEAP32[$3 >> 2]);
   HEAP32[$3 >> 2] = 0;
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 sqlite3DbFree($0, $1);
}

function errlogFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 $1 = sqlite3_value_int(HEAP32[$2 >> 2]);
 HEAP32[$0 >> 2] = sqlite3_value_text(HEAP32[$2 + 4 >> 2]);
 sqlite3_log($1, 8342, $0);
 __stack_pointer = $0 + 16 | 0;
}

function sqlite3VtabUnlockList($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 408 >> 2];
 if ($1) {
  HEAP32[$0 + 408 >> 2] = 0;
  sqlite3ExpirePreparedStatements($0, 0);
  while (1) {
   $0 = HEAP32[$1 + 24 >> 2];
   sqlite3VtabUnlock($1);
   $1 = $0;
   if ($0) {
    continue;
   }
   break;
  }
 }
}

function sqlite3VdbeDeletePriorOpcode($0) {
 var $1 = 0;
 label$1: {
  $1 = HEAP32[$0 + 108 >> 2];
  if (($1 | 0) <= 0) {
   break label$1;
  }
  $1 = $1 - 1 | 0;
  if (HEAPU8[HEAP32[$0 + 104 >> 2] + Math_imul($1, 20) | 0] != 87) {
   break label$1;
  }
  sqlite3VdbeChangeToNoop($0, $1);
 }
}

function walFramePgno($0, $1) {
 var $2 = 0;
 $0 = HEAP32[$0 + 32 >> 2];
 $2 = walFramePage($1);
 label$1: {
  if (!$2) {
   $1 = (HEAP32[$0 >> 2] + ($1 << 2) | 0) + 132 | 0;
   break label$1;
  }
  $1 = HEAP32[($2 << 2) + $0 >> 2] + (($1 + 33 & 4095) << 2) | 0;
 }
 return HEAP32[$1 >> 2];
}

function sqlite3_compileoption_get($0) {
 var $1 = 0, $2 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 sqlite3CompileOptions($1 + 12 | 0);
 __stack_pointer = $1 + 16 | 0;
 $2 = ($0 | 0) < 0 | HEAP32[$1 + 12 >> 2] <= ($0 | 0) ? $2 : HEAP32[($0 << 2) + 55232 >> 2];
 return $2;
}

function sqlite3VdbeError($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 sqlite3DbFree(HEAP32[$0 >> 2], HEAP32[$0 + 124 >> 2]);
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP32[$0 + 124 >> 2] = sqlite3VMPrintf(HEAP32[$0 >> 2], $1, $2);
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3CloseSavepoints($0) {
 var $1 = 0;
 while (1) {
  $1 = HEAP32[$0 + 488 >> 2];
  if ($1) {
   HEAP32[$0 + 488 >> 2] = HEAP32[$1 + 24 >> 2];
   sqlite3DbFree($0, $1);
   continue;
  }
  break;
 }
 HEAP8[$0 + 93 | 0] = 0;
 HEAP32[$0 + 500 >> 2] = 0;
 HEAP32[$0 + 504 >> 2] = 0;
}

function selectWindowRewriteSelectCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 24 >> 2];
 $3 = HEAP32[$2 + 16 >> 2];
 if (($3 | 0) == ($1 | 0)) {
  return 0;
 }
 HEAP32[$2 + 16 >> 2] = $1;
 sqlite3WalkSelect($0, $1);
 HEAP32[$2 + 16 >> 2] = $3;
 return 1;
}

function cume_distStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 24);
 if ($0) {
  $1 = HEAP32[$0 + 20 >> 2];
  $2 = HEAP32[$0 + 16 >> 2] + 1 | 0;
  $1 = $2 ? $1 : $1 + 1 | 0;
  HEAP32[$0 + 16 >> 2] = $2;
  HEAP32[$0 + 20 >> 2] = $1;
 }
}

function sqlite3PagerDontWrite($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  $1 = HEAP32[$0 + 20 >> 2];
  if (HEAPU8[$1 + 12 | 0]) {
   break label$1;
  }
  $2 = HEAPU16[$0 + 28 >> 1];
  if (HEAP32[$1 + 104 >> 2] | !($2 & 2)) {
   break label$1;
  }
  HEAP16[$0 + 28 >> 1] = $2 & 65515 | 16;
 }
}

function fts3ColumnlistCount($0) {
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
 $1 = HEAP32[$0 >> 2];
 while (1) {
  $2 = HEAPU8[$1 | 0];
  if ($2 & 254 | $3) {
   $1 = $1 + 1 | 0;
   $3 = $2 & 128;
   $4 = !($3 >>> 7 | 0) + $4 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 >> 2] = $1;
 return $4;
}

function sqlite3_str_append($0, $1, $2) {
 var $3 = 0, $4 = 0;
 $3 = HEAP32[$0 + 16 >> 2];
 $4 = $3 + $2 | 0;
 if ($4 >>> 0 >= HEAPU32[$0 + 8 >> 2]) {
  enlargeAndAppend($0, $1, $2);
  return;
 }
 if ($2) {
  HEAP32[$0 + 16 >> 2] = $4;
  __memcpy(HEAP32[$0 + 4 >> 2] + $3 | 0, $1, $2);
 }
}

function sqlite3JsonTableFunctions($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 while (1) {
  if (!($2 >>> 0 > 1 | $1)) {
   $1 = $2 << 3;
   $1 = sqlite3_create_module($0, HEAP32[$1 + 55200 >> 2], HEAP32[$1 + 55204 >> 2], 0);
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
 return $1 | 0;
}

function jsonAppendSeparator($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  $2 = HEAP32[$0 + 20 >> 2];
  $1 = HEAP32[$0 + 16 >> 2];
  if (!($2 | $1)) {
   break label$1;
  }
  if ((HEAPU8[($1 + HEAP32[$0 + 4 >> 2] | 0) - 1 | 0] & 223) == 91) {
   break label$1;
  }
  jsonAppendChar($0, 44);
 }
}

function initMemArray($0, $1, $2, $3) {
 var $4 = 0;
 if (($1 | 0) > 0) {
  while (1) {
   HEAP32[$0 + 24 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = $2;
   HEAP16[$0 + 16 >> 1] = $3;
   $0 = $0 + 40 | 0;
   $4 = $1 >>> 0 > 1;
   $1 = $1 - 1 | 0;
   if ($4) {
    continue;
   }
   break;
  }
 }
}

function vdbeSortSubtaskCleanup($0, $1) {
 sqlite3DbFree($0, HEAP32[$1 + 12 >> 2]);
 vdbeSorterRecordFree(0, HEAP32[$1 + 16 >> 2]);
 $0 = HEAP32[$1 + 40 >> 2];
 if ($0) {
  sqlite3OsCloseFree($0);
 }
 $0 = HEAP32[$1 + 56 >> 2];
 if ($0) {
  sqlite3OsCloseFree($0);
 }
 memset($1, 0, 72);
}

function sqlite3PreferredTableName($0) {
 var $1 = 0;
 label$1: {
  if (sqlite3_strnicmp($0, 17751, 7)) {
   break label$1;
  }
  $1 = $0 + 7 | 0;
  if (!sqlite3StrICmp($1, 8697)) {
   return 17656;
  }
  if (sqlite3StrICmp($1, 8678)) {
   break label$1;
  }
  $0 = 17637;
 }
 return $0;
}

function sqlite3FixSrcList($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 80 | 0;
 __stack_pointer = $2;
 if ($1) {
  $3 = memset($2, 0, 76);
  HEAP32[$3 + 32 >> 2] = $1;
  $1 = sqlite3WalkSelect($0 + 4 | 0, $3);
 } else {
  $1 = 0;
 }
 __stack_pointer = $2 + 80 | 0;
 return $1;
}

function shr($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if ($1 >>> 0 <= 31) {
   $3 = HEAP32[$0 + 4 >> 2];
   $2 = $0;
   break label$1;
  }
  $1 = $1 - 32 | 0;
  $2 = $0 + 4 | 0;
 }
 $2 = HEAP32[$2 >> 2];
 HEAP32[$0 + 4 >> 2] = $3 >>> $1;
 HEAP32[$0 >> 2] = $3 << 32 - $1 | $2 >>> $1;
}

function sqlite3VtabImportErrmsg($0, $1) {
 var $2 = 0;
 if (HEAP32[$1 + 8 >> 2]) {
  $2 = HEAP32[$0 >> 2];
  sqlite3DbFree($2, HEAP32[$0 + 124 >> 2]);
  HEAP32[$0 + 124 >> 2] = sqlite3DbStrDup($2, HEAP32[$1 + 8 >> 2]);
  sqlite3_free(HEAP32[$1 + 8 >> 2]);
  HEAP32[$1 + 8 >> 2] = 0;
 }
}

function setSectorSize($0) {
 var $1 = 0;
 $1 = 512;
 label$1: {
  if (HEAPU8[$0 + 12 | 0]) {
   break label$1;
  }
  if (sqlite3OsDeviceCharacteristics(HEAP32[$0 + 64 >> 2]) & 4096) {
   break label$1;
  }
  $1 = sqlite3SectorSize(HEAP32[$0 + 64 >> 2]);
 }
 HEAP32[$0 + 156 >> 2] = $1;
}

function jsonIs4Hex($0) {
 var $1 = 0, $2 = 0, $3 = 0;
 $2 = 1;
 label$1: {
  while (1) {
   if (($1 | 0) == 4) {
    break label$1;
   }
   $3 = $0 + $1 | 0;
   $1 = $1 + 1 | 0;
   if (HEAPU8[HEAPU8[$3 | 0] + 30288 | 0] & 8) {
    continue;
   }
   break;
  }
  $2 = 0;
 }
 return $2;
}

function sqlite3VectorFieldSubexpr($0, $1) {
 if (sqlite3ExprIsVector($0)) {
  if (HEAPU8[$0 | 0] != 138 & HEAPU8[$0 + 2 | 0] != 138) {
   $0 = $0 + 20 | 0;
  } else {
   $0 = HEAP32[$0 + 20 >> 2] + 28 | 0;
  }
  $0 = HEAP32[(HEAP32[$0 >> 2] + ($1 << 4) | 0) + 8 >> 2];
 }
 return $0;
}

function sqlite3Fts3FreeDeferredTokens($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 28 >> 2];
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 + 8 >> 2];
   fts3PendingListDelete(HEAP32[$1 + 12 >> 2]);
   sqlite3_free($1);
   $1 = $2;
   continue;
  }
  break;
 }
 HEAP32[$0 + 28 >> 2] = 0;
}

function dupedExprStructSize($0, $1) {
 var $2 = 0;
 $2 = 52;
 label$1: {
  if (HEAP8[$0 + 7 | 0] & 1 | (!$1 | HEAPU8[$0 | 0] == 178)) {
   break label$1;
  }
  $2 = 16412;
  if (HEAP32[$0 + 12 >> 2]) {
   break label$1;
  }
  $2 = HEAP32[$0 + 20 >> 2] ? 16412 : 65548;
 }
 return $2;
}

function dupedExprNodeSize($0, $1) {
 $1 = dupedExprStructSize($0, $1) & 4095;
 label$1: {
  if (HEAPU8[$0 + 5 | 0] & 8) {
   break label$1;
  }
  $0 = HEAP32[$0 + 8 >> 2];
  if (!$0) {
   break label$1;
  }
  $1 = ((strlen($0) & 1073741823) + $1 | 0) + 1 | 0;
 }
 return $1 + 7 & -8;
}

function vdbeSorterCompareTail($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = HEAP32[$0 + 12 >> 2];
 if (!HEAP32[$1 >> 2]) {
  sqlite3VdbeRecordUnpack(HEAP32[HEAP32[$0 + 8 >> 2] + 28 >> 2], $5, $4, $6);
  HEAP32[$1 >> 2] = 1;
 }
 return sqlite3VdbeRecordCompareWithSkip($3, $2, $6, 1);
}

function analyzeWindowKeyword($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = $0;
 $0 = 59;
 if ((getToken($1 + 12 | 0) | 0) == 59) {
  $0 = (getToken($1 + 12 | 0) | 0) == 24 ? 164 : 59;
 }
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function sqlite3ReadOnlyShadowTables($0) {
 var $1 = 0;
 label$1: {
  if (!(HEAP32[$0 + 196 >> 2] | (HEAP32[$0 + 400 >> 2] | !(HEAPU8[$0 + 35 | 0] & 16)))) {
   $1 = 1;
   if (HEAP32[$0 + 404 >> 2] | HEAP32[$0 + 380 >> 2] <= 0) {
    break label$1;
   }
  }
  $1 = 0;
 }
 return $1;
}

function sqlite3CodeVerifySchemaAtToplevel($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  $2 = HEAP32[$0 + 84 >> 2];
  $3 = 1 << $1;
  if ($2 & $3) {
   break label$1;
  }
  HEAP32[$0 + 84 >> 2] = $2 | $3;
  if (($1 | 0) != 1) {
   break label$1;
  }
  sqlite3OpenTempDatabase($0);
 }
}

function shl($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if ($1 >>> 0 <= 31) {
   $3 = HEAP32[$0 >> 2];
   $2 = $0 + 4 | 0;
   break label$1;
  }
  $1 = $1 - 32 | 0;
  $2 = $0;
 }
 $2 = HEAP32[$2 >> 2];
 HEAP32[$0 >> 2] = $3 << $1;
 HEAP32[$0 + 4 >> 2] = $2 << $1 | $3 >>> 32 - $1;
}

function fts3StrHash($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 if (($1 | 0) <= 0) {
  $1 = strlen($0);
 }
 while (1) {
  if (($1 | 0) > 0) {
   $1 = $1 - 1 | 0;
   $2 = HEAP8[$0 | 0] ^ $2 << 3 ^ $2;
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 return $2 & 2147483647;
}

function find_mapping($0, $1) {
 var $2 = 0;
 $2 = HEAP32[17774];
 if ($2) {
  while (1) {
   if (HEAP32[$2 >> 2] == ($0 | 0)) {
    return $2;
   }
   if ($1) {
    HEAP32[$1 >> 2] = $2;
   }
   $2 = HEAP32[$2 + 36 >> 2];
   if ($2) {
    continue;
   }
   break;
  }
 }
 return 0;
}

function __wasi_fd_is_valid($0) {
 var $1 = 0;
 $1 = __stack_pointer - 32 | 0;
 __stack_pointer = $1;
 $0 = __wasi_fd_fdstat_get($0 | 0, $1 + 8 | 0) | 0;
 if ($0) {
  HEAP32[__errno_location() >> 2] = $0;
  $0 = 0;
 } else {
  $0 = 1;
 }
 __stack_pointer = $1 + 32 | 0;
 return $0;
}

function sqlite3TransferBindings($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  if (($2 | 0) < HEAP16[$0 + 16 >> 1]) {
   $3 = Math_imul($2, 40);
   sqlite3VdbeMemMove($3 + HEAP32[$1 + 100 >> 2] | 0, HEAP32[$0 + 100 >> 2] + $3 | 0);
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
}

function sqlite3ExprListCheckLength($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (!(!$1 | HEAP32[$1 >> 2] <= HEAP32[HEAP32[$0 >> 2] + 128 >> 2])) {
  HEAP32[$3 >> 2] = $2;
  sqlite3ErrorMsg($0, 6188, $3);
 }
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3ClearOnOrUsing($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = HEAP32[$1 >> 2];
  if ($2) {
   sqlite3ExprDeleteNN($0, $2);
   return;
  }
  $1 = HEAP32[$1 + 4 >> 2];
  if (!$1) {
   break label$1;
  }
  sqlite3IdListDelete($0, $1);
 }
}

function sqlite3VdbeResolveLabel($0, $1) {
 var $2 = 0;
 $2 = $1 ^ -1;
 $1 = HEAP32[$0 + 12 >> 2];
 if ((HEAP32[$1 + 56 >> 2] + HEAP32[$1 + 60 >> 2] | 0) < 0) {
  resizeResolveLabel($1, $0, $2);
  return;
 }
 HEAP32[HEAP32[$1 + 64 >> 2] + ($2 << 2) >> 2] = HEAP32[$0 + 108 >> 2];
}

function returnSingleInt($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = $1;
 HEAP32[$3 + 12 >> 2] = $2;
 sqlite3VdbeAddOp4Dup8($0, 72, 1, $3 + 8 | 0, -13);
 sqlite3VdbeAddOp2($0, 84, 1, 1);
 __stack_pointer = $3 + 16 | 0;
}

function renumberCursorsCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = HEAPU8[$1 | 0];
 if (!(($2 | 0) != 179 & ($2 | 0) != 167)) {
  renumberCursorDoMapping($0, $1 + 28 | 0);
 }
 if (HEAP8[$1 + 4 | 0] & 1) {
  renumberCursorDoMapping($0, $1 + 36 | 0);
 }
 return 0;
}

function pcache1PinPage($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 28 >> 2];
 HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 24 >> 2];
 HEAP32[HEAP32[$0 + 24 >> 2] + 28 >> 2] = $1;
 HEAP32[$0 + 24 >> 2] = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 44 >> 2] = HEAP32[$1 + 44 >> 2] - 1;
 return $0;
}

function sqlite3WithDelete($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 if ($1) {
  while (1) {
   if (($2 | 0) < HEAP32[$1 >> 2]) {
    cteClear($0, (Math_imul($2, 24) + $1 | 0) + 12 | 0);
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFree($0, $1);
 }
}

function sqlite3BtreeCheckpoint($0, $1, $2, $3) {
 var $4 = 0, $5 = 0;
 if (!$0) {
  return 0;
 }
 $4 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 $5 = 6;
 if (!HEAPU8[$4 + 20 | 0]) {
  $5 = sqlite3PagerCheckpoint(HEAP32[$4 >> 2], HEAP32[$0 >> 2], $1, $2, $3);
 }
 return $5;
}

function row_numberStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 8);
 if ($0) {
  $1 = HEAP32[$0 + 4 >> 2];
  $2 = HEAP32[$0 >> 2] + 1 | 0;
  $1 = $2 ? $1 : $1 + 1 | 0;
  HEAP32[$0 >> 2] = $2;
  HEAP32[$0 + 4 >> 2] = $1;
 }
}

function sqlite3VdbeAppendP4($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 >> 2];
 if (HEAPU8[$3 + 87 | 0]) {
  freeP4($3, $2, $1);
  return;
 }
 $0 = (HEAP32[$0 + 104 >> 2] + Math_imul(HEAP32[$0 + 108 >> 2], 20) | 0) - 20 | 0;
 HEAP32[$0 + 16 >> 2] = $1;
 HEAP8[$0 + 1 | 0] = $2;
}

function sqlite3TriggerSelectStep($0, $1, $2, $3) {
 var $4 = 0;
 $4 = sqlite3DbMallocZero($0, 48, 0);
 if (!$4) {
  sqlite3SelectDelete($0, $1);
  return $4;
 }
 HEAP32[$4 + 8 >> 2] = $1;
 HEAP16[$4 >> 1] = 2954;
 HEAP32[$4 + 36 >> 2] = triggerSpanDup($0, $2, $3);
 return $4;
}

function sqlite3SrcItemColumnUsed($0, $1) {
 if (HEAPU8[$0 + 38 | 0] & 32) {
  $1 = HEAP32[HEAP32[$0 + 20 >> 2] + 28 >> 2] + ($1 << 4) | 0;
  $0 = $1 + 17 | 0;
  $1 = HEAPU8[$1 + 17 | 0] | HEAPU8[$1 + 18 | 0] << 8 | 64;
  HEAP8[$0 | 0] = $1;
  HEAP8[$0 + 1 | 0] = $1 >>> 8;
 }
}

function sqlite3SelectAddTypeInfo($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 32 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 74;
 HEAP32[$2 + 8 >> 2] = 50;
 HEAP32[$2 + 4 >> 2] = 71;
 HEAP32[$2 >> 2] = $0;
 sqlite3WalkSelect($2, $1);
 __stack_pointer = $2 + 32 | 0;
}

function sqlite3RenameTokenRemap($0, $1, $2) {
 $0 = $0 + 268 | 0;
 while (1) {
  label$2: {
   $0 = HEAP32[$0 >> 2];
   if ($0) {
    if (HEAP32[$0 >> 2] != ($2 | 0)) {
     break label$2;
    }
    HEAP32[$0 >> 2] = $1;
   }
   return;
  }
  $0 = $0 + 12 | 0;
  continue;
 }
}

function sqlite3PcacheFetchFinish($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$2 + 4 >> 2];
 if (!HEAP32[$3 >> 2]) {
  return pcacheFetchFinishWithInit($0, $1, $2);
 }
 HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
 HEAP16[$3 + 30 >> 1] = HEAPU16[$3 + 30 >> 1] + 1;
 return $3;
}

function sqlite3FreeIndex($0, $1) {
 sqlite3ExprDelete($0, HEAP32[$1 + 36 >> 2]);
 sqlite3ExprListDelete($0, HEAP32[$1 + 40 >> 2]);
 sqlite3DbFree($0, HEAP32[$1 + 16 >> 2]);
 if (HEAPU8[$1 + 55 | 0] & 16) {
  sqlite3DbFree($0, HEAP32[$1 + 32 >> 2]);
 }
 sqlite3DbFree($0, $1);
}

function renameFixQuotes($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $1;
 sqlite3NestedParse($0, 27991, $3);
 if (!$2) {
  sqlite3NestedParse($0, 28138, 0);
 }
 __stack_pointer = $3 + 16 | 0;
}

function jsonQuoteFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = __stack_pointer - 128 | 0;
 __stack_pointer = $1;
 jsonInit($1, $0);
 jsonAppendValue($1, HEAP32[$2 >> 2]);
 jsonResult($1);
 sqlite3_result_subtype($0, 74);
 __stack_pointer = $1 + 128 | 0;
}

function cannotBeFunction($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 if (HEAPU8[$1 + 37 | 0] & 4) {
  HEAP32[$2 >> 2] = HEAP32[$1 + 8 >> 2];
  sqlite3ErrorMsg($0, 9918, $2);
  $3 = 1;
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function whereUndoExprMods($0) {
 var $1 = 0;
 while (1) {
  $1 = HEAP32[$0 + 68 >> 2];
  if ($1) {
   HEAP32[$0 + 68 >> 2] = HEAP32[$1 >> 2];
   __memcpy(HEAP32[$1 + 4 >> 2], $1 + 8 | 0, 52);
   sqlite3DbFree(HEAP32[HEAP32[$0 >> 2] >> 2], $1);
   continue;
  }
  break;
 }
}

function walIndexWriteHdr($0) {
 var $1 = 0, $2 = 0;
 $2 = walIndexHdr($0);
 HEAP32[$0 + 52 >> 2] = 3007e3;
 HEAP8[$0 - -64 | 0] = 1;
 $1 = $0 + 52 | 0;
 walChecksumBytes(1, $1, 40, 0, $0 + 92 | 0);
 __memcpy($2 + 48 | 0, $1, 48);
 walShmBarrier($0);
 __memcpy($2, $1, 48);
}

function transferParseError($0, $1) {
 if (!HEAP32[$0 + 36 >> 2]) {
  HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
  HEAP32[$0 + 36 >> 2] = HEAP32[$1 + 36 >> 2];
  HEAP32[$0 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
  return;
 }
 sqlite3DbFree(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
}

function sqlite3StrIHash($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  while (1) {
   $1 = HEAPU8[$0 | 0];
   if (!$1) {
    break label$1;
   }
   $0 = $0 + 1 | 0;
   $2 = HEAPU8[$1 + 29904 | 0] + $2 | 0;
   continue;
  }
 }
 return $2 & 255;
}

function preserveExpr($0, $1) {
 var $2 = 0;
 $2 = sqlite3DbMallocRaw(HEAP32[$0 + 24 >> 2], 60, 0);
 if ($2) {
  $0 = HEAP32[$0 + 20 >> 2];
  HEAP32[$2 >> 2] = HEAP32[$0 + 68 >> 2];
  HEAP32[$0 + 68 >> 2] = $2;
  HEAP32[$2 + 4 >> 2] = $1;
  __memcpy($2 + 8 | 0, $1, 52);
 }
}

function minMaxValueFinalize($0, $1) {
 var $2 = 0;
 label$1: {
  $2 = sqlite3_aggregate_context($0, 0);
  if (!$2) {
   break label$1;
  }
  if (HEAPU16[$2 + 16 >> 1]) {
   sqlite3_result_value($0, $2);
  }
  if ($1) {
   break label$1;
  }
  sqlite3VdbeMemRelease($2);
 }
}

function addAggInfoColumn($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$1 + 28 >> 2] = sqlite3ArrayAllocate($0, HEAP32[$1 + 28 >> 2], $1 + 32 | 0, $2 + 12 | 0);
 __stack_pointer = $2 + 16 | 0;
 $1 = HEAP32[$2 + 12 >> 2];
 return $1;
}

function walBusyLock($0, $1, $2, $3, $4) {
 var $5 = 0;
 label$1: {
  while (1) {
   $5 = walLockExclusive($0, $3, $4);
   if (!$1 | ($5 | 0) != 5) {
    break label$1;
   }
   if (FUNCTION_TABLE[$1 | 0]($2) | 0) {
    continue;
   }
   break;
  }
  $5 = 5;
 }
 return $5;
}

function sqlite3_value_pointer($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$1 | (HEAPU16[$0 + 16 >> 1] & 4031) != 2561 | HEAPU8[$0 + 19 | 0] != 112) {
   break label$1;
  }
  if (strcmp(HEAP32[$0 >> 2], $1)) {
   break label$1;
  }
  $2 = HEAP32[$0 + 8 >> 2];
 }
 return $2;
}

function sqlite3_create_function_v2($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 $8 = $8 | 0;
 return createFunctionApi($0, $1, $2, $3, $4, $5, $6, $7, 0, 0, $8) | 0;
}

function sqlite3WhereOrderByLimitOptLabel($0) {
 var $1 = 0;
 if (HEAPU8[$0 + 52 | 0] & 4) {
  $1 = $0 + 32 | 0;
  $0 = Math_imul(HEAPU8[$0 + 48 | 0], 96) + $0 | 0;
  $0 = HEAP32[$0 + 728 >> 2] ? $1 : $0 + 688 | 0;
 } else {
  $0 = $0 + 32 | 0;
 }
 return HEAP32[$0 >> 2];
}

function percent_rankInvFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 24);
 $1 = HEAP32[$0 + 12 >> 2];
 $2 = HEAP32[$0 + 8 >> 2] + 1 | 0;
 $1 = $2 ? $1 : $1 + 1 | 0;
 HEAP32[$0 + 8 >> 2] = $2;
 HEAP32[$0 + 12 >> 2] = $1;
}

function heightOfExprList($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  while (1) {
   if (HEAP32[$0 >> 2] <= ($2 | 0)) {
    break label$1;
   }
   heightOfExpr(HEAP32[(($2 << 4) + $0 | 0) + 8 >> 2], $1);
   $2 = $2 + 1 | 0;
   continue;
  }
 }
}

function addAggInfoFunc($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$1 + 40 >> 2] = sqlite3ArrayAllocate($0, HEAP32[$1 + 40 >> 2], $1 + 44 | 0, $2 + 12 | 0);
 __stack_pointer = $2 + 16 | 0;
 $1 = HEAP32[$2 + 12 >> 2];
 return $1;
}

function whereRangeAdjust($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = HEAP16[$0 + 8 >> 1];
  if (($2 | 0) <= 0) {
   $1 = $1 + $2 | 0;
   break label$1;
  }
  $1 = HEAPU8[$0 + 10 | 0] & 128 ? $1 : $1 - 20 | 0;
 }
 return $1 << 16 >> 16;
}

function indexColumnNotNull($0, $1) {
 var $2 = 0;
 $1 = HEAPU16[HEAP32[$0 + 4 >> 2] + ($1 << 1) >> 1];
 $2 = $1 << 16 >> 16;
 if (($2 | 0) >= 0) {
  return HEAPU8[(HEAP32[HEAP32[$0 + 12 >> 2] + 4 >> 2] + Math_imul($1, 12) | 0) + 4 | 0] & 15;
 }
 return ($2 | 0) == -1;
}

function cume_distValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  sqlite3_result_double($0, (+HEAPU32[$1 + 8 >> 2] + +HEAP32[$1 + 12 >> 2] * 4294967296) / (+HEAPU32[$1 + 16 >> 2] + +HEAP32[$1 + 20 >> 2] * 4294967296));
 }
}

function ptrmapPageno($0, $1) {
 var $2 = 0;
 if ($1 >>> 0 >= 2) {
  $1 = $1 - 2 | 0;
  $1 = $1 - (($1 >>> 0) % ((HEAPU32[$0 + 40 >> 2] / 5 | 0) + 1 >>> 0) | 0) | 0;
  $2 = $1 + (($1 + 1 | 0) == (HEAPU32[16232] / HEAPU32[$0 + 36 >> 2] | 0) ? 3 : 2) | 0;
 }
 return $2;
}

function fts3TreeFinishNode($0, $1, $2, $3) {
 var $4 = 0, $5 = 0, $6 = 0;
 $6 = HEAP32[$0 + 36 >> 2];
 $4 = sqlite3Fts3VarintLen($2, $3);
 $5 = 10 - $4 | 0;
 HEAP8[$6 + $5 | 0] = $1;
 sqlite3Fts3PutVarint((HEAP32[$0 + 36 >> 2] - $4 | 0) + 11 | 0, $2, $3);
 return $5;
}

function cume_distInvFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 24);
 $1 = HEAP32[$0 + 12 >> 2];
 $2 = HEAP32[$0 + 8 >> 2] + 1 | 0;
 $1 = $2 ? $1 : $1 + 1 | 0;
 HEAP32[$0 + 8 >> 2] = $2;
 HEAP32[$0 + 12 >> 2] = $1;
}

function sqlite3VdbeAddOp4Int($0, $1, $2, $3, $4, $5) {
 $4 = sqlite3VdbeAddOp3($0, $1, $2, $3, $4);
 if (!HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
  $0 = HEAP32[$0 + 104 >> 2] + Math_imul($4, 20) | 0;
  HEAP32[$0 + 16 >> 2] = $5;
  HEAP8[$0 + 1 | 0] = 253;
 }
 return $4;
}

function sqlite3GetTempReg($0) {
 var $1 = 0;
 $1 = HEAPU8[$0 + 19 | 0];
 if (!$1) {
  $1 = HEAP32[$0 + 44 >> 2] + 1 | 0;
  HEAP32[$0 + 44 >> 2] = $1;
  return $1;
 }
 $1 = $1 - 1 | 0;
 HEAP8[$0 + 19 | 0] = $1;
 return HEAP32[((($1 & 255) << 2) + $0 | 0) + 152 >> 2];
}

function transferJoinMarkings($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $2 = HEAP32[$1 + 4 >> 2] & 3;
  if (!$2) {
   break label$1;
  }
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | $2;
  HEAP32[$0 + 36 >> 2] = HEAP32[$1 + 36 >> 2];
 }
}

function sqlite3ExprCodeFactorable($0, $1, $2) {
 label$1: {
  if (!HEAPU8[$0 + 23 | 0]) {
   break label$1;
  }
  if (!sqlite3ExprIsConstantNotJoin($1)) {
   break label$1;
  }
  sqlite3ExprCodeRunJustOnce($0, $1, $2);
  return;
 }
 sqlite3ExprCodeCopy($0, $1, $2);
}

function sqlite3BtreeSecureDelete($0, $1) {
 var $2 = 0;
 if (!$0) {
  return 0;
 }
 sqlite3BtreeEnter($0);
 $2 = HEAP32[$0 + 4 >> 2];
 $0 = HEAPU16[$2 + 24 >> 1];
 if (($1 | 0) >= 0) {
  $0 = $0 & -13 | $1 << 2;
  HEAP16[$2 + 24 >> 1] = $0;
 }
 return $0 >>> 2 & 3;
}

function ntileInvFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 24);
 $1 = HEAP32[$0 + 20 >> 2];
 $2 = HEAP32[$0 + 16 >> 2] + 1 | 0;
 $1 = $2 ? $1 : $1 + 1 | 0;
 HEAP32[$0 + 16 >> 2] = $2;
 HEAP32[$0 + 20 >> 2] = $1;
}

function identLength($0) {
 var $1 = 0, $2 = 0;
 while (1) {
  $2 = HEAPU8[$0 | 0];
  label$2: {
   if (($2 | 0) != 34) {
    if ($2) {
     break label$2;
    }
    return $1 + 2 | 0;
   }
   $1 = $1 + 1 | 0;
  }
  $0 = $0 + 1 | 0;
  $1 = $1 + 1 | 0;
  continue;
 }
}

function sqlite3VdbeRealValue($0) {
 var $1 = 0;
 $1 = HEAPU16[$0 + 16 >> 1];
 if ($1 & 8) {
  return HEAPF64[$0 >> 3];
 }
 if ($1 & 36) {
  return +HEAPU32[$0 >> 2] + +HEAP32[$0 + 4 >> 2] * 4294967296;
 }
 if (!($1 & 18)) {
  return 0;
 }
 return memRealValue($0);
}

function sqlite3PcacheClearSyncFlags($0) {
 var $1 = 0;
 $1 = $0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if ($1) {
   HEAP16[$1 + 28 >> 1] = HEAPU16[$1 + 28 >> 1] & 65527;
   $1 = $1 + 32 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 4 >> 2];
}

function sqlite3Expr($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = $2;
 HEAP32[$3 + 12 >> 2] = sqlite3Strlen30($2);
 $2 = sqlite3ExprAlloc($0, $1, $3 + 8 | 0, 0);
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function fts3DocidRange($0, $1, $2) {
 label$1: {
  if (!$0) {
   break label$1;
  }
  if ((sqlite3_value_numeric_type($0) | 0) != 1) {
   break label$1;
  }
  $1 = sqlite3_value_int64($0);
  $2 = i64toi32_i32$HIGH_BITS;
 }
 i64toi32_i32$HIGH_BITS = $2;
 return $1;
}

function sqlite3SchemaToIndex($0, $1) {
 var $2 = 0, $3 = 0;
 if (!$1) {
  return -32768;
 }
 $2 = HEAP32[$0 + 16 >> 2];
 while (1) {
  $0 = $3;
  $3 = $0 + 1 | 0;
  if (HEAP32[(($0 << 4) + $2 | 0) + 12 >> 2] != ($1 | 0)) {
   continue;
  }
  break;
 }
 return $0;
}

function sqlite3PcacheDrop($0) {
 var $1 = 0;
 if (HEAPU8[$0 + 28 | 0] & 2) {
  pcacheManageDirtyList($0, 1);
 }
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] - 1;
 FUNCTION_TABLE[HEAP32[16101]](HEAP32[$1 + 44 >> 2], HEAP32[$0 >> 2], 1);
}

function sqlite3PcacheClearWritable($0) {
 var $1 = 0;
 $1 = $0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if ($1) {
   HEAP16[$1 + 28 >> 1] = HEAPU16[$1 + 28 >> 1] & 65523;
   $1 = $1 + 32 | 0;
   continue;
  }
  break;
 }
 HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 4 >> 2];
}

function sqlite3BtreeSchema($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 $0 = HEAP32[$3 + 52 >> 2];
 if (!($0 | !$1)) {
  $0 = sqlite3DbMallocZero(0, $1, 0);
  HEAP32[$3 + 56 >> 2] = $2;
  HEAP32[$3 + 52 >> 2] = $0;
 }
 return $0;
}

function sqlite3TableLock($0, $1, $2, $3, $4) {
 label$1: {
  if (($1 | 0) == 1) {
   break label$1;
  }
  if (!sqlite3BtreeSharable(HEAP32[(HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + ($1 << 4) | 0) + 4 >> 2])) {
   break label$1;
  }
  lockTable($0, $1, $2, $3, $4);
 }
}

function sqlite3SubselectError($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (!HEAP32[$0 + 36 >> 2]) {
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 >> 2] = $1;
  sqlite3ErrorMsg($0, 16733, $3);
 }
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3ParseObjectInit($0, $1) {
 memset($0 + 4 | 0, 0, 148);
 memset($0 + 196 | 0, 0, 76);
 HEAP32[$0 + 184 >> 2] = HEAP32[$1 + 264 >> 2];
 HEAP32[$1 + 264 >> 2] = $0;
 HEAP32[$0 >> 2] = $1;
 if (HEAPU8[$1 + 87 | 0]) {
  sqlite3ErrorMsg($0, 1141, 0);
 }
}

function read32bits($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 $0 = sqlite3OsRead($0, $4 + 12 | 0, 4, $1, $2);
 if (!$0) {
  HEAP32[$3 >> 2] = sqlite3Get4byte($4 + 12 | 0);
 }
 __stack_pointer = $4 + 16 | 0;
 return $0;
}

function blobGrowBuffer($0, $1, $2) {
 var $3 = 0;
 if (!(HEAP32[$2 >> 2] | HEAP32[$0 + 8 >> 2] >= ($1 | 0))) {
  $3 = sqlite3_realloc(HEAP32[$0 >> 2], $1);
  if ($3) {
   HEAP32[$0 >> 2] = $3;
   HEAP32[$0 + 8 >> 2] = $1;
   return;
  }
  HEAP32[$2 >> 2] = 7;
 }
}

function sqlite3WindowUnlinkFromSelect($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 32 >> 2];
 if ($1) {
  HEAP32[$1 >> 2] = HEAP32[$0 + 36 >> 2];
  $1 = HEAP32[$0 + 36 >> 2];
  if ($1) {
   HEAP32[$1 + 32 >> 2] = HEAP32[$0 + 32 >> 2];
  }
  HEAP32[$0 + 32 >> 2] = 0;
 }
}

function sqlite3ReportError($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 8 >> 2] = 22492;
 HEAP32[$3 + 4 >> 2] = $1;
 HEAP32[$3 >> 2] = $2;
 sqlite3_log($0, 17783, $3);
 __stack_pointer = $3 + 16 | 0;
 return $0;
}

function sqlite3ErrorIfNotEmpty($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 8 >> 2] = $2;
 HEAP32[$4 + 4 >> 2] = $1;
 HEAP32[$4 >> 2] = $3;
 sqlite3NestedParse($0, 28317, $4);
 __stack_pointer = $4 + 16 | 0;
}

function yyStackOverflow($0) {
 var $1 = 0, $2 = 0;
 $2 = $0 + 8 | 0;
 $1 = HEAP32[$0 + 4 >> 2];
 while (1) {
  if ($2 >>> 0 < HEAPU32[$0 >> 2]) {
   yy_pop_parser_stack($0);
   continue;
  }
  break;
 }
 sqlite3ErrorMsg($1, 1669, 0);
 HEAP32[$0 + 4 >> 2] = $1;
}

function sqlite3_series_init($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 if (!(!$1 | (sqlite3_libversion_number() | 0) > 3008011)) {
  HEAP32[$1 >> 2] = sqlite3_mprintf(8841, 0);
  return 1;
 }
 return sqlite3_create_module($0, 5558, 70272, 0) | 0;
}

function sqlite3WindowOffsetExpr($0, $1) {
 if (!sqlite3ExprIsConstant($1)) {
  if (HEAPU8[$0 + 208 | 0] >= 2) {
   sqlite3RenameExprUnmap($0, $1);
  }
  sqlite3ExprDelete(HEAP32[$0 >> 2], $1);
  $1 = sqlite3ExprAlloc(HEAP32[$0 >> 2], 121, 0, 0);
 }
 return $1;
}

function accessPayloadChecked($0, $1, $2, $3) {
 var $4 = 0;
 $4 = 4;
 label$1: {
  if (HEAPU8[$0 | 0] == 1) {
   break label$1;
  }
  $4 = btreeRestoreCursorPosition($0);
  if ($4) {
   break label$1;
  }
  $4 = accessPayload($0, $1, $2, $3, 0);
 }
 return $4;
}

function sqlite3BtreeLockTable($0, $1, $2) {
 var $3 = 0;
 if (!HEAPU8[$0 + 9 | 0]) {
  return 0;
 }
 sqlite3BtreeEnter($0);
 $3 = $2 + 1 & 255;
 $2 = querySharedCacheTableLock($0, $1, $3);
 if (!$2) {
  $2 = setSharedCacheTableLock($0, $1, $3);
 }
 return $2;
}

function setDateTimeToCurrent($0, $1) {
 var $2 = 0;
 $2 = sqlite3StmtCurrentTime($0);
 HEAP32[$1 >> 2] = $2;
 $0 = i64toi32_i32$HIGH_BITS;
 HEAP32[$1 + 4 >> 2] = $0;
 if (!$2 & ($0 | 0) <= 0 | ($0 | 0) < 0) {
  return 1;
 }
 HEAP8[$1 + 40 | 0] = 1;
 return 0;
}

function changeTempStorage($0, $1) {
 var $2 = 0;
 label$1: {
  $1 = getTempStore($1);
  $2 = HEAP32[$0 >> 2];
  if (($1 | 0) == HEAPU8[$2 + 86 | 0]) {
   break label$1;
  }
  if (invalidateTempStorage($0)) {
   break label$1;
  }
  HEAP8[$2 + 86 | 0] = $1;
 }
}

function sqlite3VdbeMemSetRowSet($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 sqlite3VdbeMemRelease($0);
 $1 = sqlite3RowSetInit($1);
 if (!$1) {
  return 7;
 }
 HEAP32[$0 + 36 >> 2] = 25;
 HEAP16[$0 + 16 >> 1] = 4112;
 HEAP32[$0 + 8 >> 2] = $1;
 return 0;
}

function sqlite3IdListDelete($0, $1) {
 var $2 = 0;
 if ($1) {
  while (1) {
   if (($2 | 0) < HEAP32[$1 >> 2]) {
    sqlite3DbFree($0, HEAP32[(($2 << 3) + $1 | 0) + 8 >> 2]);
    $2 = $2 + 1 | 0;
    continue;
   }
   break;
  }
  sqlite3DbFreeNN($0, $1);
 }
}

function sqlite3BeginWriteOperation($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 116 >> 2];
 $0 = $3 ? $3 : $0;
 sqlite3CodeVerifySchemaAtToplevel($0, $2);
 HEAP32[$0 + 80 >> 2] = HEAP32[$0 + 80 >> 2] | 1 << $2;
 HEAP8[$0 + 20 | 0] = HEAPU8[$0 + 20 | 0] | $1;
}

function signFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 if (sqlite3_value_numeric_type(HEAP32[$2 >> 2]) - 3 >>> 0 >= 4294967294) {
  $3 = sqlite3_value_double(HEAP32[$2 >> 2]);
  sqlite3_result_int($0, $3 < 0 ? -1 : $3 > 0);
 }
}

function pageReinit($0) {
 $0 = $0 | 0;
 var $1 = 0;
 label$1: {
  $1 = sqlite3PagerGetExtra($0);
  if (!HEAPU8[$1 | 0]) {
   break label$1;
  }
  HEAP8[$1 | 0] = 0;
  if ((sqlite3PagerPageRefcount($0) | 0) < 2) {
   break label$1;
  }
  btreeInitPage($1);
 }
}

function memdbFullPathname($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 >> 2] = $1;
 sqlite3_snprintf($2, $3, 8342, $0);
 __stack_pointer = $0 + 16 | 0;
 return 0;
}

function sqlite3PcacheMove($0, $1) {
 FUNCTION_TABLE[HEAP32[16102]](HEAP32[HEAP32[$0 + 12 >> 2] + 44 >> 2], HEAP32[$0 >> 2], HEAP32[$0 + 24 >> 2], $1);
 HEAP32[$0 + 24 >> 2] = $1;
 if ((HEAPU16[$0 + 28 >> 1] & 10) == 10) {
  pcacheManageDirtyList($0, 3);
 }
}

function sqlite3EndTransaction($0, $1) {
 label$1: {
  $1 = ($1 | 0) == 12;
  if (sqlite3AuthCheck($0, 22, $1 ? 19686 : 18313, 0, 0)) {
   break label$1;
  }
  $0 = sqlite3GetVdbe($0);
  if (!$0) {
   break label$1;
  }
  sqlite3VdbeAddOp2($0, 1, 1, $1);
 }
}

function sqlite3VdbeMemTooBig($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAPU16[$0 + 16 >> 1];
 if (!($2 & 18)) {
  return 0;
 }
 $1 = HEAP32[$0 + 12 >> 2];
 $1 = $2 & 1024 ? HEAP32[$0 >> 2] + $1 | 0 : $1;
 return ($1 | 0) > HEAP32[HEAP32[$0 + 20 >> 2] + 120 >> 2];
}

function copyPayload($0, $1, $2, $3, $4) {
 label$1: {
  label$2: {
   if ($3) {
    $3 = sqlite3PagerWrite($4);
    if ($3) {
     break label$1;
    }
    __memcpy($0, $1, $2);
    break label$2;
   }
   __memcpy($1, $0, $2);
  }
  $3 = 0;
 }
 return $3;
}

function addSpaceSeparator($0) {
 var $1 = 0;
 label$1: {
  $1 = HEAP32[$0 + 16 >> 2];
  if (!$1) {
   break label$1;
  }
  if (!sqlite3IsIdChar(HEAPU8[(HEAP32[$0 + 4 >> 2] + $1 | 0) - 1 | 0])) {
   break label$1;
  }
  sqlite3_str_append($0, 29598, 1);
 }
}

function sqlite3ReleaseTempReg($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = HEAPU8[$0 + 19 | 0];
  if ($2 >>> 0 > 7) {
   break label$1;
  }
  HEAP8[$0 + 19 | 0] = $2 + 1;
  HEAP32[(($2 << 2) + $0 | 0) + 152 >> 2] = $1;
 }
}

function sqlite3ExprAddCollateString($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 sqlite3TokenInit($3 + 8 | 0, $2);
 $2 = sqlite3ExprAddCollateToken($0, $1, $3 + 8 | 0, 0);
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function markTermAsChild($0, $1, $2) {
 $0 = HEAP32[$0 + 24 >> 2];
 $1 = $0 + Math_imul($1, 48) | 0;
 HEAP32[$1 + 16 >> 2] = $2;
 $2 = Math_imul($2, 48) + $0 | 0;
 HEAP16[$1 + 8 >> 1] = HEAPU16[$2 + 8 >> 1];
 HEAP8[$2 + 14 | 0] = HEAPU8[$2 + 14 | 0] + 1;
}

function isConsonant($0) {
 var $1 = 0;
 $1 = HEAP8[$0 | 0];
 if (!$1) {
  return 0;
 }
 $1 = $1 - 97 | 0;
 if (($1 | 0) != 24) {
  return HEAP8[$1 + 54784 | 0];
 }
 $1 = 1;
 if (HEAPU8[$0 + 1 | 0]) {
  $1 = (isVowel($0 + 1 | 0) | 0) != 0;
 }
 return $1;
}

function pagerSyncHotJournal($0) {
 var $1 = 0;
 label$1: {
  if (!HEAPU8[$0 + 7 | 0]) {
   $1 = sqlite3OsSync(HEAP32[$0 + 68 >> 2], 2);
   if ($1) {
    break label$1;
   }
  }
  $1 = sqlite3OsFileSize(HEAP32[$0 + 68 >> 2], $0 + 88 | 0);
 }
 return $1;
}

function sqlite3PutVarint($0, $1, $2) {
 if (!$2 & $1 >>> 0 <= 127) {
  HEAP8[$0 | 0] = $1;
  return 1;
 }
 if (!$2 & $1 >>> 0 <= 16383) {
  HEAP8[$0 + 1 | 0] = $1 & 127;
  HEAP8[$0 | 0] = $1 >>> 7 | 128;
  return 2;
 }
 return putVarint64($0, $1, $2);
}

function sqlite3PagerLockingMode($0, $1) {
 label$1: {
  if (HEAPU8[$0 + 12 | 0] | ($1 | 0) < 0) {
   break label$1;
  }
  if (sqlite3WalHeapMemory(HEAP32[$0 + 232 >> 2])) {
   break label$1;
  }
  HEAP8[$0 + 4 | 0] = $1;
 }
 return HEAPU8[$0 + 4 | 0];
}

function seriesRowid($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 44 >> 2];
 $0 = HEAP32[$0 + 40 >> 2];
 $3 = $0 + 1 | 0;
 $0 = $1;
 HEAP32[$0 >> 2] = $3;
 $2 = $3 ? $2 : $2 + 1 | 0;
 HEAP32[$0 + 4 >> 2] = $2;
 return 0;
}

function fts3ClearCursor($0) {
 fts3CursorFinalizeStmt($0);
 sqlite3Fts3FreeDeferredTokens($0);
 sqlite3_free(HEAP32[$0 + 44 >> 2]);
 sqlite3Fts3MIBufferFree(HEAP32[$0 + 92 >> 2]);
 sqlite3Fts3ExprFree(HEAP32[$0 + 16 >> 2]);
 memset($0 + 4 | 0, 0, 92);
}

function sqlite3_str_reset($0) {
 if (HEAPU8[$0 + 21 | 0] & 4) {
  sqlite3DbFree(HEAP32[$0 >> 2], HEAP32[$0 + 4 >> 2]);
  HEAP8[$0 + 21 | 0] = HEAPU8[$0 + 21 | 0] & 251;
 }
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
}

function fts3DoIntegrityCheck($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 $0 = fts3IntegrityCheck($0, $1 + 12 | 0);
 __stack_pointer = $1 + 16 | 0;
 return HEAP32[$1 + 12 >> 2] | $0 ? $0 : 267;
}

function sqlite3_str_value($0) {
 var $1 = 0, $2 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[$0 + 16 >> 2];
  if (!$1) {
   break label$1;
  }
  HEAP8[HEAP32[$0 + 4 >> 2] + $1 | 0] = 0;
  $2 = HEAP32[$0 + 4 >> 2];
 }
 return $2;
}

function sqlite3_overload_function($0, $1, $2) {
 var $3 = 0;
 if (!sqlite3FindFunction($0, $1, $2, 1, 0)) {
  $3 = sqlite3_mprintf($1, 0);
  if (!$3) {
   return 7;
  }
  $3 = sqlite3_create_function_v2($0, $1, $2, 1, $3, 8, 0, 0, 3);
 }
 return $3;
}

function sqlite3_memory_used() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 sqlite3_status64(0, $0 + 8 | 0, $0, 0);
 __stack_pointer = $0 + 16 | 0;
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 12 >> 2];
 return HEAP32[$0 + 8 >> 2];
}

function sqlite3VtabModuleUnref($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 + 8 >> 2] - 1 | 0;
 HEAP32[$1 + 8 >> 2] = $2;
 if (!$2) {
  $2 = HEAP32[$1 + 16 >> 2];
  if ($2) {
   FUNCTION_TABLE[$2 | 0](HEAP32[$1 + 12 >> 2]);
  }
  sqlite3DbFree($0, $1);
 }
}

function sqlite3PcacheDirtyList($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 >> 2];
 $0 = $1;
 while (1) {
  if ($0) {
   $2 = HEAP32[$0 + 32 >> 2];
   HEAP32[$0 + 16 >> 2] = $2;
   $0 = $2;
   continue;
  }
  break;
 }
 return pcacheSortDirtyList($1);
}

function sqlite3BtreeFirst($0, $1) {
 var $2 = 0;
 $2 = moveToRoot($0);
 label$1: {
  if (($2 | 0) != 16) {
   if ($2) {
    break label$1;
   }
   HEAP32[$1 >> 2] = 0;
   return moveToLeftmost($0);
  }
  HEAP32[$1 >> 2] = 1;
  $2 = 0;
 }
 return $2;
}

function sleep($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 HEAP32[$1 + 4 >> 2] = 0;
 HEAP32[$1 + 8 >> 2] = 0;
 $0 = nanosleep($1);
 __stack_pointer = $1 + 16 | 0;
 return $0 ? HEAP32[$1 >> 2] : 0;
}

function fts3GrowSegReaderBuffer($0, $1) {
 if (HEAP32[$0 + 20 >> 2] < ($1 | 0)) {
  $1 = $1 << 1;
  HEAP32[$0 + 20 >> 2] = $1;
  $1 = sqlite3_realloc(HEAP32[$0 + 16 >> 2], $1);
  if (!$1) {
   return 7;
  }
  HEAP32[$0 + 16 >> 2] = $1;
 }
 return 0;
}

function vdbeMemClear($0) {
 if (HEAPU8[$0 + 17 | 0] & 144) {
  vdbeMemClearExternAndSetNull($0);
 }
 if (HEAP32[$0 + 24 >> 2]) {
  sqlite3DbFreeNN(HEAP32[$0 + 20 >> 2], HEAP32[$0 + 32 >> 2]);
  HEAP32[$0 + 24 >> 2] = 0;
 }
 HEAP32[$0 + 8 >> 2] = 0;
}

function sqlite3_mprintf($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 if (!sqlite3_initialize()) {
  HEAP32[$2 + 12 >> 2] = $1;
  $3 = sqlite3_vmprintf($0, $1);
 }
 __stack_pointer = $2 + 16 | 0;
 return $3;
}

function sqlite3Fts3VarintLen($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  $2 = $2 + 1 | 0;
  $3 = !$1 & $0 >>> 0 > 127 | ($1 | 0) != 0;
  $0 = ($1 & 127) << 25 | $0 >>> 7;
  $1 = $1 >>> 7 | 0;
  if ($3) {
   continue;
  }
  break;
 }
 return $2;
}

function whereNthSubterm($0, $1) {
 var $2 = 0;
 if (HEAPU16[$0 + 12 >> 1] != 1024) {
  return $1 ? 0 : $0;
 }
 $0 = HEAP32[$0 + 24 >> 2];
 if (HEAP32[$0 + 12 >> 2] > ($1 | 0)) {
  $2 = HEAP32[$0 + 24 >> 2] + Math_imul($1, 48) | 0;
 }
 return $2;
}

function star_oh($0) {
 var $1 = 0;
 label$1: {
  if (!isConsonant($0) | (HEAPU8[$0 | 0] - 119 & 255) >>> 0 < 3) {
   break label$1;
  }
  if (!isVowel($0 + 1 | 0)) {
   break label$1;
  }
  $1 = (isConsonant($0 + 2 | 0) | 0) != 0;
 }
 return $1;
}

function sqlite3ErrorToParser($0, $1) {
 label$1: {
  if (!$0) {
   break label$1;
  }
  $0 = HEAP32[$0 + 264 >> 2];
  if (!$0) {
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = $1;
  HEAP32[$0 + 36 >> 2] = HEAP32[$0 + 36 >> 2] + 1;
 }
 return $1;
}

function sqlite3DbStrDup($0, $1) {
 var $2 = 0, $3 = 0;
 label$1: {
  if (!$1) {
   break label$1;
  }
  $2 = strlen($1) + 1 | 0;
  $0 = sqlite3DbMallocRaw($0, $2, 0);
  if (!$0) {
   break label$1;
  }
  $3 = __memcpy($0, $1, $2);
 }
 return $3;
}

function fts3ShadowName($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 while (1) {
  if (($1 | 0) == 5) {
   return 0;
  }
  $2 = $1 << 2;
  $1 = $1 + 1 | 0;
  if (sqlite3_stricmp($0, HEAP32[$2 + 55072 >> 2])) {
   continue;
  }
  break;
 }
 return 1;
}

function fetchPayload($0, $1) {
 var $2 = 0, $3 = 0;
 $3 = HEAP32[$0 + 40 >> 2];
 $2 = HEAP32[HEAP32[$0 + 116 >> 2] + 60 >> 2] - $3 | 0;
 $0 = HEAPU16[$0 + 48 >> 1];
 HEAP32[$1 >> 2] = ($0 | 0) > ($2 | 0) ? ($2 | 0) > 0 ? $2 : 0 : $0;
 return $3;
}

function sqlite3Fts3ErrMsg($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 sqlite3_free(HEAP32[$0 >> 2]);
 HEAP32[$3 + 12 >> 2] = $2;
 HEAP32[$0 >> 2] = sqlite3_vmprintf($1, $2);
 __stack_pointer = $3 + 16 | 0;
}

function jsonWrongNumArgs($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 >> 2] = $1;
 $1 = sqlite3_mprintf(3703, $2);
 sqlite3_result_error($0, $1, -1);
 sqlite3_free($1);
 __stack_pointer = $2 + 16 | 0;
}

function sqlite3ColumnType($0, $1) {
 if (HEAPU8[$0 + 10 | 0] & 4) {
  $0 = HEAP32[$0 >> 2];
  return ($0 + strlen($0) | 0) + 1 | 0;
 }
 $0 = HEAPU8[$0 + 4 | 0];
 if ($0 >>> 0 >= 16) {
  $1 = HEAP32[($0 >>> 2 & 60) + 65324 >> 2];
 }
 return $1;
}

function last_valueValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0;
 label$1: {
  $1 = sqlite3_aggregate_context($0, 0);
  if (!$1) {
   break label$1;
  }
  $1 = HEAP32[$1 >> 2];
  if (!$1) {
   break label$1;
  }
  sqlite3_result_value($0, $1);
 }
}

function btreeParseCellPtrNoPayload($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $1 = sqlite3GetVarint($1 + 4 | 0, $2);
 HEAP16[$2 + 16 >> 1] = 0;
 HEAP32[$2 + 8 >> 2] = 0;
 HEAP32[$2 + 12 >> 2] = 0;
 HEAP16[$2 + 18 >> 1] = $1 + 4;
}

function sqlite3StatusUp($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = $0 << 2;
 $0 = $2 + 70376 | 0;
 $3 = $0;
 $0 = HEAP32[$0 >> 2] + $1 | 0;
 HEAP32[$3 >> 2] = $0;
 $1 = $2 + 70416 | 0;
 if (HEAPU32[$1 >> 2] < $0 >>> 0) {
  HEAP32[$1 >> 2] = $0;
 }
}

function sqlite3Fts3HashFindElem($0, $1, $2) {
 var $3 = 0;
 if (!(!$0 | !HEAP32[$0 + 16 >> 2])) {
  $3 = fts3FindElementByHash($0, $1, $2, FUNCTION_TABLE[ftsHashFunction(HEAP8[$0 | 0]) | 0]($1, $2) & HEAP32[$0 + 12 >> 2] - 1);
 }
 return $3;
}

function sqlite3ExpirePreparedStatements($0, $1) {
 $0 = $0 + 4 | 0;
 $1 = $1 + 1 & 3;
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if ($0) {
   HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] & 252 | $1;
   $0 = $0 + 8 | 0;
   continue;
  }
  break;
 }
}

function sqlite3CheckCollSeq($0, $1) {
 label$1: {
  if (HEAP32[$1 + 12 >> 2] | !$1) {
   break label$1;
  }
  if (sqlite3GetCollSeq($0, HEAPU8[HEAP32[$0 >> 2] + 84 | 0], $1, HEAP32[$1 >> 2])) {
   break label$1;
  }
  return 1;
 }
 return 0;
}

function binaryToUnaryIfNull($0, $1, $2, $3) {
 if (!(!$1 | !$2 | HEAPU8[$1 | 0] != 121 | HEAPU8[$0 + 208 | 0] > 1)) {
  $1 = HEAP32[$0 >> 2];
  HEAP8[$2 | 0] = $3;
  sqlite3ExprDelete($1, HEAP32[$2 + 16 >> 2]);
  HEAP32[$2 + 16 >> 2] = 0;
 }
}

function legalstub$dynCall_iiiiiij($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 return dynCall_iiiiiij($0, $1, $2, $3, $4, $5, $6, $7) | 0;
}

function fts3SegReaderTermCmp($0, $1, $2) {
 var $3 = 0;
 if (!HEAP32[$0 + 40 >> 2]) {
  return 0;
 }
 $3 = HEAP32[$0 + 64 >> 2];
 $0 = HEAP32[$0 + 60 >> 2];
 $1 = memcmp($3, $1, ($0 | 0) < ($2 | 0) ? $0 : $2);
 return $1 ? $1 : $0 - $2 | 0;
}

function fts3ExprPhraseCount($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 fts3ExprIterate($0, 110, $1 + 12 | 0);
 __stack_pointer = $1 + 16 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 return $0;
}

function fts3ExprLoadDoclistsCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + 1;
 HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$0 + 64 >> 2];
 return 0;
}

function sqlite3_bind_double($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = +$2;
 var $3 = 0;
 $3 = vdbeUnbind($0, $1);
 if (!$3) {
  sqlite3VdbeMemSetDouble((HEAP32[$0 + 100 >> 2] + Math_imul($1, 40) | 0) - 40 | 0, $2);
 }
 return $3 | 0;
}

function sqlite3KeywordCode($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 + 12 >> 2] = 59;
 keywordCode($0, $1, $2 + 12 | 0);
 __stack_pointer = $2 + 16 | 0;
 $1 = HEAP32[$2 + 12 >> 2];
 return $1;
}

function sqlite3Fts3FreeDeferredDoclists($0) {
 $0 = $0 + 28 | 0;
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if ($0) {
   fts3PendingListDelete(HEAP32[$0 + 12 >> 2]);
   HEAP32[$0 + 12 >> 2] = 0;
   $0 = $0 + 8 | 0;
   continue;
  }
  break;
 }
}

function sqlite3WalDefaultHook($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 if (($0 | 0) <= ($3 | 0)) {
  sqlite3BeginBenignMalloc();
  sqlite3_wal_checkpoint($1, $2);
  sqlite3EndBenignMalloc();
 }
 return 0;
}

function sqlite3SelectExprHeight($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 heightOfSelect($0, $1 + 12 | 0);
 __stack_pointer = $1 + 16 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 return $0;
}

function sqlite3PagerExclusiveLock($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 44 >> 2];
 label$1: {
  if ($1) {
   break label$1;
  }
  $1 = 0;
  if (HEAP32[$0 + 232 >> 2]) {
   break label$1;
  }
  $1 = pager_wait_on_lock($0, 4);
 }
 return $1;
}

function memdbFileSize($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 $0 = HEAP32[$2 >> 2];
 $3 = HEAP32[$2 + 4 >> 2];
 $2 = $0;
 $0 = $1;
 HEAP32[$0 >> 2] = $2;
 HEAP32[$0 + 4 >> 2] = $3;
 return 0;
}

function sqlite3VdbeMemClearAndResize($0, $1) {
 if (HEAP32[$0 + 24 >> 2] < ($1 | 0)) {
  return sqlite3VdbeMemGrow($0, $1, 0);
 }
 HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 32 >> 2];
 HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 45;
 return 0;
}

function getAutoVacuum($0) {
 if (!sqlite3StrICmp($0, 13166)) {
  return 0;
 }
 if (!sqlite3StrICmp($0, 11128)) {
  return 1;
 }
 if (!sqlite3StrICmp($0, 11253)) {
  return 2;
 }
 $0 = sqlite3Atoi($0);
 return $0 >>> 0 < 3 ? $0 & 255 : 0;
}

function fts3BinHash($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 while (1) {
  if (($1 | 0) > 0) {
   $1 = $1 - 1 | 0;
   $2 = HEAP8[$0 | 0] ^ $2 << 3 ^ $2;
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 return $2 & 2147483647;
}

function posixOpen($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 >> 2] = $2;
 $2 = open($0, $1, $3);
 __stack_pointer = $3 + 16 | 0;
 return $2 | 0;
}

function jsonReturnJson($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 128 | 0;
 __stack_pointer = $3;
 jsonInit($3, $1);
 jsonRenderNode($0, $3, $2);
 jsonResult($3);
 sqlite3_result_subtype($1, 74);
 __stack_pointer = $3 + 128 | 0;
}

function computeCellSize($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 $2 = FUNCTION_TABLE[HEAP32[$2 + 76 >> 2]]($2, HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2]) | 0;
 HEAP16[HEAP32[$0 + 12 >> 2] + ($1 << 1) >> 1] = $2;
 return $2;
}

function sqlite3Fts3Matchinfo($0, $1, $2) {
 var $3 = 0;
 if (!HEAP32[$1 + 16 >> 2]) {
  sqlite3_result_blob($0, 29623, 0, 0);
  return;
 }
 $3 = HEAP32[$1 >> 2];
 fts3GetMatchinfo($0, $1, $2 ? $2 : 1559);
 sqlite3Fts3SegmentsClose($3);
}

function robust_ftruncate($0, $1, $2) {
 var $3 = 0;
 while (1) {
  $3 = FUNCTION_TABLE[HEAP32[16255]]($0, $1, $2) | 0;
  if (($3 | 0) < 0) {
   if (HEAP32[__errno_location() >> 2] == 27) {
    continue;
   }
  }
  break;
 }
 return $3;
}

function pager_wait_on_lock($0, $1) {
 var $2 = 0;
 while (1) {
  $2 = pagerLockDb($0, $1);
  if (($2 | 0) == 5) {
   if (FUNCTION_TABLE[HEAP32[$0 + 192 >> 2]](HEAP32[$0 + 196 >> 2]) | 0) {
    continue;
   }
  }
  break;
 }
 return $2;
}

function lower_quartileFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  HEAPF64[$1 + 24 >> 3] = (+HEAPU32[$1 + 16 >> 2] + +HEAP32[$1 + 20 >> 2] * 4294967296) * .25;
  _medianFinalize($0);
 }
}

function __memcpy($0, $1, $2) {
 var $3 = 0;
 if ($2) {
  $3 = $0;
  while (1) {
   HEAP8[$3 | 0] = HEAPU8[$1 | 0];
   $3 = $3 + 1 | 0;
   $1 = $1 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function write32bits($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 sqlite3Put4byte($4 + 12 | 0, $3);
 $3 = sqlite3OsWrite($0, $4 + 12 | 0, 4, $1, $2);
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function sqlite3VdbeChangeEncoding($0, $1) {
 var $2 = 0;
 if (!(HEAPU8[$0 + 16 | 0] & 2)) {
  HEAP8[$0 + 18 | 0] = $1;
  return 0;
 }
 if (HEAPU8[$0 + 18 | 0] != ($1 | 0)) {
  $2 = sqlite3VdbeMemTranslate($0, $1 & 255);
 }
 return $2;
}

function sqlite3PExprAddSelect($0, $1, $2) {
 if ($1) {
  HEAP32[$1 + 20 >> 2] = $2;
  HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 4198400;
  sqlite3ExprSetHeightAndFlags($0, $1);
  return;
 }
 sqlite3SelectDelete(HEAP32[$0 >> 2], $2);
}

function sqlite3AggInfoPersistWalkerInit($0, $1) {
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 50;
 HEAP32[$0 + 4 >> 2] = 76;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
}

function pager_error($0, $1) {
 label$1: {
  switch (($1 & 255) - 10 | 0) {
  case 0:
  case 3:
   HEAP8[$0 + 17 | 0] = 6;
   HEAP32[$0 + 44 >> 2] = $1;
   setGetterMethod($0);
   break;

  default:
   break label$1;
  }
 }
 return $1;
}

function pager_cksum($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 168 >> 2];
 $0 = HEAP32[$0 + 52 >> 2];
 while (1) {
  $2 = $2 - 200 | 0;
  if (($2 | 0) > 0) {
   $0 = HEAPU8[$1 + $2 | 0] + $0 | 0;
   continue;
  }
  break;
 }
 return $0;
}

function sqlite3MemdbInit() {
 var $0 = 0, $1 = 0;
 $0 = sqlite3_vfs_find(0);
 if (!$0) {
  return 1;
 }
 $1 = HEAP32[$0 + 4 >> 2];
 HEAP32[17503] = $0;
 HEAP32[17499] = $1 >>> 0 > 12 ? $1 : 12;
 return sqlite3_vfs_register(69992, 0);
}

function sqlite3DeferForeignKey($0, $1) {
 label$1: {
  $0 = HEAP32[$0 + 236 >> 2];
  if (!$0 | HEAPU8[$0 + 43 | 0]) {
   break label$1;
  }
  $0 = HEAP32[$0 + 48 >> 2];
  if (!$0) {
   break label$1;
  }
  HEAP8[$0 + 24 | 0] = $1;
 }
}

function sqlite3BtreePayloadChecked($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 if (!HEAPU8[$0 | 0]) {
  return accessPayload($0, $1, $2, $3, 0) | 0;
 }
 return accessPayloadChecked($0, $1, $2, $3) | 0;
}

function fts3PrefixCompress($0, $1, $2, $3) {
 var $4 = 0;
 while (1) {
  if (!(($1 | 0) <= ($4 | 0) | ($3 | 0) <= ($4 | 0) | HEAPU8[$0 + $4 | 0] != HEAPU8[$2 + $4 | 0])) {
   $4 = $4 + 1 | 0;
   continue;
  }
  break;
 }
 return $4;
}

function exprToRegister($0, $1) {
 $0 = sqlite3ExprSkipCollateAndLikely($0);
 if ($0) {
  HEAP32[$0 + 28 >> 2] = $1;
  HEAP8[$0 + 2 | 0] = HEAPU8[$0 | 0];
  HEAP8[$0 | 0] = 176;
  HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] & -8193;
 }
}

function sqlite3PrimaryKeyIndex($0) {
 $0 = $0 + 8 | 0;
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if (!(!$0 | ((HEAPU8[$0 + 55 | 0] | HEAPU8[$0 + 56 | 0] << 8) & 3) == 2)) {
   $0 = $0 + 20 | 0;
   continue;
  }
  break;
 }
 return $0;
}

function sqlite3KeyInfoUnref($0) {
 var $1 = 0;
 label$1: {
  if (!$0) {
   break label$1;
  }
  $1 = HEAP32[$0 >> 2] - 1 | 0;
  HEAP32[$0 >> 2] = $1;
  if ($1) {
   break label$1;
  }
  sqlite3DbFreeNN(HEAP32[$0 + 12 >> 2], $0);
 }
}

function getDoubleArg($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 if (($1 | 0) < HEAP32[$0 >> 2]) {
  HEAP32[$0 + 4 >> 2] = $1 + 1;
  $2 = sqlite3_value_double(HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2]);
 }
 return $2;
}

function columnMem($0, $1) {
 var $2 = 0;
 if ($0) {
  $2 = HEAP32[$0 + 120 >> 2];
  if (!(!$2 | HEAPU16[$0 + 144 >> 1] <= $1 >>> 0)) {
   return Math_imul($1, 40) + $2 | 0;
  }
  sqlite3Error(HEAP32[$0 >> 2], 25);
 }
 return 33464;
}

function sqlite3VdbeSetColName($0, $1, $2, $3, $4) {
 if (!HEAPU8[HEAP32[$0 >> 2] + 87 | 0]) {
  sqlite3VdbeMemSetStr(HEAP32[$0 + 116 >> 2] + Math_imul(Math_imul(HEAPU16[$0 + 144 >> 1], $2) + $1 | 0, 40) | 0, $3, -1, -1, 1, $4);
 }
}

function setPendingFd($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 28 >> 2];
 $2 = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$2 + 32 >> 2];
 HEAP32[$2 + 32 >> 2] = $1;
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = -1;
}

function pcache1Shrink($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 if (HEAP32[$0 + 20 >> 2]) {
  $1 = HEAP32[$0 >> 2];
  $2 = HEAP32[$1 + 4 >> 2];
  HEAP32[$1 + 4 >> 2] = 0;
  pcache1EnforceMaxPage($0);
  HEAP32[$1 + 4 >> 2] = $2;
 }
}

function sqlite3GetVdbe($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 if (!$1) {
  if (!(HEAP32[$0 + 116 >> 2] | HEAPU8[HEAP32[$0 >> 2] + 80 | 0] & 8)) {
   HEAP8[$0 + 23 | 0] = 1;
  }
  $1 = sqlite3VdbeCreate($0);
 }
 return $1;
}

function row_numberValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = sqlite3_aggregate_context($0, 8);
 if ($1) {
  $2 = HEAP32[$1 + 4 >> 2];
  $1 = HEAP32[$1 >> 2];
 } else {
  $1 = 0;
 }
 sqlite3_result_int64($0, $1, $2);
}

function hasColumn($0, $1, $2) {
 var $3 = 0;
 while (1) {
  if (($1 | 0) <= 0) {
   return 0;
  }
  $1 = $1 - 1 | 0;
  $3 = HEAP16[$0 >> 1];
  $0 = $0 + 2 | 0;
  if (($2 | 0) != ($3 | 0)) {
   continue;
  }
  break;
 }
 return 1;
}

function fts3PutColNumber($0, $1) {
 var $2 = 0;
 if (!$1) {
  return 0;
 }
 $2 = HEAP32[$0 >> 2];
 $1 = sqlite3Fts3PutVarint($2 + 1 | 0, $1, $1 >> 31);
 HEAP8[$2 | 0] = 1;
 $1 = $1 + 1 | 0;
 HEAP32[$0 >> 2] = $2 + $1;
 return $1;
}

function sqlite3VdbeBooleanValue($0, $1) {
 var $2 = 0;
 $2 = HEAPU16[$0 + 16 >> 1];
 if ($2 & 36) {
  return (HEAP32[$0 >> 2] | HEAP32[$0 + 4 >> 2]) != 0;
 }
 if (!($2 & 1)) {
  $1 = sqlite3VdbeRealValue($0) != 0;
 }
 return $1;
}

function sqlite3SetHasNullFlag($0, $1, $2) {
 var $3 = 0;
 sqlite3VdbeAddOp2($0, 71, 0, $2);
 $3 = sqlite3VdbeAddOp1($0, 35, $1);
 sqlite3VdbeAddOp3($0, 94, $1, 0, $2);
 sqlite3VdbeChangeP5($0, 128);
 sqlite3VdbeJumpHere($0, $3);
}

function sqlite3IsRowid($0) {
 var $1 = 0;
 $1 = 1;
 label$1: {
  if (!sqlite3StrICmp($0, 17775)) {
   break label$1;
  }
  if (!sqlite3StrICmp($0, 19859)) {
   break label$1;
  }
  $1 = !sqlite3StrICmp($0, 19865);
 }
 return $1;
}

function pagerFlushOnCommit($0, $1) {
 var $2 = 0;
 if (!HEAPU8[$0 + 12 | 0]) {
  return 1;
 }
 if (!(!$1 | !HEAP32[HEAP32[$0 + 64 >> 2] >> 2])) {
  $2 = (sqlite3PCachePercentDirty(HEAP32[$0 + 228 >> 2]) | 0) > 24;
 }
 return $2;
}

function btreeGetHasContent($0, $1) {
 var $2 = 0;
 $0 = HEAP32[$0 + 64 >> 2];
 if (!$0) {
  return 0;
 }
 $2 = 1;
 if (sqlite3BitvecSize($0) >>> 0 >= $1 >>> 0) {
  $2 = (sqlite3BitvecTestNotNull($0, $1) | 0) != 0;
 }
 return $2;
}

function sqlite3_result_value($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 >> 2];
 sqlite3VdbeMemCopy($2, $1);
 sqlite3VdbeChangeEncoding($2, HEAPU8[$0 + 24 | 0]);
 if (sqlite3VdbeMemTooBig($2)) {
  sqlite3_result_error_toobig($0);
 }
}

function sqlite3WhereClauseInit($0, $1) {
 HEAP8[$0 + 9 | 0] = 0;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 8;
 HEAP32[$0 + 24 >> 2] = $0 + 32;
}

function sqlite3VdbeSetSql($0, $1, $2, $3) {
 if ($0) {
  HEAP8[$0 + 148 | 0] = $3;
  if ($3 << 24 >> 24 >= 0) {
   HEAP32[$0 + 224 >> 2] = 0;
  }
  HEAP32[$0 + 196 >> 2] = sqlite3DbStrNDup(HEAP32[$0 >> 2], $1, $2, $2 >> 31);
 }
}

function sqlite3Atoi($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 + 12 >> 2] = 0;
 sqlite3GetInt32($0, $1 + 12 | 0);
 __stack_pointer = $1 + 16 | 0;
 $0 = HEAP32[$1 + 12 >> 2];
 return $0;
}

function jsonHexToInt4($0) {
 var $1 = 0;
 $1 = jsonHexToInt(HEAP8[$0 | 0]);
 return (((jsonHexToInt(HEAP8[$0 + 1 | 0]) << 8) + ($1 << 12) | 0) + (jsonHexToInt(HEAP8[$0 + 2 | 0]) << 4) | 0) + jsonHexToInt(HEAP8[$0 + 3 | 0]) | 0;
}

function getTextArg($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 if (($1 | 0) < HEAP32[$0 >> 2]) {
  HEAP32[$0 + 4 >> 2] = $1 + 1;
  $2 = sqlite3_value_text(HEAP32[HEAP32[$0 + 8 >> 2] + ($1 << 2) >> 2]);
 }
 return $2;
}

function unlockBtreeIfUnused($0) {
 var $1 = 0;
 label$1: {
  if (HEAPU8[$0 + 20 | 0]) {
   break label$1;
  }
  $1 = HEAP32[$0 + 12 >> 2];
  if (!$1) {
   break label$1;
  }
  HEAP32[$0 + 12 >> 2] = 0;
  releasePageOne($1);
 }
}

function sqlite3VdbeMemSetPointer($0, $1, $2, $3) {
 vdbeMemClear($0);
 HEAP32[$0 + 36 >> 2] = $3 ? $3 : 2;
 HEAP8[$0 + 19 | 0] = 112;
 HEAP16[$0 + 16 >> 1] = 6657;
 HEAP32[$0 + 8 >> 2] = $1;
 HEAP32[$0 >> 2] = $2 ? $2 : 29623;
}

function medianFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  HEAPF64[$1 + 24 >> 3] = (+HEAPU32[$1 + 16 >> 2] + +HEAP32[$1 + 20 >> 2] * 4294967296) * .5;
  _medianFinalize($0);
 }
}

function unmapColumnIdlistNames($0, $1) {
 var $2 = 0;
 while (1) {
  if (($2 | 0) < HEAP32[$1 >> 2]) {
   sqlite3RenameTokenRemap($0, 0, HEAP32[(($2 << 3) + $1 | 0) + 8 >> 2]);
   $2 = $2 + 1 | 0;
   continue;
  }
  break;
 }
}

function sqlite3Fts3SegReaderFree($0) {
 if ($0) {
  sqlite3_free(HEAP32[$0 + 64 >> 2]);
  if (!HEAPU8[$0 + 5 | 0]) {
   sqlite3_free(HEAP32[$0 + 40 >> 2]);
  }
  sqlite3_blob_close(HEAP32[$0 + 52 >> 2]);
 }
 sqlite3_free($0);
}

function rankValueFunc($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = sqlite3_aggregate_context($0, 24);
 if ($1) {
  sqlite3_result_int64($0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2]);
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
 }
}

function jsonParseFindParents($0) {
 var $1 = 0;
 $1 = sqlite3_malloc64(HEAP32[$0 >> 2] << 2, 0);
 HEAP32[$0 + 16 >> 2] = $1;
 if (!$1) {
  HEAP8[$0 + 20 | 0] = 1;
  return 7;
 }
 jsonParseFillInParentage($0, 0, 0);
 return 0;
}

function fts3ExprIterate($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = 0;
 $2 = fts3ExprIterate2($0, $3 + 12 | 0, $1, $2);
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3PagerReadFileheader($0, $1) {
 var $2 = 0;
 $1 = memset($1, 0, 100);
 $0 = HEAP32[$0 + 64 >> 2];
 if (HEAP32[$0 >> 2]) {
  $2 = sqlite3OsRead($0, $1, 100, 0, 0);
  $2 = ($2 | 0) == 522 ? 0 : $2;
 }
 return $2;
}

function sqlite3OpenSchemaTable($0, $1) {
 var $2 = 0;
 $2 = sqlite3GetVdbe($0);
 sqlite3TableLock($0, $1, 1, 1, 8690);
 sqlite3VdbeAddOp4Int($2, 113, 0, 1, $1, 5);
 if (!HEAP32[$0 + 40 >> 2]) {
  HEAP32[$0 + 40 >> 2] = 1;
 }
}

function sqlite3ForceNotReadOnly($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 44 >> 2] + 1 | 0;
 HEAP32[$0 + 44 >> 2] = $1;
 $0 = sqlite3GetVdbe($0);
 if ($0) {
  sqlite3VdbeAddOp3($0, 4, 0, $1, -1);
  sqlite3VdbeUsesBtree($0, 0);
 }
}

function btreeParseCell($0, $1, $2) {
 $1 = HEAP32[$0 + 64 >> 2] + ($1 << 1) | 0;
 FUNCTION_TABLE[HEAP32[$0 + 80 >> 2]]($0, HEAP32[$0 + 56 >> 2] + (HEAPU16[$0 + 26 >> 1] & (HEAPU8[$1 | 0] << 8 | HEAPU8[$1 + 1 | 0])) | 0, $2);
}

function sqlite3_snprintf($0, $1, $2, $3) {
 var $4 = 0;
 $4 = __stack_pointer - 16 | 0;
 __stack_pointer = $4;
 HEAP32[$4 + 12 >> 2] = $3;
 $3 = sqlite3_vsnprintf($0, $1, $2, $3);
 __stack_pointer = $4 + 16 | 0;
 return $3;
}

function fts3ExprGlobalHitsCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return sqlite3Fts3EvalPhraseStats(HEAP32[$2 >> 2], $0, HEAP32[$2 + 28 >> 2] + Math_imul(Math_imul(HEAP32[$2 + 4 >> 2], $1), 12) | 0) | 0;
}

function countFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  $2 = HEAP32[$1 + 4 >> 2];
  $1 = HEAP32[$1 >> 2];
 } else {
  $1 = 0;
 }
 sqlite3_result_int64($0, $1, $2);
}

function unixClose($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 verifyDbFile($0);
 unixUnlock($0, 0);
 if (HEAP32[$1 + 24 >> 2]) {
  setPendingFd($0);
 }
 releaseInodeInfo($0);
 closeUnixFile($0);
 return 0;
}

function sqlite3VdbeGetOp($0, $1) {
 var $2 = 0;
 $1 = ($1 | 0) < 0 ? HEAP32[$0 + 108 >> 2] - 1 | 0 : $1;
 $2 = 71008;
 $2 = HEAPU8[HEAP32[$0 >> 2] + 87 | 0] ? $2 : HEAP32[$0 + 104 >> 2] + Math_imul($1, 20) | 0;
 return $2;
}

function sqlite3VarintLen($0, $1) {
 var $2 = 0;
 $2 = 1;
 while (1) {
  if (!(!$1 & $0 >>> 0 < 128)) {
   $2 = $2 + 1 | 0;
   $0 = ($1 & 127) << 25 | $0 >>> 7;
   $1 = $1 >>> 7 | 0;
   continue;
  }
  break;
 }
 return $2;
}

function node_destroy($0) {
 var $1 = 0;
 if ($0) {
  xfree(HEAP32[$0 + 8 >> 2]);
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   node_destroy($1);
  }
  $1 = HEAP32[$0 + 4 >> 2];
  if ($1) {
   node_destroy($1);
  }
  xfree($0);
 }
}

function sqlite3WalEndReadTransaction($0) {
 var $1 = 0;
 sqlite3WalEndWriteTransaction($0);
 $1 = HEAP16[$0 + 40 >> 1];
 if (($1 | 0) >= 0) {
  walUnlockShared($0, ($1 & 65535) + 3 | 0);
  HEAP16[$0 + 40 >> 1] = 65535;
 }
}

function sqlite3VdbeMemSetZeroBlob($0, $1) {
 sqlite3VdbeMemRelease($0);
 HEAP16[$0 + 16 >> 1] = 1040;
 HEAP8[$0 + 18 | 0] = 1;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 >> 2] = ($1 | 0) > 0 ? $1 : 0;
}

function out2Prerelease($0, $1) {
 $1 = HEAP32[$0 + 88 >> 2] + Math_imul(HEAP32[$1 + 8 >> 2], 40) | 0;
 if (HEAPU8[$1 + 17 | 0] & 144) {
  out2PrereleaseWithClear($1);
  return $1;
 }
 HEAP16[$1 + 16 >> 1] = 4;
 return $1;
}

function sqlite3VdbeSorterClose($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 + 36 >> 2];
 if ($2) {
  sqlite3VdbeSorterReset($0, $2);
  sqlite3_free(HEAP32[$2 + 40 >> 2]);
  sqlite3DbFree($0, $2);
  HEAP32[$1 + 36 >> 2] = 0;
 }
}

function sqlite3DeleteReturning($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 sqlite3HashInsert(HEAP32[HEAP32[$0 + 16 >> 2] + 28 >> 2] + 40 | 0, 11950, 0);
 sqlite3ExprListDelete($0, HEAP32[$1 + 4 >> 2]);
 sqlite3DbFree($0, $1);
}

function enlargeAndAppend($0, $1, $2) {
 $2 = sqlite3StrAccumEnlarge($0, $2);
 if (($2 | 0) > 0) {
  __memcpy(HEAP32[$0 + 4 >> 2] + HEAP32[$0 + 16 >> 2] | 0, $1, $2);
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + $2;
 }
}

function sqlite3Put4byte($0, $1) {
 $1 = $1 << 8 & 16711680 | $1 << 24 | ($1 >>> 8 & 65280 | $1 >>> 24);
 HEAP8[$0 | 0] = $1;
 HEAP8[$0 + 1 | 0] = $1 >>> 8;
 HEAP8[$0 + 2 | 0] = $1 >>> 16;
 HEAP8[$0 + 3 | 0] = $1 >>> 24;
}

function sqlite3HaltConstraint($0, $1, $2, $3, $4, $5) {
 var $6 = 0;
 $6 = sqlite3GetVdbe($0);
 if (($2 | 0) == 2) {
  sqlite3MayAbort($0);
 }
 sqlite3VdbeAddOp4($6, 70, $1, $2, 0, $3, $4);
 sqlite3VdbeChangeP5($6, $5);
}

function nocaseCollatingFunc($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $4 = sqlite3_strnicmp($2, $4, ($1 | 0) < ($3 | 0) ? $1 : $3);
 return ($4 ? $4 : $1 - $3 | 0) | 0;
}

function __memrchr($0, $1, $2) {
 var $3 = 0;
 $1 = $1 & 255;
 while (1) {
  if (!$2) {
   return 0;
  }
  $2 = $2 - 1 | 0;
  $3 = $2 + $0 | 0;
  if (HEAPU8[$3 | 0] != ($1 | 0)) {
   continue;
  }
  break;
 }
 return $3;
}

function sqlite3_os_init() {
 var $0 = 0;
 while (1) {
  if (($0 | 0) != 4) {
   sqlite3_vfs_register(Math_imul($0, 88) + 64576 | 0, !$0);
   $0 = $0 + 1 | 0;
   continue;
  }
  break;
 }
 unixTempFileInit();
 return 0;
}

function renameUnmapExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = HEAP32[$0 >> 2];
 sqlite3RenameTokenRemap($0, 0, $1);
 if (!(HEAPU8[$1 + 7 | 0] & 3)) {
  sqlite3RenameTokenRemap($0, 0, $1 + 44 | 0);
 }
 return 0;
}

function whereLikeOptimizationStringFixup($0, $1, $2) {
 if (HEAP8[$2 + 11 | 0] & 1) {
  $2 = sqlite3VdbeGetOp($0, -1);
  $1 = HEAP32[$1 + 44 >> 2];
  HEAP16[$2 + 2 >> 1] = $1 & 1;
  HEAP32[$2 + 12 >> 2] = $1 >>> 1;
 }
}

function sqliteDefaultBusyCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 if (HEAP32[$0 + 496 >> 2] >= (Math_imul($1, 1e3) + 1e3 | 0)) {
  sqlite3OsSleep(HEAP32[$0 >> 2], 1e6);
  $2 = 1;
 }
 return $2 | 0;
}

function strHash($0) {
 var $1 = 0, $2 = 0;
 while (1) {
  $1 = HEAPU8[$0 | 0];
  if ($1) {
   $0 = $0 + 1 | 0;
   $2 = Math_imul(HEAPU8[$1 + 29904 | 0] + $2 | 0, -1640531535);
   continue;
  }
  break;
 }
 return $2;
}

function sqlite3_aggregate_context($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 if (HEAP16[$2 + 16 >> 1] >= 0) {
  return createAggContext($0, $1) | 0;
 }
 return HEAP32[$2 + 8 >> 2];
}

function sqlite3VtabEponymousTableClear($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 + 20 >> 2];
 if ($2) {
  HEAP32[$2 + 28 >> 2] = HEAP32[$2 + 28 >> 2] | 16384;
  sqlite3DeleteTable($0, $2);
  HEAP32[$1 + 20 >> 2] = 0;
 }
}

function sqlite3UnlinkAndDeleteTable($0, $1, $2) {
 sqlite3DeleteTable($0, sqlite3HashInsert(HEAP32[(HEAP32[$0 + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] + 8 | 0, $2, 0));
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] | 1;
}

function __wasm_i64_urem($0, $1, $2, $3) {
 _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3);
 i64toi32_i32$HIGH_BITS = __wasm_intrinsics_temp_i64$hi;
 return __wasm_intrinsics_temp_i64;
}

function sqlite3_log($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 if (HEAP32[16127]) {
  HEAP32[$3 + 12 >> 2] = $2;
  renderLogMsg($0, $1, $2);
 }
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3WalSavepoint($0, $1) {
 HEAP32[$1 >> 2] = HEAP32[$0 + 68 >> 2];
 HEAP32[$1 + 4 >> 2] = HEAP32[$0 + 76 >> 2];
 HEAP32[$1 + 8 >> 2] = HEAP32[$0 + 80 >> 2];
 HEAP32[$1 + 12 >> 2] = HEAP32[$0 + 112 >> 2];
}

function sqlite3Fts3InitHashTable($0, $1) {
 var $2 = 0;
 $2 = sqlite3_create_function($0, 8626, 1, 524289, $1, 95, 0, 0);
 if (!$2) {
  $2 = sqlite3_create_function($0, 8626, 2, 524289, $1, 95, 0, 0);
 }
 return $2;
}

function sqlite3TableColumnAffinity($0, $1) {
 var $2 = 0;
 $2 = 68;
 $2 = ($1 | 0) < 0 | HEAP16[$0 + 34 >> 1] <= ($1 | 0) ? $2 : HEAP8[(HEAP32[$0 + 4 >> 2] + Math_imul($1, 12) | 0) + 5 | 0];
 return $2 << 24 >> 24;
}

function sqlite3ReleaseTempRange($0, $1, $2) {
 if (($2 | 0) == 1) {
  sqlite3ReleaseTempReg($0, $1);
  return;
 }
 if (HEAP32[$0 + 28 >> 2] < ($2 | 0)) {
  HEAP32[$0 + 32 >> 2] = $1;
  HEAP32[$0 + 28 >> 2] = $2;
 }
}

function vdbePmaWriteVarint($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 vdbePmaWriteBlob($0, $3 + 6 | 0, sqlite3PutVarint($3 + 6 | 0, $1, $2));
 __stack_pointer = $3 + 16 | 0;
}

function nullifFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 if (sqlite3MemCompare(HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2], sqlite3GetFuncCollSeq($0))) {
  sqlite3_result_value($0, HEAP32[$2 >> 2]);
 }
}

function jsonResult($0) {
 if (!HEAPU8[$0 + 25 | 0]) {
  sqlite3_result_text64(HEAP32[$0 >> 2], HEAP32[$0 + 4 >> 2], HEAP32[$0 + 16 >> 2], HEAP32[$0 + 20 >> 2], HEAPU8[$0 + 24 | 0] ? -1 : 3, 1);
  jsonZero($0);
 }
}

function getLockingMode($0) {
 label$1: {
  if (!$0) {
   break label$1;
  }
  if (!sqlite3StrICmp($0, 12316)) {
   return 1;
  }
  if (sqlite3StrICmp($0, 11288)) {
   break label$1;
  }
  return 0;
 }
 return -1;
}

function gatherSelectWindowsCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (!(!(HEAP8[$1 + 7 | 0] & 1) | HEAPU8[$1 | 0] != 172)) {
  sqlite3WindowLink(HEAP32[$0 + 24 >> 2], HEAP32[$1 + 44 >> 2]);
 }
 return 0;
}

function databaseName($0) {
 var $1 = 0;
 while (1) {
  $1 = $0;
  $0 = $1 - 1 | 0;
  if (HEAPU8[$0 | 0] | HEAPU8[$1 - 2 | 0] | (HEAPU8[$1 - 3 | 0] | HEAPU8[$1 - 4 | 0])) {
   continue;
  }
  break;
 }
 return $1;
}

function sqlite3MPrintf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 $2 = sqlite3VMPrintf($0, $1, $2);
 __stack_pointer = $3 + 16 | 0;
 return $2;
}

function sqlite3ExprIfFalseDup($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 >> 2];
 $1 = sqlite3ExprDup($3, $1, 0);
 if (!HEAPU8[$3 + 87 | 0]) {
  sqlite3ExprIfFalse($0, $1, $2, 16);
 }
 sqlite3ExprDelete($3, $1);
}

function sqlite3CompareAffinity($0, $1) {
 $0 = sqlite3ExprAffinity($0);
 if (!(($1 | 0) < 65 | ($0 | 0) < 65)) {
  return $1 >>> 0 > 66 ? 67 : $0 >>> 0 > 66 ? 67 : 65;
 }
 return (($0 | 0) < 65 ? $1 : $0) | 64;
}

function fts3tokRowidMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $0 = HEAP32[$0 + 12 >> 2];
 $2 = $0 >> 31;
 $3 = $0;
 $0 = $1;
 HEAP32[$0 >> 2] = $3;
 HEAP32[$0 + 4 >> 2] = $2;
 return 0;
}

function closeUnixFile($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 if (($1 | 0) >= 0) {
  robust_close($0, $1, 37571);
  HEAP32[$0 + 12 >> 2] = -1;
 }
 sqlite3_free(HEAP32[$0 + 28 >> 2]);
 memset($0, 0, 52);
}

function sqlite3_result_text64($0, $1, $2, $3, $4, $5) {
 if (!$3 & $2 >>> 0 >= 2147483648 | $3) {
  invokeValueDestructor($1, $4, $0);
  return;
 }
 setResultStrOrError($0, $1, $2, ($5 | 0) == 4 ? 2 : $5, $4);
}

function sqlite3_column_value($0, $1) {
 var $2 = 0;
 $1 = columnMem($0, $1);
 $2 = HEAPU16[$1 + 16 >> 1];
 if ($2 & 8192) {
  HEAP16[$1 + 16 >> 1] = $2 & 40959 | 16384;
 }
 columnMallocFailure($0);
 return $1;
}

function sqlite3_busy_timeout($0, $1) {
 label$1: {
  if (($1 | 0) > 0) {
   sqlite3_busy_handler($0, 7, $0);
   HEAP32[$0 + 496 >> 2] = $1;
   break label$1;
  }
  sqlite3_busy_handler($0, 0, 0);
 }
 return 0;
}

function sqlite3PragmaVtabRegister($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = pragmaLocate($1 + 7 | 0);
 if (!(!$2 | !(HEAPU8[$2 + 5 | 0] & 48))) {
  $3 = sqlite3VtabCreateModule($0, $1, 34448, $2, 0);
 }
 return $3;
}

function sqlite3StrAccumInit($0, $1, $2, $3, $4) {
 HEAP16[$0 + 20 >> 1] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = $4;
 HEAP32[$0 + 8 >> 2] = $3;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = $2;
}

function sqlite3VdbeMemSetInt64($0, $1, $2) {
 if (HEAPU8[$0 + 17 | 0] & 144) {
  vdbeReleaseAndSetInt64($0, $1, $2);
  return;
 }
 HEAP16[$0 + 16 >> 1] = 4;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = $2;
}

function sqlite3IndexAffinityOk($0, $1) {
 var $2 = 0;
 $2 = 1;
 $0 = comparisonAffinity($0);
 if (($0 | 0) >= 66) {
  if (($0 | 0) == 66) {
   return ($1 | 0) == 66;
  }
  $2 = ($1 | 0) > 66;
 }
 return $2;
}

function sqlite3BtreeGetRequestedReserve($0) {
 var $1 = 0;
 sqlite3BtreeEnter($0);
 $1 = sqlite3BtreeGetReserveNoMutex($0);
 $0 = HEAPU8[HEAP32[$0 + 4 >> 2] + 22 | 0];
 return ($0 | 0) < ($1 | 0) ? $1 : $0;
}

function invalidateAllOverflowCache($0) {
 $0 = $0 + 8 | 0;
 while (1) {
  $0 = HEAP32[$0 >> 2];
  if ($0) {
   HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 251;
   $0 = $0 + 24 | 0;
   continue;
  }
  break;
 }
}

function getTempStore($0) {
 var $1 = 0;
 $1 = HEAPU8[$0 | 0] - 48 | 0;
 if (($1 & 255) >>> 0 > 2) {
  if (!sqlite3StrICmp($0, 13448)) {
   return 1;
  }
  $1 = !sqlite3StrICmp($0, 1186) << 1;
 }
 return $1;
}

function attachBackupObject($0) {
 var $1 = 0;
 $1 = sqlite3PagerBackupPtr(sqlite3BtreePager(HEAP32[$0 + 24 >> 2]));
 HEAP32[$0 + 44 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$1 >> 2] = $0;
 HEAP32[$0 + 40 >> 2] = 1;
}

function sqlite3WalBeginReadTransaction($0, $1) {
 var $2 = 0, $3 = 0;
 while (1) {
  $2 = $2 + 1 | 0;
  $3 = walTryBeginRead($0, $1, 0, $2);
  if (($3 | 0) == -1) {
   continue;
  }
  break;
 }
 return $3;
}

function sqlite3RegisterBuiltinFunctions() {
 sqlite3AlterFunctions();
 sqlite3WindowFunctions();
 sqlite3RegisterDateTimeFunctions();
 sqlite3RegisterJsonFunctions();
 sqlite3InsertBuiltinFuncs(65360, 67);
}

function sqlite3Get4byte($0) {
 $0 = HEAPU8[$0 | 0] | HEAPU8[$0 + 1 | 0] << 8 | (HEAPU8[$0 + 2 | 0] << 16 | HEAPU8[$0 + 3 | 0] << 24);
 return $0 << 24 | $0 << 8 & 16711680 | ($0 >>> 8 & 65280 | $0 >>> 24);
}

function renameQuotefixExprCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (!(!(HEAPU8[$1 + 4 | 0] & 128) | HEAPU8[$1 | 0] != 117)) {
  renameTokenFind(HEAP32[$0 >> 2], HEAP32[$0 + 24 >> 2], $1);
 }
 return 0;
}

function fts3isspace($0) {
 var $1 = 0, $2 = 0;
 $2 = $0 - 9 | 0;
 label$1: {
  if ($2 >>> 0 <= 23) {
   $1 = 1;
   if (1 << $2 & 8388631) {
    break label$1;
   }
  }
  $1 = ($0 | 0) == 12;
 }
 return $1;
}

function fts3StartNode($0, $1, $2, $3) {
 HEAP8[HEAP32[$0 >> 2]] = $1;
 if ($2 | $3) {
  $1 = sqlite3Fts3PutVarint(HEAP32[$0 >> 2] + 1 | 0, $2, $3) + 1 | 0;
 } else {
  $1 = 1;
 }
 HEAP32[$0 + 4 >> 2] = $1;
}

function sqlite3_str_appendf($0, $1, $2) {
 var $3 = 0;
 $3 = __stack_pointer - 16 | 0;
 __stack_pointer = $3;
 HEAP32[$3 + 12 >> 2] = $2;
 sqlite3_str_vappendf($0, $1, $2);
 __stack_pointer = $3 + 16 | 0;
}

function sqlite3SafetyCheckSickOrOk($0) {
 var $1 = 0;
 $1 = 1;
 $0 = HEAPU8[$0 + 97 | 0];
 if (!(($0 | 0) == 109 | ($0 | 0) == 118 | ($0 | 0) == 186)) {
  logBadConnection(14484);
  $1 = 0;
 }
 return $1;
}

function sqlite3FtsUnicodeIsdiacritic($0) {
 var $1 = 0;
 if ($0 - 818 >>> 0 >= 4294967246) {
  if ($0 >>> 0 <= 799) {
   return 1 << $0 - 768 & 134389727;
  }
  $1 = 1 << $0 - 800 & 221688;
 }
 return $1;
}

function sqlite3PagerLookup($0, $1) {
 var $2 = 0, $3 = 0;
 $2 = sqlite3PcacheFetch(HEAP32[$0 + 228 >> 2], $1, 0);
 if ($2) {
  $3 = sqlite3PcacheFetchFinish(HEAP32[$0 + 228 >> 2], $1, $2);
 }
 return $3;
}

function __DOUBLE_BITS_5($0) {
 var $1 = 0, $2 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function __DOUBLE_BITS_2($0) {
 var $1 = 0, $2 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function sqlite3_bind_int64($0, $1, $2, $3) {
 var $4 = 0;
 $4 = vdbeUnbind($0, $1);
 if (!$4) {
  sqlite3VdbeMemSetInt64((HEAP32[$0 + 100 >> 2] + Math_imul($1, 40) | 0) - 40 | 0, $2, $3);
 }
 return $4;
}

function sqlite3FindCollSeq($0, $1, $2, $3) {
 if ($2) {
  $2 = findCollSeqEntry($0, $2, $3);
  if (!$2) {
   return 0;
  }
  return (Math_imul($1, 20) + $2 | 0) - 20 | 0;
 }
 return HEAP32[$0 + 8 >> 2];
}

function pagerReleaseMapPage($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 + 128 >> 2] = HEAP32[$1 + 128 >> 2] - 1;
 HEAP32[$0 + 16 >> 2] = HEAP32[$1 + 144 >> 2];
 HEAP32[$1 + 144 >> 2] = $0;
}

function jsonPathSyntaxError($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 $0 = sqlite3_mprintf(27523, $1);
 __stack_pointer = $1 + 16 | 0;
 return $0;
}

function jsonParseReset($0) {
 sqlite3_free(HEAP32[$0 + 8 >> 2]);
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 sqlite3_free(HEAP32[$0 + 16 >> 2]);
 HEAP32[$0 + 16 >> 2] = 0;
}

function sqlite3VectorErrorMsg($0, $1) {
 if (HEAPU8[$1 + 5 | 0] & 16) {
  sqlite3SubselectError($0, HEAP32[HEAP32[HEAP32[$1 + 20 >> 2] + 28 >> 2] >> 2], 1);
  return;
 }
 sqlite3ErrorMsg($0, 14966, 0);
}

function sqlite3ExprCodeCopy($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 >> 2];
 $1 = sqlite3ExprDup($3, $1, 0);
 if (!HEAPU8[$3 + 87 | 0]) {
  sqlite3ExprCode($0, $1, $2);
 }
 sqlite3ExprDelete($3, $1);
}

function memset($0, $1, $2) {
 var $3 = 0;
 if ($2) {
  $3 = $0;
  while (1) {
   HEAP8[$3 | 0] = $1;
   $3 = $3 + 1 | 0;
   $2 = $2 - 1 | 0;
   if ($2) {
    continue;
   }
   break;
  }
 }
 return $0;
}

function fts3SegReaderSetEof($0) {
 if (!HEAPU8[$0 + 5 | 0]) {
  sqlite3_free(HEAP32[$0 + 40 >> 2]);
  sqlite3_blob_close(HEAP32[$0 + 52 >> 2]);
  HEAP32[$0 + 52 >> 2] = 0;
 }
 HEAP32[$0 + 40 >> 2] = 0;
}

function binCollFunc($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $4 = memcmp($2, $4, ($1 | 0) < ($3 | 0) ? $1 : $3);
 return ($4 ? $4 : $1 - $3 | 0) | 0;
}

function __DOUBLE_BITS($0) {
 var $1 = 0, $2 = 0;
 wasm2js_scratch_store_f64(+$0);
 $1 = wasm2js_scratch_load_i32(1) | 0;
 $2 = wasm2js_scratch_load_i32(0) | 0;
 i64toi32_i32$HIGH_BITS = $1;
 return $2;
}

function sqlite3_bind_zeroblob($0, $1, $2) {
 var $3 = 0;
 $3 = vdbeUnbind($0, $1);
 if (!$3) {
  sqlite3VdbeMemSetZeroBlob((HEAP32[$0 + 100 >> 2] + Math_imul($1, 40) | 0) - 40 | 0, $2);
 }
 return $3;
}

function isVowel($0) {
 var $1 = 0;
 $1 = HEAP8[$0 | 0];
 if (!$1) {
  return 0;
 }
 $1 = $1 - 97 | 0;
 if (($1 | 0) != 24) {
  return 1 - HEAP8[$1 + 54784 | 0] | 0;
 }
 return isConsonant($0 + 1 | 0);
}

function compileoptionusedFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $2 = sqlite3_value_text(HEAP32[$2 >> 2]);
 if ($2) {
  sqlite3_result_int($0, sqlite3_compileoption_used($2));
 }
}

function sqlite3Fts3MIBufferFree($0) {
 label$1: {
  if (!$0) {
   break label$1;
  }
  HEAP8[$0 | 0] = 0;
  if (HEAPU8[$0 + 1 | 0] | HEAPU8[$0 + 2 | 0]) {
   break label$1;
  }
  sqlite3_free($0);
 }
}

function sqlite3ExprCompareCollSeq($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 + 4 >> 2] & 1024;
 return sqlite3BinaryCompareCollSeq($0, HEAP32[($2 ? 16 : 12) + $1 >> 2], HEAP32[($2 ? 12 : 16) + $1 >> 2]);
}

function sqlite3DbIsNamed($0, $1, $2) {
 if (!sqlite3StrICmp(HEAP32[HEAP32[$0 + 16 >> 2] + ($1 << 4) >> 2], $2)) {
  return 1;
 }
 $0 = 0;
 if (!$1) {
  $0 = !sqlite3StrICmp(10765, $2);
 }
 return $0;
}

function pcache1Init($0) {
 $0 = $0 | 0;
 memset(70876, 0, 100);
 HEAP32[17732] = 1;
 HEAP32[17722] = 10;
 $0 = HEAP32[16114];
 HEAP32[17733] = !$0;
 HEAP32[17734] = $0 ? 0 : HEAP32[16116];
 return 0;
}

function integrityCheckResultRow($0) {
 var $1 = 0;
 sqlite3VdbeAddOp2($0, 84, 3, 1);
 $1 = sqlite3VdbeAddOp3($0, 49, 1, sqlite3VdbeCurrentAddr($0) + 2 | 0, 1);
 sqlite3VdbeAddOp0($0, 70);
 return $1;
}

function sqlite3VdbeJumpHereOrPopInst($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 108 >> 2];
 if (($2 - 1 | 0) == ($1 | 0)) {
  HEAP32[$0 + 108 >> 2] = $1;
  return;
 }
 sqlite3VdbeChangeP2($0, $1, $2);
}

function sqlite3SelectDestInit($0, $1, $2) {
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = $2;
 HEAP8[$0 | 0] = $1;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
}

function sqlite3GetVTable($0, $1) {
 $1 = $1 + 52 | 0;
 while (1) {
  $1 = HEAP32[$1 >> 2];
  if (!(!$1 | HEAP32[$1 >> 2] == ($0 | 0))) {
   $1 = $1 + 24 | 0;
   continue;
  }
  break;
 }
 return $1;
}

function exprNodeIsDeterministic($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 if (!(HEAPU8[$1 + 6 | 0] & 16 | HEAPU8[$1 | 0] != 172)) {
  HEAP16[$0 + 20 >> 1] = 0;
  $2 = 2;
 }
 return $2 | 0;
}

function sqlite3_str_new($0) {
 var $1 = 0;
 $1 = sqlite3_malloc64(24, 0);
 if (!$1) {
  return 64552;
 }
 $0 = $0 ? HEAP32[$0 + 120 >> 2] : 1e9;
 sqlite3StrAccumInit($1, 0, 0, 0, $0);
 return $1;
}

function sqlite3_column_int64($0, $1) {
 var $2 = 0;
 $1 = sqlite3_value_int64(columnMem($0, $1));
 $2 = i64toi32_i32$HIGH_BITS;
 columnMallocFailure($0);
 i64toi32_i32$HIGH_BITS = $2;
 return $1;
}

function sqlite3StrAccumSetError($0, $1) {
 HEAP8[$0 + 20 | 0] = $1;
 if (HEAP32[$0 + 12 >> 2]) {
  sqlite3_str_reset($0);
 }
 if (($1 | 0) == 18) {
  sqlite3ErrorToParser(HEAP32[$0 >> 2], 18);
 }
}

function setDeviceCharacteristics($0) {
 if (!HEAP32[$0 + 44 >> 2]) {
  if (HEAPU8[$0 + 18 | 0] & 16) {
   HEAP32[$0 + 48 >> 2] = HEAP32[$0 + 48 >> 2] | 4096;
  }
  HEAP32[$0 + 44 >> 2] = 4096;
 }
}

function explainTempTable($0, $1) {
 var $2 = 0;
 $2 = __stack_pointer - 16 | 0;
 __stack_pointer = $2;
 HEAP32[$2 >> 2] = $1;
 sqlite3VdbeExplain($0, 0, 6898, $2);
 __stack_pointer = $2 + 16 | 0;
}

function sqlite3_free($0) {
 $0 = $0 | 0;
 if ($0) {
  if (HEAP32[16068]) {
   sqlite3StatusDown(0, sqlite3MallocSize($0));
   sqlite3StatusDown(9, 1);
  }
  FUNCTION_TABLE[HEAP32[16077]]($0);
 }
}

function sqlite3WhereExprAnalyze($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 + 12 >> 2];
 while (1) {
  if (($2 | 0) > 0) {
   $2 = $2 - 1 | 0;
   exprAnalyze($0, $1, $2);
   continue;
  }
  break;
 }
}

function sqlite3VdbeTakeOpArray($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 104 >> 2];
 resolveP2Values($0, $2);
 HEAP32[$1 >> 2] = HEAP32[$0 + 108 >> 2];
 HEAP32[$0 + 104 >> 2] = 0;
 return $3;
}

function fts3StrCompare($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = 1;
 if (($1 | 0) == ($3 | 0)) {
  $4 = strncmp($0, $2, $1);
 }
 return $4 | 0;
}

function totalFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  $2 = HEAPF64[$1 >> 3];
 } else {
  $2 = 0;
 }
 sqlite3_result_double($0, $2);
}

function pcache1UnderMemoryPressure($0) {
 if (!(!HEAP32[17736] | HEAP32[17735] < (HEAP32[$0 + 12 >> 2] + HEAP32[$0 + 8 >> 2] | 0))) {
  return HEAP32[17743];
 }
 return sqlite3HeapNearlyFull();
}

function fts3BinCompare($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $4 = 0;
 $4 = 1;
 if (($1 | 0) == ($3 | 0)) {
  $4 = memcmp($0, $2, $1);
 }
 return $4 | 0;
}

function sqlite3UpsertOfIndex($0, $1) {
 while (1) {
  if (!(!$0 | !HEAP32[$0 >> 2] | HEAP32[$0 + 28 >> 2] == ($1 | 0))) {
   $0 = HEAP32[$0 + 16 >> 2];
   continue;
  }
  break;
 }
 return $0;
}

function legalstub$dynCall_iijii($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 return dynCall_iijii($0, $1, $2, $3, $4, $5) | 0;
}

function legalstub$dynCall_iiiij($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 return dynCall_iiiij($0, $1, $2, $3, $4, $5) | 0;
}

function heightOfExpr($0, $1) {
 label$1: {
  if (!$0) {
   break label$1;
  }
  $0 = HEAP32[$0 + 24 >> 2];
  if (($0 | 0) <= HEAP32[$1 >> 2]) {
   break label$1;
  }
  HEAP32[$1 >> 2] = $0;
 }
}

function dense_rankStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_aggregate_context($0, 24);
 if ($0) {
  HEAP32[$0 + 8 >> 2] = 1;
  HEAP32[$0 + 12 >> 2] = 0;
 }
}

function whereRightSubexprIsColumn($0) {
 $0 = sqlite3ExprSkipCollateAndLikely(HEAP32[$0 + 16 >> 2]);
 if (HEAPU8[$0 + 4 | 0] & 32 ? 1 : !$0 | HEAPU8[$0 | 0] != 167) {
  $0 = 0;
 }
 return $0;
}

function last_insert_rowid($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_int64($0, sqlite3_last_insert_rowid(sqlite3_context_db_handle($0)), i64toi32_i32$HIGH_BITS);
}

function fts3EvalInvalidatePoslist($0) {
 if (HEAP32[$0 + 24 >> 2]) {
  sqlite3_free(HEAP32[$0 + 28 >> 2]);
 }
 HEAP32[$0 + 32 >> 2] = 0;
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 28 >> 2] = 0;
}

function pagerFreeMapHdrs($0) {
 var $1 = 0;
 $0 = HEAP32[$0 + 144 >> 2];
 while (1) {
  if ($0) {
   $1 = HEAP32[$0 + 16 >> 2];
   sqlite3_free($0);
   $0 = $1;
   continue;
  }
  break;
 }
}

function sqlite3VdbeMemIntegerify($0) {
 HEAP32[$0 >> 2] = sqlite3VdbeIntValue($0);
 HEAP32[$0 + 4 >> 2] = i64toi32_i32$HIGH_BITS;
 HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 62016 | 4;
}

function jsonZero($0) {
 HEAP8[$0 + 24 | 0] = 1;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 100;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = $0 + 26;
}

function fts3ConnectMethod($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 return fts3InitVtab(0, $0, $1, $2, $3, $4, $5) | 0;
}

function whereLoopClear($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$1 + 52 >> 2];
 if (($2 | 0) != ($1 + 60 | 0)) {
  sqlite3DbFreeNN($0, $2);
 }
 whereLoopClearUnion($0, $1);
 whereLoopInit($1);
}

function sqlite3WalEndWriteTransaction($0) {
 if (HEAPU8[$0 + 44 | 0]) {
  walUnlockExclusive($0, 0, 1);
  HEAP32[$0 + 104 >> 2] = 0;
  HEAP8[$0 + 44 | 0] = 0;
  HEAP8[$0 + 47 | 0] = 0;
 }
}

function fts3CreateMethod($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 return fts3InitVtab(1, $0, $1, $2, $3, $4, $5) | 0;
}

function sqlite3PcacheInitialize() {
 var $0 = 0;
 $0 = HEAP32[16095];
 if (!$0) {
  sqlite3PCacheSetDefault();
  $0 = HEAP32[16095];
 }
 return FUNCTION_TABLE[$0 | 0](HEAP32[16094]) | 0;
}

function sqlite3PCacheSetDefault() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 >> 2] = 51216;
 sqlite3_config(18, $0);
 __stack_pointer = $0 + 16 | 0;
}

function sqlite3ApiExit($0, $1) {
 var $2 = 0;
 label$1: {
  if (!$1) {
   $2 = 0;
   if (!HEAPU8[$0 + 87 | 0]) {
    break label$1;
   }
  }
  $2 = apiHandleError($0, $1);
 }
 return $2;
}

function sqlite3InRhsIsConstant($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[$0 + 12 >> 2] = 0;
 $2 = sqlite3ExprIsConstant($0);
 HEAP32[$0 + 12 >> 2] = $1;
 return $2;
}

function numericType($0) {
 var $1 = 0, $2 = 0;
 $2 = HEAPU16[$0 + 16 >> 1];
 $1 = $2 & 44;
 if (!$1) {
  if (!($2 & 18)) {
   return 0;
  }
  $1 = computeNumericType($0);
 }
 return $1;
}

function hashDestroy($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 HEAP32[$0 + 20 >> 2] = $1 - 1;
 if (($1 | 0) <= 1) {
  sqlite3Fts3HashClear($0);
  sqlite3_free($0);
 }
}

function groupConcatFinalize($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = sqlite3_aggregate_context($0, 0);
 if ($1) {
  sqlite3ResultStrAccum($0, $1);
  sqlite3_free(HEAP32[$1 + 32 >> 2]);
 }
}

function fts3auxRowidMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = HEAP32[$0 + 100 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 + 96 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 return 0;
}

function total_changes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_int64($0, sqlite3_total_changes64(sqlite3_context_db_handle($0)), i64toi32_i32$HIGH_BITS);
}

function sqlite3_result_error_code($0, $1) {
 HEAP32[$0 + 20 >> 2] = $1 ? $1 : -1;
 if (HEAP8[HEAP32[$0 >> 2] + 16 | 0] & 1) {
  setResultStrOrError($0, sqlite3ErrStr($1), -1, 1, 0);
 }
}

function sqlite3_result_blob64($0, $1, $2, $3, $4) {
 if (!$3 & $2 >>> 0 >= 2147483648 | $3) {
  invokeValueDestructor($1, $4, $0);
  return;
 }
 setResultStrOrError($0, $1, $2, 0, $4);
}

function sqlite3DequoteExpr($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 8 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | (HEAPU8[$1 | 0] == 34 ? 67108992 : 67108864);
 sqlite3Dequote($1);
}

function porterCreate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = sqlite3_malloc(4);
 if (!$0) {
  return 7;
 }
 HEAP32[$0 >> 2] = 0;
 HEAP32[$2 >> 2] = $0;
 return 0;
}

function exprTableColumn($0, $1, $2) {
 $0 = sqlite3Expr($0, 167, 0);
 if ($0) {
  HEAP16[$0 + 32 >> 1] = 65535;
  HEAP32[$0 + 28 >> 2] = $2;
  HEAP32[$0 + 44 >> 2] = $1;
 }
 return $0;
}

function createModule($0, $1, $2, $3, $4) {
 sqlite3VtabCreateModule($0, $1, $2, $3, $4);
 $0 = sqlite3ApiExit($0, 0);
 if (!(!$4 | !$0)) {
  FUNCTION_TABLE[$4 | 0]($3);
 }
 return $0;
}

function attachWithToSelect($0, $1, $2) {
 if ($1) {
  HEAP32[$1 + 64 >> 2] = $2;
  parserDoubleLinkSelect($0, $1);
  return $1;
 }
 sqlite3WithDelete(HEAP32[$0 >> 2], $2);
 return $1;
}

function sqlite3_value_numeric_type($0) {
 var $1 = 0;
 $1 = sqlite3_value_type($0);
 if (($1 | 0) == 3) {
  applyNumericAffinity($0, 0);
  $1 = sqlite3_value_type($0);
 }
 return $1;
}

function sqlite3WindowListDelete($0, $1) {
 var $2 = 0;
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 + 36 >> 2];
   sqlite3WindowDelete($0, $1);
   $1 = $2;
   continue;
  }
  break;
 }
}

function sqlite3MemSetDefault() {
 var $0 = 0;
 $0 = __stack_pointer - 16 | 0;
 __stack_pointer = $0;
 HEAP32[$0 >> 2] = 51184;
 sqlite3_config(4, $0);
 __stack_pointer = $0 + 16 | 0;
}

function sqlite3ChangeCookie($0, $1) {
 sqlite3VdbeAddOp3(HEAP32[$0 + 8 >> 2], 100, $1, 1, HEAP32[HEAP32[(HEAP32[HEAP32[$0 >> 2] + 16 >> 2] + ($1 << 4) | 0) + 12 >> 2] >> 2] + 1 | 0);
}

function renameColumnSelectCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = 1;
 if (!(HEAPU16[$1 + 6 >> 1] & 1056)) {
  renameWalkWith($0, $1);
  $2 = 0;
 }
 return $2 | 0;
}

function memdbUnfetch($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $0 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 32 >> 2] = HEAP32[$0 + 32 >> 2] - 1;
 return 0;
}

function getCellInfo($0) {
 if (!HEAPU16[$0 + 50 >> 1]) {
  HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] | 2;
  btreeParseCell(HEAP32[$0 + 116 >> 2], HEAPU16[$0 + 70 >> 1], $0 + 32 | 0);
 }
}

function apiHandleError($0, $1) {
 if (!(HEAPU8[$0 + 87 | 0] ? 0 : ($1 | 0) != 3082)) {
  sqlite3OomClear($0);
  sqlite3Error($0, 7);
  return 7;
 }
 return HEAP32[$0 + 72 >> 2] & $1;
}

function sqlite3_prepare_v2($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return sqlite3LockAndPrepare($0, $1, $2, 128, 0, $3, $4) | 0;
}

function memjrnlFileSize($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = HEAP32[$0 + 20 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 + 16 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 return 0;
}

function logBadConnection($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 __stack_pointer = $1;
 HEAP32[$1 >> 2] = $0;
 sqlite3_log(21, 8733, $1);
 __stack_pointer = $1 + 16 | 0;
}

function fts3RowidMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = HEAP32[$0 + 36 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 + 32 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 return 0;
}

function freeTempSpace($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 84 >> 2];
 if ($1) {
  $1 = $1 - 4 | 0;
  HEAP32[$0 + 84 >> 2] = $1;
  sqlite3PageFree($1);
  HEAP32[$0 + 84 >> 2] = 0;
 }
}

function sqlite3PagerFilename($0, $1) {
 label$1: {
  if ($1) {
   $1 = 32180;
   if (HEAPU8[$0 + 15 | 0]) {
    break label$1;
   }
  }
  $1 = HEAP32[$0 + 184 >> 2];
 }
 return $1;
}

function pragmaVtabRowid($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = HEAP32[$0 + 12 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 + 8 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 return 0;
}

function disableLookaside($0) {
 HEAP8[$0 + 24 | 0] = HEAPU8[$0 + 24 | 0] + 1;
 $0 = HEAP32[$0 >> 2];
 HEAP16[$0 + 308 >> 1] = 0;
 HEAP32[$0 + 304 >> 2] = HEAP32[$0 + 304 >> 2] + 1;
}

function compileoptiongetFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_text($0, sqlite3_compileoption_get(sqlite3_value_int(HEAP32[$2 >> 2])), -1, 0);
}

function addToVTrans($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 380 >> 2];
 HEAP32[$0 + 380 >> 2] = $2 + 1;
 HEAP32[HEAP32[$0 + 404 >> 2] + ($2 << 2) >> 2] = $1;
 sqlite3VtabLock($1);
}

function sqlite3PcacheMakeClean($0) {
 pcacheManageDirtyList($0, 1);
 HEAP16[$0 + 28 >> 1] = HEAPU16[$0 + 28 >> 1] & 65520 | 1;
 if (!HEAPU16[$0 + 30 >> 1]) {
  pcacheUnpin($0);
 }
}

function sqlite3CodeChangeCount($0, $1, $2) {
 sqlite3VdbeAddOp0($0, 83);
 sqlite3VdbeAddOp2($0, 84, $1, 1);
 sqlite3VdbeSetNumCols($0, 1);
 sqlite3VdbeSetColName($0, 0, 0, $2, 0);
}

function sqlite3BtreeCommit($0) {
 var $1 = 0;
 sqlite3BtreeEnter($0);
 $1 = sqlite3BtreeCommitPhaseOne($0, 0);
 if (!$1) {
  $1 = sqlite3BtreeCommitPhaseTwo($0, 0);
 }
 return $1;
}

function hasVowel($0) {
 $0 = $0 | 0;
 var $1 = 0;
 while (1) {
  $1 = $0;
  $0 = $1 + 1 | 0;
  if (isConsonant($1)) {
   continue;
  }
  break;
 }
 return HEAPU8[$1 | 0] != 0 | 0;
}

function robust_close($0, $1, $2) {
 var $3 = 0;
 if (FUNCTION_TABLE[HEAP32[16240]]($1) | 0) {
  $3 = $0 ? HEAP32[$0 + 32 >> 2] : $3;
  unixLogErrorAtLine(4106, 12847, $3, $2);
 }
}

function sqlite3WhereOkOnePass($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 28 >> 2];
 HEAP32[$1 >> 2] = HEAP32[$0 + 24 >> 2];
 HEAP32[$1 + 4 >> 2] = $2;
 return HEAPU8[$0 + 50 | 0];
}

function sqlite3VdbeCloseStatement($0, $1) {
 var $2 = 0;
 if (!(!HEAP32[HEAP32[$0 >> 2] + 504 >> 2] | !HEAP32[$0 + 48 >> 2])) {
  $2 = vdbeCloseStatement($0, $1);
 }
 return $2;
}

function sqlite3VdbeChangeP5($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 108 >> 2];
 if (($2 | 0) > 0) {
  HEAP16[(HEAP32[$0 + 104 >> 2] + Math_imul($2, 20) | 0) - 18 >> 1] = $1;
 }
}

function sqlite3_wal_autocheckpoint($0, $1) {
 label$1: {
  if (($1 | 0) > 0) {
   sqlite3_wal_hook($0, 9, $1);
   break label$1;
  }
  sqlite3_wal_hook($0, 0, 0);
 }
 return 0;
}

function sqlite3_result_error($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 HEAP32[$0 + 20 >> 2] = 1;
 sqlite3VdbeMemSetStr(HEAP32[$0 >> 2], $1, $2, $2 >> 31, 1, -1);
}

function sqlite3ExprCollSeqMatch($0, $1, $2) {
 $1 = sqlite3ExprNNCollSeq($0, $1);
 $0 = sqlite3ExprNNCollSeq($0, $2);
 return !sqlite3StrICmp(HEAP32[$1 >> 2], HEAP32[$0 >> 2]);
}

function sqlite3VdbeExplainParent($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 220 >> 2];
 if (!$1) {
  return 0;
 }
 return HEAP32[sqlite3VdbeGetOp(HEAP32[$0 + 8 >> 2], $1) + 8 >> 2];
}

function sqlite3ExprUnmapAndDelete($0, $1) {
 if ($1) {
  if (HEAPU8[$0 + 208 | 0] >= 2) {
   sqlite3RenameExprUnmap($0, $1);
  }
  sqlite3ExprDeleteNN(HEAP32[$0 >> 2], $1);
 }
}

function sqlite3BtreeMaxRecordSize($0) {
 var $1 = 0;
 $0 = HEAP32[$0 + 20 >> 2];
 $1 = HEAP32[$0 + 36 >> 2];
 $1 = __wasm_i64_mul(HEAP32[$0 + 48 >> 2], 0, $1, 0);
 return $1;
}

function fts3SegWriterFree($0) {
 if ($0) {
  sqlite3_free(HEAP32[$0 + 48 >> 2]);
  sqlite3_free(HEAP32[$0 + 36 >> 2]);
  fts3NodeFree(HEAP32[$0 >> 2]);
  sqlite3_free($0);
 }
}

function sqlite3ParserFinalize($0) {
 var $1 = 0;
 $1 = $0 + 8 | 0;
 while (1) {
  if ($1 >>> 0 < HEAPU32[$0 >> 2]) {
   yy_pop_parser_stack($0);
   continue;
  }
  break;
 }
}

function sqlite3PagerOpenSavepoint($0, $1) {
 var $2 = 0;
 if (!(!HEAPU8[$0 + 6 | 0] | HEAP32[$0 + 104 >> 2] >= ($1 | 0))) {
  $2 = pagerOpenSavepoint($0, $1);
 }
 return $2;
}

function vdbeSorterRecordFree($0, $1) {
 var $2 = 0;
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 + 4 >> 2];
   sqlite3DbFree($0, $1);
   $1 = $2;
   continue;
  }
  break;
 }
}

function typeofFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_text($0, HEAP32[(sqlite3_value_type(HEAP32[$2 >> 2]) << 2) + 50684 >> 2], -1, 0);
}

function sqlite3_blob_close($0) {
 var $1 = 0;
 if (!$0) {
  return 0;
 }
 $1 = HEAP32[$0 + 16 >> 2];
 sqlite3DbFree(HEAP32[$0 + 20 >> 2], $0);
 return sqlite3_finalize($1);
}

function sqlite3_bind_text($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return bindText($0, $1, $2, $3, $3 >> 31, $4, 1) | 0;
}

function sqlite3_bind_blob($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return bindText($0, $1, $2, $3, $3 >> 31, $4, 0) | 0;
}

function pcacheUnpin($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 12 >> 2];
 if (HEAPU8[$1 + 32 | 0]) {
  FUNCTION_TABLE[HEAP32[16101]](HEAP32[$1 + 44 >> 2], HEAP32[$0 >> 2], 0);
 }
}

function pcache1Truncate($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (HEAPU32[$0 + 36 >> 2] >= $1 >>> 0) {
  pcache1TruncateUnsafe($0, $1);
  HEAP32[$0 + 36 >> 2] = $1 - 1;
 }
}

function double_cmp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0;
 $2 = HEAPF64[$0 >> 3];
 $3 = HEAPF64[$1 >> 3];
 return ($2 == $3 ? 0 : $2 < $3 ? -1 : 1) | 0;
}

function changes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_int64($0, sqlite3_changes64(sqlite3_context_db_handle($0)), i64toi32_i32$HIGH_BITS);
}

function sqlite3BtreeGetAutoVacuum($0) {
 sqlite3BtreeEnter($0);
 $0 = HEAP32[$0 + 4 >> 2];
 if (!HEAPU8[$0 + 17 | 0]) {
  return 0;
 }
 return HEAPU8[$0 + 18 | 0] ? 2 : 1;
}

function memdbGetLastError($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 return FUNCTION_TABLE[HEAP32[$0 + 68 >> 2]]($0, $1, $2) | 0;
}

function makeColumnPartOfPrimaryKey($0, $1) {
 var $2 = 0;
 $2 = HEAPU16[$1 + 10 >> 1];
 HEAP16[$1 + 10 >> 1] = $2 | 1;
 if ($2 & 96) {
  sqlite3ErrorMsg($0, 17934, 0);
 }
}

function sqlite3_result_pointer($0, $1, $2, $3) {
 $0 = HEAP32[$0 >> 2];
 sqlite3VdbeMemRelease($0);
 HEAP16[$0 + 16 >> 1] = 1;
 sqlite3VdbeMemSetPointer($0, $1, $2, $3);
}

function sqlite3PagerSetBusyHandler($0, $1) {
 HEAP32[$0 + 196 >> 2] = $1;
 HEAP32[$0 + 192 >> 2] = 16;
 sqlite3OsFileControlHint(HEAP32[$0 + 64 >> 2], 15, $0 + 192 | 0);
}

function sqlite3BtreeCursor($0, $1, $2, $3, $4) {
 if (HEAPU8[$0 + 9 | 0]) {
  return btreeCursorWithLock($0, $1, $2, $3, $4);
 }
 return btreeCursor($0, $1, $2, $3, $4);
}

function memdbRandomness($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 return FUNCTION_TABLE[HEAP32[$0 + 56 >> 2]]($0, $1, $2) | 0;
}

function sqlite3OsFileControl($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 >> 2];
 if (!$3) {
  return 12;
 }
 return FUNCTION_TABLE[HEAP32[$3 + 40 >> 2]]($0, $1, $2) | 0;
}

function sqlite3Error($0, $1) {
 HEAP32[$0 + 64 >> 2] = $1;
 if (HEAP32[$0 + 288 >> 2] ? 1 : $1) {
  sqlite3ErrorFinish($0, $1);
  return;
 }
 HEAP32[$0 + 68 >> 2] = -1;
}

function renameTokenFree($0, $1) {
 var $2 = 0;
 while (1) {
  if ($1) {
   $2 = HEAP32[$1 + 12 >> 2];
   sqlite3DbFree($0, $1);
   $1 = $2;
   continue;
  }
  break;
 }
}

function legalstub$dynCall_iiji($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 return dynCall_iiji($0, $1, $2, $3, $4) | 0;
}

function sqlite3_busy_handler($0, $1, $2) {
 HEAP32[$0 + 496 >> 2] = 0;
 HEAP32[$0 + 444 >> 2] = $1;
 HEAP32[$0 + 452 >> 2] = 0;
 HEAP32[$0 + 448 >> 2] = $2;
 return 0;
}

function sqlite3VdbeSetP4KeyInfo($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 8 >> 2];
 $0 = sqlite3KeyInfoOfIndex($0, $1);
 if ($0) {
  sqlite3VdbeAppendP4($2, $0, -8);
 }
}

function sqlite3NameFromToken($0, $1) {
 if (!$1) {
  return 0;
 }
 $1 = sqlite3DbStrNDup($0, HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], 0);
 sqlite3Dequote($1);
 return $1;
}

function resolveRemoveWindowsCb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (HEAP8[$1 + 7 | 0] & 1) {
  sqlite3WindowUnlinkFromSelect(HEAP32[$1 + 44 >> 2]);
 }
 return 0;
}

function fts3auxOpenMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = sqlite3_malloc(120);
 if (!$0) {
  return 7;
 }
 HEAP32[$1 >> 2] = memset($0, 0, 120);
 return 0;
}

function fts3OpenMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = sqlite3_malloc(96);
 HEAP32[$1 >> 2] = $0;
 if (!$0) {
  return 7;
 }
 memset($0, 0, 96);
 return 0;
}

function agginfoFree($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 sqlite3DbFree($0, HEAP32[$1 + 28 >> 2]);
 sqlite3DbFree($0, HEAP32[$1 + 40 >> 2]);
 sqlite3DbFreeNN($0, $1);
}

function sqlite3_column_double($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 $2 = sqlite3_value_double(columnMem($0, $1));
 columnMallocFailure($0);
 return +$2;
}

function pager_reset($0) {
 HEAP32[$0 + 108 >> 2] = HEAP32[$0 + 108 >> 2] + 1;
 sqlite3BackupRestart(HEAP32[$0 + 96 >> 2]);
 sqlite3PcacheClear(HEAP32[$0 + 228 >> 2]);
}

function incrAggDepth($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (HEAPU8[$1 | 0] == 168) {
  HEAP8[$1 + 2 | 0] = HEAPU8[$1 + 2 | 0] + HEAPU8[$0 + 24 | 0];
 }
 return 0;
}

function sqlite3UpsertNextIsIPK($0) {
 var $1 = 0;
 $1 = 1;
 $0 = HEAP32[$0 + 16 >> 2];
 if (!(!$0 | !HEAP32[$0 >> 2])) {
  $1 = !HEAP32[$0 + 28 >> 2];
 }
 return $1;
}

function sqlite3ExprSkipCollate($0) {
 while (1) {
  if (!(!$0 | !(HEAPU8[$0 + 5 | 0] & 32))) {
   $0 = HEAP32[$0 + 12 >> 2];
   continue;
  }
  break;
 }
 return $0;
}

function fts3tokOpenMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = sqlite3_malloc(36);
 if (!$0) {
  return 7;
 }
 HEAP32[$1 >> 2] = memset($0, 0, 36);
 return 0;
}

function sqlite3BtreeCursorZero($0) {
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
}

function memdbDlSym($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 return FUNCTION_TABLE[HEAP32[$0 + 48 >> 2]]($0, $1, $2) | 0;
}

function jsonEachOpenTree($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = jsonEachOpenEach($1, $1);
 if (!$0) {
  HEAP8[HEAP32[$1 >> 2] + 21 | 0] = 1;
 }
 return $0 | 0;
}

function jsonEachOpenEach($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = sqlite3_malloc(64);
 if (!$0) {
  return 7;
 }
 HEAP32[$1 >> 2] = memset($0, 0, 64);
 return 0;
}

function fts3ExprPhraseCountCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 HEAP32[$2 >> 2] = HEAP32[$2 >> 2] + 1;
 HEAP32[$0 + 36 >> 2] = $1;
 return 0;
}

function actionName($0) {
 var $1 = 0;
 $1 = 19400;
 $0 = $0 - 7 | 0;
 if (($0 & 255) >>> 0 <= 3) {
  $1 = HEAP32[($0 << 24 >> 24 << 2) + 55408 >> 2];
 }
 return $1;
}

function vdbePmaReaderClear($0) {
 sqlite3_free(HEAP32[$0 + 28 >> 2]);
 sqlite3_free(HEAP32[$0 + 36 >> 2]);
 vdbeIncrFree(HEAP32[$0 + 48 >> 2]);
 memset($0, 0, 56);
}

function sqlite3VdbeFinalize($0) {
 var $1 = 0;
 if (HEAPU8[$0 + 149 | 0]) {
  $1 = sqlite3VdbeReset($0);
 } else {
  $1 = 0;
 }
 sqlite3VdbeDelete($0);
 return $1;
}

function sqlite3ValueNew($0) {
 var $1 = 0;
 $1 = sqlite3DbMallocZero($0, 40, 0);
 if ($1) {
  HEAP32[$1 + 20 >> 2] = $0;
  HEAP16[$1 + 16 >> 1] = 1;
 }
 return $1;
}

function sqlite3Fts3HashInit($0) {
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP16[$0 >> 1] = 257;
 HEAP32[$0 + 12 >> 2] = 0;
 HEAP32[$0 + 16 >> 2] = 0;
}

function hasAnchor($0) {
 while (1) {
  if (!(!$0 | !(HEAPU8[$0 + 5 | 0] & 32))) {
   $0 = HEAP32[$0 + 52 >> 2];
   continue;
  }
  break;
 }
 return ($0 | 0) != 0;
}

function fts3tokDisconnectMethod($0) {
 $0 = $0 | 0;
 FUNCTION_TABLE[HEAP32[HEAP32[$0 + 12 >> 2] + 8 >> 2]](HEAP32[$0 + 16 >> 2]) | 0;
 sqlite3_free($0);
 return 0;
}

function dotlockCheckReservedLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 HEAP32[$1 >> 2] = !(FUNCTION_TABLE[HEAP32[16243]](HEAP32[$0 + 24 >> 2], 0) | 0);
 return 0;
}

function sqlite3_uri_boolean($0, $1, $2) {
 $1 = sqlite3_uri_parameter($0, $1);
 if ($1) {
  return sqlite3GetBoolean($1, ($2 | 0) != 0);
 }
 return ($2 | 0) != 0;
}

function emscripten_thread_sleep($0) {
 var $1 = 0;
 $1 = +emscripten_get_now();
 while (1) {
  if (+emscripten_get_now() - $1 < $0) {
   continue;
  }
  break;
 }
}

function sqlite3_result_error_nomem($0) {
 sqlite3VdbeMemSetNull(HEAP32[$0 >> 2]);
 HEAP32[$0 + 20 >> 2] = 7;
 sqlite3OomFault(HEAP32[HEAP32[$0 >> 2] + 20 >> 2]);
}

function sqlite3VdbeFrameMemDel($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = HEAP32[$0 >> 2];
 HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 216 >> 2];
 HEAP32[$1 + 216 >> 2] = $0;
}

function sqlite3OsDeviceCharacteristics($0) {
 var $1 = 0;
 $1 = HEAP32[$0 >> 2];
 if (!$1) {
  return 0;
 }
 return FUNCTION_TABLE[HEAP32[$1 + 48 >> 2]]($0) | 0;
}

function sqlite3BtreeSetSpillSize($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 return sqlite3PagerSetSpillsize(HEAP32[$2 >> 2], $1);
}

function btreePageLookup($0, $1) {
 var $2 = 0;
 $2 = sqlite3PagerLookup(HEAP32[$0 >> 2], $1);
 if (!$2) {
  return 0;
 }
 return btreePageFromDbPage($2, $1, $0);
}

function sqlite3WhereRealloc($0, $1, $2, $3) {
 $0 = sqlite3WhereMalloc($0, $2, $3);
 if (!(!$1 | !$0)) {
  __memcpy($0, $1, HEAP32[$1 - 8 >> 2]);
 }
 return $0;
}

function resolveAttachExpr($0, $1) {
 if ($1) {
  if (HEAPU8[$1 | 0] != 59) {
   return sqlite3ResolveExprNames($0, $1);
  }
  HEAP8[$1 | 0] = 117;
 }
 return 0;
}

function indexWhereClauseMightChange($0, $1, $2) {
 $0 = HEAP32[$0 + 36 >> 2];
 if (!$0) {
  return 0;
 }
 return sqlite3ExprReferencesUpdatedColumn($0, $1, $2);
}

function sqlite3PcacheRef($0) {
 HEAP16[$0 + 30 >> 1] = HEAPU16[$0 + 30 >> 1] + 1;
 $0 = HEAP32[$0 + 12 >> 2];
 HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
}

function sqlite3BtreeBeginStmt($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 return sqlite3PagerOpenSavepoint(HEAP32[$2 >> 2], $1);
}

function sqlite3AuthContextPop($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 4 >> 2];
 if ($1) {
  HEAP32[$1 + 248 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$0 + 4 >> 2] = 0;
 }
}

function cteClear($0, $1) {
 sqlite3ExprListDelete($0, HEAP32[$1 + 4 >> 2]);
 sqlite3SelectDelete($0, HEAP32[$1 + 8 >> 2]);
 sqlite3DbFree($0, HEAP32[$1 >> 2]);
}

function seriesOpen($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = sqlite3_malloc(64);
 if (!$0) {
  return 7;
 }
 HEAP32[$1 >> 2] = memset($0, 0, 64);
 return 0;
}

function fts3MIBufferSetGlobal($0) {
 var $1 = 0;
 HEAP32[$0 + 8 >> 2] = 1;
 $1 = HEAP32[$0 + 4 >> 2] << 2;
 __memcpy(($1 + $0 | 0) + 24 | 0, $0 + 20 | 0, $1);
}

function cachedCellSize($0, $1) {
 var $2 = 0;
 $2 = HEAPU16[HEAP32[$0 + 12 >> 2] + ($1 << 1) >> 1];
 if (!$2) {
  $2 = computeCellSize($0, $1);
 }
 return $2;
}

function sqlite3VdbeParameterIndex($0, $1, $2) {
 var $3 = 0;
 if (!(!$0 | !$1)) {
  $3 = sqlite3VListNameToNum(HEAP32[$0 + 128 >> 2], $1, $2);
 }
 return $3;
}

function sqlite3PcacheCleanAll($0) {
 var $1 = 0;
 while (1) {
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   sqlite3PcacheMakeClean($1);
   continue;
  }
  break;
 }
}

function sqlite3OsSectorSize($0) {
 var $1 = 0;
 $1 = HEAP32[HEAP32[$0 >> 2] + 44 >> 2];
 if (!$1) {
  return 4096;
 }
 return FUNCTION_TABLE[$1 | 0]($0) | 0;
}

function legalstub$dynCall_viji($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 dynCall_viji($0, $1, $2, $3, $4);
}

function countLookasideSlots($0) {
 var $1 = 0;
 while (1) {
  if ($0) {
   $1 = $1 + 1 | 0;
   $0 = HEAP32[$0 >> 2];
   continue;
  }
  break;
 }
 return $1;
}

function sqlite3ErrorClear($0) {
 HEAP32[$0 + 64 >> 2] = 0;
 HEAP32[$0 + 68 >> 2] = -1;
 $0 = HEAP32[$0 + 288 >> 2];
 if ($0) {
  sqlite3ValueSetNull($0);
 }
}

function memjrnlFreeChunks($0) {
 var $1 = 0;
 while (1) {
  if ($0) {
   $1 = HEAP32[$0 >> 2];
   sqlite3_free($0);
   $0 = $1;
   continue;
  }
  break;
 }
}

function sqlite3SelectOpName($0) {
 var $1 = 0;
 $1 = 19430;
 $0 = $0 - 135 | 0;
 if ($0 >>> 0 <= 2) {
  $1 = HEAP32[($0 << 2) + 55396 >> 2];
 }
 return $1;
}

function memdbDlError($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 FUNCTION_TABLE[HEAP32[$0 + 44 >> 2]]($0, $1, $2);
}

function sqlite3_column_bytes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $1 = sqlite3_value_bytes(columnMem($0, $1));
 columnMallocFailure($0);
 return $1 | 0;
}

function sqlite3BtreeSetCacheSize($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 sqlite3PagerSetCachesize(HEAP32[$2 >> 2], $1);
}

function fts3SavepointMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0;
 if (!HEAPU8[$0 + 240 | 0]) {
  $2 = fts3SyncMethod($0);
 }
 return $2 | 0;
}

function walLockExclusive($0, $1, $2) {
 var $3 = 0;
 if (!HEAPU8[$0 + 43 | 0]) {
  $3 = sqlite3OsShmLock(HEAP32[$0 + 4 >> 2], $1, $2, 10);
 }
 return $3;
}

function sqlite3VdbeEndCoroutine($0, $1) {
 sqlite3VdbeAddOp1($0, 68, $1);
 $0 = HEAP32[$0 + 12 >> 2];
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP8[$0 + 19 | 0] = 0;
}

function sqlite3VdbeCursorRestore($0) {
 if (!sqlite3BtreeCursorHasMoved(HEAP32[$0 + 36 >> 2])) {
  return 0;
 }
 return sqlite3VdbeHandleMovedCursor($0);
}

function sqlite3OsDelete($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 + 28 >> 2];
 if (!$3) {
  return 0;
 }
 return FUNCTION_TABLE[$3 | 0]($0, $1, $2) | 0;
}

function sqlite3ExprCompareSkip($0, $1, $2) {
 return sqlite3ExprCompare(0, sqlite3ExprSkipCollateAndLikely($0), sqlite3ExprSkipCollateAndLikely($1), $2);
}

function memdbCurrentTimeInt64($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 return FUNCTION_TABLE[HEAP32[$0 + 72 >> 2]]($0, $1) | 0;
}

function sqlite3_column_type($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $1 = sqlite3_value_type(columnMem($0, $1));
 columnMallocFailure($0);
 return $1 | 0;
}

function sqlite3_column_text($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $1 = sqlite3_value_text(columnMem($0, $1));
 columnMallocFailure($0);
 return $1 | 0;
}

function sqlite3_column_blob($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $1 = sqlite3_value_blob(columnMem($0, $1));
 columnMallocFailure($0);
 return $1 | 0;
}

function sqlite3ParserInit($0, $1) {
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = $1;
 HEAP32[$0 + 1208 >> 2] = $0 + 1196;
 HEAP32[$0 >> 2] = $0 + 8;
}

function sqlite3OsFileControlHint($0, $1, $2) {
 var $3 = 0;
 $3 = HEAP32[$0 >> 2];
 if ($3) {
  FUNCTION_TABLE[HEAP32[$3 + 40 >> 2]]($0, $1, $2) | 0;
 }
}

function sqlite3Fts3SegReaderCursor($0, $1, $2, $3, $4, $5, $6, $7, $8) {
 return fts3SegReaderCursor($0, $1, $2, $3, $4, $5, $6, $7, memset($8, 0, 56));
}

function sqlite3ExprSetHeightAndFlags($0, $1) {
 if (!HEAP32[$0 + 36 >> 2]) {
  exprSetHeight($1);
  sqlite3ExprCheckHeight($0, HEAP32[$1 + 24 >> 2]);
 }
}

function yy_pop_parser_stack($0) {
 var $1 = 0;
 $1 = HEAP32[$0 >> 2];
 HEAP32[$0 >> 2] = $1 - 12;
 yy_destructor($0, HEAPU16[$1 + 2 >> 1], $1 + 4 | 0);
}

function sqlite3VdbeMemSetDouble($0, $1) {
 sqlite3VdbeMemSetNull($0);
 if (!sqlite3IsNaN($1)) {
  HEAP16[$0 + 16 >> 1] = 8;
  HEAPF64[$0 >> 3] = $1;
 }
}

function sqlite3SystemError($0, $1) {
 if (!(($1 | 0) == 3082 | ($1 & 251) != 10)) {
  HEAP32[$0 + 76 >> 2] = sqlite3OsGetLastError(HEAP32[$0 >> 2]);
 }
}

function sqlite3BtreeSetPagerFlags($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 sqlite3BtreeEnter($0);
 sqlite3PagerSetFlags(HEAP32[$2 >> 2], $1);
}

function fts3UpdateMethod($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 return sqlite3Fts3UpdateMethod($0, $1, $2, $3) | 0;
}

function __wasm_popcnt_i32($0) {
 var $1 = 0;
 while (1) {
  if ($0) {
   $0 = $0 - 1 & $0;
   $1 = $1 + 1 | 0;
   continue;
  }
  break;
 }
 return $1;
}

function sqlite3VdbeAddOp4($0, $1, $2, $3, $4, $5, $6) {
 $4 = sqlite3VdbeAddOp3($0, $1, $2, $3, $4);
 sqlite3VdbeChangeP4($0, $4, $5, $6);
 return $4;
}

function vdbeReleaseAndSetInt64($0, $1, $2) {
 sqlite3VdbeMemSetNull($0);
 HEAP16[$0 + 16 >> 1] = 4;
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = $2;
}

function sqlite3_str_finish($0) {
 var $1 = 0;
 if (!(!$0 | ($0 | 0) == 64552)) {
  $1 = sqlite3StrAccumFinish($0);
  sqlite3_free($0);
 }
 return $1;
}

function sqlite3VdbeRecordCompare($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return sqlite3VdbeRecordCompareWithSkip($0, $1, $2, 0) | 0;
}

function sqlite3PagerJrnlFile($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 232 >> 2];
 if ($1) {
  return sqlite3WalFile($1);
 }
 return HEAP32[$0 + 68 >> 2];
}

function sqlite3OsGetLastError($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 68 >> 2];
 if (!$1) {
  return 0;
 }
 return FUNCTION_TABLE[$1 | 0]($0, 0, 0) | 0;
}

function sqlite3Fts3SegReaderStart($0, $1, $2) {
 HEAP32[$1 + 12 >> 2] = $2;
 return fts3SegReaderStart($0, $1, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2]);
}

function sqlite3FindDb($0, $1) {
 var $2 = 0;
 $1 = sqlite3NameFromToken($0, $1);
 $2 = sqlite3FindDbName($0, $1);
 sqlite3DbFree($0, $1);
 return $2;
}

function fstat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if (($0 | 0) < 0) {
  return __syscall_ret(-8) | 0;
 }
 return fstatat($0, 29623, $1, 4096) | 0;
}

function sqlite3OsClose($0) {
 var $1 = 0;
 $1 = HEAP32[$0 >> 2];
 if ($1) {
  FUNCTION_TABLE[HEAP32[$1 + 4 >> 2]]($0) | 0;
  HEAP32[$0 >> 2] = 0;
 }
}

function sqlite3ErrorFinish($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 288 >> 2];
 if ($2) {
  sqlite3ValueSetNull($2);
 }
 sqlite3SystemError($0, $1);
}

function sqlite3BackupRestart($0) {
 while (1) {
  if ($0) {
   HEAP32[$0 + 16 >> 2] = 1;
   $0 = HEAP32[$0 + 44 >> 2];
   continue;
  }
  break;
 }
}

function getPageError($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 HEAP32[$2 >> 2] = 0;
 return HEAP32[$0 + 44 >> 2];
}

function findRightmost($0) {
 var $1 = 0;
 while (1) {
  $1 = $0;
  $0 = HEAP32[$0 + 56 >> 2];
  if ($0) {
   continue;
  }
  break;
 }
 return $1;
}

function sqlite3VdbeMemSetNull($0) {
 if (HEAPU8[$0 + 17 | 0] & 144) {
  vdbeMemClearExternAndSetNull($0);
  return;
 }
 HEAP16[$0 + 16 >> 1] = 1;
}

function sqlite3GetFuncCollSeq($0) {
 return HEAP32[(HEAP32[HEAP32[$0 + 12 >> 2] + 104 >> 2] + Math_imul(HEAP32[$0 + 16 >> 2], 20) | 0) - 4 >> 2];
}

function growOp3($0, $1, $2, $3, $4) {
 var $5 = 0;
 $5 = 1;
 if (!growOpArray($0)) {
  $5 = sqlite3VdbeAddOp3($0, $1, $2, $3, $4);
 }
 return $5;
}

function ftruncate($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return __syscall_ret(legalfunc$__syscall_ftruncate64($0, $1, $2)) | 0;
}

function fchown($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return __syscall_ret(__syscall_fchown32($0 | 0, $1 | 0, $2 | 0) | 0) | 0;
}

function walLockShared($0, $1) {
 var $2 = 0;
 if (!HEAPU8[$0 + 43 | 0]) {
  $2 = sqlite3OsShmLock(HEAP32[$0 + 4 >> 2], $1, 1, 6);
 }
 return $2;
}

function strdup($0) {
 var $1 = 0, $2 = 0;
 $1 = strlen($0) + 1 | 0;
 $2 = dlmalloc($1);
 if (!$2) {
  return 0;
 }
 return __memcpy($2, $0, $1);
}

function sqlite3_realloc($0, $1) {
 var $2 = 0;
 if (!sqlite3_initialize()) {
  $2 = sqlite3Realloc($0, ($1 | 0) > 0 ? $1 : 0, 0);
 }
 return $2;
}

function measureAllocationSize($0, $1) {
 $1 = sqlite3DbMallocSize($0, $1);
 $0 = HEAP32[$0 + 528 >> 2];
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + $1;
}

function lookasideMallocSize($0, $1) {
 var $2 = 0;
 $2 = 128;
 $2 = HEAPU32[$0 + 348 >> 2] > $1 >>> 0 ? HEAPU16[$0 + 310 >> 1] : $2;
 return $2;
}

function legalstub$dynCall_iij($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 return dynCall_iij($0, $1, $2, $3) | 0;
}

function createMask($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 4 >> 2] = $2 + 1;
 HEAP32[(($2 << 2) + $0 | 0) + 8 >> 2] = $1;
}

function sqlite3_result_subtype($0, $1) {
 $0 = HEAP32[$0 >> 2];
 HEAP8[$0 + 19 | 0] = $1;
 HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] | 2048;
}

function sqlite3WalDbsize($0) {
 var $1 = 0;
 if (!$0) {
  return 0;
 }
 $1 = HEAP16[$0 + 40 >> 1] >= 0 ? HEAP32[$0 + 72 >> 2] : $1;
 return $1;
}

function sqlite3RegisterPerConnectionBuiltinFunctions($0) {
 if ((sqlite3_overload_function($0, 19695, 2) | 0) == 7) {
  sqlite3OomFault($0);
 }
}

function memdbDlOpen($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 return FUNCTION_TABLE[HEAP32[$0 + 40 >> 2]]($0, $1) | 0;
}

function unixFetch($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 HEAP32[$4 >> 2] = 0;
 return 0;
}

function sqlite3_result_text($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 setResultStrOrError($0, $1, $2, 1, $3);
}

function sqlite3_result_blob($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 setResultStrOrError($0, $1, $2, 0, $3);
}

function sqlite3_bind_parameter_index($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return sqlite3VdbeParameterIndex($0, $1, sqlite3Strlen30($1)) | 0;
}

function sqlite3AuthContextPush($0, $1, $2) {
 HEAP32[$1 + 4 >> 2] = $0;
 HEAP32[$1 >> 2] = HEAP32[$0 + 248 >> 2];
 HEAP32[$0 + 248 >> 2] = $2;
}

function memdbSleep($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 return FUNCTION_TABLE[HEAP32[$0 + 60 >> 2]]($0, $1) | 0;
}

function whereLoopInit($0) {
 HEAP16[$0 + 48 >> 1] = 3;
 HEAP16[$0 + 44 >> 1] = 0;
 HEAP32[$0 + 40 >> 2] = 0;
 HEAP32[$0 + 52 >> 2] = $0 + 60;
}

function sqlite3_data_count($0) {
 $0 = $0 | 0;
 var $1 = 0;
 $1 = !$0 | !HEAP32[$0 + 120 >> 2] ? $1 : HEAPU16[$0 + 144 >> 1];
 return $1 | 0;
}

function sqlite3VdbeMemMove($0, $1) {
 sqlite3VdbeMemRelease($0);
 __memcpy($0, $1, 40);
 HEAP32[$1 + 24 >> 2] = 0;
 HEAP16[$1 + 16 >> 1] = 1;
}

function sqlite3OsInit() {
 var $0 = 0;
 $0 = sqlite3_malloc(10);
 if (!$0) {
  return 7;
 }
 sqlite3_free($0);
 sqlite3_os_init();
 return 0;
}

function langidFromSelect($0, $1) {
 if (!HEAP32[$0 + 44 >> 2]) {
  return 0;
 }
 return sqlite3_column_int($1, HEAP32[$0 + 24 >> 2] + 1 | 0);
}

function jsonValidFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_int($0, (jsonParseCached($0, $2, 0) | 0) != 0);
}

function fts3EofMethod($0) {
 $0 = $0 | 0;
 if (!HEAPU8[$0 + 6 | 0]) {
  return 0;
 }
 fts3ClearCursor($0);
 HEAP8[$0 + 6 | 0] = 1;
 return 1;
}

function unixShmRegionPerMap() {
 var $0 = 0;
 $0 = FUNCTION_TABLE[HEAP32[16312]]() | 0;
 return ($0 | 0) < 32768 ? 1 : ($0 | 0) / 32768 | 0;
}

function subtypeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_int($0, sqlite3_value_subtype(HEAP32[$2 >> 2]));
}

function sqlite3VdbeMemRealify($0) {
 HEAPF64[$0 >> 3] = sqlite3VdbeRealValue($0);
 HEAP16[$0 + 16 >> 1] = HEAPU16[$0 + 16 >> 1] & 62016 | 8;
}

function sqlite3Fts3HashFind($0, $1, $2) {
 $2 = sqlite3Fts3HashFindElem($0, $1, $2);
 if (!$2) {
  return 0;
 }
 return HEAP32[$2 + 8 >> 2];
}

function sqlite3ExprNNCollSeq($0, $1) {
 $1 = sqlite3ExprCollSeq($0, $1);
 if (!$1) {
  $1 = HEAP32[HEAP32[$0 >> 2] + 8 >> 2];
 }
 return $1;
}

function sqlite3DbReallocOrFree($0, $1, $2, $3) {
 $2 = sqlite3DbRealloc($0, $1, $2, $3);
 if (!$2) {
  sqlite3DbFree($0, $1);
 }
 return $2;
}

function __wasm_i64_udiv($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3);
 return $3;
}

function tempTriggersExist($0) {
 $0 = HEAP32[HEAP32[$0 + 16 >> 2] + 28 >> 2];
 if (!$0) {
  return 0;
 }
 return HEAP32[$0 + 48 >> 2] != 0;
}

function sqlite3WalCallback($0) {
 var $1 = 0;
 if (!$0) {
  return 0;
 }
 $1 = HEAP32[$0 + 12 >> 2];
 HEAP32[$0 + 12 >> 2] = 0;
 return $1;
}

function fts3FreeExprNode($0) {
 sqlite3Fts3EvalPhraseCleanup(HEAP32[$0 + 20 >> 2]);
 sqlite3_free(HEAP32[$0 + 40 >> 2]);
 sqlite3_free($0);
}

function allowedOp($0) {
 var $1 = 0;
 $1 = $0 - 49 | 0;
 if (!($1 >>> 0 >= 9 | !(499 >>> $1 & 1))) {
  return 1;
 }
 return ($0 | 0) == 45;
}

function sqlite3PagerUnrefNotNull($0) {
 if (HEAPU8[$0 + 28 | 0] & 32) {
  pagerReleaseMapPage($0);
  return;
 }
 sqlite3PcacheRelease($0);
}

function sqlite3BtreeMaxPageCount($0, $1) {
 sqlite3BtreeEnter($0);
 return sqlite3PagerMaxPageCount(HEAP32[HEAP32[$0 + 4 >> 2] >> 2], $1);
}

function sqlite3_wal_hook($0, $1, $2) {
 HEAP32[$0 + 268 >> 2] = $1;
 $1 = HEAP32[$0 + 272 >> 2];
 HEAP32[$0 + 272 >> 2] = $2;
 return $1;
}

function sqlite3WhereExprUsage($0, $1) {
 if (!$1) {
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 return sqlite3WhereExprUsageNN($0, $1);
}

function sqlite3CodeVerifySchema($0, $1) {
 var $2 = 0;
 $2 = HEAP32[$0 + 116 >> 2];
 sqlite3CodeVerifySchemaAtToplevel($2 ? $2 : $0, $1);
}

function pntz($0, $1) {
 $0 = __builtin_ctz($0 - 1 | 0);
 if (!$0) {
  $0 = __builtin_ctz($1);
  $0 = $0 ? $0 + 32 | 0 : 0;
 }
 return $0;
}

function isLookaside($0, $1) {
 var $2 = 0;
 $2 = HEAPU32[$0 + 352 >> 2] <= $1 >>> 0 ? HEAPU32[$0 + 356 >> 2] > $1 >>> 0 : $2;
 return $2;
}

function __wasm_rotl_i32($0, $1) {
 var $2 = 0;
 $2 = $1 & 31;
 $1 = 0 - $1 & 31;
 return (-1 >>> $2 & $0) << $2 | (-1 << $1 & $0) >>> $1;
}

function __wasm_i64_srem($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int4sdiv3Mod4mod_17h2cbb7bbf36e41d68E($0, $1, $2, $3);
 return $3;
}

function sqlite3FaultSim($0) {
 var $1 = 0, $2 = 0;
 $1 = HEAP32[16132];
 if ($1) {
  $2 = FUNCTION_TABLE[$1 | 0]($0) | 0;
 }
 return $2;
}

function jsonEachRowid($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 HEAP32[$1 >> 2] = HEAP32[$0 + 4 >> 2];
 HEAP32[$1 + 4 >> 2] = 0;
 return 0;
}

function invokeValueDestructor($0, $1, $2) {
 if ($1 + 1 >>> 0 >= 2) {
  FUNCTION_TABLE[$1 | 0]($0);
 }
 sqlite3_result_error_toobig($2);
}

function __wasm_i64_sdiv($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int4sdiv3Div3div17he78fc483e41d7ec7E($0, $1, $2, $3);
 return $3;
}

function sqlite3PcacheFetch($0, $1, $2) {
 return FUNCTION_TABLE[HEAP32[16100]](HEAP32[$0 + 44 >> 2], $1, HEAPU8[$0 + 33 | 0] & $2) | 0;
}

function unixSleep($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $1 = ($1 + 999999 | 0) / 1e6 | 0;
 sleep($1);
 return Math_imul($1, 1e6) | 0;
}

function sqlite3_bind_int($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return sqlite3_bind_int64($0, $1, $2, $2 >> 31) | 0;
}

function sqlite3IsTrueOrFalse($0) {
 if (!sqlite3StrICmp($0, 12326)) {
  return 268435456;
 }
 return !sqlite3StrICmp($0, 12859) << 29;
}

function sqlite3BtreeNewDb($0) {
 sqlite3BtreeEnter($0);
 $0 = HEAP32[$0 + 4 >> 2];
 HEAP32[$0 + 48 >> 2] = 0;
 return newDatabase($0);
}

function legalfunc$__wasi_fd_seek($0, $1, $2, $3, $4) {
 return legalimport$__wasi_fd_seek($0 | 0, $1 | 0, $2 | 0, $3 | 0, $4 | 0) | 0;
}

function __wasm_i64_mul($0, $1, $2, $3) {
 $3 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3);
 return $3;
}

function whereOrMove($0, $1) {
 var $2 = 0;
 $2 = HEAPU16[$1 >> 1];
 HEAP16[$0 >> 1] = $2;
 __memcpy($0 + 8 | 0, $1 + 8 | 0, $2 << 4);
}

function sqlite3_malloc($0) {
 var $1 = 0;
 if (!(sqlite3_initialize() | ($0 | 0) <= 0)) {
  $1 = sqlite3Malloc($0, 0);
 }
 return $1;
}

function sqlite3_create_function($0, $1, $2, $3, $4, $5, $6, $7) {
 return createFunctionApi($0, $1, $2, $3, $4, $5, $6, $7, 0, 0, 0);
}

function sqlite3WalkerDepthIncrease($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
 return 0;
}

function sqlite3VdbeSetVarmask($0, $1) {
 HEAP32[$0 + 224 >> 2] = HEAP32[$0 + 224 >> 2] | (($1 | 0) > 31 ? -2147483648 : 1 << $1 - 1);
}

function sqlite3OsFullPathname($0, $1, $2, $3) {
 HEAP8[$3 | 0] = 0;
 return FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, $1, $2, $3) | 0;
}

function robustFchown($0, $1, $2) {
 if (!(FUNCTION_TABLE[HEAP32[16300]]() | 0)) {
  FUNCTION_TABLE[HEAP32[16297]]($0, $1, $2) | 0;
 }
}

function memdbDlClose($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $0 = HEAP32[$0 + 20 >> 2];
 FUNCTION_TABLE[HEAP32[$0 + 52 >> 2]]($0, $1);
}

function sqlite3_realloc64($0, $1, $2) {
 var $3 = 0;
 if (!sqlite3_initialize()) {
  $3 = sqlite3Realloc($0, $1, $2);
 }
 return $3;
}

function sqlite3StatusHighwater($0, $1) {
 $0 = ($0 << 2) + 70416 | 0;
 if (HEAPU32[$0 >> 2] < $1 >>> 0) {
  HEAP32[$0 >> 2] = $1;
 }
}

function sqlite3PagerUnrefPageOne($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 20 >> 2];
 sqlite3PcacheRelease($0);
 pagerUnlockIfUnused($1);
}

function sqlite3BtreeIntegerKey($0) {
 getCellInfo($0);
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 36 >> 2];
 return HEAP32[$0 + 32 >> 2];
}

function setPageReferenced($0, $1) {
 $0 = HEAP32[$0 + 8 >> 2] + ($1 >>> 3 | 0) | 0;
 HEAP8[$0 | 0] = HEAPU8[$0 | 0] | 1 << ($1 & 7);
}

function setDestPgsz($0) {
 return sqlite3BtreeSetPageSize(HEAP32[$0 + 4 >> 2], sqlite3BtreeGetPageSize(HEAP32[$0 + 24 >> 2]), 0, 0);
}

function freePage($0, $1) {
 if (!HEAP32[$1 >> 2]) {
  HEAP32[$1 >> 2] = freePage2(HEAP32[$0 + 52 >> 2], $0, HEAP32[$0 + 4 >> 2]);
 }
}

function sqlite3_uri_parameter($0, $1) {
 var $2 = 0;
 if (!(!$0 | !$1)) {
  $2 = uriParameter(databaseName($0), $1);
 }
 return $2;
}

function dotlockClose($0) {
 $0 = $0 | 0;
 dotlockUnlock($0, 0);
 sqlite3_free(HEAP32[$0 + 24 >> 2]);
 closeUnixFile($0);
 return 0;
}

function __localtime_r($0) {
 tzset();
 _localtime_js($0 | 0, 71052);
 HEAP32[17773] = HEAP32[(HEAP32[17771] ? 71044 : 71040) >> 2];
}

function sqlite3_result_error_toobig($0) {
 HEAP32[$0 + 20 >> 2] = 18;
 sqlite3VdbeMemSetStr(HEAP32[$0 >> 2], 11976, -1, -1, 1, 0);
}

function sqlite3PagerMaxPageCount($0, $1) {
 if (!$1) {
  return HEAP32[$0 + 160 >> 2];
 }
 HEAP32[$0 + 160 >> 2] = $1;
 return $1;
}

function sqlite3HashInit($0) {
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 HEAP32[$0 + 12 >> 2] = 0;
}

function innerLoopLoadRow($0, $1, $2) {
 sqlite3ExprCodeExprList($0, HEAP32[$1 + 28 >> 2], HEAP32[$2 >> 2], 0, HEAPU8[$2 + 4 | 0]);
}

function exprCodeSubselect($0, $1) {
 var $2 = 0;
 if (HEAPU8[$1 | 0] == 138) {
  $2 = sqlite3CodeSubselect($0, $1);
 }
 return $2;
}

function sqlite3_stricmp($0, $1) {
 if (!$0) {
  return $1 ? -1 : 0;
 }
 if (!$1) {
  return 1;
 }
 return sqlite3StrICmp($0, $1);
}

function sqlite3SetString($0, $1, $2) {
 $2 = sqlite3DbStrDup($1, $2);
 sqlite3DbFree($1, HEAP32[$0 >> 2]);
 HEAP32[$0 >> 2] = $2;
}

function sqlite3OsSync($0, $1) {
 if (!$1) {
  return 0;
 }
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 20 >> 2]]($0, $1) | 0;
}

function sqlite3BitvecCreate($0) {
 var $1 = 0;
 $1 = sqlite3MallocZero(512, 0);
 if ($1) {
  HEAP32[$1 >> 2] = $0;
 }
 return $1;
}

function legalstub$sqlite3_result_int64($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_int64($0, $1, $2);
}

function estLog($0) {
 var $1 = 0;
 if (($0 | 0) >= 11) {
  $1 = sqlite3LogEst($0 & 65535, 0) - 33 | 0;
 }
 return $1 << 16 >> 16;
}

function access($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return __syscall_ret(__syscall_faccessat(-100, $0 | 0, $1 | 0, 0) | 0) | 0;
}

function whereScanInitIndexExpr($0) {
 HEAP8[$0 + 24 | 0] = sqlite3ExprAffinity(HEAP32[$0 + 12 >> 2]);
 return whereScanNext($0);
}

function sqlite3DbMallocRaw($0, $1, $2) {
 if ($0) {
  return sqlite3DbMallocRawNN($0, $1, $2);
 }
 return sqlite3Malloc($1, $2);
}

function sqlite3BtreeIncrblobCursor($0) {
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] | 16;
 HEAP8[HEAP32[$0 + 8 >> 2] + 11 | 0] = 1;
}

function pushDownWindowCheck($0, $1, $2) {
 return sqlite3ExprIsConstantOrGroupBy($0, $2, HEAP32[HEAP32[$1 + 68 >> 2] + 8 >> 2]);
}

function fts3MatchinfoLcsCb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 HEAP32[($1 << 4) + $2 >> 2] = $0;
 return 0;
}

function freeP4Mem($0, $1) {
 if (HEAP32[$1 + 24 >> 2]) {
  sqlite3DbFree($0, HEAP32[$1 + 32 >> 2]);
 }
 sqlite3DbFreeNN($0, $1);
}

function __syscall_ret($0) {
 if ($0 >>> 0 >= 4294963201) {
  HEAP32[__errno_location() >> 2] = 0 - $0;
  $0 = -1;
 }
 return $0;
}

function sqlite3SetTextEncoding($0, $1) {
 HEAP8[$0 + 84 | 0] = $1;
 HEAP32[$0 + 8 >> 2] = sqlite3FindCollSeq($0, $1, 32384, 0);
}

function sqlite3OsWrite($0, $1, $2, $3, $4) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 12 >> 2]]($0, $1, $2, $3, $4) | 0;
}

function sqlite3OsShmMap($0, $1, $2, $3) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 52 >> 2]]($0, $1, 32768, $2, $3) | 0;
}

function sqlite3BtreeGetReserveNoMutex($0) {
 $0 = HEAP32[$0 + 4 >> 2];
 return HEAP32[$0 + 36 >> 2] - HEAP32[$0 + 40 >> 2] | 0;
}

function fp_barrier($0) {
 var $1 = 0;
 $1 = __stack_pointer - 16 | 0;
 HEAPF64[$1 + 8 >> 3] = $0;
 return HEAPF64[$1 + 8 >> 3];
}

function columnMallocFailure($0) {
 if ($0) {
  HEAP32[$0 + 36 >> 2] = sqlite3ApiExit(HEAP32[$0 >> 2], HEAP32[$0 + 36 >> 2]);
 }
}

function windowArgCount($0) {
 $0 = HEAP32[HEAP32[$0 + 72 >> 2] + 20 >> 2];
 if (!$0) {
  return 0;
 }
 return HEAP32[$0 >> 2];
}

function sqlite3PagerIsMemdb($0) {
 var $1 = 0;
 $1 = 1;
 $1 = HEAPU8[$0 + 12 | 0] ? $1 : HEAPU8[$0 + 16 | 0] != 0;
 return $1;
}

function sqlite3DbMallocZero($0, $1, $2) {
 $0 = sqlite3DbMallocRaw($0, $1, $2);
 if ($0) {
  memset($0, 0, $1);
 }
 return $0;
}

function memdbAccess($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 HEAP32[$3 >> 2] = 0;
 return 0;
}

function unicodeDestroy($0) {
 $0 = $0 | 0;
 if ($0) {
  sqlite3_free(HEAP32[$0 + 12 >> 2]);
  sqlite3_free($0);
 }
 return 0;
}

function sqlite3VdbeSerialTypeLen($0) {
 if ($0 >>> 0 >= 128) {
  return $0 - 12 >>> 1 | 0;
 }
 return HEAPU8[$0 + 33216 | 0];
}

function sqlite3OsRead($0, $1, $2, $3, $4) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 8 >> 2]]($0, $1, $2, $3, $4) | 0;
}

function gatherSelectWindowsSelectCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return HEAP32[$0 + 24 >> 2] != ($1 | 0) | 0;
}

function close($0) {
 $0 = $0 | 0;
 $0 = __wasi_fd_close($0 | 0) | 0;
 return __wasi_syscall_ret(($0 | 0) == 27 ? 0 : $0) | 0;
}

function walUnlockExclusive($0, $1, $2) {
 if (!HEAPU8[$0 + 43 | 0]) {
  sqlite3OsShmLock(HEAP32[$0 + 4 >> 2], $1, $2, 9);
 }
}

function sqlite3OsOpen($0, $1, $2, $3, $4) {
 return FUNCTION_TABLE[HEAP32[$0 + 24 >> 2]]($0, $1, $2, $3 & 17334143, $4) | 0;
}

function legalfunc$__syscall_ftruncate64($0, $1, $2) {
 return legalimport$__syscall_ftruncate64($0 | 0, $1 | 0, $2 | 0) | 0;
}

function exprRowColumn($0, $1) {
 $0 = sqlite3PExpr($0, 75, 0, 0);
 if ($0) {
  HEAP16[$0 + 32 >> 1] = $1 + 1;
 }
 return $0;
}

function sqlite3VdbeMemInit($0, $1, $2) {
 HEAP32[$0 + 24 >> 2] = 0;
 HEAP32[$0 + 20 >> 2] = $1;
 HEAP16[$0 + 16 >> 1] = $2;
}

function sqlite3VdbeMakeLabel($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 56 >> 2] - 1 | 0;
 HEAP32[$0 + 56 >> 2] = $1;
 return $1;
}

function sqlite3SectorSize($0) {
 $0 = sqlite3OsSectorSize($0);
 return ($0 | 0) < 32 ? 512 : ($0 | 0) < 65536 ? $0 : 65536;
}

function simpleDelim($0, $1) {
 var $2 = 0;
 $2 = $1 << 24 >> 24 >= 0 ? HEAPU8[($0 + $1 | 0) + 4 | 0] != 0 : $2;
 return $2;
}

function mkdir($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return __syscall_ret(__syscall_mkdirat(-100, $0 | 0, $1 | 0) | 0) | 0;
}

function fts3ReallocOrFree($0, $1, $2) {
 $1 = sqlite3_realloc64($0, $1, $2);
 if (!$1) {
  sqlite3_free($0);
 }
 return $1;
}

function sqlite3_malloc64($0, $1) {
 var $2 = 0;
 if (!sqlite3_initialize()) {
  $2 = sqlite3Malloc($0, $1);
 }
 return $2;
}

function sqlite3WalkerDepthDecrease($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] - 1;
}

function sqlite3BtreeClearTableOfCursor($0) {
 return sqlite3BtreeClearTable(HEAP32[$0 + 8 >> 2], HEAP32[$0 + 64 >> 2], 0);
}

function jsonNodeSize($0) {
 var $1 = 0;
 $1 = 1;
 $1 = HEAPU8[$0 | 0] >= 6 ? HEAP32[$0 + 4 >> 2] + 1 | 0 : $1;
 return $1;
}

function unixGetLastError($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return HEAP32[__errno_location() >> 2];
}

function sqlite3_prepare_v3($0, $1, $2, $3, $4, $5) {
 return sqlite3LockAndPrepare($0, $1, $2, $3 & 15 | 128, 0, $4, $5);
}

function sqlite3OsShmLock($0, $1, $2, $3) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 56 >> 2]]($0, $1, $2, $3) | 0;
}

function sqlite3BtreeClearCursor($0) {
 sqlite3_free(HEAP32[$0 + 16 >> 2]);
 HEAP8[$0 | 0] = 1;
 HEAP32[$0 + 16 >> 2] = 0;
}

function setDoNotMergeFlagOnCopy($0) {
 if (HEAPU8[sqlite3VdbeGetOp($0, -1) | 0] == 80) {
  sqlite3VdbeChangeP5($0, 1);
 }
}

function pcache1Fetch($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 return pcache1FetchNoMutex($0, $1, $2) | 0;
}

function pagerExclusiveLock($0) {
 var $1 = 0;
 $1 = pagerLockDb($0, 4);
 if ($1) {
  pagerUnlockDb($0, 1);
 }
 return $1;
}

function dynCall_iiiiiij($0, $1, $2, $3, $4, $5, $6, $7) {
 return FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4, $5, $6, $7) | 0;
}

function vdbePmaReaderIncrInit($0) {
 if (!HEAP32[$0 + 48 >> 2]) {
  return 0;
 }
 return vdbePmaReaderIncrMergeInit($0);
}

function sqlite3_result_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 sqlite3VdbeMemSetInt64(HEAP32[$0 >> 2], $1, $1 >> 31);
}

function sqlite3ValueFromExpr($0, $1, $2, $3, $4) {
 if (!$1) {
  return 0;
 }
 return valueFromExpr($0, $1, $2, $3, $4);
}

function sqlite3JournalModename($0) {
 var $1 = 0;
 $1 = ($0 | 0) != 6 ? HEAP32[($0 << 2) + 33424 >> 2] : $1;
 return $1;
}

function sqlite3ExprDeferredDelete($0, $1) {
 HEAP32[$0 + 68 >> 2] = sqlite3ExprListAppend($0, HEAP32[$0 + 68 >> 2], $1);
}

function pagerUnlockIfUnused($0) {
 if (!sqlite3PcacheRefCount(HEAP32[$0 + 228 >> 2])) {
  pagerUnlockAndRollback($0);
 }
}

function sqlite3VdbeMemRelease($0) {
 if (HEAP32[$0 + 24 >> 2] ? 1 : HEAPU8[$0 + 17 | 0] & 144) {
  vdbeMemClear($0);
 }
}

function sqlite3VdbeLinkSubProgram($0, $1) {
 HEAP32[$1 + 24 >> 2] = HEAP32[$0 + 228 >> 2];
 HEAP32[$0 + 228 >> 2] = $1;
}

function returnSingleText($0, $1) {
 if ($1) {
  sqlite3VdbeLoadString($0, 1, $1);
  sqlite3VdbeAddOp2($0, 84, 1, 1);
 }
}

function btreeInvokeBusyHandler($0) {
 $0 = $0 | 0;
 return sqlite3InvokeBusyHandler(HEAP32[$0 + 4 >> 2] + 444 | 0) | 0;
}

function sqlite3_value_subtype($0) {
 var $1 = 0;
 $1 = HEAPU8[$0 + 17 | 0] & 8 ? HEAPU8[$0 + 19 | 0] : $1;
 return $1;
}

function sqlite3_column_int($0, $1) {
 $1 = sqlite3_value_int(columnMem($0, $1));
 columnMallocFailure($0);
 return $1;
}

function sqlite3ValueFree($0) {
 if ($0) {
  sqlite3VdbeMemRelease($0);
  sqlite3DbFreeNN(HEAP32[$0 + 20 >> 2], $0);
 }
}

function sqlite3Fts3MallocZero($0, $1) {
 $1 = sqlite3_malloc64($0, $1);
 if ($1) {
  memset($1, 0, $0);
 }
 return $1;
}

function sqlite3Fts3IsIdChar($0) {
 var $1 = 0;
 $1 = 1;
 $1 = $0 & 128 ? $1 : HEAPU8[$0 + 54880 | 0] != 0;
 return $1;
}

function fts3SegReaderCursorAddZero($0, $1, $2, $3, $4) {
 return fts3SegReaderCursor($0, $1, 0, -2, $2, $3, 0, 0, $4);
}

function dbMallocRawFinish($0, $1, $2) {
 $1 = sqlite3Malloc($1, $2);
 if (!$1) {
  sqlite3OomFault($0);
 }
 return $1;
}

function sqlite3_total_changes64($0) {
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 116 >> 2];
 return HEAP32[$0 + 112 >> 2];
}

function sqlite3_last_insert_rowid($0) {
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 44 >> 2];
 return HEAP32[$0 + 40 >> 2];
}

function seekAndWrite($0, $1, $2, $3, $4) {
 return seekAndWriteFd(HEAP32[$0 + 12 >> 2], $1, $2, $3, $4, $0 + 20 | 0);
}

function piFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_double($0, 3.141592653589793);
}

function walUnlockShared($0, $1) {
 if (!HEAPU8[$0 + 43 | 0]) {
  sqlite3OsShmLock(HEAP32[$0 + 4 >> 2], $1, 1, 5);
 }
}

function sourceidFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_text($0, 22472, -1, 0);
}

function vdbeSorterGetCompare($0) {
 $0 = HEAPU8[$0 + 60 | 0];
 return ($0 | 0) == 1 ? 30 : ($0 | 0) == 2 ? 31 : 32;
}

function vdbeSafety($0) {
 var $1 = 0;
 if (!HEAP32[$0 >> 2]) {
  sqlite3_log(21, 2664, 0);
  $1 = 1;
 }
 return $1;
}

function sqlite3_blob_bytes($0) {
 var $1 = 0;
 $1 = !$0 | !HEAP32[$0 + 16 >> 2] ? $1 : HEAP32[$0 >> 2];
 return $1;
}

function sqlite3OsCheckReservedLock($0, $1) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 36 >> 2]]($0, $1) | 0;
}

function sqlite3BitvecTest($0, $1) {
 if (!$0) {
  return 0;
 }
 return (sqlite3BitvecTestNotNull($0, $1) | 0) != 0;
}

function doubleConsonant($0) {
 if (!isConsonant($0)) {
  return 0;
 }
 return HEAPU8[$0 | 0] == HEAPU8[$0 + 1 | 0];
}

function __expo2($0, $1) {
 return $1 * 2247116418577895e292 * exp($0 + -1416.0996898839683) * 2247116418577895e292;
}

function versionFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 sqlite3_result_text($0, 1024, -1, 0);
}

function unixDeviceCharacteristics($0) {
 $0 = $0 | 0;
 setDeviceCharacteristics($0);
 return HEAP32[$0 + 48 >> 2];
}

function sqlite3VdbeMemNulTerminate($0) {
 if ((HEAPU16[$0 + 16 >> 1] & 514) == 2) {
  vdbeMemAddTerminator($0);
 }
}

function sqlite3OsTruncate($0, $1, $2) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 16 >> 2]]($0, $1, $2) | 0;
}

function btreeCursorWithLock($0, $1, $2, $3, $4) {
 sqlite3BtreeEnter($0);
 return btreeCursor($0, $1, $2, $3, $4);
}

function yy_find_reduce_action($0, $1) {
 return HEAPU16[(HEAP16[($0 << 1) + 49856 >> 1] + $1 << 1) + 42368 >> 1];
}

function vdbeSorterFlushPMA($0) {
 HEAP8[$0 + 56 | 0] = 1;
 return vdbeSorterListToPMA($0 - -64 | 0, $0 + 36 | 0);
}

function sqlite3RowSetDelete($0) {
 $0 = $0 | 0;
 sqlite3RowSetClear($0);
 sqlite3DbFree(HEAP32[$0 + 4 >> 2], $0);
}

function sqlite3VtabArgInit($0) {
 addArgumentToVtab($0);
 HEAP32[$0 + 252 >> 2] = 0;
 HEAP32[$0 + 256 >> 2] = 0;
}

function sqlite3BeginBenignMalloc() {
 var $0 = 0;
 $0 = HEAP32[17745];
 if ($0) {
  FUNCTION_TABLE[$0 | 0]();
 }
}

function fts3RollbackToMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 sqlite3Fts3PendingTermsClear($0);
 return 0;
}

function autoIncStep($0, $1, $2) {
 if (($1 | 0) > 0) {
  sqlite3VdbeAddOp2(HEAP32[$0 + 8 >> 2], 159, $1, $2);
 }
}

function subjournalPageIfRequired($0) {
 if (!subjRequiresPage($0)) {
  return 0;
 }
 return subjournalPage($0);
}

function stackAlloc($0) {
 $0 = $0 | 0;
 $0 = __stack_pointer - $0 & -16;
 __stack_pointer = $0;
 return $0 | 0;
}

function sqlite3_result_double($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 sqlite3VdbeMemSetDouble(HEAP32[$0 >> 2], $1);
}

function sqlite3_changes64($0) {
 i64toi32_i32$HIGH_BITS = HEAP32[$0 + 108 >> 2];
 return HEAP32[$0 + 104 >> 2];
}

function sqlite3MallocZero($0, $1) {
 $1 = sqlite3Malloc($0, $1);
 if ($1) {
  memset($1, 0, $0);
 }
 return $1;
}

function fts3HashMalloc($0, $1) {
 $1 = sqlite3_malloc64($0, $1);
 if ($1) {
  memset($1, 0, $0);
 }
 return $1;
}

function binaryCompareP5($0, $1, $2) {
 return (sqlite3CompareAffinity($0, sqlite3ExprAffinity($1)) | $2) & 255;
}

function vdbeSafetyNotNull($0) {
 if (!$0) {
  sqlite3_log(21, 2709, 0);
  return 1;
 }
 return vdbeSafety($0);
}

function sqlite3ResolvePartIdxLabel($0, $1) {
 if ($1) {
  sqlite3VdbeResolveLabel(HEAP32[$0 + 8 >> 2], $1);
 }
}

function sqlite3MultiWrite($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 116 >> 2];
 HEAP8[($1 ? $1 : $0) + 20 | 0] = 1;
}

function sqlite3Fts3SegmentsClose($0) {
 sqlite3_blob_close(HEAP32[$0 + 252 >> 2]);
 HEAP32[$0 + 252 >> 2] = 0;
}

function sqlite3EndBenignMalloc() {
 var $0 = 0;
 $0 = HEAP32[17746];
 if ($0) {
  FUNCTION_TABLE[$0 | 0]();
 }
}

function __wasi_syscall_ret($0) {
 if (!$0) {
  return 0;
 }
 HEAP32[__errno_location() >> 2] = $0;
 return -1;
}

function sqlite3WalLimit($0, $1, $2) {
 if ($0) {
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $2;
 }
}

function sqlite3ExprListDelete($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if ($1) {
  exprListDeleteNN($0, $1);
 }
}

function getPageReferenced($0, $1) {
 return HEAPU8[HEAP32[$0 + 8 >> 2] + ($1 >>> 3 | 0) | 0] & 1 << ($1 & 7);
}

function vdbeClrCopy($0, $1, $2) {
 vdbeMemClearExternAndSetNull($0);
 sqlite3VdbeMemShallowCopy($0, $1, $2);
}

function sqlite3PagerGet($0, $1, $2, $3) {
 return FUNCTION_TABLE[HEAP32[$0 + 220 >> 2]]($0, $1, $2, $3) | 0;
}

function sqlite3MayAbort($0) {
 var $1 = 0;
 $1 = HEAP32[$0 + 116 >> 2];
 HEAP8[($1 ? $1 : $0) + 21 | 0] = 1;
}

function sqlite3ExprDelete($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if ($1) {
  sqlite3ExprDeleteNN($0, $1);
 }
}

function sqlite3AbsInt32($0) {
 return ($0 | 0) < 0 ? ($0 | 0) == -2147483648 ? 2147483647 : 0 - $0 | 0 : $0;
}

function jsonOom($0) {
 HEAP8[$0 + 25 | 0] = 1;
 sqlite3_result_error_nomem(HEAP32[$0 >> 2]);
 jsonReset($0);
}

function walShmBarrier($0) {
 if (HEAPU8[$0 + 43 | 0] != 2) {
  sqlite3OsShmBarrier(HEAP32[$0 + 4 >> 2]);
 }
}

function unicodeClose($0) {
 $0 = $0 | 0;
 sqlite3_free(HEAP32[$0 + 20 >> 2]);
 sqlite3_free($0);
 return 0;
}

function sqlite3_set_last_insert_rowid($0, $1, $2) {
 HEAP32[$0 + 40 >> 2] = $1;
 HEAP32[$0 + 44 >> 2] = $2;
}

function sqlite3_column_count($0) {
 $0 = $0 | 0;
 if (!$0) {
  return 0;
 }
 return HEAPU16[$0 + 144 >> 1];
}

function sqlite3OsAccess($0, $1, $2, $3) {
 return FUNCTION_TABLE[HEAP32[$0 + 32 >> 2]]($0, $1, $2, $3) | 0;
}

function sqlite3BtreeSchemaLocked($0) {
 sqlite3BtreeEnter($0);
 return querySharedCacheTableLock($0, 1, 1);
}

function sqlite3BtreeGetJournalname($0) {
 return sqlite3PagerJournalname(HEAP32[HEAP32[$0 + 4 >> 2] >> 2]);
}

function sqlite3BtreeCreateTable($0, $1, $2) {
 sqlite3BtreeEnter($0);
 return btreeCreateTable($0, $1, $2);
}

function jsonReset($0) {
 if (!HEAPU8[$0 + 24 | 0]) {
  sqlite3_free(HEAP32[$0 + 4 >> 2]);
 }
 jsonZero($0);
}

function __munmap($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return __syscall_ret(__syscall_munmap($0, $1)) | 0;
}

function sqlite3ValueSetStr($0, $1, $2, $3) {
 if ($0) {
  sqlite3VdbeMemSetStr($0, $1, -1, -1, $2, $3);
 }
}

function sqlite3OsFileSize($0, $1) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 24 >> 2]]($0, $1) | 0;
}

function sqlite3FkReferences($0) {
 return sqlite3HashFind(HEAP32[$0 + 60 >> 2] + 56 | 0, HEAP32[$0 >> 2]);
}

function simpleClose($0) {
 $0 = $0 | 0;
 sqlite3_free(HEAP32[$0 + 20 >> 2]);
 sqlite3_free($0);
 return 0;
}

function porterClose($0) {
 $0 = $0 | 0;
 sqlite3_free(HEAP32[$0 + 20 >> 2]);
 sqlite3_free($0);
 return 0;
}

function freeP4FuncCtx($0, $1) {
 freeEphemeralFunction($0, HEAP32[$1 + 4 >> 2]);
 sqlite3DbFreeNN($0, $1);
}

function btreeClearHasContent($0) {
 sqlite3BitvecDestroy(HEAP32[$0 + 64 >> 2]);
 HEAP32[$0 + 64 >> 2] = 0;
}

function sqlite3StatusDown($0, $1) {
 $0 = ($0 << 2) + 70376 | 0;
 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] - $1;
}

function sqlite3SelectWalkFail($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 HEAP16[$0 + 20 >> 1] = 0;
 return 2;
}

function sqlite3SelectDelete($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if ($1) {
  clearSelect($0, $1, 1);
 }
}

function sqlite3ExprTruthValue($0) {
 return !HEAPU8[HEAP32[sqlite3ExprSkipCollate($0) + 8 >> 2] + 4 | 0];
}

function vdbeIncrFree($0) {
 if ($0) {
  vdbeMergeEngineFree(HEAP32[$0 + 4 >> 2]);
  sqlite3_free($0);
 }
}

function unixUnfetch($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 return 0;
}

function tableOfTrigger($0) {
 return sqlite3HashFind(HEAP32[$0 + 24 >> 2] + 8 | 0, HEAP32[$0 + 4 >> 2]);
}

function sqlite3_value_type($0) {
 $0 = $0 | 0;
 return HEAPU8[(HEAPU16[$0 + 16 >> 1] & 63) + 30192 | 0];
}

function sqlite3PagerSetSpillsize($0, $1) {
 return sqlite3PcacheSetSpillsize(HEAP32[$0 + 228 >> 2], $1);
}

function sqlite3PagerSetMmapLimit($0, $1, $2) {
 HEAP32[$0 + 136 >> 2] = $1;
 HEAP32[$0 + 140 >> 2] = $2;
}

function sqlite3OsUnlock($0, $1) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 32 >> 2]]($0, $1) | 0;
}

function sqlite3BtreeGetFilename($0) {
 return sqlite3PagerFilename(HEAP32[HEAP32[$0 + 4 >> 2] >> 2], 1);
}

function out2PrereleaseWithClear($0) {
 sqlite3VdbeMemSetNull($0);
 HEAP16[$0 + 16 >> 1] = 4;
 return $0;
}

function loadAnalysis($0, $1) {
 $0 = sqlite3GetVdbe($0);
 if ($0) {
  sqlite3VdbeAddOp1($0, 150, $1);
 }
}

function validJulianDay($0, $1) {
 return ($1 | 0) == 108096 & $0 >>> 0 < 275971584 | $1 >>> 0 < 108096;
}

function unixSectorSize($0) {
 $0 = $0 | 0;
 setDeviceCharacteristics($0);
 return HEAP32[$0 + 44 >> 2];
}

function sqlite3_column_name($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return columnName($0, $1, 0, 0) | 0;
}

function sqlite3BtreeDropTable($0, $1, $2) {
 sqlite3BtreeEnter($0);
 return btreeDropTable($0, $1, $2);
}

function exprStructSize($0) {
 $0 = HEAP32[$0 + 4 >> 2];
 return $0 & 65536 ? 12 : $0 & 16384 ? 28 : 52;
}

function dynCall_iijii($0, $1, $2, $3, $4, $5) {
 return FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4, $5) | 0;
}

function dynCall_iiiij($0, $1, $2, $3, $4, $5) {
 return FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4, $5) | 0;
}

function ctimestampFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 datetimeFunc($0, 0, 0);
}

function valueBytes($0, $1) {
 if (!valueToText($0, $1)) {
  return 0;
 }
 return HEAP32[$0 + 12 >> 2];
}

function unlink($0) {
 $0 = $0 | 0;
 return __syscall_ret(__syscall_unlinkat(-100, $0 | 0, 0) | 0) | 0;
}

function sqlite3_prepare($0, $1, $2, $3, $4) {
 return sqlite3LockAndPrepare($0, $1, $2, 0, 0, $3, $4);
}

function sqlite3OsLock($0, $1) {
 return FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 28 >> 2]]($0, $1) | 0;
}

function sqlite3ExprCodeMove($0, $1, $2, $3) {
 sqlite3VdbeAddOp3(HEAP32[$0 + 8 >> 2], 79, $1, $2, $3);
}

function nolockCheckReservedLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 HEAP32[$1 >> 2] = 0;
 return 0;
}

function fts3BeginMethod($0) {
 $0 = $0 | 0;
 HEAP32[$0 + 52 >> 2] = 0;
 return fts3SetHasStat($0) | 0;
}

function __strerror_l($0) {
 return HEAPU16[(($0 >>> 0 > 149 ? 0 : $0) << 1) + 63456 >> 1] + 61632 | 0;
}

function sqlite3TokenInit($0, $1) {
 HEAP32[$0 >> 2] = $1;
 HEAP32[$0 + 4 >> 2] = sqlite3Strlen30($1);
}

function sqlite3PcachePagecount($0) {
 return FUNCTION_TABLE[HEAP32[16099]](HEAP32[$0 + 44 >> 2]) | 0;
}

function pragmaVtabClose($0) {
 $0 = $0 | 0;
 pragmaVtabCursorClear($0);
 sqlite3_free($0);
 return 0;
}

function fts3tokCloseMethod($0) {
 $0 = $0 | 0;
 fts3tokResetCursor($0);
 sqlite3_free($0);
 return 0;
}

function freeEphemeralFunction($0, $1) {
 if (HEAPU8[$1 + 4 | 0] & 16) {
  sqlite3DbFreeNN($0, $1);
 }
}

function sqlite3DbFree($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 if ($1) {
  sqlite3DbFreeNN($0, $1);
 }
}

function unicodeIsAlnum($0, $1) {
 return sqlite3FtsUnicodeIsalnum($1) ^ unicodeIsException($0, $1);
}

function sqlite3_bind_parameter_count($0) {
 if (!$0) {
  return 0;
 }
 return HEAP16[$0 + 16 >> 1];
}

function sqlite3OsShmUnmap($0, $1) {
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 64 >> 2]]($0, $1) | 0;
}

function sqlite3_open($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return openDatabase($0, $1, 6, 0) | 0;
}

function sqlite3KeyInfoRef($0) {
 if ($0) {
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] + 1;
 }
 return $0;
}

function jsonEachEof($0) {
 $0 = $0 | 0;
 return HEAPU32[$0 + 12 >> 2] >= HEAPU32[$0 + 16 >> 2] | 0;
}
function sqlite3_sql($0) {
 $0 = $0 | 0;
 if (!$0) {
  return 0;
 }
 return HEAP32[$0 + 196 >> 2];
}

function sqlite3PagerSetCachesize($0, $1) {
 sqlite3PcacheSetCachesize(HEAP32[$0 + 228 >> 2], $1);
}

function jsonEachClose($0) {
 $0 = $0 | 0;
 jsonEachCursorReset($0);
 sqlite3_free($0);
 return 0;
}

function a_ctz_32($0) {
 return HEAP8[(Math_imul(0 - $0 & $0, 124511785) >>> 27 | 0) + 61600 | 0];
}

function sqlite3_create_module_v2($0, $1, $2, $3, $4) {
 return createModule($0, $1, $2, $3, $4);
}

function sqlite3VdbeLoadString($0, $1, $2) {
 return sqlite3VdbeAddOp4($0, 117, 0, $1, 0, $2, 0);
}

function sqlite3Fts3InitTok($0, $1) {
 return sqlite3_create_module_v2($0, 12193, 55092, $1, 94);
}

function codeOffset($0, $1, $2) {
 if (($1 | 0) > 0) {
  sqlite3VdbeAddOp3($0, 49, $1, $2, 1);
 }
}

function __wasm_ctz_i32($0) {
 if ($0) {
  return 31 - Math_clz32($0 - 1 ^ $0) | 0;
 }
 return 32;
}
function sqliteAuthBadReturnCode($0) {
 sqlite3ErrorMsg($0, 9852, 0);
 HEAP32[$0 + 12 >> 2] = 1;
}

function sqlite3WalHeapMemory($0) {
 if (!$0) {
  return 0;
 }
 return HEAPU8[$0 + 43 | 0] == 2;
}

function sqlite3PagerRekey($0, $1, $2) {
 HEAP16[$0 + 28 >> 1] = $2;
 sqlite3PcacheMove($0, $1);
}

function sqlite3ExprDup($0, $1, $2) {
 if (!$1) {
  return 0;
 }
 return exprDup($0, $1, $2, 0);
}

function fts3CloseMethod($0) {
 $0 = $0 | 0;
 fts3ClearCursor($0);
 sqlite3_free($0);
 return 0;
}

function sqlite3AutoincrementEnd($0) {
 if (HEAP32[$0 + 112 >> 2]) {
  autoIncrementEnd($0);
 }
}

function pagerOpentemp($0, $1, $2) {
 return sqlite3OsOpen(HEAP32[$0 >> 2], 0, $1, $2 | 30, 0);
}

function dynCall_iiji($0, $1, $2, $3, $4) {
 return FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4) | 0;
}

function ctimeFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 timeFunc($0, 0, 0);
}

function cdateFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 dateFunc($0, 0, 0);
}

function sqlite3VdbeMemReleaseMalloc($0) {
 if (HEAP32[$0 + 24 >> 2]) {
  vdbeMemClear($0);
 }
}

function sqlite3SkipAccumulatorLoad($0) {
 HEAP8[$0 + 25 | 0] = 1;
 HEAP32[$0 + 20 >> 2] = -1;
}

function sqlite3Fts3SelectDocsize($0, $1, $2, $3) {
 return fts3SelectDocsize($0, $1, $2, $3);
}

function sqlite3CommitInternalChanges($0) {
 HEAP32[$0 + 24 >> 2] = HEAP32[$0 + 24 >> 2] & -2;
}

function memjrnlClose($0) {
 $0 = $0 | 0;
 memjrnlFreeChunks(HEAP32[$0 + 12 >> 2]);
 return 0;
}

function fts3SetEstimatedRows($0) {
 HEAP32[$0 + 48 >> 2] = 0;
 HEAP32[$0 + 52 >> 2] = 262144;
}

function unixTempFileInit() {
 HEAP32[16324] = getenv(18990);
 HEAP32[16325] = getenv(18997);
}

function sqlite3_wal_checkpoint($0, $1) {
 return sqlite3_wal_checkpoint_v2($0, $1, 0, 0, 0);
}

function sqlite3_result_int64($0, $1, $2) {
 sqlite3VdbeMemSetInt64(HEAP32[$0 >> 2], $1, $2);
}

function sqlite3JournalSize($0) {
 $0 = HEAP32[$0 + 4 >> 2];
 return ($0 | 0) > 64 ? $0 : 64;
}

function sqlite3IsBinary($0) {
 if (!$0) {
  return 1;
 }
 return HEAP32[$0 + 12 >> 2] == 10;
}

function fts3RollbackMethod($0) {
 $0 = $0 | 0;
 sqlite3Fts3PendingTermsClear($0);
 return 0;
}

function sqlite3_free_filename($0) {
 if ($0) {
  sqlite3_free(databaseName($0) - 4 | 0);
 }
}

function sqlite3VdbeChangeP3($0, $1, $2) {
 HEAP32[sqlite3VdbeGetOp($0, $1) + 12 >> 2] = $2;
}

function lstat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return fstatat(-100, $0, $1, 256) | 0;
}

function whereAndInfoDelete($0, $1) {
 sqlite3WhereClauseClear($1);
 sqlite3DbFree($0, $1);
}

function sqlite3VdbeJumpHere($0, $1) {
 sqlite3VdbeChangeP2($0, $1, HEAP32[$0 + 108 >> 2]);
}

function sqlite3VdbeExplainPop($0) {
 HEAP32[$0 + 220 >> 2] = sqlite3VdbeExplainParent($0);
}

function sqlite3VdbeChangeP2($0, $1, $2) {
 HEAP32[sqlite3VdbeGetOp($0, $1) + 8 >> 2] = $2;
}

function sqlite3VdbeChangeP1($0, $1, $2) {
 HEAP32[sqlite3VdbeGetOp($0, $1) + 4 >> 2] = $2;
}

function sqlite3OsSleep($0, $1) {
 return FUNCTION_TABLE[HEAP32[$0 + 60 >> 2]]($0, $1) | 0;
}

function sqlite3HashFind($0, $1) {
 return HEAP32[findElementWithHash($0, $1, 0) + 8 >> 2];
}

function sqlite3ClearTempRegCache($0) {
 HEAP32[$0 + 28 >> 2] = 0;
 HEAP8[$0 + 19 | 0] = 0;
}

function callStatGet($0, $1, $2) {
 sqlite3VdbeAddFunctionCall($0, 0, $1, $2, 1, 49816, 0);
}

function whereOrInfoDelete($0, $1) {
 sqlite3WhereClauseClear($1);
 sqlite3DbFree($0, $1);
}

function vdbeMemTypeName($0) {
 return HEAP32[(sqlite3_value_type($0) << 2) + 33356 >> 2];
}

function unixUnlock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return posixUnlock($0, $1) | 0;
}

function sqlite3_str_appendall($0, $1) {
 sqlite3_str_append($0, $1, sqlite3Strlen30($1));
}

function sqlite3VdbeAddOp2($0, $1, $2, $3) {
 return sqlite3VdbeAddOp3($0, $1, $2, $3, 0);
}

function sqlite3Strlen30($0) {
 if (!$0) {
  return 0;
 }
 return strlen($0) & 1073741823;
}

function sqlite3OsShmBarrier($0) {
 FUNCTION_TABLE[HEAP32[HEAP32[$0 >> 2] + 60 >> 2]]($0);
}

function sqlite3ExprIsConstantOrFunction($0, $1) {
 return exprIsConst($0, $1 + 4 | 0, 0);
}

function sqlite3BtreeTxnState($0) {
 if (!$0) {
  return 0;
 }
 return HEAPU8[$0 + 8 | 0];
}

function rmdir($0) {
 $0 = $0 | 0;
 return __syscall_ret(__syscall_rmdir($0 | 0) | 0) | 0;
}

function jsonInit($0, $1) {
 HEAP8[$0 + 25 | 0] = 0;
 HEAP32[$0 >> 2] = $1;
 jsonZero($0);
}

function fts3SegReaderCursorFree($0) {
 sqlite3Fts3SegReaderFinish($0);
 sqlite3_free($0);
}

function walPagesize($0) {
 $0 = HEAPU16[$0 + 66 >> 1];
 return ($0 | $0 << 16) & 130560;
}

function stat($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return fstatat(-100, $0, $1, 0) | 0;
}

function sqlite3_result_null($0) {
 $0 = $0 | 0;
 sqlite3VdbeMemSetNull(HEAP32[$0 >> 2]);
}

function sqlite3_create_module($0, $1, $2, $3) {
 return createModule($0, $1, $2, $3, 0);
}

function sqlite3VdbeFreeCursor($0, $1) {
 if ($1) {
  sqlite3VdbeFreeCursorNN($0, $1);
 }
}

function sqlite3VdbeChangeOpcode($0, $1, $2) {
 HEAP8[sqlite3VdbeGetOp($0, $1) | 0] = $2;
}

function sqlite3PagerWalCallback($0) {
 return sqlite3WalCallback(HEAP32[$0 + 232 >> 2]);
}

function sqlite3BtreeEnter($0) {
 HEAP32[HEAP32[$0 + 4 >> 2] + 4 >> 2] = HEAP32[$0 >> 2];
}

function __wasm_call_ctors() {
 __emscripten_environ_constructor();
 init_pthread_self();
}

function sqlite3_vtab_on_conflict($0) {
 return HEAPU8[HEAPU8[$0 + 92 | 0] + 30543 | 0];
}

function sqlite3VdbeCountChanges($0) {
 HEAP8[$0 + 150 | 0] = HEAPU8[$0 + 150 | 0] | 16;
}

function sqlite3ValueApplyAffinity($0, $1, $2) {
 applyAffinity($0, $1 << 24 >> 24, $2);
}

function sqlite3PcacheShrink($0) {
 FUNCTION_TABLE[HEAP32[16105]](HEAP32[$0 + 44 >> 2]);
}

function sqlite3PagerClearCache($0) {
 if (!HEAPU8[$0 + 12 | 0]) {
  pager_reset($0);
 }
}

function sqlite3BtreePayload($0, $1, $2, $3) {
 return accessPayload($0, $1, $2, $3, 0);
}

function sqlite3BtreeIsReadonly($0) {
 return HEAP16[HEAP32[$0 + 4 >> 2] + 24 >> 1] & 1;
}

function sqlite3WalkExpr($0, $1) {
 if (!$1) {
  return 0;
 }
 return walkExpr($0, $1);
}

function sqlite3PcacheClose($0) {
 FUNCTION_TABLE[HEAP32[16104]](HEAP32[$0 + 44 >> 2]);
}

function setGetterMethod($0) {
 HEAP32[$0 + 220 >> 2] = HEAP32[$0 + 44 >> 2] ? 17 : 18;
}

function sqlite3_value_bytes($0) {
 $0 = $0 | 0;
 return sqlite3ValueBytes($0, 1) | 0;
}

function sqlite3_blob_read($0, $1, $2, $3) {
 return blobReadWrite($0, $1, $2, $3, 6);
}

function sqlite3BtreePayloadSize($0) {
 getCellInfo($0);
 return HEAP32[$0 + 44 >> 2];
}

function dynCall_iij($0, $1, $2, $3) {
 return FUNCTION_TABLE[$0 | 0]($1, $2, $3) | 0;
}

function whereLoopDelete($0, $1) {
 whereLoopClear($0, $1);
 sqlite3DbFreeNN($0, $1);
}

function statAccumDestructor($0) {
 $0 = $0 | 0;
 sqlite3DbFree(HEAP32[$0 >> 2], $0);
}

function sqlite3WritableSchema($0) {
 return (HEAP32[$0 + 32 >> 2] & 268435457) == 1;
}

function sqlite3VdbeAddOp1($0, $1, $2) {
 return sqlite3VdbeAddOp3($0, $1, $2, 0, 0);
}

function sqlite3BtreeGetPageSize($0) {
 return HEAP32[HEAP32[$0 + 4 >> 2] + 36 >> 2];
}

function sqlite3BtreeCursorUnpin($0) {
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] & 191;
}

function sqlite3_value_text($0) {
 $0 = $0 | 0;
 return sqlite3ValueText($0, 1) | 0;
}

function sqlite3_value_double($0) {
 $0 = $0 | 0;
 return +sqlite3VdbeRealValue($0);
}

function sqlite3StrDup($0) {
 return strcpy(sqlite3_malloc(strlen($0) + 1 | 0), $0);
}

function sqlite3Fts3InitAux($0) {
 return sqlite3_create_module($0, 1375, 54384, 0);
}

function sqlite3BackupUpdate($0, $1, $2) {
 if ($0) {
  backupUpdate($0, $1, $2);
 }
}

function sqlite3Attach($0, $1, $2, $3) {
 codeAttach($0, 24, 49556, $1, $1, $2, $3);
}

function fts3_isalnum($0) {
 return $0 - 48 >>> 0 < 10 | ($0 & -33) - 65 >>> 0 < 26;
}

function dynCall_viji($0, $1, $2, $3, $4) {
 FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4);
}

function sqlite3_value_int($0) {
 $0 = $0 | 0;
 return sqlite3VdbeIntValue($0) | 0;
}

function sqlite3_context_db_handle($0) {
 return HEAP32[HEAP32[$0 >> 2] + 20 >> 2];
}

function sqlite3StatusValue() {
 i64toi32_i32$HIGH_BITS = 0;
 return HEAP32[17594];
}

function sqlite3RegisterDateTimeFunctions() {
 sqlite3InsertBuiltinFuncs(68864, 9);
}

function sqlite3CantopenError($0) {
 sqlite3ReportError(14, $0, 13407);
 return 14;
}

function sqlite3GetBoolean($0, $1) {
 return (getSafetyLevel($0, 1, $1) | 0) != 0;
}

function sqlite3BtreeCursorPin($0) {
 HEAP8[$0 + 1 | 0] = HEAPU8[$0 + 1 | 0] | 64;
}

function releasePageNotNull($0) {
 sqlite3PagerUnrefNotNull(HEAP32[$0 + 72 >> 2]);
}

function jsonParseFree($0) {
 $0 = $0 | 0;
 jsonParseReset($0);
 sqlite3_free($0);
}

function fts3SetUniqueFlag($0) {
 HEAP32[$0 + 56 >> 2] = HEAP32[$0 + 56 >> 2] | 1;
}

function clearYMD_HMS_TZ($0) {
 HEAP8[$0 + 44 | 0] = 0;
 HEAP16[$0 + 42 >> 1] = 0;
}

function sqlite3_strlike($0, $1, $2) {
 return patternCompare($0, $1, 30284, $2);
}

function sqlite3TestExtInit($0) {
 $0 = $0 | 0;
 return sqlite3FaultSim(500) | 0;
}

function sqlite3PagerPagecount($0, $1) {
 HEAP32[$1 >> 2] = HEAP32[$0 + 28 >> 2];
}

function sqlite3MisuseError($0) {
 sqlite3ReportError(21, $0, 12600);
 return 21;
}

function sqlite3CorruptError($0) {
 sqlite3ReportError(11, $0, 9738);
 return 11;
}

function seriesNext($0) {
 $0 = $0 | 0;
 progressSequence($0 + 8 | 0);
 return 0;
}

function dotlockIoFinderImpl($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 32024;
}

function sqlite3VtabLock($0) {
 HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + 1;
}

function sqlite3VdbeAddOp0($0, $1) {
 return sqlite3VdbeAddOp3($0, $1, 0, 0, 0);
}

function sqlite3RegisterJsonFunctions() {
 sqlite3InsertBuiltinFuncs(69232, 19);
}

function sqlite3BtreeLastPage($0) {
 return btreePagecount(HEAP32[$0 + 4 >> 2]);
}

function nolockIoFinderImpl($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 31948;
}

function fts3tokEofMethod($0) {
 $0 = $0 | 0;
 return !HEAP32[$0 + 16 >> 2] | 0;
}

function sqlite3_changes($0) {
 $0 = $0 | 0;
 return sqlite3_changes64($0) | 0;
}

function sqlite3SelectWalkNoop($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function sqlite3MallocSize($0) {
 return FUNCTION_TABLE[HEAP32[16079]]($0) | 0;
}

function sqlite3ExprIsVector($0) {
 return (sqlite3ExprVectorSize($0) | 0) > 1;
}

function sqlite3BtreeEnterCursor($0) {
 sqlite3BtreeEnter(HEAP32[$0 + 8 >> 2]);
}

function pragmaVtabDisconnect($0) {
 $0 = $0 | 0;
 sqlite3_free($0);
 return 0;
}

function posixIoFinderImpl($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 31872;
}

function walCkptInfo($0) {
 return HEAP32[HEAP32[$0 + 32 >> 2] >> 2] + 96 | 0;
}

function sqlite3_value_frombind($0) {
 return HEAPU16[$0 + 16 >> 1] >>> 6 & 1;
}

function sqlite3_user_data($0) {
 return HEAP32[HEAP32[$0 + 4 >> 2] + 8 >> 2];
}

function sqlite3_close_v2($0) {
 $0 = $0 | 0;
 return sqlite3Close($0, 1) | 0;
}

function sqlite3WalkWinDefnDummyCallback($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
}

function sqlite3VdbeOneByteSerialTypeLen($0) {
 return HEAPU8[$0 + 33216 | 0];
}

function sqlite3VdbeGoto($0, $1) {
 return sqlite3VdbeAddOp3($0, 8, 0, $1, 0);
}

function sqlite3PagerUnref($0) {
 if ($0) {
  sqlite3PagerUnrefNotNull($0);
 }
}

function sqlite3PagerShrink($0) {
 sqlite3PcacheShrink(HEAP32[$0 + 228 >> 2]);
}

function sqlite3PagerPageRefcount($0) {
 return sqlite3PcachePageRefcount($0);
}

function sqlite3Fts3GetVarint($0, $1) {
 return sqlite3Fts3GetVarintU($0, $1);
}

function sqlite3FixSelect($0, $1) {
 return sqlite3WalkSelect($0 + 4 | 0, $1);
}

function sqlite3CteDelete($0, $1) {
 cteClear($0, $1);
 sqlite3DbFree($0, $1);
}

function sqlite3BtreeCursorHasHint($0) {
 return HEAPU8[$0 + 3 | 0] >>> 1 & 1;
}

function releasePageOne($0) {
 sqlite3PagerUnrefPageOne(HEAP32[$0 + 72 >> 2]);
}

function nanosleep($0) {
 return __syscall_ret(0 - __clock_nanosleep($0) | 0);
}

function isLimitTerm($0) {
 return (HEAPU8[$0 + 15 | 0] - 73 & 255) >>> 0 < 2;
}

function sqlite3_strglob($0, $1) {
 return patternCompare($0, $1, 30280, 91);
}

function sqlite3ParserFallback($0) {
 return HEAPU16[($0 << 1) + 35840 >> 1];
}

function sqlite3ExprWalkNoop($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function sqlite3ExprIsTableConstant($0, $1) {
 return exprIsConst($0, 3, $1);
}

function noopStepFunc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
}

function jsonEachDisconnect($0) {
 $0 = $0 | 0;
 sqlite3_free($0);
 return 0;
}

function __math_uflow($0) {
 return __math_xflow($0, 12882297539194267e-247);
}

function sqlite3UpsertDelete($0, $1) {
 if ($1) {
  upsertDelete($0, $1);
 }
}

function pragmaVtabEof($0) {
 $0 = $0 | 0;
 return !HEAP32[$0 + 4 >> 2] | 0;
}

function map_make($0, $1) {
 HEAP32[$0 >> 2] = 0;
 HEAP32[$0 + 4 >> 2] = $1;
}

function isFatalError($0) {
 return !$0 | ($0 | 0) == 5 ? 0 : ($0 | 0) != 6;
}

function fsync($0) {
 return __wasi_syscall_ret(__wasi_fd_sync($0 | 0) | 0);
}

function sqlite3WhereUsesDeferredSeek($0) {
 return HEAP8[$0 + 52 | 0] & 1;
}

function sqlite3VdbeHasSubProgram($0) {
 return HEAP32[$0 + 228 >> 2] != 0;
}

function seriesDisconnect($0) {
 $0 = $0 | 0;
 sqlite3_free($0);
 return 0;
}

function pcache1Pagecount($0) {
 $0 = $0 | 0;
 return HEAP32[$0 + 48 >> 2];
}

function fts3auxEofMethod($0) {
 $0 = $0 | 0;
 return HEAP32[$0 + 88 >> 2];
}

function fts3ReleaseMethod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function __math_oflow($0) {
 return __math_xflow($0, 3105036184601418e216);
}

function sqlite3WindowFunctions() {
 sqlite3InsertBuiltinFuncs(68256, 15);
}

function sqlite3WhereIsSorted($0) {
 return HEAPU8[$0 + 52 | 0] >>> 3 & 1;
}

function sqlite3MemJournalOpen($0) {
 sqlite3JournalOpen(0, 0, $0, 0, -1);
}

function sqlite3IsIdChar($0) {
 return (HEAPU8[$0 + 30288 | 0] & 70) != 0;
}

function sqlite3FixExpr($0, $1) {
 return sqlite3WalkExpr($0 + 4 | 0, $1);
}

function sqlite3ExprIsConstantNotJoin($0) {
 return exprIsConst($0, 2, 0);
}

function sqlite3Detach($0, $1) {
 codeAttach($0, 25, 49672, $1, 0, 0, $1);
}

function sqlite3BtreePager($0) {
 return HEAP32[HEAP32[$0 + 4 >> 2] >> 2];
}

function map_iterate($0, $1, $2) {
 node_iterate(HEAP32[$0 >> 2], $1, $2);
}

function strrchr($0, $1) {
 return __memrchr($0, $1, strlen($0) + 1 | 0);
}

function sqlite3OsCloseFree($0) {
 sqlite3OsClose($0);
 sqlite3_free($0);
}

function sqlite3JournalIsInMemory($0) {
 return HEAP32[$0 >> 2] == 32184;
}

function sqlite3Fts3SimpleTokenizerModule($0) {
 HEAP32[$0 >> 2] = 54640;
}

function sqlite3Fts3PorterTokenizerModule($0) {
 HEAP32[$0 >> 2] = 54668;
}

function sqlite3BtreePayloadFetch($0, $1) {
 return fetchPayload($0, $1);
}

function emscripten_get_heap_size() {
 return __wasm_memory_size() << 16;
}

function sqlite3VdbeRunOnlyOnce($0) {
 sqlite3VdbeAddOp2($0, 166, 1, 1);
}

function sqlite3PagerTruncateImage($0, $1) {
 HEAP32[$0 + 28 >> 2] = $1;
}

function sqlite3OpcodeName($0) {
 return HEAP32[($0 << 2) + 32416 >> 2];
}

function sqlite3MemSize($0) {
 $0 = $0 | 0;
 return HEAP32[$0 - 8 >> 2];
}

function sqlite3BtreeIsInBackup($0) {
 return HEAP32[$0 + 16 >> 2] != 0;
}

function sqlite3AlterFunctions() {
 sqlite3InsertBuiltinFuncs(68048, 5);
}

function simpleDestroy($0) {
 $0 = $0 | 0;
 sqlite3_free($0);
 return 0;
}

function seriesEof($0) {
 $0 = $0 | 0;
 return !HEAPU8[$0 + 56 | 0] | 0;
}

function porterDestroy($0) {
 $0 = $0 | 0;
 sqlite3_free($0);
 return 0;
}

function minMaxFinalize($0) {
 $0 = $0 | 0;
 minMaxValueFinalize($0, 0);
}

function map_insert($0, $1) {
 node_insert($0, HEAP32[$0 + 4 >> 2], $1);
}

function sqlite3WhereOutputRowCount($0) {
 return HEAP16[$0 + 54 >> 1];
}

function sqlite3BtreeCursorHintFlags($0, $1) {
 HEAP8[$0 + 3 | 0] = $1;
}

function nolockClose($0) {
 $0 = $0 | 0;
 closeUnixFile($0);
 return 0;
}

function jsonObjectValue($0) {
 $0 = $0 | 0;
 jsonObjectCompute($0, 0);
}

function jsonObjectFinal($0) {
 $0 = $0 | 0;
 jsonObjectCompute($0, 1);
}

function __math_xflow($0, $1) {
 return fp_barrier($0 ? -$1 : $1) * $1;
}

function sqlite3WhereContinueLabel($0) {
 return HEAP32[$0 + 32 >> 2];
}

function sqlite3PcachePageRefcount($0) {
 return HEAP16[$0 + 30 >> 1];
}

function sqlite3HexToInt($0) {
 return ($0 << 25 >> 31 & 9) + $0 & 15;
}

function sqlite3BtreeCursorHasMoved($0) {
 return HEAPU8[$0 | 0] != 0;
}

function seriesClose($0) {
 $0 = $0 | 0;
 sqlite3_free($0);
 return 0;
}

function nolockUnlock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function walIndexHdr($0) {
 return HEAP32[HEAP32[$0 + 32 >> 2] >> 2];
}

function sqlite3PagerJournalname($0) {
 return HEAP32[$0 + 188 >> 2];
}

function sqlite3PagerGetJournalMode($0) {
 return HEAPU8[$0 + 5 | 0];
}

function sqlite3PagerDataVersion($0) {
 return HEAP32[$0 + 108 >> 2];
}

function nodeReaderRelease($0) {
 sqlite3_free(HEAP32[$0 + 24 >> 2]);
}

function minMaxValue($0) {
 $0 = $0 | 0;
 minMaxValueFinalize($0, 1);
}

function memjrnlSync($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function memdbDeviceCharacteristics($0) {
 $0 = $0 | 0;
 return 5633;
}

function jsonArrayValue($0) {
 $0 = $0 | 0;
 jsonArrayCompute($0, 0);
}

function jsonArrayFinal($0) {
 $0 = $0 | 0;
 jsonArrayCompute($0, 1);
}

function sqlite3_value_text16($0) {
 return sqlite3ValueText($0, 2);
}

function sqlite3VdbeResetStepResult($0) {
 HEAP32[$0 + 36 >> 2] = 0;
}

function sqlite3VdbePrepareFlags($0) {
 return HEAPU8[$0 + 148 | 0];
}

function sqlite3VdbeCurrentAddr($0) {
 return HEAP32[$0 + 108 >> 2];
}

function sqlite3TempInMemory($0) {
 return HEAPU8[$0 + 86 | 0] == 2;
}

function sqlite3Fts3UnicodeTokenizer($0) {
 HEAP32[$0 >> 2] = 51504;
}

function pcache1Shutdown($0) {
 $0 = $0 | 0;
 memset(70876, 0, 100);
}

function nolockLock($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function ftsCompareFunction($0) {
 return ($0 | 0) == 1 ? 102 : 103;
}

function datetimeError($0) {
 HEAP8[memset($0, 0, 48) + 46 | 0] = 1;
}

function sqlite3_value_int64($0) {
 return sqlite3VdbeIntValue($0);
}

function sqlite3WhereBreakLabel($0) {
 return HEAP32[$0 + 36 >> 2];
}

function sqlite3PagerTempSpace($0) {
 return HEAP32[$0 + 224 >> 2];
}

function sqlite3MemRoundup($0) {
 $0 = $0 | 0;
 return $0 + 7 & -8;
}

function sqlite3ExprIsConstant($0) {
 return exprIsConst($0, 1, 0);
}

function sqlite3BtreeCursorIsValidNN($0) {
 return !HEAPU8[$0 | 0];
}

function memdbSync($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 return 0;
}

function jsonHexToInt($0) {
 return ($0 << 25 >> 31 & 9) + $0 & 15;
}

function strncpy($0, $1, $2) {
 __stpncpy($0, $1, $2);
 return $0;
}

function sqlite3WhereIsDistinct($0) {
 return HEAPU8[$0 + 51 | 0];
}

function sqlite3PcacheRefCount($0) {
 return HEAP32[$0 + 12 >> 2];
}

function sqlite3PagerIsreadonly($0) {
 return HEAPU8[$0 + 14 | 0];
}

function releasePage($0) {
 if ($0) {
  releasePageNotNull($0);
 }
}

function stackRestore($0) {
 $0 = $0 | 0;
 __stack_pointer = $0;
}

function sqlite3_bind_null($0, $1) {
 return vdbeUnbind($0, $1);
}

function sqlite3WhereIsOrdered($0) {
 return HEAP8[$0 + 49 | 0];
}

function sqlite3PcacheClear($0) {
 sqlite3PcacheTruncate($0, 0);
}

function sqlite3PagerGetExtra($0) {
 return HEAP32[$0 + 8 >> 2];
}

function sqlite3MemFree($0) {
 $0 = $0 | 0;
 dlfree($0 - 8 | 0);
}

function sqlite3PagerGetData($0) {
 return HEAP32[$0 + 4 >> 2];
}

function sqlite3BtreeSharable($0) {
 return HEAPU8[$0 + 9 | 0];
}

function ftsHashFunction($0) {
 return ($0 | 0) == 1 ? 96 : 97;
}

function computeYMD_HMS($0) {
 computeYMD($0);
 computeHMS($0);
}

function sqlite3VdbeParser($0) {
 return HEAP32[$0 + 12 >> 2];
}

function sqlite3ValueSetNull($0) {
 sqlite3VdbeMemSetNull($0);
}

function isblank($0) {
 return ($0 | 0) == 32 | ($0 | 0) == 9;
}

function storeLastErrno($0, $1) {
 HEAP32[$0 + 20 >> 2] = $1;
}

function sqlite3PagerFile($0) {
 return HEAP32[$0 + 64 >> 2];
}

function rad2deg($0) {
 return $0 * 180 / 3.141592653589793;
}

function deg2rad($0) {
 return $0 * 3.141592653589793 / 180;
}

function sqlite3CompileOptions($0) {
 HEAP32[$0 >> 2] = 41;
}

function sqlite3BtreeEof($0) {
 return HEAPU8[$0 | 0] != 0;
}

function localtime($0) {
 __localtime_r($0);
 return 71052;
}

function btreePagecount($0) {
 return HEAP32[$0 + 48 >> 2];
}

function toupper($0) {
 return islower($0) ? $0 & 95 : $0;
}

function tolower($0) {
 return isupper($0) ? $0 | 32 : $0;
}

function sqlite3WalFile($0) {
 return HEAP32[$0 + 8 >> 2];
}

function sqlite3VtabRollback($0) {
 callFinaliser($0, 68);
}

function sqlite3PageMalloc($0) {
 return pcache1Alloc($0);
}

function map_destroy($0) {
 node_destroy(HEAP32[$0 >> 2]);
}

function walHash($0) {
 return Math_imul($0, 383) & 8191;
}

function sqlite3_close($0) {
 return sqlite3Close($0, 0);
}

function sqlite3PagerBackupPtr($0) {
 return $0 + 96 | 0;
}

function sqlite3HeapNearlyFull() {
 return HEAP32[17622];
}

function sqlite3BitvecSize($0) {
 return HEAP32[$0 >> 2];
}

function isalpha($0) {
 return ($0 | 32) - 97 >>> 0 < 26;
}

function xcalloc($0, $1, $2) {
 return dlcalloc($0, $1);
}

function strcpy($0, $1) {
 __stpcpy($0, $1);
 return $0;
}

function sqlite3_value_free($0) {
 sqlite3ValueFree($0);
}

function sqlite3VtabCommit($0) {
 callFinaliser($0, 64);
}

function setTempRet0($0) {
 $0 = $0 | 0;
 tempRet0 = $0;
}

function fts3CommitMethod($0) {
 $0 = $0 | 0;
 return 0;
}

function walFramePage($0) {
 return $0 + 33 >>> 12 | 0;
}

function sqlite3_libversion_number() {
 return 3039003;
}

function sqlite3PagerVfs($0) {
 return HEAP32[$0 >> 2];
}

function fts3PendingListDelete($0) {
 sqlite3_free($0);
}

function utimes($0, $1) {
 return __futimesat($0, $1);
}

function sqlite3MemInit($0) {
 $0 = $0 | 0;
 return 0;
}

function init_pthread_self() {
 HEAP32[17775] = 71136;
}

function unixGetpagesize() {
 return sysconf(30) | 0;
}

function sqlite3VdbeDb($0) {
 return HEAP32[$0 >> 2];
}

function sqlite3PagerRef($0) {
 sqlite3PcacheRef($0);
}

function valueNew($0) {
 return sqlite3ValueNew($0);
}

function opPrecedence($0) {
 return HEAP32[$0 >> 2];
}

function tzset() {
 _tzset_js(71032, 71036, 71040);
}

function stackSave() {
 return __stack_pointer | 0;
}

function sqlite3OsFetch($0) {
 HEAP32[$0 >> 2] = 0;
}

function sqlite3NoopDestructor($0) {
 $0 = $0 | 0;
}

function isupper($0) {
 return $0 - 65 >>> 0 < 26;
}

function islower($0) {
 return $0 - 97 >>> 0 < 26;
}

function __builtin_ctz($0) {
 return a_ctz_32($0);
}

function walNextHash($0) {
 return $0 + 1 & 8191;
}

function walIteratorFree($0) {
 sqlite3_free($0);
}

function strerror($0) {
 return __strerror_l($0);
}

function sqlite3PageFree($0) {
 pcache1Free($0);
}

function sqlite3MemShutdown($0) {
 $0 = $0 | 0;
}

function getTempRet0() {
 return tempRet0 | 0;
}

function fts3HashFree($0) {
 sqlite3_free($0);
}

function full_fsync($0) {
 return fsync($0);
}

function floor($0) {
 return Math_floor($0);
}

function __errno_location() {
 return 71028;
}

function unixShmBarrier($0) {
 $0 = $0 | 0;
}

function sqrt($0) {
 return Math_sqrt($0);
}

function noopValueFunc($0) {
 $0 = $0 | 0;
}

function __fe_raise_inexact() {
 return 0;
}

function fabs($0) {
 return Math_abs($0);
}

function coth($0) {
 return 1 / tanh($0);
}

function cot($0) {
 return 1 / tan($0);
}

function __fe_getround() {
 return 0;
}

function xfree($0) {
 dlfree($0);
}

function getpid() {
 return 42;
}

function geteuid() {
 return 0;
}


// EMSCRIPTEN_END_FUNCS

;
 bufferView = HEAPU8;
 initActiveSegments(env);
 var FUNCTION_TABLE = Table([null, sqlite3OomClear, sqlite3NoopDestructor, sqlite3_free, sqlite3VdbeFrameMemDel, sqlite3InitCallback, sqlite3BtreePayloadChecked, sqliteDefaultBusyCallback, sqlite3InvalidFunction, sqlite3WalDefaultHook, binCollFunc, nocaseCollatingFunc, rtrimCollFunc, sqlite3SchemaClear, pagerStress, pageReinit, btreeInvokeBusyHandler, getPageError, getPageNormal, btreeParseCellPtrIndex, cellSizePtr, btreeParseCellPtr, btreeParseCellPtrNoPayload, cellSizePtrTableLeaf, cellSizePtrNoPayload, sqlite3RowSetDelete, analysisLoader, sqlite3VdbeRecordCompare, vdbeRecordCompareInt, vdbeRecordCompareString, vdbeSorterCompareInt, vdbeSorterCompareText, vdbeSorterCompare, sqlite3ExprListDelete, agginfoFree, sqlite3DeleteReturning, sqlite3WithDelete, renameUnmapSelectCb, renameUnmapExprCb, sqlite3WalkWinDefnDummyCallback, fixSelectCb, fixExprCb, disallowAggregatesInOrderByCb, sqlite3WalkerDepthIncrease, sqlite3WalkerDepthDecrease, sqlite3WindowExtraAggFuncDepth, sqlite3DbFree, impliesNotNullRow, sqlite3DeleteTable, sqlite3SelectDelete, sqlite3SelectWalkNoop, propagateConstantExprRewrite, havingToWhereExprCb, analyzeAggregate, sqlite3ExprIfFalse, resolveExprStep, resolveSelectStep, checkConstraintExprNode, exprColumnFlagUnion, sqlite3SelectWalkFail, exprNodeIsConstant, sqlite3ExprIfTrue, likeFunc, sqlite3SelectPopWith, gatherSelectWindowsSelectCallback, gatherSelectWindowsCallback, selectRefEnter, exprRefToSrcList, selectRefLeave, sqlite3ExprDelete, incrAggDepth, sqlite3ExprWalkNoop, convertCompoundSelectToSubquery, selectExpander, selectAddSubqueryTypeInfo, resolveRemoveWindowsCb, agginfoPersistExprCb, selectWindowRewriteSelectCb, selectWindowRewriteExprCb, renumberCursorsCb, recomputeColumnsUsedExpr, exprNodeIsDeterministic, exprNodeIsConstantOrGroupBy, whereIndexExprTransNode, whereIndexExprTransColumn, exprIdxCover, noopStepFunc, statAccumDestructor, renameColumnSelectCb, renameColumnExprCb, renameTableSelectCb, renameTableExprCb, renameQuotefixExprCb, jsonParseFree, hashDestroy, fts3TokenizerFunc, fts3StrHash, fts3BinHash, fts3SegReaderDoclistCmpRev, fts3SegReaderDoclistCmp, fts3SegReaderCmp, fts3CompareElemByTerm, fts3StrCompare, fts3BinCompare, m_gt_0, hasVowel, m_gt_1, fts3ExprTermOffsetInit, fts3SnippetFindPositions, fts3ExprLoadDoclistsCb, fts3ExprPhraseCountCb, fts3MIBufferFree, fts3ExprGlobalHitsCb, fts3ExprLocalHitsCb, fts3MatchinfoLcsCb, unixOpen, unixDelete, unixAccess, unixFullPathname, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, posixIoFinderImpl, nolockIoFinderImpl, dotlockIoFinderImpl, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, unixUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, posixOpen, close, access, getcwd, stat, fstat, ftruncate, fcntl, read, write, fchmod, unlink, openDirectory, mkdir, rmdir, fchown, geteuid, __mmap, __munmap, unixGetpagesize, readlink, lstat, nolockClose, nolockLock, nolockUnlock, nolockCheckReservedLock, dotlockClose, dotlockLock, dotlockUnlock, dotlockCheckReservedLock, memdbClose, memdbRead, memdbWrite, memdbTruncate, memdbSync, memdbFileSize, memdbLock, memdbFileControl, memdbDeviceCharacteristics, memdbFetch, memdbUnfetch, memjrnlClose, memjrnlRead, memjrnlWrite, memjrnlTruncate, memjrnlSync, memjrnlFileSize, pragmaVtabConnect, pragmaVtabBestIndex, pragmaVtabDisconnect, pragmaVtabOpen, pragmaVtabClose, pragmaVtabFilter, pragmaVtabNext, pragmaVtabEof, pragmaVtabColumn, pragmaVtabRowid, attachFunc, detachFunc, statInit, statPush, statGet, versionFunc, compileoptionusedFunc, compileoptiongetFunc, trimFunc, minmaxFunc, minmaxStep, minMaxFinalize, minMaxValue, typeofFunc, subtypeFunc, lengthFunc, instrFunc, printfFunc, unicodeFunc, charFunc, absFunc, roundFunc, upperFunc, lowerFunc, hexFunc, randomFunc, randomBlob, nullifFunc, sourceidFunc, errlogFunc, quoteFunc, last_insert_rowid, changes, total_changes, replaceFunc, zeroblobFunc, substrFunc, sumStep, sumFinalize, sumInverse, totalFinalize, avgFinalize, countStep, countFinalize, countInverse, groupConcatStep, groupConcatFinalize, groupConcatValue, groupConcatInverse, signFunc, renameColumnFunc, renameTableFunc, renameTableTest, dropColumnFunc, renameQuotefixFunc, row_numberStepFunc, row_numberValueFunc, dense_rankStepFunc, dense_rankValueFunc, rankStepFunc, rankValueFunc, percent_rankStepFunc, percent_rankValueFunc, percent_rankInvFunc, cume_distStepFunc, cume_distValueFunc, cume_distInvFunc, ntileStepFunc, ntileValueFunc, ntileInvFunc, last_valueStepFunc, last_valueFinalizeFunc, last_valueValueFunc, last_valueInvFunc, nth_valueStepFunc, nth_valueFinalizeFunc, noopValueFunc, first_valueStepFunc, first_valueFinalizeFunc, juliandayFunc, unixepochFunc, dateFunc, timeFunc, datetimeFunc, strftimeFunc, ctimeFunc, ctimestampFunc, cdateFunc, jsonRemoveFunc, jsonArrayFunc, jsonArrayLengthFunc, jsonExtractFunc, jsonSetFunc, jsonObjectFunc, jsonPatchFunc, jsonQuoteFunc, jsonReplaceFunc, jsonTypeFunc, jsonValidFunc, jsonArrayStep, jsonArrayFinal, jsonArrayValue, jsonGroupInverse, jsonObjectStep, jsonObjectFinal, jsonObjectValue, memdbOpen, memdbAccess, memdbFullPathname, memdbDlOpen, memdbDlError, memdbDlSym, memdbDlClose, memdbRandomness, memdbSleep, memdbGetLastError, memdbCurrentTimeInt64, sqlite3MemMalloc, sqlite3MemFree, sqlite3MemRealloc, sqlite3MemSize, sqlite3MemRoundup, sqlite3MemInit, sqlite3MemShutdown, pcache1Init, pcache1Shutdown, pcache1Create, pcache1Cachesize, pcache1Pagecount, pcache1Fetch, pcache1Unpin, pcache1Rekey, pcache1Truncate, pcache1Destroy, pcache1Shrink, sqlite3Fts3Init, sqlite3TestExtInit, sqlite3JsonTableFunctions, fts3CreateMethod, fts3ConnectMethod, fts3BestIndexMethod, fts3DisconnectMethod, fts3DestroyMethod, fts3OpenMethod, fts3CloseMethod, fts3FilterMethod, fts3NextMethod, fts3EofMethod, fts3ColumnMethod, fts3RowidMethod, fts3UpdateMethod, fts3BeginMethod, fts3SyncMethod, fts3CommitMethod, fts3RollbackMethod, fts3FindFunctionMethod, fts3RenameMethod, fts3SavepointMethod, fts3ReleaseMethod, fts3RollbackToMethod, fts3ShadowName, unicodeCreate, unicodeDestroy, unicodeOpen, unicodeClose, unicodeNext, fts3auxConnectMethod, fts3auxBestIndexMethod, fts3auxDisconnectMethod, fts3auxOpenMethod, fts3auxCloseMethod, fts3auxFilterMethod, fts3auxNextMethod, fts3auxEofMethod, fts3auxColumnMethod, fts3auxRowidMethod, simpleCreate, simpleDestroy, simpleOpen, simpleClose, simpleNext, porterCreate, porterDestroy, porterOpen, porterClose, porterNext, fts3SnippetFunc, fts3OffsetsFunc, fts3OptimizeFunc, fts3MatchinfoFunc, fts3tokConnectMethod, fts3tokBestIndexMethod, fts3tokDisconnectMethod, fts3tokOpenMethod, fts3tokCloseMethod, fts3tokFilterMethod, fts3tokNextMethod, fts3tokEofMethod, fts3tokColumnMethod, fts3tokRowidMethod, jsonEachConnect, jsonEachBestIndex, jsonEachDisconnect, jsonEachOpenEach, jsonEachClose, jsonEachFilter, jsonEachNext, jsonEachEof, jsonEachColumn, jsonEachRowid, jsonEachOpenTree, seriesConnect, seriesBestIndex, seriesDisconnect, seriesOpen, seriesClose, seriesFilter, seriesNext, seriesEof, seriesColumn, seriesRowid, int_cmp, double_cmp, modeIterate, medianIterate, acosFunc, asinFunc, atanFunc, atn2Func, acoshFunc, asinhFunc, atanhFunc, differenceFunc, rad2degFunc, deg2radFunc, cosFunc, sinFunc, tanFunc, cotFunc, coshFunc, sinhFunc, tanhFunc, cothFunc, expFunc, logFunc, log10Func, powerFunc, signFunc_1, sqrtFunc, squareFunc, ceilFunc, floorFunc, piFunc, replicateFunc, charindexFunc, leftFunc, rightFunc, reverseFunc, properFunc, padlFunc, padrFunc, padcFunc, strfilterFunc, varianceStep, stdevFinalize, varianceFinalize, modeStep, modeFinalize, medianFinalize, lower_quartileFinalize, upper_quartileFinalize]);
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
}
 
 return {
  "__wasm_call_ctors": __wasm_call_ctors, 
  "sqlite3_free": sqlite3_free, 
  "sqlite3_value_double": sqlite3_value_double, 
  "sqlite3_value_text": sqlite3_value_text, 
  "__errno_location": __errno_location, 
  "sqlite3_prepare_v2": sqlite3_prepare_v2, 
  "sqlite3_step": sqlite3_step, 
  "sqlite3_finalize": sqlite3_finalize, 
  "sqlite3_reset": sqlite3_reset, 
  "sqlite3_value_int": sqlite3_value_int, 
  "sqlite3_clear_bindings": sqlite3_clear_bindings, 
  "sqlite3_value_blob": sqlite3_value_blob, 
  "sqlite3_value_bytes": sqlite3_value_bytes, 
  "sqlite3_value_type": sqlite3_value_type, 
  "sqlite3_result_blob": sqlite3_result_blob, 
  "sqlite3_result_double": sqlite3_result_double, 
  "sqlite3_result_error": sqlite3_result_error, 
  "sqlite3_result_int": sqlite3_result_int, 
  "sqlite3_result_int64": legalstub$sqlite3_result_int64, 
  "sqlite3_result_null": sqlite3_result_null, 
  "sqlite3_result_text": sqlite3_result_text, 
  "sqlite3_sql": sqlite3_sql, 
  "sqlite3_aggregate_context": sqlite3_aggregate_context, 
  "sqlite3_column_count": sqlite3_column_count, 
  "sqlite3_data_count": sqlite3_data_count, 
  "sqlite3_column_blob": sqlite3_column_blob, 
  "sqlite3_column_bytes": sqlite3_column_bytes, 
  "sqlite3_column_double": sqlite3_column_double, 
  "sqlite3_column_text": sqlite3_column_text, 
  "sqlite3_column_type": sqlite3_column_type, 
  "sqlite3_column_name": sqlite3_column_name, 
  "sqlite3_bind_blob": sqlite3_bind_blob, 
  "sqlite3_bind_double": sqlite3_bind_double, 
  "sqlite3_bind_int": sqlite3_bind_int, 
  "sqlite3_bind_text": sqlite3_bind_text, 
  "sqlite3_bind_parameter_index": sqlite3_bind_parameter_index, 
  "sqlite3_normalized_sql": sqlite3_normalized_sql, 
  "sqlite3_errmsg": sqlite3_errmsg, 
  "sqlite3_exec": sqlite3_exec, 
  "sqlite3_changes": sqlite3_changes, 
  "sqlite3_close_v2": sqlite3_close_v2, 
  "sqlite3_create_function_v2": sqlite3_create_function_v2, 
  "sqlite3_open": sqlite3_open, 
  "malloc": dlmalloc, 
  "free": dlfree, 
  "__indirect_function_table": FUNCTION_TABLE, 
  "sqlite3_series_init": sqlite3_series_init, 
  "RegisterExtensionFunctions": RegisterExtensionFunctions, 
  "emscripten_builtin_memalign": emscripten_builtin_memalign, 
  "setTempRet0": setTempRet0, 
  "getTempRet0": getTempRet0, 
  "stackSave": stackSave, 
  "stackRestore": stackRestore, 
  "stackAlloc": stackAlloc, 
  "dynCall_iiiij": legalstub$dynCall_iiiij, 
  "dynCall_iij": legalstub$dynCall_iij, 
  "dynCall_iijii": legalstub$dynCall_iijii, 
  "dynCall_iiji": legalstub$dynCall_iiji, 
  "dynCall_iiiiiij": legalstub$dynCall_iiiiiij, 
  "dynCall_viji": legalstub$dynCall_viji
};
}

  return asmFunc(asmLibraryArg);
}
// EMSCRIPTEN_END_ASM




)(asmLibraryArg);
  },

  instantiate: /** @suppress{checkTypes} */ function(binary, info) {
    return {
      then: function(ok) {
        var module = new WebAssembly.Module(binary);
        ok({
          'instance': new WebAssembly.Instance(module)
        });
      }
    };
  },

  RuntimeError: Error
};

// We don't need to actually download a wasm binary, mark it as present but empty.
wasmBinary = [];

// end include: wasm2js.js
if (typeof WebAssembly != 'object') {
  abort('no native wasm support detected');
}

// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    // This build was created without ASSERTIONS defined.  `assert()` should not
    // ever be called in this configuration but in case there are callers in
    // the wild leave this simple abort() implemenation here for now.
    abort(text);
  }
}

// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf8') : undefined;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.
/**
 * heapOrArray is either a regular array, or a JavaScript typed array view.
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
  }
  var str = '';
  // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
  while (idx < endPtr) {
    // For UTF8 byte structure, see:
    // http://en.wikipedia.org/wiki/UTF-8#Description
    // https://www.ietf.org/rfc/rfc2279.txt
    // https://tools.ietf.org/html/rfc3629
    var u0 = heapOrArray[idx++];
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    var u1 = heapOrArray[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    var u2 = heapOrArray[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
    }

    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var c = str.charCodeAt(i); // possibly a lead surrogate
    if (c <= 0x7F) {
      len++;
    } else if (c <= 0x7FF) {
      len += 2;
    } else if (c >= 0xD800 && c <= 0xDFFF) {
      len += 4; ++i;
    } else {
      len += 3;
    }
  }
  return len;
}

// end include: runtime_strings.js
// Memory management

var HEAP,
/** @type {!ArrayBuffer} */
  buffer,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

// In non-standalone/normal mode, we create the memory here.
// include: runtime_init_memory.js


// Create the wasm memory. (Note: this only applies if IMPORTED_MEMORY is defined)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_MEMORY / 65536,
      'maximum': INITIAL_MEMORY / 65536
    });
  }

if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);

// end include: runtime_init_memory.js

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// end include: runtime_stack_check.js
// include: runtime_assertions.js


// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;

function keepRuntimeAlive() {
  return noExitRuntime;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  {
    if (Module['onAbort']) {
      Module['onAbort'](what);
    }
  }

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what += '. Build with -sASSERTIONS for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // defintion for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
var wasmBinaryFile;
  wasmBinaryFile = 'sql-asm.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    var binary = tryParseAsDataURI(file);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(file);
    }
    throw "both async and sync fetching of the wasm failed";
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch == 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    Module['asm'] = exports;

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');

  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(function (instance) {
      return instance;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming == 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        // Avoid instantiateStreaming() on Node.js environment for now, as while
        // Node.js v18.1.0 implements it, it does not have a full fetch()
        // implementation yet.
        //
        // Reference:
        //   https://github.com/emscripten-core/emscripten/pull/16917
        !ENVIRONMENT_IS_NODE &&
        typeof fetch == 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        // Suppress closure warning here since the upstream definition for
        // instantiateStreaming only allows Promise<Repsponse> rather than
        // an actual Response.
        // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.
        /** @suppress {checkTypes} */
        var result = WebAssembly.instantiateStreaming(response, info);

        return result.then(
          receiveInstantiationResult,
          function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  // Also pthreads and wasm workers initialize the wasm instance through this path.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};






  /** @constructor */
  function ExitStatus(status) {
      this.name = 'ExitStatus';
      this.message = 'Program terminated with exit(' + status + ')';
      this.status = status;
    }

  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    }

  function withStackSave(f) {
      var stack = stackSave();
      var ret = f();
      stackRestore(stack);
      return ret;
    }
  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  
    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': return HEAP8[((ptr)>>0)];
        case 'i8': return HEAP8[((ptr)>>0)];
        case 'i16': return HEAP16[((ptr)>>1)];
        case 'i32': return HEAP32[((ptr)>>2)];
        case 'i64': return HEAP32[((ptr)>>2)];
        case 'float': return HEAPF32[((ptr)>>2)];
        case 'double': return HEAPF64[((ptr)>>3)];
        case '*': return HEAPU32[((ptr)>>2)];
        default: abort('invalid type for getValue: ' + type);
      }
      return null;
    }

  function handleException(e) {
      // Certain exception types we do not treat as errors since they are used for
      // internal control flow.
      // 1. ExitStatus, which is thrown by exit()
      // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
      //    that wish to return to JS event loop.
      if (e instanceof ExitStatus || e == 'unwind') {
        return EXITSTATUS;
      }
      quit_(1, e);
    }

  function intArrayToString(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      var chr = array[i];
      if (chr > 0xFF) {
        if (ASSERTIONS) {
          assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
        }
        chr &= 0xFF;
      }
      ret.push(String.fromCharCode(chr));
    }
    return ret.join('');
  }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only
        // populated if an Error object is thrown, so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  
    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
      if (type.endsWith('*')) type = '*';
      switch (type) {
        case 'i1': HEAP8[((ptr)>>0)] = value; break;
        case 'i8': HEAP8[((ptr)>>0)] = value; break;
        case 'i16': HEAP16[((ptr)>>1)] = value; break;
        case 'i32': HEAP32[((ptr)>>2)] = value; break;
        case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
        case 'float': HEAPF32[((ptr)>>2)] = value; break;
        case 'double': HEAPF64[((ptr)>>3)] = value; break;
        case '*': HEAPU32[((ptr)>>2)] = value; break;
        default: abort('invalid type for setValue: ' + type);
      }
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function writeArrayToMemory(array, buffer) {
      HEAP8.set(array, buffer);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }

  var PATH = {isAbs:(path) => path.charAt(0) === '/',splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:(path) => {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },join:function() {
        var paths = Array.prototype.slice.call(arguments);
        return PATH.normalize(paths.join('/'));
      },join2:(l, r) => {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto == 'object' && typeof crypto['getRandomValues'] == 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return () => { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          // nodejs has crypto support
          return () => crypto_module['randomBytes'](1)[0];
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return () => abort("randomDevice");
    }
  
  var PATH_FS = {resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:(from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  /** @type {function(string, boolean=, number=)} */
  function intArrayFromString(stringy, dontAddNull, length) {
    var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
    var u8array = new Array(len);
    var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
    if (dontAddNull) u8array.length = numBytesWritten;
    return u8array;
  }
  var TTY = {ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.fsync(stream.tty);
        },fsync:function(stream) {
          stream.tty.ops.fsync(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = fs.readSync(process.stdin.fd, buf, 0, BUFSIZE, -1);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().includes('EOF')) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },fsync:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
      return address;
    }
  
  function alignMemory(size, alignment) {
      return Math.ceil(size / alignment) * alignment;
    }
  function mmapAlloc(size) {
      size = alignMemory(size, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size);
      if (!ptr) return 0;
      return zeroMemory(ptr, size);
    }
  var MEMFS = {ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  /** @param {boolean=} noRunDep */
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, (arrayBuffer) => {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, (event) => {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  var FS = {root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path, opts = {}) => {
        path = PATH_FS.resolve(FS.cwd(), path);
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        opts = Object.assign(defaults, opts)
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter((p) => !!p), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:(node) => {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:(parentid, name) => {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:(node) => {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:(parent, name) => {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:(parent, name, mode, rdev) => {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:(node) => {
        FS.hashRemoveNode(node);
      },isRoot:(node) => {
        return node === node.parent;
      },isMountpoint:(node) => {
        return !!node.mounted;
      },isFile:(mode) => {
        return (mode & 61440) === 32768;
      },isDir:(mode) => {
        return (mode & 61440) === 16384;
      },isLink:(mode) => {
        return (mode & 61440) === 40960;
      },isChrdev:(mode) => {
        return (mode & 61440) === 8192;
      },isBlkdev:(mode) => {
        return (mode & 61440) === 24576;
      },isFIFO:(mode) => {
        return (mode & 61440) === 4096;
      },isSocket:(mode) => {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:(str) => {
        var flags = FS.flagModes[str];
        if (typeof flags == 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:(flag) => {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:(node, perms) => {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:(dir) => {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:(dir, name) => {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:(dir, name, isdir) => {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:(node, flags) => {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:(fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:(fd) => FS.streams[fd],createStream:(stream, fd_start, fd_end) => {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function() {
            this.shared = { };
          };
          FS.FSStream.prototype = {};
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              /** @this {FS.FSStream} */
              get: function() { return this.node; },
              /** @this {FS.FSStream} */
              set: function(val) { this.node = val; }
            },
            isRead: {
              /** @this {FS.FSStream} */
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              /** @this {FS.FSStream} */
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              /** @this {FS.FSStream} */
              get: function() { return (this.flags & 1024); }
            },
            flags: {
              /** @this {FS.FSStream} */
              get: function() { return this.shared.flags; },
              /** @this {FS.FSStream} */
              set: function(val) { this.shared.flags = val; },
            },
            position : {
              /** @this {FS.FSStream} */
              get: function() { return this.shared.position; },
              /** @this {FS.FSStream} */
              set: function(val) { this.shared.position = val; },
            },
          });
        }
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:(fd) => {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:(stream) => {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:() => {
          throw new FS.ErrnoError(70);
        }},major:(dev) => ((dev) >> 8),minor:(dev) => ((dev) & 0xff),makedev:(ma, mi) => ((ma) << 8 | (mi)),registerDevice:(dev, ops) => {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:(dev) => FS.devices[dev],getMounts:(mount) => {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:(populate, callback) => {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:(type, opts, mountpoint) => {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:(mountpoint) => {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:(parent, name) => {
        return parent.node_ops.lookup(parent, name);
      },mknod:(path, mode, dev) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:(path, mode) => {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:(path, mode) => {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:(path, mode) => {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:(path, mode, dev) => {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:(oldpath, newpath) => {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:(old_path, new_path) => {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:(path) => {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:(path) => {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:(path, dontFollow) => {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:(path) => {
        return FS.stat(path, true);
      },chmod:(path, mode, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:(path, mode) => {
        FS.chmod(path, mode, true);
      },fchmod:(fd, mode) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:(path, uid, gid, dontFollow) => {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:(path, uid, gid) => {
        FS.chown(path, uid, gid, true);
      },fchown:(fd, uid, gid) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:(path, len) => {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:(fd, len) => {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:(path, atime, mtime) => {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:(path, flags, mode) => {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },close:(stream) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:(stream) => {
        return stream.fd === null;
      },llseek:(stream, offset, whence) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:(stream, buffer, offset, length, position) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:(stream, buffer, offset, length, position, canOwn) => {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:(stream, offset, length) => {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:(stream, length, position, prot, flags) => {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },msync:(stream, buffer, offset, length, mmapFlags) => {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:(stream) => 0,ioctl:(stream, cmd, arg) => {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:(path, opts = {}) => {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:(path, data, opts = {}) => {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:() => FS.currentPath,chdir:(path) => {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:() => {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:() => {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:() => {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: () => {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: (parent, name) => {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:() => {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:() => {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach((code) => {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:() => {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:(input, output, error) => {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:() => {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:(canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:(path, dontResolveLastLink) => {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },analyzePath:(path, dontResolveLastLink) => {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:(parent, path, canRead, canWrite) => {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:(parent, name, properties, canRead, canWrite) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:(parent, name, data, canRead, canWrite, canOwn) => {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:(parent, name, input, output) => {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: (stream) => {
            stream.seekable = false;
          },
          close: (stream) => {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: (stream, buffer, offset, length, pos /* ignored */) => {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: (stream, buffer, offset, length, pos) => {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:(obj) => {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:(parent, name, url, canRead, canWrite) => {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            }
            return intArrayFromString(xhr.responseText || '', true);
          };
          var lazyArray = this;
          lazyArray.setDataGetter((chunkNum) => {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        // use a custom mmap function
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr: ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
            if (onerror) onerror();
            removeRunDependency(dep);
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, (byteArray) => processData(byteArray), onerror);
        } else {
          processData(url);
        }
      },indexedDB:() => {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:() => {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = () => {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = () => { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:(paths, onload, onerror) => {
        onload = onload || (() => {});
        onerror = onerror || (() => {});
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = () => {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach((path) => {
            var getRequest = files.get(path);
            getRequest.onsuccess = () => {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = () => { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS = {DEFAULT_POLLMASK:5,calculateAt:function(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAPU32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        (tempI64 = [Math.floor(stat.atime.getTime() / 1000)>>>0,(tempDouble=Math.floor(stat.atime.getTime() / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(64))>>2)] = 0;
        (tempI64 = [Math.floor(stat.mtime.getTime() / 1000)>>>0,(tempDouble=Math.floor(stat.mtime.getTime() / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(80))>>2)] = 0;
        (tempI64 = [Math.floor(stat.ctime.getTime() / 1000)>>>0,(tempDouble=Math.floor(stat.ctime.getTime() / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(96))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(104))>>2)] = tempI64[0],HEAP32[(((buf)+(108))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      }};
  function ___syscall_chmod(path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.chmod(path, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_faccessat(dirfd, path, amode, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (amode & ~7) {
        // need a valid mode
        return -28;
      }
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node) {
        return -44;
      }
      var perms = '';
      if (amode & 4) perms += 'r';
      if (amode & 2) perms += 'w';
      if (amode & 1) perms += 'x';
      if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
        return -2;
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchmod(fd, mode) {
  try {
  
      FS.fchmod(fd, mode);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fchown32(fd, owner, group) {
  try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  function ___syscall_fcntl64(fd, cmd, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.createStream(stream, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 5:
        /* case 5: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 6:
        case 7:
        /* case 6: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 7: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fcntl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_fstat64(fd, buf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function convertI32PairToI53Checked(lo, hi) {
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    }
  function ___syscall_ftruncate64(fd, length_low, length_high) {
  try {
  
      var length = convertI32PairToI53Checked(length_low, length_high); if (isNaN(length)) return -61;
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_getcwd(buf, size) {
  try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
      if (size < cwdLengthInBytes) return -68;
      stringToUTF8(cwd, buf, size);
      return cwdLengthInBytes;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_lstat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_mkdirat(dirfd, path, mode) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      // remove a trailing slash, if one - /a/b/ has basename of '', but
      // we want to create b in the context of this function
      path = PATH.normalize(path);
      if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
      FS.mkdir(path, mode, 0);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_newfstatat(dirfd, path, buf, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      var nofollow = flags & 256;
      var allowEmpty = flags & 4096;
      flags = flags & (~4352);
      path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
      return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_openat(dirfd, path, flags, varargs) {
  SYSCALLS.varargs = varargs;
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      var mode = varargs ? SYSCALLS.get() : 0;
      return FS.open(path, flags, mode).fd;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (bufsize <= 0) return -28;
      var ret = FS.readlink(path);
  
      var len = Math.min(bufsize, lengthBytesUTF8(ret));
      var endChar = HEAP8[buf+len];
      stringToUTF8(ret, buf, bufsize+1);
      // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
      // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
      HEAP8[buf+len] = endChar;
      return len;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_rmdir(path) {
  try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_stat64(path, buf) {
  try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function ___syscall_unlinkat(dirfd, path, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path);
      if (flags === 0) {
        FS.unlink(path);
      } else if (flags === 512) {
        FS.rmdir(path);
      } else {
        abort('Invalid flags passed to unlinkat');
      }
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function readI53FromI64(ptr) {
      return HEAPU32[ptr>>2] + HEAP32[ptr+4>>2] * 4294967296;
    }
  function ___syscall_utimensat(dirfd, path, times, flags) {
  try {
  
      path = SYSCALLS.getStr(path);
      path = SYSCALLS.calculateAt(dirfd, path, true);
      if (!times) {
        var atime = Date.now();
        var mtime = atime;
      } else {
        var seconds = readI53FromI64(times);
        var nanoseconds = HEAP32[(((times)+(8))>>2)];
        atime = (seconds*1000) + (nanoseconds/(1000*1000));
        times += 16;
        seconds = readI53FromI64(times);
        nanoseconds = HEAP32[(((times)+(8))>>2)];
        mtime = (seconds*1000) + (nanoseconds/(1000*1000));
      }
      FS.utime(path, atime, mtime);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function __emscripten_date_now() {
      return Date.now();
    }

  function __localtime_js(time, tmPtr) {
      var date = new Date(readI53FromI64(time)*1000);
      HEAP32[((tmPtr)>>2)] = date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)] = date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)] = date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)] = date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)] = date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)] = date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)] = date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)] = yday;
      HEAP32[(((tmPtr)+(36))>>2)] = -(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)] = dst;
    }

  function __mmap_js(len, prot, flags, fd, off, allocated) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var res = FS.mmap(stream, len, off, prot, flags);
      var ptr = res.ptr;
      HEAP32[((allocated)>>2)] = res.allocated;
      return ptr;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function __munmap_js(addr, len, prot, flags, fd, offset) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (prot & 2) {
        SYSCALLS.doMsync(addr, stream, len, flags, offset);
      }
      FS.munmap(stream);
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return -e.errno;
  }
  }

  function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = _malloc(size);
      if (ret) stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }
  function _tzset_impl(timezone, daylight, tzname) {
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
  
      // Local standard timezone offset. Local standard time is not adjusted for daylight savings.
      // This code uses the fact that getTimezoneOffset returns a greater value during Standard Time versus Daylight Saving Time (DST).
      // Thus it determines the expected output during Standard Time, and it compares whether the output of the given date the same (Standard) or less (DST).
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by stdTimezoneOffset.
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((timezone)>>2)] = stdTimezoneOffset * 60;
  
      HEAP32[((daylight)>>2)] = Number(winterOffset != summerOffset);
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summerOffset < winterOffset) {
        // Northern hemisphere
        HEAPU32[((tzname)>>2)] = winterNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = summerNamePtr;
      } else {
        HEAPU32[((tzname)>>2)] = summerNamePtr;
        HEAPU32[(((tzname)+(4))>>2)] = winterNamePtr;
      }
    }
  function __tzset_js(timezone, daylight, tzname) {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (__tzset_js.called) return;
      __tzset_js.called = true;
      _tzset_impl(timezone, daylight, tzname);
    }

  function getHeapMax() {
      return HEAPU8.length;
    }
  function _emscripten_get_heap_max() {
      return getHeapMax();
    }

  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = () => {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else _emscripten_get_now = () => performance.now();
  ;

  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }

  var ENV = {};
  
  function getExecutableName() {
      return thisProgram || './this.program';
    }
  function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        // Browser language detection #8751
        var lang = ((typeof navigator == 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8';
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          'LANG': lang,
          '_': getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          // x is a key in ENV; if ENV[x] is undefined, that means it was
          // explicitly set to be so. We allow user code to do that to
          // force variables with default values to remain unset.
          if (ENV[x] === undefined) delete env[x];
          else env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }
  
  /** @param {boolean=} dontAddNull */
  function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
      }
      // Null-terminate the pointer to the HEAP.
      if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
    }
  function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAPU32[(((__environ)+(i*4))>>2)] = ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAPU32[((penviron_count)>>2)] = strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAPU32[((penviron_buf_size)>>2)] = bufSize;
      return 0;
    }

  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)] = type;
      // TODO HEAP16[(((pbuf)+(2))>>1)] = ?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)] = tempI64[0],HEAP32[(((pbuf)+(12))>>2)] = tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)] = tempI64[0],HEAP32[(((pbuf)+(20))>>2)] = tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  function doReadv(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
      }
      return ret;
    }
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
  try {
  
      var offset = convertI32PairToI53Checked(offset_low, offset_high); if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function _fd_sync(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      if (stream.stream_ops && stream.stream_ops.fsync) {
        return stream.stream_ops.fsync(stream);
      }
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  function doWritev(stream, iov, iovcnt, offset) {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8,ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
      }
      return ret;
    }
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
    return e.errno;
  }
  }

  function uleb128Encode(n, target) {
      if (n < 128) {
        target.push(n);
      } else {
        target.push((n % 128) | 128, n >> 7);
      }
    }
  
  function sigToWasmTypes(sig) {
      var typeNames = {
        'i': 'i32',
        'j': 'i64',
        'f': 'f32',
        'd': 'f64',
        'p': 'i32',
      };
      var type = {
        parameters: [],
        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
      };
      for (var i = 1; i < sig.length; ++i) {
        type.parameters.push(typeNames[sig[i]]);
      }
      return type;
    }
  function convertJsFunctionToWasm(func, sig) {
      return func;
    }
  
  function getWasmTableEntry(funcPtr) {
      // In -Os and -Oz builds, do not implement a JS side wasm table mirror for small
      // code size, but directly access wasmTable, which is a bit slower as uncached.
      return wasmTable.get(funcPtr);
    }
  function updateTableMap(offset, count) {
      if (functionsInTableMap) {
        for (var i = offset; i < offset + count; i++) {
          var item = getWasmTableEntry(i);
          // Ignore null values.
          if (item) {
            functionsInTableMap.set(item, i);
          }
        }
      }
    }
  
  var functionsInTableMap = undefined;
  
  var freeTableIndexes = [];
  function getEmptyTableSlot() {
      // Reuse a free index if there is one, otherwise grow.
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      // Grow the table
      try {
        wasmTable.grow(1);
      } catch (err) {
        if (!(err instanceof RangeError)) {
          throw err;
        }
        throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
      }
      return wasmTable.length - 1;
    }
  
  function setWasmTableEntry(idx, func) {
      wasmTable.set(idx, func);
    }
  /** @param {string=} sig */
  function addFunction(func, sig) {
  
      // Check if the function is already in the table, to ensure each function
      // gets a unique index. First, create the map if this is the first use.
      if (!functionsInTableMap) {
        functionsInTableMap = new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      if (functionsInTableMap.has(func)) {
        return functionsInTableMap.get(func);
      }
  
      // It's not in the table, add it now.
  
      var ret = getEmptyTableSlot();
  
      // Set the new value.
      try {
        // Attempting to call this with JS function will cause of table.set() to fail
        setWasmTableEntry(ret, func);
      } catch (err) {
        if (!(err instanceof TypeError)) {
          throw err;
        }
        var wrapped = convertJsFunctionToWasm(func, sig);
        setWasmTableEntry(ret, wrapped);
      }
  
      functionsInTableMap.set(func, ret);
  
      return ret;
    }

  function removeFunction(index) {
      functionsInTableMap.delete(getWasmTableEntry(index));
      freeTableIndexes.push(index);
    }

  var ALLOC_NORMAL = 0;
  
  var ALLOC_STACK = 1;
  function allocate(slab, allocator) {
      var ret;
  
      if (allocator == ALLOC_STACK) {
        ret = stackAlloc(slab.length);
      } else {
        ret = _malloc(slab.length);
      }
  
      if (!slab.subarray && !slab.slice) {
        slab = new Uint8Array(slab);
      }
      HEAPU8.set(slab, ret);
      return ret;
    }



  function AsciiToString(ptr) {
      var str = '';
      while (1) {
        var ch = HEAPU8[((ptr++)>>0)];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    }

  function stringToAscii(str, outPtr) {
      return writeAsciiToMemory(str, outPtr, false);
    }

  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;;
  function UTF16ToString(ptr, maxBytesToRead) {
      var endPtr = ptr;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
      // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
      var idx = endPtr >> 1;
      var maxIdx = idx + maxBytesToRead / 2;
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
      endPtr = idx << 1;
  
      if (endPtr - ptr > 32 && UTF16Decoder) {
        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
      } else {
        var str = '';
  
        // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
        // will always evaluate to true. The loop is then terminated on the first null char.
        for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
          var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
          if (codeUnit == 0) break;
          // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
          str += String.fromCharCode(codeUnit);
        }
  
        return str;
      }
    }

  function stringToUTF16(str, outPtr, maxBytesToWrite) {
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      if (maxBytesToWrite === undefined) {
        maxBytesToWrite = 0x7FFFFFFF;
      }
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2; // Null terminator.
      var startPtr = outPtr;
      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        HEAP16[((outPtr)>>1)] = codeUnit;
        outPtr += 2;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP16[((outPtr)>>1)] = 0;
      return outPtr - startPtr;
    }

  function lengthBytesUTF16(str) {
      return str.length*2;
    }

  function UTF32ToString(ptr, maxBytesToRead) {
      var i = 0;
  
      var str = '';
      // If maxBytesToRead is not passed explicitly, it will be undefined, and this
      // will always evaluate to true. This saves on code size.
      while (!(i >= maxBytesToRead / 4)) {
        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
        if (utf32 == 0) break;
        ++i;
        // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        if (utf32 >= 0x10000) {
          var ch = utf32 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        } else {
          str += String.fromCharCode(utf32);
        }
      }
      return str;
    }

  function stringToUTF32(str, outPtr, maxBytesToWrite) {
      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
      if (maxBytesToWrite === undefined) {
        maxBytesToWrite = 0x7FFFFFFF;
      }
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
          var trailSurrogate = str.charCodeAt(++i);
          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
        }
        HEAP32[((outPtr)>>2)] = codeUnit;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      // Null-terminate the pointer to the HEAP.
      HEAP32[((outPtr)>>2)] = 0;
      return outPtr - startPtr;
    }

  function lengthBytesUTF32(str) {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
        len += 4;
      }
  
      return len;
    }


  function allocateUTF8OnStack(str) {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8Array(str, HEAP8, ret, size);
      return ret;
    }

  /** @deprecated @param {boolean=} dontAddNull */
  function writeStringToMemory(string, buffer, dontAddNull) {
      warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');
  
      var /** @type {number} */ lastChar, /** @type {number} */ end;
      if (dontAddNull) {
        // stringToUTF8Array always appends null. If we don't want to do that, remember the
        // character that existed at the location where the null will be placed, and restore
        // that after the write (below).
        end = buffer + lengthBytesUTF8(string);
        lastChar = HEAP8[end];
      }
      stringToUTF8(string, buffer, Infinity);
      if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
    }





  function warnOnce(text) {
      if (!warnOnce.shown) warnOnce.shown = {};
      if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;
        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;
        err(text);
      }
    }

  function getCFunc(ident) {
      var func = Module['_' + ident]; // closure exported function
      return func;
    }
  
    /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */
  function ccall(ident, returnType, argTypes, args, opts) {
      // For fast lookup of conversion functions
      var toC = {
        'string': (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) { // null string
            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
            var len = (str.length << 2) + 1;
            ret = stackAlloc(len);
            stringToUTF8(str, ret, len);
          }
          return ret;
        },
        'array': (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }
      };
  
      function convertReturnValue(ret) {
        if (returnType === 'string') {
          
          return UTF8ToString(ret);
        }
        if (returnType === 'boolean') return Boolean(ret);
        return ret;
      }
  
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func.apply(null, cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }
  
      ret = onDone(ret);
      return ret;
    }

  
    /**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */
  function cwrap(ident, returnType, argTypes, opts) {
      argTypes = argTypes || [];
      // When the function takes numbers and returns a number, we can just return
      // the original function
      var numericArgs = argTypes.every((type) => type === 'number' || type === 'boolean');
      var numericRet = returnType !== 'string';
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return function() {
        return ccall(ident, returnType, argTypes, arguments, opts);
      }
    }



  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
var ASSERTIONS = false;

// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob == 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE == 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf = Buffer.from(s, 'base64');
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


var asmLibraryArg = {
  "__assert_fail": ___assert_fail,
  "__syscall_chmod": ___syscall_chmod,
  "__syscall_faccessat": ___syscall_faccessat,
  "__syscall_fchmod": ___syscall_fchmod,
  "__syscall_fchown32": ___syscall_fchown32,
  "__syscall_fcntl64": ___syscall_fcntl64,
  "__syscall_fstat64": ___syscall_fstat64,
  "__syscall_ftruncate64": ___syscall_ftruncate64,
  "__syscall_getcwd": ___syscall_getcwd,
  "__syscall_lstat64": ___syscall_lstat64,
  "__syscall_mkdirat": ___syscall_mkdirat,
  "__syscall_newfstatat": ___syscall_newfstatat,
  "__syscall_openat": ___syscall_openat,
  "__syscall_readlinkat": ___syscall_readlinkat,
  "__syscall_rmdir": ___syscall_rmdir,
  "__syscall_stat64": ___syscall_stat64,
  "__syscall_unlinkat": ___syscall_unlinkat,
  "__syscall_utimensat": ___syscall_utimensat,
  "_emscripten_date_now": __emscripten_date_now,
  "_localtime_js": __localtime_js,
  "_mmap_js": __mmap_js,
  "_munmap_js": __munmap_js,
  "_tzset_js": __tzset_js,
  "emscripten_get_heap_max": _emscripten_get_heap_max,
  "emscripten_get_now": _emscripten_get_now,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "environ_get": _environ_get,
  "environ_sizes_get": _environ_sizes_get,
  "fd_close": _fd_close,
  "fd_fdstat_get": _fd_fdstat_get,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_sync": _fd_sync,
  "fd_write": _fd_write,
  "memory": wasmMemory
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_free = Module["_sqlite3_free"] = function() {
  return (_sqlite3_free = Module["_sqlite3_free"] = Module["asm"]["sqlite3_free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_value_double = Module["_sqlite3_value_double"] = function() {
  return (_sqlite3_value_double = Module["_sqlite3_value_double"] = Module["asm"]["sqlite3_value_double"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_value_text = Module["_sqlite3_value_text"] = function() {
  return (_sqlite3_value_text = Module["_sqlite3_value_text"] = Module["asm"]["sqlite3_value_text"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = function() {
  return (_sqlite3_prepare_v2 = Module["_sqlite3_prepare_v2"] = Module["asm"]["sqlite3_prepare_v2"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_step = Module["_sqlite3_step"] = function() {
  return (_sqlite3_step = Module["_sqlite3_step"] = Module["asm"]["sqlite3_step"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_finalize = Module["_sqlite3_finalize"] = function() {
  return (_sqlite3_finalize = Module["_sqlite3_finalize"] = Module["asm"]["sqlite3_finalize"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_reset = Module["_sqlite3_reset"] = function() {
  return (_sqlite3_reset = Module["_sqlite3_reset"] = Module["asm"]["sqlite3_reset"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_value_int = Module["_sqlite3_value_int"] = function() {
  return (_sqlite3_value_int = Module["_sqlite3_value_int"] = Module["asm"]["sqlite3_value_int"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = function() {
  return (_sqlite3_clear_bindings = Module["_sqlite3_clear_bindings"] = Module["asm"]["sqlite3_clear_bindings"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_value_blob = Module["_sqlite3_value_blob"] = function() {
  return (_sqlite3_value_blob = Module["_sqlite3_value_blob"] = Module["asm"]["sqlite3_value_blob"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = function() {
  return (_sqlite3_value_bytes = Module["_sqlite3_value_bytes"] = Module["asm"]["sqlite3_value_bytes"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_value_type = Module["_sqlite3_value_type"] = function() {
  return (_sqlite3_value_type = Module["_sqlite3_value_type"] = Module["asm"]["sqlite3_value_type"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_blob = Module["_sqlite3_result_blob"] = function() {
  return (_sqlite3_result_blob = Module["_sqlite3_result_blob"] = Module["asm"]["sqlite3_result_blob"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_double = Module["_sqlite3_result_double"] = function() {
  return (_sqlite3_result_double = Module["_sqlite3_result_double"] = Module["asm"]["sqlite3_result_double"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_error = Module["_sqlite3_result_error"] = function() {
  return (_sqlite3_result_error = Module["_sqlite3_result_error"] = Module["asm"]["sqlite3_result_error"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_int = Module["_sqlite3_result_int"] = function() {
  return (_sqlite3_result_int = Module["_sqlite3_result_int"] = Module["asm"]["sqlite3_result_int"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_int64 = Module["_sqlite3_result_int64"] = function() {
  return (_sqlite3_result_int64 = Module["_sqlite3_result_int64"] = Module["asm"]["sqlite3_result_int64"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_null = Module["_sqlite3_result_null"] = function() {
  return (_sqlite3_result_null = Module["_sqlite3_result_null"] = Module["asm"]["sqlite3_result_null"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_result_text = Module["_sqlite3_result_text"] = function() {
  return (_sqlite3_result_text = Module["_sqlite3_result_text"] = Module["asm"]["sqlite3_result_text"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_sql = Module["_sqlite3_sql"] = function() {
  return (_sqlite3_sql = Module["_sqlite3_sql"] = Module["asm"]["sqlite3_sql"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = function() {
  return (_sqlite3_aggregate_context = Module["_sqlite3_aggregate_context"] = Module["asm"]["sqlite3_aggregate_context"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_count = Module["_sqlite3_column_count"] = function() {
  return (_sqlite3_column_count = Module["_sqlite3_column_count"] = Module["asm"]["sqlite3_column_count"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_data_count = Module["_sqlite3_data_count"] = function() {
  return (_sqlite3_data_count = Module["_sqlite3_data_count"] = Module["asm"]["sqlite3_data_count"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_blob = Module["_sqlite3_column_blob"] = function() {
  return (_sqlite3_column_blob = Module["_sqlite3_column_blob"] = Module["asm"]["sqlite3_column_blob"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = function() {
  return (_sqlite3_column_bytes = Module["_sqlite3_column_bytes"] = Module["asm"]["sqlite3_column_bytes"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_double = Module["_sqlite3_column_double"] = function() {
  return (_sqlite3_column_double = Module["_sqlite3_column_double"] = Module["asm"]["sqlite3_column_double"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_text = Module["_sqlite3_column_text"] = function() {
  return (_sqlite3_column_text = Module["_sqlite3_column_text"] = Module["asm"]["sqlite3_column_text"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_type = Module["_sqlite3_column_type"] = function() {
  return (_sqlite3_column_type = Module["_sqlite3_column_type"] = Module["asm"]["sqlite3_column_type"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_column_name = Module["_sqlite3_column_name"] = function() {
  return (_sqlite3_column_name = Module["_sqlite3_column_name"] = Module["asm"]["sqlite3_column_name"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = function() {
  return (_sqlite3_bind_blob = Module["_sqlite3_bind_blob"] = Module["asm"]["sqlite3_bind_blob"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_bind_double = Module["_sqlite3_bind_double"] = function() {
  return (_sqlite3_bind_double = Module["_sqlite3_bind_double"] = Module["asm"]["sqlite3_bind_double"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_bind_int = Module["_sqlite3_bind_int"] = function() {
  return (_sqlite3_bind_int = Module["_sqlite3_bind_int"] = Module["asm"]["sqlite3_bind_int"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_bind_text = Module["_sqlite3_bind_text"] = function() {
  return (_sqlite3_bind_text = Module["_sqlite3_bind_text"] = Module["asm"]["sqlite3_bind_text"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = function() {
  return (_sqlite3_bind_parameter_index = Module["_sqlite3_bind_parameter_index"] = Module["asm"]["sqlite3_bind_parameter_index"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_normalized_sql = Module["_sqlite3_normalized_sql"] = function() {
  return (_sqlite3_normalized_sql = Module["_sqlite3_normalized_sql"] = Module["asm"]["sqlite3_normalized_sql"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_errmsg = Module["_sqlite3_errmsg"] = function() {
  return (_sqlite3_errmsg = Module["_sqlite3_errmsg"] = Module["asm"]["sqlite3_errmsg"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_exec = Module["_sqlite3_exec"] = function() {
  return (_sqlite3_exec = Module["_sqlite3_exec"] = Module["asm"]["sqlite3_exec"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_changes = Module["_sqlite3_changes"] = function() {
  return (_sqlite3_changes = Module["_sqlite3_changes"] = Module["asm"]["sqlite3_changes"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_close_v2 = Module["_sqlite3_close_v2"] = function() {
  return (_sqlite3_close_v2 = Module["_sqlite3_close_v2"] = Module["asm"]["sqlite3_close_v2"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = function() {
  return (_sqlite3_create_function_v2 = Module["_sqlite3_create_function_v2"] = Module["asm"]["sqlite3_create_function_v2"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_open = Module["_sqlite3_open"] = function() {
  return (_sqlite3_open = Module["_sqlite3_open"] = Module["asm"]["sqlite3_open"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _sqlite3_series_init = Module["_sqlite3_series_init"] = function() {
  return (_sqlite3_series_init = Module["_sqlite3_series_init"] = Module["asm"]["sqlite3_series_init"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _RegisterExtensionFunctions = Module["_RegisterExtensionFunctions"] = function() {
  return (_RegisterExtensionFunctions = Module["_RegisterExtensionFunctions"] = Module["asm"]["RegisterExtensionFunctions"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
  return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["emscripten_builtin_memalign"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var setTempRet0 = Module["setTempRet0"] = function() {
  return (setTempRet0 = Module["setTempRet0"] = Module["asm"]["setTempRet0"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var getTempRet0 = Module["getTempRet0"] = function() {
  return (getTempRet0 = Module["getTempRet0"] = Module["asm"]["getTempRet0"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiij = Module["dynCall_iiiij"] = function() {
  return (dynCall_iiiij = Module["dynCall_iiiij"] = Module["asm"]["dynCall_iiiij"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iij = Module["dynCall_iij"] = function() {
  return (dynCall_iij = Module["dynCall_iij"] = Module["asm"]["dynCall_iij"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iijii = Module["dynCall_iijii"] = function() {
  return (dynCall_iijii = Module["dynCall_iijii"] = Module["asm"]["dynCall_iijii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiji = Module["dynCall_iiji"] = function() {
  return (dynCall_iiji = Module["dynCall_iiji"] = Module["asm"]["dynCall_iiji"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiiij = Module["dynCall_iiiiiij"] = function() {
  return (dynCall_iiiiiij = Module["dynCall_iiiiiij"] = Module["asm"]["dynCall_iiiiiij"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viji = Module["dynCall_viji"] = function() {
  return (dynCall_viji = Module["dynCall_viji"] = Module["asm"]["dynCall_viji"]).apply(null, arguments);
};





// === Auto-generated postamble setup entry stuff ===

Module["UTF8ToString"] = UTF8ToString;
Module["stackAlloc"] = stackAlloc;
Module["stackSave"] = stackSave;
Module["stackRestore"] = stackRestore;
Module["cwrap"] = cwrap;


var calledRun;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();







        // The shell-pre.js and emcc-generated code goes above
        return Module;
    }); // The end of the promise being returned

  return initSqlJsPromise;
} // The end of our initSqlJs function

// This bit below is copied almost exactly from what you get when you use the MODULARIZE=1 flag with emcc
// However, we don't want to use the emcc modularization. See shell-pre.js
if (typeof exports === 'object' && typeof module === 'object'){
    module.exports = initSqlJs;
    // This will allow the module to be used in ES6 or CommonJS
    module.exports.default = initSqlJs;
}
else if (typeof define === 'function' && define['amd']) {
    define([], function() { return initSqlJs; });
}
else if (typeof exports === 'object'){
    exports["Module"] = initSqlJs;
}
/* global initSqlJs */
/* eslint-env worker */
/* eslint no-restricted-globals: ["error"] */

"use strict";

var db;

function onModuleReady(SQL) {
    function createDb(data) {
        if (db != null) db.close();
        db = new SQL.Database(data);
        return db;
    }

    var buff; var data; var result;
    data = this["data"];
    var config = data["config"] ? data["config"] : {};
    switch (data && data["action"]) {
        case "open":
            buff = data["buffer"];
            createDb(buff && new Uint8Array(buff));
            return postMessage({
                id: data["id"],
                ready: true
            });
        case "exec":
            if (db === null) {
                createDb();
            }
            if (!data["sql"]) {
                throw "exec: Missing query string";
            }
            return postMessage({
                id: data["id"],
                results: db.exec(data["sql"], data["params"], config)
            });
        case "each":
            if (db === null) {
                createDb();
            }
            var callback = function callback(row) {
                return postMessage({
                    id: data["id"],
                    row: row,
                    finished: false
                });
            };
            var done = function done() {
                return postMessage({
                    id: data["id"],
                    finished: true
                });
            };
            return db.each(data["sql"], data["params"], callback, done, config);
        case "export":
            buff = db["export"]();
            result = {
                id: data["id"],
                buffer: buff
            };
            try {
                return postMessage(result, [result]);
            } catch (error) {
                return postMessage(result);
            }
        case "close":
            if (db) {
                db.close();
            }
            return postMessage({
                id: data["id"]
            });
        default:
            throw new Error("Invalid action : " + (data && data["action"]));
    }
}

function onError(err) {
    return postMessage({
        id: this["data"]["id"],
        error: err["message"]
    });
}

if (typeof importScripts === "function") {
    db = null;
    var sqlModuleReady = initSqlJs();
    self.onmessage = function onmessage(event) {
        return sqlModuleReady
            .then(onModuleReady.bind(event))
            .catch(onError.bind(event));
    };
}
